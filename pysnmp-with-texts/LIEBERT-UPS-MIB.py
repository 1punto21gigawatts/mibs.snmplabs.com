#
# PySNMP MIB module LIEBERT-UPS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LIEBERT-UPS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysUpTime, = mibBuilder.importSymbols("SNMPv2-MIB", "sysUpTime")
Integer32, NotificationType, iso, Gauge32, Bits, ObjectIdentity, Counter64, NotificationType, Unsigned32, IpAddress, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, enterprises, TimeTicks, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "iso", "Gauge32", "Bits", "ObjectIdentity", "Counter64", "NotificationType", "Unsigned32", "IpAddress", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "enterprises", "TimeTicks", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
emerson = MibIdentifier((1, 3, 6, 1, 4, 1, 476))
liebertCorp = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1))
liebertUps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1))
luExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1))
luExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 2))
luPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 3))
luCore = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1))
lcUpsIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1))
lcUpsIdentManufacturer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setDescription('The UPS manufacturer.')
lcUpsIdentModel = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsIdentModel.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentModel.setDescription('The UPS Model designation.')
lcUpsIdentSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setDescription('The UPS SNMP Agent software version.')
lcUpsIdentSpecific = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSpecific.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSpecific.setDescription('A reference to MIB definitions specific to the particular UPS being managed. This object is used to locate the product-specific MIB for this device. If this information is not present, its value should be the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
lcUpsIdentFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentFirmwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentFirmwareVersion.setDescription('The firmware revision level of the UPS.')
lcUpsIdentSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(20, 20)).setFixedLength(20)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSerialNumber.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSerialNumber.setDescription('The serial number of the UPS.')
lcUpsIdentManufactureDate = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentManufactureDate.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentManufactureDate.setDescription('The date of manufacture of the UPS.')
lcUpsBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2))
lcUpsBatTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setDescription('The estimated time to depletion of battery charge. (Unit of measure: Minute)')
lcUpsBatTemperature = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTemperature.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTemperature.setDescription('The battery temperature. (Unit of measure: Degree, Centigrade)')
lcUpsBatVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatVoltage.setDescription('The current battery voltage. (Unit of measure: volt)')
lcUpsBatCurrent = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatCurrent.setDescription('The current battery discharging/charging current. (Unit of measure: Amp)')
lcUpsBatCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatCapacity.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatCapacity.setDescription('The current battery capacity in percentage of total available.')
lcUpsBatTotalDischCounts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTotalDischCounts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTotalDischCounts.setDescription('The number of discharges the UPS has experienced.')
lcUpsBatCycleDurationInSeconds = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatCycleDurationInSeconds.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatCycleDurationInSeconds.setDescription('The total accumulated discharge time in seconds.')
lcUpsBatAmpHours = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatAmpHours.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatAmpHours.setDescription('The number of amp hours withdrawn from battery.')
lcUpsBatKWhours = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatKWhours.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatKWhours.setDescription('The number of Kilowatt-hours withdrawn from battery.')
lcUpsBatWattHours = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatWattHours.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatWattHours.setDescription('The number of Watt-hours withdrawn from battery.')
lcUpsInput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3))
lcUpsInputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputFrequency.setDescription('The current input frequency. (Unit of measure: Hertz)')
lcUpsInputBrownOuts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputBrownOuts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputBrownOuts.setDescription('The number of brown-out conditions the UPS has experienced.')
lcUpsInputBlackOuts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputBlackOuts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputBlackOuts.setDescription('The number of black-out conditions the UPS has experienced.')
lcUpsInputTransients = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputTransients.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputTransients.setDescription('The number of transient (surge and spike) conditions the UPS has experienced.')
lcUpsInputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputNumLines.setDescription('The number of input lines utilized in this device. This entry indicates the number of rows in the input table.')
lcUpsInputTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6), )
if mibBuilder.loadTexts: lcUpsInputTable.setStatus('optional')
lcUpsInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1), ).setIndexNames((0, "LIEBERT-UPS-MIB", "lcUpsInputLine"))
if mibBuilder.loadTexts: lcUpsInputEntry.setStatus('optional')
lcUpsInputLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputLine.setDescription('The input Line.')
lcUpsInputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputVoltage.setDescription('The input voltage. (Unit of measure: Volt)')
lcUpsInputCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputCurrent.setDescription('The input current. (Unit of measure: Amp)')
lcUpsInputVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputVA.setDescription('The input volt-amps.')
lcUpsOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4))
lcUpsOutputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputFrequency.setDescription('The current output frequency. (Unit of measure: Hertz)')
lcUpsOutputLoad = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputLoad.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputLoad.setDescription('The current output load percentage.')
lcUpsOutputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputNumLines.setDescription('The number of output lines utilized in this device. This entry indicates the number of rows in the output table.')
lcUpsOutputTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4), )
if mibBuilder.loadTexts: lcUpsOutputTable.setStatus('optional')
lcUpsOutputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1), ).setIndexNames((0, "LIEBERT-UPS-MIB", "lcUpsOutputLine"))
if mibBuilder.loadTexts: lcUpsOutputEntry.setStatus('optional')
lcUpsOutputLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputLine.setDescription('The output Line.')
lcUpsOutputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputVoltage.setDescription('The output voltage. (Unit of measure: Volt)')
lcUpsOutputCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputCurrent.setDescription('The output current. (Unit of measure: Amp)')
lcUpsOutputVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputVA.setDescription('The output volt-amps.')
lcUpsOutputWatts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputWatts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputWatts.setDescription('The output power in watts.')
lcUpsInverter = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5))
lcUpsInverterStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInverterStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInverterStatus.setDescription('The state of the inverter. Unknown is returned if the state can not be determined.')
lcUpsInverterTemp = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInverterTemp.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInverterTemp.setDescription('The temperature of the inverter. (Unit of measure: degree, Centigrade)')
lcUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6))
lcUpsAlarms = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarms.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarms.setDescription('The current number of alarm conditions.')
lcUpsAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2), )
if mibBuilder.loadTexts: lcUpsAlarmTable.setStatus('optional')
lcUpsAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1), ).setIndexNames((0, "LIEBERT-UPS-MIB", "lcUpsAlarmId"))
if mibBuilder.loadTexts: lcUpsAlarmEntry.setStatus('optional')
lcUpsAlarmId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmId.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmId.setDescription('A unique identifier for an alarm condition. This value must remain constant between agent initializations.')
lcUpsAlarmDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmDescr.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmDescr.setDescription('A reference to an alarm description object. The object referenced should not be accessible, but rather be used to provide a unique description of the alarm condition.')
lcUpsAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmTime.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmTime.setDescription('The value of sysUpTime when the alarm condition occured.')
lcUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3))
lcUpsAlarmLowBatteryWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 1))
lcUpsAlarmLowBatteryShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 2))
lcUpsAlarmUtilFailed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 3))
lcUpsAlarmOverTempWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 4))
lcUpsAlarmOverTempShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 5))
lcUpsAlarmOutputOverloadWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 6))
lcUpsAlarmOutputOverloadShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 7))
lcUpsAlarmInputOverVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 8))
lcUpsAlarmBatteryBad = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 9))
lcUpsAlarmOnBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 10))
lcUpsAlarmStopNoticeIssued = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 11))
lcUpsAlarmUpsOff = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 12))
lcUpsAlarmInputFreqError = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 13))
lcUpsAlarmOutputUnderVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 15))
lcUpsAlarmOutputOverVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 16))
lcUpsBadBypassPower = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 17))
lcUpsAlarmDCOverVoltageShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 18))
lcUpsAlarmHardwareShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 23))
lcUpsAlarmEmergencyXferToBypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 24))
lcUpsAlarmInverterFault = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 25))
lcUpsAlarmPhaseRotationError = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 26))
lcUpsAlarmFuseBlown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 28))
lcUpsAlarmAmbientOverTemp = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 29))
lcUpsAlarmEmergencyPowerOff = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 30))
lcUpsAlarmFanFailed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 31))
lcUpsAlarmControlPowerFailed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 32))
lcUpsAlarmReversePower = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 33))
lcUpsAlarmDCgroundFault = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 34))
lcUpsAlarmLoadOnBypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 35))
lcUpsAlarmBatteryCbOpen = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 37))
lcUpsAlarmInputCbOpen = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 38))
lcUpsAlarmOutputCbOpen = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 39))
lcUpsAlarmOutputFreqError = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 40))
lcUpsAlarmStaticSwUnable = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 41))
lcUpsAlarmManualResetXfer = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 42))
lcUpsAlarmAutoRexferPrimed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 43))
lcUpsAlarmBattCycleBuffWarn = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 44))
lcUpsAlarmModuleSummary = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 45))
lcUpsLineCorrectionActive = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 46))
lcUpsTest = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7))
lcUpsTestBattery = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("start", 2), ("abort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsTestBattery.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBattery.setDescription("Setting this variable to 'start' will initiate the battery test. Setting this variable to 'abort' will stop the battery test if the test is in- progress, otherwise it has no effect. Setting this variable to 'unknown' has no effect. Reading this variable will always result in a return value of 'unknown'. If 'lcUpsTestBatteryStatus' is 'failed' the test may not be performed again and the status will remain in the failure state.")
lcUpsTestBatteryStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("sysFailure", 5), ("notSupported", 6), ("inhibited", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setDescription('The status of the battery test.')
lcUpsTestDiag = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("start", 2), ("abort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsTestDiag.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestDiag.setDescription("Setting this variable to 'start' will initiate the diagnostics test. Setting this variable to 'abort' will stop the diagnostics test if the test is in-progress, otherwise it has no effect. Setting this variable to 'unknown' has no effect. Reading this variable will always result in a return value of 'unknown'.")
lcUpsTestDiagStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("sysFailure", 5), ("notSupported", 6), ("inhibited", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsTestDiagStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestDiagStatus.setDescription('The status of the diagnostics test.')
lcUpsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8))
lcUpsControlOutputOffDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn off the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOffTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn on the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOnTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOffTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setDescription("When 'lcUpsControlOutputOffDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOffWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlOutputOnTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setDescription("When 'lcUpsControlOutputOnDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOnWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlUnixShutdownDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setDescription("Setting this object causes the agent to instruct the UPS to perform a UNIX Shutdown in the indicated number of seconds. The agent counts down the number of seconds until the event will take place. A Unix shutdown is only valid if the UPS is on Battery. During a UNIX Shutdown, the UPS will turn off the output even if the Utility comes back on line before the shutdown time arrives. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value 'cancel'.")
lcUpsControlUnixShutdownTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setDescription("When 'lcUpsControlUnixShutdownDelay' reaches a value less than or equal to this object's value, an lcUpsUnixShutdownWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlCancelCommands = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setDescription("Setting this variable to 'cancel' will cause the agent to issue instructions to the UPS to cancel all outstanding commands, such as lcUpsControlOutputOff, lcUpsControlOutputOn, lcUpsControlUnixShutdown.")
lcUpsControlRebootAgentDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setDescription('Setting this object causes the agent to reboot after the indicated number of seconds have expired. The value will count down until the event takes place.')
lcUpsNominal = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9))
lcUpsNominalOutputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setDescription('The nominal output voltage. (Unit of measure: volt)')
lcUpsNominalInputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setDescription('The nominal input voltage. (Unit of measure: volt)')
lcUpsNominalOutputVA = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVA.setDescription('The nominal Volt-Amp rating.')
lcUpsNominalOutputWatts = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputWatts.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputWatts.setDescription('The nominal power rating. (Unit of measure: watt)')
lcUpsNominalOutputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setDescription('The nominal output frequency. (Unit of measure: Hertz)')
lcUpsNominalInputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setDescription('The nominal input frequency. (Unit of measure: Hertz)')
lcUpsNominalOutputVaRating = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVaRating.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVaRating.setDescription('The nominal Volt-Amp rating.')
lcUpsNominalOutputWattsRating = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputWattsRating.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputWattsRating.setDescription('The nominal power rating. (Unit of measure: watt)')
lcUpsBypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13))
lcUpsOnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3), ("maintenance", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOnBypass.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOnBypass.setDescription('Indicates that the UPS is currently on bypass.')
lcUpsBypassFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassFrequency.setDescription('The current bypass frequency. (Unit of measure: Hertz)')
lcUpsBypassNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassNumLines.setDescription('The number of bypass lines utilized in this device. This entry indicates the number of rows in the bypass table.')
lcUpsBypassTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4), )
if mibBuilder.loadTexts: lcUpsBypassTable.setStatus('optional')
lcUpsBypassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4, 1), ).setIndexNames((0, "LIEBERT-UPS-MIB", "lcUpsBypassLine"))
if mibBuilder.loadTexts: lcUpsBypassEntry.setStatus('optional')
lcUpsBypassLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassLine.setDescription('The bypass Line.')
lcUpsBypassVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassVoltage.setDescription('The bypass voltage. (Unit of measure: Volt)')
lcUpsBypassCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBypassCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBypassCurrent.setDescription('The bypass current. (Unit of measure: Amp)')
lcUpsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14))
lcUpsConfigType = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("online", 2), ("offline", 3), ("lineinteractive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsConfigType.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigType.setDescription('Indicates the UPS topology.')
lcUpsConfigBypassInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3), ("dualinput", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsConfigBypassInstalled.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigBypassInstalled.setDescription('Indicates if a bypass is installed in the UPS.')
lcUpsConfigModuleCount = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsConfigModuleCount.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigModuleCount.setDescription('A number identifying how many multi-module UPS are connected to the System Control Cabinet.')
lcUpsConfigCurrentModule = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsConfigCurrentModule.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigCurrentModule.setDescription('A number identifying which module of a multi-module UPS is currently being monitored.')
lcUpsConfigAudibleStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("muted", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsConfigAudibleStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigAudibleStatus.setDescription('The requested state of the audible alarm. When in the disabled state, the audible alarm should never sound. The enabled state is self-describing. Setting this object to muted(3) when the audible alarm is sounding shall temporarily silence the alarm.')
lcUpsConfigLowBattTime = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsConfigLowBattTime.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigLowBattTime.setDescription('The value of lcUpsBatTimeRemaining at which a lowBatteryWarning condition is declared. (Unit of measure: Minute)')
lcUpsConfigAutoRestart = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 14, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsConfigAutoRestart.setStatus('optional')
if mibBuilder.loadTexts: lcUpsConfigAutoRestart.setDescription('Setting this object will start the output after the indicated number of ticks (1 tick = 10 seconds), including starting the UPS, if necessary. Setting this object to 0 will cause the startup to occur immediately. Setting this object to -1 will disable autorestart.')
lcUpsSwitchedReceptacles = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12))
lcUpsSwitchedReceptMaxNum = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsSwitchedReceptMaxNum.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptMaxNum.setDescription('The maximum number of switched receptacles supported by the Ups.')
lcUpsSwitchedReceptTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2), )
if mibBuilder.loadTexts: lcUpsSwitchedReceptTable.setStatus('optional')
lcUpsSwitchedReceptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1), ).setIndexNames((0, "LIEBERT-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsSwitchedReceptEntry.setStatus('optional')
lcUpsSwitchedReceptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsSwitchedReceptIndex.setStatus('optional')
lcUpsSwitchedReceptOnDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn on a receptacle after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsReceptOnTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsSwitchedCancelCommand to the value cancel.")
lcUpsSwitchedReceptOnTrapDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOnTrapDelay.setDescription("When 'lcUpsSwitchedReceptOnDelay' reaches a value less than or equal to this object's value, an lcUpsReceptOnWarningTrap will be produced and this object will be reset to 0.")
lcUpsSwitchedReceptOffDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn off a receptacle after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsReceptOffTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsSwitchedCancelCommand to the value cancel.")
lcUpsSwitchedReceptOffTrapDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptOffTrapDelay.setDescription("When 'lcUpsSwitchedReceptOffDelay' reaches a value less than or equal to this object's value, an lcUpsReceptOffWarningTrap will be produced and this object will be reset to 0.")
lcUpsSwitchedReceptStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsSwitchedReceptStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptStatus.setDescription('The status of the device receptacle. Note that some devices may support Switched of device receptacles as a group only (by using lcUpsSwitchedOutputOffDelay and lcUpsSwitchedOutputOnDelay).')
lcUpsSwitchedReceptLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 12, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(32, 32)).setFixedLength(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsSwitchedReceptLabel.setStatus('optional')
if mibBuilder.loadTexts: lcUpsSwitchedReceptLabel.setDescription('A user-defined text string associated with a switched receptacle. This may be used to describe the load powered from the receptacle. The text string is stored in non-volatile memory.')
lcUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11))
lcUpsOverloadWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverloadWarningTrap.setDescription("An lcUpsOverloadWarningTrap signifies that the UPS has detected an Overload condition where the output load has exceeded the UPS's rated capacity.")
lcUpsOverloadShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,2)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverloadShutdownTrap.setDescription("An lcUpsOverloadShutdownTrap signifies that the UPS has detected an Overload condition where the output load has exceeded the UPS's rated capacity and has shut off the output.")
lcUpsOnBatteryTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOnBatteryTrap.setDescription('An lcUpsOnBatteryTrap signifies that the UPS is currently on Battery Power.')
lcUpsLowBatteryWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLowBatteryWarningTrap.setDescription('An lcUpsLowBatteryWarningTrap signifies that the UPS has entered a Low Battery state.')
lcUpsLowBatteryShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,5)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLowBatteryShutdownTrap.setDescription('An lcUpsLowBatteryShutdownTrap signifies that the UPS has shut off the output due to a Low Battery state.')
lcUpsUtilPowerFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,6)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerFailedTrap.setDescription('An lcUpsUtilPowerFailedTrap signifies that the utility power input to the UPS has been lost.')
lcUpsUtilPowerRestoredTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,7)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerRestoredTrap.setDescription('An lcUpsUtilPowerRestoredTrap signifies that the utility power has been restored to the UPS.')
lcUpsInputOverVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,8)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsInputOverVoltageTrap.setDescription('An lcUpsInputOverVoltageTrap signifies that the UPS has detected a high input voltage condition.')
lcUpsOverTempWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,9)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverTempWarningTrap.setDescription('An lcUpsOverTempWarningTrap signifies that the UPS has detected a excessive temperature condition.')
lcUpsOverTempShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,10)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverTempShutdownTrap.setDescription('An lcUpsOverTempShutdownTrap signifies that the UPS has detected a excessive temperature condition and shut off the output.')
lcUpsAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,11)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsAlarmTrap.setDescription('An Alarm condition has occurred and is being reported in the lcUpsAlarmTable.')
lcUpsOutputOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,12)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffTrap.setDescription('An lcUpsOutputOffTrap is sent when the UPS turns all of its output off, either at the inverter or via a relay.')
lcUpsOutputOffWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,13)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffWarningTrap.setDescription('An lcUpsOutputOffWarningTrap is sent when the lcUpsControlOutputOffDelay reaches the value of lcUpsControlOutputOffTrapDelay.')
lcUpsOutputOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,14)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnTrap.setDescription('An lcUpsOutputOnTrap is sent when the UPS turns all of its output back on, either at the inverter or via a relay.')
lcUpsOutputOnWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,15)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnWarningTrap.setDescription('An lcUpsOutputOnWarningTrap is sent when the lcUpsControlOutputOnDelay reaches the value of lcUpsControlOutputOnTrapDelay.')
lcUpsUnixShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,16)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownTrap.setDescription('An lcUpsUnixShutodwnTrap is sent 2 seconds before the UPS is scheduled to perform a Unix Shutdown.')
lcUpsUnixShutdownWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,17)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownWarningTrap.setDescription('An lcUpsUnixShutdownWarningTrap is sent when the lcUpsControlUnixShudownDelay reaches the value of lcUpsControlUnixShutdownTrapDelay.')
lcUpsInputFreqErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,22)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsInputFreqErrorTrap.setDescription('An ldUpsInputFreqErrorTrap signifies that the UPS has detected that input frequency is outside tolerable variance.')
lcUpsDCOverVoltageShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,23)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsDCOverVoltageShutdownTrap.setDescription('An lcUpsDCOverVoltageShutdownTrap signifies that the UPS has detected that battery voltage is over the tolarable level.')
lcUpsOutputOverVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,24)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOverVoltageTrap.setDescription('An lcUpsOutputOverVoltageTrap signifies that the UPS has detected that the output voltage is too high.')
lcUpsFuseBlownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,25)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsFuseBlownTrap.setDescription("An lcUpsFuseBlownTrap is sent when the UPS's rectifier or DC capacitor fuse has failed.")
lcUpsEmergencyPowerOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,26)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsEmergencyPowerOffTrap.setDescription('An lcUpsEmergencyPowerOffTrap signifies that the UPS has shut off output due to an emergency condition.')
lcUpsControlPowerFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,27)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsControlPowerFailureTrap.setDescription('An lcUpsControlPowerFailureTrap signifies a failure in the secondary control power.')
lcUpsReversePowerTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,28)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsReversePowerTrap.setDescription('An lcUpsReversePowerTrap signifies that output has been shut off due to a reverse power flow condition.')
lcUpsPhaseRotationErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,29)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsPhaseRotationErrorTrap.setDescription('An lcUpsPhaseRotationErrorTrap signifies a phase-rotation error in the bypass power.')
lcUpsLoadOnBypassTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,30)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLoadOnBypassTrap.setDescription('An lcUpsLoadOnBypassTrap signifies that the load has been transferred to bypass power.')
lcUpsEmergencyXferToBypassTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,31)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsEmergencyXferToBypassTrap.setDescription('An lcUpsEmergencyXferToBypassTrap signifies that the UPS has automatically tranferred the load to bypass power.')
lcUpsInverterFaultTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,34)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsInverterFaultTrap.setDescription('An lcUpsInverterFaultTrap signifies that the UPS detected a problem with the Inverter.')
lcUpsReceptOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,18)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOffTrap.setDescription('An lcUpsReceptOffTrap is sent when the UPS turns an output receptacle off.')
lcUpsReceptOffWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,19)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOffWarningTrap.setDescription('An lcUpsReceptOffWarningTrap is sent when the lcUpsSwitchedReceptOffDelay reaches the value of lcUpsSwitchedReceptOffTrapDelay.')
lcUpsReceptOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,20)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOnTrap.setDescription('An lcUpsReceptOnTrap is sent when the UPS turns an output receptacle on.')
lcUpsReceptOnWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,21)).setObjects(("SNMPv2-MIB", "sysUpTime"), ("LIEBERT-UPS-MIB", "lcUpsSwitchedReceptIndex"))
if mibBuilder.loadTexts: lcUpsReceptOnWarningTrap.setDescription('An lcUpsReceptOnWarningTrap is sent when the lcUpsSwitchedReceptOnDelay reaches the value of lcUpsSwitchedReceptOnTrapDelay.')
luUPStationS = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2))
lsUpsIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 1))
lsUpsIdentFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsIdentFirmwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lsUpsIdentFirmwareVersion.setDescription('The firmware revision level of the UPS.')
lsUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 6))
lsUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 6, 1))
lsUpsAlarmCheckAirFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 6, 1, 1))
lsUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 11))
lsUpsCheckAirFilterTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lsUpsCheckAirFilterTrap.setDescription('An lsUpsCheckAirFilterTrap signifies that the programmed time interval for checking the air filter has passed and it is time to check the air filter.')
lsUpsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 12))
lsUpsConfigBypassInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsConfigBypassInstalled.setStatus('optional')
if mibBuilder.loadTexts: lsUpsConfigBypassInstalled.setDescription('Indicates if a bypass is installed in the UPS.')
lsUpsBypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13))
lsUpsOnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsOnBypass.setStatus('optional')
if mibBuilder.loadTexts: lsUpsOnBypass.setDescription('Indicates that the UPS is currently on bypass.')
lsUpsBypassFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassFrequency.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassFrequency.setDescription('The current bypass frequency. (Unit of measure: Hertz)')
lsUpsBypassNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassNumLines.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassNumLines.setDescription('The number of bypass lines utilized in this device. This entry indicates the number of rows in the bypass table.')
lsUpsBypassTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4), )
if mibBuilder.loadTexts: lsUpsBypassTable.setStatus('optional')
lsUpsBypassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1), ).setIndexNames((0, "LIEBERT-UPS-MIB", "lsUpsBypassLine"))
if mibBuilder.loadTexts: lsUpsBypassEntry.setStatus('optional')
lsUpsBypassLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassLine.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassLine.setDescription('The bypass Line.')
lsUpsBypassVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassVoltage.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassVoltage.setDescription('The bypass voltage. (Unit of measure: Volt)')
lsUpsBypassCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 2, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lsUpsBypassCurrent.setStatus('optional')
if mibBuilder.loadTexts: lsUpsBypassCurrent.setDescription('The bypass current. (Unit of measure: Amp)')
luUPStationD = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3))
ldUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6))
ldUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1))
ldUpsAlarmDCOverVoltageShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 1))
ldUpsAlarmOutputShortShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 2))
ldUpsAlarmLNReversedShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 3))
ldUpsAlarmImminentShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 4))
ldUpsAlarmInputFreqError = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 5))
ldUpsAlarmBoostOn = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 6))
ldUpsAlarmReplaceBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 7))
ldUpsAlarmOutputOverVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 8))
ldUpsAlarmOutputUnderVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 9))
ldUpsAlarmChargerFailed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 6, 1, 10))
ldUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11))
ldUpsDCOverVoltageShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsDCOverVoltageShutdownTrap.setDescription('An ldUpsDCOverVoltageShutdownTrap signifies that the UPS has detected that battery voltage is over the tolarable level.')
ldUpsOutputShortShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,2)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsOutputShortShutdownTrap.setDescription('An ldUpsOutputShortShutdownTrap signifies that the UPS has detected a short circuit across the output.')
ldUpsLNReversedShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsLNReversedShutdownTrap.setDescription('An ldUpsLNReversedShutdownTrap signifies that the UPS has detected that Line and Neutral have been reversed.')
ldUpsImminentShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsImminentShutdownTrap.setDescription('An ldUpsImminentShutdownTrap signifies that the UPS is about to turn off output power.')
ldUpsInputFreqErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,5)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsInputFreqErrorTrap.setDescription('An ldUpsInputFreqErrorTrap signifies that the UPS has detected that input frequency is outside tolerable variance.')
ldUpsOutputOverVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,6)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsOutputOverVoltageTrap.setDescription('An ldUpsOutputOverVoltageTrap signifies that the UPS has detected that the output voltage is too high.')
ldUpsOutputUnderVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,7)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsOutputUnderVoltageTrap.setDescription('An ldUpsOutputUnderVoltageTrap signifies that the UPS has detected that the output voltage is too low.')
ldUpsChargerFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 11) + (0,8)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: ldUpsChargerFailedTrap.setDescription('An ldUpsChargerFailedTrap signifies that the UPS has detected that the battery charger has failed.')
ldUpsInput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 3))
ldUpsInputMaxVoltsSinceLastPoll = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldUpsInputMaxVoltsSinceLastPoll.setStatus('optional')
if mibBuilder.loadTexts: ldUpsInputMaxVoltsSinceLastPoll.setDescription('The maximum input voltage encountered since the object was last retrieved. Note: if there are multiple managers talking to the same agent, the use of this object needs to be coordinated.')
ldUpsInputMinVoltsSinceLastPoll = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldUpsInputMinVoltsSinceLastPoll.setStatus('optional')
if mibBuilder.loadTexts: ldUpsInputMinVoltsSinceLastPoll.setDescription('The minimum input voltage encountered since the object was last retrieved. Note: if there are multiple managers talking to the same agent, the use of this object needs to be coordinated.')
ldUpsOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 4))
ldUpsOutputMaxVoltsSinceLastPoll = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldUpsOutputMaxVoltsSinceLastPoll.setStatus('optional')
if mibBuilder.loadTexts: ldUpsOutputMaxVoltsSinceLastPoll.setDescription('The maximum output voltage encountered since the object was last retrieved. Note: if there are multiple managers talking to the same agent, the use of this object needs to be coordinated.')
ldUpsOutputMinVoltsSinceLastPoll = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 3, 4, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ldUpsOutputMinVoltsSinceLastPoll.setStatus('optional')
if mibBuilder.loadTexts: ldUpsOutputMinVoltsSinceLastPoll.setDescription('The minimum output voltage encountered since the object was last retrieved. Note: if there are multiple managers talking to the same agent, the use of this object needs to be coordinated.')
luUPStationG = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4))
lgUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6))
lgUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1))
lgUpsAlarmDCOverVoltageShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 1))
lgUpsAlarmOutputShortShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 2))
lgUpsAlarmLNReversedShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 3))
lgUpsAlarmRemoteShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 4))
lgUpsAlarmInputUVOnStartup = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 5))
lgUpsAlarmPFCFailedOnStartup = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 6))
lgUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11))
lgUpsDCOverVoltageShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsDCOverVoltageShutdownTrap.setDescription('An lgUpsDCOverVoltageShutdownTrap signifies that the UPS has detected that battery voltage is over the nominal level.')
lgUpsOutputShortShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,2)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsOutputShortShutdownTrap.setDescription('An lgUpsOutputShortShutdownTrap signifies that the UPS has detected a short circuit across the output.')
lgUpsLNReversedShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsLNReversedShutdownTrap.setDescription('An lgUpsLNReversedShutdownTrap signifies that the UPS has detected that Line and Neutral have been reversed.')
lgUpsInputUVOnStartupTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsInputUVOnStartupTrap.setDescription('An lgUpsInputUVOnStartupTrap signifies that the UPS detected a low voltage condition upon system startup.')
luSeries200 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8))
luSeries200Alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 6))
luSeries200AlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 6, 1))
luSeries200AlarmInputFreqError = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 6, 1, 1))
luSeries200Input = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 3))
luSeries200InputMaxVoltsSinceLastPoll = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: luSeries200InputMaxVoltsSinceLastPoll.setStatus('optional')
if mibBuilder.loadTexts: luSeries200InputMaxVoltsSinceLastPoll.setDescription('The maximum input voltage encountered since the object was last retrieved. Note: if there are multiple managers talking to the same agent, the use of this object needs to be coordinated.')
luSeries200InputMinVoltsSinceLastPoll = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: luSeries200InputMinVoltsSinceLastPoll.setStatus('optional')
if mibBuilder.loadTexts: luSeries200InputMinVoltsSinceLastPoll.setDescription('The minimum input voltage encountered since the object was last retrieved. Note: if there are multiple managers talking to the same agent, the use of this object needs to be coordinated.')
luSeries200Config = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 12))
luSeries200ConfigBypassInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: luSeries200ConfigBypassInstalled.setStatus('optional')
if mibBuilder.loadTexts: luSeries200ConfigBypassInstalled.setDescription('Indicates if a bypass is installed in the UPS.')
luSeries200ConfigFrequencyChangerModel = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: luSeries200ConfigFrequencyChangerModel.setStatus('optional')
if mibBuilder.loadTexts: luSeries200ConfigFrequencyChangerModel.setDescription('Indicates whether this AP200 model is a frequency changer model.')
luSeries200Bypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 13))
luSeries200OnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 8, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: luSeries200OnBypass.setStatus('optional')
if mibBuilder.loadTexts: luSeries200OnBypass.setDescription('Indicates that the UPS is currently on bypass.')
luSeries4300 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10))
ls43cUpsIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 1))
ls43cUpsIdentFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsIdentFirmwareVersion.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsIdentFirmwareVersion.setDescription('The firmware revision level of the UPS.')
ls43cUpsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 12))
ls43cUpsConfigBypassInstalled = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsConfigBypassInstalled.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsConfigBypassInstalled.setDescription('Indicates if a bypass is installed in the UPS.')
ls43cUpsBypass = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13))
ls43cUpsOnBypass = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("yes", 2), ("no", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsOnBypass.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsOnBypass.setDescription('Indicates that the UPS is currently on bypass.')
ls43cUpsBypassFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsBypassFrequency.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsBypassFrequency.setDescription('The current bypass frequency. (Unit of measure: Hertz)')
ls43cUpsBypassNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsBypassNumLines.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsBypassNumLines.setDescription('The number of bypass lines utilized in this device. This entry indicates the number of rows in the bypass table.')
ls43cUpsBypassTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 4), )
if mibBuilder.loadTexts: ls43cUpsBypassTable.setStatus('optional')
ls43cUpsBypassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 4, 1), ).setIndexNames((0, "LIEBERT-UPS-MIB", "ls43cUpsBypassLine"))
if mibBuilder.loadTexts: ls43cUpsBypassEntry.setStatus('optional')
ls43cUpsBypassLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsBypassLine.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsBypassLine.setDescription('The bypass Line.')
ls43cUpsBypassVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsBypassVoltage.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsBypassVoltage.setDescription('The bypass voltage. (Unit of measure: Volt)')
ls43cUpsBypassCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 10, 13, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ls43cUpsBypassCurrent.setStatus('optional')
if mibBuilder.loadTexts: ls43cUpsBypassCurrent.setDescription('The bypass current. (Unit of measure: Amp)')
luSeries300 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 5))
luExternal = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 6))
luUPStationS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 7))
luUpsModule = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 11))
luSystemCabinet = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 12))
luUPStationGxt = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 14))
luPowerSure = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 15))
mibBuilder.exportSymbols("LIEBERT-UPS-MIB", lcUpsSwitchedReceptIndex=lcUpsSwitchedReceptIndex, lcUpsOverTempShutdownTrap=lcUpsOverTempShutdownTrap, luSeries200Alarm=luSeries200Alarm, ldUpsAlarmLNReversedShutdown=ldUpsAlarmLNReversedShutdown, lcUpsOutputOffTrap=lcUpsOutputOffTrap, lcUpsBatAmpHours=lcUpsBatAmpHours, luSeries200=luSeries200, lcUpsControlPowerFailureTrap=lcUpsControlPowerFailureTrap, luUPStationS3=luUPStationS3, ldUpsAlarmOutputShortShutdown=ldUpsAlarmOutputShortShutdown, lcUpsBatCapacity=lcUpsBatCapacity, lcUpsConfig=lcUpsConfig, lgUpsAlarmPFCFailedOnStartup=lgUpsAlarmPFCFailedOnStartup, ldUpsOutput=ldUpsOutput, lcUpsAlarmTime=lcUpsAlarmTime, lcUpsLowBatteryWarningTrap=lcUpsLowBatteryWarningTrap, luUPStationG=luUPStationG, luExternal=luExternal, luSeries4300=luSeries4300, lgUpsOutputShortShutdownTrap=lgUpsOutputShortShutdownTrap, lcUpsOutputVoltage=lcUpsOutputVoltage, lcUpsBypassVoltage=lcUpsBypassVoltage, lcUpsBatVoltage=lcUpsBatVoltage, lcUpsSwitchedReceptacles=lcUpsSwitchedReceptacles, lsUpsIdent=lsUpsIdent, lsUpsBypass=lsUpsBypass, lcUpsInverterFaultTrap=lcUpsInverterFaultTrap, lcUpsInput=lcUpsInput, lcUpsAlarmOutputUnderVoltage=lcUpsAlarmOutputUnderVoltage, lcUpsAlarmOverTempWarning=lcUpsAlarmOverTempWarning, lcUpsOutputLine=lcUpsOutputLine, lcUpsAlarmFuseBlown=lcUpsAlarmFuseBlown, lcUpsBattery=lcUpsBattery, lcUpsReceptOffTrap=lcUpsReceptOffTrap, lcUpsReceptOnTrap=lcUpsReceptOnTrap, lcUpsAlarmOutputOverVoltage=lcUpsAlarmOutputOverVoltage, lsUpsOnBypass=lsUpsOnBypass, lgUpsAlarmOutputShortShutdown=lgUpsAlarmOutputShortShutdown, lcUpsDCOverVoltageShutdownTrap=lcUpsDCOverVoltageShutdownTrap, ldUpsOutputMinVoltsSinceLastPoll=ldUpsOutputMinVoltsSinceLastPoll, lcUpsAlarmTable=lcUpsAlarmTable, lcUpsOutputOverVoltageTrap=lcUpsOutputOverVoltageTrap, lcUpsBypass=lcUpsBypass, lcUpsConfigType=lcUpsConfigType, lsUpsBypassNumLines=lsUpsBypassNumLines, lcUpsInputTransients=lcUpsInputTransients, luUPStationGxt=luUPStationGxt, lcUpsIdentSpecific=lcUpsIdentSpecific, lcUpsFuseBlownTrap=lcUpsFuseBlownTrap, lcUpsInputFrequency=lcUpsInputFrequency, lcUpsAlarmInputOverVoltage=lcUpsAlarmInputOverVoltage, lcUpsInputOverVoltageTrap=lcUpsInputOverVoltageTrap, lcUpsOutputOffWarningTrap=lcUpsOutputOffWarningTrap, ldUpsAlarmConditions=ldUpsAlarmConditions, ldUpsAlarmOutputOverVoltage=ldUpsAlarmOutputOverVoltage, ldUpsTraps=ldUpsTraps, ls43cUpsBypassCurrent=ls43cUpsBypassCurrent, lcUpsOverTempWarningTrap=lcUpsOverTempWarningTrap, lcUpsOutputNumLines=lcUpsOutputNumLines, ldUpsOutputOverVoltageTrap=ldUpsOutputOverVoltageTrap, lgUpsAlarmInputUVOnStartup=lgUpsAlarmInputUVOnStartup, lcUpsSwitchedReceptTable=lcUpsSwitchedReceptTable, lcUpsAlarmLowBatteryShutdown=lcUpsAlarmLowBatteryShutdown, lsUpsBypassLine=lsUpsBypassLine, lcUpsInputFreqErrorTrap=lcUpsInputFreqErrorTrap, lcUpsAlarmInputFreqError=lcUpsAlarmInputFreqError, lcUpsAlarmPhaseRotationError=lcUpsAlarmPhaseRotationError, luExtensions=luExtensions, lgUpsAlarmLNReversedShutdown=lgUpsAlarmLNReversedShutdown, luSeries200Config=luSeries200Config, lcUpsSwitchedReceptEntry=lcUpsSwitchedReceptEntry, lcUpsInverterTemp=lcUpsInverterTemp, lcUpsAlarmLowBatteryWarning=lcUpsAlarmLowBatteryWarning, lcUpsSwitchedReceptOffDelay=lcUpsSwitchedReceptOffDelay, ls43cUpsIdentFirmwareVersion=ls43cUpsIdentFirmwareVersion, ls43cUpsBypassTable=ls43cUpsBypassTable, lcUpsAlarmBatteryCbOpen=lcUpsAlarmBatteryCbOpen, lcUpsNominalInputVoltage=lcUpsNominalInputVoltage, ldUpsDCOverVoltageShutdownTrap=ldUpsDCOverVoltageShutdownTrap, lcUpsOnBypass=lcUpsOnBypass, lcUpsOverloadWarningTrap=lcUpsOverloadWarningTrap, lcUpsAlarmManualResetXfer=lcUpsAlarmManualResetXfer, lcUpsIdent=lcUpsIdent, lcUpsAlarms=lcUpsAlarms, lcUpsNominalOutputWattsRating=lcUpsNominalOutputWattsRating, ldUpsAlarmInputFreqError=ldUpsAlarmInputFreqError, lsUpsBypassCurrent=lsUpsBypassCurrent, lcUpsInputNumLines=lcUpsInputNumLines, lcUpsEmergencyPowerOffTrap=lcUpsEmergencyPowerOffTrap, lsUpsAlarmCheckAirFilter=lsUpsAlarmCheckAirFilter, lgUpsAlarmConditions=lgUpsAlarmConditions, luSeries200Input=luSeries200Input, luSeries200ConfigFrequencyChangerModel=luSeries200ConfigFrequencyChangerModel, luSeries200OnBypass=luSeries200OnBypass, lcUpsBypassEntry=lcUpsBypassEntry, lcUpsPhaseRotationErrorTrap=lcUpsPhaseRotationErrorTrap, lcUpsBatTimeRemaining=lcUpsBatTimeRemaining, lcUpsTestBatteryStatus=lcUpsTestBatteryStatus, lsUpsTraps=lsUpsTraps, lcUpsOutputOnWarningTrap=lcUpsOutputOnWarningTrap, lsUpsCheckAirFilterTrap=lsUpsCheckAirFilterTrap, lsUpsConfigBypassInstalled=lsUpsConfigBypassInstalled, luPrivate=luPrivate, luPowerSure=luPowerSure, lcUpsAlarmAmbientOverTemp=lcUpsAlarmAmbientOverTemp, lsUpsAlarmConditions=lsUpsAlarmConditions, lcUpsConfigCurrentModule=lcUpsConfigCurrentModule, lsUpsBypassFrequency=lsUpsBypassFrequency, lcUpsControlOutputOnDelay=lcUpsControlOutputOnDelay, luSeries200Bypass=luSeries200Bypass, lcUpsConfigBypassInstalled=lcUpsConfigBypassInstalled, lcUpsOnBatteryTrap=lcUpsOnBatteryTrap, luSystemCabinet=luSystemCabinet, lcUpsBypassCurrent=lcUpsBypassCurrent, lcUpsUtilPowerFailedTrap=lcUpsUtilPowerFailedTrap, lcUpsConfigModuleCount=lcUpsConfigModuleCount, lcUpsSwitchedReceptStatus=lcUpsSwitchedReceptStatus, lcUpsAlarmModuleSummary=lcUpsAlarmModuleSummary, lcUpsTraps=lcUpsTraps, lcUpsUnixShutdownWarningTrap=lcUpsUnixShutdownWarningTrap, lcUpsLoadOnBypassTrap=lcUpsLoadOnBypassTrap, lcUpsAlarmFanFailed=lcUpsAlarmFanFailed, lgUpsTraps=lgUpsTraps, lsUpsBypassEntry=lsUpsBypassEntry, liebertUps=liebertUps, lgUpsLNReversedShutdownTrap=lgUpsLNReversedShutdownTrap, ldUpsChargerFailedTrap=ldUpsChargerFailedTrap, lcUpsReversePowerTrap=lcUpsReversePowerTrap, lcUpsAlarmOutputOverloadWarning=lcUpsAlarmOutputOverloadWarning, lcUpsAlarmInverterFault=lcUpsAlarmInverterFault, lcUpsAlarmEmergencyPowerOff=lcUpsAlarmEmergencyPowerOff, lcUpsNominalInputFreq=lcUpsNominalInputFreq, lcUpsOverloadShutdownTrap=lcUpsOverloadShutdownTrap, ldUpsLNReversedShutdownTrap=ldUpsLNReversedShutdownTrap, lcUpsIdentSoftwareVersion=lcUpsIdentSoftwareVersion, lcUpsAlarmOverTempShutdown=lcUpsAlarmOverTempShutdown, lcUpsAlarmEmergencyXferToBypass=lcUpsAlarmEmergencyXferToBypass, luCore=luCore, lcUpsNominalOutputVaRating=lcUpsNominalOutputVaRating, lcUpsUnixShutdownTrap=lcUpsUnixShutdownTrap, lcUpsSwitchedReceptOnDelay=lcUpsSwitchedReceptOnDelay, ldUpsImminentShutdownTrap=ldUpsImminentShutdownTrap, lcUpsInputBrownOuts=lcUpsInputBrownOuts, ldUpsOutputMaxVoltsSinceLastPoll=ldUpsOutputMaxVoltsSinceLastPoll, lcUpsSwitchedReceptOffTrapDelay=lcUpsSwitchedReceptOffTrapDelay, lcUpsAlarmStaticSwUnable=lcUpsAlarmStaticSwUnable, lcUpsBatCurrent=lcUpsBatCurrent, lcUpsBadBypassPower=lcUpsBadBypassPower, lcUpsAlarmDCgroundFault=lcUpsAlarmDCgroundFault, ls43cUpsBypassNumLines=ls43cUpsBypassNumLines, lcUpsInputVA=lcUpsInputVA, lcUpsOutputWatts=lcUpsOutputWatts, lcUpsNominalOutputWatts=lcUpsNominalOutputWatts, emerson=emerson, luUPStationS=luUPStationS, lcUpsIdentModel=lcUpsIdentModel, ls43cUpsBypassFrequency=ls43cUpsBypassFrequency, lcUpsAlarmConditions=lcUpsAlarmConditions, ldUpsAlarmDCOverVoltageShutdown=ldUpsAlarmDCOverVoltageShutdown, lcUpsInputBlackOuts=lcUpsInputBlackOuts, ldUpsAlarmOutputUnderVoltage=ldUpsAlarmOutputUnderVoltage, lcUpsSwitchedReceptMaxNum=lcUpsSwitchedReceptMaxNum, lcUpsControlCancelCommands=lcUpsControlCancelCommands, ldUpsAlarm=ldUpsAlarm, lcUpsNominalOutputVoltage=lcUpsNominalOutputVoltage, luSeries300=luSeries300, lcUpsUtilPowerRestoredTrap=lcUpsUtilPowerRestoredTrap, lsUpsBypassVoltage=lsUpsBypassVoltage, lsUpsAlarm=lsUpsAlarm, lcUpsOutputCurrent=lcUpsOutputCurrent, lcUpsInputLine=lcUpsInputLine, lcUpsOutputEntry=lcUpsOutputEntry, lcUpsControlOutputOnTrapDelay=lcUpsControlOutputOnTrapDelay, lcUpsBypassLine=lcUpsBypassLine, lcUpsEmergencyXferToBypassTrap=lcUpsEmergencyXferToBypassTrap, lcUpsTestDiag=lcUpsTestDiag, ls43cUpsBypassEntry=ls43cUpsBypassEntry, lcUpsNominalOutputFreq=lcUpsNominalOutputFreq, lcUpsBypassTable=lcUpsBypassTable, lcUpsAlarmInputCbOpen=lcUpsAlarmInputCbOpen, lsUpsConfig=lsUpsConfig, lgUpsInputUVOnStartupTrap=lgUpsInputUVOnStartupTrap, lcUpsAlarmDCOverVoltageShutdown=lcUpsAlarmDCOverVoltageShutdown, lcUpsBatKWhours=lcUpsBatKWhours, lcUpsIdentFirmwareVersion=lcUpsIdentFirmwareVersion, lcUpsControlOutputOffTrapDelay=lcUpsControlOutputOffTrapDelay, ldUpsInputMaxVoltsSinceLastPoll=ldUpsInputMaxVoltsSinceLastPoll, ls43cUpsIdent=ls43cUpsIdent, lcUpsOutputTable=lcUpsOutputTable, lcUpsSwitchedReceptOnTrapDelay=lcUpsSwitchedReceptOnTrapDelay, lcUpsAlarmOutputOverloadShutdown=lcUpsAlarmOutputOverloadShutdown, lcUpsBatWattHours=lcUpsBatWattHours, lcUpsControlOutputOffDelay=lcUpsControlOutputOffDelay, ldUpsAlarmImminentShutdown=ldUpsAlarmImminentShutdown, ldUpsInput=ldUpsInput, lcUpsSwitchedReceptLabel=lcUpsSwitchedReceptLabel, lcUpsAlarm=lcUpsAlarm, lcUpsAlarmLoadOnBypass=lcUpsAlarmLoadOnBypass, lcUpsAlarmTrap=lcUpsAlarmTrap, lcUpsOutputVA=lcUpsOutputVA, lcUpsOutputFrequency=lcUpsOutputFrequency, luSeries200AlarmInputFreqError=luSeries200AlarmInputFreqError, ls43cUpsBypassVoltage=ls43cUpsBypassVoltage, luUpsModule=luUpsModule, lcUpsConfigLowBattTime=lcUpsConfigLowBattTime, lcUpsConfigAudibleStatus=lcUpsConfigAudibleStatus, lcUpsInputCurrent=lcUpsInputCurrent, lcUpsNominalOutputVA=lcUpsNominalOutputVA, lgUpsAlarmDCOverVoltageShutdown=lgUpsAlarmDCOverVoltageShutdown, lcUpsTestBattery=lcUpsTestBattery, lcUpsControl=lcUpsControl, ls43cUpsOnBypass=ls43cUpsOnBypass, luExperimental=luExperimental, lcUpsAlarmOutputFreqError=lcUpsAlarmOutputFreqError, lcUpsAlarmAutoRexferPrimed=lcUpsAlarmAutoRexferPrimed, lcUpsAlarmDescr=lcUpsAlarmDescr, lcUpsInverter=lcUpsInverter, lcUpsLowBatteryShutdownTrap=lcUpsLowBatteryShutdownTrap, ldUpsAlarmChargerFailed=ldUpsAlarmChargerFailed, lcUpsTestDiagStatus=lcUpsTestDiagStatus, lcUpsControlUnixShutdownTrapDelay=lcUpsControlUnixShutdownTrapDelay, ls43cUpsConfigBypassInstalled=ls43cUpsConfigBypassInstalled, ls43cUpsBypass=ls43cUpsBypass, ldUpsInputMinVoltsSinceLastPoll=ldUpsInputMinVoltsSinceLastPoll, lgUpsDCOverVoltageShutdownTrap=lgUpsDCOverVoltageShutdownTrap, lgUpsAlarm=lgUpsAlarm, ldUpsAlarmReplaceBattery=ldUpsAlarmReplaceBattery, lcUpsOutputLoad=lcUpsOutputLoad, lcUpsOutputOnTrap=lcUpsOutputOnTrap, lcUpsAlarmControlPowerFailed=lcUpsAlarmControlPowerFailed, lgUpsAlarmRemoteShutdown=lgUpsAlarmRemoteShutdown, luSeries200AlarmConditions=luSeries200AlarmConditions, luSeries200InputMinVoltsSinceLastPoll=luSeries200InputMinVoltsSinceLastPoll, lcUpsInputEntry=lcUpsInputEntry, lcUpsConfigAutoRestart=lcUpsConfigAutoRestart, lcUpsAlarmOutputCbOpen=lcUpsAlarmOutputCbOpen, ls43cUpsBypassLine=ls43cUpsBypassLine, ldUpsAlarmBoostOn=ldUpsAlarmBoostOn, ldUpsOutputUnderVoltageTrap=ldUpsOutputUnderVoltageTrap, lcUpsNominal=lcUpsNominal, ls43cUpsConfig=ls43cUpsConfig, luSeries200ConfigBypassInstalled=luSeries200ConfigBypassInstalled, lcUpsAlarmUtilFailed=lcUpsAlarmUtilFailed, lcUpsAlarmId=lcUpsAlarmId, ldUpsOutputShortShutdownTrap=ldUpsOutputShortShutdownTrap, liebertCorp=liebertCorp, lcUpsBatTotalDischCounts=lcUpsBatTotalDischCounts, lcUpsAlarmReversePower=lcUpsAlarmReversePower, lcUpsReceptOffWarningTrap=lcUpsReceptOffWarningTrap, lcUpsBatCycleDurationInSeconds=lcUpsBatCycleDurationInSeconds, luSeries200InputMaxVoltsSinceLastPoll=luSeries200InputMaxVoltsSinceLastPoll, lcUpsAlarmBattCycleBuffWarn=lcUpsAlarmBattCycleBuffWarn, lcUpsLineCorrectionActive=lcUpsLineCorrectionActive, lcUpsTest=lcUpsTest)
mibBuilder.exportSymbols("LIEBERT-UPS-MIB", lcUpsInputVoltage=lcUpsInputVoltage, lcUpsOutput=lcUpsOutput, lcUpsAlarmUpsOff=lcUpsAlarmUpsOff, lcUpsControlUnixShutdownDelay=lcUpsControlUnixShutdownDelay, lcUpsIdentSerialNumber=lcUpsIdentSerialNumber, lsUpsIdentFirmwareVersion=lsUpsIdentFirmwareVersion, lcUpsAlarmEntry=lcUpsAlarmEntry, lcUpsInputTable=lcUpsInputTable, lcUpsControlRebootAgentDelay=lcUpsControlRebootAgentDelay, lcUpsAlarmHardwareShutdown=lcUpsAlarmHardwareShutdown, lcUpsIdentManufacturer=lcUpsIdentManufacturer, lcUpsBypassNumLines=lcUpsBypassNumLines, ldUpsInputFreqErrorTrap=ldUpsInputFreqErrorTrap, lcUpsAlarmOnBattery=lcUpsAlarmOnBattery, lcUpsIdentManufactureDate=lcUpsIdentManufactureDate, lsUpsBypassTable=lsUpsBypassTable, luUPStationD=luUPStationD, lcUpsAlarmBatteryBad=lcUpsAlarmBatteryBad, lcUpsReceptOnWarningTrap=lcUpsReceptOnWarningTrap, lcUpsAlarmStopNoticeIssued=lcUpsAlarmStopNoticeIssued, lcUpsBatTemperature=lcUpsBatTemperature, lcUpsInverterStatus=lcUpsInverterStatus, lcUpsBypassFrequency=lcUpsBypassFrequency)

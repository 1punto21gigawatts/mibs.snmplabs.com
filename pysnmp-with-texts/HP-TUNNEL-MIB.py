#
# PySNMP MIB module HP-TUNNEL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-TUNNEL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:36:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
hpSwitch, = mibBuilder.importSymbols("HP-ICF-OID", "hpSwitch")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
VlanIndex, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, TimeTicks, ModuleIdentity, Bits, Gauge32, NotificationType, MibIdentifier, Counter64, Counter32, Unsigned32, ObjectIdentity, iso = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "TimeTicks", "ModuleIdentity", "Bits", "Gauge32", "NotificationType", "MibIdentifier", "Counter64", "Counter32", "Unsigned32", "ObjectIdentity", "iso")
RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "DisplayString")
tunnelIfRemoteInetAddress, tunnelInetConfigEntry, tunnelIfAddressType, tunnelIfEntry, tunnelIfLocalInetAddress = mibBuilder.importSymbols("TUNNEL-MIB", "tunnelIfRemoteInetAddress", "tunnelInetConfigEntry", "tunnelIfAddressType", "tunnelIfEntry", "tunnelIfLocalInetAddress")
hpTunnelMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77))
hpTunnelMIB.setRevisions(('2015-02-02 00:00', '2014-08-15 00:00', '2014-08-13 00:00', '2010-07-22 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hpTunnelMIB.setRevisionsDescriptions(('The MIB module for managing the tunnel interfaces', 'Added hpTunnelNotifyScalars & hpTunnelNotifications', 'Added option macinudp under HpTunnelType', 'The initial revision of this MIB module',))
if mibBuilder.loadTexts: hpTunnelMIB.setLastUpdated('201502020000Z')
if mibBuilder.loadTexts: hpTunnelMIB.setOrganization('HP Networking')
if mibBuilder.loadTexts: hpTunnelMIB.setContactInfo('Hewlett Packard Company 8000 Foothills Blvd. Roseville, CA 95747')
if mibBuilder.loadTexts: hpTunnelMIB.setDescription('Renamed hpTunnelNotifications')
hpTunnelNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 0))
hpTunnelObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1))
hpTunnelConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2))
class HpTunnelType(TextualConvention, Integer32):
    description = 'The encapsulation method used by a tunnel.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("unspecified", 1), ("direct4in4", 2), ("direct6in4", 3), ("direct6in4Ipsec", 4), ("direct6in6", 5), ("ipsecIpv4", 6), ("ipsecIpv6", 7), ("macinudp", 8))

hpTunnelConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 1), )
if mibBuilder.loadTexts: hpTunnelConfigTable.setStatus('current')
if mibBuilder.loadTexts: hpTunnelConfigTable.setDescription('This table is used to provision for a tunnel without having to configure the source and destination ends of the tunnels. ')
hpTunnelConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 1, 1), ).setIndexNames((0, "HP-TUNNEL-MIB", "hpTunnelID"))
if mibBuilder.loadTexts: hpTunnelConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hpTunnelConfigEntry.setDescription('A set of objects that are used to create a tunnel.')
hpTunnelID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpTunnelID.setStatus('current')
if mibBuilder.loadTexts: hpTunnelID.setDescription('The tunnel number to configure a tunnel.')
hpTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 1, 1, 2), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpTunnelIfIndex.setStatus('deprecated')
if mibBuilder.loadTexts: hpTunnelIfIndex.setDescription('The interface index associated with this tunnel entry. Since this Object is read-only, it is deprecated in favor of hpTunnelInterfaceIndex.')
hpTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpTunnelRowStatus.setStatus('current')
if mibBuilder.loadTexts: hpTunnelRowStatus.setDescription('The status of this row, by which new entries may be created, or old entries deleted from this table.')
hpTunnelInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 1, 1, 4), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpTunnelInterfaceIndex.setStatus('current')
if mibBuilder.loadTexts: hpTunnelInterfaceIndex.setDescription('The tunnel interface index associated with this tunnel entry.')
hpTunnelIfTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 2), )
if mibBuilder.loadTexts: hpTunnelIfTable.setStatus('current')
if mibBuilder.loadTexts: hpTunnelIfTable.setDescription('This table augments the tunnelIfTable ')
hpTunnelIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 2, 1), )
tunnelIfEntry.registerAugmentions(("HP-TUNNEL-MIB", "hpTunnelIfEntry"))
hpTunnelIfEntry.setIndexNames(*tunnelIfEntry.getIndexNames())
if mibBuilder.loadTexts: hpTunnelIfEntry.setStatus('current')
if mibBuilder.loadTexts: hpTunnelIfEntry.setDescription('A set of objects as an augment to tunnelIfTable.')
hpTunnelIfPMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpTunnelIfPMTU.setStatus('current')
if mibBuilder.loadTexts: hpTunnelIfPMTU.setDescription('Enable/Disable path mtu discovery for this tunnel.')
hpTunnelIfNUD = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpTunnelIfNUD.setStatus('current')
if mibBuilder.loadTexts: hpTunnelIfNUD.setDescription('Enable/Disable Neighbor Unreachability Detection for this tunnel.')
hpTunnelIfMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 2, 1, 3), Unsigned32().clone(1280)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpTunnelIfMTU.setStatus('current')
if mibBuilder.loadTexts: hpTunnelIfMTU.setDescription('The size of the largest packet which can be sent/received on the interface, specified in octets. For interfaces that are used for transmitting network datagrams, this is the size of the largest network datagram that can be sent on the interface.')
hpTunnelEncapsMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 2, 1, 4), HpTunnelType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpTunnelEncapsMethod.setStatus('current')
if mibBuilder.loadTexts: hpTunnelEncapsMethod.setDescription('The encapsulation method used by the tunnel.')
hpTunnelIpsecName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 2, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpTunnelIpsecName.setStatus('current')
if mibBuilder.loadTexts: hpTunnelIpsecName.setDescription('Specifies the IPSEC profile name for tunnel. This mentioned IPSEC profile can be attached with tunnel to avail the protection for tunnel traffic')
hpTunnelInetConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 3), )
if mibBuilder.loadTexts: hpTunnelInetConfigTable.setStatus('current')
if mibBuilder.loadTexts: hpTunnelInetConfigTable.setDescription('This table augments the tunnelInetConfigTable ')
hpTunnelInetConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 3, 1), )
tunnelInetConfigEntry.registerAugmentions(("HP-TUNNEL-MIB", "hpTunnelInetConfigEntry"))
hpTunnelInetConfigEntry.setIndexNames(*tunnelInetConfigEntry.getIndexNames())
if mibBuilder.loadTexts: hpTunnelInetConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hpTunnelInetConfigEntry.setDescription('A set of objects as an augment to tunnelInetConfigTable.')
hpTunnelInetConfigEncapsMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 3, 1, 1), HpTunnelType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpTunnelInetConfigEncapsMethod.setStatus('current')
if mibBuilder.loadTexts: hpTunnelInetConfigEncapsMethod.setDescription('The encapsulation method used by the tunnel. ')
hpTunnelNotifyScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6))
hpTunnelMTUDropRouterAddrType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 1), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropRouterAddrType.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropRouterAddrType.setDescription('The IP address type of the router that sent the ICMP destination unreachable message.')
hpTunnelMTUDropRouterAddr = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 2), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropRouterAddr.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropRouterAddr.setDescription('IP address of the router that sent the ICMP destination unreachable message.')
hpTunnelMTUDropRouterMTU = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 3), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropRouterMTU.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropRouterMTU.setDescription('The interface MTU of the router that sent the ICMP destination unreachable message.')
hpTunnelMTUDropTunnelSrcAddrType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 4), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelSrcAddrType.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelSrcAddrType.setDescription('The address type of the source IP address of the original packet that is encapsulated by the VXLAN/Tap tunnel interface.')
hpTunnelMTUDropTunnelSource = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 5), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelSource.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelSource.setDescription('The source IP address of the original packet that is encapsulated by the VXLAN/Tap tunnel interface.')
hpTunnelMTUDropTunnelDstAddrType = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 6), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelDstAddrType.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelDstAddrType.setDescription('The address type of the destination IP address of the original packet that is encapsulated by the VXLAN/Tap tunnel interface.')
hpTunnelMTUDropTunnelDest = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 7), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelDest.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropTunnelDest.setDescription('The destination IP address of the original packet that is encapsulated by the VXLAN/Tap tunnel interface.')
hpTunnelMTUDropInIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 8), InterfaceIndex()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hpTunnelMTUDropInIfIndex.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropInIfIndex.setDescription('The interface index of the inbound VLAN of the ICMP destination unreachable packet.')
hpTunnelMTUDropNotifyEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 6, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpTunnelMTUDropNotifyEnable.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMTUDropNotifyEnable.setDescription(' This enables or disables the virtual network notifications.')
hpTunnelIcmpErrorRcvd = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 0, 1)).setObjects(("HP-TUNNEL-MIB", "hpTunnelMTUDropRouterAddrType"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropRouterAddr"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropRouterMTU"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelSrcAddrType"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelSource"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelDstAddrType"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelDest"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropInIfIndex"), ("TUNNEL-MIB", "tunnelIfAddressType"), ("TUNNEL-MIB", "tunnelIfLocalInetAddress"), ("TUNNEL-MIB", "tunnelIfRemoteInetAddress"))
if mibBuilder.loadTexts: hpTunnelIcmpErrorRcvd.setStatus('current')
if mibBuilder.loadTexts: hpTunnelIcmpErrorRcvd.setDescription('This notification is generated when the tunnel source recevied an ICMP destination unreachable error message from the router in the underlay network with the IP address hpTunnelMTUDropRouterAddr for the reason of MTU violation.')
hpicfVlanTunnelMappingTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 4), )
if mibBuilder.loadTexts: hpicfVlanTunnelMappingTable.setStatus('current')
if mibBuilder.loadTexts: hpicfVlanTunnelMappingTable.setDescription('A table that maps a VLAN to a tunnel. The tunnel to VLAN mapping implies that tunnel will carry bidirectional traffic of a VLAN.')
hpicfVlanTunnelMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 4, 1), ).setIndexNames((0, "HP-TUNNEL-MIB", "hpicfVLANIndex"), (0, "HP-TUNNEL-MIB", "hpicfTunnelIfIndex"))
if mibBuilder.loadTexts: hpicfVlanTunnelMappingEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfVlanTunnelMappingEntry.setDescription('An entry containing the mapping of a VLAN to a tunnel. The VLAN-to-tunnel mapping allows all the VLAN traffic to flow through the associated tunnel.')
hpicfVLANIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 4, 1, 1), VlanIndex())
if mibBuilder.loadTexts: hpicfVLANIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfVLANIndex.setDescription('This object refers to the VLANID that is mapped to a tunnel')
hpicfTunnelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 4, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: hpicfTunnelIfIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfTunnelIfIndex.setDescription('This object specifies the tunnel interface index which is mapped to a speciifc VLAN.')
hpicfVlanTunnelMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfVlanTunnelMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfVlanTunnelMappingRowStatus.setDescription('The row status of a VLAN to tunnel mapping entry.')
hpicfUDPTunnelTypeTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 5), )
if mibBuilder.loadTexts: hpicfUDPTunnelTypeTable.setStatus('current')
if mibBuilder.loadTexts: hpicfUDPTunnelTypeTable.setDescription('A table containing the information about the UDP tunnel types.')
hpicfUDPTunnelTypeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 5, 1), )
tunnelInetConfigEntry.registerAugmentions(("HP-TUNNEL-MIB", "hpicfUDPTunnelTypeEntry"))
hpicfUDPTunnelTypeEntry.setIndexNames(*tunnelInetConfigEntry.getIndexNames())
if mibBuilder.loadTexts: hpicfUDPTunnelTypeEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfUDPTunnelTypeEntry.setDescription('An entry containing the information on a UDP tunnel type.')
hpicfUDPTunnelType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("remotemirror", 1), ("vxlan", 2))).clone('remotemirror')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfUDPTunnelType.setStatus('current')
if mibBuilder.loadTexts: hpicfUDPTunnelType.setDescription('This object is used to configure the UDP tunnel type. A value of none(0) indicates that the tunnel is not a UDP tunnel. A value of remotemirror(1) indicates that the UDP tunnel configured is a remote mirroring tunnel. A value of vxlan(2) indicates that the UDP tunnel configured is a VXLAN tunnel.')
hpTunnelMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 1))
hpTunnelMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 2))
hpTunnelMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 1, 1)).setObjects(("HP-TUNNEL-MIB", "hpTunnelProvisionGroup"), ("HP-TUNNEL-MIB", "hpTunnelInetConfigGroup"), ("HP-TUNNEL-MIB", "hpVlanTunnelMappingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpTunnelMIBCompliance = hpTunnelMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpTunnelMIBCompliance.setDescription('The compliance statement for the HP Tunnel MIB.')
hpTunnelMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 1, 2)).setObjects(("HP-TUNNEL-MIB", "hpTunnelProvisionGroup2"), ("HP-TUNNEL-MIB", "hpTunnelInetConfigGroup"), ("HP-TUNNEL-MIB", "hpTunnelNotifyScalarsGroup"), ("HP-TUNNEL-MIB", "hpTunnelNotificationsGroup"), ("HP-TUNNEL-MIB", "hpVlanTunnelMappingGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpTunnelMIBCompliance2 = hpTunnelMIBCompliance2.setStatus('current')
if mibBuilder.loadTexts: hpTunnelMIBCompliance2.setDescription('The compliance statement for the HP Tunnel MIB.')
hpTunnelProvisionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 2, 1)).setObjects(("HP-TUNNEL-MIB", "hpTunnelIfIndex"), ("HP-TUNNEL-MIB", "hpTunnelEncapsMethod"), ("HP-TUNNEL-MIB", "hpTunnelIfPMTU"), ("HP-TUNNEL-MIB", "hpTunnelIfMTU"), ("HP-TUNNEL-MIB", "hpTunnelIfNUD"), ("HP-TUNNEL-MIB", "hpTunnelRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpTunnelProvisionGroup = hpTunnelProvisionGroup.setStatus('deprecated')
if mibBuilder.loadTexts: hpTunnelProvisionGroup.setDescription('A collection of objects to support creation of a tunnel.')
hpTunnelInetConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 2, 2)).setObjects(("HP-TUNNEL-MIB", "hpTunnelInetConfigEncapsMethod"), ("HP-TUNNEL-MIB", "hpTunnelIpsecName"), ("HP-TUNNEL-MIB", "hpicfUDPTunnelType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpTunnelInetConfigGroup = hpTunnelInetConfigGroup.setStatus('current')
if mibBuilder.loadTexts: hpTunnelInetConfigGroup.setDescription('A collection of objects to augment tunnelInetConfigTable.')
hpVlanTunnelMappingGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 2, 3)).setObjects(("HP-TUNNEL-MIB", "hpicfVlanTunnelMappingRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpVlanTunnelMappingGroup = hpVlanTunnelMappingGroup.setStatus('current')
if mibBuilder.loadTexts: hpVlanTunnelMappingGroup.setDescription('A collection of objects to support VLAN to tunnel mapping.')
hpTunnelProvisionGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 2, 4)).setObjects(("HP-TUNNEL-MIB", "hpTunnelInterfaceIndex"), ("HP-TUNNEL-MIB", "hpTunnelEncapsMethod"), ("HP-TUNNEL-MIB", "hpTunnelIfPMTU"), ("HP-TUNNEL-MIB", "hpTunnelIfMTU"), ("HP-TUNNEL-MIB", "hpTunnelIfNUD"), ("HP-TUNNEL-MIB", "hpTunnelRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpTunnelProvisionGroup2 = hpTunnelProvisionGroup2.setStatus('current')
if mibBuilder.loadTexts: hpTunnelProvisionGroup2.setDescription('A collection of objects to support creation of a tunnel.')
hpTunnelNotifyScalarsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 2, 5)).setObjects(("HP-TUNNEL-MIB", "hpTunnelMTUDropRouterAddrType"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropRouterAddr"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropRouterMTU"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelSrcAddrType"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelSource"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelDstAddrType"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropTunnelDest"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropInIfIndex"), ("HP-TUNNEL-MIB", "hpTunnelMTUDropNotifyEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpTunnelNotifyScalarsGroup = hpTunnelNotifyScalarsGroup.setStatus('current')
if mibBuilder.loadTexts: hpTunnelNotifyScalarsGroup.setDescription('Group of objects required for notifications.')
hpTunnelNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 77, 2, 2, 6)).setObjects(("HP-TUNNEL-MIB", "hpTunnelIcmpErrorRcvd"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpTunnelNotificationsGroup = hpTunnelNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: hpTunnelNotificationsGroup.setDescription('The notifications for the VXLAN/Tap tunnels.')
mibBuilder.exportSymbols("HP-TUNNEL-MIB", hpTunnelObjects=hpTunnelObjects, hpTunnelConfigEntry=hpTunnelConfigEntry, hpTunnelMTUDropRouterAddr=hpTunnelMTUDropRouterAddr, hpTunnelMIBCompliances=hpTunnelMIBCompliances, hpTunnelInetConfigGroup=hpTunnelInetConfigGroup, hpicfUDPTunnelTypeTable=hpicfUDPTunnelTypeTable, hpTunnelMTUDropTunnelDest=hpTunnelMTUDropTunnelDest, hpTunnelIfPMTU=hpTunnelIfPMTU, hpTunnelConfigTable=hpTunnelConfigTable, hpTunnelIfNUD=hpTunnelIfNUD, hpTunnelInetConfigEncapsMethod=hpTunnelInetConfigEncapsMethod, PYSNMP_MODULE_ID=hpTunnelMIB, hpTunnelMTUDropTunnelSource=hpTunnelMTUDropTunnelSource, hpTunnelMTUDropNotifyEnable=hpTunnelMTUDropNotifyEnable, hpTunnelIpsecName=hpTunnelIpsecName, hpTunnelInetConfigTable=hpTunnelInetConfigTable, hpTunnelMIBCompliance=hpTunnelMIBCompliance, hpTunnelNotifyScalarsGroup=hpTunnelNotifyScalarsGroup, hpTunnelMTUDropTunnelDstAddrType=hpTunnelMTUDropTunnelDstAddrType, hpTunnelConformance=hpTunnelConformance, hpTunnelInterfaceIndex=hpTunnelInterfaceIndex, hpTunnelRowStatus=hpTunnelRowStatus, hpTunnelIfIndex=hpTunnelIfIndex, hpTunnelInetConfigEntry=hpTunnelInetConfigEntry, hpicfVLANIndex=hpicfVLANIndex, hpTunnelMIBGroups=hpTunnelMIBGroups, hpTunnelMIBCompliance2=hpTunnelMIBCompliance2, hpTunnelProvisionGroup=hpTunnelProvisionGroup, hpTunnelMTUDropRouterAddrType=hpTunnelMTUDropRouterAddrType, hpTunnelMTUDropTunnelSrcAddrType=hpTunnelMTUDropTunnelSrcAddrType, hpicfUDPTunnelType=hpicfUDPTunnelType, hpTunnelNotifications=hpTunnelNotifications, hpTunnelMTUDropInIfIndex=hpTunnelMTUDropInIfIndex, hpTunnelNotifyScalars=hpTunnelNotifyScalars, hpTunnelIfMTU=hpTunnelIfMTU, hpicfVlanTunnelMappingRowStatus=hpicfVlanTunnelMappingRowStatus, HpTunnelType=HpTunnelType, hpTunnelMTUDropRouterMTU=hpTunnelMTUDropRouterMTU, hpicfVlanTunnelMappingTable=hpicfVlanTunnelMappingTable, hpTunnelIfEntry=hpTunnelIfEntry, hpTunnelMIB=hpTunnelMIB, hpVlanTunnelMappingGroup=hpVlanTunnelMappingGroup, hpTunnelIfTable=hpTunnelIfTable, hpTunnelNotificationsGroup=hpTunnelNotificationsGroup, hpTunnelID=hpTunnelID, hpicfVlanTunnelMappingEntry=hpicfVlanTunnelMappingEntry, hpicfTunnelIfIndex=hpicfTunnelIfIndex, hpTunnelEncapsMethod=hpTunnelEncapsMethod, hpTunnelIcmpErrorRcvd=hpTunnelIcmpErrorRcvd, hpicfUDPTunnelTypeEntry=hpicfUDPTunnelTypeEntry, hpTunnelProvisionGroup2=hpTunnelProvisionGroup2)

#
# PySNMP MIB module TimesTen (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/TimesTen
# Produced by pysmi-0.3.4 at Wed May  1 15:28:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
NotificationType, ModuleIdentity, Integer32, ObjectIdentity, Counter32, MibIdentifier, TimeTicks, Gauge32, NotificationType, enterprises, IpAddress, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "ModuleIdentity", "Integer32", "ObjectIdentity", "Counter32", "MibIdentifier", "TimeTicks", "Gauge32", "NotificationType", "enterprises", "IpAddress", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "iso", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
timesten = MibIdentifier((1, 3, 6, 1, 4, 1, 5549))
ttSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 1))
ttTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 5549, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: ttTimeStamp.setDescription('A TimeStamp String.')
ttVersion = MibScalar((1, 3, 6, 1, 4, 1, 5549, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttVersion.setStatus('mandatory')
if mibBuilder.loadTexts: ttVersion.setDescription('TimesTen version string')
ttPid = MibScalar((1, 3, 6, 1, 4, 1, 5549, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttPid.setStatus('mandatory')
if mibBuilder.loadTexts: ttPid.setDescription('Process ID String')
ttProcessName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttProcessName.setStatus('obsolete')
if mibBuilder.loadTexts: ttProcessName.setDescription('Process Name String')
ttUid = MibScalar((1, 3, 6, 1, 4, 1, 5549, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttUid.setStatus('mandatory')
if mibBuilder.loadTexts: ttUid.setDescription('User ID String')
ttUserName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttUserName.setStatus('obsolete')
if mibBuilder.loadTexts: ttUserName.setDescription('User Name String')
ttMsg = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 2))
ttMesg = MibScalar((1, 3, 6, 1, 4, 1, 5549, 2, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttMesg.setStatus('mandatory')
if mibBuilder.loadTexts: ttMesg.setDescription('Generic Message String')
ttTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5))
ttAssertTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5, 1))
ttDSTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5, 10))
ttFileTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5, 20))
ttDaemonTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5, 40))
ttRepTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5, 50))
ttOraTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5, 60))
ttRecoveryTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 5, 70))
ttTrapTruncated = MibScalar((1, 3, 6, 1, 4, 1, 5549, 5, 100), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttTrapTruncated.setStatus('mandatory')
if mibBuilder.loadTexts: ttTrapTruncated.setDescription('1 If the trap is too large and has been truncated.')
ttDataStore = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 10))
ttDSName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSName.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSName.setDescription('Data store name')
ttDSPath = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSPath.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSPath.setDescription('Data store path')
ttDSShmKey = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSShmKey.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSShmKey.setDescription('Data store Shared Memory ID/Key')
ttDSNConn = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSNConn.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSNConn.setDescription('Connection number. Starting with 0.')
ttDSMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSMaxSize.setDescription('Maximum size of data store, in KB.')
ttDSCurSize = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSCurSize.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSCurSize.setDescription('Current size of data store, in KB.')
ttDSReqSize = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSReqSize.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSReqSize.setDescription('Requested increase in data store size, in KB.')
ttDSPartition = MibScalar((1, 3, 6, 1, 4, 1, 5549, 10, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDSPartition.setStatus('mandatory')
if mibBuilder.loadTexts: ttDSPartition.setDescription('Name of the data store partition, ie. Permanent or Temporary.')
ttFile = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 20))
ttFilePath = MibScalar((1, 3, 6, 1, 4, 1, 5549, 20, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttFilePath.setStatus('mandatory')
if mibBuilder.loadTexts: ttFilePath.setDescription('Full path of file.')
ttReadSize = MibScalar((1, 3, 6, 1, 4, 1, 5549, 20, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ttReadSize.setStatus('mandatory')
if mibBuilder.loadTexts: ttReadSize.setDescription('Number of bytes successfully read from a file.')
ttReadReq = MibScalar((1, 3, 6, 1, 4, 1, 5549, 20, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttReadReq.setStatus('mandatory')
if mibBuilder.loadTexts: ttReadReq.setDescription('Number of bytes requested to be read from a file.')
ttWriteSize = MibScalar((1, 3, 6, 1, 4, 1, 5549, 20, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttWriteSize.setStatus('mandatory')
if mibBuilder.loadTexts: ttWriteSize.setDescription('Number of bytes successfully written to a file.')
ttWriteReq = MibScalar((1, 3, 6, 1, 4, 1, 5549, 20, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttWriteReq.setStatus('mandatory')
if mibBuilder.loadTexts: ttWriteReq.setDescription('Number of bytes requested to be written to a file.')
ttDaemon = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 40))
ttDaeName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 40, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDaeName.setStatus('mandatory')
if mibBuilder.loadTexts: ttDaeName.setDescription('Executable name of daemon, ie. timestend or timestensubd.')
ttDaePid = MibScalar((1, 3, 6, 1, 4, 1, 5549, 40, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDaePid.setStatus('mandatory')
if mibBuilder.loadTexts: ttDaePid.setDescription('Process ID of the daemon.')
ttDaeInst = MibScalar((1, 3, 6, 1, 4, 1, 5549, 40, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttDaeInst.setStatus('mandatory')
if mibBuilder.loadTexts: ttDaeInst.setDescription('Daemon number, starting with 0.')
ttReplication = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 50))
ttRepPid = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepPid.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepPid.setDescription('Process ID of replication agent.')
ttRepName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepName.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepName.setDescription('This is last component of my datastore path name.')
ttRepPeerStoreID = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepPeerStoreID.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepPeerStoreID.setDescription('The unique Store-ID of my peer (master or subscriber).')
ttRepPeerName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepPeerName.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepPeerName.setDescription("This is last component of my peer's datastore path name.")
ttRepMasterHost = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepMasterHost.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepMasterHost.setDescription("The master's host name.")
ttRepMasterPort = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepMasterPort.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepMasterPort.setDescription("The master's port.")
ttRepSubscriberHost = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepSubscriberHost.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepSubscriberHost.setDescription("The subscriber's host name.")
ttRepSubscriberPort = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepSubscriberPort.setStatus('mandatory')
if mibBuilder.loadTexts: ttRepSubscriberPort.setDescription("The subscriber's port.")
ttRepTable = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepTable.setStatus('mandatory')
ttRepAction = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepAction.setStatus('mandatory')
ttRepReason = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepReason.setStatus('mandatory')
ttRepConflictKey = MibScalar((1, 3, 6, 1, 4, 1, 5549, 50, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttRepConflictKey.setStatus('mandatory')
ttOraCache = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 60))
ttOraAgentName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 60, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttOraAgentName.setStatus('mandatory')
if mibBuilder.loadTexts: ttOraAgentName.setDescription('Executable path name of Oracle Cache agent.')
ttOraAgentPid = MibScalar((1, 3, 6, 1, 4, 1, 5549, 60, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttOraAgentPid.setStatus('mandatory')
if mibBuilder.loadTexts: ttOraAgentPid.setDescription('Process ID of Orache Cache agent.')
ttOraDSName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 60, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttOraDSName.setStatus('mandatory')
if mibBuilder.loadTexts: ttOraDSName.setDescription('Name of TimesTen data store used by Oracle Cache Agent.')
ttOraCacheGroupName = MibScalar((1, 3, 6, 1, 4, 1, 5549, 60, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ttOraCacheGroupName.setStatus('mandatory')
if mibBuilder.loadTexts: ttOraCacheGroupName.setDescription('Name of cache groups managed Oracle Cache Agent.')
ttRecovery = MibIdentifier((1, 3, 6, 1, 4, 1, 5549, 70))
endLFN = MibScalar((1, 3, 6, 1, 4, 1, 5549, 70, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: endLFN.setStatus('mandatory')
if mibBuilder.loadTexts: endLFN.setDescription('Last log file number reached during data store recovery.')
endLFO = MibScalar((1, 3, 6, 1, 4, 1, 5549, 70, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: endLFO.setStatus('mandatory')
if mibBuilder.loadTexts: endLFO.setDescription('Last log file offset reached during data store recovery.')
maxLFN = MibScalar((1, 3, 6, 1, 4, 1, 5549, 70, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: maxLFN.setStatus('mandatory')
if mibBuilder.loadTexts: maxLFN.setDescription('Maximum log file number expected during data store recovery.')
ttAssertFailTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 1) + (0,1)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"))
if mibBuilder.loadTexts: ttAssertFailTrap.setDescription('TimesTen assertion failure.')
ttMainDaemonReadyTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 40) + (0,2)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDaeName"), ("TimesTen", "ttDaeInst"), ("TimesTen", "ttDaePid"))
if mibBuilder.loadTexts: ttMainDaemonReadyTrap.setDescription('Main or sub daemons starting.')
ttMainDaemonExitingTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 40) + (0,3)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDaeName"), ("TimesTen", "ttDaeInst"), ("TimesTen", "ttDaePid"))
if mibBuilder.loadTexts: ttMainDaemonExitingTrap.setDescription('Main or sub daemons exiting normally.')
ttMainDaemonDiedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 40) + (0,4)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDaeName"), ("TimesTen", "ttDaeInst"), ("TimesTen", "ttDaePid"))
if mibBuilder.loadTexts: ttMainDaemonDiedTrap.setDescription('Main or sub daemons died abnormally.')
ttDSGoingInvalidTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 10) + (0,5)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"), ("TimesTen", "ttDSShmKey"), ("TimesTen", "ttDSNConn"))
if mibBuilder.loadTexts: ttDSGoingInvalidTrap.setDescription('Setting data store to invalid state.')
ttRepAgentStartingTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,6)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"))
if mibBuilder.loadTexts: ttRepAgentStartingTrap.setDescription('Replication agent starting.')
ttRepAgentExitingTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,7)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"))
if mibBuilder.loadTexts: ttRepAgentExitingTrap.setDescription('Replication agent exiting normally.')
ttRepAgentDiedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,8)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"), ("TimesTen", "ttRepPid"))
if mibBuilder.loadTexts: ttRepAgentDiedTrap.setDescription('Replication agent died abnormally.')
ttRepUpdateFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,9)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttRepPeerStoreID"), ("TimesTen", "ttRepName"), ("TimesTen", "ttDSName"), ("TimesTen", "ttRepReason"), ("TimesTen", "ttRepTable"), ("TimesTen", "ttRepAction"), ("TimesTen", "ttRepPeerName"), ("TimesTen", "ttRepConflictKey"))
if mibBuilder.loadTexts: ttRepUpdateFailedTrap.setDescription('A replication insert, update or delete operation failed.')
ttRepSubscriberFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,10)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttRepPeerStoreID"), ("TimesTen", "ttRepName"), ("TimesTen", "ttDSName"), ("TimesTen", "ttRepReason"), ("TimesTen", "ttRepSubscriberHost"), ("TimesTen", "ttRepSubscriberPort"))
if mibBuilder.loadTexts: ttRepSubscriberFailedTrap.setDescription('Subscriber marked as failed because too much log accumulated on its behalf by the master.')
ttPartitionSpaceStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 10) + (0,11)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"), ("TimesTen", "ttDSMaxSize"), ("TimesTen", "ttDSCurSize"), ("TimesTen", "ttDSReqSize"), ("TimesTen", "ttDSPartition"))
if mibBuilder.loadTexts: ttPartitionSpaceStateTrap.setDescription('Data store partition (permanent or temporary) space is transitioning from OK to Low, or vice versa.')
ttPartitionSpaceExhaustedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 10) + (0,12)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"), ("TimesTen", "ttDSMaxSize"), ("TimesTen", "ttDSCurSize"), ("TimesTen", "ttDSReqSize"), ("TimesTen", "ttDSPartition"))
if mibBuilder.loadTexts: ttPartitionSpaceExhaustedTrap.setDescription('Data store partition (permanent or temporary) space is exhausted.')
ttDaemonOutOfMemoryTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 40) + (0,13)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDaeName"), ("TimesTen", "ttDaeInst"))
if mibBuilder.loadTexts: ttDaemonOutOfMemoryTrap.setDescription('Call to malloc failed in TimesTen daemon.')
ttOraAutoRefQueFullTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 60) + (0,14)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttOraAgentPid"), ("TimesTen", "ttOraAgentName"))
if mibBuilder.loadTexts: ttOraAutoRefQueFullTrap.setDescription('TimesTen Oracle Connect autorefresh queue is full.')
ttOraIncAutoRefFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 60) + (0,15)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttOraAgentPid"), ("TimesTen", "ttOraAgentName"), ("TimesTen", "ttOraDSName"))
if mibBuilder.loadTexts: ttOraIncAutoRefFailedTrap.setDescription('TimesTen Oracle Connect incremental autorefresh failed.')
ttOraAgentDiedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 60) + (0,17)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttOraAgentPid"), ("TimesTen", "ttOraDSName"))
if mibBuilder.loadTexts: ttOraAgentDiedTrap.setDescription('TimesTen Oracle Connect daemon died.')
ttRepReturnReceiptTransitionTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,19)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttRepPeerStoreID"), ("TimesTen", "ttRepName"), ("TimesTen", "ttDSName"), ("TimesTen", "ttRepReason"), ("TimesTen", "ttRepSubscriberHost"))
if mibBuilder.loadTexts: ttRepReturnReceiptTransitionTrap.setDescription('Return receipt has been disabled or enabled on the subscriber.')
ttFileWriteErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 20) + (0,20)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"), ("TimesTen", "ttFilePath"), ("TimesTen", "ttWriteSize"), ("TimesTen", "ttWriteReq"))
if mibBuilder.loadTexts: ttFileWriteErrorTrap.setDescription('Error encountered during file I/O write.')
ttDSDataCorruptionTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 10) + (0,21)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"))
if mibBuilder.loadTexts: ttDSDataCorruptionTrap.setDescription('TimesTen Internal Data Corruption.')
ttUnexpectedEndOfLogTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 70) + (0,22)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"), ("TimesTen", "endLFN"), ("TimesTen", "endLFO"), ("TimesTen", "maxLFN"))
if mibBuilder.loadTexts: ttUnexpectedEndOfLogTrap.setDescription('Premature end of log file reached during data store recovery.')
ttRepCatchupStartTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,23)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"))
if mibBuilder.loadTexts: ttRepCatchupStartTrap.setDescription('Replication Master Catchup starting.')
ttRepCatchupStopTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 50) + (0,24)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttDSName"))
if mibBuilder.loadTexts: ttRepCatchupStopTrap.setDescription('Replication Master Catchup stopping.')
ttOraValidationErrorTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 60) + (0,25)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttOraAgentPid"), ("TimesTen", "ttOraAgentName"), ("TimesTen", "ttOraDSName"))
if mibBuilder.loadTexts: ttOraValidationErrorTrap.setDescription('TimesTen Oracle Connect detected serious error during self validation.')
ttOraValidationWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 60) + (0,26)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttOraAgentPid"), ("TimesTen", "ttOraAgentName"), ("TimesTen", "ttOraDSName"))
if mibBuilder.loadTexts: ttOraValidationWarningTrap.setDescription('TimesTen Oracle Connect detected non-fatal error during self validation.')
ttOraValidationAbortedTrap = NotificationType((1, 3, 6, 1, 4, 1, 5549, 5, 60) + (0,27)).setObjects(("TimesTen", "ttTimeStamp"), ("TimesTen", "ttPid"), ("TimesTen", "ttUid"), ("TimesTen", "ttVersion"), ("TimesTen", "ttMesg"), ("TimesTen", "ttOraAgentPid"), ("TimesTen", "ttOraAgentName"), ("TimesTen", "ttOraDSName"))
if mibBuilder.loadTexts: ttOraValidationAbortedTrap.setDescription('TimesTen Oracle Connect aborted self validation.')
mibBuilder.exportSymbols("TimesTen", ttDSReqSize=ttDSReqSize, ttRepReason=ttRepReason, ttRepCatchupStopTrap=ttRepCatchupStopTrap, ttOraValidationAbortedTrap=ttOraValidationAbortedTrap, ttDSTraps=ttDSTraps, ttOraAgentDiedTrap=ttOraAgentDiedTrap, ttReadSize=ttReadSize, maxLFN=maxLFN, ttTrapTruncated=ttTrapTruncated, ttDSShmKey=ttDSShmKey, ttRepTraps=ttRepTraps, ttUserName=ttUserName, ttOraAutoRefQueFullTrap=ttOraAutoRefQueFullTrap, ttRepSubscriberHost=ttRepSubscriberHost, ttUnexpectedEndOfLogTrap=ttUnexpectedEndOfLogTrap, ttRepCatchupStartTrap=ttRepCatchupStartTrap, ttDSDataCorruptionTrap=ttDSDataCorruptionTrap, ttVersion=ttVersion, ttDaemon=ttDaemon, ttOraDSName=ttOraDSName, ttMsg=ttMsg, ttFileWriteErrorTrap=ttFileWriteErrorTrap, ttDSPartition=ttDSPartition, ttUid=ttUid, ttAssertFailTrap=ttAssertFailTrap, ttOraIncAutoRefFailedTrap=ttOraIncAutoRefFailedTrap, ttOraCacheGroupName=ttOraCacheGroupName, ttReplication=ttReplication, ttFile=ttFile, ttPartitionSpaceStateTrap=ttPartitionSpaceStateTrap, ttProcessName=ttProcessName, ttSystem=ttSystem, timesten=timesten, ttRepSubscriberPort=ttRepSubscriberPort, ttRepSubscriberFailedTrap=ttRepSubscriberFailedTrap, ttOraValidationErrorTrap=ttOraValidationErrorTrap, ttRepPeerStoreID=ttRepPeerStoreID, ttDSCurSize=ttDSCurSize, ttReadReq=ttReadReq, endLFO=endLFO, ttAssertTraps=ttAssertTraps, ttDSName=ttDSName, ttRepAgentExitingTrap=ttRepAgentExitingTrap, ttPartitionSpaceExhaustedTrap=ttPartitionSpaceExhaustedTrap, ttTraps=ttTraps, ttRecoveryTraps=ttRecoveryTraps, ttRepUpdateFailedTrap=ttRepUpdateFailedTrap, ttMesg=ttMesg, ttFilePath=ttFilePath, endLFN=endLFN, ttOraValidationWarningTrap=ttOraValidationWarningTrap, ttMainDaemonExitingTrap=ttMainDaemonExitingTrap, ttDaemonOutOfMemoryTrap=ttDaemonOutOfMemoryTrap, ttDataStore=ttDataStore, ttDSMaxSize=ttDSMaxSize, ttDaePid=ttDaePid, ttRepName=ttRepName, ttRepPeerName=ttRepPeerName, ttRepAgentStartingTrap=ttRepAgentStartingTrap, ttRecovery=ttRecovery, ttOraTraps=ttOraTraps, ttDaeName=ttDaeName, ttDSNConn=ttDSNConn, ttWriteReq=ttWriteReq, ttDSPath=ttDSPath, ttDSGoingInvalidTrap=ttDSGoingInvalidTrap, ttDaemonTraps=ttDaemonTraps, ttOraCache=ttOraCache, ttTimeStamp=ttTimeStamp, ttMainDaemonDiedTrap=ttMainDaemonDiedTrap, ttOraAgentPid=ttOraAgentPid, ttRepAction=ttRepAction, ttRepMasterPort=ttRepMasterPort, ttFileTraps=ttFileTraps, ttRepTable=ttRepTable, ttRepPid=ttRepPid, ttDaeInst=ttDaeInst, ttRepMasterHost=ttRepMasterHost, ttPid=ttPid, ttWriteSize=ttWriteSize, ttRepReturnReceiptTransitionTrap=ttRepReturnReceiptTransitionTrap, ttRepAgentDiedTrap=ttRepAgentDiedTrap, ttOraAgentName=ttOraAgentName, ttRepConflictKey=ttRepConflictKey, ttMainDaemonReadyTrap=ttMainDaemonReadyTrap)

#
# PySNMP MIB module PAIRGAIN-AGENT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PAIRGAIN-AGENT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:36:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
pgainAgent, = mibBuilder.importSymbols("PAIRGAIN-COMMON-HD-MIB", "pgainAgent")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter64, Integer32, MibIdentifier, Unsigned32, IpAddress, TimeTicks, iso, ModuleIdentity, Gauge32, Bits, Counter32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "Integer32", "MibIdentifier", "Unsigned32", "IpAddress", "TimeTicks", "iso", "ModuleIdentity", "Gauge32", "Bits", "Counter32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class DisplayString(OctetString):
    pass

pgAgentSw = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 2, 1))
pgAgentNetProtocol = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 2, 2))
pgSnmpAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 2, 3))
pgAgentHw = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 2, 4))
pgAgentLocImage = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 2, 5))
pgAgentType = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("pgCMU", 2), ("pgHMU", 3), ("pgEMU", 4), ("pgDMU", 5), ("pgMBMTiger", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgAgentType.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentType.setDescription("The agent's Unit type.")
pgAgentFwVer = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgAgentFwVer.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentFwVer.setDescription("The agent's Unit major firmware version number 0=Rev. A, 1=Rev. B, etc.")
pgAgentSwVer = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgAgentSwVer.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentSwVer.setDescription("The agent's software version number in string format: 1.1 = major swftware version number 1, minor version 2. For pgAgentType = pgDMU, the format is XX.YY.ZZ where XX represents the software feature release: 10-20 MuxWare 30-40 SwitchWare 50-60 Interware YY is incremented to indicate major changes that may affect backward compatibility. ZZ is incremented to represent minor changes to the system. When a string of zero length is returned, it means either the version.txt file is missing or the string format in the file is incorrect.")
pgAgentBootProtocol = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("bootp-tftp", 2), ("tftp-only", 3), ("ftp-only", 4), ("proprietary", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgAgentBootProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentBootProtocol.setDescription('Boot protocol used to load the Unit with its image software.')
pgAgentBootFile = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentBootFile.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentBootFile.setDescription('The name of the boot file that is sent to the file server during boot time. The actual boot protocol used to retrieve the file is determined by pgAgentBootProtocol.')
pgAgentAuthTraps = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("disable", 2), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentAuthTraps.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentAuthTraps.setDescription('Enable or disable the use of authentication error trap generation.')
pgAgentTraps = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1))).clone(namedValues=NamedValues(("disable", 2), ("enable", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentTraps.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentTraps.setDescription('Enable or disable the use of all trap generation.')
pgAgentMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgAgentMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentMibLevel.setDescription('Used to determine current MIB release supported by agent. The encoding of this object is of the following form: xyy, where x is the major version number and yy is the minor version number. Thus, version 3.0 would be represented as 300, version 3.01 would be 301 and 3.1 would be 310. Object is in decimal.')
pgAgentMySlotId = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgAgentMySlotId.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentMySlotId.setDescription('Slot where this agent currently resides. If hardware is unable to determine then a 0 should be returned. This object is useful if multiple management units are installed in different slots of a PairGain chassis.')
pgAgentIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 2, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentIpAddr.setDescription("The network management unit's administrative IP address. The current operational IP address can be obtained by the ipAdEntAddr entry in the ipAddrTable.")
pgAgentNetMask = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 2, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentNetMask.setDescription('The network management units administrative subnet mask. The current operational subnet mask can be obtained by the ipAdEntNetMask entry in the ipAddrTable.')
pgAgentDefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 2, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentDefaultGateway.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentDefaultGateway.setDescription("The network management units administrative default gateway IP address. The current operational default gateway's IP address can be obtained from the ipRoutingTable.")
pgAgentBootServerAddr = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 2, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentBootServerAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentBootServerAddr.setDescription('The IP address to which the requests for boot files are sent. The protocol used to retrieve the boot files is determined by object pgAgentBootProtocol.')
pgAgentTrapReceiverTable = MibTable((1, 3, 6, 1, 4, 1, 927, 1, 2, 3, 1), )
if mibBuilder.loadTexts: pgAgentTrapReceiverTable.setStatus('optional')
if mibBuilder.loadTexts: pgAgentTrapReceiverTable.setDescription("Table containing list of NMS's that are to receive traps generated by this agent.")
pgAgentTrapReceiverEntry = MibTableRow((1, 3, 6, 1, 4, 1, 927, 1, 2, 3, 1, 1), ).setIndexNames((0, "PAIRGAIN-AGENT-MIB", "pgAgentTrapRcvrNetAddress"))
if mibBuilder.loadTexts: pgAgentTrapReceiverEntry.setStatus('optional')
if mibBuilder.loadTexts: pgAgentTrapReceiverEntry.setDescription('A destination address and community string to a particular trap server, along with a trap filter and entry aging capability.')
pgAgentTrapRcvrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("valid", 2), ("invalid", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentTrapRcvrStatus.setStatus('optional')
if mibBuilder.loadTexts: pgAgentTrapRcvrStatus.setDescription('Setting this object to the value invalid(3) has the effect of invalidating the corresponding entry in the pgAgentTrapReceiverTable. That is, it effectively disassociates the address identified with the entry by removing the entry from the table. On a read the value of valid(2) should be returned if the entry contains a valid record, or invalid(3) should be returned if the entry contains an invalid record.')
pgAgentTrapRcvrNetAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 2, 3, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentTrapRcvrNetAddress.setStatus('optional')
if mibBuilder.loadTexts: pgAgentTrapRcvrNetAddress.setDescription('IP address for trap server that is to receive the trap.')
pgAgentTrapRcvrComm = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 2, 3, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentTrapRcvrComm.setStatus('optional')
if mibBuilder.loadTexts: pgAgentTrapRcvrComm.setDescription('Community string used for traps sent to this trap receiver.')
pgAgentReset = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noReset", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentReset.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentReset.setDescription('Network management unit reset status. Writing a reset(2) to this object will reset the agent and perform a download and restart.')
pgAgentRestart = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noRestart", 1), ("restart", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentRestart.setStatus('optional')
if mibBuilder.loadTexts: pgAgentRestart.setDescription('Network management unit restart status. Writing a restart(2) to this object will restart the agent. This initializes all the counters, re-reads the NVRAM data structure and starts executing from the beginning of the code.')
pgAgentBootMode = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nvram", 1), ("network", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentBootMode.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentBootMode.setDescription('The method for obtaining boot parameter information. This parameter will not take effect until written into NVRAM (pgAgentWriteNvram) and a reset (pgAgentReset) is issued.')
pgAgentWriteNvram = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noWriteNvram", 1), ("writeNvram", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgAgentWriteNvram.setStatus('mandatory')
if mibBuilder.loadTexts: pgAgentWriteNvram.setDescription('Network management unit NVRAM write status. Writing a (2) to this object will write the contents of current NVRAM data structure in the NVRAM.')
pgLocImageValid = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("localImageValid", 2), ("localImageInvalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgLocImageValid.setStatus('optional')
if mibBuilder.loadTexts: pgLocImageValid.setDescription('This indicates whether the agent has a valid local code image on board. A FLASH checksum failure would cause the agent to return localImageInvalid(3).')
pgLocImageVersion = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 5, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgLocImageVersion.setStatus('optional')
if mibBuilder.loadTexts: pgLocImageVersion.setDescription('The major and minor software version number of the locally-stored image in string format. This object applies only to agents with valid local image. Other agents should return zero.')
pgLocImageLoadMode = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("network", 2), ("localBoot", 3), ("localAsBackup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgLocImageLoadMode.setStatus('optional')
if mibBuilder.loadTexts: pgLocImageLoadMode.setDescription('This indicates whether the agent should get code from the network, use a local image, or try the network first and then fall back to local image if the network boot fails.')
pgLocImageActualSource = MibScalar((1, 3, 6, 1, 4, 1, 927, 1, 2, 5, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("remoteImage", 2), ("localImage", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgLocImageActualSource.setStatus('optional')
if mibBuilder.loadTexts: pgLocImageActualSource.setDescription('This indicates whether the agent loaded code from the network or used a local image. When the the ImageLoadMode is localAsBackup, this variable indicates whether the network load was successful.')
mibBuilder.exportSymbols("PAIRGAIN-AGENT-MIB", pgAgentBootFile=pgAgentBootFile, pgLocImageActualSource=pgLocImageActualSource, pgAgentIpAddr=pgAgentIpAddr, pgAgentTrapRcvrStatus=pgAgentTrapRcvrStatus, pgAgentWriteNvram=pgAgentWriteNvram, pgAgentMibLevel=pgAgentMibLevel, pgAgentTrapRcvrNetAddress=pgAgentTrapRcvrNetAddress, pgAgentBootMode=pgAgentBootMode, pgAgentDefaultGateway=pgAgentDefaultGateway, pgAgentHw=pgAgentHw, pgAgentAuthTraps=pgAgentAuthTraps, pgAgentLocImage=pgAgentLocImage, pgAgentSw=pgAgentSw, pgAgentTrapReceiverTable=pgAgentTrapReceiverTable, pgAgentMySlotId=pgAgentMySlotId, pgAgentRestart=pgAgentRestart, pgAgentTrapReceiverEntry=pgAgentTrapReceiverEntry, pgAgentFwVer=pgAgentFwVer, pgLocImageLoadMode=pgLocImageLoadMode, pgLocImageValid=pgLocImageValid, pgAgentNetProtocol=pgAgentNetProtocol, pgAgentBootProtocol=pgAgentBootProtocol, DisplayString=DisplayString, pgSnmpAgent=pgSnmpAgent, pgAgentReset=pgAgentReset, pgAgentTrapRcvrComm=pgAgentTrapRcvrComm, pgAgentNetMask=pgAgentNetMask, pgAgentBootServerAddr=pgAgentBootServerAddr, pgAgentTraps=pgAgentTraps, pgAgentType=pgAgentType, pgAgentSwVer=pgAgentSwVer, pgLocImageVersion=pgLocImageVersion)

#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-LogicalProcessorMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-LogicalProcessorMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:00 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
StorageType, RowStatus, Integer32, Counter32, Unsigned32, DisplayString, Gauge32, RowPointer, InterfaceIndex = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "StorageType", "RowStatus", "Integer32", "Counter32", "Unsigned32", "DisplayString", "Gauge32", "RowPointer", "InterfaceIndex")
EnterpriseDateAndTime, AsciiString, PassportCounter64, Hex, Link, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "EnterpriseDateAndTime", "AsciiString", "PassportCounter64", "Hex", "Link", "NonReplicated")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Bits, Integer32, NotificationType, iso, Counter32, MibIdentifier, Unsigned32, IpAddress, Counter64, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, TimeTicks, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "NotificationType", "iso", "Counter32", "MibIdentifier", "Unsigned32", "IpAddress", "Counter64", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "TimeTicks", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
logicalProcessorMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11))
mscLp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12))
mscLpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 1), )
if mibBuilder.loadTexts: mscLpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpRowStatusTable.setDescription('This entry controls the addition and deletion of mscLp components.')
mscLpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"))
if mibBuilder.loadTexts: mscLpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpRowStatusEntry.setDescription('A single entry in the table represents a single mscLp component.')
mscLpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLp components. These components can be added and deleted.')
mscLpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpStorageType.setDescription('This variable represents the storage type value for the mscLp tables.')
mscLpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscLpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpIndex.setDescription('This variable represents the index for the mscLp tables.')
mscLpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 100), )
if mibBuilder.loadTexts: mscLpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpProvTable.setDescription('This Group contains the provisionable attributes for the LP component.')
mscLpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"))
if mibBuilder.loadTexts: mscLpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpProvEntry.setDescription('An entry in the mscLpProvTable.')
mscLpMainCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 100, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpMainCard.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMainCard.setDescription('This is the preferred processor card on which this LP should be assigned.')
mscLpSpareCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 100, 1, 2), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSpareCard.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSpareCard.setDescription('This is the spare processor card on which this LP should be assigned.')
mscLpLogicalProcessorType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 100, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpLogicalProcessorType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLogicalProcessorType.setDescription('This is the Logical Processor Type (LPT) that determines which software this LP will run.')
mscLpCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 101), )
if mibBuilder.loadTexts: mscLpCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"))
if mibBuilder.loadTexts: mscLpCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCidDataEntry.setDescription('An entry in the mscLpCidDataTable.')
mscLpCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 101, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102), )
if mibBuilder.loadTexts: mscLpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"))
if mibBuilder.loadTexts: mscLpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpStateEntry.setDescription('An entry in the mscLpStateTable.')
mscLpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 102, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 103), )
if mibBuilder.loadTexts: mscLpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpOperTable.setDescription('This Group contains the operational attributes for the LP component.')
mscLpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 103, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"))
if mibBuilder.loadTexts: mscLpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpOperEntry.setDescription('An entry in the mscLpOperTable.')
mscLpActiveCard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 103, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpActiveCard.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpActiveCard.setDescription('This attribute indicates on which card this LP is currently running (if any).')
mscLpMainCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 103, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4))).clone(namedValues=NamedValues(("notProvisioned", 0), ("notAvailable", 1), ("available", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMainCardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMainCardStatus.setDescription("This attribute specifies the status of this LP's main card. The following values have been defined: notProvisioned No main card has been provisioned. notAvailable The main card is not available. available The main card is available (running as standby). active The main card is running as active.")
mscLpSpareCardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 103, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notProvisioned", 0), ("notAvailable", 1), ("alreadyInUse", 2), ("available", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSpareCardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSpareCardStatus.setDescription("This attribute specifies the status of this LP's spare card. The following values have been defined: notProvisioned No spare card has been provisioned. notAvailable The spare card is not available. alreadyInUse The spare card is already in use by another LP. available The spare card is available (running as standby). active The spare card is running as active.")
mscLpRestartOnCpSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 103, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpRestartOnCpSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpRestartOnCpSwitch.setDescription("This attribute indicates whether the Lp always restarts upon a CP switchover. The value is true if the featureList of the associated Sw Lpt component contains a feature that does not support hitless CP switchover. The value is also true when the feature noHitlessCpSwitch is provisioned on the CP. A value of false does not guarantee 'no restart'; dynamic conditions may still result in an FP restart when a CP switchover occurs.")
mscLpScheduledSwitchover = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 103, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpScheduledSwitchover.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpScheduledSwitchover.setDescription('This attribute indicates the execution time of the scheduled switchover. When there is no switchover scheduled the time is equals to 0 (0000-00-00 00:00).')
mscLpUtilTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104), )
if mibBuilder.loadTexts: mscLpUtilTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpUtilTable.setDescription("This group contains the operational attributes that specify the processor's utilization levels. When this group exists for an LP component, the attributes are representative of the active card.")
mscLpUtilEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"))
if mibBuilder.loadTexts: mscLpUtilEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpUtilEntry.setDescription('An entry in the mscLpUtilTable.')
mscLpTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpTimeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpTimeInterval.setDescription('This attribute indicates the time period (in minutes) for which the average, minimum and maximum utilization values are calculated. This attribute is reset to 0 every 15 minutes.')
mscLpCpuUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpCpuUtil.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCpuUtil.setDescription('This attribute indicates an approximation of the current processor utilization level (expressed as a percentage).')
mscLpCpuUtilAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpCpuUtilAvg.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCpuUtilAvg.setDescription('This attribute indicates an average processor utilization level over the specified time period, timeInterval. This average is calculated based on one minute CPU utilization averages.')
mscLpCpuUtilAvgMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpCpuUtilAvgMin.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCpuUtilAvgMin.setDescription('This attribute indicates the minimum processor utilization level over a specified time period, timeInterval. This is based on one minute CPU utilization averages.')
mscLpCpuUtilAvgMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpCpuUtilAvgMax.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCpuUtilAvgMax.setDescription('This attribute indicates the maximum processor utilization level over a specified time period, timeInterval. This is based on one minute CPU utilization averages.')
mscLpMsgBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMsgBlockUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMsgBlockUsage.setDescription("This attribute indicates the processor's current shared message block memory utilization. If there is no shared memory on the card, this attribute indicates 0.")
mscLpMsgBlockUsageAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 7), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMsgBlockUsageAvg.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMsgBlockUsageAvg.setDescription("This attribute indicates the processor's average memory utilization of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this average memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
mscLpMsgBlockUsageAvgMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 8), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMsgBlockUsageAvgMin.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMsgBlockUsageAvgMin.setDescription("This attribute indicates the processor's minimum memory utilization of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this minimum memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
mscLpMsgBlockUsageAvgMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMsgBlockUsageAvgMax.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMsgBlockUsageAvgMax.setDescription("This attribute indicates the processor's maximum memory utilization of shared message blocks, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this maximum memory utilization is reset to the current usage, sharedMsgBlockUsage. If there is no shared memory on the card, this attribute indicates 0.")
mscLpLocalMsgBlockUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsage.setDescription("This attribute indicates the processor's current memory utilization of message blocks which are used for local messaging on the card.")
mscLpLocalMsgBlockUsageAvg = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 11), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsageAvg.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsageAvg.setDescription("This attribute indicates the processor's average memory utilization of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is calculated using 15 second samples. At the start of each timeInterval, this average memory utilization is reset to the current usage, localMsgBlockUsage.")
mscLpLocalMsgBlockUsageMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsageMin.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsageMin.setDescription("This attribute indicates the processor's minimum memory utilization of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is updated at 15 second intervals. At the start of each timeInterval, this minimum memory utilization is reset to the current usage, localMsgBlockUsage.")
mscLpLocalMsgBlockUsageMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 104, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsageMax.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLocalMsgBlockUsageMax.setDescription("This attribute indicates the processor's maximum memory utilization of message blocks used for local messaging on the card, calculated over a specified time period, timeInterval. This utilization value is updated at 15 second intervals. At the start of each timeInterval, this maximum memory utilization is reset to the current usage, localMsgBlockUsage.")
mscLpCapTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 105), )
if mibBuilder.loadTexts: mscLpCapTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCapTable.setDescription("This group contains the operational attributes that specify the processor's capacity levels. When this group exists for an LP component, the attributes are representative of the active Card.")
mscLpCapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 105, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"))
if mibBuilder.loadTexts: mscLpCapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpCapEntry.setDescription('An entry in the mscLpCapTable.')
mscLpMsgBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 105, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMsgBlockCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMsgBlockCapacity.setDescription("This attribute indicates the processor card's shared message block memory capacity.")
mscLpLocalMsgBlockCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 105, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpLocalMsgBlockCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLocalMsgBlockCapacity.setDescription("This attribute indicates the processor card's local message block memory capacity. These message blocks are used for local messaging on the card.")
mscLpLinkToApplicationsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 242), )
if mibBuilder.loadTexts: mscLpLinkToApplicationsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLinkToApplicationsTable.setDescription('This attribute allows applications to link themselves directly to the LP component.')
mscLpLinkToApplicationsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 242, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpLinkToApplicationsValue"))
if mibBuilder.loadTexts: mscLpLinkToApplicationsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLinkToApplicationsEntry.setDescription('An entry in the mscLpLinkToApplicationsTable.')
mscLpLinkToApplicationsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 242, 1, 1), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpLinkToApplicationsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpLinkToApplicationsValue.setDescription('This variable represents both the value and the index for the mscLpLinkToApplicationsTable.')
mscLpMemoryCapacityTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 244), )
if mibBuilder.loadTexts: mscLpMemoryCapacityTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryCapacityTable.setDescription("This attribute indicates the processor card's memory capacity for each type of memory.")
mscLpMemoryCapacityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 244, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpMemoryCapacityIndex"))
if mibBuilder.loadTexts: mscLpMemoryCapacityEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryCapacityEntry.setDescription('An entry in the mscLpMemoryCapacityTable.')
mscLpMemoryCapacityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 244, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: mscLpMemoryCapacityIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryCapacityIndex.setDescription('This variable represents the mscLpMemoryCapacityTable specific index for the mscLpMemoryCapacityTable.')
mscLpMemoryCapacityValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 244, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMemoryCapacityValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryCapacityValue.setDescription('This variable represents an individual value for the mscLpMemoryCapacityTable.')
mscLpMemoryUsageTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 245), )
if mibBuilder.loadTexts: mscLpMemoryUsageTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageTable.setDescription("This attribute indicates the processor's current memory utilization for each type of memory.")
mscLpMemoryUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 245, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpMemoryUsageIndex"))
if mibBuilder.loadTexts: mscLpMemoryUsageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageEntry.setDescription('An entry in the mscLpMemoryUsageTable.')
mscLpMemoryUsageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 245, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: mscLpMemoryUsageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageIndex.setDescription('This variable represents the mscLpMemoryUsageTable specific index for the mscLpMemoryUsageTable.')
mscLpMemoryUsageValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 245, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMemoryUsageValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageValue.setDescription('This variable represents an individual value for the mscLpMemoryUsageTable.')
mscLpMemoryUsageAvgTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 276), )
if mibBuilder.loadTexts: mscLpMemoryUsageAvgTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgTable.setDescription("This attribute indicates the processor's average memory utilization for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
mscLpMemoryUsageAvgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 276, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpMemoryUsageAvgIndex"))
if mibBuilder.loadTexts: mscLpMemoryUsageAvgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgEntry.setDescription('An entry in the mscLpMemoryUsageAvgTable.')
mscLpMemoryUsageAvgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 276, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: mscLpMemoryUsageAvgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgIndex.setDescription('This variable represents the mscLpMemoryUsageAvgTable specific index for the mscLpMemoryUsageAvgTable.')
mscLpMemoryUsageAvgValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 276, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMemoryUsageAvgValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgValue.setDescription('This variable represents an individual value for the mscLpMemoryUsageAvgTable.')
mscLpMemoryUsageAvgMinTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 277), )
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinTable.setDescription("This attribute indicates the processor's minimum memory utilization for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
mscLpMemoryUsageAvgMinEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 277, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpMemoryUsageAvgMinIndex"))
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinEntry.setDescription('An entry in the mscLpMemoryUsageAvgMinTable.')
mscLpMemoryUsageAvgMinIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 277, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinIndex.setDescription('This variable represents the mscLpMemoryUsageAvgMinTable specific index for the mscLpMemoryUsageAvgMinTable.')
mscLpMemoryUsageAvgMinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 277, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMinValue.setDescription('This variable represents an individual value for the mscLpMemoryUsageAvgMinTable.')
mscLpMemoryUsageAvgMaxTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 278), )
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxTable.setDescription("This attribute indicates the processor's maximum memory utilization for each type of memory in the specified time period, timeInterval. This value is calculated using 15 second samples.")
mscLpMemoryUsageAvgMaxEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 278, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpMemoryUsageAvgMaxIndex"))
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxEntry.setDescription('An entry in the mscLpMemoryUsageAvgMaxTable.')
mscLpMemoryUsageAvgMaxIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 278, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fastRam", 0), ("normalRam", 1), ("sharedRam", 2))))
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxIndex.setDescription('This variable represents the mscLpMemoryUsageAvgMaxTable specific index for the mscLpMemoryUsageAvgMaxTable.')
mscLpMemoryUsageAvgMaxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 278, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpMemoryUsageAvgMaxValue.setDescription('This variable represents an individual value for the mscLpMemoryUsageAvgMaxTable.')
mscLpDS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5))
mscLpDS3RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 1), )
if mibBuilder.loadTexts: mscLpDS3RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3 components.')
mscLpDS3RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3RowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3 component.')
mscLpDS3RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3 components. These components can be added and deleted.')
mscLpDS3ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3StorageType.setDescription('This variable represents the storage type value for the mscLpDS3 tables.')
mscLpDS3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11)))
if mibBuilder.loadTexts: mscLpDS3Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3Index.setDescription('This variable represents the index for the mscLpDS3 tables.')
mscLpDS3ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 10), )
if mibBuilder.loadTexts: mscLpDS3ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ProvTable.setDescription('This group contains all of the provisioning data for a DS3 component.')
mscLpDS3ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ProvEntry.setDescription('An entry in the mscLpDS3ProvTable.')
mscLpDS3CbitParity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3CbitParity.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CbitParity.setDescription('This attribute indicates if C-Bit parity has been turned ON or OFF. The CBIT component will appear under the DS3 component when the cbitParity attribute is set to on.')
mscLpDS3LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 450)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LineLength.setDescription('This attribute defines the line length for equalization calculations for the DS3 line. The range is between 0 and 450 feet (1 metre = 3.28 feet). Note: There are currently only two ranges as far as the equalization calculation performed on the FP is concerned: 0 to 224ft and 225 to 450ft.')
mscLpDS3ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ClockingSource.setDescription("This attribute defines the type of clocking source used for synchronizing the DS3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means use of a signal phase-locked to the incoming DS3 line rate; module means the use of a signal phase-locked to the CP reference clock. Note that the multiport cell-based cards have one common clock source for all ports. For this reason, the following rules apply for the value of clockingSource across the board's three ports: All three clockingSource values must be 'local' OR All three clockingSource values must be 'module' OR One clockingSource value must be 'line' and the other two must be 'otherPort'. If there is no NS component provisioned, the default value for this attribute will be local. If the NS component has been provisioned, the default value is module, except for the 1pDS3C cards. For the 1pDS3C cards, the default and only valid value for this attribute is local. The clockingSource of the DS1 sub-component becomes the effective clocking source for this attribute. All the DS1 sub-components have the same clocking source.")
mscLpDS3ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 10, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the DS3 component.')
mscLpDS3Mapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("direct", 0), ("plcp", 1))).clone('direct')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3Mapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3Mapping.setDescription('This attribute indicates if ATM cells will be mapped directly into the DS3 payload, or whether PLCP mapping will be used. The PLCP component will appear under the DS3 component when this attribute is set to plcp. This attribute will be ignored when set on frame-based cards.')
mscLpDS3CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 11), )
if mibBuilder.loadTexts: mscLpDS3CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpDS3CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CidDataEntry.setDescription('An entry in the mscLpDS3CidDataTable.')
mscLpDS3CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpDS3AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 12), )
if mibBuilder.loadTexts: mscLpDS3AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpDS3AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3AdminInfoEntry.setDescription('An entry in the mscLpDS3AdminInfoTable.')
mscLpDS3Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpDS3CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpDS3IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 13), )
if mibBuilder.loadTexts: mscLpDS3IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpDS3IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3IfEntryEntry.setDescription('An entry in the mscLpDS3IfEntryTable.')
mscLpDS3IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpDS3IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpDS3OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 14), )
if mibBuilder.loadTexts: mscLpDS3OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpDS3OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3OperStatusEntry.setDescription('An entry in the mscLpDS3OperStatusTable.')
mscLpDS3SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpDS3StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15), )
if mibBuilder.loadTexts: mscLpDS3StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpDS3StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3StateEntry.setDescription('An entry in the mscLpDS3StateTable.')
mscLpDS3AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpDS3ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpDS3ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpDS3AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpDS3StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpDS3UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpDS3OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16), )
if mibBuilder.loadTexts: mscLpDS3OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3OperTable.setDescription('This group contains the common operational data for DS3 component.')
mscLpDS3OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3OperEntry.setDescription('An entry in the mscLpDS3OperTable.')
mscLpDS3LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LosAlarm.setDescription('This attribute displays whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOS defect is detected at the DS3 line interface upon observing 175 +/- 75 continuous pulse positions with no pulses of either positive or negative polarity. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared after LOS defects have been absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpDS3LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when Severely Errored Frame (SEF) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. A SEF defect is detected when 3 (or more) out of 16 (or fewer) F-bits are in error, or one (or more) M-bits in two (or more) out of four (or fewer) consecutive M-frames are in error. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when framing has been achieved for a period of 10 seconds +/- 0.5 seconds. As long as SEF defects are detected, the node also transmits the far-end SEF/AIS defect indicator over the outgoing line. When not running in C-Bit Parity mode, the txRai attribute is also set to on when transmitting the far-end SEF/AIS defect indicator on the outgoing line. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpDS3RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3RxAisAlarm.setDescription('This attribute displays whether an Alarm Indication Signal (AIS) alarm state has been entered. An AIS alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/ - 0.5 seconds. An AIS defect is the occurrence of AIS (valid DS3 frame with payload containing the 1010...sequence and with C-Bits set to zero) in contiguous M-frames for a time greater than 100 milliseconds. If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the AIS alarm condition is cleared (after AIS has been no longer detected for a period of 10 seconds +/- 0.5 seconds). As long as AIS is detected, the node also transmits the far-end SEF/AIS defect indicator over the outgoing line. When not running in C-Bit Parity mode, the txRai attribute is also set to on when transmitting the far- end SEF/AIS defect indicator on the outgoing line. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpDS3RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3RxRaiAlarm.setDescription('This attribute displays whether a Remote Alarm Indication (RAI) alarm state has been entered. When not running the C-Bit Parity mode, the RAI alarm state is entered when the far-end SEF/AIS defect indicator has been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds on the incoming DS3 line. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the RAI alarm condition is cleared. The condition is cleared when the far-end SEF/AIS defect indicator has not been detected for 10 seconds +/- 0.5 seconds. When running the C-Bit Parity mode, the RAI alarm state is entered upon detection of a far-end alarm over the Far-End Alarm and Control (FEAC) channel. The RAI alarm state is exited as soon as no more far-end alarm is detected on the FEAC channel. The far- end alarms that can be detected on the FEAC channel and that cause the RAI alarm state to be entered are: equipment failure alarm (service affecting), LOS alarm, LOF alarm, idle and AIS alarm. The rxRaiAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpDS3RxIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3RxIdle.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3RxIdle.setDescription('This attribute displays whether an Idle failure condition has been reported on the DS3 port. An Idle condition is reported when DS3 Idle defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The DS3 Idle defect is the occurrence of a valid DS3 frame with the information bits set to a 11001100.. sequence. If the DS3 Idle defects are intermittently occurring, the DS3 Idle defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The DS3 component goes into an operational state of disabled until the Idle failure condition is cleared. The failure condition is cleared when the DS3 idle pattern has not been detected for at least 10 seconds +/- 0.5 seconds. The rxIdle attribute is always set to off when the component has been locked and left offline. The idle pattern indicates that the far-end is physically connected but not put in service. For instance, DS3 idle is transmitted on the outgoing line when the DS3 component is locked and not used for operational testing.')
mscLpDS3TxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TxAis.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TxAis.setDescription('This attribute displays whether an Alarm Indication Signal (AIS) alarm is being transmitted on the DS3 line. Currently, AIS is never transmitted by a Passport DS3 node.')
mscLpDS3TxRai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TxRai.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TxRai.setDescription('When not running C-Bit Parity mode, this attribute displays whether the far-end SEF/AIS defect indicator is transmitted over the outgoing line when the DS3 component has been unlocked or used in operational testing. When running in C-Bit Parity mode, this attribute displays whether a far-end alarm is sent over the Far-End Alarm and Control (FEAC) channel when the DS3 component has been unlocked or used in operational testing. When the DS3 component is locked and not used in operational testing, this attribute is always set to off.')
mscLpDS3TxIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 16, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TxIdle.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TxIdle.setDescription('This attribute displays whether the DS3 Idle signal is transmitted over the outgoing line. DS3 Idle is sent when the DS3 component has been locked and not used in operational testing.')
mscLpDS3StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17), )
if mibBuilder.loadTexts: mscLpDS3StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3StatsTable.setDescription('This group contains the specific DS3 common operational data for a DS3 component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"))
if mibBuilder.loadTexts: mscLpDS3StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3StatsEntry.setDescription('An entry in the mscLpDS3StatsTable.')
mscLpDS3RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3RunningTime.setDescription("This attribute indicates the total number of seconds since the DS3 component has been activated and been in unlocked state or used for operational testing. All the other error counts that follow as well as each DS3 subcomponent's error counts can be updated when this count is active.")
mscLpDS3ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3ErrorFreeSec.setDescription('This attribute indicates the number of seconds that the DS3 port has been in an error free state.')
mscLpDS3LineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3LineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCV) detected. A DS3 Line Code Violation is a B3Zs error. LCV counting is inhibited for second intervals where Line Severely Errored Second (LSES) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3LineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3LineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LES) that have been counted. A LES is declared for second intervals containing one or more LCV or one or more Loss Of Signal (LOS) defects.')
mscLpDS3LineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3LineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSES) that have been counted. A LSES is declared for second intervals containing more than 44 LCVs or one or more LOS defects.')
mscLpDS3LineLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3LineLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LineLosSec.setDescription('This attribute indicates the total number of Line LOS Seconds (LOSS) that have been counted. A LOSS is declared for second intervals containing one or more LOS defects.')
mscLpDS3LineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3LineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3LineFailures.setDescription('This attribute indicates the total number of times that a line failure (LOS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3PathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCVs) detected. Each PCV corresponds to a P-bit parity error, or possibly a frame error or a disagreement between P-bits or X-bits. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3PathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PESs) that have been counted. A PES is declared for second intervals containing one or more Path Code Violations (PCV) or one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of Path Errored Seconds is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
mscLpDS3PathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSESs) that have been counted. A PSES is declared for second intervals containing more than 44 PCVs or one or more SEF or AIS defects. Counting of PSESs is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
mscLpDS3PathSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PathSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PathSefAisSec.setDescription('This attribute indicates the total number of SEF/AIS Seconds (PSASs). A PSAS is declared for second intervals containing one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of PSAS is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
mscLpDS3PathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the DS3 path is unavailable. The DS3 path becomes unavailable at the onset of 10 consecutive Path Severely Errored Seconds (PSES). The 10 PSESs are included in the unavailable time. Once unavailable, the DS3 path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where PUAS is counted, counting of Path Coding Violations (PCV), Path Errored Seconds (PES), Path Severely Errored Seconds (PSES) and Path Sef/Ais Seconds (PSAS) is inhibited.')
mscLpDS3PathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOF/AIS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2))
mscLpDS3TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 1), )
if mibBuilder.loadTexts: mscLpDS3TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3Test components.')
mscLpDS3TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3TestIndex"))
if mibBuilder.loadTexts: mscLpDS3TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3Test component.')
mscLpDS3TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3Test components. These components cannot be added nor deleted.')
mscLpDS3TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestStorageType.setDescription('This variable represents the storage type value for the mscLpDS3Test tables.')
mscLpDS3TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestIndex.setDescription('This variable represents the index for the mscLpDS3Test tables.')
mscLpDS3TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 10), )
if mibBuilder.loadTexts: mscLpDS3TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpDS3TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3TestIndex"))
if mibBuilder.loadTexts: mscLpDS3TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestStateEntry.setDescription('An entry in the mscLpDS3TestStateTable.')
mscLpDS3TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpDS3TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpDS3TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpDS3TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11), )
if mibBuilder.loadTexts: mscLpDS3TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpDS3TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3TestIndex"))
if mibBuilder.loadTexts: mscLpDS3TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestSetupEntry.setDescription('An entry in the mscLpDS3TestSetupTable.')
mscLpDS3TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpDS3TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpDS3TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpDS3TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpDS3TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpDS3TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpDS3TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpDS3TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpDS3TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12), )
if mibBuilder.loadTexts: mscLpDS3TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpDS3TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3TestIndex"))
if mibBuilder.loadTexts: mscLpDS3TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestResultsEntry.setDescription('An entry in the mscLpDS3TestResultsTable.')
mscLpDS3TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpDS3TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpDS3TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpDS3TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpDS3TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS3TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS3TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpDS3TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpDS3CBit = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3))
mscLpDS3CBitRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 1), )
if mibBuilder.loadTexts: mscLpDS3CBitRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3CBit components.')
mscLpDS3CBitRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3CBitIndex"))
if mibBuilder.loadTexts: mscLpDS3CBitRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3CBit component.')
mscLpDS3CBitRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3CBit components. These components cannot be added nor deleted.')
mscLpDS3CBitComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3CBitStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitStorageType.setDescription('This variable represents the storage type value for the mscLpDS3CBit tables.')
mscLpDS3CBitIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3CBitIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitIndex.setDescription('This variable represents the index for the mscLpDS3CBit tables.')
mscLpDS3CBitOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 10), )
if mibBuilder.loadTexts: mscLpDS3CBitOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitOperationalTable.setDescription('This group contains the DS3 C-Bit Parity operational data for the CBIT component.')
mscLpDS3CBitOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3CBitIndex"))
if mibBuilder.loadTexts: mscLpDS3CBitOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitOperationalEntry.setDescription('An entry in the mscLpDS3CBitOperationalTable.')
mscLpDS3CBitFarEndAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("equipmentFailure", 0), ("los", 1), ("sef", 2), ("ais", 3), ("idle", 4), ("none", 5))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndAlarm.setDescription('This attribute indicates the Far-End alarm signal that is currently received at the DS3 interface. This signal is carried over the Far- End Alarm and Control (FEAC) bits of DS3 frames. Five far-end alarm signals can be received: far-end equipment failure that is received when the far-end terminal has detected a local equipment failure; far-end Loss Of Signal (LOS) that is received when the far- end DS3 terminal has declared a LOS failure condition; far-end Loss of Frame (LOF) when the far-end DS3 terminal has declared a Loss Of Frame (LOF) failure condition; far-end Alarm Indication Signal (AIS) when the far-end has declared an AIS failure condition; far-end Idle when the far-end has declared an Idle signal condition.')
mscLpDS3CBitLoopedbackToFarEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitLoopedbackToFarEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitLoopedbackToFarEnd.setDescription('This indicates whether or not the DS3 component is currently looping back the incoming DS3 signal or one of its DS1 tributaries to the far-end DS3 terminal. This is activated when the far-end DS3 equipment has ordered the local terminal to do so. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) notused29(29) notused30(30) ds3Line(31)')
mscLpDS3CBitLoopbackAtFarEndRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitLoopbackAtFarEndRequested.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitLoopbackAtFarEndRequested.setDescription('This attribute indicates which DS1 tributaries are being looped back, or if the DS3 line is being looped back. Each value listed indicates a loopback request has been made. When a loopback deactivation command has been sent to the far end, the corresponding value will be removed from the list. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) notused29(29) notused30(30) ds3Line(31)')
mscLpDS3CBitStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11), )
if mibBuilder.loadTexts: mscLpDS3CBitStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitStatsTable.setDescription('This group contains the DS3 C-Bit Parity statistical data for the CBIT component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3CBitStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3CBitIndex"))
if mibBuilder.loadTexts: mscLpDS3CBitStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitStatsEntry.setDescription('An entry in the mscLpDS3CBitStatsTable.')
mscLpDS3CBitCbitErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitCbitErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitCbitErrorFreeSec.setDescription('This attribute indicates the number of seconds that the DS3 port has not suffered any C-Bit errors.')
mscLpDS3CBitCbitCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitCbitCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitCbitCodeViolations.setDescription('This attribute indicates the total count of C-Bit Parity Code Violations (CCV). A CCV is obtained when the parity calculated over the previous DS3 frame and the value of the CP-bits appearing in the current DS3 frame differ. The value of this attribute will wrap around to 0 if it does reach its maximum value. CCV counting is inhibited for second intervals where C-Bit Parity Severely Errored Seconds (CSES) are counted. It is also inhibited for second intervals where C-Bit Unavailable Seconds (CUAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3CBitCbitErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitCbitErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitCbitErroredSec.setDescription('This attribute indicates the total number of C-Bit Parity Errored Seconds (CES). A CES second is declared for second intervals containing one or more CCVs or when one or more SEF (Severely Errored Frame) or AIS (Alarm Indication Signal) defects. CES counting is inhibited for second intervals where C-Bit Unavailable Seconds (CUAS) are counted.')
mscLpDS3CBitCbitSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitCbitSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitCbitSevErroredSec.setDescription('This attribute indicates the total number of C-Bit Parity Severely Errored Seconds (CSES). A CSES is declared for second intervals containing more than 44 CCVs or one or more SEF or AIS defects. The occurrence of CSES in a one second interval causes the inhibition of CCV counting during that second interval. CSES counting is also inhibited for second intervals where C-Bit Unavailable Seconds (CUAS) are counted.')
mscLpDS3CBitCbitUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitCbitUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitCbitUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the DS3 path is unavailable. The DS3 path becomes unavailable at the onset of 10 consecutive C-Bit Severely Errored Seconds (CSES). The 10 CSESs are included in the unavailable time. Once unavailable, the DS3 path becomes available at the onset of 10 contiguous seconds with no CSES. The 10 seconds with no CSES are excluded from the unavailable time. For second intervals where CUAS is counted, counting of C-Bit Coding Violations (CCV), C-Bit Errored Seconds (CES) and C-Bit Severely Errored Seconds (CSES) is inhibited.')
mscLpDS3CBitFarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds that the DS3 port has not suffered of any far-end errors.')
mscLpDS3CBitFarEndCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndCodeViolations.setDescription('This attribute indicates the total count of DS3 frames containing a Coding Violation on the Far-End (FECV), also known as a Far-End Block Error (FEBE). Each FEBE is reported over the FEBE bits each time the far-end DS3 terminal detects a C-BIT Parity error over a received DS3 frame. For second intervals where Far-End Unavailable Seconds (FEAUS) or Far-End Severely Errored Seconds (FESES) are counted, counting of FECVs is inhibited. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3CBitFarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndErroredSec.setDescription('This attribute indicates the total number of Far-End Errored Seconds (FEES). A FEES is declared for second intervals containing with one or more FECVs or one or more far-end SEF/ AIS defects. A far-end SEF/AIS defect occurs when the X-Bits of the DS3 frame are received as being set to zero. For second intervals where Far-End Unavailable Seconds (FEUAS) are counted, counting of FEESs is inhibited.')
mscLpDS3CBitFarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndSevErroredSec.setDescription('This attribute indicates the total number of Far-End Severely Errored Seconds (FESES). A FESES is declared for second intervals containing more than 44 FECVs or one or more far-end SEF/AIS defects. For second intervals where a FESES is counted, counting of FECVs is inhibited. For second intervals where Far-End Unavailable Seconds (FEUAS) are counted, counting of FESESs is inhibited.')
mscLpDS3CBitFarEndSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndSefAisSec.setDescription('This attribute indicates the total number of Far-End SEF/AIS Seconds (FESAS). A FESAS is declared for second intervals containing one or more far-end SEF/AIS defects.For second intervals where Far-End Unavailable Seconds (FEUAS) are counted, counting of FESASs is inhibited.')
mscLpDS3CBitFarEndUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the DS3 far-end path is unavailable. The DS3 far-end path becomes unavailable at the onset of 10 consecutive Far-End Severely Errored Seconds (FESES). The 10 FESESs are included in the unavailable time. Once unavailable, the DS3 far-end path becomes available at the onset of 10 contiguous seconds with no FESES. The 10 seconds with no FESES are excluded from the unavailable time. For second intervals where FEUAS is counted, counting of Far-End Coding Violations (FECV), Far-End Errored Seconds (FEES), Far-End Severely Errored Seconds (FESES) and Far-End Sef/Ais Seconds (FESAS) is inhibited.')
mscLpDS3CBitFarEndFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 3, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CBitFarEndFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CBitFarEndFailures.setDescription('This attribute indicates the total number of times that a far-end path failure (i.e. a Far-End SEF/AIS defect) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3Plcp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4))
mscLpDS3PlcpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 1), )
if mibBuilder.loadTexts: mscLpDS3PlcpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3Plcp components.')
mscLpDS3PlcpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3PlcpIndex"))
if mibBuilder.loadTexts: mscLpDS3PlcpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3Plcp component.')
mscLpDS3PlcpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3Plcp components. These components cannot be added nor deleted.')
mscLpDS3PlcpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3PlcpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpStorageType.setDescription('This variable represents the storage type value for the mscLpDS3Plcp tables.')
mscLpDS3PlcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3PlcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpIndex.setDescription('This variable represents the index for the mscLpDS3Plcp tables.')
mscLpDS3PlcpOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 10), )
if mibBuilder.loadTexts: mscLpDS3PlcpOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpOperationalTable.setDescription('This group contains the operational data for the PLCP component.')
mscLpDS3PlcpOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3PlcpIndex"))
if mibBuilder.loadTexts: mscLpDS3PlcpOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpOperationalEntry.setDescription('An entry in the mscLpDS3PlcpOperationalTable.')
mscLpDS3PlcpLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpLofAlarm.setDescription('This attribute displays whether a PLCP Loss Of Frame (LOF) failure alarm state has been entered. An LOF failure is declared when a PLCP LOF defect persists for 2.5 s +/- 0.5 s. An LOF defect occurs when an OOF (Out of Frame) state persists for more than 1 ms. If the OOF events are intermittent, the LOF defect counter is decremented at a rate of 1/12 (for DS3 PLCP) or 1/9 (for G.751 E3 PLCP) of the incrementing rate, with all measurements based on a 200 ms polling cycle. An OOF event (also known as a PLCP SEF event) is declared when an error is detected in both the A1 and A2 octets, or when two consecutive POHIDs are found in error. OOF is removed when two valid sets of framing octets and two valid and sequential POHID octets have been found. The LOF defect is removed when the defect counter reaches zero, i.e. when OOF events are absent for more than 12 ms (DS3 PLCP) or 9 ms (G.751 E3 PLCP). LOF failure alarm is cleared when LOF defect is absent for 10.0 s +/- 0.5 s The DS3 or E3 component goes into an operational state of disabled until the LOF failure alarm is cleared. The terminal declaring the LOF failure alarm will transmit a PLCP RAI signal to the far-end for the duration of the alarm. The lofAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
mscLpDS3PlcpRxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpRxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpRxRaiAlarm.setDescription('This attribute displays whether a PLCP Remote Alarm Indication (RAI) failure alarm state has been entered. An RAI failure alarm occurs when ten consecutive PLCP RAI bits (bit 5 in the G1 byte) are high on the incoming line. An RAI failure alarm is cleared when ten consecutive RAI bits are set to 0. Note: Some standards call this alarm RFI. The rxRaiAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
mscLpDS3PlcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11), )
if mibBuilder.loadTexts: mscLpDS3PlcpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpStatsTable.setDescription('This group contains the statistical data for the PLCP component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3PlcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3PlcpIndex"))
if mibBuilder.loadTexts: mscLpDS3PlcpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpStatsEntry.setDescription('An entry in the mscLpDS3PlcpStatsTable.')
mscLpDS3PlcpErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the near-end PLCP path layer had no errors.')
mscLpDS3PlcpCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpCodingViolations.setDescription('This attribute indicates the total number of BIP-8 Errors, framing pattern octet errors, and path overhead identification errors detected in received PLCP frames. Counting of PLCP CV is inhibited for second intervals where PLCP Severely Errored Framing Seconds (SEFS) or PLCP Unavailable Seconds (UAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3PlcpErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Coding Violations (CV) or in which a PLCP Severely Errored Framing Second (SEFS) was counted. Counting of PLCP ES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
mscLpDS3PlcpSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCPCVs or in which a PLCPSEFS was counted (i.e. a PLCP OOF event occurred). Counting of PLCP SES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
mscLpDS3PlcpSevErroredFramingSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpSevErroredFramingSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpSevErroredFramingSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Severely Errored Frame (SEF) events. An SEF event is equivalent to a PLCP OOF (Out of Frame) event. Counting of PLCPP SEFSs is inhibited for second intervals where PLCP Unavailable Seconds (UAS) are counted.')
mscLpDS3PlcpUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpUnavailSec.setDescription('This attribute indicates the number of seconds when the near-end PLCP layer is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP LOF (Loss of Frame) failure alarm state. The PLCP Path Layer becomes available again only after clearing this condition. For second intervals where PLCP UAS are counted, counting of PLCP Severely Errored Framing Seconds (SEFS), PLCP Coding Violations (CV), PLCP Errored Seconds (ES), PLCP Severely Errored Seconds (SES) and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
mscLpDS3PlcpFarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the far- end PLCP path layer had no errors.')
mscLpDS3PlcpFarEndCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndCodingViolations.setDescription('This attribute indicates the total number of PLCP Far-End Block Errors (FEBE) reported by the far-end terminal. Counting of FEBEs is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3PlcpFarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FEES is inhibited during second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
mscLpDS3PlcpFarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FESES is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
mscLpDS3PlcpFarEndUnavailableSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 4, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndUnavailableSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3PlcpFarEndUnavailableSec.setDescription('This attribute indicates the number of seconds during which the PLCP far end is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP RAI (Remote Alarm Indication). Service becomes available again after this condition is cleared. For second intervals where PLCP FEUAS are counted, counting of PLCP Far-End Coding Violations (FECV), PLCP Far- End Errored Seconds (FEES), and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
mscLpDS3Cell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5))
mscLpDS3CellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 1), )
if mibBuilder.loadTexts: mscLpDS3CellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3Cell components.')
mscLpDS3CellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3CellIndex"))
if mibBuilder.loadTexts: mscLpDS3CellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3Cell component.')
mscLpDS3CellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3CellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3Cell components. These components can be added and deleted.')
mscLpDS3CellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3CellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellStorageType.setDescription('This variable represents the storage type value for the mscLpDS3Cell tables.')
mscLpDS3CellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3CellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellIndex.setDescription('This variable represents the index for the mscLpDS3Cell tables.')
mscLpDS3CellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 10), )
if mibBuilder.loadTexts: mscLpDS3CellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpDS3CellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3CellIndex"))
if mibBuilder.loadTexts: mscLpDS3CellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellProvEntry.setDescription('An entry in the mscLpDS3CellProvTable.')
mscLpDS3CellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3CellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpDS3CellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3CellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpDS3CellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3CellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpDS3CellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 11), )
if mibBuilder.loadTexts: mscLpDS3CellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpDS3CellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3CellIndex"))
if mibBuilder.loadTexts: mscLpDS3CellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellOperEntry.setDescription('An entry in the mscLpDS3CellOperTable.')
mscLpDS3CellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS3CellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 12), )
if mibBuilder.loadTexts: mscLpDS3CellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3CellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3CellIndex"))
if mibBuilder.loadTexts: mscLpDS3CellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellStatsEntry.setDescription('An entry in the mscLpDS3CellStatsTable.')
mscLpDS3CellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpDS3CellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpDS3CellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS3CellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS3CellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 5, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3CellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3CellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpDS3DS1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6))
mscLpDS3DS1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 1), )
if mibBuilder.loadTexts: mscLpDS3DS1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3DS1 components.')
mscLpDS3DS1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1RowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3DS1 component.')
mscLpDS3DS1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3DS1 components. These components can be added and deleted.')
mscLpDS3DS1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3DS1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1StorageType.setDescription('This variable represents the storage type value for the mscLpDS3DS1 tables.')
mscLpDS3DS1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 28)))
if mibBuilder.loadTexts: mscLpDS3DS1Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1Index.setDescription('This variable represents the index for the mscLpDS3DS1 tables.')
mscLpDS3DS1ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 10), )
if mibBuilder.loadTexts: mscLpDS3DS1ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ProvTable.setDescription('This group contains all of the provisioning data for a DS1 component.')
mscLpDS3DS1ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ProvEntry.setDescription('An entry in the mscLpDS3DS1ProvTable.')
mscLpDS3DS1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("d4", 0), ("esf", 1), ("d4Cas", 4), ("esfCas", 5))).clone('esf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1LineType.setDescription('This attribute defines the framing of the DS1 tributary. d4 defines a framing pattern of 12 frames per multiframe. esf defines a framing pattern of 24 frames per multiframe. d4Cas defines a framing pattern of 12 frames per multiframe with channel associated signalling. esfCas defines a framing pattern of 24 frames per multiframe with channel associated signalling. For the 4pDS3ChAtm card, only d4 and esf framing patterns are permitted.')
mscLpDS3DS1ZeroCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3))).clone(namedValues=NamedValues(("bit7Stuffing", 0), ("none", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ZeroCoding.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ZeroCoding.setDescription("This attribute defines the zero encoding on the DS1 tributary. bit7Stuffing sets bit 7 of every timeslot to a one to guarantee ones's density. This reduces the available bandwidth of the channel by 1/8. none does no zero encoding.")
mscLpDS3DS1ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ClockingSource.setDescription('This attribute defines the source of the transmit clock for the DS1 tributary. When the clocking source is selected from local, the crystal on the port generates the clocking for the DS1 tributary. When the clocking source is selected from line, the port synchronizes to the clock from the DS1 tributary. When the clocking source is selected from module, the ports clock synchronizes to the clock provided by the oscillator on the active CP. On a 1pDS3C card, if the NetworkSynchronization (NS) component is present the default value of this attribute will be module otherwise it will be line. On a 2pDS3cAal or 4pDS3ChAtm card, the only valid values are local and module. If the NS component is present the default value of this attribute will be module otherwise it will be local. On a 4pDS3ChAtm card the clocking source for all DS1 and all DS3 components on card must be the same, except when a DS1 is using line as a clocking source.')
mscLpDS3DS1CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 11), )
if mibBuilder.loadTexts: mscLpDS3DS1CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpDS3DS1CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1CidDataEntry.setDescription('An entry in the mscLpDS3DS1CidDataTable.')
mscLpDS3DS1CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpDS3DS1AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 12), )
if mibBuilder.loadTexts: mscLpDS3DS1AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpDS3DS1AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1AdminInfoEntry.setDescription('An entry in the mscLpDS3DS1AdminInfoTable.')
mscLpDS3DS1Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpDS3DS1CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpDS3DS1IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 13), )
if mibBuilder.loadTexts: mscLpDS3DS1IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpDS3DS1IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1IfEntryEntry.setDescription('An entry in the mscLpDS3DS1IfEntryTable.')
mscLpDS3DS1IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpDS3DS1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpDS3DS1OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 14), )
if mibBuilder.loadTexts: mscLpDS3DS1OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpDS3DS1OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1OperStatusEntry.setDescription('An entry in the mscLpDS3DS1OperStatusTable.')
mscLpDS3DS1SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpDS3DS1StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15), )
if mibBuilder.loadTexts: mscLpDS3DS1StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpDS3DS1StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1StateEntry.setDescription('An entry in the mscLpDS3DS1StateTable.')
mscLpDS3DS1AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3DS1OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3DS1UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3DS1AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpDS3DS1ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpDS3DS1ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpDS3DS1AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpDS3DS1StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpDS3DS1UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpDS3DS1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 16), )
if mibBuilder.loadTexts: mscLpDS3DS1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1OperTable.setDescription('This group contains the common operational data for a component in a digital hierarchy interface.')
mscLpDS3DS1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1OperEntry.setDescription('An entry in the mscLpDS3DS1OperTable.')
mscLpDS3DS1RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1RxAisAlarm.setDescription('This attribute indicates whether an AIS (Alarm Indication Signal) alarm state has been entered. The AIS Alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/- 0.5 seconds. An AIS defect is detected after having received less than 3 zeros in a 2048 bit period. If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. This tributary goes into an operationalState of disabled for the duration of an AIS alarm state. The AIS alarm state is cleared when AIS defects are absent for 10 seconds +/- 0.5 seconds.')
mscLpDS3DS1LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1LofAlarm.setDescription('This attribute indicates whether a LOF (Loss of Frame) alarm state has been entered. The LOF alarm state is entered when LOF defects (2 out of 5 framing bits in error ) have been detected for 3 seconds +/- 0.5 seconds. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. This tributary goes into an operationalState of disabled until the LOF alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOF alarm state The condition is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds.')
mscLpDS3DS1RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1RxRaiAlarm.setDescription('This attribute indicates whether an RAI (Remote Alarm Indication) alarm state has been entered. An RAI alarm state is entered when the RAI defect indicator has been observed and accumulated for 3.5 seconds +/- 0.5 seconds. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/ 10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The RAI alarm state is cleared when the RAI defect indicator has been absent for 10 seconds +/- 0.5 seconds. The RAI alarm is usually an indication that the far end facility is unable to gain synchronization.')
mscLpDS3DS1TxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TxAisAlarm.setDescription('This attribute indicates whether an AIS (Alarm Indication Signal) alarm is being transmitted on the line. An AIS alarm is transmitted when the tributary is in a locked state.')
mscLpDS3DS1TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TxRaiAlarm.setDescription('This attribute indicates whether a RAI signal is being sent on the outgoing line. The RAI signal is transmitted when the tributary detects a LOF alarm condition.')
mscLpDS3DS1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17), )
if mibBuilder.loadTexts: mscLpDS3DS1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1StatsTable.setDescription('This group contains the common statistical data for a component in a digital hierarchy interface.')
mscLpDS3DS1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"))
if mibBuilder.loadTexts: mscLpDS3DS1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1StatsEntry.setDescription('An entry in the mscLpDS3DS1StatsTable.')
mscLpDS3DS1RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1RunningTime.setDescription('This attribute counts the number of seconds since the tributary was activated.')
mscLpDS3DS1ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ErrorFreeSec.setDescription('This attribute counts the number of seconds that the tributary has been in an error free state.')
mscLpDS3DS1ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ErroredSec.setDescription('This attribute counts the number of errored seconds the tributary has counted since it was activated. An errored second is declared when a second with one or more Code Violation Error events, or one or more Out Of Frame events occurs. A code violation error may be a CRC error or a BPV error. An Out Of Frame event occurs when 2 out of 5 framing bits are in error.')
mscLpDS3DS1SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1SevErroredSec.setDescription('This attribute counts the number of severely errored seconds the tributary has counted since it was activated. A severely errored second occurs when a second with 320 or more Code Violation Error events or one or more Out Of Frame events occurs.')
mscLpDS3DS1SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1SevErroredFrmSec.setDescription('This attribute counts the number of severely errored framing seconds the tributary has counted since it was activated A severely errored framing second occurs when a second with one or more Out Of Frame events occurs.')
mscLpDS3DS1UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1UnavailSec.setDescription('This attribute counts the total number of seconds that the tributary has been in an unavailable signal state. An unavailable signal state occurs at the onset of 10 consecutive Severely Errored Seconds. The state is cleared at the onset of 10 seconds with no Severely Errored Seconds.')
mscLpDS3DS1CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1CrcErrors.setDescription('This attribute counts the total number of CRC-6 errors. These will only be counted when the lineType is esf.')
mscLpDS3DS1FrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1FrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1FrmErrors.setDescription('This attribute counts the total number of frame errors. A frame error is an error in the framing bits.')
mscLpDS3DS1SlipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1SlipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1SlipErrors.setDescription('The total number of times that the line experienced a controlled frame slip.')
mscLpDS3DS1Chan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2))
mscLpDS3DS1ChanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 1), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3DS1Chan components.')
mscLpDS3DS1ChanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3DS1Chan component.')
mscLpDS3DS1ChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3DS1Chan components. These components can be added and deleted.')
mscLpDS3DS1ChanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3DS1ChanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanStorageType.setDescription('This variable represents the storage type value for the mscLpDS3DS1Chan tables.')
mscLpDS3DS1ChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscLpDS3DS1ChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanIndex.setDescription('This variable represents the index for the mscLpDS3DS1Chan tables.')
mscLpDS3DS1ChanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 10), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanProvTable.setDescription('This group contains all of the provisional data for a Channel component.')
mscLpDS3DS1ChanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanProvEntry.setDescription('An entry in the mscLpDS3DS1ChanProvTable.')
mscLpDS3DS1ChanTimeslots = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTimeslots.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTimeslots.setDescription('This attribute contains the list of timeslots that are used by the Channel component. Valid numbers are 1-24 for a Channel used by a DS1 component, and 1-31 for a Channel used by an E1 component. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) n29(29) n30(30) n31(31)')
mscLpDS3DS1ChanTimeslotDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n56k", 0), ("doNotOverride", 1))).clone('doNotOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTimeslotDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTimeslotDataRate.setDescription("This attribute selects the data rate of the timeslots in a channel of a DS1 component. For E1, the data rate of the timeslots will always be 64kbit/s regardless of this attribute. When doNotOverride is selected for a channel on a DS1, the data rate of the channel's timeslots are dependant on the zeroCoding selection of the DS1 component. If the zeroCoding is B8ZS (where supported on the FP) or none, the timeslot's data rate will be 64kbit/ s. If the zeroCoding option is bit7Stuffing, the data rate of a timeslot will be 56kbit/s. When 56k is selected for a channel on a DS1, the least significant bit of each timeslot of this Channel will always be set to 1 and not used for data. The data rate for the timeslots of this channel is therefore restricted to 56kbit/s. One application of this attribute is to allow a DS1 line to support mixing channels that originate from lines that use different zeroCoding schemes.")
mscLpDS3DS1ChanApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of this hardware component.')
mscLpDS3DS1ChanCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 11), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpDS3DS1ChanCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCidDataEntry.setDescription('An entry in the mscLpDS3DS1ChanCidDataTable.')
mscLpDS3DS1ChanCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpDS3DS1ChanIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 12), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpDS3DS1ChanIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfEntryEntry.setDescription('An entry in the mscLpDS3DS1ChanIfEntryTable.')
mscLpDS3DS1ChanIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpDS3DS1ChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpDS3DS1ChanOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 13), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpDS3DS1ChanOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperStatusEntry.setDescription('An entry in the mscLpDS3DS1ChanOperStatusTable.')
mscLpDS3DS1ChanSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpDS3DS1ChanStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpDS3DS1ChanStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanStateEntry.setDescription('An entry in the mscLpDS3DS1ChanStateTable.')
mscLpDS3DS1ChanAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3DS1ChanOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3DS1ChanUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS3DS1ChanAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpDS3DS1ChanProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpDS3DS1ChanControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpDS3DS1ChanAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpDS3DS1ChanStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpDS3DS1ChanUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpDS3DS1ChanOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 15), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperTable.setDescription('This group contains all of the operational data for a Channel component.')
mscLpDS3DS1ChanOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanOperEntry.setDescription('An entry in the mscLpDS3DS1ChanOperTable.')
mscLpDS3DS1ChanActualChannelSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 15, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanActualChannelSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanActualChannelSpeed.setDescription('This attribute displays the measured link speed of the Channel component.')
mscLpDS3DS1ChanAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 16), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpDS3DS1ChanAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanAdminInfoEntry.setDescription('An entry in the mscLpDS3DS1ChanAdminInfoTable.')
mscLpDS3DS1ChanVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanVendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanVendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpDS3DS1ChanCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 16, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCommentText.setDescription('Any miscellaneous text about the facility.')
mscLpDS3DS1ChanTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2))
mscLpDS3DS1ChanTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 1), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3DS1ChanTest components.')
mscLpDS3DS1ChanTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3DS1ChanTest component.')
mscLpDS3DS1ChanTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3DS1ChanTest components. These components cannot be added nor deleted.')
mscLpDS3DS1ChanTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3DS1ChanTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestStorageType.setDescription('This variable represents the storage type value for the mscLpDS3DS1ChanTest tables.')
mscLpDS3DS1ChanTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestIndex.setDescription('This variable represents the index for the mscLpDS3DS1ChanTest tables.')
mscLpDS3DS1ChanTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 10), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpDS3DS1ChanTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestStateEntry.setDescription('An entry in the mscLpDS3DS1ChanTestStateTable.')
mscLpDS3DS1ChanTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpDS3DS1ChanTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpDS3DS1ChanTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpDS3DS1ChanTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpDS3DS1ChanTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestSetupEntry.setDescription('An entry in the mscLpDS3DS1ChanTestSetupTable.')
mscLpDS3DS1ChanTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpDS3DS1ChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpDS3DS1ChanTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpDS3DS1ChanTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpDS3DS1ChanTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpDS3DS1ChanTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpDS3DS1ChanTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpDS3DS1ChanTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpDS3DS1ChanTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpDS3DS1ChanTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestResultsEntry.setDescription('An entry in the mscLpDS3DS1ChanTestResultsTable.')
mscLpDS3DS1ChanTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpDS3DS1ChanTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpDS3DS1ChanTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpDS3DS1ChanTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpDS3DS1ChanTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS3DS1ChanTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS3DS1ChanTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpDS3DS1ChanTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3DS1ChanTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3DS1ChanTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3DS1ChanTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpDS3DS1ChanCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3))
mscLpDS3DS1ChanCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 1), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3DS1ChanCell components.')
mscLpDS3DS1ChanCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3DS1ChanCell component.')
mscLpDS3DS1ChanCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3DS1ChanCell components. These components can be added and deleted.')
mscLpDS3DS1ChanCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3DS1ChanCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellStorageType.setDescription('This variable represents the storage type value for the mscLpDS3DS1ChanCell tables.')
mscLpDS3DS1ChanCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellIndex.setDescription('This variable represents the index for the mscLpDS3DS1ChanCell tables.')
mscLpDS3DS1ChanCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 10), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpDS3DS1ChanCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellProvEntry.setDescription('An entry in the mscLpDS3DS1ChanCellProvTable.')
mscLpDS3DS1ChanCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpDS3DS1ChanCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpDS3DS1ChanCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpDS3DS1ChanCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 11), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpDS3DS1ChanCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellOperEntry.setDescription('An entry in the mscLpDS3DS1ChanCellOperTable.')
mscLpDS3DS1ChanCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS3DS1ChanCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 12), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS3DS1ChanCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellStatsEntry.setDescription('An entry in the mscLpDS3DS1ChanCellStatsTable.')
mscLpDS3DS1ChanCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpDS3DS1ChanCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpDS3DS1ChanCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS3DS1ChanCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS3DS1ChanCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpDS3DS1ChanTc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4))
mscLpDS3DS1ChanTcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 1), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3DS1ChanTc components.')
mscLpDS3DS1ChanTcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3DS1ChanTc component.')
mscLpDS3DS1ChanTcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3DS1ChanTc components. These components can be added and deleted.')
mscLpDS3DS1ChanTcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3DS1ChanTcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcStorageType.setDescription('This variable represents the storage type value for the mscLpDS3DS1ChanTc tables.')
mscLpDS3DS1ChanTcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcIndex.setDescription('This variable represents the index for the mscLpDS3DS1ChanTc tables.')
mscLpDS3DS1ChanTcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 10), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcProvTable.setDescription('This group contains all specific provisioning data for a Tc component.')
mscLpDS3DS1ChanTcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcProvEntry.setDescription('An entry in the mscLpDS3DS1ChanTcProvTable.')
mscLpDS3DS1ChanTcReplacementData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 10, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcReplacementData.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcReplacementData.setDescription('This attribute specifies the trunk conditioning data byte to be substituted into the timeslots defined by the Chan component under fault conditions. replacementData can be set to any two digit hexadecimal number. The following are recommended values: DS1 MUX Out Of Service Code = 0x1A E1 MUX Out Of Service Code = 0xFF')
mscLpDS3DS1ChanTcSignalOneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSignalOneDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSignalOneDuration.setDescription('This attribute specifies the time duration in seconds for which signalOne is substituted into the appropriate signaling bits, when a lineType that uses CAS has been defined. When signalOneDuration has expired signalTwo is substituted into the appropriate signaling bits. If signalOneDuration is set to zero then only signalTwo is substituted into the appropriate signaling bits during error conditions. signalOneDuration can be set to any integer value from 0 to 60 seconds.')
mscLpDS3DS1ChanTcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 11), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcOpTable.setDescription('This group contains all specific operational data for a Tc component.')
mscLpDS3DS1ChanTcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcOpEntry.setDescription('An entry in the mscLpDS3DS1ChanTcOpTable.')
mscLpDS3DS1ChanTcIngressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcIngressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcIngressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the ATM network. When trunk conditioning is being locally generated towards the ATM network, ingressConditioning is set to on. When trunk conditioning is not being locally generated towards the ATM network, ingressConditioning is set to off. Trunk conditioning is transmitted towards the ATM network under the following conditions: lossOfSignal (LOS) lossOfFrame (LOF) remoteAlarmIndication (RAI) alarmIndicationSignal (AIS) bufferUnderflow (BU) and in addition for E1: lossOfMultiframe (LOMF) receiveMultiframeRemoteAlarmIndication (RMRAI)')
mscLpDS3DS1ChanTcEgressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcEgressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcEgressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the PDH line. When trunk conditioning is being locally generated towards the PDH line, egressConditioning is set to on. When trunk conditioning is not being locally generated towards the PDH line, egressConditioning is set to off. Trunk conditioning is transmitted towards the PDH line under the following conditions: bufferUnderflow (BU) AAL1 protocol errors.')
mscLpDS3DS1ChanTcSigOneTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 398), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted for the duration provisioned in signalOneDuration when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
mscLpDS3DS1ChanTcSigOneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 398, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTcIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTcSigOneIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneEntry.setDescription('An entry in the mscLpDS3DS1ChanTcSigOneTable.')
mscLpDS3DS1ChanTcSigOneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 398, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneIndex.setDescription('This variable represents the mscLpDS3DS1ChanTcSigOneTable specific index for the mscLpDS3DS1ChanTcSigOneTable.')
mscLpDS3DS1ChanTcSigOneValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 398, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigOneValue.setDescription('This variable represents an individual value for the mscLpDS3DS1ChanTcSigOneTable.')
mscLpDS3DS1ChanTcSigTwoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 399), )
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted after the duration provisioned in signalOneDuration has expired and when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
mscLpDS3DS1ChanTcSigTwoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 399, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTcIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1ChanTcSigTwoIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoEntry.setDescription('An entry in the mscLpDS3DS1ChanTcSigTwoTable.')
mscLpDS3DS1ChanTcSigTwoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 399, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoIndex.setDescription('This variable represents the mscLpDS3DS1ChanTcSigTwoTable specific index for the mscLpDS3DS1ChanTcSigTwoTable.')
mscLpDS3DS1ChanTcSigTwoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 2, 4, 399, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1ChanTcSigTwoValue.setDescription('This variable represents an individual value for the mscLpDS3DS1ChanTcSigTwoTable.')
mscLpDS3DS1Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3))
mscLpDS3DS1TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 1), )
if mibBuilder.loadTexts: mscLpDS3DS1TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS3DS1Test components.')
mscLpDS3DS1TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS3DS1Test component.')
mscLpDS3DS1TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS3DS1Test components. These components cannot be added nor deleted.')
mscLpDS3DS1TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS3DS1TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestStorageType.setDescription('This variable represents the storage type value for the mscLpDS3DS1Test tables.')
mscLpDS3DS1TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS3DS1TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestIndex.setDescription('This variable represents the index for the mscLpDS3DS1Test tables.')
mscLpDS3DS1TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 10), )
if mibBuilder.loadTexts: mscLpDS3DS1TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpDS3DS1TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestStateEntry.setDescription('An entry in the mscLpDS3DS1TestStateTable.')
mscLpDS3DS1TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpDS3DS1TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpDS3DS1TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpDS3DS1TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11), )
if mibBuilder.loadTexts: mscLpDS3DS1TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpDS3DS1TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestSetupEntry.setDescription('An entry in the mscLpDS3DS1TestSetupTable.')
mscLpDS3DS1TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpDS3DS1TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpDS3DS1TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpDS3DS1TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpDS3DS1TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpDS3DS1TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpDS3DS1TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpDS3DS1TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS3DS1TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpDS3DS1TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12), )
if mibBuilder.loadTexts: mscLpDS3DS1TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpDS3DS1TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS3DS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS3DS1TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestResultsEntry.setDescription('An entry in the mscLpDS3DS1TestResultsTable.')
mscLpDS3DS1TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpDS3DS1TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpDS3DS1TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpDS3DS1TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpDS3DS1TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS3DS1TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS3DS1TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpDS3DS1TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3DS1TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3DS1TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS3DS1TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 5, 6, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS3DS1TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS3DS1TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpE3 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6))
mscLpE3RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 1), )
if mibBuilder.loadTexts: mscLpE3RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE3 components.')
mscLpE3RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3RowStatusEntry.setDescription('A single entry in the table represents a single mscLpE3 component.')
mscLpE3RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE3 components. These components can be added and deleted.')
mscLpE3ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE3StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3StorageType.setDescription('This variable represents the storage type value for the mscLpE3 tables.')
mscLpE3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 11)))
if mibBuilder.loadTexts: mscLpE3Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3Index.setDescription('This variable represents the index for the mscLpE3 tables.')
mscLpE3ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10), )
if mibBuilder.loadTexts: mscLpE3ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ProvTable.setDescription('This group contains all of the provisioning data for a E3 component.')
mscLpE3ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ProvEntry.setDescription('An entry in the mscLpE3ProvTable.')
mscLpE3LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 300)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LineLength.setDescription('This attribute defines the line length for equalization calculations for the E3 line. The line length range is between 0 and 300 metres (1 metres = 3.28 feet).')
mscLpE3ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ClockingSource.setDescription("This attribute defines the type of clocking source used for synchronizing the E3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means use of a signal phase-locked to the incoming E3 line rate; module means the use of a signal phase-locked to the CP reference clock. Note that the multiport cell-based cards have one common clock source for each of the three ports. For this reason, the following rules apply for the value of clockingSource across the board's three ports: All three clockingSource values must be 'local' OR All three clockingSource values must be 'module' OR One clockingSource value must be 'line' and the other two must be 'otherPort'. The default value for this attribute will be module if a CP clock is available, and local otherwise.")
mscLpE3ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the E3 component.')
mscLpE3Mapping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("direct", 0), ("plcp", 1))).clone('direct')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3Mapping.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3Mapping.setDescription('This attribute indicates if ATM cells will be mapped directly into the E3 payload, or whether PLCP mapping will be used. The PLCP component will appear under the E3 component when this attribute is set to plcp. This attribute will be ignored when set on frame- based cards.')
mscLpE3Framing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("g751", 0), ("g832", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3Framing.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3Framing.setDescription('This attribute indicates if the framing mode will be in accordance with the CCITT G.751 or G.832 specification. The G832 component will appear under the E3 component when this attribute is set to g832. This attribute may only be set on cell-based card types. Note also that this attribute may only be set to g751 if the mapping attribute is set to plcp. The default value of this attribute will be g751 for frame-based cards, and g832 for cell-based cards. Note: when E3 framing is changed from g832 to g751, the G832 component must be deleted.')
mscLpE3LinkAlarmActivationThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 2600)).clone(2200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3LinkAlarmActivationThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LinkAlarmActivationThreshold.setDescription('This attribute specifies the time interval between the detection of a sustained link failure and the activation of an alarm. It is provisionable for E3 cards.')
mscLpE3LinkAlarmScanInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(50, 250)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3LinkAlarmScanInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LinkAlarmScanInterval.setDescription('This attribute specifies the alarm scan timer polling interval. It determines how frequently the status of the link is monitored after a first link error interrupt. It is provisionable for E3 cards.')
mscLpE3CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 11), )
if mibBuilder.loadTexts: mscLpE3CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpE3CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CidDataEntry.setDescription('An entry in the mscLpE3CidDataTable.')
mscLpE3CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpE3AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 12), )
if mibBuilder.loadTexts: mscLpE3AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpE3AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3AdminInfoEntry.setDescription('An entry in the mscLpE3AdminInfoTable.')
mscLpE3Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpE3CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpE3IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 13), )
if mibBuilder.loadTexts: mscLpE3IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpE3IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3IfEntryEntry.setDescription('An entry in the mscLpE3IfEntryTable.')
mscLpE3IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpE3IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpE3OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 14), )
if mibBuilder.loadTexts: mscLpE3OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpE3OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3OperStatusEntry.setDescription('An entry in the mscLpE3OperStatusTable.')
mscLpE3SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpE3StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15), )
if mibBuilder.loadTexts: mscLpE3StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpE3StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3StateEntry.setDescription('An entry in the mscLpE3StateTable.')
mscLpE3AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE3OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE3UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE3AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpE3ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpE3ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpE3AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpE3StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpE3UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpE3OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16), )
if mibBuilder.loadTexts: mscLpE3OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3OperTable.setDescription('This group contains the common operational data for E3 component.')
mscLpE3OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3OperEntry.setDescription('An entry in the mscLpE3OperTable.')
mscLpE3LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LosAlarm.setDescription('This attribute displays whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects has been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOS defect is detected at the E3 line interface upon observing N continuous pulse positions with no pulses of either positive or negative polarity, where N is between 10 and 255. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared when the LOS defects are absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpE3LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when Severely Errored Frame (SEF) defects have been detected and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An E3 SEF defect is reported after detecting Frame Alignment Signal (FAS) errors on 4 consecutive E3 frames received on the incoming line. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when E3 framing has been achieved for a period of 10 seconds +/- 0.5 seconds. As long as SEF defects are detected, the node also transmits the far-end SEF/AIS (in G.751 E3) or FERF (in G.832) defect indicator over the outgoing line. The txRai attribute is set to on when transmitting the far-end SEF/AIS defect indicator on the outgoing line. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpE3RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3RxAisAlarm.setDescription('This attribute displays whether an Alarm Indication Signal (AIS) alarm when state has been entered. An AIS alarm state is entered when AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds on the incoming E3 line. An AIS defect is the occurrence of the AIS (unframed signal with a density of zeros below a certain threshold such as defined by ITU Recommendation G.775). If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/ 10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the AIS alarm condition is cleared (after AIS has been no longer detected for a period of 10 seconds +/- 0.5 seconds). As long as AIS is detected on the incoming line, the node also transmits the far-end SEF/AIS (in G.751 E3) or FERF (in G.832) defect indicator over the outgoing line. The txRai attribute is set to on when transmitting the far-end SEF/AIS defect indicator on the outgoing line. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpE3RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3RxRaiAlarm.setDescription('This attribute displays whether a Remote Alarm Indication (RAI) alarm state has been entered. A RAI alarm state is entered when far- end SEF/AIS defects (or Far-End Receive Failure (FERF) defects in G.832 E3 Framing mode) have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds on the E3 incoming line. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The E3 component goes into an operational state of disabled until the RAI alarm condition is cleared. The condition is cleared when the far-end defect indicator has not been detected for 10 seconds +/- 0.5 seconds. The declaration of a RAI Alarm is usually a signal that the far end facility is unable to gain synchronization. The rxRaiAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpE3TxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TxAis.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TxAis.setDescription('This attribute displays whether an AIS alarm is being transmitted on the E3 line. AIS is transmitted on the outgoing line when the E3 component is locked and not used for operational testing.')
mscLpE3TxRai = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TxRai.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TxRai.setDescription("This attribute displays whether the far-end SEF/AIS defect indicator is transmitted over the outgoing line when the E3 component has been unlocked or used in operational testing. When the E3 component is locked and not used in operational testing, this attribute is always set to off. The far-end SEF/AIS defect indicator is transmitted over the outgoing line when SEF/AIS defects are detected on the incoming line. In G.832 E3 Framing mode, the FERF bit is set to '1' to transmit the SEF/AIS defect indicator.")
mscLpE3StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17), )
if mibBuilder.loadTexts: mscLpE3StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3StatsTable.setDescription('This group contains the common operational data for E3 component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"))
if mibBuilder.loadTexts: mscLpE3StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3StatsEntry.setDescription('An entry in the mscLpE3StatsTable.')
mscLpE3RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3RunningTime.setDescription("This attribute indicates the total number of seconds since the E3 component has been activated and been in unlocked state or used for operational testing. All the other error counts that follow as well as each E3 subcomponent's error counts can be updated when this count is active.")
mscLpE3ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3ErrorFreeSec.setDescription('This attribute indicates the number of seconds that the E3 port has been in an error free state.')
mscLpE3LineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3LineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCV) detected. An E3 Line Code Violation is an HDB3 coded signal error. LCV counting is inhibited for second intervals where a Line Severely Errored Second (LSES) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3LineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3LineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LES) that have been counted. A LES is declared for interval seconds containing one or more Line Code Violations (LCV) or one or more Loss Of Signal (LOS) defects.')
mscLpE3LineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3LineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSES) that have been counted. A LSES is declared for second intervals containing more than 34 Line Code Violations (LCV) or one or more Loss of Signal (LOS) defects.')
mscLpE3LineLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3LineLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LineLosSec.setDescription('This attribute indicates the total number of Line LOS Seconds (LOSS) that have been counted. A LOSS is declared for second intervals containing one or more Loss of Signal (LOS) defects.')
mscLpE3LineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3LineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3LineFailures.setDescription('This attribute indicates the total number of times that a line failure (LOS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3PathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCV) detected. An E3 PCV is an error in the Frame Alignment (FA) signal, or, in G.832 Framing Mode, an error in the Frame Alignment signal or a BIP-8 error. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3PathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PES) that have been counted. A PES is declared for second intervals containing one or more Path Code Violations (PCV) or one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of Path Errored Seconds is inhibited when a Path Unavailable Second (PUAS) is counted over the monitored second.')
mscLpE3PathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSES) that have been counted. A PSES is declared for second intervals containing more than 22 (G.751 E3) or 34 (G.832 E3) Path Code Violations (PCV) or one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of PSESs is inhibited when a Path Unavailable Second (PUAS) is counted over the monitored second.')
mscLpE3PathSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PathSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PathSefAisSec.setDescription('This attribute indicates the total number of Path SEF/AIS Seconds (PSAS). A PSAS is declared for second intervals containing one or more Severely Errored Frame (SEF) or Alarm Indication Signal (AIS) defects. Counting of PSAS is inhibited when Path Unavailable Seconds (PUAS) is counted over the monitored second.')
mscLpE3PathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the E3 path is unavailable. The E3 path becomes unavailable at the onset of 10 consecutive Path Severely Errored Seconds (PSES). The 10 PSESs are included in the unavailable time. Once unavailable, the E3 path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where PUAS is counted, counting of Path Code Violations (PCV), Path Errored Seconds (PES), Path Severely Errored Seconds (PSES) and Path SefAis Seconds (PSAS) is inhibited.')
mscLpE3PathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOF/AIS failure) has been declared. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2))
mscLpE3TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 1), )
if mibBuilder.loadTexts: mscLpE3TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE3Test components.')
mscLpE3TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3TestIndex"))
if mibBuilder.loadTexts: mscLpE3TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE3Test component.')
mscLpE3TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE3Test components. These components cannot be added nor deleted.')
mscLpE3TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE3TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestStorageType.setDescription('This variable represents the storage type value for the mscLpE3Test tables.')
mscLpE3TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE3TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestIndex.setDescription('This variable represents the index for the mscLpE3Test tables.')
mscLpE3TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 10), )
if mibBuilder.loadTexts: mscLpE3TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpE3TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3TestIndex"))
if mibBuilder.loadTexts: mscLpE3TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestStateEntry.setDescription('An entry in the mscLpE3TestStateTable.')
mscLpE3TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpE3TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpE3TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpE3TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11), )
if mibBuilder.loadTexts: mscLpE3TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpE3TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3TestIndex"))
if mibBuilder.loadTexts: mscLpE3TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestSetupEntry.setDescription('An entry in the mscLpE3TestSetupTable.')
mscLpE3TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpE3TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpE3TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpE3TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpE3TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpE3TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpE3TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpE3TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpE3TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12), )
if mibBuilder.loadTexts: mscLpE3TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpE3TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3TestIndex"))
if mibBuilder.loadTexts: mscLpE3TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestResultsEntry.setDescription('An entry in the mscLpE3TestResultsTable.')
mscLpE3TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpE3TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpE3TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpE3TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpE3TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpE3TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpE3TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpE3TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE3TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE3TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE3TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpE3G832 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3))
mscLpE3G832RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 1), )
if mibBuilder.loadTexts: mscLpE3G832RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE3G832 components.')
mscLpE3G832RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3G832Index"))
if mibBuilder.loadTexts: mscLpE3G832RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832RowStatusEntry.setDescription('A single entry in the table represents a single mscLpE3G832 component.')
mscLpE3G832RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3G832RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE3G832 components. These components can be added and deleted.')
mscLpE3G832ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE3G832StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832StorageType.setDescription('This variable represents the storage type value for the mscLpE3G832 tables.')
mscLpE3G832Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE3G832Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832Index.setDescription('This variable represents the index for the mscLpE3G832 tables.')
mscLpE3G832ProvisionedTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 10), )
if mibBuilder.loadTexts: mscLpE3G832ProvisionedTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832ProvisionedTable.setDescription('This group contains the provisionable data for the G832 component.')
mscLpE3G832ProvisionedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3G832Index"))
if mibBuilder.loadTexts: mscLpE3G832ProvisionedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832ProvisionedEntry.setDescription('An entry in the mscLpE3G832ProvisionedTable.')
mscLpE3G832TrailTraceTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 15)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3G832TrailTraceTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832TrailTraceTransmitted.setDescription('This attribute indicates the E.164 address which is to be encoded in the trail access point identifier, which is transmitted using the Trail Trace (TR) field of the transmitted E3 Frame. Both the expected trail access point identifier and the transmitted trail access point identifier are provisionable attributes of the G832 component. The 16 byte Trail Trace frame is composed of one byte containing a frame start marker and a CRC-7 calculation over the previous frame, and 15 bytes for transporting an E.164 address. If less than the full 15 bytes are used, the address is padded with NULL characters.')
mscLpE3G832TrailTraceExpected = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 15)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3G832TrailTraceExpected.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832TrailTraceExpected.setDescription('This attribute indicates the E.164 address which is expected in the trail access point identifier, which is transmitted using the Trail Trace (TR) field of the transmitted E3 Frame. Both the expected trail access point identifier and the transmitted trail access point identifier are provisionable attributes of the G832 component. The 16 byte Trail Trace frame is composed of one byte containing a frame start marker and a CRC-7 calculation over the previous frame, and 15 bytes for transporting an E.164 address. If less than the full 15 bytes are used, the address is padded with NULL characters.')
mscLpE3G832OperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 11), )
if mibBuilder.loadTexts: mscLpE3G832OperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832OperationalTable.setDescription('This group contains the operational data for the G832 component.')
mscLpE3G832OperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3G832Index"))
if mibBuilder.loadTexts: mscLpE3G832OperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832OperationalEntry.setDescription('An entry in the mscLpE3G832OperationalTable.')
mscLpE3G832UnexpectedPayloadType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832UnexpectedPayloadType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832UnexpectedPayloadType.setDescription('This attribute displays whether the Unexpected Payload Type (UPT) alarm state has been entered. The UPT alarm state is entered when UPT defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The UPT defect is reported when a received frame fails to agree with the expected Payload Type. If the UPT defects are intermittently occurring, the UPT defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle.. The UPT alarm is cleared when the Payload Type in the received frame agrees with the expected Payload Type for a period of 10 seconds +/- 0.5 seconds. The unexpectedPayloadType attribute is always set to off when the E3 component has been locked and left offline.')
mscLpE3G832TrailTraceMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832TrailTraceMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832TrailTraceMismatch.setDescription('This attribute displays whether the Trail Trace Mismatch (TTM) alarm state has been entered. The TTM alarm state is entered when TTM defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The TTM defect is reported when the trail access point identifier contained in the Trail Trace (TR) field in the received frame fails to agree with the expected identifier. If the TTM defects are intermittently occurring, the TTM defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The TTM alarm is cleared when the trail access point identifier in the received frame agrees with the expected identifier for a period of 10 seconds +/- 0.5 seconds. The trailTraceMismatch attribute is always set to off when the E3 component has been locked and left offline. Both the expected trail access identifier and the transmitted trail access identifier are provisionable attributes of the G832 component.')
mscLpE3G832TimingMarker = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notTraceable", 0), ("traceable", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832TimingMarker.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832TimingMarker.setDescription('Indicates whether or not the timing source at the far-end node is traceable to a Primary Reference Clock. The timingMarker indication is controlled by the timing marker bit in the G832 MA byte. If the received timing marker bit is 1 for five consecutive frames, and five consecutive 0s are not received for two seconds, the timingMarker indication will be set to not traceable. If the received timing marker bit is 0 for five consecutive frames and five consecutive 1s are not received for two seconds, the timingMarker indication will be set to traceable.')
mscLpE3G832TrailTraceReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 11, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832TrailTraceReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832TrailTraceReceived.setDescription('This attribute indicates the 15 byte E.164 address which is currently being received in the trail trace (TR) field of the E3 G832 frame. If this attribute differs from the provisioned trailTraceTransmitted string a trail trace mismatch (TTM) defect is reported, possibly resulting in a TTM alarm, as described for operational attribute trailTraceMismatch.')
mscLpE3G832StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12), )
if mibBuilder.loadTexts: mscLpE3G832StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832StatsTable.setDescription('This group contains the statistical data for the G832 component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3G832StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3G832Index"))
if mibBuilder.loadTexts: mscLpE3G832StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832StatsEntry.setDescription('An entry in the mscLpE3G832StatsTable.')
mscLpE3G832FarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832FarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832FarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds that the E3 line has not suffered any G832 errors.')
mscLpE3G832FarEndCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832FarEndCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832FarEndCodeViolations.setDescription('A count of E3 frames containing a Far-End Block Error (FEBE). A FEBE is reported over the FEBE bit each time the far-end terminal detects a BIP-8 error in a received E3 frame. For second intervals where Far End Unavailable Seconds (FEUAS) or Far End Severely Errored Seconds (FESES) are counted, counting of FECVs is inhibited. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3G832FarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832FarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832FarEndErroredSec.setDescription('This attribute indicates the total number of Far-End Errored Seconds (FEES). A FEES is declared for second intervals containing with one or more Far-End Coding Violations (FECV) or one or more Far-End Receive Failure (FERF) defects. A FERF defect occurs when the FERF bit in the received frame is set to one. For second intervals where Far End Unavailable Seconds (FEUAS) are counted, counting of FEESs is inhibited.')
mscLpE3G832FarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832FarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832FarEndSevErroredSec.setDescription('This attribute indicates the total number of Far-End Severely Errored Seconds (FESESs). A FESES is declared for second intervals containing more than 34 Far-End Coding Violations (FECV) or one or more Far-End Receive Failure (FERF) defects. For second intervals where a Far-End Severely Errored Seconds (FESES) is counted, counting of FECVs is inhibited. For second intervals where Far End Unavailable Seconds (FEUAS) are counted, counting of FESESs is inhibited.')
mscLpE3G832FarEndSefAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832FarEndSefAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832FarEndSefAisSec.setDescription('This attribute indicates the total number of Far-End SEF/AIS Seconds (FESAS). A FESAS is declared for second intervals containing one or more Far-End Receive Failure (FERF) defects. For second intervals where Far End Unavailable Seconds (FEUAS) are counted, counting of FESAS is inhibited.')
mscLpE3G832FarEndUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 3, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3G832FarEndUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3G832FarEndUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the E3 far-end path is unavailable. The E3 far-end path becomes unavailable at the onset of 10 consecutive Far End Severely Errored Seconds (FESES). It comes available at the onset of 10 contiguous seconds with no FESES. The unavailable time includes the initial 10 seconds to enter the unavailable state but not the 10 seconds to exit the state For second intervals where FEUAS is counted, counting of Far End Coding Violations (FECV), Far- End Errored Seconds (FEES), Far-End Severely Errored Seconds (FESES) and Far-End SefAis Seconds (FESAS) are inhibited.')
mscLpE3Plcp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4))
mscLpE3PlcpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 1), )
if mibBuilder.loadTexts: mscLpE3PlcpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE3Plcp components.')
mscLpE3PlcpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3PlcpIndex"))
if mibBuilder.loadTexts: mscLpE3PlcpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE3Plcp component.')
mscLpE3PlcpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE3Plcp components. These components cannot be added nor deleted.')
mscLpE3PlcpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE3PlcpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpStorageType.setDescription('This variable represents the storage type value for the mscLpE3Plcp tables.')
mscLpE3PlcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE3PlcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpIndex.setDescription('This variable represents the index for the mscLpE3Plcp tables.')
mscLpE3PlcpOperationalTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 10), )
if mibBuilder.loadTexts: mscLpE3PlcpOperationalTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpOperationalTable.setDescription('This group contains the operational data for the PLCP component.')
mscLpE3PlcpOperationalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3PlcpIndex"))
if mibBuilder.loadTexts: mscLpE3PlcpOperationalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpOperationalEntry.setDescription('An entry in the mscLpE3PlcpOperationalTable.')
mscLpE3PlcpLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpLofAlarm.setDescription('This attribute displays whether a PLCP Loss Of Frame (LOF) failure alarm state has been entered. An LOF failure is declared when a PLCP LOF defect persists for 2.5 s +/- 0.5 s. An LOF defect occurs when an OOF (Out of Frame) state persists for more than 1 ms. If the OOF events are intermittent, the LOF defect counter is decremented at a rate of 1/12 (for DS3 PLCP) or 1/9 (for G.751 E3 PLCP) of the incrementing rate, with all measurements based on a 200 ms polling cycle. An OOF event (also known as a PLCP SEF event) is declared when an error is detected in both the A1 and A2 octets, or when two consecutive POHIDs are found in error. OOF is removed when two valid sets of framing octets and two valid and sequential POHID octets have been found. The LOF defect is removed when the defect counter reaches zero, i.e. when OOF events are absent for more than 12 ms (DS3 PLCP) or 9 ms (G.751 E3 PLCP). LOF failure alarm is cleared when LOF defect is absent for 10.0 s +/- 0.5 s The DS3 or E3 component goes into an operational state of disabled until the LOF failure alarm is cleared. The terminal declaring the LOF failure alarm will transmit a PLCP RAI signal to the far-end for the duration of the alarm. The lofAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
mscLpE3PlcpRxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpRxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpRxRaiAlarm.setDescription('This attribute displays whether a PLCP Remote Alarm Indication (RAI) failure alarm state has been entered. An RAI failure alarm occurs when ten consecutive PLCP RAI bits (bit 5 in the G1 byte) are high on the incoming line. An RAI failure alarm is cleared when ten consecutive RAI bits are set to 0. Note: Some standards call this alarm RFI. The rxRaiAlarm attribute is always set to off when the DS3 or E3 component has been locked and left offline.')
mscLpE3PlcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11), )
if mibBuilder.loadTexts: mscLpE3PlcpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpStatsTable.setDescription('This group contains the statistical data for the PLCP component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3PlcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3PlcpIndex"))
if mibBuilder.loadTexts: mscLpE3PlcpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpStatsEntry.setDescription('An entry in the mscLpE3PlcpStatsTable.')
mscLpE3PlcpErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the near-end PLCP path layer had no errors.')
mscLpE3PlcpCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpCodingViolations.setDescription('This attribute indicates the total number of BIP-8 Errors, framing pattern octet errors, and path overhead identification errors detected in received PLCP frames. Counting of PLCP CV is inhibited for second intervals where PLCP Severely Errored Framing Seconds (SEFS) or PLCP Unavailable Seconds (UAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3PlcpErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Coding Violations (CV) or in which a PLCP Severely Errored Framing Second (SEFS) was counted. Counting of PLCP ES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
mscLpE3PlcpSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCPCVs or in which a PLCPSEFS was counted (i.e. a PLCP OOF event occurred). Counting of PLCP SES is inhibited during second intervals where PLCP Unavailable Seconds (UAS) are counted.')
mscLpE3PlcpSevErroredFramingSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpSevErroredFramingSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpSevErroredFramingSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Severely Errored Frame (SEF) events. An SEF event is equivalent to a PLCP OOF (Out of Frame) event. Counting of PLCPP SEFSs is inhibited for second intervals where PLCP Unavailable Seconds (UAS) are counted.')
mscLpE3PlcpUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpUnavailSec.setDescription('This attribute indicates the number of seconds when the near-end PLCP layer is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP LOF (Loss of Frame) failure alarm state. The PLCP Path Layer becomes available again only after clearing this condition. For second intervals where PLCP UAS are counted, counting of PLCP Severely Errored Framing Seconds (SEFS), PLCP Coding Violations (CV), PLCP Errored Seconds (ES), PLCP Severely Errored Seconds (SES) and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
mscLpE3PlcpFarEndErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpFarEndErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpFarEndErrorFreeSec.setDescription('This attribute indicates the number of seconds during which the far- end PLCP path layer had no errors.')
mscLpE3PlcpFarEndCodingViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpFarEndCodingViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpFarEndCodingViolations.setDescription('This attribute indicates the total number of PLCP Far-End Block Errors (FEBE) reported by the far-end terminal. Counting of FEBEs is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted. This attribute is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3PlcpFarEndErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpFarEndErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpFarEndErroredSec.setDescription('This attribute indicates the number of seconds containing one or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FEES is inhibited during second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
mscLpE3PlcpFarEndSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpFarEndSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpFarEndSevErroredSec.setDescription('This attribute indicates the number of seconds containing 5 or more PLCP Far-End Coding Violations (FECV). Counting of PLCP FESES is inhibited for second intervals where PLCP Far-End Unavailable Seconds (FEUAS) are counted.')
mscLpE3PlcpFarEndUnavailableSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 4, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3PlcpFarEndUnavailableSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3PlcpFarEndUnavailableSec.setDescription('This attribute indicates the number of seconds during which the PLCP far end is unavailable. The PLCP Path Layer becomes unavailable at the declaration of PLCP RAI (Remote Alarm Indication). Service becomes available again after this condition is cleared. For second intervals where PLCP FEUAS are counted, counting of PLCP Far-End Coding Violations (FECV), PLCP Far- End Errored Seconds (FEES), and PLCP Far-End Severely Errored Seconds (FESES) is inhibited.')
mscLpE3Cell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5))
mscLpE3CellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 1), )
if mibBuilder.loadTexts: mscLpE3CellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE3Cell components.')
mscLpE3CellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3CellIndex"))
if mibBuilder.loadTexts: mscLpE3CellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE3Cell component.')
mscLpE3CellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3CellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE3Cell components. These components can be added and deleted.')
mscLpE3CellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE3CellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellStorageType.setDescription('This variable represents the storage type value for the mscLpE3Cell tables.')
mscLpE3CellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE3CellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellIndex.setDescription('This variable represents the index for the mscLpE3Cell tables.')
mscLpE3CellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 10), )
if mibBuilder.loadTexts: mscLpE3CellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpE3CellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3CellIndex"))
if mibBuilder.loadTexts: mscLpE3CellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellProvEntry.setDescription('An entry in the mscLpE3CellProvTable.')
mscLpE3CellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3CellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpE3CellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3CellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpE3CellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE3CellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpE3CellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 11), )
if mibBuilder.loadTexts: mscLpE3CellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpE3CellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3CellIndex"))
if mibBuilder.loadTexts: mscLpE3CellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellOperEntry.setDescription('An entry in the mscLpE3CellOperTable.')
mscLpE3CellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpE3CellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 12), )
if mibBuilder.loadTexts: mscLpE3CellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE3CellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE3CellIndex"))
if mibBuilder.loadTexts: mscLpE3CellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellStatsEntry.setDescription('An entry in the mscLpE3CellStatsTable.')
mscLpE3CellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpE3CellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpE3CellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpE3CellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpE3CellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 6, 5, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE3CellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE3CellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpDS1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7))
mscLpDS1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 1), )
if mibBuilder.loadTexts: mscLpDS1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1 components.')
mscLpDS1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1RowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1 component.')
mscLpDS1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1 components. These components can be added and deleted.')
mscLpDS1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1StorageType.setDescription('This variable represents the storage type value for the mscLpDS1 tables.')
mscLpDS1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)))
if mibBuilder.loadTexts: mscLpDS1Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1Index.setDescription('This variable represents the index for the mscLpDS1 tables.')
mscLpDS1ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 10), )
if mibBuilder.loadTexts: mscLpDS1ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ProvTable.setDescription('This group contains all of the provisioning data for a DS1 component.')
mscLpDS1ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ProvEntry.setDescription('An entry in the mscLpDS1ProvTable.')
mscLpDS1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5, 6))).clone(namedValues=NamedValues(("d4", 0), ("esf", 1), ("d4Cas", 4), ("esfCas", 5), ("unframed", 6))).clone('esf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1LineType.setDescription('This attribute defines the framing of the DS1 line. d4 defines a framing pattern of 12 frames per multiframe. esf defines a framing pattern of 24 frames per multiframe. d4Cas defines a framing pattern of 12 frames per multiframe with channel associated signalling. esfCas defines a framing pattern of 24 frames per multiframe with channel associated signalling. unframed defines an unknown framing pattern for clear channels. For cell-based cards only the default option esf is permitted.')
mscLpDS1ZeroCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("bit7Stuffing", 0), ("b8zs", 1), ("ami", 2))).clone('b8zs')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ZeroCoding.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ZeroCoding.setDescription("This attribute defines the zero encoding on the DS1 line. bit7Stuffing sets bit 7 of every timeslot to a one to guarantee ones's density. This reduces the available bandwidth of the channel by 1/8. b8zs substitutes a pattern of bipolar violations if more than 7 zeros in a row are to be transported. ami specifies Alternate Mark Inversion, in which successive marks (ones) alternate between positive and negative polarity voltage signals, and spaces (zeros) are sent as a zero amplitude signal. When zeroCoding is set to ami and lineType is set to d4, it is recommended that raiAlarmType be set to SBit in order to avoid possible mimic RAI alarm. For cell-based cards only the default value b8zs is permitted.")
mscLpDS1ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 3), ("srtsMode", 4), ("adaptiveMode", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ClockingSource.setDescription("This attribute defines the source of the transmit clock for the DS1 line. When local is selected, the crystal on the port generates the clocking for the line. When line is selected, the port synchronizes to the clock from the facility. When module is selected, the ports clock synchronizes to the clock provided by the oscillator on the active CP. When otherPort is selected, the port synchronizes to the port with a clocking source of line. When srtsMode is selected, the port transmit frequency depends on the SRTS (Synchronous Residual Time-Stamp) received over the ATM network. SRTS information is also generated sent over the ATM network. When adaptiveMode is selected, the port transmit frequency continually adapts to match the egress data received from the ATM network. A port with srtsMode or adaptiveMode must have a single Chan which may be linked only to an Aal1Ces.service with serviceType unstructured If the NetworkSynchronization component is present, the default value of this attribute is module, otherwise it defaults to line, except for the 3pDS1Atm card, which it defaults to local. On a 3pDS1Atm card all ports must have the same value, and be either local or module. otherPort is valid only on AAL1 cards. srtsMode is valid only on AAL1 and Multi-Service Access cards. adaptiveMode is valid only on Multi-Service Access cards. On 4DS1Aal1 cards either: all four ports' clockingSource values must be local OR all four ports' clockingSource values must be module OR one port's clockingSource value must be line and the other three must be otherPort. A port can only have srtsMode selected if the other ports are module or srtsMode.")
mscLpDS1RaiAlarmType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("sBit", 0), ("bit2", 1), ("fdl", 2))).clone('fdl')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1RaiAlarmType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1RaiAlarmType.setDescription("This attribute defines the method of sending a RAI (Remote Alarm Indication) alarm on a DS1 line. When SBit is selected, RAI alarm is sent by setting the S bit in frame 12. When Bit2 is selected, RAI alarm is sent by setting bit 2 in all timeslots to 0. When fdl is selected, RAI alarm is sent by a repeating pattern of 00 hex and FF hex on the FDL link. Note that for lineType of d4, only the SBit and the Bit2 methods are applicable. Whereas for lineType of esf, only the Bit2 and the fdl methods are applicable. SBit method is recommended if lineType is set to d4 and zeroCoding is set to ami. This will help to avoid potential mimic RAI alarm when 1's density is too low in the data transmitted. For cell-based cards only the default value fdl is permitted.")
mscLpDS1LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 655))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1LineLength.setDescription('This attribute defines the line length (in feet) for equalization calculations for the DS1 line. The value ranges between 0-655. For 8pDS1Atm cards the actual value used for equalization is rounded up to the nearest 110 feet; for all other card types the actual value used is rounded to the nearest 50 feet.')
mscLpDS1CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 11), )
if mibBuilder.loadTexts: mscLpDS1CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpDS1CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1CidDataEntry.setDescription('An entry in the mscLpDS1CidDataTable.')
mscLpDS1CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpDS1AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 12), )
if mibBuilder.loadTexts: mscLpDS1AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpDS1AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AdminInfoEntry.setDescription('An entry in the mscLpDS1AdminInfoTable.')
mscLpDS1Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpDS1CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpDS1IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 13), )
if mibBuilder.loadTexts: mscLpDS1IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpDS1IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1IfEntryEntry.setDescription('An entry in the mscLpDS1IfEntryTable.')
mscLpDS1IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpDS1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpDS1OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 14), )
if mibBuilder.loadTexts: mscLpDS1OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpDS1OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1OperStatusEntry.setDescription('An entry in the mscLpDS1OperStatusTable.')
mscLpDS1SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpDS1StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15), )
if mibBuilder.loadTexts: mscLpDS1StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpDS1StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1StateEntry.setDescription('An entry in the mscLpDS1StateTable.')
mscLpDS1AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS1OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS1UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS1AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpDS1ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpDS1ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpDS1AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpDS1StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpDS1UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpDS1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16), )
if mibBuilder.loadTexts: mscLpDS1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1OperTable.setDescription('This group contains the common operational data for a component in a digital hierarchy interface.')
mscLpDS1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1OperEntry.setDescription('An entry in the mscLpDS1OperTable.')
mscLpDS1LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1LosAlarm.setDescription('This attribute displays whether a LOS (Loss of Signal) alarm state has been entered. A LOS alarm is declared after LOS defects have been observed and accumulated for a period of 2 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). A LOS defect is detected upon observing all zeros for 150 ms (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: upon observing 175 +/- 75 pulse positions with no pulses of either positive or negative polarity). If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOS alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOS alarm state. The LOS alarm state is cleared when LOS defects are absent for 10 seconds +/- 0.5 seconds.')
mscLpDS1RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1RxAisAlarm.setDescription("This attribute displays whether an AIS (Alarm Indication Signal) alarm state has been entered. The AIS Alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/ - 0.5 seconds. An AIS defect is detected after having received less than 3 zeros in a 2048 bit period (for 8pDS1Atm cards: when both an Out Of Frame condition exists and a 1's density of at least 99.9% is present for a time T, where 3 ms T 75 ms; for 8pE1Atm cards: when both an Out Of Frame condition exists and fewer than three 0's have been received in 512 bit periods). If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled for the duration of an AIS alarm state. The AIS alarm state is cleared when AIS defects are absent for 10 seconds +/- 0.5 seconds.")
mscLpDS1LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1LofAlarm.setDescription('This attribute displays whether a LOF (Loss of Frame) alarm state has been entered. The LOF alarm state is entered when LOF defects (for DS1: 2 out of 5 framing bits in error; for E1: 3 consecutive frame alignment patterns in error) have been detected for 3 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOF alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOF alarm state The condition is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds.')
mscLpDS1RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1RxRaiAlarm.setDescription('This attribute displays whether an RAI (Remote Alarm Indication) alarm state has been entered. An RAI alarm state is entered when the RAI defect indicator has been observed and accumulated for 3.5 seconds +/- 0.5 seconds. For 3pDS1Atm, and 8pDS1Atm cards: alarm is declared immediately upon observing the defect is present, with no integration time. For 3pE1Atm, and 8pE1Atm cards: alarm state is entered when the RAI defect indicator has been observed and accumulated for 2.5 seconds +/- 0.5 seconds. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The RAI alarm state is cleared when the RAI defect indicator has been absent for 10 seconds +/- 0.5 seconds (for 3pDS1Atm, and 8pDS1Atm cards: alarm is cleared immediately upon observing the defect is absent, with no integration time). The RAI alarm is usually an indication that the far end facility is unable to gain synchronization.')
mscLpDS1TxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TxAisAlarm.setDescription('This attribute displays whether an AIS (Alarm Indication Signal) alarm is being transmitted on the line. An AIS alarm is transmitted when the port is in a locked state.')
mscLpDS1TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TxRaiAlarm.setDescription('This attribute displays whether a RAI signal is being sent on the outgoing line. The RAI signal is transmitted when the port detects a LOF alarm condition (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: RAI is transmitted when the port detects a LOS, LOF, or AIS condition).')
mscLpDS1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17), )
if mibBuilder.loadTexts: mscLpDS1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1StatsTable.setDescription('This group contains the common statistical data for a component in a digital hierarchy interface.')
mscLpDS1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"))
if mibBuilder.loadTexts: mscLpDS1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1StatsEntry.setDescription('An entry in the mscLpDS1StatsTable.')
mscLpDS1RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1RunningTime.setDescription('The number of seconds since the port component was activated.')
mscLpDS1ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ErrorFreeSec.setDescription('The number of seconds that the port has been in an error free state.')
mscLpDS1ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ErroredSec.setDescription('An errored second is declared when a second with one or more Code Violation Error events, or one or more Out Of Frame events occurs. A code violation error may be a CRC error or a BPV error. An Out Of Frame event occurs when 2 out of 5 framing bits are in error.')
mscLpDS1SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1SevErroredSec.setDescription('A severely errored second occurs when a second with 320 or more Code Violation Error events or one or more Out Of Frame events occurs.')
mscLpDS1SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1SevErroredFrmSec.setDescription('A severely errored framing second occurs when a second with one or more Out Of Frame events occurs.')
mscLpDS1UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1UnavailSec.setDescription('The total number of seconds that the interface is in an unavailable signal state. An unavailable signal state occurs at the onset of 10 consecutive Severely Errored Seconds. The state is cleared at the onset of 10 seconds with no Severely Errored Seconds.')
mscLpDS1BpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1BpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1BpvErrors.setDescription('The current count of Bipolar Violations. A bipolar violation is an error in the alternate mark inversion pattern (AMI) on the line.')
mscLpDS1CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1CrcErrors.setDescription('If the interface is a DS1 line, it is the current count of CRC-6 errors. These will only be counted when the lineType is ESF. If the interface is an E1 line, it is the total number of CRC-4 errors. These will only be counted when crc4Mode is on.')
mscLpDS1FrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1FrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1FrmErrors.setDescription('The current count of frame errors. A frame error is an error in the framing bits')
mscLpDS1LosStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1LosStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1LosStateChanges.setDescription('The total number of times that the line lost signal.')
mscLpDS1SlipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1SlipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1SlipErrors.setDescription('The total number of times that the line experienced a controlled frame slip. This attribute is incremented for ports on the voice cards (for example the 1pDS1V and the 1pE1V function processors) only.')
mscLpDS1Chan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2))
mscLpDS1ChanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 1), )
if mibBuilder.loadTexts: mscLpDS1ChanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1Chan components.')
mscLpDS1ChanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1Chan component.')
mscLpDS1ChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1Chan components. These components can be added and deleted.')
mscLpDS1ChanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1ChanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanStorageType.setDescription('This variable represents the storage type value for the mscLpDS1Chan tables.')
mscLpDS1ChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24)))
if mibBuilder.loadTexts: mscLpDS1ChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanIndex.setDescription('This variable represents the index for the mscLpDS1Chan tables.')
mscLpDS1ChanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 10), )
if mibBuilder.loadTexts: mscLpDS1ChanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanProvTable.setDescription('This group contains all of the provisional data for a Channel component.')
mscLpDS1ChanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanProvEntry.setDescription('An entry in the mscLpDS1ChanProvTable.')
mscLpDS1ChanTimeslots = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTimeslots.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTimeslots.setDescription('This attribute contains the list of timeslots that are used by the Channel component. Valid numbers are 1-24 for a Channel used by a DS1 component, and 1-31 for a Channel used by an E1 component. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) n29(29) n30(30) n31(31)')
mscLpDS1ChanTimeslotDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n56k", 0), ("doNotOverride", 1))).clone('doNotOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTimeslotDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTimeslotDataRate.setDescription("This attribute selects the data rate of the timeslots in a channel of a DS1 component. For E1, the data rate of the timeslots will always be 64kbit/s regardless of this attribute. When doNotOverride is selected for a channel on a DS1, the data rate of the channel's timeslots are dependant on the zeroCoding selection of the DS1 component. If the zeroCoding is B8ZS (where supported on the FP) or none, the timeslot's data rate will be 64kbit/ s. If the zeroCoding option is bit7Stuffing, the data rate of a timeslot will be 56kbit/s. When 56k is selected for a channel on a DS1, the least significant bit of each timeslot of this Channel will always be set to 1 and not used for data. The data rate for the timeslots of this channel is therefore restricted to 56kbit/s. One application of this attribute is to allow a DS1 line to support mixing channels that originate from lines that use different zeroCoding schemes.")
mscLpDS1ChanApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of this hardware component.')
mscLpDS1ChanCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 11), )
if mibBuilder.loadTexts: mscLpDS1ChanCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpDS1ChanCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCidDataEntry.setDescription('An entry in the mscLpDS1ChanCidDataTable.')
mscLpDS1ChanCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpDS1ChanIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 12), )
if mibBuilder.loadTexts: mscLpDS1ChanIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpDS1ChanIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanIfEntryEntry.setDescription('An entry in the mscLpDS1ChanIfEntryTable.')
mscLpDS1ChanIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpDS1ChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpDS1ChanOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 13), )
if mibBuilder.loadTexts: mscLpDS1ChanOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpDS1ChanOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanOperStatusEntry.setDescription('An entry in the mscLpDS1ChanOperStatusTable.')
mscLpDS1ChanSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpDS1ChanStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14), )
if mibBuilder.loadTexts: mscLpDS1ChanStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpDS1ChanStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanStateEntry.setDescription('An entry in the mscLpDS1ChanStateTable.')
mscLpDS1ChanAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS1ChanOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS1ChanUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpDS1ChanAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpDS1ChanProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpDS1ChanControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpDS1ChanAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpDS1ChanStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpDS1ChanUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpDS1ChanOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 15), )
if mibBuilder.loadTexts: mscLpDS1ChanOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanOperTable.setDescription('This group contains all of the operational data for a Channel component.')
mscLpDS1ChanOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanOperEntry.setDescription('An entry in the mscLpDS1ChanOperTable.')
mscLpDS1ChanActualChannelSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 15, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanActualChannelSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanActualChannelSpeed.setDescription('This attribute displays the measured link speed of the Channel component.')
mscLpDS1ChanAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 16), )
if mibBuilder.loadTexts: mscLpDS1ChanAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpDS1ChanAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanAdminInfoEntry.setDescription('An entry in the mscLpDS1ChanAdminInfoTable.')
mscLpDS1ChanVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanVendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanVendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpDS1ChanCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 16, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCommentText.setDescription('Any miscellaneous text about the facility.')
mscLpDS1ChanTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2))
mscLpDS1ChanTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 1), )
if mibBuilder.loadTexts: mscLpDS1ChanTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1ChanTest components.')
mscLpDS1ChanTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1ChanTest component.')
mscLpDS1ChanTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1ChanTest components. These components cannot be added nor deleted.')
mscLpDS1ChanTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1ChanTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestStorageType.setDescription('This variable represents the storage type value for the mscLpDS1ChanTest tables.')
mscLpDS1ChanTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS1ChanTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestIndex.setDescription('This variable represents the index for the mscLpDS1ChanTest tables.')
mscLpDS1ChanTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 10), )
if mibBuilder.loadTexts: mscLpDS1ChanTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpDS1ChanTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestStateEntry.setDescription('An entry in the mscLpDS1ChanTestStateTable.')
mscLpDS1ChanTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpDS1ChanTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpDS1ChanTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpDS1ChanTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11), )
if mibBuilder.loadTexts: mscLpDS1ChanTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpDS1ChanTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestSetupEntry.setDescription('An entry in the mscLpDS1ChanTestSetupTable.')
mscLpDS1ChanTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpDS1ChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpDS1ChanTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpDS1ChanTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpDS1ChanTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpDS1ChanTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpDS1ChanTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpDS1ChanTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpDS1ChanTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12), )
if mibBuilder.loadTexts: mscLpDS1ChanTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpDS1ChanTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestResultsEntry.setDescription('An entry in the mscLpDS1ChanTestResultsTable.')
mscLpDS1ChanTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpDS1ChanTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpDS1ChanTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpDS1ChanTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpDS1ChanTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS1ChanTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS1ChanTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpDS1ChanTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS1ChanTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS1ChanTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS1ChanTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpDS1ChanCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3))
mscLpDS1ChanCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 1), )
if mibBuilder.loadTexts: mscLpDS1ChanCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1ChanCell components.')
mscLpDS1ChanCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1ChanCell component.')
mscLpDS1ChanCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1ChanCell components. These components can be added and deleted.')
mscLpDS1ChanCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1ChanCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellStorageType.setDescription('This variable represents the storage type value for the mscLpDS1ChanCell tables.')
mscLpDS1ChanCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS1ChanCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellIndex.setDescription('This variable represents the index for the mscLpDS1ChanCell tables.')
mscLpDS1ChanCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 10), )
if mibBuilder.loadTexts: mscLpDS1ChanCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpDS1ChanCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellProvEntry.setDescription('An entry in the mscLpDS1ChanCellProvTable.')
mscLpDS1ChanCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpDS1ChanCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpDS1ChanCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpDS1ChanCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 11), )
if mibBuilder.loadTexts: mscLpDS1ChanCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpDS1ChanCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellOperEntry.setDescription('An entry in the mscLpDS1ChanCellOperTable.')
mscLpDS1ChanCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS1ChanCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 12), )
if mibBuilder.loadTexts: mscLpDS1ChanCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpDS1ChanCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellStatsEntry.setDescription('An entry in the mscLpDS1ChanCellStatsTable.')
mscLpDS1ChanCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpDS1ChanCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpDS1ChanCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS1ChanCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpDS1ChanCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpDS1ChanTc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4))
mscLpDS1ChanTcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 1), )
if mibBuilder.loadTexts: mscLpDS1ChanTcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1ChanTc components.')
mscLpDS1ChanTcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1ChanTc component.')
mscLpDS1ChanTcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1ChanTc components. These components can be added and deleted.')
mscLpDS1ChanTcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1ChanTcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcStorageType.setDescription('This variable represents the storage type value for the mscLpDS1ChanTc tables.')
mscLpDS1ChanTcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS1ChanTcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcIndex.setDescription('This variable represents the index for the mscLpDS1ChanTc tables.')
mscLpDS1ChanTcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 10), )
if mibBuilder.loadTexts: mscLpDS1ChanTcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcProvTable.setDescription('This group contains all specific provisioning data for a Tc component.')
mscLpDS1ChanTcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcProvEntry.setDescription('An entry in the mscLpDS1ChanTcProvTable.')
mscLpDS1ChanTcReplacementData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 10, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTcReplacementData.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcReplacementData.setDescription('This attribute specifies the trunk conditioning data byte to be substituted into the timeslots defined by the Chan component under fault conditions. replacementData can be set to any two digit hexadecimal number. The following are recommended values: DS1 MUX Out Of Service Code = 0x1A E1 MUX Out Of Service Code = 0xFF')
mscLpDS1ChanTcSignalOneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTcSignalOneDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSignalOneDuration.setDescription('This attribute specifies the time duration in seconds for which signalOne is substituted into the appropriate signaling bits, when a lineType that uses CAS has been defined. When signalOneDuration has expired signalTwo is substituted into the appropriate signaling bits. If signalOneDuration is set to zero then only signalTwo is substituted into the appropriate signaling bits during error conditions. signalOneDuration can be set to any integer value from 0 to 60 seconds.')
mscLpDS1ChanTcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 11), )
if mibBuilder.loadTexts: mscLpDS1ChanTcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcOpTable.setDescription('This group contains all specific operational data for a Tc component.')
mscLpDS1ChanTcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcOpEntry.setDescription('An entry in the mscLpDS1ChanTcOpTable.')
mscLpDS1ChanTcIngressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTcIngressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcIngressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the ATM network. When trunk conditioning is being locally generated towards the ATM network, ingressConditioning is set to on. When trunk conditioning is not being locally generated towards the ATM network, ingressConditioning is set to off. Trunk conditioning is transmitted towards the ATM network under the following conditions: lossOfSignal (LOS) lossOfFrame (LOF) remoteAlarmIndication (RAI) alarmIndicationSignal (AIS) bufferUnderflow (BU) and in addition for E1: lossOfMultiframe (LOMF) receiveMultiframeRemoteAlarmIndication (RMRAI)')
mscLpDS1ChanTcEgressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1ChanTcEgressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcEgressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the PDH line. When trunk conditioning is being locally generated towards the PDH line, egressConditioning is set to on. When trunk conditioning is not being locally generated towards the PDH line, egressConditioning is set to off. Trunk conditioning is transmitted towards the PDH line under the following conditions: bufferUnderflow (BU) AAL1 protocol errors.')
mscLpDS1ChanTcSigOneTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 398), )
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted for the duration provisioned in signalOneDuration when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
mscLpDS1ChanTcSigOneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 398, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTcIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTcSigOneIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneEntry.setDescription('An entry in the mscLpDS1ChanTcSigOneTable.')
mscLpDS1ChanTcSigOneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 398, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneIndex.setDescription('This variable represents the mscLpDS1ChanTcSigOneTable specific index for the mscLpDS1ChanTcSigOneTable.')
mscLpDS1ChanTcSigOneValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 398, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigOneValue.setDescription('This variable represents an individual value for the mscLpDS1ChanTcSigOneTable.')
mscLpDS1ChanTcSigTwoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 399), )
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted after the duration provisioned in signalOneDuration has expired and when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
mscLpDS1ChanTcSigTwoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 399, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTcIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1ChanTcSigTwoIndex"))
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoEntry.setDescription('An entry in the mscLpDS1ChanTcSigTwoTable.')
mscLpDS1ChanTcSigTwoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 399, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoIndex.setDescription('This variable represents the mscLpDS1ChanTcSigTwoTable specific index for the mscLpDS1ChanTcSigTwoTable.')
mscLpDS1ChanTcSigTwoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 2, 4, 399, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1ChanTcSigTwoValue.setDescription('This variable represents an individual value for the mscLpDS1ChanTcSigTwoTable.')
mscLpDS1Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3))
mscLpDS1TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 1), )
if mibBuilder.loadTexts: mscLpDS1TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1Test components.')
mscLpDS1TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS1TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1Test component.')
mscLpDS1TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1Test components. These components cannot be added nor deleted.')
mscLpDS1TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestStorageType.setDescription('This variable represents the storage type value for the mscLpDS1Test tables.')
mscLpDS1TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS1TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestIndex.setDescription('This variable represents the index for the mscLpDS1Test tables.')
mscLpDS1TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 10), )
if mibBuilder.loadTexts: mscLpDS1TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpDS1TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS1TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestStateEntry.setDescription('An entry in the mscLpDS1TestStateTable.')
mscLpDS1TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpDS1TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpDS1TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpDS1TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11), )
if mibBuilder.loadTexts: mscLpDS1TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpDS1TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS1TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestSetupEntry.setDescription('An entry in the mscLpDS1TestSetupTable.')
mscLpDS1TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpDS1TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpDS1TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpDS1TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpDS1TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpDS1TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpDS1TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpDS1TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpDS1TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpDS1TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12), )
if mibBuilder.loadTexts: mscLpDS1TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpDS1TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1TestIndex"))
if mibBuilder.loadTexts: mscLpDS1TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestResultsEntry.setDescription('An entry in the mscLpDS1TestResultsTable.')
mscLpDS1TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpDS1TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpDS1TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpDS1TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpDS1TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS1TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpDS1TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpDS1TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS1TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS1TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpDS1TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpDS1Dsp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 4))
mscLpDS1DspRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 4, 1), )
if mibBuilder.loadTexts: mscLpDS1DspRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1DspRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1Dsp components.')
mscLpDS1DspRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1DspIndex"))
if mibBuilder.loadTexts: mscLpDS1DspRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1DspRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1Dsp component.')
mscLpDS1DspRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1DspRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1DspRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1Dsp components. These components cannot be added nor deleted.')
mscLpDS1DspComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1DspComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1DspComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1DspStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1DspStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1DspStorageType.setDescription('This variable represents the storage type value for the mscLpDS1Dsp tables.')
mscLpDS1DspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS1DspIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1DspIndex.setDescription('This variable represents the index for the mscLpDS1Dsp tables.')
mscLpDS1Audio = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 5))
mscLpDS1AudioRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 5, 1), )
if mibBuilder.loadTexts: mscLpDS1AudioRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AudioRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpDS1Audio components.')
mscLpDS1AudioRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpDS1AudioIndex"))
if mibBuilder.loadTexts: mscLpDS1AudioRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AudioRowStatusEntry.setDescription('A single entry in the table represents a single mscLpDS1Audio component.')
mscLpDS1AudioRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1AudioRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AudioRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpDS1Audio components. These components cannot be added nor deleted.')
mscLpDS1AudioComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1AudioComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AudioComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpDS1AudioStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpDS1AudioStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AudioStorageType.setDescription('This variable represents the storage type value for the mscLpDS1Audio tables.')
mscLpDS1AudioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 7, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpDS1AudioIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpDS1AudioIndex.setDescription('This variable represents the index for the mscLpDS1Audio tables.')
mscLpE1 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8))
mscLpE1RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 1), )
if mibBuilder.loadTexts: mscLpE1RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1 components.')
mscLpE1RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1 component.')
mscLpE1RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1 components. These components can be added and deleted.')
mscLpE1ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1StorageType.setDescription('This variable represents the storage type value for the mscLpE1 tables.')
mscLpE1Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)))
if mibBuilder.loadTexts: mscLpE1Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1Index.setDescription('This variable represents the index for the mscLpE1 tables.')
mscLpE1ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10), )
if mibBuilder.loadTexts: mscLpE1ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ProvTable.setDescription('This group contains all of the provisioning data for an E1 component.')
mscLpE1ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ProvEntry.setDescription('An entry in the mscLpE1ProvTable.')
mscLpE1LineType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 6))).clone(namedValues=NamedValues(("ccs", 2), ("cas", 3), ("unframed", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1LineType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1LineType.setDescription('This attribute specifies the framing of the E1 line. When cas (channel associated signalling) is selected, timeslot 16 is reserved for multiframe signalling and only 30 timeslots are available for data. The signalling bits are not interpreted. When ccs (common channel signalling) is selected, timeslot 16 is not reserved for multiframe signalling and 31 timeslots are available for data. The signalling bits are not interpreted. When unframed is selected, a clear channel is defined whereby data from all timeslots including the framing data (in timeslot 0) and timeslot 16 are passed transparently. This value is valid only for AAL1 cards. For cell-based cards the ATM Forum specifies that timeslot 16 be reserved, leaving 30 timeslots available for data. The default value is cas except for the 8pE1Atm card, for which the default and only valid value is ccs.')
mscLpE1ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 3), ("srtsMode", 4), ("adaptiveMode", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ClockingSource.setDescription("This attribute defines the source of the transmit clock for the E1 line. When local is selected, the crystal on the port generates the clocking for the line. When line is selected, the port synchronizes to the clock from the facility. When module is selected, the ports clock synchronizes to the clock provided by the oscillator on the active CP. When otherPort is selected, the port synchronizes to the port with a clocking source of line. When srtsMode is selected, the port transmit frequency depends on the SRTS (Synchronous Residual Time-Stamp) received over the ATM network. SRTS information is also generated sent over the ATM network. When adaptiveMode is selected, the port transmit frequency continually adapts to match the egress data received from the ATM network. A port with srtsMode or adaptiveMode must have a single Chan which may be linked only to an Aal1Ces.service with serviceType unstructured If the NetworkSynchronization component is present, the default value of this attribute is module, otherwise it defaults to line, except for the 3pE1Atm card, which it defaults to local. On a 3pE1Atm card all ports must have the same value, and be either local or module. otherPort is valid only on AAL1 cards. srtsMode is valid only on AAL1 and Multi-Service Access cards. adaptiveMode is valid only on Multi-Service Access cards. On 4E1Aal1 cards either: all four ports' clockingSource values must be local OR all four ports' clockingSource values must be module OR one port's clockingSource value must be line and the other three must be otherPort. A port can only have srtsMode selected if the other ports are module or srtsMode.")
mscLpE1Crc4Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1Crc4Mode.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1Crc4Mode.setDescription('This attribute defines whether the CRC-4 checking and generation on the E1 line is enabled or disabled. The default CRC-4 mode is off except for the cell-based cards which default to on as per the ATM Forum.')
mscLpE1SendRaiOnAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1SendRaiOnAis.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1SendRaiOnAis.setDescription('This attribute defines whether the Remote Alarm Indicator (RAI) will be sent when receiving an AIS alarm. The value is yes by default; it can be changed to no only for ports on J2MV cards.')
mscLpE1RaiDeclareAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 20000), )).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1RaiDeclareAlarmTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RaiDeclareAlarmTime.setDescription('This attribute specifies the period of time that a Remote Alarm Indicator (RAI) must be present before declaring an RAI alarm. The value of auto sets the RAI declare time to the default value for E1 and E1C card types which do not have hardware support for RAI response. On E1C card types with hardware support, if the value of auto is set, RAI response is done according to the standards. If auto is set, the value of the raiClearAlarmTime attribute is ignored and auto is used. This attribute is for E1 and E1C card types only. For all other card types, the default value must be used. VALUES ( 0 = auto )')
mscLpE1RaiClearAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 20000), )).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1RaiClearAlarmTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RaiClearAlarmTime.setDescription('This attribute specifies the period of time that a Remote Alarm Indicator (RAI) has been absent before clearing an RAI alarm. The value of auto sets the RAI clear time to the default value for E1 and E1C card types which do not have hardware support for RAI response. On E1C card types with hardware support, if the value of auto is set, RAI response is done according to the standards. If auto is set, the value of the raiDeclareAlarmTime attribute is ignored and auto is used. This attribute is for E1 and E1C card types only. For all other card types, the default value must be used. VALUES ( 0 = auto )')
mscLpE1CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 11), )
if mibBuilder.loadTexts: mscLpE1CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpE1CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1CidDataEntry.setDescription('An entry in the mscLpE1CidDataTable.')
mscLpE1CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpE1AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 12), )
if mibBuilder.loadTexts: mscLpE1AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpE1AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AdminInfoEntry.setDescription('An entry in the mscLpE1AdminInfoTable.')
mscLpE1Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpE1CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpE1IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 13), )
if mibBuilder.loadTexts: mscLpE1IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpE1IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1IfEntryEntry.setDescription('An entry in the mscLpE1IfEntryTable.')
mscLpE1IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpE1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpE1OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 14), )
if mibBuilder.loadTexts: mscLpE1OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpE1OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1OperStatusEntry.setDescription('An entry in the mscLpE1OperStatusTable.')
mscLpE1SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpE1StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15), )
if mibBuilder.loadTexts: mscLpE1StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpE1StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1StateEntry.setDescription('An entry in the mscLpE1StateTable.')
mscLpE1AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE1OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE1UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE1AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpE1ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpE1ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpE1AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpE1StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpE1UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpE1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16), )
if mibBuilder.loadTexts: mscLpE1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1OperTable.setDescription('This group contains the common operational data for a component in a digital hierarchy interface.')
mscLpE1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1OperEntry.setDescription('An entry in the mscLpE1OperTable.')
mscLpE1LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1LosAlarm.setDescription('This attribute displays whether a LOS (Loss of Signal) alarm state has been entered. A LOS alarm is declared after LOS defects have been observed and accumulated for a period of 2 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). A LOS defect is detected upon observing all zeros for 150 ms (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: upon observing 175 +/- 75 pulse positions with no pulses of either positive or negative polarity). If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOS alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOS alarm state. The LOS alarm state is cleared when LOS defects are absent for 10 seconds +/- 0.5 seconds.')
mscLpE1RxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1RxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RxAisAlarm.setDescription("This attribute displays whether an AIS (Alarm Indication Signal) alarm state has been entered. The AIS Alarm state is entered when AIS defects have been observed and accumulated for 2.5 seconds +/ - 0.5 seconds. An AIS defect is detected after having received less than 3 zeros in a 2048 bit period (for 8pDS1Atm cards: when both an Out Of Frame condition exists and a 1's density of at least 99.9% is present for a time T, where 3 ms T 75 ms; for 8pE1Atm cards: when both an Out Of Frame condition exists and fewer than three 0's have been received in 512 bit periods). If the AIS defects are intermittently occurring, the AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled for the duration of an AIS alarm state. The AIS alarm state is cleared when AIS defects are absent for 10 seconds +/- 0.5 seconds.")
mscLpE1LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1LofAlarm.setDescription('This attribute displays whether a LOF (Loss of Frame) alarm state has been entered. The LOF alarm state is entered when LOF defects (for DS1: 2 out of 5 framing bits in error; for E1: 3 consecutive frame alignment patterns in error) have been detected for 3 seconds +/- 0.5 seconds (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: 2.5 seconds +/- 0.5 seconds). If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The port goes into an operational state of disabled until the LOF alarm state is cleared. Also, an RAI alarm is transmitted to the far end for the duration of the LOF alarm state The condition is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds.')
mscLpE1RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RxRaiAlarm.setDescription('This attribute displays whether an RAI (Remote Alarm Indication) alarm state has been entered. An RAI alarm state is entered when the RAI defect indicator has been observed and accumulated for 3.5 seconds +/- 0.5 seconds. For 3pDS1Atm, and 8pDS1Atm cards: alarm is declared immediately upon observing the defect is present, with no integration time. For 3pE1Atm, and 8pE1Atm cards: alarm state is entered when the RAI defect indicator has been observed and accumulated for 2.5 seconds +/- 0.5 seconds. If the RAI defects are intermittently occurring, the RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The RAI alarm state is cleared when the RAI defect indicator has been absent for 10 seconds +/- 0.5 seconds (for 3pDS1Atm, and 8pDS1Atm cards: alarm is cleared immediately upon observing the defect is absent, with no integration time). The RAI alarm is usually an indication that the far end facility is unable to gain synchronization.')
mscLpE1TxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TxAisAlarm.setDescription('This attribute displays whether an AIS (Alarm Indication Signal) alarm is being transmitted on the line. An AIS alarm is transmitted when the port is in a locked state.')
mscLpE1TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TxRaiAlarm.setDescription('This attribute displays whether a RAI signal is being sent on the outgoing line. The RAI signal is transmitted when the port detects a LOF alarm condition (for 3pDS1Atm, 3pE1Atm, 8pDS1Atm, and 8pE1Atm cards: RAI is transmitted when the port detects a LOS, LOF, or AIS condition).')
mscLpE1E1OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 17), )
if mibBuilder.loadTexts: mscLpE1E1OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1E1OperTable.setDescription('This group contains all of the operational data for a E1 component that are not defined in the DSCommonOp group.')
mscLpE1E1OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1E1OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1E1OperEntry.setDescription('An entry in the mscLpE1E1OperTable.')
mscLpE1MultifrmLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 17, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1MultifrmLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1MultifrmLofAlarm.setDescription('This attribute indicates whether a multiframe LOF (loss of frame) alarm state is entered. A multiframe LOF alarm state is entered when a multiframe LOF defect (2 consecutive errors in the multiframe alignment signal) has been detected and accumulated for 2.5 seconds +/- 0.5 seconds. If the multiframe LOF defects are intermittently occurring, the multiframe LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The alarm is cleared when the defect is not detected for 10 seconds +/- 0.5 seconds. When the multiframe LOF alarm is on, a multiframe RAI alarm indicator is transmitted on the line. The 8pE1Atm card does not support the multiframe LOF alarm.')
mscLpE1RxMultifrmRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 17, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1RxMultifrmRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RxMultifrmRaiAlarm.setDescription('This attribute displays whether a multiframe RAI (remote alarm indicator) alarm state has been entered. A multiframe RAI alarm state is entered when a multiframe RAI alarm indicator (bit 6 of timeslot 16 in frame 0 is set to a one) is observed and accumulated for 2.5 seconds +/- 0.5 seconds. If the multiframe RAI indicator is intermittently received, the multiframe RAI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The multiframe RAI alarm condition is cleared when the multiframe RAI alarm indication is not received for 10 seconds +/- 0.5 seconds. The multiframe RAI alarm is usually an indication that the far end facility is unable to gain multiframe synchronization. The 8pE1Atm card does not support the multiframe RAI alarm.')
mscLpE1TxMultifrmRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 17, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TxMultifrmRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TxMultifrmRaiAlarm.setDescription('This attribute displays whether a multiframe RAI (remote alarm indicator) alarm is being sent on the E1 line. This is transmitted when the E1 port detects a multiframe LOF condition. The 8pE1Atm card does not generate the multiframe RAI alarm.')
mscLpE1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18), )
if mibBuilder.loadTexts: mscLpE1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1StatsTable.setDescription('This group contains the common statistical data for a component in a digital hierarchy interface.')
mscLpE1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"))
if mibBuilder.loadTexts: mscLpE1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1StatsEntry.setDescription('An entry in the mscLpE1StatsTable.')
mscLpE1RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1RunningTime.setDescription('The number of seconds since the port component was activated.')
mscLpE1ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ErrorFreeSec.setDescription('The number of seconds that the port has been in an error free state.')
mscLpE1ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ErroredSec.setDescription('An errored second is declared when a second with one or more Code Violation Error events, or one or more Out Of Frame events occurs. A code violation error may be a CRC error or a BPV error. An Out Of Frame event occurs when 2 out of 5 framing bits are in error.')
mscLpE1SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1SevErroredSec.setDescription('A severely errored second occurs when a second with 320 or more Code Violation Error events or one or more Out Of Frame events occurs.')
mscLpE1SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1SevErroredFrmSec.setDescription('A severely errored framing second occurs when a second with one or more Out Of Frame events occurs.')
mscLpE1UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1UnavailSec.setDescription('The total number of seconds that the interface is in an unavailable signal state. An unavailable signal state occurs at the onset of 10 consecutive Severely Errored Seconds. The state is cleared at the onset of 10 seconds with no Severely Errored Seconds.')
mscLpE1BpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1BpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1BpvErrors.setDescription('The current count of Bipolar Violations. A bipolar violation is an error in the alternate mark inversion pattern (AMI) on the line.')
mscLpE1CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1CrcErrors.setDescription('If the interface is a DS1 line, it is the current count of CRC-6 errors. These will only be counted when the lineType is ESF. If the interface is an E1 line, it is the total number of CRC-4 errors. These will only be counted when crc4Mode is on.')
mscLpE1FrmErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1FrmErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1FrmErrors.setDescription('The current count of frame errors. A frame error is an error in the framing bits')
mscLpE1LosStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1LosStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1LosStateChanges.setDescription('The total number of times that the line lost signal.')
mscLpE1SlipErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 18, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1SlipErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1SlipErrors.setDescription('The total number of times that the line experienced a controlled frame slip. This attribute is incremented for ports on the voice cards (for example the 1pDS1V and the 1pE1V function processors) only.')
mscLpE1Chan = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2))
mscLpE1ChanRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 1), )
if mibBuilder.loadTexts: mscLpE1ChanRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1Chan components.')
mscLpE1ChanRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1Chan component.')
mscLpE1ChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1Chan components. These components can be added and deleted.')
mscLpE1ChanComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1ChanStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanStorageType.setDescription('This variable represents the storage type value for the mscLpE1Chan tables.')
mscLpE1ChanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)))
if mibBuilder.loadTexts: mscLpE1ChanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanIndex.setDescription('This variable represents the index for the mscLpE1Chan tables.')
mscLpE1ChanProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 10), )
if mibBuilder.loadTexts: mscLpE1ChanProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanProvTable.setDescription('This group contains all of the provisional data for a Channel component.')
mscLpE1ChanProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanProvEntry.setDescription('An entry in the mscLpE1ChanProvTable.')
mscLpE1ChanTimeslots = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTimeslots.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTimeslots.setDescription('This attribute contains the list of timeslots that are used by the Channel component. Valid numbers are 1-24 for a Channel used by a DS1 component, and 1-31 for a Channel used by an E1 component. Description of bits: notused0(0) n1(1) n2(2) n3(3) n4(4) n5(5) n6(6) n7(7) n8(8) n9(9) n10(10) n11(11) n12(12) n13(13) n14(14) n15(15) n16(16) n17(17) n18(18) n19(19) n20(20) n21(21) n22(22) n23(23) n24(24) n25(25) n26(26) n27(27) n28(28) n29(29) n30(30) n31(31)')
mscLpE1ChanTimeslotDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("n56k", 0), ("doNotOverride", 1))).clone('doNotOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTimeslotDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTimeslotDataRate.setDescription("This attribute selects the data rate of the timeslots in a channel of a DS1 component. For E1, the data rate of the timeslots will always be 64kbit/s regardless of this attribute. When doNotOverride is selected for a channel on a DS1, the data rate of the channel's timeslots are dependant on the zeroCoding selection of the DS1 component. If the zeroCoding is B8ZS (where supported on the FP) or none, the timeslot's data rate will be 64kbit/ s. If the zeroCoding option is bit7Stuffing, the data rate of a timeslot will be 56kbit/s. When 56k is selected for a channel on a DS1, the least significant bit of each timeslot of this Channel will always be set to 1 and not used for data. The data rate for the timeslots of this channel is therefore restricted to 56kbit/s. One application of this attribute is to allow a DS1 line to support mixing channels that originate from lines that use different zeroCoding schemes.")
mscLpE1ChanApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 10, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of this hardware component.')
mscLpE1ChanCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 11), )
if mibBuilder.loadTexts: mscLpE1ChanCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpE1ChanCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCidDataEntry.setDescription('An entry in the mscLpE1ChanCidDataTable.')
mscLpE1ChanCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpE1ChanIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 12), )
if mibBuilder.loadTexts: mscLpE1ChanIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpE1ChanIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanIfEntryEntry.setDescription('An entry in the mscLpE1ChanIfEntryTable.')
mscLpE1ChanIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpE1ChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpE1ChanOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 13), )
if mibBuilder.loadTexts: mscLpE1ChanOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpE1ChanOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanOperStatusEntry.setDescription('An entry in the mscLpE1ChanOperStatusTable.')
mscLpE1ChanSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpE1ChanStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14), )
if mibBuilder.loadTexts: mscLpE1ChanStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpE1ChanStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanStateEntry.setDescription('An entry in the mscLpE1ChanStateTable.')
mscLpE1ChanAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE1ChanOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE1ChanUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpE1ChanAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpE1ChanProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpE1ChanControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpE1ChanAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpE1ChanStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpE1ChanUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpE1ChanOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 15), )
if mibBuilder.loadTexts: mscLpE1ChanOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanOperTable.setDescription('This group contains all of the operational data for a Channel component.')
mscLpE1ChanOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanOperEntry.setDescription('An entry in the mscLpE1ChanOperTable.')
mscLpE1ChanActualChannelSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 15, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanActualChannelSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanActualChannelSpeed.setDescription('This attribute displays the measured link speed of the Channel component.')
mscLpE1ChanAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 16), )
if mibBuilder.loadTexts: mscLpE1ChanAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpE1ChanAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"))
if mibBuilder.loadTexts: mscLpE1ChanAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanAdminInfoEntry.setDescription('An entry in the mscLpE1ChanAdminInfoTable.')
mscLpE1ChanVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanVendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanVendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpE1ChanCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 16, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCommentText.setDescription('Any miscellaneous text about the facility.')
mscLpE1ChanTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2))
mscLpE1ChanTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 1), )
if mibBuilder.loadTexts: mscLpE1ChanTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1ChanTest components.')
mscLpE1ChanTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1ChanTest component.')
mscLpE1ChanTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1ChanTest components. These components cannot be added nor deleted.')
mscLpE1ChanTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1ChanTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestStorageType.setDescription('This variable represents the storage type value for the mscLpE1ChanTest tables.')
mscLpE1ChanTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE1ChanTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestIndex.setDescription('This variable represents the index for the mscLpE1ChanTest tables.')
mscLpE1ChanTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 10), )
if mibBuilder.loadTexts: mscLpE1ChanTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpE1ChanTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestStateEntry.setDescription('An entry in the mscLpE1ChanTestStateTable.')
mscLpE1ChanTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpE1ChanTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpE1ChanTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpE1ChanTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11), )
if mibBuilder.loadTexts: mscLpE1ChanTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpE1ChanTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestSetupEntry.setDescription('An entry in the mscLpE1ChanTestSetupTable.')
mscLpE1ChanTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpE1ChanTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpE1ChanTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpE1ChanTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpE1ChanTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpE1ChanTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpE1ChanTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpE1ChanTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpE1ChanTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12), )
if mibBuilder.loadTexts: mscLpE1ChanTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpE1ChanTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTestIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestResultsEntry.setDescription('An entry in the mscLpE1ChanTestResultsTable.')
mscLpE1ChanTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpE1ChanTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpE1ChanTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpE1ChanTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpE1ChanTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpE1ChanTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpE1ChanTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpE1ChanTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE1ChanTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE1ChanTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE1ChanTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpE1ChanCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3))
mscLpE1ChanCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 1), )
if mibBuilder.loadTexts: mscLpE1ChanCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1ChanCell components.')
mscLpE1ChanCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpE1ChanCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1ChanCell component.')
mscLpE1ChanCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1ChanCell components. These components can be added and deleted.')
mscLpE1ChanCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1ChanCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellStorageType.setDescription('This variable represents the storage type value for the mscLpE1ChanCell tables.')
mscLpE1ChanCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE1ChanCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellIndex.setDescription('This variable represents the index for the mscLpE1ChanCell tables.')
mscLpE1ChanCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 10), )
if mibBuilder.loadTexts: mscLpE1ChanCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpE1ChanCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpE1ChanCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellProvEntry.setDescription('An entry in the mscLpE1ChanCellProvTable.')
mscLpE1ChanCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpE1ChanCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpE1ChanCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpE1ChanCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 11), )
if mibBuilder.loadTexts: mscLpE1ChanCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpE1ChanCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpE1ChanCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellOperEntry.setDescription('An entry in the mscLpE1ChanCellOperTable.')
mscLpE1ChanCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpE1ChanCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 12), )
if mibBuilder.loadTexts: mscLpE1ChanCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpE1ChanCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanCellIndex"))
if mibBuilder.loadTexts: mscLpE1ChanCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellStatsEntry.setDescription('An entry in the mscLpE1ChanCellStatsTable.')
mscLpE1ChanCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpE1ChanCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpE1ChanCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpE1ChanCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpE1ChanCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpE1ChanTc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4))
mscLpE1ChanTcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 1), )
if mibBuilder.loadTexts: mscLpE1ChanTcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1ChanTc components.')
mscLpE1ChanTcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1ChanTc component.')
mscLpE1ChanTcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1ChanTc components. These components can be added and deleted.')
mscLpE1ChanTcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1ChanTcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcStorageType.setDescription('This variable represents the storage type value for the mscLpE1ChanTc tables.')
mscLpE1ChanTcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE1ChanTcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcIndex.setDescription('This variable represents the index for the mscLpE1ChanTc tables.')
mscLpE1ChanTcProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 10), )
if mibBuilder.loadTexts: mscLpE1ChanTcProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcProvTable.setDescription('This group contains all specific provisioning data for a Tc component.')
mscLpE1ChanTcProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTcProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcProvEntry.setDescription('An entry in the mscLpE1ChanTcProvTable.')
mscLpE1ChanTcReplacementData = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 10, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTcReplacementData.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcReplacementData.setDescription('This attribute specifies the trunk conditioning data byte to be substituted into the timeslots defined by the Chan component under fault conditions. replacementData can be set to any two digit hexadecimal number. The following are recommended values: DS1 MUX Out Of Service Code = 0x1A E1 MUX Out Of Service Code = 0xFF')
mscLpE1ChanTcSignalOneDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTcSignalOneDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSignalOneDuration.setDescription('This attribute specifies the time duration in seconds for which signalOne is substituted into the appropriate signaling bits, when a lineType that uses CAS has been defined. When signalOneDuration has expired signalTwo is substituted into the appropriate signaling bits. If signalOneDuration is set to zero then only signalTwo is substituted into the appropriate signaling bits during error conditions. signalOneDuration can be set to any integer value from 0 to 60 seconds.')
mscLpE1ChanTcOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 11), )
if mibBuilder.loadTexts: mscLpE1ChanTcOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcOpTable.setDescription('This group contains all specific operational data for a Tc component.')
mscLpE1ChanTcOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTcIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTcOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcOpEntry.setDescription('An entry in the mscLpE1ChanTcOpTable.')
mscLpE1ChanTcIngressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTcIngressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcIngressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the ATM network. When trunk conditioning is being locally generated towards the ATM network, ingressConditioning is set to on. When trunk conditioning is not being locally generated towards the ATM network, ingressConditioning is set to off. Trunk conditioning is transmitted towards the ATM network under the following conditions: lossOfSignal (LOS) lossOfFrame (LOF) remoteAlarmIndication (RAI) alarmIndicationSignal (AIS) bufferUnderflow (BU) and in addition for E1: lossOfMultiframe (LOMF) receiveMultiframeRemoteAlarmIndication (RMRAI)')
mscLpE1ChanTcEgressConditioning = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanTcEgressConditioning.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcEgressConditioning.setDescription('This attribute indicates the status of locally generated trunk conditioning towards the PDH line. When trunk conditioning is being locally generated towards the PDH line, egressConditioning is set to on. When trunk conditioning is not being locally generated towards the PDH line, egressConditioning is set to off. Trunk conditioning is transmitted towards the PDH line under the following conditions: bufferUnderflow (BU) AAL1 protocol errors.')
mscLpE1ChanTcSigOneTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 398), )
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted for the duration provisioned in signalOneDuration when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
mscLpE1ChanTcSigOneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 398, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTcIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTcSigOneIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneEntry.setDescription('An entry in the mscLpE1ChanTcSigOneTable.')
mscLpE1ChanTcSigOneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 398, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneIndex.setDescription('This variable represents the mscLpE1ChanTcSigOneTable specific index for the mscLpE1ChanTcSigOneTable.')
mscLpE1ChanTcSigOneValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 398, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigOneValue.setDescription('This variable represents an individual value for the mscLpE1ChanTcSigOneTable.')
mscLpE1ChanTcSigTwoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 399), )
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoTable.setDescription('This attribute specifies the value to be substituted into the ABCD signaling bits for the timeslots defined by the Chan component under fault conditions. The value will be substituted after the duration provisioned in signalOneDuration has expired and when a lineType that uses CAS has been defined. For a lineType of d4Cas (Super Frame), signaling bits C and D are required to equal bits A and B respectively.')
mscLpE1ChanTcSigTwoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 399, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTcIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanTcSigTwoIndex"))
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoEntry.setDescription('An entry in the mscLpE1ChanTcSigTwoTable.')
mscLpE1ChanTcSigTwoIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 399, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("d", 0), ("c", 1), ("b", 2), ("a", 3))))
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoIndex.setDescription('This variable represents the mscLpE1ChanTcSigTwoTable specific index for the mscLpE1ChanTcSigTwoTable.')
mscLpE1ChanTcSigTwoValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 4, 399, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanTcSigTwoValue.setDescription('This variable represents an individual value for the mscLpE1ChanTcSigTwoTable.')
mscLpE1ChanFlm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5))
mscLpE1ChanFlmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 1), )
if mibBuilder.loadTexts: mscLpE1ChanFlmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1ChanFlm components.')
mscLpE1ChanFlmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanFlmIndex"))
if mibBuilder.loadTexts: mscLpE1ChanFlmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1ChanFlm component.')
mscLpE1ChanFlmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanFlmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1ChanFlm components. These components can be added and deleted.')
mscLpE1ChanFlmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanFlmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1ChanFlmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanFlmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmStorageType.setDescription('This variable represents the storage type value for the mscLpE1ChanFlm tables.')
mscLpE1ChanFlmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE1ChanFlmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmIndex.setDescription('This variable represents the index for the mscLpE1ChanFlm tables.')
mscLpE1ChanFlmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 10), )
if mibBuilder.loadTexts: mscLpE1ChanFlmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmProvTable.setDescription('This group contains all specific provisioning data for an Flm component.')
mscLpE1ChanFlmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanFlmIndex"))
if mibBuilder.loadTexts: mscLpE1ChanFlmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmProvEntry.setDescription('An entry in the mscLpE1ChanFlmProvTable.')
mscLpE1ChanFlmABitMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanFlmABitMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmABitMonitoring.setDescription('This attribute controls the monitoring of A-bit defects.')
mscLpE1ChanFlmHdlcMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1ChanFlmHdlcMonitoring.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmHdlcMonitoring.setDescription('This attribute controls the monitoring of HDLC defect.')
mscLpE1ChanFlmOpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 11), )
if mibBuilder.loadTexts: mscLpE1ChanFlmOpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmOpTable.setDescription('This group contains all specific operational data for an Flm component.')
mscLpE1ChanFlmOpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1ChanFlmIndex"))
if mibBuilder.loadTexts: mscLpE1ChanFlmOpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmOpEntry.setDescription('An entry in the mscLpE1ChanFlmOpTable.')
mscLpE1ChanFlmFlmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 2, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notMonitoring", 0), ("frameLinkUp", 1), ("frameLinkDown", 2), ("lossOfHdlc", 3), ("lossOfAbit", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1ChanFlmFlmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1ChanFlmFlmStatus.setDescription("This attribute indicates the status of a Frame Relay channel on an E1 line. By combining the E1 channel-associated-signalling (CAS) A-bits status, and HDLC defect, a single value indicates the likely cause of the failure. This mechanism assumes that the far end equipment loops back signaling A-bits for some or all of the timeslots in a channel. The A-bits in channel are transmitted as '0'. If they are all received as '0', it is assumed that the E1 link is up in both directions. The presence of HDLC frames indicates that the service is connected. When A-bits and HDLC frames are correctly received, frameLinkUp is indicated. When neither are received, frameLinkDown is indicated. When HDLC frames are not receive but A-bits are not at fault, lossOfHdlc is indicated. When HDLC frames are received, but there is a fault in the any of timeslot's A-bits on a channel lossOfAbit is indicated.")
mscLpE1Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3))
mscLpE1TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 1), )
if mibBuilder.loadTexts: mscLpE1TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1Test components.')
mscLpE1TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1TestIndex"))
if mibBuilder.loadTexts: mscLpE1TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1Test component.')
mscLpE1TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1Test components. These components cannot be added nor deleted.')
mscLpE1TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestStorageType.setDescription('This variable represents the storage type value for the mscLpE1Test tables.')
mscLpE1TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE1TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestIndex.setDescription('This variable represents the index for the mscLpE1Test tables.')
mscLpE1TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 10), )
if mibBuilder.loadTexts: mscLpE1TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpE1TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1TestIndex"))
if mibBuilder.loadTexts: mscLpE1TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestStateEntry.setDescription('An entry in the mscLpE1TestStateTable.')
mscLpE1TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpE1TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpE1TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpE1TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11), )
if mibBuilder.loadTexts: mscLpE1TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpE1TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1TestIndex"))
if mibBuilder.loadTexts: mscLpE1TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestSetupEntry.setDescription('An entry in the mscLpE1TestSetupTable.')
mscLpE1TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpE1TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpE1TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpE1TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpE1TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpE1TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpE1TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpE1TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpE1TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpE1TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12), )
if mibBuilder.loadTexts: mscLpE1TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpE1TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1TestIndex"))
if mibBuilder.loadTexts: mscLpE1TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestResultsEntry.setDescription('An entry in the mscLpE1TestResultsTable.')
mscLpE1TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpE1TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpE1TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpE1TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpE1TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpE1TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpE1TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpE1TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE1TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE1TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpE1TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpE1Dsp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 4))
mscLpE1DspRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 4, 1), )
if mibBuilder.loadTexts: mscLpE1DspRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1DspRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1Dsp components.')
mscLpE1DspRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1DspIndex"))
if mibBuilder.loadTexts: mscLpE1DspRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1DspRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1Dsp component.')
mscLpE1DspRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1DspRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1DspRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1Dsp components. These components cannot be added nor deleted.')
mscLpE1DspComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1DspComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1DspComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1DspStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1DspStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1DspStorageType.setDescription('This variable represents the storage type value for the mscLpE1Dsp tables.')
mscLpE1DspIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE1DspIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1DspIndex.setDescription('This variable represents the index for the mscLpE1Dsp tables.')
mscLpE1Audio = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 5))
mscLpE1AudioRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 5, 1), )
if mibBuilder.loadTexts: mscLpE1AudioRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AudioRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpE1Audio components.')
mscLpE1AudioRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpE1AudioIndex"))
if mibBuilder.loadTexts: mscLpE1AudioRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AudioRowStatusEntry.setDescription('A single entry in the table represents a single mscLpE1Audio component.')
mscLpE1AudioRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1AudioRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AudioRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpE1Audio components. These components cannot be added nor deleted.')
mscLpE1AudioComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1AudioComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AudioComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpE1AudioStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpE1AudioStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AudioStorageType.setDescription('This variable represents the storage type value for the mscLpE1Audio tables.')
mscLpE1AudioIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 8, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpE1AudioIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpE1AudioIndex.setDescription('This variable represents the index for the mscLpE1Audio tables.')
mscLpV35 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9))
mscLpV35RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 1), )
if mibBuilder.loadTexts: mscLpV35RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpV35 components.')
mscLpV35RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35RowStatusEntry.setDescription('A single entry in the table represents a single mscLpV35 component.')
mscLpV35RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpV35 components. These components can be added and deleted.')
mscLpV35ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpV35StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35StorageType.setDescription('This variable represents the storage type value for the mscLpV35 tables.')
mscLpV35Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: mscLpV35Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35Index.setDescription('This variable represents the index for the mscLpV35 tables.')
mscLpV35ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10), )
if mibBuilder.loadTexts: mscLpV35ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ProvTable.setDescription('This group contains all specific provisioning data for a V35 component.')
mscLpV35ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ProvEntry.setDescription('An entry in the mscLpV35ProvTable.')
mscLpV35LinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128))).clone('dte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35LinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35LinkMode.setDescription('This attribute defines the intended gender of the V.35 interface. The actual gender of the interface is determined by the physical connection to the patch panel. If the hardware setup does not match this attribute, an alarm will be generated. In dte mode, the RTS line signal is driven as specified by the attribute readyLineState when the interface passes its initial diagnostics. Then, the RTS line signal will be driven as specified in the attribute dataTransferLineState when the application is ready to transfer data. On the other hand, the input line signals (RFS, DSR, and DCD) are compared against those specified in the attributes readyLineState and dataTransferLineState. The application will be notified when the specified input line states are observed. In dce mode, the V35 component behaves similarly as when it is in dte mode. However, it will be driving the DCE line signals (RFS, DSR, and DCD) and monitoring the DTE line signal (RTS) as specified by the attributes readyLineState and dataTransferLineState.')
mscLpV35ReadyLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35ReadyLineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ReadyLineState.setDescription('This attribute specifies the line signals originating from the V.35 interface that will always be turned on, provided the interface passes its diagnostics. This set of signals is generally required for maintaining the connection. Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. See also linkMode. Description of bits: rfs(0) dsr(1) dcd(2) rts(3)')
mscLpV35DataTransferLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35DataTransferLineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35DataTransferLineState.setDescription('This attribute specifies the line signals required to indicate that the external equipment is in a good state (that is, data transfer can proceed). Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. The value of this attribute must be a superset of that of the readyLineState attribute. See also linkMode. Description of bits: rfs(0) dsr(1) dcd(2) rts(3)')
mscLpV35LineStatusTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 20000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35LineStatusTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35LineStatusTimeOut.setDescription('This attribute defines the time that the line state must be stable (good or bad) before a line state change is declared.')
mscLpV35LineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(9600, 3840000)).clone(192000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35LineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35LineSpeed.setDescription('This attribute defines the speed of the line for source clocking. This attribute is ignored if the interface is not providing a clock. The clock rate is rounded up to the nearest available value. Note that the actual clock rates are available in the operational attributes actualTxLineSpeed and actualRxLineSpeed. The actual lineSpeeds configurable on a V.35 DCE interface are: 3840000, 2560000, 2048000, 1920000, 1536000, 1344000, 1280000, 1024000, 960000, 768000, 672000, 640000, 512000, 448000, 384000, 336000, 320000, 256000, 224000, 192000, 168000, 128000, 112000, 64000, 56000, 48000, 32000, 19200, 9600. Note that linspeeds of 1024000 and 2048000 cannot be provisioned on cards that have ports provisioned at 3840000, 2560000, 1920000, 1280000, 960000, 640000 or 320000.')
mscLpV35ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("local", 0), ("module", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ClockingSource.setDescription('This attribute defines the source of synchronization of the outgoing clocks. This attribute is only used when the actualLinkMode is dce. If the value of the attribute is local, the outgoing clocks are synchronized to a local oscillator on the FP. If the value of the attribute is module, the outgoing clocks are synchronized to the oscillator on the active CP.')
mscLpV35DteDataClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("fromDce", 0), ("fromDte", 2))).clone('fromDce')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35DteDataClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35DteDataClockSource.setDescription('This attribute is only used when the actualLinkMode is dce. It is used to determine the clock to be used to recover the receive data. A DTE interface uses TSET(DCE) and RSET(DCE) for timing. If the value of the attribute is fromDce, the DCE uses the internally generated transmit clock to supply both TSET(DCE) and RSET(DCE). If the value of the attribute is fromDte, the DCE still uses the internally generated transmit clock to supply TSET(DCE), but the receive timing is derived from TSET(DTE) on the link. The fromDte mode is recommended when the DTE is far away from the DCE interface. Note that TSET(DTE) is CCITT V.24 circuit 113; TSET(DCE) is CCITT V.24 circuit 114; and RSET(DCE) is CCITT V.24 circuit 115.')
mscLpV35ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 8), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ApplicationFramerName.setDescription('This attribute contains the component name of a Framer which is associated with the V35 component.')
mscLpV35EnableDynamicSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35EnableDynamicSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35EnableDynamicSpeed.setDescription('When set to yes, this attribute specifies that the transmit link speed should be set to the calculated receiver link speed. This attribute can be set to yes only if the linkMode is dce and the dteDataClockSource is fromDte.')
mscLpV35CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 11), )
if mibBuilder.loadTexts: mscLpV35CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpV35CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35CidDataEntry.setDescription('An entry in the mscLpV35CidDataTable.')
mscLpV35CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpV35AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 12), )
if mibBuilder.loadTexts: mscLpV35AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpV35AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35AdminInfoEntry.setDescription('An entry in the mscLpV35AdminInfoTable.')
mscLpV35Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpV35CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpV35IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 13), )
if mibBuilder.loadTexts: mscLpV35IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpV35IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35IfEntryEntry.setDescription('An entry in the mscLpV35IfEntryTable.')
mscLpV35IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpV35IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpV35OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 14), )
if mibBuilder.loadTexts: mscLpV35OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpV35OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35OperStatusEntry.setDescription('An entry in the mscLpV35OperStatusTable.')
mscLpV35SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpV35StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15), )
if mibBuilder.loadTexts: mscLpV35StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpV35StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35StateEntry.setDescription('An entry in the mscLpV35StateTable.')
mscLpV35AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpV35OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpV35UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpV35AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpV35ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpV35ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpV35AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpV35StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpV35UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpV35OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 16), )
if mibBuilder.loadTexts: mscLpV35OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35OperTable.setDescription('This group contains all specific operational data for a V35 component.')
mscLpV35OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"))
if mibBuilder.loadTexts: mscLpV35OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35OperEntry.setDescription('An entry in the mscLpV35OperTable.')
mscLpV35ActualLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35ActualLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ActualLinkMode.setDescription('This attribute contains the actual link mode defined by the hardware. Note that the hardware overrides the provisionable data. The interface behaves as a DCE or DTE according to the actualLinkMode.')
mscLpV35LineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 16, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35LineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35LineState.setDescription('This attribute contains the current state of the interface signals. Description of bits: rfs(0) dsr(1) dcd(2) rts(3)')
mscLpV35ActualTxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 16, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35ActualTxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ActualTxLineSpeed.setDescription('This attribute is the measured speed of the transmit clock.')
mscLpV35ActualRxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 16, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35ActualRxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35ActualRxLineSpeed.setDescription('This attribute is the measured speed of the receive clock.')
mscLpV35DataXferStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35DataXferStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35DataXferStateChanges.setDescription('This attribute contains the number of times that the line has entered or exited the data transfer state.')
mscLpV35Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2))
mscLpV35TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 1), )
if mibBuilder.loadTexts: mscLpV35TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpV35Test components.')
mscLpV35TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35TestIndex"))
if mibBuilder.loadTexts: mscLpV35TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpV35Test component.')
mscLpV35TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpV35Test components. These components cannot be added nor deleted.')
mscLpV35TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpV35TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestStorageType.setDescription('This variable represents the storage type value for the mscLpV35Test tables.')
mscLpV35TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpV35TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestIndex.setDescription('This variable represents the index for the mscLpV35Test tables.')
mscLpV35TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 10), )
if mibBuilder.loadTexts: mscLpV35TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpV35TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35TestIndex"))
if mibBuilder.loadTexts: mscLpV35TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestStateEntry.setDescription('An entry in the mscLpV35TestStateTable.')
mscLpV35TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpV35TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpV35TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpV35TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11), )
if mibBuilder.loadTexts: mscLpV35TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpV35TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35TestIndex"))
if mibBuilder.loadTexts: mscLpV35TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestSetupEntry.setDescription('An entry in the mscLpV35TestSetupTable.')
mscLpV35TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpV35TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpV35TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpV35TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpV35TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpV35TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpV35TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpV35TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpV35TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpV35TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12), )
if mibBuilder.loadTexts: mscLpV35TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpV35TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpV35TestIndex"))
if mibBuilder.loadTexts: mscLpV35TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestResultsEntry.setDescription('An entry in the mscLpV35TestResultsTable.')
mscLpV35TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpV35TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpV35TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpV35TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpV35TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpV35TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpV35TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpV35TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpV35TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpV35TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpV35TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 9, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpV35TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpV35TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpX21 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10))
mscLpX21RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 1), )
if mibBuilder.loadTexts: mscLpX21RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpX21 components.')
mscLpX21RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21RowStatusEntry.setDescription('A single entry in the table represents a single mscLpX21 component.')
mscLpX21RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpX21 components. These components can be added and deleted.')
mscLpX21ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpX21StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21StorageType.setDescription('This variable represents the storage type value for the mscLpX21 tables.')
mscLpX21Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)))
if mibBuilder.loadTexts: mscLpX21Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21Index.setDescription('This variable represents the index for the mscLpX21 tables.')
mscLpX21ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10), )
if mibBuilder.loadTexts: mscLpX21ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ProvTable.setDescription('This group contains all specific provisioning data for an X21 component.')
mscLpX21ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ProvEntry.setDescription('An entry in the mscLpX21ProvTable.')
mscLpX21LinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128))).clone('dte')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21LinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21LinkMode.setDescription('This attribute defines the intended gender of the X21 component (V.11 interface). The actual gender of the interface is determined by the physical connection to the patch panel. If the hardware setup does not match this attribute, an alarm will be generated. In dte mode, the control line signal is driven as specified by the attribute readyLineState when the interface passes its initial diagnostics. Then, the control line signal will be driven as specified in the attribute dataTransferLineState when the application is ready to transfer data. On the other hand, the input line signal (indication) is compared against those specified in the attributes readyLineState and dataTransferLineState. The application will be notified when the specified line states are observed. In dce mode, the X21 component behaves similarly as when it is in dte mode. However, it will be driving the DCE line signal (control) and monitoring the DTE line signal (indication) as specified by the attributes readyLineState and dataTransferLineState.')
mscLpX21ReadyLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21ReadyLineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ReadyLineState.setDescription('This attribute specifies the line signals originating from the V.11 interface that will always be turned on, provided the interface passes its diagnostics. This set of signals is generally required to maintain the connection. Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. See also linkMode. Description of bits: indication(0) control(1)')
mscLpX21DataTransferLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21DataTransferLineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21DataTransferLineState.setDescription('The state of the line signals required to indicate that the external equipment is in a good state (that is, data transfer can proceed). Note that both DTE and DCE signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the actualLinkMode. The value of this attribute must be a superset of that of the readyLineState attribute. See also linkMode. Description of bits: indication(0) control(1)')
mscLpX21LineStatusTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 20000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21LineStatusTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21LineStatusTimeOut.setDescription('This attribute defines the time the line state must be stable (good or bad) before a state change is declared.')
mscLpX21LineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(9600, 7680000)).clone(192000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21LineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21LineSpeed.setDescription('This attribute defines the speed of the line for source clocking. This attribute is ignored if the interface is not providing a clock. The clock rate is rounded up to the nearest available value. Note that the actual clock rates are available in the operational attributes actualTxLineSpeed and actualRxLineSpeed. The actual lineSpeeds configurable on a V.11 DCE interface are: 7680000, 3840000, 2560000, 2048000, 1920000, 1536000, 1344000, 1280000, 1024000, 960000, 768000, 672000, 640000, 512000, 448000, 384000, 336000, 320000, 256000, 224000, 192000, 168000, 128000, 112000, 64000, 56000, 48000, 32000, 19200, 9600. Note that linspeeds of 1024000 and 2048000 cannot be provisioned on cards that have ports provisioned at 3840000, 2560000, 1920000, 1280000, 960000, 640000 or 320000.')
mscLpX21ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("local", 0), ("module", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ClockingSource.setDescription('This attribute defines the source of synchronization of the outgoing clocks. This attribute is only used when the actualLinkMode is dce. If the value of the attribute is local, the outgoing clocks are synchronized to a local oscillator on the FP. If the value of the attribute is module, the outgoing clocks are synchronized to the oscillator on the active CP.')
mscLpX21DteDataClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("fromDce", 0), ("fromDte", 2))).clone('fromDce')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21DteDataClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21DteDataClockSource.setDescription('This attribute is only used when the actualLinkMode is dce. It is used to determine the clock to be used to recover the receive data. Note that a V.11 DTE interface uses the S clock (see X.21 standard) for both receive data and transmit data timing. The DTE interface always loops the received S clock back to the DCE as the X clock (see X.21 standard). If the value of the attribute is fromDce, the DCE V.11 interface uses the internally generated transmit clock as the S clock and for both receive and transmit data timing. The X clock is ignored. If the value of the attribute is fromDte, the DCE still uses the internally generated transmit clock as the S clock and for transmit data timing, but the receive data timing is derived from the X clock. The fromDte mode is recommended when the DTE is far away from the DCE interface.')
mscLpX21LineTerminationRequired = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21LineTerminationRequired.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21LineTerminationRequired.setDescription('This attribute specifies whether termination is required for this interface. If the hardware setup does not match this attribute, an alarm will be generated.')
mscLpX21ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 9), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ApplicationFramerName.setDescription('This attribute contains the component name of a Framer which is associated with the X21 component.')
mscLpX21EnableDynamicSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21EnableDynamicSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21EnableDynamicSpeed.setDescription('When set to yes, this attribute specifies that the transmit link speed should be set to the calculated receiver link speed. This attribute can be set to yes only if the linkMode is dce and the dteDataClockSource is fromDte..')
mscLpX21CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 11), )
if mibBuilder.loadTexts: mscLpX21CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpX21CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21CidDataEntry.setDescription('An entry in the mscLpX21CidDataTable.')
mscLpX21CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpX21AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 12), )
if mibBuilder.loadTexts: mscLpX21AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpX21AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21AdminInfoEntry.setDescription('An entry in the mscLpX21AdminInfoTable.')
mscLpX21Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpX21CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpX21IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 13), )
if mibBuilder.loadTexts: mscLpX21IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpX21IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21IfEntryEntry.setDescription('An entry in the mscLpX21IfEntryTable.')
mscLpX21IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpX21IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpX21OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 14), )
if mibBuilder.loadTexts: mscLpX21OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpX21OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21OperStatusEntry.setDescription('An entry in the mscLpX21OperStatusTable.')
mscLpX21SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpX21StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15), )
if mibBuilder.loadTexts: mscLpX21StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpX21StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21StateEntry.setDescription('An entry in the mscLpX21StateTable.')
mscLpX21AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpX21OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpX21UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpX21AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpX21ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpX21ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpX21AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpX21StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpX21UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpX21OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 16), )
if mibBuilder.loadTexts: mscLpX21OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21OperTable.setDescription('This group contains all specific operational data for an X21 component.')
mscLpX21OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"))
if mibBuilder.loadTexts: mscLpX21OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21OperEntry.setDescription('An entry in the mscLpX21OperTable.')
mscLpX21ActualLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21ActualLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ActualLinkMode.setDescription('This attribute contains the actual link mode defined by the hardware. Note that the hardware overrides the provisionable data. The interface behaves as a DCE or DTE according to the actualLinkMode.')
mscLpX21LineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 16, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21LineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21LineState.setDescription('This attribute contains the current state of the interface signals. Description of bits: indication(0) control(1)')
mscLpX21ActualTxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 16, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21ActualTxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ActualTxLineSpeed.setDescription('This attribute is the measured speed of the transmit clock.')
mscLpX21ActualRxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 16, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21ActualRxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21ActualRxLineSpeed.setDescription('This attribute is the measured speed of the receive clock.')
mscLpX21DataXferStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21DataXferStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21DataXferStateChanges.setDescription('This attribute contains the number of times that the line has entered or exited the data transfer state.')
mscLpX21Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2))
mscLpX21TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 1), )
if mibBuilder.loadTexts: mscLpX21TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpX21Test components.')
mscLpX21TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21TestIndex"))
if mibBuilder.loadTexts: mscLpX21TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpX21Test component.')
mscLpX21TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpX21Test components. These components cannot be added nor deleted.')
mscLpX21TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpX21TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestStorageType.setDescription('This variable represents the storage type value for the mscLpX21Test tables.')
mscLpX21TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpX21TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestIndex.setDescription('This variable represents the index for the mscLpX21Test tables.')
mscLpX21TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 10), )
if mibBuilder.loadTexts: mscLpX21TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpX21TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21TestIndex"))
if mibBuilder.loadTexts: mscLpX21TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestStateEntry.setDescription('An entry in the mscLpX21TestStateTable.')
mscLpX21TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpX21TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpX21TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpX21TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11), )
if mibBuilder.loadTexts: mscLpX21TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpX21TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21TestIndex"))
if mibBuilder.loadTexts: mscLpX21TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestSetupEntry.setDescription('An entry in the mscLpX21TestSetupTable.')
mscLpX21TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpX21TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpX21TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpX21TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpX21TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpX21TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpX21TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpX21TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpX21TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpX21TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12), )
if mibBuilder.loadTexts: mscLpX21TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpX21TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpX21TestIndex"))
if mibBuilder.loadTexts: mscLpX21TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestResultsEntry.setDescription('An entry in the mscLpX21TestResultsTable.')
mscLpX21TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpX21TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpX21TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpX21TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpX21TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpX21TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpX21TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpX21TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpX21TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpX21TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpX21TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 10, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpX21TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpX21TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpSonet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14))
mscLpSonetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 1), )
if mibBuilder.loadTexts: mscLpSonetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSonet components.')
mscLpSonetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSonet component.')
mscLpSonetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSonet components. These components can be added and deleted.')
mscLpSonetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSonetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetStorageType.setDescription('This variable represents the storage type value for the mscLpSonet tables.')
mscLpSonetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpSonetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetIndex.setDescription('This variable represents the index for the mscLpSonet tables.')
mscLpSonetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 10), )
if mibBuilder.loadTexts: mscLpSonetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetProvTable.setDescription('This group contains all of the provisioning data for a Sonet or Sdh component.')
mscLpSonetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetProvEntry.setDescription('An entry in the mscLpSonetProvTable.')
mscLpSonetClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetClockingSource.setDescription('This attribute defines the type of clocking source used for synchronizing the OC-3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means the use of a signal phase-locked to the incoming OC-3 line rate; module means the use of a signal phase-locked to the CP reference clock. When adding a Sonet/Sdh component, the clockingSource attribute is set to module if the NetworkSynchronization component has been added and is set to local otherwise. Note that the multiport OC-3 cell-based cards has one common clock source for each of the three ports when either the clocking source local or module is selected. For this reason, it is not allowed to have at the same time the clockingSource attribute set to local on one port and module on another port. Furthermore, the clockingSource attribute cannot be set to module if the NetworkSynchronization component has not been added.')
mscLpSonetCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 11), )
if mibBuilder.loadTexts: mscLpSonetCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpSonetCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetCidDataEntry.setDescription('An entry in the mscLpSonetCidDataTable.')
mscLpSonetCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpSonetAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 12), )
if mibBuilder.loadTexts: mscLpSonetAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpSonetAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetAdminInfoEntry.setDescription('An entry in the mscLpSonetAdminInfoTable.')
mscLpSonetVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetVendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetVendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpSonetCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetCommentText.setDescription('Any miscellaneous text about the facility.')
mscLpSonetIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 13), )
if mibBuilder.loadTexts: mscLpSonetIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpSonetIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetIfEntryEntry.setDescription('An entry in the mscLpSonetIfEntryTable.')
mscLpSonetIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpSonetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpSonetOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 14), )
if mibBuilder.loadTexts: mscLpSonetOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpSonetOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetOperStatusEntry.setDescription('An entry in the mscLpSonetOperStatusTable.')
mscLpSonetSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpSonetStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15), )
if mibBuilder.loadTexts: mscLpSonetStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpSonetStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetStateEntry.setDescription('An entry in the mscLpSonetStateTable.')
mscLpSonetAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSonetOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSonetUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSonetAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpSonetProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpSonetControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpSonetAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpSonetStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpSonetUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpSonetOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16), )
if mibBuilder.loadTexts: mscLpSonetOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetOperTable.setDescription('This group contains the common operational data for Sonet or Sdh component.')
mscLpSonetOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetOperEntry.setDescription('An entry in the mscLpSonetOperTable.')
mscLpSonetLosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLosAlarm.setDescription('This attribute indicates whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, or if an LOS defect is present when the criteria for LOF failure declaration have been met. A LOS defect is declared when 20+/-3 us of all-zeros pattern is detected. The LOS defect is cleared when two valid framing words are detected and no Loss Of Signal condition is detected during an interval of 20+/-3 us. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared after LOS defects have been absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSonetLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when LOF defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, except when an LOS defect or failure is present. An LOF defect is detected when getting contiguous errored frame alignment for at least 3 msec. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when framing has been achieved for a period of 10 seconds +/- 0.5 seconds. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSonetRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetRxAisAlarm.setDescription('This attribute displays whether a Line Alarm Indication Signal (L- AIS) alarm state has been entered. An L-AIS alarm state is entered when L-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-AIS defect is the occurrence of the L-AIS signal in five contiguous STS (STM) frames (111 pattern in bits 6,7, and 8 of the K2 bytes). If the L-AIS defects are intermittently occurring, the L-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-AIS alarm condition is cleared. The condition is cleared after not detecting the L-AIS signal for a period of 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSonetRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetRxRfiAlarm.setDescription('This attribute displays whether a Line Remote Failure Indication (LRFI) alarm state has been entered. An L-RFI alarm state is entered when Line Remote Failure Indication (L-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-RDI defect is the occurrence of the L-RDI signal in five contiguous valid STS (STM) frame (110 pattern in bits 6,7, and 8 of the K2 bytes). If the L-RDI defects are intermittently occurring, the L-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-RFI alarm condition is cleared. The condition is cleared after not detecting the L-RDI signal for a period of 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSonetTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTxAis.setDescription('This attribute displays whether the Line Alarm Indication Signal (L- AIS) signal is being transmitted on the outgoing line. This signal is transmitted when the Sonet/Sdh is locked and left offline.')
mscLpSonetTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTxRdi.setDescription('This attribute displays whether the Line Remote Defect Indicator (L-RDI) signal is being transmitted over the OC-3 line. The L-RDI signal is transmitted upon the detection of the LOS, LOF or L-AIS defect. This attribute is always set to off when the component has been locked and left offline.')
mscLpSonetUnusableTxClockRefAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetUnusableTxClockRefAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetUnusableTxClockRefAlarm.setDescription("This attribute displays whether an Unusable Transmit Clock Reference (UTCR) alarm state has been entered. A UTCR alarm state is entered when a Sonet/Sdh port provisioned to act as a transmit clock reference has received the code 'do not use for synchronization' in the S1 byte (in the SONET/ SDH line overhead) for 2.5 +/- 0.5 seconds. The condition is cleared after not detecting the 'do not use for synchronization' code for a period of 10 +/- 0.5 seconds or when the port is no longer provisioned to act as a transmit clock reference. A port is acting as a transmit clock reference if it is provisioned with a) a clockingSource of line, or b) it has been provisioned as a primaryReference, secondaryReference or tertiaryReference in the NetworkSynchronization component. The unusableTxClockRefAlarm attribute is always set to off when the component has been locked and left offline.")
mscLpSonetStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17), )
if mibBuilder.loadTexts: mscLpSonetStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetStatsTable.setDescription('This group contains the statistics data for a Sonet or Sdh component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpSonetStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"))
if mibBuilder.loadTexts: mscLpSonetStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetStatsEntry.setDescription('An entry in the mscLpSonetStatsTable.')
mscLpSonetRunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetRunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetRunningTime.setDescription('This attribute indicates the total number of seconds since the Sonet/ Sdh component has been activated and been in unlocked state. All the other error counts that follow can be updated when this count is active.')
mscLpSonetErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an near-end error free state.')
mscLpSonetSectCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetSectCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetSectCodeViolations.setDescription('This attribute indicates the total number of Section Code Violations (SCVs) detected. A SCV corresponds to section BIP-8 error. SCV counting is inhibited for second intervals where a Section Severely Errored Second (SSES) is counted. The count wraps at its maximum value.')
mscLpSonetSectErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetSectErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetSectErroredSec.setDescription('This attribute indicates the total number of Section Errored Seconds (SESs) that have been counted. A SES is declared for second intervals containing one or more SCVs or one or more Loss Of Signal (LOS) or Severely Errored Frame (SEF) defects. A SEF defect is the occurrence of 4 contiguous errored STS or STM frame alignment words.')
mscLpSonetSectSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetSectSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetSectSevErroredSec.setDescription('This attribute indicates the total number of Section Severely Errored Seconds (SSESs) that have been counted. A SSES is declared for second intervals containing more than x SCVs or one or more LOS or SEF defects. The value of x is 155 for a 155 Mbits/sec interface.')
mscLpSonetSectLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetSectLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetSectLosSec.setDescription('This attribute indicates the total number of Section LOS Seconds (SLOSSs) that have been counted. A SLOSS is declared for second intervals containing one or more LOS defects.')
mscLpSonetSectSevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetSectSevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetSectSevErroredFrmSec.setDescription('This attribute indicates the total number of Section Severely Errored Frame Seconds (SSEFSs) that have been counted. A SSEFS is declared for second intervals containing one or more SEF defects.')
mscLpSonetSectFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetSectFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetSectFailures.setDescription('This attribute indicates the total number of times that a section failure (LOS or LOF failure) has been declared.')
mscLpSonetLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCVs) detected. A LCV corresponds to a line BIP-24 errors. LCV counting is inhibited for second intervals where a Line Severely Errored Second (LSES) is counted. Counting of LCVs is also inhibited over second intervals where a Line Unavailable Second (LUAS) is counted. The count wraps at its maximum value.')
mscLpSonetLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LESs) that have been counted. A LES is declared for second intervals containing one or more LCVs or one or more line AIS defects. Counting of LES is inhibited over second intervals where a LUAS is counted.')
mscLpSonetLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSESs) that have been counted. A LSES is declared for second intervals containing more than x LCVs or one or more L- AIS defects. The value of x is 154 for a 155 Mbits/sec interface. Counting of LSES is inhibited over second intervals where a LUAS is counted.')
mscLpSonetLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLineAisSec.setDescription('This attribute indicates the total number of Line AIS Seconds (LAISSs) that have been counted. A LAISS is declared for second intervals containing one or more L-AIS defects. Counting of LAISS is inhibited over second intervals where a LUAS is counted.')
mscLpSonetLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS line is unavailable. The STS line becomes unavailable at the onset of 10 consecutive LSESs. The 10 LSESs are included in the unavailable time. Once unavailable, the STS line becomes available at the onset of 10 contiguous seconds with no LSES. The 10 seconds with no LSES are excluded from the unavailable time. For second intervals where a Line Unavailable Second (LUAS) is counted, counting of LCV, LES, LSES and LAISS is inhibited.')
mscLpSonetLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetLineFailures.setDescription('This attribute indicates the total number of times that a line failure (L-AIS failure) has been declared.')
mscLpSonetFarEndLineErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetFarEndLineErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetFarEndLineErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an far-end error free state.')
mscLpSonetFarEndLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetFarEndLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetFarEndLineCodeViolations.setDescription('This attribute indicates the total number of line FEBE detected from the incoming line. The counting of line FEBE is inhibited for second intervals where a Far-End Line Severely Errored Second (FELSES) is counted. Counting of FELCVs is also inhibited over second intervals where a Far-End Line Unavailable Second (FELUAS) is counted. The count wraps at its maximum value.')
mscLpSonetFarEndLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetFarEndLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetFarEndLineErroredSec.setDescription('This attribute indicates the total number of Far-End Line Errored Seconds (FELESs) that have been counted. A FELES is declared for second intervals containing one or more Far-End Line CVs (FELCVs) or one or more L-RDI defects. Counting of FELES is inhibited over second intervals where a FELUAS is counted.')
mscLpSonetFarEndLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetFarEndLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetFarEndLineSevErroredSec.setDescription('This attribute indicates the total number of Far-End Line Severely Errored Seconds (FELSESs) that have been counted. A FELSES is declared for second intervals containing more than x FELCVs or one or more L-RDI defects. The value of x is 154 for a 155 Mbits/ sec interface. Counting of FELSES is inhibited over second intervals where a FELUAS is counted.')
mscLpSonetFarEndLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetFarEndLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetFarEndLineAisSec.setDescription('This attribute indicates the total number of Far-End Line AIS Seconds (FELAISSs) that have been counted. A FELAISS is declared for second intervals one or more L-RDI defects. Counting of FELAISS is inhibited over second intervals where a FELUAS is counted.')
mscLpSonetFarEndLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetFarEndLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetFarEndLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS far-end line is unavailable. The STS far-end line becomes unavailable at the onset of 10 consecutive FELSESs. The 10 FELSESs are included in the unavailable time. Once unavailable, the STS far-end line becomes available at the onset of 10 contiguous seconds with no FELSES. The 10 seconds with no FELSES are excluded from the unavailable time. For second intervals where a Far-End Line Unavailable Second (FELUAS) is counted, counting of FELCV, FELES, FELSES and FELAISS is inhibited.')
mscLpSonetFarEndLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 17, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetFarEndLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetFarEndLineFailures.setDescription('This attribute indicates the total number of times that a far-end line failure (L-RFI failure) has been declared.')
mscLpSonetPath = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2))
mscLpSonetPathRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 1), )
if mibBuilder.loadTexts: mscLpSonetPathRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSonetPath components.')
mscLpSonetPathRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSonetPath component.')
mscLpSonetPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetPathRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSonetPath components. These components can be added and deleted.')
mscLpSonetPathComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSonetPathStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathStorageType.setDescription('This variable represents the storage type value for the mscLpSonetPath tables.')
mscLpSonetPathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscLpSonetPathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathIndex.setDescription('This variable represents the index for the mscLpSonetPath tables.')
mscLpSonetPathProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 10), )
if mibBuilder.loadTexts: mscLpSonetPathProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathProvTable.setDescription('This group contains all of the provisioning data for a Sonet/Sdh Path component.')
mscLpSonetPathProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathProvEntry.setDescription('An entry in the mscLpSonetPathProvTable.')
mscLpSonetPathApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetPathApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the Path component.')
mscLpSonetPathCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 11), )
if mibBuilder.loadTexts: mscLpSonetPathCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpSonetPathCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCidDataEntry.setDescription('An entry in the mscLpSonetPathCidDataTable.')
mscLpSonetPathCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetPathCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpSonetPathStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12), )
if mibBuilder.loadTexts: mscLpSonetPathStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpSonetPathStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathStateEntry.setDescription('An entry in the mscLpSonetPathStateTable.')
mscLpSonetPathAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSonetPathOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSonetPathUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSonetPathAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpSonetPathProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpSonetPathControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpSonetPathAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpSonetPathStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpSonetPathUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpSonetPathIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 13), )
if mibBuilder.loadTexts: mscLpSonetPathIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpSonetPathIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathIfEntryEntry.setDescription('An entry in the mscLpSonetPathIfEntryTable.')
mscLpSonetPathIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetPathIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpSonetPathIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpSonetPathOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 14), )
if mibBuilder.loadTexts: mscLpSonetPathOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpSonetPathOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathOperStatusEntry.setDescription('An entry in the mscLpSonetPathOperStatusTable.')
mscLpSonetPathSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpSonetPathOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15), )
if mibBuilder.loadTexts: mscLpSonetPathOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathOperTable.setDescription('This group contains the common operational data for Path component.')
mscLpSonetPathOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathOperEntry.setDescription('An entry in the mscLpSonetPathOperTable.')
mscLpSonetPathLopAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathLopAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathLopAlarm.setDescription('This attribute displays whether a Loss Of Pointer (LOP) alarm state has been entered. An LOP alarm state is entered when LOP defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOP defect occurs when no valid SPE or VC pointer was received in 8 contiguous frames. If the LOP defects are intermittently occurring, the LOP defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the LOP alarm condition is cleared. The condition is cleared when no more invalid pointer has been reported for 10 seconds +/- 0.5 seconds. The lopAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSonetPathRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathRxAisAlarm.setDescription("This attribute displays whether an Path Alarm Indication Signal (P- AIS) alarm state has been entered. An P-AIS alarm state is entered when P-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-AIS defect is the occurrence of the P-AIS signal in three contiguous valid STS or STM frames (all one's in bytes H1 and H2). If the P-AIS defects are intermittently occurring, the P-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-AIS alarm condition is cleared. The condition is cleared after no P-AIS defect has been detected for 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
mscLpSonetPathRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathRxRfiAlarm.setDescription('This attribute displays whether the Path Remote Failure Indication (P-RFI) alarm state has been entered. An P-RFI alarm state is entered when Path Remote Defect Indicator (P-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-RDI defect is the occurrence of the P-RDI signal in five contiguous valid STS or STM frames (bit 5 of the G1 byte set to 1). If the P-RDI defects are intermittently occurring, the P-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10)with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-RFI alarm condition is cleared. The condition is cleared after no P-RDI defect has been detected for 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSonetPathSignalLabelMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathSignalLabelMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathSignalLabelMismatch.setDescription("This attribute displays whether the Path Signal Label Mismatch (P- SLM) failure condition has been entered. An P-SLM failure condition is entered when P-SLM defects have been observed and accumulated for period of 2.5 seconds +/- 0.5 seconds. An P-SLM defect occurs when detecting an unexpected path signal label. The expected Path signal labels are 'Mapping for ATM' or 'Equipped - Non Specific Payload'. If the P-SLM defects are intermittently occurring, the P-SLM defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the Path Signal Label Mismatch failure condition is cleared. The condition is cleared when an expected path signal label is received for 10 seconds +/- 0.5 seconds. The signalLabelMismatch attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
mscLpSonetPathTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathTxAis.setDescription('This attribute displays whether the Path Alarm Indication Signal (P- AIS) signal is being transmitted on the path. The P-AIS signal is transmitted when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSonetPathTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathTxRdi.setDescription('This attribute displays whether the Path Remote Defect Indicator (P-RDI) signal is being transmitted over the path signal. The P-RDI signal is transmitted over the outgoing line upon detection of LOP, P-AIS or the occurrence of the LCD state. This attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSonetPathStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16), )
if mibBuilder.loadTexts: mscLpSonetPathStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathStatsTable.setDescription('This group contains the statistics data for a Sonet/Sdh Path component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpSonetPathStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"))
if mibBuilder.loadTexts: mscLpSonetPathStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathStatsEntry.setDescription('An entry in the mscLpSonetPathStatsTable.')
mscLpSonetPathPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an near-end error free state.')
mscLpSonetPathPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathPathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCVs) detected. Each PCV corresponds to a path BIP-8 error. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. The count wraps at its maximum value.')
mscLpSonetPathPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathPathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PESs) that have been counted. A PES is declared for second intervals containing one or more PCVs or one or more LOP or path AIS defects. Counting of PES is inhibited when PUAS is counted over the monitored second.')
mscLpSonetPathPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathPathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSESs) that have been counted. A PSES is declared for second intervals containing more than x PCVs or one or more LOP or path AIS defects. The value of x is 2400 for a 155 Mbits/sec interface. Counting of PSES is inhibited when PUAS is counted over the monitored second.')
mscLpSonetPathPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathPathAisLopSec.setDescription('This attribute indicates the total number of path AIS and LOP Seconds (PALSs). A PALS is declared for second intervals containing one or more path AIS or LOP defects. Counting of PALS is inhibited when PUAS is counted over the monitored second.')
mscLpSonetPathPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM path is unavailable. The path becomes unavailable at the onset of 10 consecutive PSESs. The 10 PSESs are included in the unavailable time. Once unavailable, the path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where a Path Unavailable Second (PUAS) is counted, counting of PCV, PES, PSES and PALS is inhibited.')
mscLpSonetPathPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathPathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOP, P-AIS or Path Signal Label Mismatch failure) has been declared.')
mscLpSonetPathFarEndPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an far-end error free state.')
mscLpSonetPathFarEndPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathCodeViolations.setDescription('This attribute indicates the total number of Far-End Path Code Violations (FEPCVs) detected. Each FEPCV corresponds to a path FEBE. FEPCV counting is inhibited over second intervals where a Far-End Path Severely Errored Second (FEPSES) is counted. Counting of PCVs is also inhibited over second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted. The count wraps at its maximum value.')
mscLpSonetPathFarEndPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathErroredSec.setDescription('This attribute indicates the total number of Far-End Path Errored Seconds (FEPESs) that have been counted. A FEPES is declared for second intervals containing one or more FEPCVs or one or more path RDI (P-RDI) defects. Counting of FEPES is inhibited when FEPUAS is counted over the monitored second.')
mscLpSonetPathFarEndPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathSevErroredSec.setDescription('This attribute indicates the total number of Far-End Path Severely Errored Seconds (FEPSESs) that have been counted. A FEPSES is declared for second intervals containing more than x FEPCVs or one or more P-RDI defects. The value of x is 2400 for a 155 Mbits/ sec interface. Counting of FEPSESs is inhibited when FEPUAS is counted over the monitored second.')
mscLpSonetPathFarEndPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathAisLopSec.setDescription('This attribute indicates the total number of Far-End Path AIS and LOP Seconds (FEPALSs). A FEPALS is declared for second intervals containing one or more P-RDI defects. Counting of FEPALS is inhibited when FEPUAS is counted over the monitored second.')
mscLpSonetPathFarEndPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM far-end path is unavailable. The far-end path becomes unavailable at the onset of 10 consecutive FEPSESs. The 10 FEPSESs are included in the unavailable time. Once unavailable, the far-end path becomes available at the onset of 10 contiguous seconds with no FEPSES. The 10 seconds with no FEPSES are excluded from the unavailable time. For second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted, counting of FEPCV, FEPES, FEPSES and FEPALS is inhibited.')
mscLpSonetPathFarEndPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 16, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathFarEndPathFailures.setDescription('This attribute indicates the total number of times that a STS/STM far-end path failure (P-RFI failure) has been declared.')
mscLpSonetPathCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2))
mscLpSonetPathCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 1), )
if mibBuilder.loadTexts: mscLpSonetPathCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSonetPathCell components.')
mscLpSonetPathCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathCellIndex"))
if mibBuilder.loadTexts: mscLpSonetPathCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSonetPathCell component.')
mscLpSonetPathCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSonetPathCell components. These components cannot be added nor deleted.')
mscLpSonetPathCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSonetPathCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellStorageType.setDescription('This variable represents the storage type value for the mscLpSonetPathCell tables.')
mscLpSonetPathCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpSonetPathCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellIndex.setDescription('This variable represents the index for the mscLpSonetPathCell tables.')
mscLpSonetPathCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 10), )
if mibBuilder.loadTexts: mscLpSonetPathCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpSonetPathCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathCellIndex"))
if mibBuilder.loadTexts: mscLpSonetPathCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellProvEntry.setDescription('An entry in the mscLpSonetPathCellProvTable.')
mscLpSonetPathCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetPathCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpSonetPathCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetPathCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpSonetPathCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetPathCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpSonetPathCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 11), )
if mibBuilder.loadTexts: mscLpSonetPathCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpSonetPathCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathCellIndex"))
if mibBuilder.loadTexts: mscLpSonetPathCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellOperEntry.setDescription('An entry in the mscLpSonetPathCellOperTable.')
mscLpSonetPathCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpSonetPathCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 12), )
if mibBuilder.loadTexts: mscLpSonetPathCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpSonetPathCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetPathCellIndex"))
if mibBuilder.loadTexts: mscLpSonetPathCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellStatsEntry.setDescription('An entry in the mscLpSonetPathCellStatsTable.')
mscLpSonetPathCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpSonetPathCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpSonetPathCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpSonetPathCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpSonetPathCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 2, 2, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetPathCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetPathCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpSonetTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3))
mscLpSonetTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 1), )
if mibBuilder.loadTexts: mscLpSonetTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSonetTest components.')
mscLpSonetTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetTestIndex"))
if mibBuilder.loadTexts: mscLpSonetTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSonetTest component.')
mscLpSonetTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSonetTest components. These components cannot be added nor deleted.')
mscLpSonetTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSonetTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestStorageType.setDescription('This variable represents the storage type value for the mscLpSonetTest tables.')
mscLpSonetTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpSonetTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestIndex.setDescription('This variable represents the index for the mscLpSonetTest tables.')
mscLpSonetTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 10), )
if mibBuilder.loadTexts: mscLpSonetTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpSonetTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetTestIndex"))
if mibBuilder.loadTexts: mscLpSonetTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestStateEntry.setDescription('An entry in the mscLpSonetTestStateTable.')
mscLpSonetTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpSonetTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpSonetTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpSonetTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11), )
if mibBuilder.loadTexts: mscLpSonetTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpSonetTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetTestIndex"))
if mibBuilder.loadTexts: mscLpSonetTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestSetupEntry.setDescription('An entry in the mscLpSonetTestSetupTable.')
mscLpSonetTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpSonetTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpSonetTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpSonetTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpSonetTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpSonetTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpSonetTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpSonetTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSonetTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpSonetTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12), )
if mibBuilder.loadTexts: mscLpSonetTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpSonetTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSonetTestIndex"))
if mibBuilder.loadTexts: mscLpSonetTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestResultsEntry.setDescription('An entry in the mscLpSonetTestResultsTable.')
mscLpSonetTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpSonetTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpSonetTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpSonetTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpSonetTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpSonetTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpSonetTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpSonetTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpSonetTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpSonetTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpSonetTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 14, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSonetTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSonetTestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpSdh = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15))
mscLpSdhRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 1), )
if mibBuilder.loadTexts: mscLpSdhRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSdh components.')
mscLpSdhRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSdh component.')
mscLpSdhRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSdh components. These components can be added and deleted.')
mscLpSdhComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSdhStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhStorageType.setDescription('This variable represents the storage type value for the mscLpSdh tables.')
mscLpSdhIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscLpSdhIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhIndex.setDescription('This variable represents the index for the mscLpSdh tables.')
mscLpSdhProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 10), )
if mibBuilder.loadTexts: mscLpSdhProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhProvTable.setDescription('This group contains all of the provisioning data for a Sonet or Sdh component.')
mscLpSdhProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhProvEntry.setDescription('An entry in the mscLpSdhProvTable.')
mscLpSdhClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhClockingSource.setDescription('This attribute defines the type of clocking source used for synchronizing the OC-3 transmit clock: local means direct use of the local clock oscillator at its centre frequency; line means the use of a signal phase-locked to the incoming OC-3 line rate; module means the use of a signal phase-locked to the CP reference clock. When adding a Sonet/Sdh component, the clockingSource attribute is set to module if the NetworkSynchronization component has been added and is set to local otherwise. Note that the multiport OC-3 cell-based cards has one common clock source for each of the three ports when either the clocking source local or module is selected. For this reason, it is not allowed to have at the same time the clockingSource attribute set to local on one port and module on another port. Furthermore, the clockingSource attribute cannot be set to module if the NetworkSynchronization component has not been added.')
mscLpSdhCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 11), )
if mibBuilder.loadTexts: mscLpSdhCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpSdhCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhCidDataEntry.setDescription('An entry in the mscLpSdhCidDataTable.')
mscLpSdhCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpSdhAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 12), )
if mibBuilder.loadTexts: mscLpSdhAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpSdhAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhAdminInfoEntry.setDescription('An entry in the mscLpSdhAdminInfoTable.')
mscLpSdhVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhVendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhVendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpSdhCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhCommentText.setDescription('Any miscellaneous text about the facility.')
mscLpSdhIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 13), )
if mibBuilder.loadTexts: mscLpSdhIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpSdhIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhIfEntryEntry.setDescription('An entry in the mscLpSdhIfEntryTable.')
mscLpSdhIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpSdhIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpSdhOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 14), )
if mibBuilder.loadTexts: mscLpSdhOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpSdhOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhOperStatusEntry.setDescription('An entry in the mscLpSdhOperStatusTable.')
mscLpSdhSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpSdhStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15), )
if mibBuilder.loadTexts: mscLpSdhStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpSdhStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhStateEntry.setDescription('An entry in the mscLpSdhStateTable.')
mscLpSdhAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSdhOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSdhUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSdhAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpSdhProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpSdhControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpSdhAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpSdhStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpSdhUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpSdhOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16), )
if mibBuilder.loadTexts: mscLpSdhOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhOperTable.setDescription('This group contains the common operational data for Sonet or Sdh component.')
mscLpSdhOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhOperEntry.setDescription('An entry in the mscLpSdhOperTable.')
mscLpSdhLosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLosAlarm.setDescription('This attribute indicates whether a Loss Of Signal (LOS) alarm state has been entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, or if an LOS defect is present when the criteria for LOF failure declaration have been met. A LOS defect is declared when 20+/-3 us of all-zeros pattern is detected. The LOS defect is cleared when two valid framing words are detected and no Loss Of Signal condition is detected during an interval of 20+/-3 us. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOS alarm condition is cleared. The LOS alarm state is cleared after LOS defects have been absent for a period of 10 seconds +/- 0.5 seconds. The losAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSdhLofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLofAlarm.setDescription('This attribute displays whether a Loss Of Frame (LOF) alarm state has been entered. An LOF alarm state is entered when LOF defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds, except when an LOS defect or failure is present. An LOF defect is detected when getting contiguous errored frame alignment for at least 3 msec. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the LOF alarm condition is cleared. The condition is cleared when framing has been achieved for a period of 10 seconds +/- 0.5 seconds. The lofAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSdhRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhRxAisAlarm.setDescription('This attribute displays whether a Line Alarm Indication Signal (L- AIS) alarm state has been entered. An L-AIS alarm state is entered when L-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-AIS defect is the occurrence of the L-AIS signal in five contiguous STS (STM) frames (111 pattern in bits 6,7, and 8 of the K2 bytes). If the L-AIS defects are intermittently occurring, the L-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-AIS alarm condition is cleared. The condition is cleared after not detecting the L-AIS signal for a period of 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSdhRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhRxRfiAlarm.setDescription('This attribute displays whether a Line Remote Failure Indication (LRFI) alarm state has been entered. An L-RFI alarm state is entered when Line Remote Failure Indication (L-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The L-RDI defect is the occurrence of the L-RDI signal in five contiguous valid STS (STM) frame (110 pattern in bits 6,7, and 8 of the K2 bytes). If the L-RDI defects are intermittently occurring, the L-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Sonet/Sdh component goes into an operational state of disabled until the L-RFI alarm condition is cleared. The condition is cleared after not detecting the L-RDI signal for a period of 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the component has been locked and left offline.')
mscLpSdhTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTxAis.setDescription('This attribute displays whether the Line Alarm Indication Signal (L- AIS) signal is being transmitted on the outgoing line. This signal is transmitted when the Sonet/Sdh is locked and left offline.')
mscLpSdhTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTxRdi.setDescription('This attribute displays whether the Line Remote Defect Indicator (L-RDI) signal is being transmitted over the OC-3 line. The L-RDI signal is transmitted upon the detection of the LOS, LOF or L-AIS defect. This attribute is always set to off when the component has been locked and left offline.')
mscLpSdhUnusableTxClockRefAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhUnusableTxClockRefAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhUnusableTxClockRefAlarm.setDescription("This attribute displays whether an Unusable Transmit Clock Reference (UTCR) alarm state has been entered. A UTCR alarm state is entered when a Sonet/Sdh port provisioned to act as a transmit clock reference has received the code 'do not use for synchronization' in the S1 byte (in the SONET/ SDH line overhead) for 2.5 +/- 0.5 seconds. The condition is cleared after not detecting the 'do not use for synchronization' code for a period of 10 +/- 0.5 seconds or when the port is no longer provisioned to act as a transmit clock reference. A port is acting as a transmit clock reference if it is provisioned with a) a clockingSource of line, or b) it has been provisioned as a primaryReference, secondaryReference or tertiaryReference in the NetworkSynchronization component. The unusableTxClockRefAlarm attribute is always set to off when the component has been locked and left offline.")
mscLpSdhStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17), )
if mibBuilder.loadTexts: mscLpSdhStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhStatsTable.setDescription('This group contains the statistics data for a Sonet or Sdh component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpSdhStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"))
if mibBuilder.loadTexts: mscLpSdhStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhStatsEntry.setDescription('An entry in the mscLpSdhStatsTable.')
mscLpSdhRunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhRunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhRunningTime.setDescription('This attribute indicates the total number of seconds since the Sonet/ Sdh component has been activated and been in unlocked state. All the other error counts that follow can be updated when this count is active.')
mscLpSdhErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an near-end error free state.')
mscLpSdhSectCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhSectCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhSectCodeViolations.setDescription('This attribute indicates the total number of Section Code Violations (SCVs) detected. A SCV corresponds to section BIP-8 error. SCV counting is inhibited for second intervals where a Section Severely Errored Second (SSES) is counted. The count wraps at its maximum value.')
mscLpSdhSectErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhSectErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhSectErroredSec.setDescription('This attribute indicates the total number of Section Errored Seconds (SESs) that have been counted. A SES is declared for second intervals containing one or more SCVs or one or more Loss Of Signal (LOS) or Severely Errored Frame (SEF) defects. A SEF defect is the occurrence of 4 contiguous errored STS or STM frame alignment words.')
mscLpSdhSectSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhSectSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhSectSevErroredSec.setDescription('This attribute indicates the total number of Section Severely Errored Seconds (SSESs) that have been counted. A SSES is declared for second intervals containing more than x SCVs or one or more LOS or SEF defects. The value of x is 155 for a 155 Mbits/sec interface.')
mscLpSdhSectLosSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhSectLosSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhSectLosSec.setDescription('This attribute indicates the total number of Section LOS Seconds (SLOSSs) that have been counted. A SLOSS is declared for second intervals containing one or more LOS defects.')
mscLpSdhSectSevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhSectSevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhSectSevErroredFrmSec.setDescription('This attribute indicates the total number of Section Severely Errored Frame Seconds (SSEFSs) that have been counted. A SSEFS is declared for second intervals containing one or more SEF defects.')
mscLpSdhSectFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhSectFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhSectFailures.setDescription('This attribute indicates the total number of times that a section failure (LOS or LOF failure) has been declared.')
mscLpSdhLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLineCodeViolations.setDescription('This attribute indicates the total number of Line Code Violations (LCVs) detected. A LCV corresponds to a line BIP-24 errors. LCV counting is inhibited for second intervals where a Line Severely Errored Second (LSES) is counted. Counting of LCVs is also inhibited over second intervals where a Line Unavailable Second (LUAS) is counted. The count wraps at its maximum value.')
mscLpSdhLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLineErroredSec.setDescription('This attribute indicates the total number of Line Errored Seconds (LESs) that have been counted. A LES is declared for second intervals containing one or more LCVs or one or more line AIS defects. Counting of LES is inhibited over second intervals where a LUAS is counted.')
mscLpSdhLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLineSevErroredSec.setDescription('This attribute indicates the total number of Line Severely Errored Seconds (LSESs) that have been counted. A LSES is declared for second intervals containing more than x LCVs or one or more L- AIS defects. The value of x is 154 for a 155 Mbits/sec interface. Counting of LSES is inhibited over second intervals where a LUAS is counted.')
mscLpSdhLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLineAisSec.setDescription('This attribute indicates the total number of Line AIS Seconds (LAISSs) that have been counted. A LAISS is declared for second intervals containing one or more L-AIS defects. Counting of LAISS is inhibited over second intervals where a LUAS is counted.')
mscLpSdhLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS line is unavailable. The STS line becomes unavailable at the onset of 10 consecutive LSESs. The 10 LSESs are included in the unavailable time. Once unavailable, the STS line becomes available at the onset of 10 contiguous seconds with no LSES. The 10 seconds with no LSES are excluded from the unavailable time. For second intervals where a Line Unavailable Second (LUAS) is counted, counting of LCV, LES, LSES and LAISS is inhibited.')
mscLpSdhLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhLineFailures.setDescription('This attribute indicates the total number of times that a line failure (L-AIS failure) has been declared.')
mscLpSdhFarEndLineErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhFarEndLineErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhFarEndLineErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh component has been in an far-end error free state.')
mscLpSdhFarEndLineCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhFarEndLineCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhFarEndLineCodeViolations.setDescription('This attribute indicates the total number of line FEBE detected from the incoming line. The counting of line FEBE is inhibited for second intervals where a Far-End Line Severely Errored Second (FELSES) is counted. Counting of FELCVs is also inhibited over second intervals where a Far-End Line Unavailable Second (FELUAS) is counted. The count wraps at its maximum value.')
mscLpSdhFarEndLineErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhFarEndLineErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhFarEndLineErroredSec.setDescription('This attribute indicates the total number of Far-End Line Errored Seconds (FELESs) that have been counted. A FELES is declared for second intervals containing one or more Far-End Line CVs (FELCVs) or one or more L-RDI defects. Counting of FELES is inhibited over second intervals where a FELUAS is counted.')
mscLpSdhFarEndLineSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhFarEndLineSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhFarEndLineSevErroredSec.setDescription('This attribute indicates the total number of Far-End Line Severely Errored Seconds (FELSESs) that have been counted. A FELSES is declared for second intervals containing more than x FELCVs or one or more L-RDI defects. The value of x is 154 for a 155 Mbits/ sec interface. Counting of FELSES is inhibited over second intervals where a FELUAS is counted.')
mscLpSdhFarEndLineAisSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhFarEndLineAisSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhFarEndLineAisSec.setDescription('This attribute indicates the total number of Far-End Line AIS Seconds (FELAISSs) that have been counted. A FELAISS is declared for second intervals one or more L-RDI defects. Counting of FELAISS is inhibited over second intervals where a FELUAS is counted.')
mscLpSdhFarEndLineUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhFarEndLineUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhFarEndLineUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS far-end line is unavailable. The STS far-end line becomes unavailable at the onset of 10 consecutive FELSESs. The 10 FELSESs are included in the unavailable time. Once unavailable, the STS far-end line becomes available at the onset of 10 contiguous seconds with no FELSES. The 10 seconds with no FELSES are excluded from the unavailable time. For second intervals where a Far-End Line Unavailable Second (FELUAS) is counted, counting of FELCV, FELES, FELSES and FELAISS is inhibited.')
mscLpSdhFarEndLineFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 17, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhFarEndLineFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhFarEndLineFailures.setDescription('This attribute indicates the total number of times that a far-end line failure (L-RFI failure) has been declared.')
mscLpSdhPath = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2))
mscLpSdhPathRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 1), )
if mibBuilder.loadTexts: mscLpSdhPathRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSdhPath components.')
mscLpSdhPathRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSdhPath component.')
mscLpSdhPathRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhPathRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSdhPath components. These components can be added and deleted.')
mscLpSdhPathComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSdhPathStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathStorageType.setDescription('This variable represents the storage type value for the mscLpSdhPath tables.')
mscLpSdhPathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscLpSdhPathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathIndex.setDescription('This variable represents the index for the mscLpSdhPath tables.')
mscLpSdhPathProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 10), )
if mibBuilder.loadTexts: mscLpSdhPathProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathProvTable.setDescription('This group contains all of the provisioning data for a Sonet/Sdh Path component.')
mscLpSdhPathProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathProvEntry.setDescription('An entry in the mscLpSdhPathProvTable.')
mscLpSdhPathApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 10, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhPathApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the Path component.')
mscLpSdhPathCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 11), )
if mibBuilder.loadTexts: mscLpSdhPathCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpSdhPathCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCidDataEntry.setDescription('An entry in the mscLpSdhPathCidDataTable.')
mscLpSdhPathCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhPathCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpSdhPathStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12), )
if mibBuilder.loadTexts: mscLpSdhPathStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpSdhPathStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathStateEntry.setDescription('An entry in the mscLpSdhPathStateTable.')
mscLpSdhPathAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSdhPathOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSdhPathUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpSdhPathAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpSdhPathProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpSdhPathControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpSdhPathAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpSdhPathStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpSdhPathUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpSdhPathIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 13), )
if mibBuilder.loadTexts: mscLpSdhPathIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpSdhPathIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathIfEntryEntry.setDescription('An entry in the mscLpSdhPathIfEntryTable.')
mscLpSdhPathIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhPathIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpSdhPathIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpSdhPathOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 14), )
if mibBuilder.loadTexts: mscLpSdhPathOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpSdhPathOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathOperStatusEntry.setDescription('An entry in the mscLpSdhPathOperStatusTable.')
mscLpSdhPathSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpSdhPathOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15), )
if mibBuilder.loadTexts: mscLpSdhPathOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathOperTable.setDescription('This group contains the common operational data for Path component.')
mscLpSdhPathOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathOperEntry.setDescription('An entry in the mscLpSdhPathOperTable.')
mscLpSdhPathLopAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathLopAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathLopAlarm.setDescription('This attribute displays whether a Loss Of Pointer (LOP) alarm state has been entered. An LOP alarm state is entered when LOP defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOP defect occurs when no valid SPE or VC pointer was received in 8 contiguous frames. If the LOP defects are intermittently occurring, the LOP defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the LOP alarm condition is cleared. The condition is cleared when no more invalid pointer has been reported for 10 seconds +/- 0.5 seconds. The lopAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSdhPathRxAisAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathRxAisAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathRxAisAlarm.setDescription("This attribute displays whether an Path Alarm Indication Signal (P- AIS) alarm state has been entered. An P-AIS alarm state is entered when P-AIS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-AIS defect is the occurrence of the P-AIS signal in three contiguous valid STS or STM frames (all one's in bytes H1 and H2). If the P-AIS defects are intermittently occurring, the P-AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-AIS alarm condition is cleared. The condition is cleared after no P-AIS defect has been detected for 10 seconds +/- 0.5 seconds. The rxAisAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
mscLpSdhPathRxRfiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathRxRfiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathRxRfiAlarm.setDescription('This attribute displays whether the Path Remote Failure Indication (P-RFI) alarm state has been entered. An P-RFI alarm state is entered when Path Remote Defect Indicator (P-RDI) defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. The P-RDI defect is the occurrence of the P-RDI signal in five contiguous valid STS or STM frames (bit 5 of the G1 byte set to 1). If the P-RDI defects are intermittently occurring, the P-RDI defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10)with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the P-RFI alarm condition is cleared. The condition is cleared after no P-RDI defect has been detected for 10 seconds +/- 0.5 seconds. The rxRfiAlarm attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSdhPathSignalLabelMismatch = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathSignalLabelMismatch.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathSignalLabelMismatch.setDescription("This attribute displays whether the Path Signal Label Mismatch (P- SLM) failure condition has been entered. An P-SLM failure condition is entered when P-SLM defects have been observed and accumulated for period of 2.5 seconds +/- 0.5 seconds. An P-SLM defect occurs when detecting an unexpected path signal label. The expected Path signal labels are 'Mapping for ATM' or 'Equipped - Non Specific Payload'. If the P-SLM defects are intermittently occurring, the P-SLM defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The Path component goes into an operational state of disabled until the Path Signal Label Mismatch failure condition is cleared. The condition is cleared when an expected path signal label is received for 10 seconds +/- 0.5 seconds. The signalLabelMismatch attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.")
mscLpSdhPathTxAis = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathTxAis.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathTxAis.setDescription('This attribute displays whether the Path Alarm Indication Signal (P- AIS) signal is being transmitted on the path. The P-AIS signal is transmitted when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSdhPathTxRdi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathTxRdi.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathTxRdi.setDescription('This attribute displays whether the Path Remote Defect Indicator (P-RDI) signal is being transmitted over the path signal. The P-RDI signal is transmitted over the outgoing line upon detection of LOP, P-AIS or the occurrence of the LCD state. This attribute is always set to off when the Path component has been locked and left offline by the operator or when the Path component has been suspended since the parent component has been locked.')
mscLpSdhPathStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16), )
if mibBuilder.loadTexts: mscLpSdhPathStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathStatsTable.setDescription('This group contains the statistics data for a Sonet/Sdh Path component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpSdhPathStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"))
if mibBuilder.loadTexts: mscLpSdhPathStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathStatsEntry.setDescription('An entry in the mscLpSdhPathStatsTable.')
mscLpSdhPathPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an near-end error free state.')
mscLpSdhPathPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathPathCodeViolations.setDescription('This attribute indicates the total number of Path Code Violations (PCVs) detected. Each PCV corresponds to a path BIP-8 error. PCV counting is inhibited over second intervals where a Path Severely Errored Second (PSES) is counted. Counting of PCVs is also inhibited over second intervals where a Path Unavailable Second (PUAS) is counted. The count wraps at its maximum value.')
mscLpSdhPathPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathPathErroredSec.setDescription('This attribute indicates the total number of Path Errored Seconds (PESs) that have been counted. A PES is declared for second intervals containing one or more PCVs or one or more LOP or path AIS defects. Counting of PES is inhibited when PUAS is counted over the monitored second.')
mscLpSdhPathPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathPathSevErroredSec.setDescription('This attribute indicates the total number of Path Severely Errored Seconds (PSESs) that have been counted. A PSES is declared for second intervals containing more than x PCVs or one or more LOP or path AIS defects. The value of x is 2400 for a 155 Mbits/sec interface. Counting of PSES is inhibited when PUAS is counted over the monitored second.')
mscLpSdhPathPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathPathAisLopSec.setDescription('This attribute indicates the total number of path AIS and LOP Seconds (PALSs). A PALS is declared for second intervals containing one or more path AIS or LOP defects. Counting of PALS is inhibited when PUAS is counted over the monitored second.')
mscLpSdhPathPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM path is unavailable. The path becomes unavailable at the onset of 10 consecutive PSESs. The 10 PSESs are included in the unavailable time. Once unavailable, the path becomes available at the onset of 10 contiguous seconds with no PSES. The 10 seconds with no PSES are excluded from the unavailable time. For second intervals where a Path Unavailable Second (PUAS) is counted, counting of PCV, PES, PSES and PALS is inhibited.')
mscLpSdhPathPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathPathFailures.setDescription('This attribute indicates the total number of times that a path failure (LOP, P-AIS or Path Signal Label Mismatch failure) has been declared.')
mscLpSdhPathFarEndPathErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathErrorFreeSec.setDescription('This attribute indicates the number of seconds that the Sonet/Sdh Path component has been in an far-end error free state.')
mscLpSdhPathFarEndPathCodeViolations = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathCodeViolations.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathCodeViolations.setDescription('This attribute indicates the total number of Far-End Path Code Violations (FEPCVs) detected. Each FEPCV corresponds to a path FEBE. FEPCV counting is inhibited over second intervals where a Far-End Path Severely Errored Second (FEPSES) is counted. Counting of PCVs is also inhibited over second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted. The count wraps at its maximum value.')
mscLpSdhPathFarEndPathErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathErroredSec.setDescription('This attribute indicates the total number of Far-End Path Errored Seconds (FEPESs) that have been counted. A FEPES is declared for second intervals containing one or more FEPCVs or one or more path RDI (P-RDI) defects. Counting of FEPES is inhibited when FEPUAS is counted over the monitored second.')
mscLpSdhPathFarEndPathSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathSevErroredSec.setDescription('This attribute indicates the total number of Far-End Path Severely Errored Seconds (FEPSESs) that have been counted. A FEPSES is declared for second intervals containing more than x FEPCVs or one or more P-RDI defects. The value of x is 2400 for a 155 Mbits/ sec interface. Counting of FEPSESs is inhibited when FEPUAS is counted over the monitored second.')
mscLpSdhPathFarEndPathAisLopSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathAisLopSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathAisLopSec.setDescription('This attribute indicates the total number of Far-End Path AIS and LOP Seconds (FEPALSs). A FEPALS is declared for second intervals containing one or more P-RDI defects. Counting of FEPALS is inhibited when FEPUAS is counted over the monitored second.')
mscLpSdhPathFarEndPathUnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathUnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathUnavailSec.setDescription('This attribute indicates the total number of one second intervals for which the STS/STM far-end path is unavailable. The far-end path becomes unavailable at the onset of 10 consecutive FEPSESs. The 10 FEPSESs are included in the unavailable time. Once unavailable, the far-end path becomes available at the onset of 10 contiguous seconds with no FEPSES. The 10 seconds with no FEPSES are excluded from the unavailable time. For second intervals where a Far-End Path Unavailable Second (FEPUAS) is counted, counting of FEPCV, FEPES, FEPSES and FEPALS is inhibited.')
mscLpSdhPathFarEndPathFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 16, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathFailures.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathFarEndPathFailures.setDescription('This attribute indicates the total number of times that a STS/STM far-end path failure (P-RFI failure) has been declared.')
mscLpSdhPathCell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2))
mscLpSdhPathCellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 1), )
if mibBuilder.loadTexts: mscLpSdhPathCellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSdhPathCell components.')
mscLpSdhPathCellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathCellIndex"))
if mibBuilder.loadTexts: mscLpSdhPathCellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSdhPathCell component.')
mscLpSdhPathCellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSdhPathCell components. These components cannot be added nor deleted.')
mscLpSdhPathCellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSdhPathCellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellStorageType.setDescription('This variable represents the storage type value for the mscLpSdhPathCell tables.')
mscLpSdhPathCellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpSdhPathCellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellIndex.setDescription('This variable represents the index for the mscLpSdhPathCell tables.')
mscLpSdhPathCellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 10), )
if mibBuilder.loadTexts: mscLpSdhPathCellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpSdhPathCellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathCellIndex"))
if mibBuilder.loadTexts: mscLpSdhPathCellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellProvEntry.setDescription('An entry in the mscLpSdhPathCellProvTable.')
mscLpSdhPathCellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhPathCellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpSdhPathCellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhPathCellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpSdhPathCellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhPathCellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpSdhPathCellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 11), )
if mibBuilder.loadTexts: mscLpSdhPathCellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpSdhPathCellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathCellIndex"))
if mibBuilder.loadTexts: mscLpSdhPathCellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellOperEntry.setDescription('An entry in the mscLpSdhPathCellOperTable.')
mscLpSdhPathCellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpSdhPathCellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 12), )
if mibBuilder.loadTexts: mscLpSdhPathCellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpSdhPathCellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhPathCellIndex"))
if mibBuilder.loadTexts: mscLpSdhPathCellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellStatsEntry.setDescription('An entry in the mscLpSdhPathCellStatsTable.')
mscLpSdhPathCellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpSdhPathCellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpSdhPathCellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpSdhPathCellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpSdhPathCellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 2, 2, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhPathCellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhPathCellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpSdhTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3))
mscLpSdhTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 1), )
if mibBuilder.loadTexts: mscLpSdhTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpSdhTest components.')
mscLpSdhTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhTestIndex"))
if mibBuilder.loadTexts: mscLpSdhTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpSdhTest component.')
mscLpSdhTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpSdhTest components. These components cannot be added nor deleted.')
mscLpSdhTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpSdhTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestStorageType.setDescription('This variable represents the storage type value for the mscLpSdhTest tables.')
mscLpSdhTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpSdhTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestIndex.setDescription('This variable represents the index for the mscLpSdhTest tables.')
mscLpSdhTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 10), )
if mibBuilder.loadTexts: mscLpSdhTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpSdhTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhTestIndex"))
if mibBuilder.loadTexts: mscLpSdhTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestStateEntry.setDescription('An entry in the mscLpSdhTestStateTable.')
mscLpSdhTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpSdhTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpSdhTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpSdhTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11), )
if mibBuilder.loadTexts: mscLpSdhTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpSdhTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhTestIndex"))
if mibBuilder.loadTexts: mscLpSdhTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestSetupEntry.setDescription('An entry in the mscLpSdhTestSetupTable.')
mscLpSdhTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpSdhTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpSdhTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpSdhTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpSdhTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpSdhTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpSdhTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpSdhTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpSdhTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpSdhTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12), )
if mibBuilder.loadTexts: mscLpSdhTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpSdhTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpSdhTestIndex"))
if mibBuilder.loadTexts: mscLpSdhTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestResultsEntry.setDescription('An entry in the mscLpSdhTestResultsTable.')
mscLpSdhTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpSdhTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpSdhTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpSdhTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpSdhTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpSdhTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpSdhTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpSdhTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpSdhTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpSdhTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpSdhTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 15, 3, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpSdhTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpSdhTestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpJT2 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16))
mscLpJT2RowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 1), )
if mibBuilder.loadTexts: mscLpJT2RowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2RowStatusTable.setDescription('This entry controls the addition and deletion of mscLpJT2 components.')
mscLpJT2RowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2RowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2RowStatusEntry.setDescription('A single entry in the table represents a single mscLpJT2 component.')
mscLpJT2RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2RowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2RowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpJT2 components. These components can be added and deleted.')
mscLpJT2ComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2ComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpJT2StorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2StorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2StorageType.setDescription('This variable represents the storage type value for the mscLpJT2 tables.')
mscLpJT2Index = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1)))
if mibBuilder.loadTexts: mscLpJT2Index.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2Index.setDescription('This variable represents the index for the mscLpJT2 tables.')
mscLpJT2CidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 10), )
if mibBuilder.loadTexts: mscLpJT2CidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpJT2CidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2CidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CidDataEntry.setDescription('An entry in the mscLpJT2CidDataTable.')
mscLpJT2CustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2CustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpJT2ProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 11), )
if mibBuilder.loadTexts: mscLpJT2ProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ProvTable.setDescription('This group contains all of the JT2 specific provisioning data for a JT2 component.')
mscLpJT2ProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2ProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ProvEntry.setDescription('An entry in the mscLpJT2ProvTable.')
mscLpJT2ClockingSource = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("local", 0), ("line", 1), ("module", 2), ("otherPort", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2ClockingSource.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ClockingSource.setDescription("This attribute defines the source of the transmit clock for the JT2 line. When the clocking source is selected from local, the oscillator on the port generates the clocking for the line. When the clocking source is selected from line, the port synchronizes to the clock recovered from the incoming line signal. When the clocking source is selected from module, the port's clock synchronizes to the clock provided by the oscillator on the active CP. Note:- that when one port is set to local, the other port must also be set to local, and when one port is set to module, the other port must also be set to module. If one of the ports is set to line, the other port must be set to otherPort. Also, if a CP reference clock is available when the JT2 component is added, the clocking source defaults to module, whereas if a CP reference clock is not available when the component is added, the clocking source defaults to local.")
mscLpJT2LineLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 480))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2LineLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2LineLength.setDescription('This attribute defines the line length for equalization calculations for the JT2 line. The range is between 0 and 480 feet (1 metre = 3.28 feet).')
mscLpJT2ApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 11, 1, 3), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2ApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ApplicationFramerName.setDescription('This attribute defines the link to the software stack. It defines which application is running on top of the JT2 component.')
mscLpJT2IfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 12), )
if mibBuilder.loadTexts: mscLpJT2IfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2IfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpJT2IfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2IfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2IfEntryEntry.setDescription('An entry in the mscLpJT2IfEntryTable.')
mscLpJT2IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2IfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2IfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpJT2IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 12, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2IfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2IfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpJT2OperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 13), )
if mibBuilder.loadTexts: mscLpJT2OperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2OperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpJT2OperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2OperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2OperStatusEntry.setDescription('An entry in the mscLpJT2OperStatusTable.')
mscLpJT2SnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2SnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2SnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpJT2StateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14), )
if mibBuilder.loadTexts: mscLpJT2StateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2StateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpJT2StateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2StateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2StateEntry.setDescription('An entry in the mscLpJT2StateTable.')
mscLpJT2AdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2AdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2AdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpJT2OperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2OperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2OperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpJT2UsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2UsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2UsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpJT2AvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2AvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2AvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpJT2ProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2ProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpJT2ControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2ControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpJT2AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2AlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpJT2StandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2StandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2StandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpJT2UnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 14, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2UnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2UnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpJT2OperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15), )
if mibBuilder.loadTexts: mscLpJT2OperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2OperTable.setDescription('This group contains the JT2 specific operational data for a JT2 component in a digital hierarchy interface.')
mscLpJT2OperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2OperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2OperEntry.setDescription('An entry in the mscLpJT2OperTable.')
mscLpJT2LosAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2LosAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2LosAlarm.setDescription('This attribute displays whether a LOS (Loss of Signal) alarm state is entered. An LOS alarm state is entered when LOS defects have been observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. An LOS defect is declared at the JT2 line interface when the input data is zero for 20 - 32 clock cycles. If the LOS defects are intermittently occurring, the LOS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. An LOS failure alarm is cleared when the LOS defect is absent for a period of 10 seconds +/- 0.5 seconds. The JT2 port goes into an operationalState of disabled for the duration of the LOS alarm condition. While the port is in the LOS alarm state, the port also transmits the far-end RAI defect indicator on the out-going JT2 line.')
mscLpJT2LofAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2LofAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2LofAlarm.setDescription('This attribute indicates whether a LOF (Loss of Frame) alarm state is entered. A LOF alarm state is entered when LOF defects are observed and accumulated for 2.5 seconds +/- 0.5 seconds or more. A LOF defect occurs when seven or more consecutive incorrect frame alignment patterns (4 multiframes) are received. If the LOF defects are intermittently occurring, the LOF defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. The LOF alarm is cleared when framing has been achieved for 10 seconds +/- 0.5 seconds. The port goes into an operationalState of disabled for the duration of the LOF alarm condition. While the port is in the LOF alarm state, the node also transmits the far-end RAI defect indicator on the out-going JT2 line.')
mscLpJT2RxAisPhysicalAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2RxAisPhysicalAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2RxAisPhysicalAlarm.setDescription('This attribute indicates whether a Physical AIS alarm state is entered. A Physical AIS alarm state is entered when a Physical AIS defect is observed and accumulated for a period of 2.5 seconds +/- 0.5 seconds. A Physical AIS defect is declared when the incoming signal has two or less zeros in a sequence of 3,156 bits (0.5 ms). If the physical AIS defects are intermittently occurring, the physical AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. A Physical AIS alarm is cleared when the Physical AIS defect is absent for a period of 10 seconds +/- 0.5 seconds. The port goes into an operationalState of disabled until the AIS alarm condition is cleared. While the port is in the Physical AIS alarm state, the node also transmits the far-end RAI defect indicator on the out-going JT2 line.')
mscLpJT2RxAisPayloadAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2RxAisPayloadAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2RxAisPayloadAlarm.setDescription('This attribute indicates whether a Payload AIS alarm state is entered. A Payload AIS alarm state is entered when a Payload AIS defect persists for a period of 2.5 seconds +/- 0.5 seconds. A Payload AIS defect is declared when the incoming signal of the 6312 kbit/s frame payload (TS1 - TS96) has two or less zeros in a sequence of 3,072 bits (0.5 ms). If the payload AIS defects are intermittently occurring, the payload AIS defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle. A Payload AIS failure alarm is cleared when the Payload AIS defect is absent for a period of 10 seconds +/- 0.5 seconds. The port goes into an operationalState of disabled until the AIS alarm condition is cleared. While the port is in the Payload AIS alarm state, the node also transmits the far-end RAI defect indicator on the out-going JT2 line.')
mscLpJT2RxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2RxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2RxRaiAlarm.setDescription('This attribute indicates whether a Received RAI alarm state is entered. A received RAI alarm state is entered when the RAI signal is detected on the incoming JT2 Line (when 16 or more consecutive RAI patterns of 1111111100000000 are received on the 4 kbit/s data channel (m-bits) within the framing bits of the JT2 frame). The JT2 port goes into an operationalState of Disabled until the RAI alarm condition is cleared. The RAI alarm is cleared when four or more consecutive non-RAI patterns (anything other than 1111111100000000) are received.')
mscLpJT2TxAisPhysicalAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TxAisPhysicalAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TxAisPhysicalAlarm.setDescription('This attribute indicates whether an AIS (Alarm Indication Signal) alarm is being transmitted on the outgoing JT2 line. Currently the JT2 port only transmits a Physical AIS (no Payload AIS) on the outgoing JT2 line. Since there is no Idle signal defined for JT2, the AIS signal is transmitted when the JT2 port is in the operationalState of locked. The AIS signal may also be transmitted for diagnostic testing.')
mscLpJT2TxRaiAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TxRaiAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TxRaiAlarm.setDescription('This attribute indicates whether an RAI defect indication pattern is being sent on the out-going JT2 line. The RAI alarm pattern is transmitted in the 4 kbit/s data channel (m-bits) when the port detects a LOS, AIS or LOF alarm condition.')
mscLpJT2StatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16), )
if mibBuilder.loadTexts: mscLpJT2StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2StatsTable.setDescription('This group contains the statistical data for a JT2 component in a digital hierarchy interface.')
mscLpJT2StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2StatsEntry.setDescription('An entry in the mscLpJT2StatsTable.')
mscLpJT2RunningTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2RunningTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2RunningTime.setDescription("This attribute indicates the number of seconds since the JT2 component was activated and placed in an unlocked state or used for operational testing. All the other error counts that follow as well as each JT2 subcomponent's error counts can be updated when this count is active.")
mscLpJT2ErrorFreeSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2ErrorFreeSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ErrorFreeSec.setDescription('This attribute indicates the number of seconds that the JT2 port has been in an error free state.')
mscLpJT2ErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2ErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2ErroredSec.setDescription('This attribute indicates the total number of errored seconds for the JT2 port. An errored second is declared when a second with one or more Code Violation Error events, or one or more LOF or LOS defects occur. A code violation error may be a cyclic redundancy check (CRC) error or a bipolar violation (BPV) error.')
mscLpJT2SevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2SevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2SevErroredSec.setDescription('This attribute indicates the total number of severely errored seconds for the JT2 port. A severely errored second occurs when a second with 255 or more Code Violation Error events or one or more LOF or LOS defects occur.')
mscLpJT2SevErroredFrmSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2SevErroredFrmSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2SevErroredFrmSec.setDescription('This attribute indicates the total number of severely errored framing seconds for the JT2 port. A severely errored framing second occurs when a second with one or more Framing Errors occur.')
mscLpJT2UnavailSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2UnavailSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2UnavailSec.setDescription('This attribute indicates the total number of seconds that the interface has been in an unavailable state. An unavailable state occurs at the onset of 10 consecutive Severely Errored Seconds. When the unavailable state is entered, the 10 Severely Errored Seconds are immediately transfered to the count of unavailableSeconds by incrementing the count of unavailSec by 10 and decrementing the count of sevErroredSec by 10. Whilst in the unavailable state, an unavailableSecond is counted for each SES or SEFS that occurs, and the count of SES and SEFS are both inhibited. The unavailable state is cleared at the onset of 10 consecutive seconds which are not Severely Errored Seconds.')
mscLpJT2BpvErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2BpvErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2BpvErrors.setDescription('This attribute indicates the total count of bipolar violations (BPV). A bipolar violation is an error in the alternate mark inversion pattern (AMI) on the line. The value of this attribute will wrap to zero when it reaches its maximum value.')
mscLpJT2CrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CrcErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CrcErrors.setDescription('This attribute indicates the total number of cyclic redundancy check (CRC-5) errors detected on the incoming JT2 line. The value of this attribute will wrap to 0 when its maximum value is reached.')
mscLpJT2FrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2FrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2FrameErrors.setDescription('This attribute indicates the total number of Framing Errors that have occured on the JT2 port. A Framing Error is an error in the framing bits. The value of this attribute will wrap to 0 when its maximum value is reached.')
mscLpJT2LosStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2LosStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2LosStateChanges.setDescription('This attribute indicates the total number of times that the incoming signal on the JT2 line has been lost. The value of this attribute will wrap to 0 when its maximum value is reached.')
mscLpJT2AdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 17), )
if mibBuilder.loadTexts: mscLpJT2AdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2AdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpJT2AdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"))
if mibBuilder.loadTexts: mscLpJT2AdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2AdminInfoEntry.setDescription('An entry in the mscLpJT2AdminInfoTable.')
mscLpJT2Vendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 17, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2Vendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2Vendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpJT2CommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 17, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2CommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CommentText.setDescription('Any miscellaneous text about the facility.')
mscLpJT2Test = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2))
mscLpJT2TestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 1), )
if mibBuilder.loadTexts: mscLpJT2TestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpJT2Test components.')
mscLpJT2TestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2TestIndex"))
if mibBuilder.loadTexts: mscLpJT2TestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpJT2Test component.')
mscLpJT2TestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpJT2Test components. These components cannot be added nor deleted.')
mscLpJT2TestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpJT2TestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestStorageType.setDescription('This variable represents the storage type value for the mscLpJT2Test tables.')
mscLpJT2TestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpJT2TestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestIndex.setDescription('This variable represents the index for the mscLpJT2Test tables.')
mscLpJT2TestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 10), )
if mibBuilder.loadTexts: mscLpJT2TestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpJT2TestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2TestIndex"))
if mibBuilder.loadTexts: mscLpJT2TestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestStateEntry.setDescription('An entry in the mscLpJT2TestStateTable.')
mscLpJT2TestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpJT2TestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpJT2TestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpJT2TestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11), )
if mibBuilder.loadTexts: mscLpJT2TestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpJT2TestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2TestIndex"))
if mibBuilder.loadTexts: mscLpJT2TestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestSetupEntry.setDescription('An entry in the mscLpJT2TestSetupTable.')
mscLpJT2TestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpJT2TestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpJT2TestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpJT2TestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpJT2TestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpJT2TestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpJT2TestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpJT2TestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2TestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpJT2TestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12), )
if mibBuilder.loadTexts: mscLpJT2TestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpJT2TestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2TestIndex"))
if mibBuilder.loadTexts: mscLpJT2TestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestResultsEntry.setDescription('An entry in the mscLpJT2TestResultsTable.')
mscLpJT2TestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpJT2TestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpJT2TestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpJT2TestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpJT2TestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpJT2TestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpJT2TestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpJT2TestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpJT2TestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpJT2TestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpJT2TestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2TestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2TestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpJT2Cell = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3))
mscLpJT2CellRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 1), )
if mibBuilder.loadTexts: mscLpJT2CellRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpJT2Cell components.')
mscLpJT2CellRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2CellIndex"))
if mibBuilder.loadTexts: mscLpJT2CellRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellRowStatusEntry.setDescription('A single entry in the table represents a single mscLpJT2Cell component.')
mscLpJT2CellRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpJT2Cell components. These components cannot be added nor deleted.')
mscLpJT2CellComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpJT2CellStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellStorageType.setDescription('This variable represents the storage type value for the mscLpJT2Cell tables.')
mscLpJT2CellIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpJT2CellIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellIndex.setDescription('This variable represents the index for the mscLpJT2Cell tables.')
mscLpJT2CellProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 10), )
if mibBuilder.loadTexts: mscLpJT2CellProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellProvTable.setDescription('This group contains the provisioning attributes for the AtmCell component.')
mscLpJT2CellProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2CellIndex"))
if mibBuilder.loadTexts: mscLpJT2CellProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellProvEntry.setDescription('An entry in the mscLpJT2CellProvTable.')
mscLpJT2CellAlarmActDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2CellAlarmActDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellAlarmActDelay.setDescription('This attribute defines the time during which a Loss of Cell Delineation (LCD) defect should be observed before declaring an LCD alarm (alarm 70115501). The time is specified in milliseconds.')
mscLpJT2CellScrambleCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2CellScrambleCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellScrambleCellPayload.setDescription('Cell scrambling, as defined by ITU-T Recommendation I.432., can provide a solution to the problem of transmission equipment which is sensitive to certain bit patterns in the ATM cell payload. This attribute controls whether or not the cell payload is scrambled. It defaults to off for DS1 interfaces, and on for all other interfaces. Note that this setting must be the same at both ends of the link.')
mscLpJT2CellCorrectSingleBitHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpJT2CellCorrectSingleBitHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellCorrectSingleBitHeaderErrors.setDescription('This attribute specifies whether the port corrects single bit errors detected in the headers of received cells. If single bit errors are corrected, the affected cells are passed up to the ATM layer according to normal operation. If single bit errors are not corrected, these errored cells are discarded by the physical layer. Note that cells containing multiple bit errors in their headers are always discarded. Single bit HEC error correction must remain off for the following card types: 3pDS1Atm, 8pDS1Atm, 3pE1Atm, 8pE1Atm, 2pJ6MAtm, 3pDS3Atm, and 3pE3Atm.')
mscLpJT2CellOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 11), )
if mibBuilder.loadTexts: mscLpJT2CellOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellOperTable.setDescription('This group contains the common operational attributes for the AtmCell component.')
mscLpJT2CellOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2CellIndex"))
if mibBuilder.loadTexts: mscLpJT2CellOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellOperEntry.setDescription('An entry in the mscLpJT2CellOperTable.')
mscLpJT2CellLcdAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellLcdAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellLcdAlarm.setDescription('This attribute displays whether the Loss of Cell Delineation (LCD) failure alarm state has been entered. This state is entered when LCD defects have been observed and accumulated for a period of time specified through the alarmActDelay attribute. In ATM cell direct mapping mode, an LCD defect occurs when Out of Cell Delineation (OCD) anomaly persists for x milliseconds, and disappears when the Out of Cell Delineation (OCD) is absent for x msec. An OCD anomaly occurs when 7 consecutive incorrect HECs have been detected. An OCD anomaly terminates when 6 consecutive correct HECs have been detected. For an AtmCell component located under a DS3 or E3 component with mapping = PLCP, the LCD defect is directly derived from the PLCP LOF defect. If LCD defects are intermittently occurring, the LCD defect accumulator is decremented at a rate of 1/10 of the incrementing rate (alarm integration ratio of 1/10), with all measurements based on a 200 ms polling cycle The component under which is located the AtmCell component goes into an operational state of disabled until the LCD alarm condition is cleared. The condition is cleared after the LCD defect has not been reported for a period of 10 seconds +/- 0.5 seconds. The lcdAlarm attribute is always set to off when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpJT2CellStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 12), )
if mibBuilder.loadTexts: mscLpJT2CellStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellStatsTable.setDescription('This group contains the Statistics attribute for the AtmCell component. Each attribute type is a non-negative integer which monotonically increases until it reaches a maximum value, at which point it wraps around and starts increasing again from zero.')
mscLpJT2CellStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2Index"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpJT2CellIndex"))
if mibBuilder.loadTexts: mscLpJT2CellStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellStatsEntry.setDescription('An entry in the mscLpJT2CellStatsTable.')
mscLpJT2CellUncorrectableHecErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellUncorrectableHecErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellUncorrectableHecErrors.setDescription('This attribute indicates the number of uncorrectable ATM cell header errors that have been detected. Counting of uncorrectableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected.')
mscLpJT2CellSevErroredSec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 12, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellSevErroredSec.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellSevErroredSec.setDescription('This attribute indicates the total number of ATM Cell Severely Errored Seconds (SESs) that have been counted. In direct mapping mode, an ATM Cell SES is declared for second intervals containing one or more Out of Cell Delineation (OCD) defects. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected. In PLCP mapping mode, an ATM Cell SES is declared for second intervals containing one or more PLCP LOF defects. Counting of uncorrectableHeaderErrors (ucErr) and correctableHeaderErrors (cErr) is inhibited when the OCD defect is present.')
mscLpJT2CellReceiveCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 12, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellReceiveCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellReceiveCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells received on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpJT2CellTransmitCellUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 12, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellTransmitCellUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellTransmitCellUtilization.setDescription('This attribute is the ratio of the number of valid, assigned cells transmitted on the link to the nominal link capacity. The utilization is calculated over a period of one minute. This attribute is always set to 0 when the parent of the AtmCell component has been locked and left offline. This can also happen when the Path or Channel component has been suspended since its parent has been locked.')
mscLpJT2CellCorrectableHeaderErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 16, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpJT2CellCorrectableHeaderErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpJT2CellCorrectableHeaderErrors.setDescription('This attribute indicates the number of correctable ATM cell header errors that have been detected and corrected. Counting of correctableHeaderErrors is inhibited when an Out of Cell Delineation (OCD) defect is present. An OCD defect occurs when seven consecutive incorrect HECs have been detected. An OCD defect terminates when six consecutive correct HECs have been detected')
mscLpHssi = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17))
mscLpHssiRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 1), )
if mibBuilder.loadTexts: mscLpHssiRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpHssi components.')
mscLpHssiRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiRowStatusEntry.setDescription('A single entry in the table represents a single mscLpHssi component.')
mscLpHssiRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpHssi components. These components can be added and deleted.')
mscLpHssiComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpHssiStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiStorageType.setDescription('This variable represents the storage type value for the mscLpHssi tables.')
mscLpHssiIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscLpHssiIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiIndex.setDescription('This variable represents the index for the mscLpHssi tables.')
mscLpHssiProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 10), )
if mibBuilder.loadTexts: mscLpHssiProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiProvTable.setDescription('This group contains the specific provisioning data for a Hssi component.')
mscLpHssiProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiProvEntry.setDescription('An entry in the mscLpHssiProvTable.')
mscLpHssiLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128))).clone('dce')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiLinkMode.setDescription('This attribute defines the intended gender of the HSSI port. The actual gender of the port is determined by the hardware setup. In dte mode, the ta line signal is driven as specified by the attribute readyLineState when the HSSI port passes its diagnostics. The ta line signal is then driven as specified by the attribute dataTransferLineState when the application is ready to transfer data. On the other hand, the input line signal ca is compared against those specified in the attributes readyLineState and dataTransferLineState. The application will be notified when the specified input line states are observed. In dce mode, the Hssi component behaves similarly as when it is in dte mode. However, it will be driving the dce line signal (ca) and monitoring the dte line signal (ta) as specified by the attributes readyLineState and dataTransferLineState.')
mscLpHssiReadyLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 10, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiReadyLineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiReadyLineState.setDescription('This attribute specifies the line signal originating from the HSSI interface that will always be turned on, provided the HSSI interface passes it diagnostics. This set of signal is generally required for maintaining the connection. Note that both dte and dce signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the operational attribute actualLinkMode. See also linkMode. Description of bits: ca(0) ta(1)')
mscLpHssiDataTransferLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiDataTransferLineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiDataTransferLineState.setDescription('This attribute specifies the line signals required to indicate that the external equipment is in a good state (that is, data transfer can proceed). Note that both dte and dce signals are specified in this attribute. The appropriate set of specified signals will be turned on or checked according to the operational attribute actualLinkMode. The value of this attribute must be a superset of that of the readyLineState attribute. See also linkMode. Description of bits: ca(0) ta(1)')
mscLpHssiLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000000, 50000000)).clone(45000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiLineSpeed.setDescription('This attribute defines the speed of the line for source clocking. This attribute is ignored if the interface is not providing a clock. Note that the actual clock rate are available in the operational attributes actualTxLineSpeed and actualRxLineSpeed.')
mscLpHssiApplicationFramerName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 10, 1, 7), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiApplicationFramerName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiApplicationFramerName.setDescription('This attribute contains the component name of a Framer which is associated with the Hssi component.')
mscLpHssiCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 11), )
if mibBuilder.loadTexts: mscLpHssiCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscLpHssiCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiCidDataEntry.setDescription('An entry in the mscLpHssiCidDataTable.')
mscLpHssiCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscLpHssiAdminInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 12), )
if mibBuilder.loadTexts: mscLpHssiAdminInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiAdminInfoTable.setDescription('This group contains the attributes pertaining to the vendor of the equipment.')
mscLpHssiAdminInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiAdminInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiAdminInfoEntry.setDescription('An entry in the mscLpHssiAdminInfoTable.')
mscLpHssiVendor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 12, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiVendor.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiVendor.setDescription('This is the name of the vendor supplying the facility.')
mscLpHssiCommentText = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 12, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiCommentText.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiCommentText.setDescription('Any miscellaneous text about the facility.')
mscLpHssiIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 13), )
if mibBuilder.loadTexts: mscLpHssiIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscLpHssiIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiIfEntryEntry.setDescription('An entry in the mscLpHssiIfEntryTable.')
mscLpHssiIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscLpHssiIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 13, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscLpHssiOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 14), )
if mibBuilder.loadTexts: mscLpHssiOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscLpHssiOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiOperStatusEntry.setDescription('An entry in the mscLpHssiOperStatusTable.')
mscLpHssiSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscLpHssiStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15), )
if mibBuilder.loadTexts: mscLpHssiStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscLpHssiStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiStateEntry.setDescription('An entry in the mscLpHssiStateTable.')
mscLpHssiAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpHssiOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpHssiUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscLpHssiAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscLpHssiProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscLpHssiControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscLpHssiAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscLpHssiStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscLpHssiUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 15, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscLpHssiOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 16), )
if mibBuilder.loadTexts: mscLpHssiOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiOperTable.setDescription('This group contains all specific operational data for a Hssi component.')
mscLpHssiOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"))
if mibBuilder.loadTexts: mscLpHssiOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiOperEntry.setDescription('An entry in the mscLpHssiOperTable.')
mscLpHssiActualLinkMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 128))).clone(namedValues=NamedValues(("dte", 0), ("dce", 128)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiActualLinkMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiActualLinkMode.setDescription('This attribute contains the actual link mode defined by the hardware. Note that the hardware overrides the provisionable data. The port behaves as a dce or dte according to the actualLinkMode.')
mscLpHssiLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 16, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiLineState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiLineState.setDescription('This attribute contains the state of the interface signals. Description of bits: ca(0) ta(1) tm(2) la(3) lb(4)')
mscLpHssiActualTxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 16, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiActualTxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiActualTxLineSpeed.setDescription('This attribute is the measured speed of the transmit clock. Note the reported transmit speed is in an error of +/- 10000 bit/s')
mscLpHssiActualRxLineSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 16, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiActualRxLineSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiActualRxLineSpeed.setDescription('This attribute is the measured speed of the receive clock. Note the reported receive speed is in an error of +/- 10000 bit/s')
mscLpHssiDataXferStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 16, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiDataXferStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiDataXferStateChanges.setDescription('This attribute contains the number of times that the line has entered or exited the data transfer state.')
mscLpHssiTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2))
mscLpHssiTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 1), )
if mibBuilder.loadTexts: mscLpHssiTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpHssiTest components.')
mscLpHssiTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiTestIndex"))
if mibBuilder.loadTexts: mscLpHssiTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestRowStatusEntry.setDescription('A single entry in the table represents a single mscLpHssiTest component.')
mscLpHssiTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpHssiTest components. These components cannot be added nor deleted.')
mscLpHssiTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpHssiTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestStorageType.setDescription('This variable represents the storage type value for the mscLpHssiTest tables.')
mscLpHssiTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpHssiTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestIndex.setDescription('This variable represents the index for the mscLpHssiTest tables.')
mscLpHssiTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 10), )
if mibBuilder.loadTexts: mscLpHssiTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscLpHssiTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiTestIndex"))
if mibBuilder.loadTexts: mscLpHssiTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestStateEntry.setDescription('An entry in the mscLpHssiTestStateTable.')
mscLpHssiTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscLpHssiTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscLpHssiTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscLpHssiTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11), )
if mibBuilder.loadTexts: mscLpHssiTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestSetupTable.setDescription('This group contains all of the operational data for a Test component.')
mscLpHssiTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiTestIndex"))
if mibBuilder.loadTexts: mscLpHssiTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestSetupEntry.setDescription('An entry in the mscLpHssiTestSetupTable.')
mscLpHssiTestPurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestPurpose.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestPurpose.setDescription('This attribute records the purpose of the test so that the test results can be associated and properly analyzed.')
mscLpHssiTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("card", 0), ("manual", 1), ("localLoop", 2), ("remoteLoop", 3), ("externalLoop", 4), ("payloadLoop", 5), ("remoteLoopThisTrib", 6), ("v54RemoteLoop", 7), ("pn127RemoteLoop", 8))).clone('card')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestType.setDescription('This attribute is the type of test to be run. The available test types include the following: card test sets up an internal loop on the board and runs a bit error rate test. manual test assumes the line is looped back externally and a bit error rate test is performed. localLoop test loops back the local modem and performs a bit error rate test. remoteLoop test loops back the remote modem (or CSU) and performs a bit error rate test. externalLoop test loops back the line to the far end. payloadLoop test only loops back the payload data received from the incoming line. remoteLoopThisTrib loops this particular tributary back at the far end, using services provided by the parent. v54RemoteLoop initiates a V.54 Remote Loopback test. pn127RemoteLoop initiates a PN127 Remote Loopback test. Note that not all test types are not supported by all function processors.')
mscLpHssiTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestFrmSize.setDescription('This attribute defines the size of the test data frames in number of bytes.')
mscLpHssiTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestFrmPatternType.setDescription('This attribute defines the type of data pattern generation to use. The following lists the available pattern types: ccitt32kBitPattern is a pseudo-random sequence of 32 kbit. ccitt8MBitPattern is a pseudo-random sequence of 8Mbit. customizedPattern is the pattern defined in the customizedPattern attribute.')
mscLpHssiTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 5), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestCustomizedPattern.setDescription('This attribute allows a customized 32 bit pattern to be defined for use in the test data frames. This attribute is used when the attribute frmPatternType is set to CustomizedPattern. Note that a 55 hex pattern is an alternating 1 and 0 pattern.')
mscLpHssiTestDataStartDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1814400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestDataStartDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestDataStartDelay.setDescription('This attribute specifies the time delay (in seconds) between when the test expects the loop to have been set up, to when the test data actually starts to be transmitted. This attribute is to accommodate some non-standard equipment that requires extra time for setting up a requested loop. This attribute is ignored when the test type is set to externalLoop.')
mscLpHssiTestDisplayInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestDisplayInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestDisplayInterval.setDescription('This attribute defines the interval (in minutes) between which interim test results are to be displayed. Results are displayed at the operator console at which the test was started. When the test type is set to externalLoop, this attribute is ignored. There will be no display of results if displayInterval is set to 0. This attribute can be changed anytime.')
mscLpHssiTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpHssiTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestDuration.setDescription('This attribute is the duration (in minutes) that test data will be transmitted. In the case of an externalLoop, this is the time that the loop is in effect. Note that dataStartDelay does not apply to the externalLoop.')
mscLpHssiTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12), )
if mibBuilder.loadTexts: mscLpHssiTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestResultsTable.setDescription('This group contains all the statistics related attributes of the Test component.')
mscLpHssiTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpHssiTestIndex"))
if mibBuilder.loadTexts: mscLpHssiTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestResultsEntry.setDescription('An entry in the mscLpHssiTestResultsTable.')
mscLpHssiTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestElapsedTime.setDescription('This attribute is the number of minutes elapsed since the test started for an externalLoop test. For a data test, this is the time since test data was first transmitted.')
mscLpHssiTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestTimeRemaining.setDescription('This attribute is the number of minutes remaining before the test is to be stopped according to the duration attribute.')
mscLpHssiTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("unknown", 2), ("neverStarted", 3), ("testRunning", 4), ("hardwareReconfigured", 5), ("loopCodeSyncFailed", 6), ("patternSyncFailed", 7), ("patternSyncLost", 8))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestCauseOfTermination.setDescription("This attribute indicates either the status of the test or the cause of the test's termination: neverStarted indicates that the test has not yet been started. testRunning indicates that the test has been started. stoppedByOperator indicates that the operator issued a stop command on a test that was running. testTimeExpired indicates that the test ran for the time specified by the test's duration. loopCodeSyncFailed indicates that the local end failed to synchronize to the loopCode pattern. The local end transmits the loopCode pattern to cause the remote end to apply a loopback, after which the local end should receive the loopCode pattern. The exact pattern used to request loopCode depends on the test type. This failure indicates a high rate of transmission errors, or that the remote end has failed to apply the loopback. patternSyncFailed indicates that the local end failed to synchronize to the frmPatternType test pattern, that should have been looped back at the remote end. This failure indicates a high rate of transmission errors or the absence of a loopback. patternSyncLost indicates that the local end gained and then lost synchronization to the returned frmPatternType test pattern. This failure indicates a sudden increase in transmission errors, frame slippage, or the removal of an existing loopback. unknown is set when a reason to terminate other than those listed here is encountered. Note: Only MSA cards support recognition of the failures loopCodeSyncFailed, patternSyncFailed and patternSyncLost. Other cards will not terminate the test under the conditions described by these values.")
mscLpHssiTestBitsTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestBitsTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestBitsTx.setDescription('This attribute is the total number of bits sent during the test period. As long as the line speed of the hardware interface is less than 70 Mbit/s, this counter is not expected to reach the maximum value.')
mscLpHssiTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestBytesTx.setDescription('This attribute is the total number of bytes sent during the test period. This counter is not expected to reach its maximum value.')
mscLpHssiTestFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 6), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestFrmTx.setDescription('This attribute is the total number of frames sent during the test period. This counter is not expected to reach its maximum value.')
mscLpHssiTestBitsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 7), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestBitsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestBitsRx.setDescription('This attribute is the total number of bits received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach the maximum value.')
mscLpHssiTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestBytesRx.setDescription('This attribute is the total number of bytes received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpHssiTestFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestFrmRx.setDescription('This attribute is the total number of frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpHssiTestErroredFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestErroredFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestErroredFrmRx.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the total number of errored frames received during the test period. This counter is not expected to reach its maximum value. The counter will wrap around to 0 if it does reach its maximum value.')
mscLpHssiTestBitErrorRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 17, 2, 12, 1, 11), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpHssiTestBitErrorRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpHssiTestBitErrorRate.setDescription('This attribute is not displayed for ATM cards because the physical layer drops all errored frames at the controller interface. For all other card types, this attribute is the calculated bit error rate on the link. Test data are generated and sent in frames of a preset size (frameSize). The Test component will try to estimate the number of bit errors in any errored frame which is identifiable. The statistics will be updated accordingly. A lost frame (may be due to an error on the flag sequence) will be discarded for the bit error rate calculation. The result is presented in the form of xEsyy, where x is the mantissa, syy is the exponent, for example 0E+00, 2E-09. Note that the bitErrorRate is an estimate only. For more reliable test results, the test should be done over a long period. Multiple tests would also improve the confidence level of the test results.')
mscLpEng = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23))
mscLpEngRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 1), )
if mibBuilder.loadTexts: mscLpEngRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEng components.')
mscLpEngRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"))
if mibBuilder.loadTexts: mscLpEngRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEng component.')
mscLpEngRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEng components. These components cannot be added nor deleted.')
mscLpEngComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngStorageType.setDescription('This variable represents the storage type value for the mscLpEng tables.')
mscLpEngIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngIndex.setDescription('This variable represents the index for the mscLpEng tables.')
mscLpEngDs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2))
mscLpEngDsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 1), )
if mibBuilder.loadTexts: mscLpEngDsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngDs components.')
mscLpEngDsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngDsIndex"))
if mibBuilder.loadTexts: mscLpEngDsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngDs component.')
mscLpEngDsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngDsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngDs components. These components can be added and deleted.')
mscLpEngDsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngDsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngDsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngDsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsStorageType.setDescription('This variable represents the storage type value for the mscLpEngDs tables.')
mscLpEngDsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("accounting", 0), ("alarm", 1), ("log", 2), ("debug", 3), ("scn", 4), ("trap", 5), ("stats", 6))))
if mibBuilder.loadTexts: mscLpEngDsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsIndex.setDescription('This variable represents the index for the mscLpEngDs tables.')
mscLpEngDsOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 10), )
if mibBuilder.loadTexts: mscLpEngDsOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOperTable.setDescription('This group contains operational attributes for the DataStream components under Lp Engineering.')
mscLpEngDsOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngDsIndex"))
if mibBuilder.loadTexts: mscLpEngDsOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOperEntry.setDescription('An entry in the mscLpEngDsOperTable.')
mscLpEngDsAgentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngDsAgentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsAgentQueueSize.setDescription("This attribute indicates the maximum size of the DCS Agent queue size maximum for a DCS data stream on the LP. It is the maximum size to which the Agent's currentQueueSize can grow. When the queue is full and more data is offered to the Agent, it will be discarded. The following are the system defaults (in number of records): - alarm: 100 - accounting: 10000 - debug: 0 - log: 50 - scn: 200 - trap: 50 - stats: 0 To override the system defaults, see Lp Eng Ds Ov's agentQueueSize attribute.")
mscLpEngDsOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2))
mscLpEngDsOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 1), )
if mibBuilder.loadTexts: mscLpEngDsOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvRowStatusTable.setDescription('This entry controls the addition and deletion of mscLpEngDsOv components.')
mscLpEngDsOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngDsIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngDsOvIndex"))
if mibBuilder.loadTexts: mscLpEngDsOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvRowStatusEntry.setDescription('A single entry in the table represents a single mscLpEngDsOv component.')
mscLpEngDsOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngDsOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscLpEngDsOv components. These components can be added and deleted.')
mscLpEngDsOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngDsOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscLpEngDsOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscLpEngDsOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvStorageType.setDescription('This variable represents the storage type value for the mscLpEngDsOv tables.')
mscLpEngDsOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscLpEngDsOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvIndex.setDescription('This variable represents the index for the mscLpEngDsOv tables.')
mscLpEngDsOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 10), )
if mibBuilder.loadTexts: mscLpEngDsOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvProvTable.setDescription('This group contains provisionable attributes for the DataStream Ov components under Lp Engineering. DESCRIPTION')
mscLpEngDsOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngDsIndex"), (0, "Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", "mscLpEngDsOvIndex"))
if mibBuilder.loadTexts: mscLpEngDsOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvProvEntry.setDescription('An entry in the mscLpEngDsOvProvTable.')
mscLpEngDsOvAgentQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 12, 23, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscLpEngDsOvAgentQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscLpEngDsOvAgentQueueSize.setDescription("This attribute specifies the maximum size of the DCS Agent's queue for this data stream on this LP. For more details on the defaults and other information, refer to the parent component's agentQueueSize attribute. The size should be set to 0 if absolutely no data is to be accepted from applications. There are threshold alarms based on the value of the Agent's currentQueueSize attribute (a Set when the queue becomes 75% full and a Clear after dropping back to 50% full). To properly determine what to set this to, consult the 'Magellan Passport Engineering Notes and Guidelines'.")
logicalProcessorGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 1))
logicalProcessorGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 1, 1))
logicalProcessorGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 1, 1, 3))
logicalProcessorGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 1, 1, 3, 2))
logicalProcessorCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 3))
logicalProcessorCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 3, 1))
logicalProcessorCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 3, 1, 3))
logicalProcessorCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 11, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpDS3DS1ChanTestFrmRx=mscLpDS3DS1ChanTestFrmRx, mscLpDS3DS1ChanCellRowStatusTable=mscLpDS3DS1ChanCellRowStatusTable, mscLpDS3PathSevErroredSec=mscLpDS3PathSevErroredSec, mscLpDS3CBitFarEndSevErroredSec=mscLpDS3CBitFarEndSevErroredSec, mscLpDS1ChanProvTable=mscLpDS1ChanProvTable, mscLpX21ProvTable=mscLpX21ProvTable, mscLpX21IfEntryEntry=mscLpX21IfEntryEntry, mscLpHssiTestResultsTable=mscLpHssiTestResultsTable, mscLpDS3DS1ChanCellLcdAlarm=mscLpDS3DS1ChanCellLcdAlarm, mscLpSonetAdminState=mscLpSonetAdminState, mscLpSdhTestCauseOfTermination=mscLpSdhTestCauseOfTermination, mscLpSonetPathFarEndPathAisLopSec=mscLpSonetPathFarEndPathAisLopSec, mscLpE1ChanSnmpOperStatus=mscLpE1ChanSnmpOperStatus, mscLpDS3CidDataEntry=mscLpDS3CidDataEntry, mscLpDS3DS1ChanCellStatsTable=mscLpDS3DS1ChanCellStatsTable, mscLpDS1TestElapsedTime=mscLpDS1TestElapsedTime, mscLpDS3DS1TestFrmPatternType=mscLpDS3DS1TestFrmPatternType, mscLpE1RxAisAlarm=mscLpE1RxAisAlarm, mscLpE1TestUsageState=mscLpE1TestUsageState, mscLpSonetControlStatus=mscLpSonetControlStatus, mscLpE1ChanTestStorageType=mscLpE1ChanTestStorageType, mscLpSonetPathLopAlarm=mscLpSonetPathLopAlarm, mscLpLocalMsgBlockUsageMax=mscLpLocalMsgBlockUsageMax, mscLpDS3TestResultsTable=mscLpDS3TestResultsTable, mscLpX21TestUsageState=mscLpX21TestUsageState, mscLpCidDataEntry=mscLpCidDataEntry, mscLpDS1ChanTestElapsedTime=mscLpDS1ChanTestElapsedTime, mscLpHssiTestOperationalState=mscLpHssiTestOperationalState, mscLpE1ChanCellOperTable=mscLpE1ChanCellOperTable, mscLpDS3PlcpFarEndUnavailableSec=mscLpDS3PlcpFarEndUnavailableSec, mscLpE1ChanOperEntry=mscLpE1ChanOperEntry, mscLpSonetTestDisplayInterval=mscLpSonetTestDisplayInterval, mscLpV35TestBytesRx=mscLpV35TestBytesRx, mscLpSonetProvTable=mscLpSonetProvTable, mscLpE3TestResultsTable=mscLpE3TestResultsTable, mscLpJT2TxRaiAlarm=mscLpJT2TxRaiAlarm, mscLpDS1TestDuration=mscLpDS1TestDuration, mscLpX21ControlStatus=mscLpX21ControlStatus, mscLpSonetIfEntryTable=mscLpSonetIfEntryTable, mscLpE3StateEntry=mscLpE3StateEntry, mscLpSdhStateEntry=mscLpSdhStateEntry, mscLpDS3DS1ChanCellOperEntry=mscLpDS3DS1ChanCellOperEntry, mscLpDS3TestBitsRx=mscLpDS3TestBitsRx, mscLpE3CellStatsTable=mscLpE3CellStatsTable, mscLpDS1TestIndex=mscLpDS1TestIndex, mscLpE3G832ProvisionedTable=mscLpE3G832ProvisionedTable, mscLpX21TestPurpose=mscLpX21TestPurpose, mscLpSonetTest=mscLpSonetTest, mscLpDS3IfEntryEntry=mscLpDS3IfEntryEntry, mscLpDS3TestBitErrorRate=mscLpDS3TestBitErrorRate, mscLpDS1StatsTable=mscLpDS1StatsTable, mscLpSdhCustomerIdentifier=mscLpSdhCustomerIdentifier, mscLpV35TestUsageState=mscLpV35TestUsageState, mscLpE3IfEntryEntry=mscLpE3IfEntryEntry, mscLpHssiTestFrmSize=mscLpHssiTestFrmSize, mscLpDS3PlcpSevErroredFramingSec=mscLpDS3PlcpSevErroredFramingSec, mscLpSdhControlStatus=mscLpSdhControlStatus, mscLpHssiRowStatusEntry=mscLpHssiRowStatusEntry, mscLpSdhPathIfEntryTable=mscLpSdhPathIfEntryTable, mscLpDS3CellCorrectSingleBitHeaderErrors=mscLpDS3CellCorrectSingleBitHeaderErrors, mscLpSonetPathCellLcdAlarm=mscLpSonetPathCellLcdAlarm, mscLpE1ChanTestBitsRx=mscLpE1ChanTestBitsRx, mscLpE1ChanFlmStorageType=mscLpE1ChanFlmStorageType, mscLpRowStatus=mscLpRowStatus, mscLpSdhTestDataStartDelay=mscLpSdhTestDataStartDelay, mscLpSdhPathStorageType=mscLpSdhPathStorageType, mscLpDS3LofAlarm=mscLpDS3LofAlarm, mscLpE1ChanTestTimeRemaining=mscLpE1ChanTestTimeRemaining, mscLpDS3DS1RowStatusTable=mscLpDS3DS1RowStatusTable, mscLpDS3DS1TestErroredFrmRx=mscLpDS3DS1TestErroredFrmRx, mscLpEngDsOvAgentQueueSize=mscLpEngDsOvAgentQueueSize, mscLpE1AudioRowStatus=mscLpE1AudioRowStatus, mscLpJT2StatsTable=mscLpJT2StatsTable, mscLpSonetPathPathFailures=mscLpSonetPathPathFailures, mscLpDS1TestUsageState=mscLpDS1TestUsageState, mscLpDS3CellUncorrectableHecErrors=mscLpDS3CellUncorrectableHecErrors, mscLpSonetPathRowStatus=mscLpSonetPathRowStatus, mscLpE3PlcpIndex=mscLpE3PlcpIndex, mscLpDS3DS1ChanTimeslots=mscLpDS3DS1ChanTimeslots, mscLpDS1TestStateEntry=mscLpDS1TestStateEntry, mscLpDS3DS1ChanCellScrambleCellPayload=mscLpDS3DS1ChanCellScrambleCellPayload, mscLpV35LineStatusTimeOut=mscLpV35LineStatusTimeOut, mscLpDS1TestCauseOfTermination=mscLpDS1TestCauseOfTermination, mscLpDS3DS1UnavailSec=mscLpDS3DS1UnavailSec, mscLpJT2CommentText=mscLpJT2CommentText, mscLpSdhPathStateEntry=mscLpSdhPathStateEntry, mscLpE1ChanCidDataEntry=mscLpE1ChanCidDataEntry, mscLpDS3DS1CidDataTable=mscLpDS3DS1CidDataTable, mscLpEngComponentName=mscLpEngComponentName, mscLpSonetComponentName=mscLpSonetComponentName, mscLpDS3DS1ChanTcOpEntry=mscLpDS3DS1ChanTcOpEntry, mscLpDS3DS1ChanTestDataStartDelay=mscLpDS3DS1ChanTestDataStartDelay, mscLpDS3DS1ChanTcSigOneValue=mscLpDS3DS1ChanTcSigOneValue, mscLpDS3PlcpOperationalTable=mscLpDS3PlcpOperationalTable, mscLpV35TestErroredFrmRx=mscLpV35TestErroredFrmRx, mscLpE1RowStatusEntry=mscLpE1RowStatusEntry, mscLpX21RowStatusTable=mscLpX21RowStatusTable, mscLpDS1DspStorageType=mscLpDS1DspStorageType, mscLpDS3LineFailures=mscLpDS3LineFailures, mscLpDS3DS1OperTable=mscLpDS3DS1OperTable, mscLpDS1ChanTcProvEntry=mscLpDS1ChanTcProvEntry, mscLpDS3DS1ChanCellRowStatusEntry=mscLpDS3DS1ChanCellRowStatusEntry, mscLpDS1ChanTestResultsTable=mscLpDS1ChanTestResultsTable, mscLpDS1ChanTcEgressConditioning=mscLpDS1ChanTcEgressConditioning, mscLpDS1TestFrmTx=mscLpDS1TestFrmTx, mscLpDS1ChanAlarmStatus=mscLpDS1ChanAlarmStatus, mscLpSonetTestIndex=mscLpSonetTestIndex, mscLpDS3DS1TestSetupEntry=mscLpDS3DS1TestSetupEntry, mscLpSdhTestResultsTable=mscLpSdhTestResultsTable, mscLpE3TestStateEntry=mscLpE3TestStateEntry, mscLpSdhErrorFreeSec=mscLpSdhErrorFreeSec, mscLpSonetTestBytesRx=mscLpSonetTestBytesRx, mscLpSdhTestDuration=mscLpSdhTestDuration, mscLpDS3CellStatsTable=mscLpDS3CellStatsTable, mscLpE3TestBitErrorRate=mscLpE3TestBitErrorRate, mscLpCpuUtilAvg=mscLpCpuUtilAvg, mscLpJT2CellRowStatusEntry=mscLpJT2CellRowStatusEntry, mscLpSonetTestResultsTable=mscLpSonetTestResultsTable, mscLpDS3CellProvTable=mscLpDS3CellProvTable, mscLpE1ChanFlmRowStatus=mscLpE1ChanFlmRowStatus, mscLpV35ApplicationFramerName=mscLpV35ApplicationFramerName, mscLpJT2TestBytesRx=mscLpJT2TestBytesRx, mscLpDS3CBitFarEndErrorFreeSec=mscLpDS3CBitFarEndErrorFreeSec, mscLpSonetPathSnmpOperStatus=mscLpSonetPathSnmpOperStatus, mscLpJT2CrcErrors=mscLpJT2CrcErrors, mscLpE1ChanCommentText=mscLpE1ChanCommentText, mscLpSonetPathCellStorageType=mscLpSonetPathCellStorageType, mscLpSonetIfIndex=mscLpSonetIfIndex, mscLpHssiAdminInfoTable=mscLpHssiAdminInfoTable, mscLpSonetFarEndLineErrorFreeSec=mscLpSonetFarEndLineErrorFreeSec, mscLpHssiTestStorageType=mscLpHssiTestStorageType, mscLpJT2CellStorageType=mscLpJT2CellStorageType, mscLpDS1ChanTestCustomizedPattern=mscLpDS1ChanTestCustomizedPattern, mscLpSdhTestStateEntry=mscLpSdhTestStateEntry, mscLpSdhUnknownStatus=mscLpSdhUnknownStatus, mscLpDS1ChanTestPurpose=mscLpDS1ChanTestPurpose, mscLpV35TestComponentName=mscLpV35TestComponentName, mscLpHssiIfAdminStatus=mscLpHssiIfAdminStatus, mscLpE1ChanTimeslotDataRate=mscLpE1ChanTimeslotDataRate, mscLpDS1OperTable=mscLpDS1OperTable, mscLpDS1ChanTcOpTable=mscLpDS1ChanTcOpTable, mscLpE3CellCorrectableHeaderErrors=mscLpE3CellCorrectableHeaderErrors, mscLpDS3PlcpComponentName=mscLpDS3PlcpComponentName, logicalProcessorCapabilitiesCA=logicalProcessorCapabilitiesCA, mscLpJT2CellSevErroredSec=mscLpJT2CellSevErroredSec, mscLpHssiTestDuration=mscLpHssiTestDuration, mscLpDS1FrmErrors=mscLpDS1FrmErrors, mscLpDS3DS1TestDisplayInterval=mscLpDS3DS1TestDisplayInterval, mscLpE1ChanCellIndex=mscLpE1ChanCellIndex, mscLpSonetPathIfEntryTable=mscLpSonetPathIfEntryTable, mscLpE1ChanTest=mscLpE1ChanTest, mscLpSonetClockingSource=mscLpSonetClockingSource, mscLpJT2TestFrmPatternType=mscLpJT2TestFrmPatternType, mscLpE3OperStatusTable=mscLpE3OperStatusTable, mscLpDS3DS1ChanTestBytesTx=mscLpDS3DS1ChanTestBytesTx, mscLpEngDsIndex=mscLpEngDsIndex, mscLpSonetTestDataStartDelay=mscLpSonetTestDataStartDelay, mscLpEngDsAgentQueueSize=mscLpEngDsAgentQueueSize, mscLpDS3LosAlarm=mscLpDS3LosAlarm, mscLpJT2OperStatusEntry=mscLpJT2OperStatusEntry, mscLpEngDs=mscLpEngDs, mscLpE1ChanTcSigTwoEntry=mscLpE1ChanTcSigTwoEntry, mscLpStateEntry=mscLpStateEntry, mscLpDS1ChanCellAlarmActDelay=mscLpDS1ChanCellAlarmActDelay, mscLpDS3RunningTime=mscLpDS3RunningTime, mscLpDS3DS1ChanCellComponentName=mscLpDS3DS1ChanCellComponentName, logicalProcessorMIB=logicalProcessorMIB, mscLpCpuUtilAvgMax=mscLpCpuUtilAvgMax, mscLpDS1SevErroredSec=mscLpDS1SevErroredSec, mscLpDS3DS1ChanTestType=mscLpDS3DS1ChanTestType, mscLpDS3TestStateTable=mscLpDS3TestStateTable, mscLpDS3DS1TestTimeRemaining=mscLpDS3DS1TestTimeRemaining, mscLpDS1StorageType=mscLpDS1StorageType, mscLpDS3TestTimeRemaining=mscLpDS3TestTimeRemaining, mscLpDS1TestFrmSize=mscLpDS1TestFrmSize, mscLpE3CellRowStatus=mscLpE3CellRowStatus, mscLpDS1ChanTestErroredFrmRx=mscLpDS1ChanTestErroredFrmRx, mscLpE1ChanProvEntry=mscLpE1ChanProvEntry, mscLpDS3DS1CrcErrors=mscLpDS3DS1CrcErrors, mscLpE3StatsTable=mscLpE3StatsTable, mscLpE1ChanTcIngressConditioning=mscLpE1ChanTcIngressConditioning, mscLpE1ChanTimeslots=mscLpE1ChanTimeslots, mscLpV35TestType=mscLpV35TestType, mscLpDS3DS1ChanTestPurpose=mscLpDS3DS1ChanTestPurpose, mscLpE3PlcpFarEndCodingViolations=mscLpE3PlcpFarEndCodingViolations, mscLpDS3ApplicationFramerName=mscLpDS3ApplicationFramerName, mscLpDS1ClockingSource=mscLpDS1ClockingSource, mscLpX21TestBitsTx=mscLpX21TestBitsTx, mscLpSdhPathCellOperTable=mscLpSdhPathCellOperTable, mscLpProceduralStatus=mscLpProceduralStatus, mscLpV35Test=mscLpV35Test, mscLpDS1ChanTestDataStartDelay=mscLpDS1ChanTestDataStartDelay, mscLpSonetPathRxRfiAlarm=mscLpSonetPathRxRfiAlarm, mscLpHssiTestFrmTx=mscLpHssiTestFrmTx, mscLpE1Chan=mscLpE1Chan, mscLpE3G832OperationalTable=mscLpE3G832OperationalTable, mscLpE3TestSetupEntry=mscLpE3TestSetupEntry, mscLpE3CellTransmitCellUtilization=mscLpE3CellTransmitCellUtilization, mscLpE1OperTable=mscLpE1OperTable, mscLpDS3DS1ChanTcEgressConditioning=mscLpDS3DS1ChanTcEgressConditioning, mscLpHssiAdminInfoEntry=mscLpHssiAdminInfoEntry, mscLpE1ChanTestStateTable=mscLpE1ChanTestStateTable, mscLpDS3RxAisAlarm=mscLpDS3RxAisAlarm, mscLpV35ProceduralStatus=mscLpV35ProceduralStatus, mscLpDS3CellRowStatusTable=mscLpDS3CellRowStatusTable, mscLpDS3CellScrambleCellPayload=mscLpDS3CellScrambleCellPayload, mscLpJT2CellOperEntry=mscLpJT2CellOperEntry, mscLpSdhPathOperTable=mscLpSdhPathOperTable, mscLpDS3StatsEntry=mscLpDS3StatsEntry, mscLpDS1ChanTestFrmPatternType=mscLpDS1ChanTestFrmPatternType, mscLpDS1ChanTcComponentName=mscLpDS1ChanTcComponentName, mscLpDS3DS1UnknownStatus=mscLpDS3DS1UnknownStatus, mscLpX21TestAdminState=mscLpX21TestAdminState, mscLpSonetPathOperStatusEntry=mscLpSonetPathOperStatusEntry, mscLpE1BpvErrors=mscLpE1BpvErrors, mscLpDS3DS1ChanTcProvEntry=mscLpDS3DS1ChanTcProvEntry, mscLpSdhTest=mscLpSdhTest, mscLpX21TestDuration=mscLpX21TestDuration, mscLpSdhTxAis=mscLpSdhTxAis, mscLpDS1ChanTestOperationalState=mscLpDS1ChanTestOperationalState, mscLpDS3DS1SnmpOperStatus=mscLpDS3DS1SnmpOperStatus, mscLpX21TestFrmRx=mscLpX21TestFrmRx, mscLpSonetTestStateEntry=mscLpSonetTestStateEntry, mscLpSonetLineUnavailSec=mscLpSonetLineUnavailSec, mscLpDS3OperTable=mscLpDS3OperTable, mscLpDS3DS1ChanTestTimeRemaining=mscLpDS3DS1ChanTestTimeRemaining, mscLpV35OperStatusTable=mscLpV35OperStatusTable, mscLpSonetTestSetupEntry=mscLpSonetTestSetupEntry, mscLpDS1RxAisAlarm=mscLpDS1RxAisAlarm, mscLpE3TestStorageType=mscLpE3TestStorageType, mscLpJT2TestRowStatusEntry=mscLpJT2TestRowStatusEntry, mscLpE3Mapping=mscLpE3Mapping, mscLpDS3CellIndex=mscLpDS3CellIndex, mscLpE3CellIndex=mscLpE3CellIndex, mscLpSonetOperStatusTable=mscLpSonetOperStatusTable, mscLpV35CustomerIdentifier=mscLpV35CustomerIdentifier, mscLpDS3DS1ChanTestStateTable=mscLpDS3DS1ChanTestStateTable, mscLpV35TestFrmTx=mscLpV35TestFrmTx, mscLpDS3DS1TestAdminState=mscLpDS3DS1TestAdminState, mscLpSdhPathCidDataTable=mscLpSdhPathCidDataTable, mscLpDS3DS1ChanCommentText=mscLpDS3DS1ChanCommentText, mscLpDS3DS1ChanCellSevErroredSec=mscLpDS3DS1ChanCellSevErroredSec, mscLpDS1TestRowStatusTable=mscLpDS1TestRowStatusTable, mscLpE3TestCauseOfTermination=mscLpE3TestCauseOfTermination, mscLpDS3OperStatusTable=mscLpDS3OperStatusTable, mscLpX21TestFrmSize=mscLpX21TestFrmSize, mscLpDS1ChanActualChannelSpeed=mscLpDS1ChanActualChannelSpeed, mscLpDS1ChanOperEntry=mscLpDS1ChanOperEntry, mscLpDS3DS1ChanTcSigTwoValue=mscLpDS3DS1ChanTcSigTwoValue, mscLpDS1RowStatusTable=mscLpDS1RowStatusTable, mscLpE1ChanTcSigTwoIndex=mscLpE1ChanTcSigTwoIndex, mscLpJT2ComponentName=mscLpJT2ComponentName, mscLpSonetPathCellOperTable=mscLpSonetPathCellOperTable, mscLpStandbyStatus=mscLpStandbyStatus)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpDS3DS1ChanAdminInfoTable=mscLpDS3DS1ChanAdminInfoTable, mscLpE3RowStatusTable=mscLpE3RowStatusTable, mscLpE1ChanFlmProvEntry=mscLpE1ChanFlmProvEntry, mscLpE1UnknownStatus=mscLpE1UnknownStatus, mscLpE1IfAdminStatus=mscLpE1IfAdminStatus, mscLpJT2FrameErrors=mscLpJT2FrameErrors, mscLpSonetPathCellScrambleCellPayload=mscLpSonetPathCellScrambleCellPayload, mscLpDS3DS1TestBitsTx=mscLpDS3DS1TestBitsTx, mscLpDS3ProceduralStatus=mscLpDS3ProceduralStatus, mscLpJT2LofAlarm=mscLpJT2LofAlarm, mscLpSdhPathOperStatusEntry=mscLpSdhPathOperStatusEntry, mscLpSdhTestRowStatusTable=mscLpSdhTestRowStatusTable, mscLpJT2TestSetupTable=mscLpJT2TestSetupTable, mscLpEngDsRowStatusTable=mscLpEngDsRowStatusTable, mscLpHssiStateEntry=mscLpHssiStateEntry, mscLpDS3Cell=mscLpDS3Cell, mscLpSdhPathFarEndPathAisLopSec=mscLpSdhPathFarEndPathAisLopSec, mscLpX21OperStatusTable=mscLpX21OperStatusTable, mscLpJT2StateTable=mscLpJT2StateTable, mscLpSdhTestDisplayInterval=mscLpSdhTestDisplayInterval, mscLpX21=mscLpX21, mscLpJT2TestAdminState=mscLpJT2TestAdminState, mscLpV35TestIndex=mscLpV35TestIndex, mscLpE3=mscLpE3, mscLpDS3DS1StatsEntry=mscLpDS3DS1StatsEntry, mscLpDS3TestElapsedTime=mscLpDS3TestElapsedTime, mscLpHssiControlStatus=mscLpHssiControlStatus, mscLpJT2TestCustomizedPattern=mscLpJT2TestCustomizedPattern, mscLpSdhPathSnmpOperStatus=mscLpSdhPathSnmpOperStatus, mscLpE1ChanUsageState=mscLpE1ChanUsageState, mscLpMsgBlockCapacity=mscLpMsgBlockCapacity, mscLpSonetPathOperStatusTable=mscLpSonetPathOperStatusTable, mscLpSdhOperEntry=mscLpSdhOperEntry, mscLpDS3TestSetupEntry=mscLpDS3TestSetupEntry, mscLpDS3DS1ChanTestBitsTx=mscLpDS3DS1ChanTestBitsTx, mscLpE3CellRowStatusEntry=mscLpE3CellRowStatusEntry, mscLpDS1ChanVendor=mscLpDS1ChanVendor, mscLpJT2=mscLpJT2, mscLpDS3TestStorageType=mscLpDS3TestStorageType, mscLpDS3DS1ErroredSec=mscLpDS3DS1ErroredSec, mscLpE1ChanCidDataTable=mscLpE1ChanCidDataTable, mscLpE1ChanFlmHdlcMonitoring=mscLpE1ChanFlmHdlcMonitoring, mscLpDS1ChanRowStatus=mscLpDS1ChanRowStatus, mscLpE1TestTimeRemaining=mscLpE1TestTimeRemaining, mscLpE3TestOperationalState=mscLpE3TestOperationalState, mscLpSdhIfAdminStatus=mscLpSdhIfAdminStatus, mscLpDS1AudioRowStatusTable=mscLpDS1AudioRowStatusTable, mscLpDS1ChanTestStorageType=mscLpDS1ChanTestStorageType, mscLpX21RowStatusEntry=mscLpX21RowStatusEntry, mscLpV35TestResultsTable=mscLpV35TestResultsTable, mscLpJT2LosStateChanges=mscLpJT2LosStateChanges, mscLpDS3AdminInfoTable=mscLpDS3AdminInfoTable, mscLpSonetSnmpOperStatus=mscLpSonetSnmpOperStatus, mscLpV35UsageState=mscLpV35UsageState, mscLpE3G832StorageType=mscLpE3G832StorageType, mscLpE3OperEntry=mscLpE3OperEntry, mscLpSonetPathStatsTable=mscLpSonetPathStatsTable, mscLpUnknownStatus=mscLpUnknownStatus, mscLpDS3DS1ChanTestIndex=mscLpDS3DS1ChanTestIndex, mscLpSdhSnmpOperStatus=mscLpSdhSnmpOperStatus, mscLpJT2TestOperationalState=mscLpJT2TestOperationalState, mscLpDS3PlcpUnavailSec=mscLpDS3PlcpUnavailSec, mscLpSonetTestCauseOfTermination=mscLpSonetTestCauseOfTermination, mscLpSdhPathIfIndex=mscLpSdhPathIfIndex, mscLpSonetTxRdi=mscLpSonetTxRdi, mscLpDS3DS1ChanRowStatusTable=mscLpDS3DS1ChanRowStatusTable, mscLpControlStatus=mscLpControlStatus, mscLpDS3DS1IfAdminStatus=mscLpDS3DS1IfAdminStatus, mscLpE3ControlStatus=mscLpE3ControlStatus, mscLpHssiAvailabilityStatus=mscLpHssiAvailabilityStatus, mscLpDS3DS1ChanCellIndex=mscLpDS3DS1ChanCellIndex, mscLpMemoryUsageAvgTable=mscLpMemoryUsageAvgTable, mscLpDS3LineCodeViolations=mscLpDS3LineCodeViolations, mscLpDS3DS1ChanCellProvTable=mscLpDS3DS1ChanCellProvTable, mscLpJT2CellIndex=mscLpJT2CellIndex, mscLpAlarmStatus=mscLpAlarmStatus, mscLpJT2TestStorageType=mscLpJT2TestStorageType, mscLpE3TestAdminState=mscLpE3TestAdminState, mscLpDS1ChanCellStorageType=mscLpDS1ChanCellStorageType, mscLpDS3DS1ChanCellStatsEntry=mscLpDS3DS1ChanCellStatsEntry, mscLpSonetPathPathSevErroredSec=mscLpSonetPathPathSevErroredSec, mscLpDS3DS1ZeroCoding=mscLpDS3DS1ZeroCoding, mscLpDS1IfAdminStatus=mscLpDS1IfAdminStatus, mscLpJT2StorageType=mscLpJT2StorageType, mscLpDS3DS1ChanTestCauseOfTermination=mscLpDS3DS1ChanTestCauseOfTermination, mscLpV35ControlStatus=mscLpV35ControlStatus, mscLpE1AudioRowStatusEntry=mscLpE1AudioRowStatusEntry, mscLpSonetStatsEntry=mscLpSonetStatsEntry, mscLpE1ChanTestBitErrorRate=mscLpE1ChanTestBitErrorRate, mscLpE1SevErroredFrmSec=mscLpE1SevErroredFrmSec, mscLpX21AvailabilityStatus=mscLpX21AvailabilityStatus, mscLpSdhOperStatusTable=mscLpSdhOperStatusTable, mscLpDS3DS1ChanTimeslotDataRate=mscLpDS3DS1ChanTimeslotDataRate, mscLpHssiTestComponentName=mscLpHssiTestComponentName, mscLpDS1OperationalState=mscLpDS1OperationalState, mscLpDS1ChanTestRowStatus=mscLpDS1ChanTestRowStatus, mscLpE1ChanCellStatsTable=mscLpE1ChanCellStatsTable, mscLpDS1ChanAdminInfoTable=mscLpDS1ChanAdminInfoTable, mscLpSdhPathCellRowStatus=mscLpSdhPathCellRowStatus, mscLpMemoryCapacityTable=mscLpMemoryCapacityTable, mscLpE3Test=mscLpE3Test, mscLpSonetPathComponentName=mscLpSonetPathComponentName, mscLpHssiReadyLineState=mscLpHssiReadyLineState, mscLpE1ChanAdminInfoEntry=mscLpE1ChanAdminInfoEntry, mscLpDS3DS1TestComponentName=mscLpDS3DS1TestComponentName, mscLpE3TestErroredFrmRx=mscLpE3TestErroredFrmRx, mscLpX21TestElapsedTime=mscLpX21TestElapsedTime, mscLpDS3TestResultsEntry=mscLpDS3TestResultsEntry, mscLpSonetStateEntry=mscLpSonetStateEntry, mscLpDS3ClockingSource=mscLpDS3ClockingSource, mscLpSonetIndex=mscLpSonetIndex, mscLpMemoryUsageAvgMaxEntry=mscLpMemoryUsageAvgMaxEntry, mscLpSonetSectLosSec=mscLpSonetSectLosSec, mscLpE3G832StatsTable=mscLpE3G832StatsTable, mscLpUtilEntry=mscLpUtilEntry, mscLpSdhFarEndLineUnavailSec=mscLpSdhFarEndLineUnavailSec, mscLpDS3DS1Test=mscLpDS3DS1Test, mscLpDS3DS1ChanSnmpOperStatus=mscLpDS3DS1ChanSnmpOperStatus, mscLpE1RxMultifrmRaiAlarm=mscLpE1RxMultifrmRaiAlarm, mscLpDS3DS1RxRaiAlarm=mscLpDS3DS1RxRaiAlarm, mscLpDS1Audio=mscLpDS1Audio, mscLpSdhPathCellLcdAlarm=mscLpSdhPathCellLcdAlarm, mscLpSonetPathFarEndPathFailures=mscLpSonetPathFarEndPathFailures, mscLpDS3DS1ChanTestComponentName=mscLpDS3DS1ChanTestComponentName, mscLpE1ChanAdminInfoTable=mscLpE1ChanAdminInfoTable, mscLpComponentName=mscLpComponentName, mscLpX21OperTable=mscLpX21OperTable, mscLpE3LineLength=mscLpE3LineLength, mscLpSonetFarEndLineUnavailSec=mscLpSonetFarEndLineUnavailSec, mscLpDS1DspIndex=mscLpDS1DspIndex, mscLpSonetCidDataTable=mscLpSonetCidDataTable, mscLpDS3Vendor=mscLpDS3Vendor, mscLpHssiTestUsageState=mscLpHssiTestUsageState, mscLpE3TxRai=mscLpE3TxRai, mscLpDS1LineType=mscLpDS1LineType, mscLpV35=mscLpV35, mscLpJT2ApplicationFramerName=mscLpJT2ApplicationFramerName, mscLpV35TestRowStatusTable=mscLpV35TestRowStatusTable, mscLpSdhTestResultsEntry=mscLpSdhTestResultsEntry, mscLpDS3PathCodeViolations=mscLpDS3PathCodeViolations, mscLpDS3DS1RowStatus=mscLpDS3DS1RowStatus, mscLpE1TestStateEntry=mscLpE1TestStateEntry, mscLpE1ChanCellRowStatusTable=mscLpE1ChanCellRowStatusTable, mscLpSdhProceduralStatus=mscLpSdhProceduralStatus, mscLpE1ChanComponentName=mscLpE1ChanComponentName, mscLpDS1ChanTestBitErrorRate=mscLpDS1ChanTestBitErrorRate, mscLpSdhLofAlarm=mscLpSdhLofAlarm, mscLpDS3TestType=mscLpDS3TestType, mscLpSonetTestRowStatus=mscLpSonetTestRowStatus, mscLpJT2CellRowStatusTable=mscLpJT2CellRowStatusTable, mscLpSonetTestResultsEntry=mscLpSonetTestResultsEntry, mscLpV35TestStorageType=mscLpV35TestStorageType, mscLpE3PlcpCodingViolations=mscLpE3PlcpCodingViolations, mscLpDS3CBitStatsTable=mscLpDS3CBitStatsTable, mscLpE3PlcpFarEndErrorFreeSec=mscLpE3PlcpFarEndErrorFreeSec, mscLpV35OperationalState=mscLpV35OperationalState, mscLpV35TestCauseOfTermination=mscLpV35TestCauseOfTermination, mscLpDS3DS1ChanTcStorageType=mscLpDS3DS1ChanTcStorageType, mscLpJT2RowStatusTable=mscLpJT2RowStatusTable, mscLpJT2OperTable=mscLpJT2OperTable, mscLpDS3TestDuration=mscLpDS3TestDuration, mscLpSdhTestRowStatus=mscLpSdhTestRowStatus, mscLpJT2TestBytesTx=mscLpJT2TestBytesTx, mscLpJT2ProceduralStatus=mscLpJT2ProceduralStatus, mscLpDS1ChanTcSigOneValue=mscLpDS1ChanTcSigOneValue, mscLpE1ChanTcProvEntry=mscLpE1ChanTcProvEntry, mscLpE3G832ComponentName=mscLpE3G832ComponentName, mscLpDS1ChanTestAdminState=mscLpDS1ChanTestAdminState, mscLpE3CellAlarmActDelay=mscLpE3CellAlarmActDelay, mscLpDS3DS1AdminInfoTable=mscLpDS3DS1AdminInfoTable, mscLpSdhPathComponentName=mscLpSdhPathComponentName, mscLpHssiTestIndex=mscLpHssiTestIndex, mscLpJT2TestDisplayInterval=mscLpJT2TestDisplayInterval, mscLpSonetTxAis=mscLpSonetTxAis, mscLpDS3ErrorFreeSec=mscLpDS3ErrorFreeSec, mscLpE3PlcpOperationalTable=mscLpE3PlcpOperationalTable, mscLpDS1BpvErrors=mscLpDS1BpvErrors, mscLpSdhPathIfEntryEntry=mscLpSdhPathIfEntryEntry, mscLpSdhPathFarEndPathErrorFreeSec=mscLpSdhPathFarEndPathErrorFreeSec, mscLpDS3CellOperTable=mscLpDS3CellOperTable, mscLpE3TestBytesTx=mscLpE3TestBytesTx, mscLpE1ChanTestBytesTx=mscLpE1ChanTestBytesTx, mscLpE3OperationalState=mscLpE3OperationalState, mscLpDS1CrcErrors=mscLpDS1CrcErrors, mscLpSonetTestStorageType=mscLpSonetTestStorageType, mscLpDS1ChanTcSigOneIndex=mscLpDS1ChanTcSigOneIndex, mscLpSdhPathCellSevErroredSec=mscLpSdhPathCellSevErroredSec, mscLpDS3UsageState=mscLpDS3UsageState, mscLpV35ReadyLineState=mscLpV35ReadyLineState, mscLpDS3DS1TestBytesRx=mscLpDS3DS1TestBytesRx, mscLpSonetRunningTime=mscLpSonetRunningTime, mscLpHssiAdminState=mscLpHssiAdminState, mscLpDS1ControlStatus=mscLpDS1ControlStatus, mscLpDS3TestDataStartDelay=mscLpDS3TestDataStartDelay, mscLpE1ChanTcSignalOneDuration=mscLpE1ChanTcSignalOneDuration, mscLpSdhPathCell=mscLpSdhPathCell, mscLpDS1CidDataTable=mscLpDS1CidDataTable, mscLpE1ChanTestDuration=mscLpE1ChanTestDuration, mscLpSdhPathCellOperEntry=mscLpSdhPathCellOperEntry, mscLpSdhPathTxRdi=mscLpSdhPathTxRdi, mscLpE1ChanFlmABitMonitoring=mscLpE1ChanFlmABitMonitoring, mscLpE1CustomerIdentifier=mscLpE1CustomerIdentifier, mscLpSonetTestSetupTable=mscLpSonetTestSetupTable, mscLpE1ChanTestRowStatus=mscLpE1ChanTestRowStatus, mscLpSonetRowStatus=mscLpSonetRowStatus, mscLpSonetPathOperationalState=mscLpSonetPathOperationalState, mscLpMemoryUsageAvgEntry=mscLpMemoryUsageAvgEntry, mscLpDS3DS1ChanCellRowStatus=mscLpDS3DS1ChanCellRowStatus, mscLpDS1OperStatusEntry=mscLpDS1OperStatusEntry, mscLpDS3TestUsageState=mscLpDS3TestUsageState, mscLpDS1ChanOperStatusEntry=mscLpDS1ChanOperStatusEntry, mscLpSonetFarEndLineErroredSec=mscLpSonetFarEndLineErroredSec, mscLpSdhCidDataEntry=mscLpSdhCidDataEntry, mscLpHssiTestBitsRx=mscLpHssiTestBitsRx, mscLpDS3TestFrmTx=mscLpDS3TestFrmTx, mscLpE1ChanTestIndex=mscLpE1ChanTestIndex, mscLpJT2AlarmStatus=mscLpJT2AlarmStatus, mscLpDS3CBitRowStatusTable=mscLpDS3CBitRowStatusTable, mscLpDS1ChanCustomerIdentifier=mscLpDS1ChanCustomerIdentifier, mscLpDS3StandbyStatus=mscLpDS3StandbyStatus, mscLpDS1LosAlarm=mscLpDS1LosAlarm, mscLpSonetTestRowStatusTable=mscLpSonetTestRowStatusTable, mscLpSdhTxRdi=mscLpSdhTxRdi, mscLpStorageType=mscLpStorageType, mscLpDS1ChanCellProvEntry=mscLpDS1ChanCellProvEntry, mscLpSdhPathStatsEntry=mscLpSdhPathStatsEntry, mscLpEngDsOvRowStatusEntry=mscLpEngDsOvRowStatusEntry, mscLpDS3PlcpIndex=mscLpDS3PlcpIndex, mscLpDS1ChanTestRowStatusEntry=mscLpDS1ChanTestRowStatusEntry, mscLpDS1ChanCellSevErroredSec=mscLpDS1ChanCellSevErroredSec, mscLpDS1ChanTest=mscLpDS1ChanTest, mscLpX21IfAdminStatus=mscLpX21IfAdminStatus, mscLpV35TestBytesTx=mscLpV35TestBytesTx, mscLpDS3CellTransmitCellUtilization=mscLpDS3CellTransmitCellUtilization, mscLpE3PlcpStatsEntry=mscLpE3PlcpStatsEntry, mscLpV35TestDuration=mscLpV35TestDuration, mscLpE3TxAis=mscLpE3TxAis, mscLpX21CidDataEntry=mscLpX21CidDataEntry, mscLpV35ProvEntry=mscLpV35ProvEntry, mscLpX21ClockingSource=mscLpX21ClockingSource, mscLpE1ChanCellCorrectSingleBitHeaderErrors=mscLpE1ChanCellCorrectSingleBitHeaderErrors, mscLpJT2TxAisPhysicalAlarm=mscLpJT2TxAisPhysicalAlarm, mscLpLinkToApplicationsValue=mscLpLinkToApplicationsValue, mscLpSdhFarEndLineErroredSec=mscLpSdhFarEndLineErroredSec, mscLpSdhTestElapsedTime=mscLpSdhTestElapsedTime, mscLpE3PlcpFarEndSevErroredSec=mscLpE3PlcpFarEndSevErroredSec, mscLpE1TestBitsTx=mscLpE1TestBitsTx, mscLpDS3DS1Chan=mscLpDS3DS1Chan, mscLpE1TxAisAlarm=mscLpE1TxAisAlarm, mscLpDS3CBitFarEndFailures=mscLpDS3CBitFarEndFailures, mscLpDS3DS1TestBytesTx=mscLpDS3DS1TestBytesTx, mscLpSdhAvailabilityStatus=mscLpSdhAvailabilityStatus, mscLpSonetPathProceduralStatus=mscLpSonetPathProceduralStatus, mscLpDS3TestCustomizedPattern=mscLpDS3TestCustomizedPattern)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpE1IfEntryTable=mscLpE1IfEntryTable, mscLpSonetPathIndex=mscLpSonetPathIndex, mscLpDS3OperEntry=mscLpDS3OperEntry, mscLpDS3CBitCbitErroredSec=mscLpDS3CBitCbitErroredSec, mscLpE1ChanTestStateEntry=mscLpE1ChanTestStateEntry, mscLpDS3DS1CustomerIdentifier=mscLpDS3DS1CustomerIdentifier, mscLpE3LinkAlarmActivationThreshold=mscLpE3LinkAlarmActivationThreshold, mscLpX21ProceduralStatus=mscLpX21ProceduralStatus, mscLpHssiVendor=mscLpHssiVendor, mscLpDS3CellComponentName=mscLpDS3CellComponentName, mscLpDS1ZeroCoding=mscLpDS1ZeroCoding, mscLpE1ChanProvTable=mscLpE1ChanProvTable, mscLpE3PlcpStorageType=mscLpE3PlcpStorageType, mscLpE1ChanStateEntry=mscLpE1ChanStateEntry, mscLpE3LosAlarm=mscLpE3LosAlarm, mscLpDS3DS1OperationalState=mscLpDS3DS1OperationalState, mscLpDS3DS1ChanUsageState=mscLpDS3DS1ChanUsageState, mscLpV35ClockingSource=mscLpV35ClockingSource, mscLpCpuUtil=mscLpCpuUtil, mscLpDS3TxIdle=mscLpDS3TxIdle, mscLpDS3DS1ChanTcSigTwoIndex=mscLpDS3DS1ChanTcSigTwoIndex, mscLpE3LineSevErroredSec=mscLpE3LineSevErroredSec, mscLpE3G832FarEndErroredSec=mscLpE3G832FarEndErroredSec, mscLpE1TestStorageType=mscLpE1TestStorageType, mscLpSdhPathFarEndPathFailures=mscLpSdhPathFarEndPathFailures, mscLpSdhPathStatsTable=mscLpSdhPathStatsTable, mscLpE3TestDataStartDelay=mscLpE3TestDataStartDelay, mscLpE1StateTable=mscLpE1StateTable, mscLpHssiStateTable=mscLpHssiStateTable, mscLpDS3DS1ChanStateTable=mscLpDS3DS1ChanStateTable, mscLpV35TestRowStatusEntry=mscLpV35TestRowStatusEntry, mscLpE1OperEntry=mscLpE1OperEntry, mscLpSonetPathFarEndPathErroredSec=mscLpSonetPathFarEndPathErroredSec, mscLpX21TestSetupEntry=mscLpX21TestSetupEntry, mscLpMemoryUsageAvgMinValue=mscLpMemoryUsageAvgMinValue, mscLpE1ChanCellComponentName=mscLpE1ChanCellComponentName, mscLpE3G832Index=mscLpE3G832Index, mscLpHssiTestDataStartDelay=mscLpHssiTestDataStartDelay, mscLpE1IfEntryEntry=mscLpE1IfEntryEntry, mscLpV35OperTable=mscLpV35OperTable, mscLpDS3CellStorageType=mscLpDS3CellStorageType, mscLpDS3DS1ChanOperationalState=mscLpDS3DS1ChanOperationalState, mscLpDS3DS1TestCauseOfTermination=mscLpDS3DS1TestCauseOfTermination, mscLpDS1ChanCommentText=mscLpDS1ChanCommentText, mscLpSdhPathPathFailures=mscLpSdhPathPathFailures, mscLpSonetSectCodeViolations=mscLpSonetSectCodeViolations, mscLpE3ProvEntry=mscLpE3ProvEntry, mscLpE3IfIndex=mscLpE3IfIndex, mscLpSdhPathCellRowStatusEntry=mscLpSdhPathCellRowStatusEntry, mscLpDS3UnknownStatus=mscLpDS3UnknownStatus, mscLpSonetTestBitErrorRate=mscLpSonetTestBitErrorRate, mscLpDS3DS1ChanTestStorageType=mscLpDS3DS1ChanTestStorageType, mscLpE1ChanAdminState=mscLpE1ChanAdminState, mscLpDS1ChanCellRowStatusTable=mscLpDS1ChanCellRowStatusTable, mscLpJT2TestFrmTx=mscLpJT2TestFrmTx, mscLpJT2ClockingSource=mscLpJT2ClockingSource, mscLpHssiTestFrmRx=mscLpHssiTestFrmRx, mscLpDS1ChanIfIndex=mscLpDS1ChanIfIndex, mscLpSonetPathUnknownStatus=mscLpSonetPathUnknownStatus, mscLpMemoryUsageAvgMinEntry=mscLpMemoryUsageAvgMinEntry, mscLpX21SnmpOperStatus=mscLpX21SnmpOperStatus, mscLpLogicalProcessorType=mscLpLogicalProcessorType, mscLpSonetTestUsageState=mscLpSonetTestUsageState, mscLpDS3CellSevErroredSec=mscLpDS3CellSevErroredSec, mscLpDS3DS1UsageState=mscLpDS3DS1UsageState, mscLpE3LofAlarm=mscLpE3LofAlarm, mscLpSdhPathCellProvEntry=mscLpSdhPathCellProvEntry, mscLpDS3TestFrmPatternType=mscLpDS3TestFrmPatternType, mscLpX21ProvEntry=mscLpX21ProvEntry, mscLpDS1ChanTestBitsTx=mscLpDS1ChanTestBitsTx, mscLpDS1ChanTcOpEntry=mscLpDS1ChanTcOpEntry, mscLpDS3DS1ChanCellReceiveCellUtilization=mscLpDS3DS1ChanCellReceiveCellUtilization, mscLpDS3OperationalState=mscLpDS3OperationalState, mscLpSonetPathCellRowStatusEntry=mscLpSonetPathCellRowStatusEntry, mscLpDS3DS1TestStateEntry=mscLpDS3DS1TestStateEntry, mscLpDS1ChanAdminState=mscLpDS1ChanAdminState, mscLpDS1CommentText=mscLpDS1CommentText, mscLpSdhPathAvailabilityStatus=mscLpSdhPathAvailabilityStatus, mscLpSonetTestComponentName=mscLpSonetTestComponentName, mscLpLinkToApplicationsTable=mscLpLinkToApplicationsTable, mscLpDS1LosStateChanges=mscLpDS1LosStateChanges, mscLpE3TestFrmPatternType=mscLpE3TestFrmPatternType, mscLpE1ChanCellProvEntry=mscLpE1ChanCellProvEntry, mscLpSonetPathCellStatsTable=mscLpSonetPathCellStatsTable, mscLpMemoryUsageTable=mscLpMemoryUsageTable, mscLpE3PathCodeViolations=mscLpE3PathCodeViolations, mscLpSdhAdminInfoTable=mscLpSdhAdminInfoTable, mscLpDS3DS1ClockingSource=mscLpDS3DS1ClockingSource, mscLpSdhTestErroredFrmRx=mscLpSdhTestErroredFrmRx, mscLpDS3TestCauseOfTermination=mscLpDS3TestCauseOfTermination, mscLpDS1ChanTc=mscLpDS1ChanTc, mscLpDS3ProvEntry=mscLpDS3ProvEntry, mscLpDS3DS1RunningTime=mscLpDS3DS1RunningTime, mscLpScheduledSwitchover=mscLpScheduledSwitchover, mscLpDS3DS1TestDuration=mscLpDS3DS1TestDuration, mscLpJT2UnavailSec=mscLpJT2UnavailSec, mscLpSonetPathStatsEntry=mscLpSonetPathStatsEntry, mscLpDS3DS1TestElapsedTime=mscLpDS3DS1TestElapsedTime, mscLpE1StorageType=mscLpE1StorageType, mscLpSonet=mscLpSonet, mscLpDS3StatsTable=mscLpDS3StatsTable, mscLpSdhSectErroredSec=mscLpSdhSectErroredSec, mscLpLocalMsgBlockUsage=mscLpLocalMsgBlockUsage, mscLpDS3LineLosSec=mscLpDS3LineLosSec, mscLpE1ChanCellUncorrectableHecErrors=mscLpE1ChanCellUncorrectableHecErrors, mscLpX21StateEntry=mscLpX21StateEntry, mscLpDS1UnavailSec=mscLpDS1UnavailSec, mscLpSdhPathProvEntry=mscLpSdhPathProvEntry, mscLpHssiTestRowStatusEntry=mscLpHssiTestRowStatusEntry, mscLpDS3DS1ChanIfEntryEntry=mscLpDS3DS1ChanIfEntryEntry, mscLpE1ChanStorageType=mscLpE1ChanStorageType, mscLpDS3TestIndex=mscLpDS3TestIndex, mscLpSdhTestBitsRx=mscLpSdhTestBitsRx, mscLpDS3DS1LofAlarm=mscLpDS3DS1LofAlarm, mscLpE1LineType=mscLpE1LineType, mscLpE1ChanFlmOpTable=mscLpE1ChanFlmOpTable, mscLpSonetPathStandbyStatus=mscLpSonetPathStandbyStatus, mscLpLocalMsgBlockUsageAvg=mscLpLocalMsgBlockUsageAvg, mscLpSdhPathCellProvTable=mscLpSdhPathCellProvTable, mscLpE1TestIndex=mscLpE1TestIndex, mscLpDS3TestRowStatusTable=mscLpDS3TestRowStatusTable, mscLpE1ChanTestBitsTx=mscLpE1ChanTestBitsTx, mscLpDS3DS1ChanCell=mscLpDS3DS1ChanCell, mscLpHssiTestStateTable=mscLpHssiTestStateTable, mscLpJT2LosAlarm=mscLpJT2LosAlarm, mscLpE3CidDataTable=mscLpE3CidDataTable, mscLpEngDsOvIndex=mscLpEngDsOvIndex, mscLpE3PathSevErroredSec=mscLpE3PathSevErroredSec, mscLpSonetPathCellOperEntry=mscLpSonetPathCellOperEntry, mscLpE1TestRowStatusTable=mscLpE1TestRowStatusTable, mscLpDS3StorageType=mscLpDS3StorageType, mscLpEngDsOperTable=mscLpEngDsOperTable, mscLpV35CidDataEntry=mscLpV35CidDataEntry, mscLpSonetVendor=mscLpSonetVendor, mscLpHssiTestRowStatus=mscLpHssiTestRowStatus, mscLpEngDsOvStorageType=mscLpEngDsOvStorageType, mscLpE1Index=mscLpE1Index, mscLpDS1TestRowStatus=mscLpDS1TestRowStatus, mscLpSonetPathRowStatusEntry=mscLpSonetPathRowStatusEntry, logicalProcessorGroupCA02A=logicalProcessorGroupCA02A, mscLpSdhPathProceduralStatus=mscLpSdhPathProceduralStatus, mscLpDS1CidDataEntry=mscLpDS1CidDataEntry, mscLpJT2CellLcdAlarm=mscLpJT2CellLcdAlarm, logicalProcessorCapabilitiesCA02=logicalProcessorCapabilitiesCA02, mscLpSonetPathPathErrorFreeSec=mscLpSonetPathPathErrorFreeSec, mscLpJT2OperationalState=mscLpJT2OperationalState, mscLpSpareCardStatus=mscLpSpareCardStatus, mscLpSonetPathCell=mscLpSonetPathCell, mscLpSdhPathFarEndPathSevErroredSec=mscLpSdhPathFarEndPathSevErroredSec, mscLpSonetPathCellAlarmActDelay=mscLpSonetPathCellAlarmActDelay, mscLpV35RowStatusEntry=mscLpV35RowStatusEntry, mscLpX21ApplicationFramerName=mscLpX21ApplicationFramerName, mscLpRestartOnCpSwitch=mscLpRestartOnCpSwitch, mscLpE3TestSetupTable=mscLpE3TestSetupTable, mscLpSdhTestFrmSize=mscLpSdhTestFrmSize, mscLpDS1ChanCell=mscLpDS1ChanCell, mscLpE3TestBytesRx=mscLpE3TestBytesRx, mscLpX21ComponentName=mscLpX21ComponentName, mscLpJT2Cell=mscLpJT2Cell, mscLpDS1DspRowStatusEntry=mscLpDS1DspRowStatusEntry, mscLpDS3CBitOperationalTable=mscLpDS3CBitOperationalTable, mscLpDS1ComponentName=mscLpDS1ComponentName, mscLpDS1ChanTestDisplayInterval=mscLpDS1ChanTestDisplayInterval, mscLpActiveCard=mscLpActiveCard, mscLpE1SendRaiOnAis=mscLpE1SendRaiOnAis, mscLpHssiIfIndex=mscLpHssiIfIndex, mscLpE1DspRowStatus=mscLpE1DspRowStatus, mscLpV35AdminInfoEntry=mscLpV35AdminInfoEntry, mscLpX21EnableDynamicSpeed=mscLpX21EnableDynamicSpeed, mscLpDS1ChanTestUsageState=mscLpDS1ChanTestUsageState, mscLpE3CellUncorrectableHecErrors=mscLpE3CellUncorrectableHecErrors, mscLpJT2OperEntry=mscLpJT2OperEntry, mscLpE1ChanFlmIndex=mscLpE1ChanFlmIndex, mscLpE1StandbyStatus=mscLpE1StandbyStatus, mscLpDS3DS1ChanTcRowStatusEntry=mscLpDS3DS1ChanTcRowStatusEntry, mscLpMemoryCapacityValue=mscLpMemoryCapacityValue, mscLpDS1ProvTable=mscLpDS1ProvTable, mscLpSdhStandbyStatus=mscLpSdhStandbyStatus, mscLpX21AlarmStatus=mscLpX21AlarmStatus, mscLpDS3DS1ChanCidDataTable=mscLpDS3DS1ChanCidDataTable, mscLpDS3PlcpStorageType=mscLpDS3PlcpStorageType, mscLpHssiTestType=mscLpHssiTestType, mscLpJT2Test=mscLpJT2Test, mscLpJT2TestIndex=mscLpJT2TestIndex, mscLpV35ProvTable=mscLpV35ProvTable, mscLpE3ClockingSource=mscLpE3ClockingSource, mscLpDS3DS1=mscLpDS3DS1, mscLpE1TestSetupEntry=mscLpE1TestSetupEntry, mscLpE1IfIndex=mscLpE1IfIndex, mscLpDS3PathErroredSec=mscLpDS3PathErroredSec, mscLpDS3CBitLoopbackAtFarEndRequested=mscLpDS3CBitLoopbackAtFarEndRequested, mscLpDS1StateTable=mscLpDS1StateTable, mscLpDS1ChanTestBytesTx=mscLpDS1ChanTestBytesTx, mscLpSonetPathRowStatusTable=mscLpSonetPathRowStatusTable, mscLpSonetRowStatusTable=mscLpSonetRowStatusTable, mscLpSdhCommentText=mscLpSdhCommentText, mscLpDS3RowStatus=mscLpDS3RowStatus, mscLpDS1AudioComponentName=mscLpDS1AudioComponentName, mscLpDS3CBitFarEndCodeViolations=mscLpDS3CBitFarEndCodeViolations, mscLpSonetPathIfAdminStatus=mscLpSonetPathIfAdminStatus, mscLpE3TestUsageState=mscLpE3TestUsageState, mscLpSonetUsageState=mscLpSonetUsageState, mscLpX21TestCustomizedPattern=mscLpX21TestCustomizedPattern, mscLpE1ChanTestCauseOfTermination=mscLpE1ChanTestCauseOfTermination, mscLpEngDsOvProvTable=mscLpEngDsOvProvTable, mscLpJT2TestComponentName=mscLpJT2TestComponentName, mscLpJT2CellStatsEntry=mscLpJT2CellStatsEntry, mscLpE3AdminInfoEntry=mscLpE3AdminInfoEntry, mscLpDS3DS1ChanTcSigOneTable=mscLpDS3DS1ChanTcSigOneTable, mscLpE1ChanTestFrmTx=mscLpE1ChanTestFrmTx, mscLpJT2TestResultsEntry=mscLpJT2TestResultsEntry, mscLpE3StateTable=mscLpE3StateTable, mscLpDS1ChanTcSigTwoTable=mscLpDS1ChanTcSigTwoTable, mscLpJT2TestRowStatusTable=mscLpJT2TestRowStatusTable, mscLpDS1TestSetupEntry=mscLpDS1TestSetupEntry, mscLpDS1ChanCellUncorrectableHecErrors=mscLpDS1ChanCellUncorrectableHecErrors, mscLpE1ChanTestElapsedTime=mscLpE1ChanTestElapsedTime, mscLpEngDsComponentName=mscLpEngDsComponentName, mscLpJT2TestDuration=mscLpJT2TestDuration, mscLpDS3DS1ChanCidDataEntry=mscLpDS3DS1ChanCidDataEntry, mscLpE1ChanFlmRowStatusEntry=mscLpE1ChanFlmRowStatusEntry, mscLpDS1RunningTime=mscLpDS1RunningTime, mscLpDS3DS1ChanTestDisplayInterval=mscLpDS3DS1ChanTestDisplayInterval, mscLpE1TestFrmTx=mscLpE1TestFrmTx, mscLpV35AvailabilityStatus=mscLpV35AvailabilityStatus, mscLpE3G832TrailTraceReceived=mscLpE3G832TrailTraceReceived, mscLpDS3DS1ChanOperStatusTable=mscLpDS3DS1ChanOperStatusTable, mscLpDS1SlipErrors=mscLpDS1SlipErrors, mscLpE1ChanCellProvTable=mscLpE1ChanCellProvTable, mscLpDS3DS1TestBitsRx=mscLpDS3DS1TestBitsRx, mscLpX21Index=mscLpX21Index, mscLpSonetPathApplicationFramerName=mscLpSonetPathApplicationFramerName, mscLpV35RowStatus=mscLpV35RowStatus, mscLpHssiOperStatusEntry=mscLpHssiOperStatusEntry, mscLpJT2TestFrmSize=mscLpJT2TestFrmSize, mscLpDS3DS1StatsTable=mscLpDS3DS1StatsTable, mscLpSdhTestIndex=mscLpSdhTestIndex, mscLpDS1ChanTimeslots=mscLpDS1ChanTimeslots, mscLpE1RowStatus=mscLpE1RowStatus, mscLpDS1ChanCellOperEntry=mscLpDS1ChanCellOperEntry, mscLpV35Vendor=mscLpV35Vendor, mscLpDS3PlcpStatsEntry=mscLpDS3PlcpStatsEntry, mscLpX21IfEntryTable=mscLpX21IfEntryTable, mscLpDS1ChanTestRowStatusTable=mscLpDS1ChanTestRowStatusTable, mscLpDS3TestOperationalState=mscLpDS3TestOperationalState, mscLpDS1ChanStorageType=mscLpDS1ChanStorageType, mscLpE1ChanTestFrmRx=mscLpE1ChanTestFrmRx, mscLpE1FrmErrors=mscLpE1FrmErrors, mscLpDS3DS1TestType=mscLpDS3DS1TestType, mscLpSdhPathIndex=mscLpSdhPathIndex, mscLpEngDsOperEntry=mscLpEngDsOperEntry, mscLpE1StatsTable=mscLpE1StatsTable, mscLpHssiSnmpOperStatus=mscLpHssiSnmpOperStatus, mscLpX21OperStatusEntry=mscLpX21OperStatusEntry)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpE3PlcpSevErroredFramingSec=mscLpE3PlcpSevErroredFramingSec, mscLpE1TestOperationalState=mscLpE1TestOperationalState, mscLpV35OperEntry=mscLpV35OperEntry, mscLpCapEntry=mscLpCapEntry, mscLpDS3DS1ErrorFreeSec=mscLpDS3DS1ErrorFreeSec, mscLpE3RxAisAlarm=mscLpE3RxAisAlarm, mscLpDS1ChanRowStatusTable=mscLpDS1ChanRowStatusTable, mscLpJT2StateEntry=mscLpJT2StateEntry, mscLpE3Framing=mscLpE3Framing, mscLpSdhPathAlarmStatus=mscLpSdhPathAlarmStatus, mscLpHssiOperationalState=mscLpHssiOperationalState, mscLpSdhRowStatusEntry=mscLpSdhRowStatusEntry, mscLpX21DataTransferLineState=mscLpX21DataTransferLineState, mscLpSdhTestBitsTx=mscLpSdhTestBitsTx, mscLpDS3DS1ChanTestRowStatus=mscLpDS3DS1ChanTestRowStatus, mscLpX21TestComponentName=mscLpX21TestComponentName, mscLpE1ChanCellTransmitCellUtilization=mscLpE1ChanCellTransmitCellUtilization, mscLpV35LinkMode=mscLpV35LinkMode, mscLpDS3CBitRowStatusEntry=mscLpDS3CBitRowStatusEntry, mscLpE3IfEntryTable=mscLpE3IfEntryTable, mscLpSonetSectFailures=mscLpSonetSectFailures, mscLpSdhTestSetupEntry=mscLpSdhTestSetupEntry, mscLpSdhUnusableTxClockRefAlarm=mscLpSdhUnusableTxClockRefAlarm, mscLpHssiProvTable=mscLpHssiProvTable, mscLpE1AudioRowStatusTable=mscLpE1AudioRowStatusTable, mscLpSonetPathIfEntryEntry=mscLpSonetPathIfEntryEntry, mscLpSonetPathStateEntry=mscLpSonetPathStateEntry, mscLpJT2CellRowStatus=mscLpJT2CellRowStatus, mscLpDS3DS1ChanTcSigOneEntry=mscLpDS3DS1ChanTcSigOneEntry, mscLpSdhStatsEntry=mscLpSdhStatsEntry, mscLpSdhPathProvTable=mscLpSdhPathProvTable, mscLpDS3CBitFarEndAlarm=mscLpDS3CBitFarEndAlarm, mscLpJT2SnmpOperStatus=mscLpJT2SnmpOperStatus, mscLpMemoryCapacityIndex=mscLpMemoryCapacityIndex, mscLpDS3DS1TxAisAlarm=mscLpDS3DS1TxAisAlarm, mscLpDS1ChanIfEntryEntry=mscLpDS1ChanIfEntryEntry, mscLpE3PlcpFarEndErroredSec=mscLpE3PlcpFarEndErroredSec, mscLpDS3CellLcdAlarm=mscLpDS3CellLcdAlarm, mscLpE3PlcpOperationalEntry=mscLpE3PlcpOperationalEntry, mscLpSonetTestBitsRx=mscLpSonetTestBitsRx, mscLpDS3CBit=mscLpDS3CBit, mscLpSonetPathCellStatsEntry=mscLpSonetPathCellStatsEntry, mscLpEngDsStorageType=mscLpEngDsStorageType, mscLpE3AdminInfoTable=mscLpE3AdminInfoTable, mscLpV35TestStateTable=mscLpV35TestStateTable, mscLpE3TestDisplayInterval=mscLpE3TestDisplayInterval, mscLpDS3DS1StateEntry=mscLpDS3DS1StateEntry, mscLpE3StatsEntry=mscLpE3StatsEntry, mscLpJT2AdminState=mscLpJT2AdminState, mscLpDS1TestSetupTable=mscLpDS1TestSetupTable, mscLpDS1ChanTcSigTwoIndex=mscLpDS1ChanTcSigTwoIndex, mscLpDS3CBitIndex=mscLpDS3CBitIndex, mscLpDS3TxAis=mscLpDS3TxAis, mscLpSonetTestFrmSize=mscLpSonetTestFrmSize, mscLpDS3DS1ChanIfIndex=mscLpDS3DS1ChanIfIndex, mscLpV35TestElapsedTime=mscLpV35TestElapsedTime, mscLpJT2TestBitsRx=mscLpJT2TestBitsRx, mscLpHssiProceduralStatus=mscLpHssiProceduralStatus, mscLpDS3DS1ChanTestFrmPatternType=mscLpDS3DS1ChanTestFrmPatternType, mscLpV35TestFrmSize=mscLpV35TestFrmSize, mscLpDS1IfEntryTable=mscLpDS1IfEntryTable, mscLpE3ComponentName=mscLpE3ComponentName, mscLpSonetPathCidDataTable=mscLpSonetPathCidDataTable, mscLpV35DataTransferLineState=mscLpV35DataTransferLineState, mscLpV35TestDisplayInterval=mscLpV35TestDisplayInterval, mscLpE1ChanFlmOpEntry=mscLpE1ChanFlmOpEntry, mscLpSonetPathAdminState=mscLpSonetPathAdminState, mscLpDS1TestDataStartDelay=mscLpDS1TestDataStartDelay, mscLpSonetCustomerIdentifier=mscLpSonetCustomerIdentifier, mscLpSdhPathFarEndPathCodeViolations=mscLpSdhPathFarEndPathCodeViolations, mscLpDS3DS1ChanTestOperationalState=mscLpDS3DS1ChanTestOperationalState, mscLpDS3IfAdminStatus=mscLpDS3IfAdminStatus, mscLpSdhTestAdminState=mscLpSdhTestAdminState, mscLpDS1ErrorFreeSec=mscLpDS1ErrorFreeSec, mscLpE1ChanIfAdminStatus=mscLpE1ChanIfAdminStatus, mscLpSdhPathIfAdminStatus=mscLpSdhPathIfAdminStatus, mscLpDS3=mscLpDS3, mscLpE1ChanStateTable=mscLpE1ChanStateTable, mscLpE1ChanOperStatusEntry=mscLpE1ChanOperStatusEntry, mscLpX21TestDataStartDelay=mscLpX21TestDataStartDelay, mscLpDS3TxRai=mscLpDS3TxRai, mscLpE3Plcp=mscLpE3Plcp, mscLpSonetProceduralStatus=mscLpSonetProceduralStatus, mscLpDS1AudioStorageType=mscLpDS1AudioStorageType, mscLpE1ChanCell=mscLpE1ChanCell, mscLpSonetLineSevErroredSec=mscLpSonetLineSevErroredSec, mscLpSdhTestBytesRx=mscLpSdhTestBytesRx, mscLpDS1ChanTcSignalOneDuration=mscLpDS1ChanTcSignalOneDuration, mscLpSonetPathOperEntry=mscLpSonetPathOperEntry, mscLpDS3DS1ControlStatus=mscLpDS3DS1ControlStatus, mscLpE1ChanActualChannelSpeed=mscLpE1ChanActualChannelSpeed, mscLpDS1StateEntry=mscLpDS1StateEntry, mscLpSonetPathCidDataEntry=mscLpSonetPathCidDataEntry, mscLpSdhPathOperEntry=mscLpSdhPathOperEntry, mscLpSonetAdminInfoEntry=mscLpSonetAdminInfoEntry, mscLpE1CidDataEntry=mscLpE1CidDataEntry, mscLpSonetPathCellProvTable=mscLpSonetPathCellProvTable, mscLpSonetTestElapsedTime=mscLpSonetTestElapsedTime, mscLpJT2TestFrmRx=mscLpJT2TestFrmRx, mscLpDS3DS1ChanTc=mscLpDS3DS1ChanTc, mscLpCapTable=mscLpCapTable, mscLpJT2ErroredSec=mscLpJT2ErroredSec, mscLpSonetPathProvTable=mscLpSonetPathProvTable, mscLpEngStorageType=mscLpEngStorageType, mscLpE1ChanRowStatus=mscLpE1ChanRowStatus, mscLpDS1ChanRowStatusEntry=mscLpDS1ChanRowStatusEntry, mscLpDS1TestOperationalState=mscLpDS1TestOperationalState, mscLpDS1CustomerIdentifier=mscLpDS1CustomerIdentifier, mscLpDS1ChanTcSigTwoValue=mscLpDS1ChanTcSigTwoValue, mscLpJT2IfIndex=mscLpJT2IfIndex, mscLpDS3Plcp=mscLpDS3Plcp, mscLpDS1TestFrmPatternType=mscLpDS1TestFrmPatternType, mscLpE1ErrorFreeSec=mscLpE1ErrorFreeSec, mscLpDS1IfIndex=mscLpDS1IfIndex, mscLpV35RowStatusTable=mscLpV35RowStatusTable, mscLpHssiOperStatusTable=mscLpHssiOperStatusTable, mscLpDS3AdminInfoEntry=mscLpDS3AdminInfoEntry, mscLpDS1ChanTestStateTable=mscLpDS1ChanTestStateTable, mscLpDS3DS1TestIndex=mscLpDS3DS1TestIndex, mscLpE3CellStatsEntry=mscLpE3CellStatsEntry, mscLpHssiRowStatusTable=mscLpHssiRowStatusTable, mscLpE1DspComponentName=mscLpE1DspComponentName, mscLpDS3Mapping=mscLpDS3Mapping, mscLpE3LineLosSec=mscLpE3LineLosSec, mscLpSonetLineErroredSec=mscLpSonetLineErroredSec, mscLpE1ChanTcIndex=mscLpE1ChanTcIndex, mscLpE3PlcpRowStatusEntry=mscLpE3PlcpRowStatusEntry, mscLpHssiTestRowStatusTable=mscLpHssiTestRowStatusTable, mscLpE3G832ProvisionedEntry=mscLpE3G832ProvisionedEntry, mscLpDS3DS1ChanCellAlarmActDelay=mscLpDS3DS1ChanCellAlarmActDelay, mscLpSdhLosAlarm=mscLpSdhLosAlarm, mscLpE1ChanTestDataStartDelay=mscLpE1ChanTestDataStartDelay, mscLpHssiStorageType=mscLpHssiStorageType, mscLpE1ErroredSec=mscLpE1ErroredSec, mscLpJT2SevErroredSec=mscLpJT2SevErroredSec, mscLpE1RunningTime=mscLpE1RunningTime, mscLpSdhPathControlStatus=mscLpSdhPathControlStatus, mscLpSonetFarEndLineAisSec=mscLpSonetFarEndLineAisSec, mscLpE3PathSefAisSec=mscLpE3PathSefAisSec, mscLpDS1ChanTestFrmTx=mscLpDS1ChanTestFrmTx, mscLpE1LosAlarm=mscLpE1LosAlarm, mscLpSdhPathPathCodeViolations=mscLpSdhPathPathCodeViolations, mscLpX21TestStateTable=mscLpX21TestStateTable, mscLpE3G832RowStatusEntry=mscLpE3G832RowStatusEntry, mscLpSdhStateTable=mscLpSdhStateTable, mscLpDS1TxRaiAlarm=mscLpDS1TxRaiAlarm, mscLpE1ChanTestOperationalState=mscLpE1ChanTestOperationalState, mscLpE1ChanTestRowStatusEntry=mscLpE1ChanTestRowStatusEntry, mscLpLinkToApplicationsEntry=mscLpLinkToApplicationsEntry, mscLpDS1ChanIfEntryTable=mscLpDS1ChanIfEntryTable, mscLpSonetLineCodeViolations=mscLpSonetLineCodeViolations, mscLpDS3TestDisplayInterval=mscLpDS3TestDisplayInterval, mscLpE1AudioStorageType=mscLpE1AudioStorageType, mscLpJT2TestSetupEntry=mscLpJT2TestSetupEntry, mscLpV35TestBitsRx=mscLpV35TestBitsRx, mscLpSdhPathCellStatsTable=mscLpSdhPathCellStatsTable, mscLpHssiUsageState=mscLpHssiUsageState, mscLpE3TestBitsRx=mscLpE3TestBitsRx, mscLpHssiTestCauseOfTermination=mscLpHssiTestCauseOfTermination, mscLpDS3TestBytesTx=mscLpDS3TestBytesTx, mscLpDS1AdminInfoTable=mscLpDS1AdminInfoTable, mscLpSdhAdminInfoEntry=mscLpSdhAdminInfoEntry, mscLpEngRowStatusTable=mscLpEngRowStatusTable, mscLpJT2ControlStatus=mscLpJT2ControlStatus, mscLpDS3DS1ChanCellProvEntry=mscLpDS3DS1ChanCellProvEntry, mscLpHssiOperTable=mscLpHssiOperTable, mscLpE1E1OperEntry=mscLpE1E1OperEntry, mscLpDS1TestRowStatusEntry=mscLpDS1TestRowStatusEntry, mscLpDS1ChanTestIndex=mscLpDS1ChanTestIndex, mscLpE1ChanTestAdminState=mscLpE1ChanTestAdminState, mscLpDS1TestBytesRx=mscLpDS1TestBytesRx, mscLpDS3DS1ChanTcProvTable=mscLpDS3DS1ChanTcProvTable, mscLpSonetPathProvEntry=mscLpSonetPathProvEntry, mscLpX21TestRowStatusTable=mscLpX21TestRowStatusTable, mscLpOperEntry=mscLpOperEntry, mscLpE3PlcpComponentName=mscLpE3PlcpComponentName, mscLpSdhPathCellRowStatusTable=mscLpSdhPathCellRowStatusTable, mscLpV35TestOperationalState=mscLpV35TestOperationalState, mscLpE1ProceduralStatus=mscLpE1ProceduralStatus, mscLpV35StateEntry=mscLpV35StateEntry, mscLpE1ChanAvailabilityStatus=mscLpE1ChanAvailabilityStatus, logicalProcessorCapabilitiesCA02A=logicalProcessorCapabilitiesCA02A, mscLpJT2IfEntryEntry=mscLpJT2IfEntryEntry, mscLpX21StandbyStatus=mscLpX21StandbyStatus, mscLpDS1ChanTestResultsEntry=mscLpDS1ChanTestResultsEntry, mscLpV35TestFrmPatternType=mscLpV35TestFrmPatternType, mscLpV35TestTimeRemaining=mscLpV35TestTimeRemaining, mscLpX21TestSetupTable=mscLpX21TestSetupTable, mscLpSdhPathRowStatusTable=mscLpSdhPathRowStatusTable, mscLpJT2TestType=mscLpJT2TestType, mscLpDS3TestSetupTable=mscLpDS3TestSetupTable, mscLpDS1ChanTcStorageType=mscLpDS1ChanTcStorageType, mscLpUsageState=mscLpUsageState, mscLpX21ReadyLineState=mscLpX21ReadyLineState, mscLpSonetLineAisSec=mscLpSonetLineAisSec, mscLpSdhPathFarEndPathUnavailSec=mscLpSdhPathFarEndPathUnavailSec, mscLpHssiTestSetupTable=mscLpHssiTestSetupTable, mscLpDS3PlcpCodingViolations=mscLpDS3PlcpCodingViolations, mscLpE1MultifrmLofAlarm=mscLpE1MultifrmLofAlarm, mscLpE1ChanCellLcdAlarm=mscLpE1ChanCellLcdAlarm, mscLpHssiLineState=mscLpHssiLineState, mscLpE1E1OperTable=mscLpE1E1OperTable, mscLpJT2StandbyStatus=mscLpJT2StandbyStatus, mscLpDS1ChanAvailabilityStatus=mscLpDS1ChanAvailabilityStatus, mscLpE1ChanIfEntryEntry=mscLpE1ChanIfEntryEntry, mscLpV35DataXferStateChanges=mscLpV35DataXferStateChanges, mscLpDS3DS1ChanTestSetupEntry=mscLpDS3DS1ChanTestSetupEntry, mscLpE1ChanTcSigOneTable=mscLpE1ChanTcSigOneTable, mscLpX21TestRowStatusEntry=mscLpX21TestRowStatusEntry, mscLpDS1SevErroredFrmSec=mscLpDS1SevErroredFrmSec, mscLpDS1ChanTestBytesRx=mscLpDS1ChanTestBytesRx, mscLpE1AdminInfoTable=mscLpE1AdminInfoTable, mscLpJT2CellOperTable=mscLpJT2CellOperTable, mscLpSdhPathTxAis=mscLpSdhPathTxAis, mscLpMemoryUsageValue=mscLpMemoryUsageValue, mscLpSdhRxAisAlarm=mscLpSdhRxAisAlarm, mscLpJT2OperStatusTable=mscLpJT2OperStatusTable, mscLpE3PathErroredSec=mscLpE3PathErroredSec, mscLpSdhFarEndLineSevErroredSec=mscLpSdhFarEndLineSevErroredSec, mscLpE1Audio=mscLpE1Audio, mscLpSonetTestBitsTx=mscLpSonetTestBitsTx, mscLpV35TestBitsTx=mscLpV35TestBitsTx, mscLpE3CellComponentName=mscLpE3CellComponentName, mscLpX21TestStateEntry=mscLpX21TestStateEntry, mscLpHssiTestAdminState=mscLpHssiTestAdminState, mscLpJT2RxRaiAlarm=mscLpJT2RxRaiAlarm, mscLpE1AdminState=mscLpE1AdminState, mscLpDS3DS1ChanTestSetupTable=mscLpDS3DS1ChanTestSetupTable, mscLpX21TestFrmPatternType=mscLpX21TestFrmPatternType, mscLpE1CidDataTable=mscLpE1CidDataTable, mscLpDS3PlcpOperationalEntry=mscLpDS3PlcpOperationalEntry, mscLpDS1ChanCellStatsTable=mscLpDS1ChanCellStatsTable, mscLpE1TestDisplayInterval=mscLpE1TestDisplayInterval, mscLpHssiActualTxLineSpeed=mscLpHssiActualTxLineSpeed, mscLpE3TestFrmTx=mscLpE3TestFrmTx, mscLpDS3DS1ChanAvailabilityStatus=mscLpDS3DS1ChanAvailabilityStatus, mscLpDS3DS1ChanProceduralStatus=mscLpDS3DS1ChanProceduralStatus, mscLpHssiDataXferStateChanges=mscLpHssiDataXferStateChanges, mscLpSdhTestBytesTx=mscLpSdhTestBytesTx, mscLpHssiTestDisplayInterval=mscLpHssiTestDisplayInterval, mscLpE1ChanTestResultsEntry=mscLpE1ChanTestResultsEntry, mscLpDS1ChanStandbyStatus=mscLpDS1ChanStandbyStatus, mscLpDS3TestComponentName=mscLpDS3TestComponentName, mscLpE1ChanFlmComponentName=mscLpE1ChanFlmComponentName, mscLpV35TestAdminState=mscLpV35TestAdminState, mscLpE3TestType=mscLpE3TestType, mscLpSonetPathFarEndPathErrorFreeSec=mscLpSonetPathFarEndPathErrorFreeSec, mscLpDS3RowStatusTable=mscLpDS3RowStatusTable, mscLpSonetIfAdminStatus=mscLpSonetIfAdminStatus, mscLpE1RowStatusTable=mscLpE1RowStatusTable, mscLpSdhTestFrmRx=mscLpSdhTestFrmRx, mscLpX21TestRowStatus=mscLpX21TestRowStatus, mscLpE1ChanCustomerIdentifier=mscLpE1ChanCustomerIdentifier, mscLpSdhClockingSource=mscLpSdhClockingSource)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpDS3DS1TestStateTable=mscLpDS3DS1TestStateTable, mscLpV35ActualTxLineSpeed=mscLpV35ActualTxLineSpeed, mscLpJT2AvailabilityStatus=mscLpJT2AvailabilityStatus, mscLpDS3TestPurpose=mscLpDS3TestPurpose, mscLpX21Test=mscLpX21Test, mscLpX21TestBitErrorRate=mscLpX21TestBitErrorRate, mscLpDS1ChanCellIndex=mscLpDS1ChanCellIndex, mscLpSdhPathLopAlarm=mscLpSdhPathLopAlarm, mscLpE1ChanCellReceiveCellUtilization=mscLpE1ChanCellReceiveCellUtilization, mscLpX21IfIndex=mscLpX21IfIndex, mscLpX21RowStatus=mscLpX21RowStatus, mscLpE1UnavailSec=mscLpE1UnavailSec, mscLpDS3DS1ChanTestBitsRx=mscLpDS3DS1ChanTestBitsRx, mscLpE1SnmpOperStatus=mscLpE1SnmpOperStatus, mscLpJT2CidDataEntry=mscLpJT2CidDataEntry, mscLpV35TestDataStartDelay=mscLpV35TestDataStartDelay, mscLpSdhOperTable=mscLpSdhOperTable, mscLpDS1ChanComponentName=mscLpDS1ChanComponentName, mscLpDS3DS1ChanTcOpTable=mscLpDS3DS1ChanTcOpTable, mscLpSonetTestAdminState=mscLpSonetTestAdminState, mscLpJT2TestBitErrorRate=mscLpJT2TestBitErrorRate, mscLpDS3DS1StateTable=mscLpDS3DS1StateTable, mscLpE3ProceduralStatus=mscLpE3ProceduralStatus, mscLpDS1ChanCellComponentName=mscLpDS1ChanCellComponentName, mscLpDS1ChanTcRowStatusTable=mscLpDS1ChanTcRowStatusTable, mscLpSonetOperEntry=mscLpSonetOperEntry, mscLpE1ChanTestRowStatusTable=mscLpE1ChanTestRowStatusTable, mscLpSdhLineUnavailSec=mscLpSdhLineUnavailSec, mscLpDS1ChanUnknownStatus=mscLpDS1ChanUnknownStatus, mscLpE3TestDuration=mscLpE3TestDuration, mscLpHssiActualLinkMode=mscLpHssiActualLinkMode, mscLpE3CellOperTable=mscLpE3CellOperTable, mscLpE3Index=mscLpE3Index, mscLpJT2ErrorFreeSec=mscLpJT2ErrorFreeSec, mscLpSonetPathTxAis=mscLpSonetPathTxAis, mscLpMemoryUsageAvgMinIndex=mscLpMemoryUsageAvgMinIndex, mscLpDS3DS1TestDataStartDelay=mscLpDS3DS1TestDataStartDelay, mscLpV35ActualRxLineSpeed=mscLpV35ActualRxLineSpeed, mscLpE1TestPurpose=mscLpE1TestPurpose, mscLpE1TxRaiAlarm=mscLpE1TxRaiAlarm, mscLpJT2IfAdminStatus=mscLpJT2IfAdminStatus, mscLpSonetPathPathCodeViolations=mscLpSonetPathPathCodeViolations, mscLpJT2TestDataStartDelay=mscLpJT2TestDataStartDelay, mscLpV35ComponentName=mscLpV35ComponentName, mscLpX21LineTerminationRequired=mscLpX21LineTerminationRequired, mscLpE1ChanIfIndex=mscLpE1ChanIfIndex, mscLpDS3DS1AdminState=mscLpDS3DS1AdminState, mscLpSdhProvEntry=mscLpSdhProvEntry, mscLpDS3TestStateEntry=mscLpDS3TestStateEntry, mscLpV35Index=mscLpV35Index, mscLpJT2AdminInfoEntry=mscLpJT2AdminInfoEntry, mscLpE1StateEntry=mscLpE1StateEntry, mscLpSonetUnusableTxClockRefAlarm=mscLpSonetUnusableTxClockRefAlarm, mscLpJT2CidDataTable=mscLpJT2CidDataTable, mscLpV35IfEntryTable=mscLpV35IfEntryTable, mscLpHssiDataTransferLineState=mscLpHssiDataTransferLineState, mscLpE3G832FarEndErrorFreeSec=mscLpE3G832FarEndErrorFreeSec, mscLpV35StorageType=mscLpV35StorageType, mscLpHssiIndex=mscLpHssiIndex, mscLpDS3DS1SlipErrors=mscLpDS3DS1SlipErrors, mscLpX21TestErroredFrmRx=mscLpX21TestErroredFrmRx, mscLpE1ProvEntry=mscLpE1ProvEntry, mscLpE3CellLcdAlarm=mscLpE3CellLcdAlarm, mscLpE1TestRowStatusEntry=mscLpE1TestRowStatusEntry, mscLpDS3DS1AdminInfoEntry=mscLpDS3DS1AdminInfoEntry, mscLpDS3DS1TestResultsTable=mscLpDS3DS1TestResultsTable, mscLpE3CellStorageType=mscLpE3CellStorageType, mscLpDS1ChanStateTable=mscLpDS1ChanStateTable, mscLpE1ChanFlmFlmStatus=mscLpE1ChanFlmFlmStatus, mscLpJT2RowStatusEntry=mscLpJT2RowStatusEntry, mscLpSonetPathCellProvEntry=mscLpSonetPathCellProvEntry, mscLpDS1ChanCellProvTable=mscLpDS1ChanCellProvTable, mscLpV35StandbyStatus=mscLpV35StandbyStatus, mscLpJT2TestErroredFrmRx=mscLpJT2TestErroredFrmRx, mscLpJT2CellProvTable=mscLpJT2CellProvTable, mscLpEngDsOvRowStatusTable=mscLpEngDsOvRowStatusTable, mscLpMemoryUsageEntry=mscLpMemoryUsageEntry, mscLpX21TestStorageType=mscLpX21TestStorageType, mscLpHssi=mscLpHssi, mscLpE1ChanTestResultsTable=mscLpE1ChanTestResultsTable, mscLpDS1TestResultsTable=mscLpDS1TestResultsTable, mscLpDS3DS1TestUsageState=mscLpDS3DS1TestUsageState, mscLpE1ChanCellRowStatusEntry=mscLpE1ChanCellRowStatusEntry, mscLpSonetLofAlarm=mscLpSonetLofAlarm, mscLpSonetFarEndLineSevErroredSec=mscLpSonetFarEndLineSevErroredSec, mscLpSdhPathOperStatusTable=mscLpSdhPathOperStatusTable, mscLpE3TestFrmRx=mscLpE3TestFrmRx, mscLpE3G832TrailTraceExpected=mscLpE3G832TrailTraceExpected, mscLpX21OperEntry=mscLpX21OperEntry, logicalProcessorGroupCA02=logicalProcessorGroupCA02, mscLpSonetPathFarEndPathSevErroredSec=mscLpSonetPathFarEndPathSevErroredSec, mscLpE1ChanTcOpTable=mscLpE1ChanTcOpTable, mscLpDS1ChanTcProvTable=mscLpDS1ChanTcProvTable, mscLpSdhTestStateTable=mscLpSdhTestStateTable, mscLpX21AdminInfoEntry=mscLpX21AdminInfoEntry, mscLpE1ChanIfEntryTable=mscLpE1ChanIfEntryTable, mscLpV35CidDataTable=mscLpV35CidDataTable, mscLpSonetTestErroredFrmRx=mscLpSonetTestErroredFrmRx, mscLpProvEntry=mscLpProvEntry, mscLpE3TestStateTable=mscLpE3TestStateTable, mscLpE3Vendor=mscLpE3Vendor, mscLpE1ChanTestComponentName=mscLpE1ChanTestComponentName, mscLpSdhUsageState=mscLpSdhUsageState, mscLpE1AudioComponentName=mscLpE1AudioComponentName, mscLpJT2IfEntryTable=mscLpJT2IfEntryTable, mscLpAvailabilityStatus=mscLpAvailabilityStatus, mscLpX21TestResultsTable=mscLpX21TestResultsTable, mscLpDS3DS1ChanTestCustomizedPattern=mscLpDS3DS1ChanTestCustomizedPattern, mscLpDS3DS1ChanAdminInfoEntry=mscLpDS3DS1ChanAdminInfoEntry, mscLpDS3DS1CommentText=mscLpDS3DS1CommentText, mscLpHssiProvEntry=mscLpHssiProvEntry, mscLpDS3DS1ChanCellTransmitCellUtilization=mscLpDS3DS1ChanCellTransmitCellUtilization, mscLpMemoryUsageAvgMaxTable=mscLpMemoryUsageAvgMaxTable, mscLpSdhStorageType=mscLpSdhStorageType, mscLpE3StandbyStatus=mscLpE3StandbyStatus, mscLpDS3CBitFarEndErroredSec=mscLpDS3CBitFarEndErroredSec, mscLpE1ChanCellStatsEntry=mscLpE1ChanCellStatsEntry, mscLpSdhPathCellStatsEntry=mscLpSdhPathCellStatsEntry, mscLpE3AdminState=mscLpE3AdminState, mscLpSonetSectSevErroredSec=mscLpSonetSectSevErroredSec, mscLpX21DteDataClockSource=mscLpX21DteDataClockSource, mscLpE3UsageState=mscLpE3UsageState, mscLpDS3DS1StandbyStatus=mscLpDS3DS1StandbyStatus, mscLpDS3DS1ChanTcIngressConditioning=mscLpDS3DS1ChanTcIngressConditioning, mscLpHssiCommentText=mscLpHssiCommentText, mscLpDS3DS1ChanRowStatusEntry=mscLpDS3DS1ChanRowStatusEntry, mscLpSdhPathCellReceiveCellUtilization=mscLpSdhPathCellReceiveCellUtilization, mscLpE1TestResultsTable=mscLpE1TestResultsTable, mscLpDS3DS1ChanIndex=mscLpDS3DS1ChanIndex, mscLpSdhTestCustomizedPattern=mscLpSdhTestCustomizedPattern, mscLpHssiTestBitsTx=mscLpHssiTestBitsTx, mscLpDS3CBitStorageType=mscLpDS3CBitStorageType, mscLpDS3StateEntry=mscLpDS3StateEntry, mscLpHssiComponentName=mscLpHssiComponentName, mscLpDS1ChanTestComponentName=mscLpDS1ChanTestComponentName, mscLpSdhTestRowStatusEntry=mscLpSdhTestRowStatusEntry, mscLpJT2StatsEntry=mscLpJT2StatsEntry, mscLpDS3DS1ChanCellStorageType=mscLpDS3DS1ChanCellStorageType, mscLpX21Vendor=mscLpX21Vendor, mscLpSonetPathPathAisLopSec=mscLpSonetPathPathAisLopSec, mscLpSdhFarEndLineFailures=mscLpSdhFarEndLineFailures, mscLpSdhSectSevErroredFrmSec=mscLpSdhSectSevErroredFrmSec, mscLpDS3TestFrmSize=mscLpDS3TestFrmSize, mscLpV35TestSetupTable=mscLpV35TestSetupTable, mscLpV35TestBitErrorRate=mscLpV35TestBitErrorRate, mscLpSdhPathRowStatus=mscLpSdhPathRowStatus, mscLpE3G832FarEndSevErroredSec=mscLpE3G832FarEndSevErroredSec, mscLpSonetPathCellSevErroredSec=mscLpSonetPathCellSevErroredSec, logicalProcessorGroupCA=logicalProcessorGroupCA, mscLpE3UnknownStatus=mscLpE3UnknownStatus, mscLpDS3DS1ChanTcReplacementData=mscLpDS3DS1ChanTcReplacementData, mscLpHssiCidDataTable=mscLpHssiCidDataTable, mscLpSonetTestOperationalState=mscLpSonetTestOperationalState, mscLpDS3CellStatsEntry=mscLpDS3CellStatsEntry, mscLpE1ChanTcStorageType=mscLpE1ChanTcStorageType, mscLpDS1TestBytesTx=mscLpDS1TestBytesTx, mscLpSdhIfEntryTable=mscLpSdhIfEntryTable, mscLpE1TestBytesTx=mscLpE1TestBytesTx, mscLpHssiTestPurpose=mscLpHssiTestPurpose, mscLpSonetPathCustomerIdentifier=mscLpSonetPathCustomerIdentifier, mscLpDS3DS1ChanTestRowStatusTable=mscLpDS3DS1ChanTestRowStatusTable, mscLpSdhPathUsageState=mscLpSdhPathUsageState, mscLpE3PlcpErroredSec=mscLpE3PlcpErroredSec, mscLpSonetStateTable=mscLpSonetStateTable, mscLpSonetPathStateTable=mscLpSonetPathStateTable, mscLpEngRowStatus=mscLpEngRowStatus, mscLpSonetPathSignalLabelMismatch=mscLpSonetPathSignalLabelMismatch, mscLpDS3PathSefAisSec=mscLpDS3PathSefAisSec, mscLpMainCard=mscLpMainCard, mscLpSonetStandbyStatus=mscLpSonetStandbyStatus, mscLpSonetProvEntry=mscLpSonetProvEntry, mscLpE3IfAdminStatus=mscLpE3IfAdminStatus, mscLpHssiTestBitErrorRate=mscLpHssiTestBitErrorRate, mscLpSonetAvailabilityStatus=mscLpSonetAvailabilityStatus, mscLpDS1RowStatusEntry=mscLpDS1RowStatusEntry, mscLpSonetUnknownStatus=mscLpSonetUnknownStatus, mscLpV35TestSetupEntry=mscLpV35TestSetupEntry, mscLpMsgBlockUsage=mscLpMsgBlockUsage, mscLpHssiTestFrmPatternType=mscLpHssiTestFrmPatternType, mscLpJT2CellUncorrectableHecErrors=mscLpJT2CellUncorrectableHecErrors, mscLpSonetTestFrmPatternType=mscLpSonetTestFrmPatternType, mscLpSdhStatsTable=mscLpSdhStatsTable, mscLpHssiApplicationFramerName=mscLpHssiApplicationFramerName, mscLpE1TestDataStartDelay=mscLpE1TestDataStartDelay, mscLpDS1ChanCellReceiveCellUtilization=mscLpDS1ChanCellReceiveCellUtilization, mscLpDS3DS1ChanTcSigTwoTable=mscLpDS3DS1ChanTcSigTwoTable, mscLpDS3DS1ChanTcSigOneIndex=mscLpDS3DS1ChanTcSigOneIndex, mscLpE3TestCustomizedPattern=mscLpE3TestCustomizedPattern, mscLpDS1ChanTestSetupTable=mscLpDS1ChanTestSetupTable, mscLpJT2TestCauseOfTermination=mscLpJT2TestCauseOfTermination, mscLpSdhPathPathUnavailSec=mscLpSdhPathPathUnavailSec, mscLpDS1ChanTcRowStatusEntry=mscLpDS1ChanTcRowStatusEntry, mscLpDS1ChanCellRowStatusEntry=mscLpDS1ChanCellRowStatusEntry, mscLpSdhIfEntryEntry=mscLpSdhIfEntryEntry, mscLpDS1ErroredSec=mscLpDS1ErroredSec, mscLpE1ChanRowStatusTable=mscLpE1ChanRowStatusTable, mscLpE3RunningTime=mscLpE3RunningTime, mscLpSonetAdminInfoTable=mscLpSonetAdminInfoTable, mscLpDS3CellReceiveCellUtilization=mscLpDS3CellReceiveCellUtilization, mscLpDS1AvailabilityStatus=mscLpDS1AvailabilityStatus, mscLpV35TestStateEntry=mscLpV35TestStateEntry, mscLpSdhTestType=mscLpSdhTestType, mscLpDS1DspRowStatus=mscLpDS1DspRowStatus, mscLpX21TestFrmTx=mscLpX21TestFrmTx, mscLpE1SlipErrors=mscLpE1SlipErrors, mscLpJT2LineLength=mscLpJT2LineLength, mscLpE1ChanTestPurpose=mscLpE1ChanTestPurpose, mscLpE1TestBytesRx=mscLpE1TestBytesRx, mscLpDS1OperEntry=mscLpDS1OperEntry, mscLpDS1ChanOperationalState=mscLpDS1ChanOperationalState, mscLpDS1TestPurpose=mscLpDS1TestPurpose, mscLpEng=mscLpEng, mscLpSdhPathPathErroredSec=mscLpSdhPathPathErroredSec, mscLpSdhPathCellIndex=mscLpSdhPathCellIndex, mscLpDS1AudioRowStatusEntry=mscLpDS1AudioRowStatusEntry, mscLpDS1RxRaiAlarm=mscLpDS1RxRaiAlarm, mscLpDS1TestType=mscLpDS1TestType, mscLpSonetPathUsageState=mscLpSonetPathUsageState, mscLpDS1ChanCellCorrectSingleBitHeaderErrors=mscLpDS1ChanCellCorrectSingleBitHeaderErrors, mscLpE3ErrorFreeSec=mscLpE3ErrorFreeSec, mscLpE3PlcpLofAlarm=mscLpE3PlcpLofAlarm, mscLpX21AdminState=mscLpX21AdminState, mscLpV35TestFrmRx=mscLpV35TestFrmRx, mscLpHssiLinkMode=mscLpHssiLinkMode, mscLpDS1DspRowStatusTable=mscLpDS1DspRowStatusTable, mscLpV35SnmpOperStatus=mscLpV35SnmpOperStatus, mscLpV35LineSpeed=mscLpV35LineSpeed, mscLpJT2CustomerIdentifier=mscLpJT2CustomerIdentifier, mscLpE3StorageType=mscLpE3StorageType, mscLpHssiCidDataEntry=mscLpHssiCidDataEntry, mscLpSdhIndex=mscLpSdhIndex, mscLpDS3DS1IfIndex=mscLpDS3DS1IfIndex, mscLpE3G832StatsEntry=mscLpE3G832StatsEntry, mscLpSdhCidDataTable=mscLpSdhCidDataTable, mscLpDS3DS1ChanIfAdminStatus=mscLpDS3DS1ChanIfAdminStatus, mscLpE1TestStateTable=mscLpE1TestStateTable, mscLpE3OperStatusEntry=mscLpE3OperStatusEntry, mscLpSdhFarEndLineCodeViolations=mscLpSdhFarEndLineCodeViolations, mscLpE3PlcpStatsTable=mscLpE3PlcpStatsTable, mscLpDS3CidDataTable=mscLpDS3CidDataTable, mscLpSdhTestStorageType=mscLpSdhTestStorageType, mscLpSdhOperStatusEntry=mscLpSdhOperStatusEntry, mscLpJT2CellAlarmActDelay=mscLpJT2CellAlarmActDelay, mscLpSonetTestCustomizedPattern=mscLpSonetTestCustomizedPattern, mscLpSonetTestStateTable=mscLpSonetTestStateTable, mscLpSdhComponentName=mscLpSdhComponentName, mscLpSonetPathTxRdi=mscLpSonetPathTxRdi, mscLpE1ProvTable=mscLpE1ProvTable, mscLpJT2CellTransmitCellUtilization=mscLpJT2CellTransmitCellUtilization, mscLpDS1ChanTcRowStatus=mscLpDS1ChanTcRowStatus, mscLpX21OperationalState=mscLpX21OperationalState, mscLpJT2CellScrambleCellPayload=mscLpJT2CellScrambleCellPayload, mscLpDS3CbitParity=mscLpDS3CbitParity, mscLpDS3DS1ChanCellCorrectSingleBitHeaderErrors=mscLpDS3DS1ChanCellCorrectSingleBitHeaderErrors)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpDS3DS1AvailabilityStatus=mscLpDS3DS1AvailabilityStatus, mscLpDS1TestAdminState=mscLpDS1TestAdminState, mscLpE1AvailabilityStatus=mscLpE1AvailabilityStatus, mscLpHssiLineSpeed=mscLpHssiLineSpeed, mscLpSdhPathPathAisLopSec=mscLpSdhPathPathAisLopSec, mscLpDS3CBitCbitCodeViolations=mscLpDS3CBitCbitCodeViolations, mscLpDS1ChanTestCauseOfTermination=mscLpDS1ChanTestCauseOfTermination, mscLpDS1SnmpOperStatus=mscLpDS1SnmpOperStatus, mscLpE1ChanTcReplacementData=mscLpE1ChanTcReplacementData, mscLpSdhTestOperationalState=mscLpSdhTestOperationalState, mscLpSonetPathPathErroredSec=mscLpSonetPathPathErroredSec, mscLpDS3DS1ChanTestFrmSize=mscLpDS3DS1ChanTestFrmSize, mscLpMemoryUsageAvgIndex=mscLpMemoryUsageAvgIndex, mscLpDS3PlcpErroredSec=mscLpDS3PlcpErroredSec, mscLpX21CidDataTable=mscLpX21CidDataTable, mscLpSdhTestFrmPatternType=mscLpSdhTestFrmPatternType, mscLpDS3DS1ChanApplicationFramerName=mscLpDS3DS1ChanApplicationFramerName, mscLpSonetPathPathUnavailSec=mscLpSonetPathPathUnavailSec, mscLpE1ChanProceduralStatus=mscLpE1ChanProceduralStatus, mscLpE1OperStatusEntry=mscLpE1OperStatusEntry, mscLpDS1AudioIndex=mscLpDS1AudioIndex, mscLpDS3IfIndex=mscLpDS3IfIndex, mscLpDS1AdminState=mscLpDS1AdminState, mscLpDS1ChanControlStatus=mscLpDS1ChanControlStatus, mscLpDS3SnmpOperStatus=mscLpDS3SnmpOperStatus, mscLpE1AlarmStatus=mscLpE1AlarmStatus, mscLpV35IfAdminStatus=mscLpV35IfAdminStatus, mscLpDS1OperStatusTable=mscLpDS1OperStatusTable, mscLpE3CellReceiveCellUtilization=mscLpE3CellReceiveCellUtilization, mscLpE1TestFrmRx=mscLpE1TestFrmRx, mscLpDS1TestStorageType=mscLpDS1TestStorageType, mscLpSdhSectFailures=mscLpSdhSectFailures, mscLpJT2CellCorrectableHeaderErrors=mscLpJT2CellCorrectableHeaderErrors, mscLpE1ChanTestFrmSize=mscLpE1ChanTestFrmSize, mscLpJT2TestResultsTable=mscLpJT2TestResultsTable, mscLpE1ChanTestUsageState=mscLpE1ChanTestUsageState, mscLpHssiTestErroredFrmRx=mscLpHssiTestErroredFrmRx, mscLpX21UnknownStatus=mscLpX21UnknownStatus, mscLpE1ComponentName=mscLpE1ComponentName, mscLpV35TestPurpose=mscLpV35TestPurpose, mscLpDS3DS1LineType=mscLpDS3DS1LineType, mscLpSonetPath=mscLpSonetPath, mscLpSdhAlarmStatus=mscLpSdhAlarmStatus, mscLpE1ChanCellStorageType=mscLpE1ChanCellStorageType, mscLpDS3DS1ChanTestStateEntry=mscLpDS3DS1ChanTestStateEntry, mscLpDS3ProvTable=mscLpDS3ProvTable, mscLpDS3CBitCbitSevErroredSec=mscLpDS3CBitCbitSevErroredSec, mscLpE3PlcpUnavailSec=mscLpE3PlcpUnavailSec, mscLpDS1TestStateTable=mscLpDS1TestStateTable, mscLpDS1ChanSnmpOperStatus=mscLpDS1ChanSnmpOperStatus, mscLpSdhPathCellAlarmActDelay=mscLpSdhPathCellAlarmActDelay, mscLpSdhPathStandbyStatus=mscLpSdhPathStandbyStatus, mscLpX21ActualTxLineSpeed=mscLpX21ActualTxLineSpeed, mscLpDS3DS1ProvEntry=mscLpDS3DS1ProvEntry, mscLpDS1RowStatus=mscLpDS1RowStatus, mscLpDS3ControlStatus=mscLpDS3ControlStatus, mscLpDS3DS1Index=mscLpDS3DS1Index, mscLpDS3OperStatusEntry=mscLpDS3OperStatusEntry, mscLpDS3DS1ChanComponentName=mscLpDS3DS1ChanComponentName, mscLpJT2BpvErrors=mscLpJT2BpvErrors, mscLpDS1ChanTestType=mscLpDS1ChanTestType, mscLpE1ChanCellRowStatus=mscLpE1ChanCellRowStatus, mscLpDS1ChanCellScrambleCellPayload=mscLpDS1ChanCellScrambleCellPayload, mscLpSonetPathControlStatus=mscLpSonetPathControlStatus, mscLpDS1TestBitErrorRate=mscLpDS1TestBitErrorRate, mscLpSdhFarEndLineErrorFreeSec=mscLpSdhFarEndLineErrorFreeSec, mscLpDS3DS1ChanTestBitErrorRate=mscLpDS3DS1ChanTestBitErrorRate, mscLpJT2TestPurpose=mscLpJT2TestPurpose, mscLpSonetPathCellCorrectSingleBitHeaderErrors=mscLpSonetPathCellCorrectSingleBitHeaderErrors, mscLpE1TxMultifrmRaiAlarm=mscLpE1TxMultifrmRaiAlarm, mscLpSonetPathFarEndPathCodeViolations=mscLpSonetPathFarEndPathCodeViolations, mscLpDS3PlcpRxRaiAlarm=mscLpDS3PlcpRxRaiAlarm, mscLpDS3CellRowStatus=mscLpDS3CellRowStatus, mscLpE1AdminInfoEntry=mscLpE1AdminInfoEntry, mscLpHssiUnknownStatus=mscLpHssiUnknownStatus, mscLpE3TestRowStatusEntry=mscLpE3TestRowStatusEntry, mscLpE1AudioIndex=mscLpE1AudioIndex, mscLpE1ChanTcRowStatusTable=mscLpE1ChanTcRowStatusTable, mscLpCustomerIdentifier=mscLpCustomerIdentifier, mscLpSonetFarEndLineCodeViolations=mscLpSonetFarEndLineCodeViolations, mscLpHssiAlarmStatus=mscLpHssiAlarmStatus, mscLpSdhProvTable=mscLpSdhProvTable, mscLpDS1ChanOperStatusTable=mscLpDS1ChanOperStatusTable, mscLpE1ChanRowStatusEntry=mscLpE1ChanRowStatusEntry, mscLpDS1ChanProceduralStatus=mscLpDS1ChanProceduralStatus, mscLpV35AdminState=mscLpV35AdminState, mscLpE1SevErroredSec=mscLpE1SevErroredSec, mscLpE3G832FarEndSefAisSec=mscLpE3G832FarEndSefAisSec, mscLpE3G832TrailTraceTransmitted=mscLpE3G832TrailTraceTransmitted, mscLpSdhPathPathSevErroredSec=mscLpSdhPathPathSevErroredSec, mscLpDS1ChanTcSigTwoEntry=mscLpDS1ChanTcSigTwoEntry, mscLpSdhLineFailures=mscLpSdhLineFailures, mscLpE3RxRaiAlarm=mscLpE3RxRaiAlarm, mscLpSdhPathRowStatusEntry=mscLpSdhPathRowStatusEntry, mscLpDS1ChanProvEntry=mscLpDS1ChanProvEntry, mscLpDS3DS1ChanAdminState=mscLpDS3DS1ChanAdminState, mscLpSonetPathCellRowStatusTable=mscLpSonetPathCellRowStatusTable, mscLpE3TestResultsEntry=mscLpE3TestResultsEntry, mscLpDS3CBitFarEndSefAisSec=mscLpDS3CBitFarEndSefAisSec, mscLpDS1DspComponentName=mscLpDS1DspComponentName, mscLpX21TestType=mscLpX21TestType, mscLpDS1ChanCellLcdAlarm=mscLpDS1ChanCellLcdAlarm, mscLpDS1TxAisAlarm=mscLpDS1TxAisAlarm, mscLpDS1TestResultsEntry=mscLpDS1TestResultsEntry, mscLpX21StateTable=mscLpX21StateTable, mscLpDS3DS1TestRowStatusTable=mscLpDS3DS1TestRowStatusTable, mscLpDS3DS1ChanCellOperTable=mscLpDS3DS1ChanCellOperTable, mscLpE1ChanFlmRowStatusTable=mscLpE1ChanFlmRowStatusTable, mscLpE3TestTimeRemaining=mscLpE3TestTimeRemaining, mscLpDS3DS1TestBitErrorRate=mscLpDS3DS1TestBitErrorRate, mscLpProvTable=mscLpProvTable, mscLpMemoryCapacityEntry=mscLpMemoryCapacityEntry, mscLpE1OperationalState=mscLpE1OperationalState, mscLpJT2CellStatsTable=mscLpJT2CellStatsTable, mscLpE3PlcpSevErroredSec=mscLpE3PlcpSevErroredSec, mscLpSdhPathAdminState=mscLpSdhPathAdminState, mscLpDS1ChanTestDuration=mscLpDS1ChanTestDuration, mscLpDS3TestAdminState=mscLpDS3TestAdminState, mscLpJT2RowStatus=mscLpJT2RowStatus, mscLpDS1AudioRowStatus=mscLpDS1AudioRowStatus, mscLpSdhLineAisSec=mscLpSdhLineAisSec, mscLpDS3DS1ComponentName=mscLpDS3DS1ComponentName, mscLpE1Dsp=mscLpE1Dsp, mscLpSonetPathFarEndPathUnavailSec=mscLpSonetPathFarEndPathUnavailSec, mscLpDS3CellOperEntry=mscLpDS3CellOperEntry, mscLpEngDsRowStatusEntry=mscLpEngDsRowStatusEntry, mscLpV35ActualLinkMode=mscLpV35ActualLinkMode, mscLpDS3DS1AlarmStatus=mscLpDS3DS1AlarmStatus, mscLpDS3DS1FrmErrors=mscLpDS3DS1FrmErrors, mscLpSdhPathFarEndPathErroredSec=mscLpSdhPathFarEndPathErroredSec, mscLpE3CellProvTable=mscLpE3CellProvTable, mscLpSdhPathApplicationFramerName=mscLpSdhPathApplicationFramerName, mscLpE3RowStatus=mscLpE3RowStatus, mscLpDS3DS1ChanCustomerIdentifier=mscLpDS3DS1ChanCustomerIdentifier, mscLpHssiTestStateEntry=mscLpHssiTestStateEntry, mscLpDS1Index=mscLpDS1Index, mscLpDS3DS1OperStatusTable=mscLpDS3DS1OperStatusTable, mscLpDS3DS1ChanUnknownStatus=mscLpDS3DS1ChanUnknownStatus, mscLpE1ChanOperationalState=mscLpE1ChanOperationalState, mscLpE1TestResultsEntry=mscLpE1TestResultsEntry, mscLpE1RaiDeclareAlarmTime=mscLpE1RaiDeclareAlarmTime, mscLpHssiTest=mscLpHssiTest, mscLpDS1ChanTcReplacementData=mscLpDS1ChanTcReplacementData, mscLpDS3DS1SevErroredSec=mscLpDS3DS1SevErroredSec, mscLpSdhPathCidDataEntry=mscLpSdhPathCidDataEntry, mscLpAdminState=mscLpAdminState, mscLpSonetPathCellRowStatus=mscLpSonetPathCellRowStatus, mscLpDS3PlcpRowStatusTable=mscLpDS3PlcpRowStatusTable, mscLpE1StatsEntry=mscLpE1StatsEntry, mscLpDS3DS1TestFrmRx=mscLpDS3DS1TestFrmRx, mscLpSdhPathPathErrorFreeSec=mscLpSdhPathPathErrorFreeSec, mscLpDS3DS1StorageType=mscLpDS3DS1StorageType, mscLpDS1ChanUsageState=mscLpDS1ChanUsageState, mscLpSonetOperStatusEntry=mscLpSonetOperStatusEntry, mscLpSonetPathCellTransmitCellUtilization=mscLpSonetPathCellTransmitCellUtilization, mscLpSdhSectSevErroredSec=mscLpSdhSectSevErroredSec, mscLpDS3CBitCbitUnavailSec=mscLpDS3CBitCbitUnavailSec, mscLpDS3CellAlarmActDelay=mscLpDS3CellAlarmActDelay, mscLpDS1AdminInfoEntry=mscLpDS1AdminInfoEntry, mscLpDS3StateTable=mscLpDS3StateTable, mscLpDS1ChanCidDataEntry=mscLpDS1ChanCidDataEntry, mscLpSdhIfIndex=mscLpSdhIfIndex, mscLpE3TestFrmSize=mscLpE3TestFrmSize, mscLpSonetIfEntryEntry=mscLpSonetIfEntryEntry, mscLpDS3PlcpRowStatus=mscLpDS3PlcpRowStatus, mscLpDS1ChanStateEntry=mscLpDS1ChanStateEntry, mscLpDS3DS1ChanTestUsageState=mscLpDS3DS1ChanTestUsageState, mscLpE1ControlStatus=mscLpE1ControlStatus, mscLpE1TestRowStatus=mscLpE1TestRowStatus, mscLpJT2TestStateEntry=mscLpJT2TestStateEntry, mscLpE3TestPurpose=mscLpE3TestPurpose, mscLpDS3PlcpFarEndErrorFreeSec=mscLpDS3PlcpFarEndErrorFreeSec, mscLpE1DspRowStatusEntry=mscLpE1DspRowStatusEntry, mscLpV35StateTable=mscLpV35StateTable, mscLpDS3DS1ChanTcRowStatusTable=mscLpDS3DS1ChanTcRowStatusTable, mscLpSonetTestPurpose=mscLpSonetTestPurpose, mscLpE3G832OperationalEntry=mscLpE3G832OperationalEntry, mscLpDS1TestBitsRx=mscLpDS1TestBitsRx, mscLpDS1Chan=mscLpDS1Chan, mscLpE3PathFailures=mscLpE3PathFailures, mscLpUtilTable=mscLpUtilTable, mscLpE3TestBitsTx=mscLpE3TestBitsTx, mscLpDS3CBitRowStatus=mscLpDS3CBitRowStatus, mscLpE1ChanCellScrambleCellPayload=mscLpE1ChanCellScrambleCellPayload, mscLpDS3TestBytesRx=mscLpDS3TestBytesRx, mscLpSdhTestSetupTable=mscLpSdhTestSetupTable, mscLpE3G832RowStatus=mscLpE3G832RowStatus, mscLpE1TestBitsRx=mscLpE1TestBitsRx, mscLpE1ChanTcSigOneIndex=mscLpE1ChanTcSigOneIndex, mscLpE3G832TimingMarker=mscLpE3G832TimingMarker, mscLpSonetFarEndLineFailures=mscLpSonetFarEndLineFailures, mscLpDS3PathFailures=mscLpDS3PathFailures, mscLpDS3DS1RxAisAlarm=mscLpDS3DS1RxAisAlarm, mscLpDS1UnknownStatus=mscLpDS1UnknownStatus, mscLpDS1TestTimeRemaining=mscLpDS1TestTimeRemaining, mscLpDS3DS1ChanAlarmStatus=mscLpDS3DS1ChanAlarmStatus, mscLpE1ChanTcSigOneValue=mscLpE1ChanTcSigOneValue, mscLpSdhPathRxAisAlarm=mscLpSdhPathRxAisAlarm, mscLpV35CommentText=mscLpV35CommentText, mscLpDS3DS1TestRowStatus=mscLpDS3DS1TestRowStatus, mscLpDS3PlcpErrorFreeSec=mscLpDS3PlcpErrorFreeSec, mscLpV35EnableDynamicSpeed=mscLpV35EnableDynamicSpeed, mscLpJT2TestStateTable=mscLpJT2TestStateTable, mscLpMemoryUsageAvgMinTable=mscLpMemoryUsageAvgMinTable, mscLpDS3DS1TestCustomizedPattern=mscLpDS3DS1TestCustomizedPattern, mscLpSonetOperTable=mscLpSonetOperTable, mscLpSonetPathCellUncorrectableHecErrors=mscLpSonetPathCellUncorrectableHecErrors, mscLpJT2AdminInfoTable=mscLpJT2AdminInfoTable, mscLpDS3DS1ChanTcIndex=mscLpDS3DS1ChanTcIndex, mscLpDS3DS1ChanTestAdminState=mscLpDS3DS1ChanTestAdminState, mscLpDS1ChanTestSetupEntry=mscLpDS1ChanTestSetupEntry, mscLpE1ChanTestSetupTable=mscLpE1ChanTestSetupTable, mscLpE1ChanTcProvTable=mscLpE1ChanTcProvTable, mscLpSonetPathCellComponentName=mscLpSonetPathCellComponentName, mscLpE3CellScrambleCellPayload=mscLpE3CellScrambleCellPayload, mscLpEngDsOv=mscLpEngDsOv, mscLpE3CellOperEntry=mscLpE3CellOperEntry, mscLpDS1LineLength=mscLpDS1LineLength, mscLpDS1ChanCellOperTable=mscLpDS1ChanCellOperTable, mscLpE3TestRowStatusTable=mscLpE3TestRowStatusTable, mscLpSonetPathStorageType=mscLpSonetPathStorageType, mscLpSdhTestPurpose=mscLpSdhTestPurpose, mscLpSdhPathCellStorageType=mscLpSdhPathCellStorageType, mscLpE3LineErroredSec=mscLpE3LineErroredSec, mscLpDS1LofAlarm=mscLpDS1LofAlarm, mscLpE3PlcpErrorFreeSec=mscLpE3PlcpErrorFreeSec, mscLpDS3DS1ChanTestResultsEntry=mscLpDS3DS1ChanTestResultsEntry, mscLpSonetErrorFreeSec=mscLpSonetErrorFreeSec, mscLpOperationalState=mscLpOperationalState, mscLpDS1ChanTimeslotDataRate=mscLpDS1ChanTimeslotDataRate, mscLpE1ChanTestCustomizedPattern=mscLpE1ChanTestCustomizedPattern, mscLpSonetRxRfiAlarm=mscLpSonetRxRfiAlarm, mscLpSdhTestTimeRemaining=mscLpSdhTestTimeRemaining, mscLpSdhPathRxRfiAlarm=mscLpSdhPathRxRfiAlarm, mscLpE3CellProvEntry=mscLpE3CellProvEntry, mscLpDS3DS1ChanCellCorrectableHeaderErrors=mscLpDS3DS1ChanCellCorrectableHeaderErrors, mscLpDS3DS1TestPurpose=mscLpDS3DS1TestPurpose, mscLpE1RaiClearAlarmTime=mscLpE1RaiClearAlarmTime, mscLpSdhPathSignalLabelMismatch=mscLpSdhPathSignalLabelMismatch, mscLpDS3LineSevErroredSec=mscLpDS3LineSevErroredSec, mscLpE1TestAdminState=mscLpE1TestAdminState, mscLpHssiCustomerIdentifier=mscLpHssiCustomerIdentifier, mscLpOperTable=mscLpOperTable, mscLpE1ChanFlm=mscLpE1ChanFlm, mscLpSdhPathCellTransmitCellUtilization=mscLpSdhPathCellTransmitCellUtilization, mscLpE1ChanTcEgressConditioning=mscLpE1ChanTcEgressConditioning, mscLpDS1ChanTcIndex=mscLpDS1ChanTcIndex, mscLpE1ChanAlarmStatus=mscLpE1ChanAlarmStatus, mscLpDS3CBitLoopedbackToFarEnd=mscLpDS3CBitLoopedbackToFarEnd, mscLpX21ActualLinkMode=mscLpX21ActualLinkMode, mscLpSdh=mscLpSdh, mscLpMemoryUsageAvgMaxValue=mscLpMemoryUsageAvgMaxValue, mscLpSdhPathCellCorrectableHeaderErrors=mscLpSdhPathCellCorrectableHeaderErrors, mscLpE1UsageState=mscLpE1UsageState)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpSpareCard=mscLpSpareCard, mscLpJT2CellProvEntry=mscLpJT2CellProvEntry, mscLpE1ChanTcSigOneEntry=mscLpE1ChanTcSigOneEntry, mscLpDS1ChanCellRowStatus=mscLpDS1ChanCellRowStatus, mscLpX21CommentText=mscLpX21CommentText, mscLpJT2Index=mscLpJT2Index, mscLpDS3CellProvEntry=mscLpDS3CellProvEntry, mscLpE1ClockingSource=mscLpE1ClockingSource, mscLpE3G832=mscLpE3G832, mscLpE3PlcpRowStatus=mscLpE3PlcpRowStatus, mscLpSdhOperationalState=mscLpSdhOperationalState, mscLpX21LineState=mscLpX21LineState, mscLpDS1TestErroredFrmRx=mscLpDS1TestErroredFrmRx, mscLpX21LineStatusTimeOut=mscLpX21LineStatusTimeOut, mscLpDS3DS1ChanTcSignalOneDuration=mscLpDS3DS1ChanTcSignalOneDuration, mscLpDS3DS1ChanTestDuration=mscLpDS3DS1ChanTestDuration, mscLpDS3DS1ChanControlStatus=mscLpDS3DS1ChanControlStatus, mscLpDS3AvailabilityStatus=mscLpDS3AvailabilityStatus, mscLpDS1TestDisplayInterval=mscLpDS1TestDisplayInterval, mscLpE3LineCodeViolations=mscLpE3LineCodeViolations, mscLpSonetStatsTable=mscLpSonetStatsTable, mscLpE1ChanControlStatus=mscLpE1ChanControlStatus, mscLpSonetPathCellReceiveCellUtilization=mscLpSonetPathCellReceiveCellUtilization, mscLpStateTable=mscLpStateTable, mscLpE1ChanTestDisplayInterval=mscLpE1ChanTestDisplayInterval, mscLpDS1ChanCellStatsEntry=mscLpDS1ChanCellStatsEntry, mscLpJT2RunningTime=mscLpJT2RunningTime, mscLpE3AlarmStatus=mscLpE3AlarmStatus, mscLpSonetPathAlarmStatus=mscLpSonetPathAlarmStatus, mscLpSdhPathCustomerIdentifier=mscLpSdhPathCustomerIdentifier, mscLpDS3DS1TestRowStatusEntry=mscLpDS3DS1TestRowStatusEntry, mscLpDS3PlcpSevErroredSec=mscLpDS3PlcpSevErroredSec, mscLpE1ChanTestFrmPatternType=mscLpE1ChanTestFrmPatternType, mscLpDS3DS1ChanProvEntry=mscLpDS3DS1ChanProvEntry, mscLpX21TestResultsEntry=mscLpX21TestResultsEntry, mscLpDS1TestBitsTx=mscLpDS1TestBitsTx, mscLpHssiStandbyStatus=mscLpHssiStandbyStatus, mscLpDS3DS1ChanTest=mscLpDS3DS1ChanTest, mscLpE1ChanTestSetupEntry=mscLpE1ChanTestSetupEntry, mscLpDS1StatsEntry=mscLpDS1StatsEntry, mscLpSdhPathCellUncorrectableHecErrors=mscLpSdhPathCellUncorrectableHecErrors, mscLpV35TestResultsEntry=mscLpV35TestResultsEntry, mscLpDS3DS1ChanStandbyStatus=mscLpDS3DS1ChanStandbyStatus, mscLpE3ApplicationFramerName=mscLpE3ApplicationFramerName, mscLpE1ChanUnknownStatus=mscLpE1ChanUnknownStatus, mscLpDS1ChanCellTransmitCellUtilization=mscLpDS1ChanCellTransmitCellUtilization, mscLpX21TestTimeRemaining=mscLpX21TestTimeRemaining, mscLpDS1ChanApplicationFramerName=mscLpDS1ChanApplicationFramerName, mscLpDS1ChanCidDataTable=mscLpDS1ChanCidDataTable, mscLpV35TestRowStatus=mscLpV35TestRowStatus, mscLpE1LosStateChanges=mscLpE1LosStateChanges, mscLpSonetLineFailures=mscLpSonetLineFailures, mscLpDS3DS1ProvTable=mscLpDS3DS1ProvTable, mscLpX21TestBitsRx=mscLpX21TestBitsRx, mscLpSdhSectCodeViolations=mscLpSdhSectCodeViolations, mscLpSonetTestRowStatusEntry=mscLpSonetTestRowStatusEntry, mscLpRowStatusEntry=mscLpRowStatusEntry, mscLpDS3DS1TestOperationalState=mscLpDS3DS1TestOperationalState, mscLpHssiOperEntry=mscLpHssiOperEntry, mscLpTimeInterval=mscLpTimeInterval, mscLpSdhLineSevErroredSec=mscLpSdhLineSevErroredSec, mscLpE1ChanTcSigTwoTable=mscLpE1ChanTcSigTwoTable, mscLpDS3DS1ChanTestElapsedTime=mscLpDS3DS1ChanTestElapsedTime, mscLpDS3DS1SevErroredFrmSec=mscLpDS3DS1SevErroredFrmSec, mscLpE1TestSetupTable=mscLpE1TestSetupTable, mscLpSdhFarEndLineAisSec=mscLpSdhFarEndLineAisSec, mscLpDS1ChanTcIngressConditioning=mscLpDS1ChanTcIngressConditioning, mscLpMemoryUsageAvgMaxIndex=mscLpMemoryUsageAvgMaxIndex, mscLpDS3DS1ChanTestBytesRx=mscLpDS3DS1ChanTestBytesRx, mscLpDS3DS1ChanOperTable=mscLpDS3DS1ChanOperTable, mscLpDS3DS1TestResultsEntry=mscLpDS3DS1TestResultsEntry, mscLpDS1TestFrmRx=mscLpDS1TestFrmRx, mscLpE1ChanStandbyStatus=mscLpE1ChanStandbyStatus, mscLpV35TestCustomizedPattern=mscLpV35TestCustomizedPattern, mscLpSdhRowStatus=mscLpSdhRowStatus, mscLpDS3DS1ChanProvTable=mscLpDS3DS1ChanProvTable, mscLpDS3DS1ChanStorageType=mscLpDS3DS1ChanStorageType, mscLpE3G832FarEndUnavailSec=mscLpE3G832FarEndUnavailSec, mscLpJT2CellCorrectSingleBitHeaderErrors=mscLpJT2CellCorrectSingleBitHeaderErrors, mscLpDS3DS1ChanOperEntry=mscLpDS3DS1ChanOperEntry, mscLpDS3DS1ProceduralStatus=mscLpDS3DS1ProceduralStatus, mscLpE1ChanFlmProvTable=mscLpE1ChanFlmProvTable, mscLpSdhTestFrmTx=mscLpSdhTestFrmTx, mscLpMsgBlockUsageAvgMax=mscLpMsgBlockUsageAvgMax, mscLpE1ChanCellSevErroredSec=mscLpE1ChanCellSevErroredSec, mscLpE1TestFrmPatternType=mscLpE1TestFrmPatternType, mscLpSdhPathUnknownStatus=mscLpSdhPathUnknownStatus, mscLpE3CellSevErroredSec=mscLpE3CellSevErroredSec, mscLpE1OperStatusTable=mscLpE1OperStatusTable, mscLpSdhTestUsageState=mscLpSdhTestUsageState, mscLpX21LineSpeed=mscLpX21LineSpeed, mscLpE1TestBitErrorRate=mscLpE1TestBitErrorRate, mscLpDS3DS1ChanActualChannelSpeed=mscLpDS3DS1ChanActualChannelSpeed, mscLpDS3CellCorrectableHeaderErrors=mscLpDS3CellCorrectableHeaderErrors, mscLpV35UnknownStatus=mscLpV35UnknownStatus, mscLpDS3DS1ChanTestFrmTx=mscLpDS3DS1ChanTestFrmTx, mscLpX21TestDisplayInterval=mscLpX21TestDisplayInterval, mscLpSdhSectLosSec=mscLpSdhSectLosSec, mscLpE1ChanOperStatusTable=mscLpE1ChanOperStatusTable, mscLpCidDataTable=mscLpCidDataTable, mscLpDS3DS1CidDataEntry=mscLpDS3DS1CidDataEntry, mscLpSonetSectErroredSec=mscLpSonetSectErroredSec, mscLpJT2TestUsageState=mscLpJT2TestUsageState, mscLpE1ChanTestType=mscLpE1ChanTestType, mscLpSonetPathIfIndex=mscLpSonetPathIfIndex, mscLpX21ActualRxLineSpeed=mscLpX21ActualRxLineSpeed, mscLpLocalMsgBlockCapacity=mscLpLocalMsgBlockCapacity, mscLpE1Crc4Mode=mscLpE1Crc4Mode, mscLpSdhAdminState=mscLpSdhAdminState, mscLpDS3CBitFarEndUnavailSec=mscLpDS3CBitFarEndUnavailSec, mscLpV35OperStatusEntry=mscLpV35OperStatusEntry, mscLpE3PlcpFarEndUnavailableSec=mscLpE3PlcpFarEndUnavailableSec, mscLpHssiTestBytesRx=mscLpHssiTestBytesRx, mscLpE3PlcpRxRaiAlarm=mscLpE3PlcpRxRaiAlarm, mscLpJT2UnknownStatus=mscLpJT2UnknownStatus, mscLpE1DspIndex=mscLpE1DspIndex, mscLpE3RowStatusEntry=mscLpE3RowStatusEntry, mscLpDS3DS1TestSetupTable=mscLpDS3DS1TestSetupTable, mscLpDS1ChanOperTable=mscLpDS1ChanOperTable, mscLpSonetOperationalState=mscLpSonetOperationalState, mscLpE3ProvTable=mscLpE3ProvTable, mscLpDS1Vendor=mscLpDS1Vendor, mscLpDS1ChanCellCorrectableHeaderErrors=mscLpDS1ChanCellCorrectableHeaderErrors, mscLpDS1Test=mscLpDS1Test, mscLpDS3DS1OperEntry=mscLpDS3DS1OperEntry, mscLpCpuUtilAvgMin=mscLpCpuUtilAvgMin, mscLpDS3LineErroredSec=mscLpDS3LineErroredSec, mscLpMemoryUsageIndex=mscLpMemoryUsageIndex, mscLpDS1ChanTestStateEntry=mscLpDS1ChanTestStateEntry, mscLpSdhPathCellScrambleCellPayload=mscLpSdhPathCellScrambleCellPayload, mscLpX21CustomerIdentifier=mscLpX21CustomerIdentifier, mscLpDS3CellRowStatusEntry=mscLpDS3CellRowStatusEntry, mscLpE1ChanTestErroredFrmRx=mscLpE1ChanTestErroredFrmRx, mscLpX21TestOperationalState=mscLpX21TestOperationalState, mscLpE1ChanTcRowStatus=mscLpE1ChanTcRowStatus, mscLpE3LineFailures=mscLpE3LineFailures, mscLpE1TestComponentName=mscLpE1TestComponentName, mscLpX21StorageType=mscLpX21StorageType, mscLpDS3DS1TestFrmSize=mscLpDS3DS1TestFrmSize, mscLpE1ChanTcRowStatusEntry=mscLpE1ChanTcRowStatusEntry, mscLpSonetRxAisAlarm=mscLpSonetRxAisAlarm, mscLpIndex=mscLpIndex, mscLpSdhRxRfiAlarm=mscLpSdhRxRfiAlarm, mscLpV35DteDataClockSource=mscLpV35DteDataClockSource, mscLpDS3CBitStatsEntry=mscLpDS3CBitStatsEntry, mscLpJT2TestBitsTx=mscLpJT2TestBitsTx, mscLpSonetPathCellCorrectableHeaderErrors=mscLpSonetPathCellCorrectableHeaderErrors, mscLpJT2UsageState=mscLpJT2UsageState, mscLpMainCardStatus=mscLpMainCardStatus, mscLpSonetTestBytesTx=mscLpSonetTestBytesTx, mscLpDS3DS1ChanTcRowStatus=mscLpDS3DS1ChanTcRowStatus, mscLpHssiTestResultsEntry=mscLpHssiTestResultsEntry, mscLpE1ChanCellCorrectableHeaderErrors=mscLpE1ChanCellCorrectableHeaderErrors, mscLpJT2RxAisPayloadAlarm=mscLpJT2RxAisPayloadAlarm, mscLpMemoryUsageAvgValue=mscLpMemoryUsageAvgValue, mscLpJT2ProvEntry=mscLpJT2ProvEntry, mscLpHssiTestTimeRemaining=mscLpHssiTestTimeRemaining, mscLpX21LinkMode=mscLpX21LinkMode, mscLpE1Vendor=mscLpE1Vendor, mscLpSdhTestComponentName=mscLpSdhTestComponentName, mscLpSonetRowStatusEntry=mscLpSonetRowStatusEntry, mscLpDS3TestRowStatus=mscLpDS3TestRowStatus, mscLpDS1=mscLpDS1, mscLpSonetTestType=mscLpSonetTestType, mscLpE1ChanTcOpEntry=mscLpE1ChanTcOpEntry, mscLpSonetSectSevErroredFrmSec=mscLpSonetSectSevErroredFrmSec, mscLpDS1ChanTestFrmSize=mscLpDS1ChanTestFrmSize, mscLpJT2ProvTable=mscLpJT2ProvTable, mscLpHssiTestSetupEntry=mscLpHssiTestSetupEntry, mscLpSdhPath=mscLpSdhPath, mscLpJT2SevErroredFrmSec=mscLpJT2SevErroredFrmSec, mscLpE1TestErroredFrmRx=mscLpE1TestErroredFrmRx, mscLpE1ChanCellAlarmActDelay=mscLpE1ChanCellAlarmActDelay, mscLpV35AdminInfoTable=mscLpV35AdminInfoTable, mscLpSonetCidDataEntry=mscLpSonetCidDataEntry, mscLpE3G832UnexpectedPayloadType=mscLpE3G832UnexpectedPayloadType, mscLpDS3DS1ChanTcComponentName=mscLpDS3DS1ChanTcComponentName, mscLpDS3CBitComponentName=mscLpDS3CBitComponentName, mscLpE1ChanTcSigTwoValue=mscLpE1ChanTcSigTwoValue, mscLpSdhPathCellCorrectSingleBitHeaderErrors=mscLpSdhPathCellCorrectSingleBitHeaderErrors, mscLpDS3Test=mscLpDS3Test, mscLpE3G832RowStatusTable=mscLpE3G832RowStatusTable, mscLpDS3RxIdle=mscLpDS3RxIdle, mscLpE3LinkAlarmScanInterval=mscLpE3LinkAlarmScanInterval, mscLpE1TestCauseOfTermination=mscLpE1TestCauseOfTermination, mscLpE3PlcpRowStatusTable=mscLpE3PlcpRowStatusTable, mscLpV35IfEntryEntry=mscLpV35IfEntryEntry, mscLpDS1IfEntryEntry=mscLpDS1IfEntryEntry, mscLpSonetCommentText=mscLpSonetCommentText, mscLpE1LofAlarm=mscLpE1LofAlarm, mscLpDS3PlcpRowStatusEntry=mscLpDS3PlcpRowStatusEntry, mscLpE1ChanVendor=mscLpE1ChanVendor, mscLpHssiTestElapsedTime=mscLpHssiTestElapsedTime, mscLpSonetStorageType=mscLpSonetStorageType, mscLpDS3IfEntryTable=mscLpDS3IfEntryTable, mscLpLocalMsgBlockUsageMin=mscLpLocalMsgBlockUsageMin, mscLpDS1ChanTestTimeRemaining=mscLpDS1ChanTestTimeRemaining, mscLpV35AlarmStatus=mscLpV35AlarmStatus, mscLpDS3CommentText=mscLpDS3CommentText, mscLpSdhPathOperationalState=mscLpSdhPathOperationalState, mscLpDS3RxRaiAlarm=mscLpDS3RxRaiAlarm, mscLpDS3TestRowStatusEntry=mscLpDS3TestRowStatusEntry, mscLpSdhRunningTime=mscLpSdhRunningTime, mscLpDS3DS1RowStatusEntry=mscLpDS3DS1RowStatusEntry, mscLpSdhTestBitErrorRate=mscLpSdhTestBitErrorRate, mscLpX21TestCauseOfTermination=mscLpX21TestCauseOfTermination, mscLpX21TestBytesRx=mscLpX21TestBytesRx, logicalProcessorGroup=logicalProcessorGroup, mscLpDS3DS1ChanCellUncorrectableHecErrors=mscLpDS3DS1ChanCellUncorrectableHecErrors, mscLpDS3PlcpFarEndSevErroredSec=mscLpDS3PlcpFarEndSevErroredSec, mscLpDS3CBitOperationalEntry=mscLpDS3CBitOperationalEntry, mscLpX21AdminInfoTable=mscLpX21AdminInfoTable, mscLpEngDsRowStatus=mscLpEngDsRowStatus, mscLpDS3PlcpStatsTable=mscLpDS3PlcpStatsTable, mscLpDS3DS1Vendor=mscLpDS3DS1Vendor, mscLpE3G832FarEndCodeViolations=mscLpE3G832FarEndCodeViolations, mscLpE3CommentText=mscLpE3CommentText, mscLpHssiIfEntryTable=mscLpHssiIfEntryTable, mscLpE1ChanApplicationFramerName=mscLpE1ChanApplicationFramerName, mscLpE1TestType=mscLpE1TestType, mscLpSdhRowStatusTable=mscLpSdhRowStatusTable, mscLpDS3DS1ChanTestResultsTable=mscLpDS3DS1ChanTestResultsTable, mscLpDS3DS1TestFrmTx=mscLpDS3DS1TestFrmTx, mscLpE3OperTable=mscLpE3OperTable, mscLpSdhPathCellComponentName=mscLpSdhPathCellComponentName, mscLpDS1ChanTcSigOneTable=mscLpDS1ChanTcSigOneTable, mscLpHssiIfEntryEntry=mscLpHssiIfEntryEntry, mscLpDS3DS1ChanRowStatus=mscLpDS3DS1ChanRowStatus, mscLpJT2TestElapsedTime=mscLpJT2TestElapsedTime, mscLpDS3AdminState=mscLpDS3AdminState, mscLpDS3DS1OperStatusEntry=mscLpDS3DS1OperStatusEntry, mscLpDS3PlcpLofAlarm=mscLpDS3PlcpLofAlarm, mscLpDS3PlcpFarEndErroredSec=mscLpDS3PlcpFarEndErroredSec, mscLpDS3DS1ChanTcSigTwoEntry=mscLpDS3DS1ChanTcSigTwoEntry, mscLpDS1TestComponentName=mscLpDS1TestComponentName, mscLpE3SnmpOperStatus=mscLpE3SnmpOperStatus, mscLpSonetLosAlarm=mscLpSonetLosAlarm, mscLpHssiTestBytesTx=mscLpHssiTestBytesTx, mscLpDS3PlcpFarEndCodingViolations=mscLpDS3PlcpFarEndCodingViolations, mscLpE3PathUnavailSec=mscLpE3PathUnavailSec, mscLpE1ChanOperTable=mscLpE1ChanOperTable, mscLpDS1ProceduralStatus=mscLpDS1ProceduralStatus, mscLpE1TestFrmSize=mscLpE1TestFrmSize, mscLpE1CommentText=mscLpE1CommentText, mscLpE3G832TrailTraceMismatch=mscLpE3G832TrailTraceMismatch, mscLpJT2RxAisPhysicalAlarm=mscLpJT2RxAisPhysicalAlarm, mscLpEngDsOvProvEntry=mscLpEngDsOvProvEntry, mscLpDS1RaiAlarmType=mscLpDS1RaiAlarmType, mscLpJT2TestRowStatus=mscLpJT2TestRowStatus, mscLpV35LineState=mscLpV35LineState, mscLp=mscLp, mscLpE1CrcErrors=mscLpE1CrcErrors, mscLpE1DspStorageType=mscLpE1DspStorageType, mscLpSonetTestFrmRx=mscLpSonetTestFrmRx)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-LogicalProcessorMIB", mscLpE1DspRowStatusTable=mscLpE1DspRowStatusTable, mscLpE1TestElapsedTime=mscLpE1TestElapsedTime, mscLpX21UsageState=mscLpX21UsageState, mscLpJT2CellComponentName=mscLpJT2CellComponentName, mscLpDS3ComponentName=mscLpDS3ComponentName, mscLpHssiTestCustomizedPattern=mscLpHssiTestCustomizedPattern, mscLpSdhLineErroredSec=mscLpSdhLineErroredSec, mscLpSonetPathCellIndex=mscLpSonetPathCellIndex, mscLpDS3DS1TxRaiAlarm=mscLpDS3DS1TxRaiAlarm, mscLpDS1ChanIndex=mscLpDS1ChanIndex, mscLpDS1UsageState=mscLpDS1UsageState, mscLpSonetPathRxAisAlarm=mscLpSonetPathRxAisAlarm, mscLpDS3CustomerIdentifier=mscLpDS3CustomerIdentifier, mscLpSonetAlarmStatus=mscLpSonetAlarmStatus, mscLpEngDsOvComponentName=mscLpEngDsOvComponentName, mscLpE3CustomerIdentifier=mscLpE3CustomerIdentifier, mscLpE1RxRaiAlarm=mscLpE1RxRaiAlarm, mscLpSonetTestTimeRemaining=mscLpSonetTestTimeRemaining, mscLpHssiActualRxLineSpeed=mscLpHssiActualRxLineSpeed, mscLpDS1StandbyStatus=mscLpDS1StandbyStatus, mscLpX21TestIndex=mscLpX21TestIndex, mscLpDS1TestCustomizedPattern=mscLpDS1TestCustomizedPattern, logicalProcessorCapabilities=logicalProcessorCapabilities, mscLpE1=mscLpE1, mscLpE1ChanTestBytesRx=mscLpE1ChanTestBytesRx, mscLpDS1ChanIfAdminStatus=mscLpDS1ChanIfAdminStatus, mscLpSdhPathStateTable=mscLpSdhPathStateTable, mscLpDS3TestBitsTx=mscLpDS3TestBitsTx, mscLpHssiRowStatus=mscLpHssiRowStatus, mscLpDS3TestFrmRx=mscLpDS3TestFrmRx, mscLpE3CidDataEntry=mscLpE3CidDataEntry, mscLpDS3RowStatusEntry=mscLpDS3RowStatusEntry, mscLpDS1ChanAdminInfoEntry=mscLpDS1ChanAdminInfoEntry, mscLpE3TestElapsedTime=mscLpE3TestElapsedTime, mscLpDS3LineLength=mscLpDS3LineLength, mscLpE3CellRowStatusTable=mscLpE3CellRowStatusTable, mscLpEngRowStatusEntry=mscLpEngRowStatusEntry, mscLpEngIndex=mscLpEngIndex, mscLpSonetTestFrmTx=mscLpSonetTestFrmTx, mscLpE3AvailabilityStatus=mscLpE3AvailabilityStatus, mscLpDS3DS1ChanVendor=mscLpDS3DS1ChanVendor, mscLpDS3DS1TestStorageType=mscLpDS3DS1TestStorageType, mscLpMsgBlockUsageAvg=mscLpMsgBlockUsageAvg, mscLpE3Cell=mscLpE3Cell, mscLpDS3AlarmStatus=mscLpDS3AlarmStatus, mscLpE1TestDuration=mscLpE1TestDuration, mscLpX21TestBytesTx=mscLpX21TestBytesTx, mscLpJT2Vendor=mscLpJT2Vendor, mscLpDS3DS1IfEntryTable=mscLpDS3DS1IfEntryTable, mscLpDS3DS1ChanIfEntryTable=mscLpDS3DS1ChanIfEntryTable, mscLpDS3DS1IfEntryEntry=mscLpDS3DS1IfEntryEntry, mscLpDS3DS1ChanTestRowStatusEntry=mscLpDS3DS1ChanTestRowStatusEntry, mscLpE1ChanIndex=mscLpE1ChanIndex, mscLpDS1ChanTestBitsRx=mscLpDS1ChanTestBitsRx, mscLpDS3DS1ChanStateEntry=mscLpDS3DS1ChanStateEntry, mscLpE1ChanTcComponentName=mscLpE1ChanTcComponentName, mscLpSdhLineCodeViolations=mscLpSdhLineCodeViolations, mscLpRowStatusTable=mscLpRowStatusTable, mscLpSonetTestDuration=mscLpSonetTestDuration, mscLpE3TestRowStatus=mscLpE3TestRowStatus, mscLpE1TestCustomizedPattern=mscLpE1TestCustomizedPattern, mscLpDS1AlarmStatus=mscLpDS1AlarmStatus, mscLpSonetPathAvailabilityStatus=mscLpSonetPathAvailabilityStatus, mscLpDS1ChanTcSigOneEntry=mscLpDS1ChanTcSigOneEntry, mscLpDS3Index=mscLpDS3Index, mscLpE1ChanCellOperEntry=mscLpE1ChanCellOperEntry, mscLpMsgBlockUsageAvgMin=mscLpMsgBlockUsageAvgMin, mscLpE1ChanTc=mscLpE1ChanTc, mscLpE3TestComponentName=mscLpE3TestComponentName, mscLpDS3TestErroredFrmRx=mscLpDS3TestErroredFrmRx, mscLpDS1Dsp=mscLpDS1Dsp, mscLpDS3DS1ChanTestErroredFrmRx=mscLpDS3DS1ChanTestErroredFrmRx, mscLpDS3PathUnavailSec=mscLpDS3PathUnavailSec, mscLpDS1ChanTestFrmRx=mscLpDS1ChanTestFrmRx, mscLpSdhVendor=mscLpSdhVendor, mscLpDS1ProvEntry=mscLpDS1ProvEntry, mscLpE3CellCorrectSingleBitHeaderErrors=mscLpE3CellCorrectSingleBitHeaderErrors, mscLpSonetPathOperTable=mscLpSonetPathOperTable, mscLpDS3DS1ChanOperStatusEntry=mscLpDS3DS1ChanOperStatusEntry, mscLpV35IfIndex=mscLpV35IfIndex, mscLpE1Test=mscLpE1Test, mscLpJT2CellReceiveCellUtilization=mscLpJT2CellReceiveCellUtilization, mscLpJT2TestTimeRemaining=mscLpJT2TestTimeRemaining, mscLpE3TestIndex=mscLpE3TestIndex, mscLpEngDsOvRowStatus=mscLpEngDsOvRowStatus, mscLpDS3CBitCbitErrorFreeSec=mscLpDS3CBitCbitErrorFreeSec, mscLpX21DataXferStateChanges=mscLpX21DataXferStateChanges)

#
# PySNMP MIB module NETWORTH-FASTPIPES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NETWORTH-FASTPIPES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:21:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
enterprises, Counter32, Unsigned32, IpAddress, MibIdentifier, Bits, NotificationType, Integer32, ObjectIdentity, iso, NotificationType, Gauge32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "Counter32", "Unsigned32", "IpAddress", "MibIdentifier", "Bits", "NotificationType", "Integer32", "ObjectIdentity", "iso", "NotificationType", "Gauge32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
networth = MibIdentifier((1, 3, 6, 1, 4, 1, 215))
networthProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 215, 1))
networthInternetworking = MibIdentifier((1, 3, 6, 1, 4, 1, 215, 1, 2))
nwFastPipes = MibIdentifier((1, 3, 6, 1, 4, 1, 215, 1, 2, 2))
nwfpProductType = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpProductType.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpProductType.setDescription('The switch product type based on whether the switch is modular or nonmodular, has one of four uplinks or none, and has routing or not. The product types are: Modular with no Uplink and no Routing Modular with no Uplink and Routing Modular with FDDI Uplink and no Routing Modular with FDDI Uplink and Routing Modular with ATM Uplink and no Routing Modular with ATM Uplink and Routing Modular with 100BT Uplink and no Routing Modular with 100BT Uplink and Routing Modular with 100VG Uplink and no Routing Modular with 100VG Uplink and Routing NonModular with no Uplink and no Routing NonModular with no Uplink and Routing NonModular with FDDI Uplink and no Routing NonModular with FDDI Uplink and Routing NonModular with ATM Uplink and no Routing NonModular with ATM Uplink and Routing NonModular with 100BT Uplink and no Routing NonModular with 100BT Uplink and Routing NonModular with 100VG Uplink and no Routing NonModular with 100VG Uplink and Routing')
nwfpReset = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-reset", 1), ("reset", 2), ("reset-and-erase-config", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpReset.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpReset.setDescription('Setting this object to reset(2) will cause the FastPipes to perform a hardware reset within approximately 5 seconds. Setting this object to reset-and-erase-config(3) will cause the switch to perform a hardware reset to all config values stored in nvram to default values within approximately 5 seconds. Setting this object to no-reset(1) will have no effect. The value no-reset(1) will be returned whenever this object is retrieved. The primary purpose for including this variable in the FastPipes MIB is to allow SNMP managers to modify the operational mode of the FastPipes.')
nwfpCurrentSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpCurrentSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpCurrentSoftwareVersion.setDescription('The version of software currently running on the switch. The version is specified in ASCII format')
nwfpFutureSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFutureSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFutureSoftwareVersion.setDescription('The version of software the switch will run after the next reset. If this variable is different than nwfpCurrentSoftwareVersion, the switch will request a download for the new software the next time the switch is reset (as in setting the variable nwfpReset or power cycling the unit). The version should be specified as an ASCII string.')
nwfpTFTPServerIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpTFTPServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpTFTPServerIPAddress.setDescription('The IP address of the TFTP Server to which the FastPipes will send its next TFTP request.')
nwfpCurrentUplinkSoftwareVers = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpCurrentUplinkSoftwareVers.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpCurrentUplinkSoftwareVers.setDescription("The version of software currently running on the switch's Uplink Card. The version is an ASCI string of the form.")
nwfpFutureUplinkSoftwareVers = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFutureUplinkSoftwareVers.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFutureUplinkSoftwareVers.setDescription("The version of software the switch's Uplink Card will run after the next reset. If this variable is different than nwfpCurrentUplinkSoftwareVers, the switch will request a download for the new software the next time the switch is reset (as in setting the variable nwfpReset or power cycling the unit). The version should be specified as an ASCII string.")
nwfpLastFailureReason = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpLastFailureReason.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpLastFailureReason.setDescription('The last error that caused a switch failure. A value of zero (0) indicates that there has not been a switch failure since the nvram was last erased. A non-zero value indicates the reason for the last switch failure. A normal switch reset or power cycle will not change the value of this variable (it will still indicate the reason for the last known failure).')
nwfpEEPROMVersion = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpEEPROMVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpEEPROMVersion.setDescription("The hardware EEPROM version. The string 'unknown' is returned if the value is not known.")
nwfpManufactureDate = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpManufactureDate.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpManufactureDate.setDescription("The hardware manufacture date. The string 'unknown' is returned if the value is not known.")
nwfpAuthErrIPaddress = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpAuthErrIPaddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpAuthErrIPaddress.setDescription('The IP address of the device that sent the SNMP packet that caused an authentication error trap to be issued by the switch.')
nwfpRAMsize = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("one-MB", 1), ("two-MB", 2), ("four-MB", 4), ("eight-MB", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpRAMsize.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpRAMsize.setDescription('The size of RAM.')
nwfpEthernetTable = MibTable((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 13), )
if mibBuilder.loadTexts: nwfpEthernetTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpEthernetTable.setDescription('A table of ethernet-port-specific information for the FastPipes. This table augments the Ethernet RFC1398 MIB.')
nwfpEthernetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 13, 1), ).setIndexNames((0, "NETWORTH-FASTPIPES-MIB", "nwfpIfIndex"))
if mibBuilder.loadTexts: nwfpEthernetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpEthernetEntry.setDescription('A list of information for every ethernet interface.')
nwfpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 12))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpIfIndex.setDescription('Ethernet interface number that corresponds to the ifIndex value in mib-2.')
nwfpBOOTPrequestFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpBOOTPrequestFlag.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpBOOTPrequestFlag.setDescription('This flag determines whether this ethernet interface will send a BOOTP request. When booting, the FastPipes will broadcast a BOOTP request from the lowest ethernet interface with this value enabled(1). If that BOOTP request fails, the FastPipes will broadcast another BOOTP request from the next ethernet interface with this value enabled(1). At least one ethernet interface must have this value enabled(1) or BOOTP will not work.')
nwfpBOOTPServerIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 18), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpBOOTPServerIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpBOOTPServerIPAddress.setDescription("The IP address of the BOOTP Server that responded to the FastPipes's BOOTP request.")
nwfpBOOTPEthernetIF = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpBOOTPEthernetIF.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpBOOTPEthernetIF.setDescription('The Ethernet interface number that successfully completed the BOOTP interaction.')
nwfpUplinkSoftwarePath = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpUplinkSoftwarePath.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpUplinkSoftwarePath.setDescription('The path to the switch software file. Following this path will reveal the actual version of the file.')
nwfpSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpSerialNumber.setDescription('The hardware serial number.')
nwfpConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(500, 501, 502, 503, 504))).clone(namedValues=NamedValues(("fsp12", 500), ("fsp6", 501), ("fsp11", 502), ("fsp12fx", 503), ("fsp6fl", 504)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpConfiguration.setDescription('This object returns the type of base module that is being queried.')
nwfpUpLinkEEPROMVersion = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpUpLinkEEPROMVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpUpLinkEEPROMVersion.setDescription("The uplink EEPROM version. The string 'unknown' is returned if the value is not known.")
nwfpUpLinkManufactureDate = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpUpLinkManufactureDate.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpUpLinkManufactureDate.setDescription("The uplink manufacture date. The string 'unknown' is returned if the value is not known.")
nwfpUpLinkSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpUpLinkSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpUpLinkSerialNumber.setDescription('The uplink serial number.')
nwfpUpLinkConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("fddi-fiber-das", 2), ("fddi-fiber-sas", 3), ("fddi-tppmd-sas", 4), ("ethernet-100mbps-t4", 5), ("ethernet-100mbps-tx", 6), ("ethernet-100mbps-fx", 7), ("atm", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpUpLinkConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpUpLinkConfiguration.setDescription('This object returns the type of HSSP (Uplink) module that is in the base unit.')
nwfpSoftwarePath = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpSoftwarePath.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpSoftwarePath.setDescription('The path to the switch software file. Following this path will reveal the actual version of the file.')
nwfpCurrentBooterSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 28), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpCurrentBooterSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpCurrentBooterSoftwareVersion.setDescription('The version of Booter software currently running on the switch. The version is an ASCII string.')
nwfpFutureBooterSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFutureBooterSoftwareVersion.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFutureBooterSoftwareVersion.setDescription('The version of Booter software the switch will run after the next reset. If this variable is different than nwfpCurrentSoftwareVersion, the switch will request a download for the new software the next time the switch is reset (as in setting the variable nwfpReset or power cycling the unit). The version is an ASCII string.')
nwfpBooterSoftwarePath = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpBooterSoftwarePath.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpBooterSoftwarePath.setDescription('The path to the Booter software file. Following this path will reveal the actual version of the file.')
nwfpSaveConfig = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("config-info-saved", 1), ("save-all", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpSaveConfig.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpSaveConfig.setDescription('This object allows the user to permanently save configuration parameters into the NVRAM of a managed device. It can only be written with save-all(2). Writing this object with config-info-saved(1) has no effect. Setting this object to save-all(2) will save all configuration info changed into the NVRAM. Reading this object will normally return config-info-saved(1) if the previous save operation is successful. It will return the value set when the previous set operation failed.')
nwfpFddiIPFrag = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFddiIPFrag.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFddiIPFrag.setDescription('When on(2), the FastPipes FDDI Uplink will perform IP fragmentation. When off(1), IP fragmentation is not done and FDDI frames containing IP information that exceed the Ethernet maximum frame size will be dropped. Default mode is on(2).')
nwfpFddiToEthIPTrans = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ethernet-ii", 1), ("ethernet-802-3-RAW", 2), ("automatic", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFddiToEthIPTrans.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFddiToEthIPTrans.setDescription('This attribute defines how FDDI frames containing IP packets get translated into Ethernet frames. When automatic(3) mode is selected, then FDDI frames are translated either in 802.3 RAW or ethernet-ii frames, depending on the FDDI frame format (FDDI SNAP frames are translated into ethernet-ii frames and FDDI 802.2 frames are translated into 802.3 RAW frames). When ethernet-802-3-RAW(2) mode is selected, all FDDI frames are translated into 802.3 RAW frames. When ethernet-ii(1) mode is selected, all FDDI frames are translated into ethernet-ii frames. Default mode is automatic(3).')
nwfpFddiSNAPToEthIPXTrans = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet-ii", 1), ("ieee8022snap", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFddiSNAPToEthIPXTrans.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFddiSNAPToEthIPXTrans.setDescription('This attribute defines how incoming FDDI SNAP frames containing IPX information are translated into ethernet frames. When ethernet-ii(1) mode is selected, then, the incoming FDDI SNAP frames are translated into ethernet-ii frames. When ieee8022snap(2) is selected, then the incoming FDDI SNAP frames are translated into ethernet SNAP frames. Default mode is ethernet-ii(1).')
nwfpFddi8022ToEthIPXTrans = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet-802-3-RAW", 1), ("ieee8022", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFddi8022ToEthIPXTrans.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFddi8022ToEthIPXTrans.setDescription('This attribute defines how incoming FDDI 802.2 frames containing IPX information are translated into ethernet frames. When the 802-3-Raw(1) mode is selected, then, incoming FDDI 802.2 frames are translated into 802.3 Raw format. When the 802-2(2) format is selected, then incoming FDDI 802.2 frames are translated into 802.2 frames. Default mode is 802-3-Raw(1).')
nwfpFddiLocTrafFiltering = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpFddiLocTrafFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFddiLocTrafFiltering.setDescription('Defines whether or not traffic local to the FDDI network the FastPipes is connected to is filtered or not (i.e not forwarded to the FastPipes switch process). The default is on(2)')
nwfpSpanningTreeEnable = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpSpanningTreeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpSpanningTreeEnable.setDescription('When set to enable(1), the FastPipes will run the Spanning Tree Protocol (STP). When set to disable(2), the FastPipes will not run STP. Default value is enable(1).')
nwfpTpFdbMaxSize = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpTpFdbMaxSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpTpFdbMaxSize.setDescription('Gives the maximum number of entries that the forwarding data base may have ')
nwfpTpFdbNbEntriesUsed = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpTpFdbNbEntriesUsed.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpTpFdbNbEntriesUsed.setDescription('Gives the number of entries currently existing in the forwarding data base.')
nwfpEthIPX8023ToFddiTrans = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet-802-3-RAW", 1), ("ieee8022", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpEthIPX8023ToFddiTrans.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpEthIPX8023ToFddiTrans.setDescription('When set to ieee8022(2), an LLC header is added to the FDDI frame, between the MAC header and the IPX header. When set to ethernet-802-3-RAW(1), 802.3 raw packet format will be used in performing packet translation. The default mode is ethernet-802-3-RAW(1).')
nwfpPowerSupplyNumber = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpPowerSupplyNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpPowerSupplyNumber.setDescription('The number of system power supplies installed (regardless of their current state) in the FastPipe product.')
nwfpPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 42), )
if mibBuilder.loadTexts: nwfpPowerSupplyTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpPowerSupplyTable.setDescription('A table of system power supply specific information for the FastPipes.')
nwfpPowerSupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 42, 1), ).setIndexNames((0, "NETWORTH-FASTPIPES-MIB", "nwfpPowerSupplyIndex"))
if mibBuilder.loadTexts: nwfpPowerSupplyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpPowerSupplyEntry.setDescription('A list of information for every power supply installed')
nwfpPowerSupplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 42, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpPowerSupplyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpPowerSupplyIndex.setDescription('A unique value for each power supply.')
nwfpPowerSupplyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 42, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("good", 1), ("bad", 2), ("na", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpPowerSupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpPowerSupplyStatus.setDescription('The status of the power supply. The value good(1) is returned if the power supply identified by nwfpPowerSupplyIndex is running properly. The value bad(2) is returned if the power supply identified by nwfpPowerSupplyIndex has failed to operate properly but has been inserted into the slot. This will include an inserted power supply with no power. The value na(3) is returned if the power supply has not been inserted into the slot.')
nwfpFanNumber = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpFanNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFanNumber.setDescription('The number of system fans installed (regardless of their current state) in the FastPipe product.')
nwfpFanTable = MibTable((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 44), )
if mibBuilder.loadTexts: nwfpFanTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFanTable.setDescription('A table of system fan specific information for the FastPipes.')
nwfpFanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 44, 1), ).setIndexNames((0, "NETWORTH-FASTPIPES-MIB", "nwfpFanIndex"))
if mibBuilder.loadTexts: nwfpFanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFanEntry.setDescription('A list of information for every fans installed')
nwfpFanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 44, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpFanIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFanIndex.setDescription('A unique value for each fan. Its value ranges between 1 and the value of nwfpFanNumber.')
nwfpFanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 44, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("good", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwfpFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpFanStatus.setDescription('The status of the system fan. The value good(1) is returned if the fan identified by nwfpFanIndex is running properly. The value bad(2) is returned if the fan identified by nwfpFanIndex has failed to operate properly.')
nwfpMonitorPort = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 45), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpMonitorPort.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpMonitorPort.setDescription('The index value of a port which will receive all traffic from the ports specified in the nwfpMonitorSource bitmask. Acceptable values are 1 to Max port number.')
nwfpMonitorSource = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 46), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpMonitorSource.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpMonitorSource.setDescription('A bitmask of the port numbers to monitor. This bitmask (which must not include the port number used for nwfpMonitorPort) specifies which ports are to be monitored. Traffic sent to the ports specified in this bitmask will also be sent to nwfpMonitorPort. Bit 0 in the bitmask corresponds to port 1, bit 1 corresponds to port 2, and so on. The greater the number of ports specified in the bitmask, the lower the integrity of information to the monitoring port. i.e. the more ports monitored, the greater the probability of lost data.')
nwfpMonitorPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 215, 1, 2, 2, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nwfpMonitorPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nwfpMonitorPortStatus.setDescription('Status value of RMON monitoring. When set to disabled the port specified in nwfpMonitorPort will not receive monitored data. When set to enabled the port will begin recieving data from the ports specified in nwfpMonitorSource.')
nwfpPowerSupplyDown = NotificationType((1, 3, 6, 1, 4, 1, 215) + (0,11)).setObjects(("NETWORTH-FASTPIPES-MIB", "nwfpPowerSupplyIndex"), ("NETWORTH-FASTPIPES-MIB", "nwfpPowerSupplyStatus"))
if mibBuilder.loadTexts: nwfpPowerSupplyDown.setDescription('A nwfpPowerSupplyDown trap signifies that a system power supply has stopped running. This trap will only be generated when the system power supply changes its operational state from up to down due to internal failure.')
nwfpPowerSupplyUp = NotificationType((1, 3, 6, 1, 4, 1, 215) + (0,12)).setObjects(("NETWORTH-FASTPIPES-MIB", "nwfpPowerSupplyIndex"), ("NETWORTH-FASTPIPES-MIB", "nwfpPowerSupplyStatus"))
if mibBuilder.loadTexts: nwfpPowerSupplyUp.setDescription('A nwfpPowerSupplyUp trap signifies that a system power supply is up and running. This trap will only be generated when the system power supply changes its operational state from down to up. ')
nwfpfanDown = NotificationType((1, 3, 6, 1, 4, 1, 215) + (0,13)).setObjects(("NETWORTH-FASTPIPES-MIB", "nwfpFanIndex"), ("NETWORTH-FASTPIPES-MIB", "nwfpFanStatus"))
if mibBuilder.loadTexts: nwfpfanDown.setDescription('A nwfpfanDown trap signifies that a system fan has stopped running. This trap will only be generated when the system fan changes its operational state from up to down due to internal failure. ')
nwfpfanUp = NotificationType((1, 3, 6, 1, 4, 1, 215) + (0,14)).setObjects(("NETWORTH-FASTPIPES-MIB", "nwfpFanIndex"), ("NETWORTH-FASTPIPES-MIB", "nwfpFanStatus"))
if mibBuilder.loadTexts: nwfpfanUp.setDescription('A nwfpfanUp trap signifies that a system fan is up and running. This trap will only be generated when the system fan changes its operational state from down to up. ')
mibBuilder.exportSymbols("NETWORTH-FASTPIPES-MIB", nwfpReset=nwfpReset, nwfpLastFailureReason=nwfpLastFailureReason, nwfpfanDown=nwfpfanDown, nwfpEthernetTable=nwfpEthernetTable, nwfpFutureSoftwareVersion=nwfpFutureSoftwareVersion, nwfpFddiSNAPToEthIPXTrans=nwfpFddiSNAPToEthIPXTrans, nwfpSaveConfig=nwfpSaveConfig, nwfpPowerSupplyNumber=nwfpPowerSupplyNumber, nwfpFanNumber=nwfpFanNumber, nwFastPipes=nwFastPipes, nwfpMonitorPort=nwfpMonitorPort, nwfpMonitorPortStatus=nwfpMonitorPortStatus, networth=networth, nwfpBOOTPServerIPAddress=nwfpBOOTPServerIPAddress, nwfpTFTPServerIPAddress=nwfpTFTPServerIPAddress, nwfpMonitorSource=nwfpMonitorSource, nwfpPowerSupplyDown=nwfpPowerSupplyDown, nwfpCurrentBooterSoftwareVersion=nwfpCurrentBooterSoftwareVersion, nwfpCurrentSoftwareVersion=nwfpCurrentSoftwareVersion, nwfpUpLinkManufactureDate=nwfpUpLinkManufactureDate, nwfpBooterSoftwarePath=nwfpBooterSoftwarePath, nwfpPowerSupplyIndex=nwfpPowerSupplyIndex, nwfpSerialNumber=nwfpSerialNumber, nwfpSoftwarePath=nwfpSoftwarePath, nwfpUpLinkConfiguration=nwfpUpLinkConfiguration, nwfpFanStatus=nwfpFanStatus, nwfpPowerSupplyUp=nwfpPowerSupplyUp, nwfpUpLinkSerialNumber=nwfpUpLinkSerialNumber, nwfpCurrentUplinkSoftwareVers=nwfpCurrentUplinkSoftwareVers, nwfpFddiToEthIPTrans=nwfpFddiToEthIPTrans, nwfpConfiguration=nwfpConfiguration, nwfpUpLinkEEPROMVersion=nwfpUpLinkEEPROMVersion, nwfpTpFdbMaxSize=nwfpTpFdbMaxSize, networthInternetworking=networthInternetworking, nwfpPowerSupplyStatus=nwfpPowerSupplyStatus, nwfpEthIPX8023ToFddiTrans=nwfpEthIPX8023ToFddiTrans, nwfpFddiIPFrag=nwfpFddiIPFrag, nwfpFutureUplinkSoftwareVers=nwfpFutureUplinkSoftwareVers, nwfpFanEntry=nwfpFanEntry, nwfpSpanningTreeEnable=nwfpSpanningTreeEnable, nwfpPowerSupplyTable=nwfpPowerSupplyTable, nwfpRAMsize=nwfpRAMsize, nwfpFutureBooterSoftwareVersion=nwfpFutureBooterSoftwareVersion, nwfpIfIndex=nwfpIfIndex, nwfpAuthErrIPaddress=nwfpAuthErrIPaddress, nwfpEthernetEntry=nwfpEthernetEntry, nwfpProductType=nwfpProductType, nwfpBOOTPEthernetIF=nwfpBOOTPEthernetIF, nwfpTpFdbNbEntriesUsed=nwfpTpFdbNbEntriesUsed, nwfpfanUp=nwfpfanUp, networthProducts=networthProducts, nwfpFddi8022ToEthIPXTrans=nwfpFddi8022ToEthIPXTrans, nwfpPowerSupplyEntry=nwfpPowerSupplyEntry, nwfpFddiLocTrafFiltering=nwfpFddiLocTrafFiltering, nwfpManufactureDate=nwfpManufactureDate, nwfpEEPROMVersion=nwfpEEPROMVersion, nwfpUplinkSoftwarePath=nwfpUplinkSoftwarePath, nwfpFanIndex=nwfpFanIndex, nwfpFanTable=nwfpFanTable, nwfpBOOTPrequestFlag=nwfpBOOTPrequestFlag)

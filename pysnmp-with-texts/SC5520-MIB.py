#
# PySNMP MIB module SC5520-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SC5520-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:00:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
dsu, = mibBuilder.importSymbols("DDS-MIB", "dsu")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, NotificationType, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, ObjectIdentity, Unsigned32, iso, MibIdentifier, Counter32, Counter64, TimeTicks, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "NotificationType", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "ObjectIdentity", "Unsigned32", "iso", "MibIdentifier", "Counter32", "Counter64", "TimeTicks", "ModuleIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
sc5520 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3))
sc5520MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 8, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
sc5520UnitCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 3, 2), )
if mibBuilder.loadTexts: sc5520UnitCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520UnitCfgTable.setDescription('The SC5520 Unit Configuration table.')
sc5520UnitCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1), ).setIndexNames((0, "SC5520-MIB", "sc5520UnitCfgIndex"))
if mibBuilder.loadTexts: sc5520UnitCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520UnitCfgEntry.setDescription('The SC5520 Unit Configuration table entry. The information in this entry provides unit level configuration for the SC5520.')
sc5520UnitCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520UnitCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520UnitCfgIndex.setDescription('The index value which uniquely identifies the SC5520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the SC5520 with no sub-identifier value.')
sc5520Nms510CompatibilityMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520Nms510CompatibilityMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520Nms510CompatibilityMode.setDescription('The NMS510 compatibility mode. This mode allows the SC5520 to behave in a manner compatible with that of the NMS510. If this object has the value enabled(2), then the device can be used in conjunction with an NMS510. A value of disabled(1) implies that the device is not backwardly compatible with the NMS510.')
sc5520PtToPtSentryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520PtToPtSentryTime.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520PtToPtSentryTime.setDescription('The Point to point sentry time sc5520PtToPtSentryTime, is used to control the amount of time between unsolicited alarm responses from a remote unit in a point to point application when there are no alarm conditions to report. This unsolicited response maintains the management link between the two units. These alarm responses are intrusive to data. The range is from 1 minute to 127 minutes, with 60 minutes being the default value. The value of 0(zero) minutes will disable remote alarm sentry reporting.')
sc5520AlarmHystTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520AlarmHystTime.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520AlarmHystTime.setDescription('The Alarm hysteresis time sc5520AlarmHystTime, is used to control the amount of time a remote must wait between reporting unsolicited alarm conditions. A remote will send an unsolicited alarm response at the time of the first alarm. If second alarm occurs the remote will wait for the time specified by this object before it will send another alarm response. This time applies for both point to point and multipoint applications. The range is from 1 second to 127 seconds, with 10 seconds being the default value.')
sc5520MtpointRmRspIntrvl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520MtpointRmRspIntrvl.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MtpointRmRspIntrvl.setDescription('The multipoint remote response interval sc5520MtpointRmRspIntrvl, is used to control the amount of time between unsolicited alarm responses from a remote unit in a multipoint applications when there are no alarm conditions to report. This unsolicited response maintains the management link between the two units. The range is from 1 second to 127 seconds with 10 seconds being the default value. The value of 0(zero) seconds is disable remote alarm sentry reporting. All remotes in a multipoint application must be set the same. These alarm responses are non-intrusive to data.')
sc5520DtePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rs232", 1), ("v35", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DtePortType.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DtePortType.setDescription('The value auto(3), indicates that the DTE port is automatically being detected, and set. The rs232(1), will force the DTE port to EIA/TIA-232-E, and v35(2), will force the DTE port to V.35.')
sc5520DteCtsDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ctsOn", 1), ("cts0mSec", 2), ("ctsFixed3Char", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DteCtsDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DteCtsDelay.setDescription('RTS/CTS Delay options ctsOn(1) Forces both RTS and CTS On regardless of the state of the attached business equipment (the transmitter is On regardless of the status of the RTS interface lead). MIB object sc5520DteCtsDelayExt is ignored. cts0mSec(2) Provides zero bits of delay between active RTS and CTS being set to active. MIB object sc5520DteCtsDelayExt must be set to ext0mSec(1). ctsFix3Char(3) Provides three character bits of delay between active RTS and CTS being set to active. MIB object sc5520DteCtsDelayExt must be set to ext0mSec(1).')
sc5520DteCtsDelayExt = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ext0mSec", 1), ("ext30mSec", 2), ("ext60mSec", 3), ("ext90mSec", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DteCtsDelayExt.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DteCtsDelayExt.setDescription('RTS/CTS Delay options extension ext0mSec(1) Used to enable options cts0mSec(2) or ctsFix3Char(3) from MIB object sc5520DteCtsDelay. ext30mSec(2) Provides 30 msec of delay between active RTS and CTS being set to active. MIB object sc5520DteCtsDelay must be set for either cts0mSec(2) or ctsFix3Char(3). ext60mSec(3) Provides 60 msec of delay between active RTS and CTS being set to active. MIB object sc5520DteCtsDelay must be set for either cts0mSec(2) or ctsFix3Char(3). ext90mSec(4) Provides 90 msec of delay between active RTS and CTS being set to active. MIB object sc5520DteCtsDelay must be set for either cts0mSec(2) or ctsFix3Char(3).')
sc5520BkPlaneFracNum = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520BkPlaneFracNum.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520BkPlaneFracNum.setDescription('Configures the unit to direct data to 1 of 32 time slots that exits on each of 4 highways (see sc5520BkPlaneFracIndex). By setting up units to a highway and time slot data can be channeled to different units within a management shelf. ')
sc5520BkPlaneFracIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("highway1", 2), ("highway2", 3), ("highway3", 4), ("highway4", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520BkPlaneFracIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520BkPlaneFracIfIndex.setDescription('Configures the unit to direct data to 1 of 4 hardware channels (pairs) that exist on the backplane of the management shelf. By seting up units to a highway and time slot (see sc5520BkPlaneFracNum) data can be channeled to different units within a management shelf. The default for this object is none(1) which indicates that data is not being directed toward the management shelf backplane. ')
sc5520FirmwareLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520FirmwareLevel.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520FirmwareLevel.setDescription('The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. Test versions are numerical from 01 to 99.')
sc5520FrontPanelInhibit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fpInhibited", 1), ("fpEnabled", 2), ("execute", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520FrontPanelInhibit.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520FrontPanelInhibit.setDescription('Inhibits all front panel test switches. If a test switch is activated while inhibited it will simply be ignored. If enabled via the sc5520FrontPanelEnable object the test switch will function as normal.')
sc5520FrontPanelEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fpInhibited", 1), ("fpEnabled", 2), ("execute", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520FrontPanelEnable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520FrontPanelEnable.setDescription('Enables all front panel test switches. If a test switch is activated while inhibited, via the sc5520FrontPanelInhibit object, it will simply be ignored. If enabled the test switch will function as normal.')
sc5520RemLoopAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("inhibit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520RemLoopAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520RemLoopAllowed.setDescription('Inhibits or enables a unit from going into remote loop when requested by the far end. ')
sc5520RemLoopPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("patternV54", 1), ("patternPn127", 2), ("patternGDC", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520RemLoopPattern.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520RemLoopPattern.setDescription('Selects the test pattern to be used in a remote loop test.')
sc5520RemLoopTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inhibit", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520RemLoopTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520RemLoopTimeout.setDescription('Inhibits or enables a 10 miniute remote loop test timer. When enabled the remote loop test will be terminated 10 minutes after being initiated. If inhibited the unit will remain in remote loop test indefinately.')
sc5520HdlcInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("invert", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520HdlcInvert.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520HdlcInvert.setDescription('Primary data invert option. Will enhance the quality of data when network does not provide B8Z5. Primarily used with DDS II 56k')
sc5520EIARemLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520EIARemLoop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520EIARemLoop.setDescription('The Remote Loop (RL) EIA test control lead option. This option either allows or blocks EIA initiated test inputs from the DTE interface. The remote unit must support v.54 or PN127 remote loop.')
sc5520EIALineLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520EIALineLoop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520EIALineLoop.setDescription('The LT EIA test control lead option. This option either allows or blocks EIA initiated test inputs from the DTE interface. LT (or Analoop) can be either a bilateral or unilateral loopback depending on option dds DTE Termaloop.')
sc5520PiggyBackDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("not-installed", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520PiggyBackDetect.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520PiggyBackDetect.setDescription('If set to 2 then either a Data Rate Adadaptor or 530 card is installed.')
sc5520RateBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520RateBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520RateBroadcast.setDescription('This should only be enabled when adding a remote unit and the Line Type is either DDSII with data rate equal to 56k or 64k Clear Channel.')
sc5520CircuitType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("point-to-point", 1), ("multipoint", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520CircuitType.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520CircuitType.setDescription('This object defines the circuit type.')
sc5520WakeUpRemote = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520WakeUpRemote.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520WakeUpRemote.setDescription('This object is requested to initiate the add remote process in a point to point circuit. The serial number of the associated remote is returned.')
sc5520ListOfRemotes = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 24), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520ListOfRemotes.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520ListOfRemotes.setDescription('A bitwise snapshot of the elements associated with this circuit, the master is always drop zero, the remote in a point to point circuit is always drop one. first octet second octet third octet fourth octet ----------- ------------- ------------- -------------- bit0 - drop 0 bit0 - drop 8 bit0 - drop 16 bit0 - drop 24 bit1 - drop 1 bit1 - drop 9 bit1 - drop 17 bit1 - drop 25 bit2 - drop 2 bit2 - drop 10 bit2 - drop 18 bit2 - drop 26 bit3 - drop 3 bit3 - drop 11 bit3 - drop 19 bit3 - drop 27 bit4 - drop 4 bit4 - drop 12 bit4 - drop 20 bit4 - drop 28 bit5 - drop 5 bit5 - drop 13 bit5 - drop 21 bit5 - drop 29 bit6 - drop 6 bit6 - drop 14 bit6 - drop 22 bit6 - drop 30 bit7 - drop 7 bit7 - drop 15 bit7 - drop 23 bit7 - drop 31 bit values are: 0 = no element, 1 = element present')
sc5520TelcoLatchingLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("inhibit", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520TelcoLatchingLoop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520TelcoLatchingLoop.setDescription('Inhibits or enables a unit from going into a latching loopback when requested by Telco. ')
sc5520MasterTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 3, 3), )
if mibBuilder.loadTexts: sc5520MasterTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MasterTable.setDescription('Configure Master with Remote addresses.')
sc5520MasterTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1), ).setIndexNames((0, "SC5520-MIB", "sc5520MasterIndex"))
if mibBuilder.loadTexts: sc5520MasterTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MasterTableEntry.setDescription('The SC5520 Mater table entry. A doublely indexed table using the sc5520RemoteSerialNumber object as the second index.')
sc5520MasterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520MasterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MasterIndex.setDescription('The index value which uniquely identifies the SC5520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the SC5520 with no sub-identifier value.')
sc5520AddRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(18, 18)).setFixedLength(18)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520AddRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520AddRemoteAddress.setDescription("Add Remote address from Master tells the master (SC5520) how many remotes (nms520) units are in its network, the serial number of those remote units and its Drop adrress. This information allows the Master to perform alarm reporting functions in a multipoint configuration. This object allows the master unit to add remote units from its network table. To add a remote unit to the Master's network table SET this object and specifiy the Serial Number of the unit in the first 16 locations in the OCTET STRING, and the Drop address(00 to 31) in the last 2 locations of the OCTET STRING. Remote alarm reporting will work in DDS1 only. Reading this object will report the last serial/address added or deleted.")
sc5520DelRemoteAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(18, 18)).setFixedLength(18)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DelRemoteAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DelRemoteAddress.setDescription("Delete Remote address from Master tells the master (SC5520) how many remotes (nms520) units are in its network, the serial number of those remote units and its Drop adrress. This information allows the Master to perform alarm reporting functions in a multipoint configuration. This object allows the master unit to delete remote units from its network table. To delete a remote unit from the Master's network table SET this object and specifiy the Serial Number of the unit in the first 16 locations in the OCTET STRING, and the Drop address(00 to 31) in the last 2 locations of the OCTET STRING. Remote alarm reporting will work in DDS1 only. Reading this object will report the last serial/address added or deleted.")
sc5520EnableRemoteAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520EnableRemoteAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520EnableRemoteAlarm.setDescription('Enable Remote Alarm Control tells the master (SC5520) how to configure the remote units (nms520) in a multipoint configuration with respect to alarm reporting. The master unit maintains alarm information about the remote units in its network. This object allows the master unit to enable alarm reporting on any remote unit in its network. To enable a remote unit to report alarms SET this object and specifiy the Drop address of the Remote, 1 to 31. Reading this object will report the last address added or deleted.')
sc5520DisableRemoteAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DisableRemoteAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DisableRemoteAlarm.setDescription('Disable Remote Alarm Control tells the master (SC5520) how to configure the remote units (nms520) in a multipoint configuration with respect to alarm reporting. The master unit maintains alarm information about the remote units in its network. This object allows the master unit to disable alarm reporting on any remote unit in its network. To disable remote alarm reporting on a remote unit SET this object and specifiy the Drop address of the Remote, 1 to 31. Reading this object will report the last address added or deleted.')
sc5520EnableAllRemoteAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520EnableAllRemoteAlarms.setStatus('obsolete')
if mibBuilder.loadTexts: sc5520EnableAllRemoteAlarms.setDescription('Enable All Remote Alarms tells the master (SC5520) how to configure the remote units (nms520) in a multipoint configuration with respect to alarm reporting. The master unit maintains alarm information about the remote units in its network. This object allows the master unit to enable alarm reporting on all of the remote units in its network. To enable all remote units to report alarms SET this object and specifiy enable(1). Reading this object indicates the modem is operating normally')
sc5520DisableAllRemoteAlarms = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DisableAllRemoteAlarms.setStatus('obsolete')
if mibBuilder.loadTexts: sc5520DisableAllRemoteAlarms.setDescription('Disable All Remote Alarms tells the master (SC5520) how to configure the remote units (nms520) in a multipoint configuration with respect to alarm reporting. The master unit maintains alarm information about the remote units in its network. This object allows the master unit to disable alarm reporting on all of the remote units in its network. To disable all remote units from reporting alarms SET this object and specifiy disable(2). Reading this object indicates the modem is operating normally')
sc5520AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4))
sc5520NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 1))
sc5520DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 2))
sc5520PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 3))
sc5520EEChkSumErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 4))
sc5520FpTestAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 5))
sc5520DSRLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 7))
sc5520DTRLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 8))
sc5520DTPLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 9))
sc5520DCDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 10))
sc5520RXDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 11))
sc5520TXDLossAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 12))
sc5520TmShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 13))
sc5520DcdShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 14))
sc5520DsrShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 15))
sc5520CtsShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 16))
sc5520RxdShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 17))
sc5520RxcShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 18))
sc5520TxcShortedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 19))
sc5520DBURequestForScanAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 20))
sc5520DBUOnAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 21))
sc5520DBUFailedAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 22))
sc5520CSULoopbackAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 8, 3, 4, 23))
sc5520MaintTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 3, 5), )
if mibBuilder.loadTexts: sc5520MaintTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MaintTable.setDescription('The table describes the maintenance functions for the SC5520. ')
sc5520MaintEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1), ).setIndexNames((0, "SC5520-MIB", "sc5520MaintIndex"))
if mibBuilder.loadTexts: sc5520MaintEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MaintEntry.setDescription('An entry in the GDC maintenance Table')
sc5520MaintIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520MaintIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520MaintIndex.setDescription('The index value which uniquely identifies the SC5520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the SC5520 with no sub-identifier value.')
sc5520LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520LedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state. Octet 1 bit 7 - not used bit 6 - ON bit 5 - INSV bit 4 - RSP bit 3 - TMG bit 2 - future use bit 1 - future use bit 0 - future use Octet 2 bit 7 - not used bit 6 - SD bit 5 - RD bit 4 - RS bit 3 - CO bit 2 - future use bit 1 - ALM bit 0 - TM Octet 3 bit 7 - not used bit 6 - ST bit 5 - LT bit 4 - RL bit 3 - DL bit 2 - future use bit 1 - future use bit 0 - future use')
sc5520SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520SoftReset.setDescription('This object will cause software reset in dataset.')
sc5520SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 4), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520SysUpTime.setDescription('This variable is used to report the elapsed system tick time for conversion to real time at the controller and is not related to the sysUpTime referenced in MIB-II. Upon power-up of the unit, the elapsed time is cleared. The elapsed time counter rolls over upon reaching the maximum count.')
sc5520PrivateStorage1 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520PrivateStorage1.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520PrivateStorage1.setDescription('This object is used for general purpose storage.')
sc5520PrivateStorage2 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520PrivateStorage2.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520PrivateStorage2.setDescription('This object is used for general purpose storage.')
sc5520PrivateStorage3 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520PrivateStorage3.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520PrivateStorage3.setDescription('This object is used for general purpose storage.')
sc5520BlinkINS = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notBlinking", 1), ("blinking", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520BlinkINS.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520BlinkINS.setDescription('This variable is used to blink the in service (INS) led on the front panel of the sc5520. A get returns the current status of the INS LED - either blinking(2) or not blinking(1). A set of blinking(2) will cause the sc5520 to blink the INS LED and a set of notBlinking(1) will cause the sc5520 to stop blinking the INS LED.')
sc5520DiagCfgTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 3, 6), )
if mibBuilder.loadTexts: sc5520DiagCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagCfgTable.setDescription('The Diagnostic Configuration Table.')
sc5520DiagCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1), ).setIndexNames((0, "SC5520-MIB", "sc5520DiagCfgIndex"))
if mibBuilder.loadTexts: sc5520DiagCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagCfgEntry.setDescription('An entry in the GDC DDS Diagnostic Configuration Table.')
sc5520DiagCfgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520DiagCfgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagCfgIndex.setDescription('The index value which uniquely identifies the SC5520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the SC5520 with no sub-identifier value.')
sc5520DiagSendCode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("sc5520SendOtherPattern", 1), ("sc5520Send511Pattern", 2), ("sc5520Send2047Pattern", 3), ("sc5520Send15BitPattern", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DiagSendCode.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagSendCode.setDescription('Configures the selftest pattern to be run during any diagonostic test involving selftest. If option SendOtherPattern is selected, then pattern will default to 15 bit if unit is set for 56k-DDS/sc-multi point else pattern will default to 511 bit for all other conditions')
sc5520DiagTestExceptions = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noExceptions", 1), ("blocksOutOfRange", 2), ("bitsOutOfRange", 3), ("blocksAndBitsOutOfRange", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520DiagTestExceptions.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagTestExceptions.setDescription('Indicates exceptions that have occurred that may affect interpretation of the test results. The value of this object is a sum. This sum initially take the value zero. Then, for each exception, the value associated with the exception is added to the sum. The exception values are: value exception 0 No errors 1 bit over range 2 block over range 4 bit and block over range')
sc5520DiagBitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520DiagBitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagBitErrors.setDescription('The bit errors of the last diagnostic test that involved a Selftest pattern. Reading bit errors while a diagnostic test in running will cause the unit to drop out of test and invalidate the bit errors. Bit errors should be read only after the test is completed. The valid range for bit errors is 0 to 1,023, 65535 will be returned if for any reason the test was terminated early.')
sc5520DiagBlockErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520DiagBlockErrors.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagBlockErrors.setDescription('The block errors of the last diagnostic test that involved a Selftest pattern. Reading block errors while a diagnostic test in running will cause the unit to drop out of test and invalidate the block errors. Block errors should be read only after the test is completed. The valid range for block errors is 0 to 1,023, 65535 will be returned if for any reason the test was terminated early.')
sc5520DiagTestReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noTestActive", 1), ("testActive", 2), ("resetTest", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DiagTestReset.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagTestReset.setDescription('This object will halt the execution of any and all diagnostic test that may be running.')
sc5520DiagTimeDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16383))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520DiagTimeDelay.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagTimeDelay.setDescription('This object reads the results of a Network Delay Test. The results are valid only after the test is completed which takes about 10 seconds. The unit for time delay is in miliseconds. The valid range for delay is 0 to 4096, 16383 will be returned if for any reason the test was terminated early. Reading this object while a test is in progress will terminate the test.')
sc5520ExcDiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 3, 7), )
if mibBuilder.loadTexts: sc5520ExcDiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520ExcDiagTable.setDescription('The Diagnostic Execution Table.')
sc5520ExcDiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1), ).setIndexNames((0, "SC5520-MIB", "sc5520ExcDiagIndex"))
if mibBuilder.loadTexts: sc5520ExcDiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520ExcDiagEntry.setDescription('An entry in the GDC DDS Diagnostic Execution Table.')
sc5520ExcDiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520ExcDiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520ExcDiagIndex.setDescription('The index value which uniquely identifies the SC5520 to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, and drop of the SC5520 with no sub-identifier value.')
sc5520DiagExtLineloop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lineloopOff", 1), ("lineloopOn", 2), ("external", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DiagExtLineloop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagExtLineloop.setDescription('Lineloop (or Analoop) can be either a Bilaterial or Unilaterial loopback depending on option ddsDteTermaloop. To initiate a Lineloop with no Selftest SET this object and specifiy external, this will allow the data from the DTE to looped back to itself. Emun external(3) is write only. The only valid response to a READ is lineloopOn(2) or lineloopOff(1). To halt this test you must SET the sc5520DiagTestReset object. Reading test results via the sc5520DiagBitErrors or sc5520DiagBlockErrors objects while the test is running will also cause the test to terminate. There are no test results associated with this test. ')
sc5520DiagIntLineloop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("lineloopOff", 1), ("lineloopOn", 2), ("blocks1", 3), ("blocks10", 4), ("blocks100", 5), ("blocks500", 6), ("blocks1000", 7), ("blocks5000", 8), ("blocks10000", 9), ("blocks50000", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DiagIntLineloop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagIntLineloop.setDescription('Lineloop (or Analoop) can be either a Bilaterial or Unilaterial loopback depending on option ddsDteTermaloop. To initiate a Lineloop with Selftest SET this object and specifiy a blocksize. The blocksize indicates the number of blocks the Selftest pattern generator will run. There are 1000 bits/block. Emuns 3 through 10 are write only. The only valid responses to a READ are lineloopOn(2) or lineloopOff(1). This test will terminate after the specified number of blocks have been run. Reading test results via the sc5520DiagBitErrors or sc5520DiagBlockErrors objects while the test is running will cause the test to terminate prematurely and render the results invalid. Test results should be only read after the test is completed. The current Test Status can be obtained by reading this object or the nms520DiagTestStatus object on the unit under test. This test can also be terminated by seting the sc5520DiagTestReset object. ')
sc5520DiagExtDataloop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dataloopOff", 1), ("dataloopOn", 2), ("external", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DiagExtDataloop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagExtDataloop.setDescription('To initiate a Dataloop test with no Selftest SET this object and specifiy external, this will allow the data from the DTE attached to the far end unit (nms520) to looped back to itself. Emun external(3) is write only. The only valid response to a READ is dataloopOn(2) or dataloopOff(1). To halt this test you must SET the sc5520DiagTestReset object. Reading test results via the sc5520DiagBitErrors or sc5520DiagBlockErrors objects while the test is running will also cause the test to terminate. There are no test results associated with this test. Reading test status on the remote unit via nms520DiagTestStatus may interfere with the diagonostic test pattern generated from the terminal equiptment. ')
sc5520DiagTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("noTest", 1), ("externalLineloop", 2), ("internalLineloop", 3), ("externalDataloop", 4), ("serviceTestCenterLoop", 5), ("endToend", 6), ("remoteLoop", 7), ("remoteLoopWithSelfTest", 8), ("networkDelay", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520DiagTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagTestStatus.setDescription('This object gives the current diagonostic test status. noTest indicates that no diagonostic test is currently active. ')
sc5520DiagExtRemoteLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("remoteloopOff", 1), ("remoteloopOn", 2), ("external", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DiagExtRemoteLoop.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagExtRemoteLoop.setDescription('Point to Point Application only. To initiate a Remoteloop test with no Selftest SET this object and specifiy external. The sc5520 DSE transmitt an in-band command to its remote DSU, directing the remote to loop received signals back onto the network. The DSE is configurable to send (and accept) either a V.54 or a PN127 remote loop command. The remote DSU must be configured to accept the same command the DSE transmits. Emun external(3) is write only. The only valid response to a READ is remoteloopOn(2) or remoteloopOff(1). To halt this test you must SET the sc5520DiagTestReset object unless option RemLoopTimeOut is enabled. If enable maximum test time is 10 minutes. Reading test results via the sc5520DiagBitErrors or sc5520DiagBlockErrors objects while the test is running will also cause the test to terminate. There are no test results associated with this test. Reading test status on the remote unit via nms520DiagTestStatus may interfere with the diagonostic test pattern generated from the terminal equipment. The Remote Loop Function is for use ONLY on point to point links.')
sc5520DiagRemLoopWithSelf = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("remoteloopOff", 1), ("remoteloopOn", 2), ("blocks1", 3), ("blocks10", 4), ("blocks100", 5), ("blocks500", 6), ("blocks1000", 7), ("blocks5000", 8), ("blocks10000", 9), ("blocks50000", 10)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DiagRemLoopWithSelf.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DiagRemLoopWithSelf.setDescription('To initiate a Remoteloop with Selftest SET this object and specifiy a blocksize. The remote unit will go into remoteloop and the master (the sc5520) unit will go into Selftest. The sc5520 transmits an in-band command to its remote DSU, directing the remote to loop received signals back onto the network. The DSE is configurable to send (and accept) either a V.54 or a PN 127 remote loop command. The remote DSU must be configured to accept the same command the DSE transmits. The sc5520 enables its internal Test Pattern Generator to provide the signal for the Remote Loop and enables its Test Pattern Checker to verify the signal. The DSE is isolated from its DTE while the Test Pattern Generator and Checker are enabled. The blocksize indicates the number of blocks the Selftest pattern generator will run. There are 1000 bits/block. Emuns 3 through 10 are write only. If option Remlooptimeout is enabled then the maximum test time is 10 minutes otherwise block size time is used. The only valid responses to a READ are remoteloopOn(2) or remoteloopOff(1). This test will terminate after the specified number of blocks have been run. Reading test results via the sc5520DiagBitErrors or sc5520DiagBlockErrors objects while the test is running will cause the test to terminate prematurely and render the results invalid. Test results should be read only after the test is completed and are available from the master (sc5520) unit. The current Test Status can be obtained by reading the sc5520DiagTestStatus object on the master unit, reading test status on the remote unit may interfere with the diagonostic test pattern and cause errors. This test can also be terminated by seting the nms520DiagTestReset object. ')
sc5520VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 8, 3, 8), )
if mibBuilder.loadTexts: sc5520VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520VersionTable.setDescription(' ')
sc5520VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1), ).setIndexNames((0, "SC5520-MIB", "sc5520VersionIndex"))
if mibBuilder.loadTexts: sc5520VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520VersionEntry.setDescription('An entry in the GDC SC5520 Version Table.')
sc5520VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520VersionIndex.setDescription('Identifies Version parameters associated with the managed object.')
sc5520ActiveFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520ActiveFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520ActiveFirmwareRev.setDescription('The version number of the firmware currently executing. The format is MM.NN.BB where: MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
sc5520StoredFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520StoredFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520StoredFirmwareRev.setDescription('The version number of the firmware stored (in a compressed format) but not currently executing. MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) ')
sc5520BootRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520BootRev.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520BootRev.setDescription('The version number of the bootstrap firmware. The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. ')
sc5520StoredFirmwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("statBlank", 1), ("statDownLoading", 2), ("statOK", 3), ("statCheckSumBad", 4), ("statUnZipping", 5), ("statBadUnZip", 6), ("statDownloadAborted", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sc5520StoredFirmwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520StoredFirmwareStatus.setDescription('This object represents the state of the Non-Active or Stored firmware: statBlank(1) Factory Default statDownLoading(2) In process of downloading firmware statOK(3) Zipped version checksum succesful (OK to switch) (can set sc5520SwitchActive to switchActive(2)) statCheckSumBad(4) Failed checksum after download statUnZipping(5) In process of uncompressing into active area statBadUnZip(6) Failed last uncompress statDownloadAborted(7) Download aborted by user The object is read only. ')
sc5520SwitchActiveFirmware = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNorm", 1), ("switchActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520SwitchActiveFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520SwitchActiveFirmware.setDescription('This object is used to switch the active executing firmware from the version in sc5520ActiveRev to the version in sc5520StoredRev. When a switchActive(2) is set (write only) the element will: 1) reboot 2) uncompress stored code into active area 3) perform checksum on active area 4) Set sc5520StoredStatus object to indicate results 5) If succesfull: update sc5520ActiveFirmwareRev and sc5520StoredFirmwareRev and begin executing If failed: replace active area with previous revision The switchNorm(1) enumeration will always be read. Setting switchActive(2) when the sc5520StoredStatus is not statOK(3) will result in an error. ')
sc5520DownloadingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 8, 3, 8, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disableAll", 1), ("enableAndWait", 2), ("enableAndSwitch", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sc5520DownloadingMode.setStatus('mandatory')
if mibBuilder.loadTexts: sc5520DownloadingMode.setDescription('This object is used to configure the download mode: disableAll(1) Prevents any firmware downloading to SC5520 enableAndWait(2) Allows downloading zipped code to be stored only! enableAndSwitch(3) Allows downloading and then unzips and begins executing the new code ')
mibBuilder.exportSymbols("SC5520-MIB", sc5520DiagIntLineloop=sc5520DiagIntLineloop, sc5520MasterIndex=sc5520MasterIndex, sc5520BootRev=sc5520BootRev, sc5520EIARemLoop=sc5520EIARemLoop, sc5520PiggyBackDetect=sc5520PiggyBackDetect, sc5520MaintTable=sc5520MaintTable, sc5520RemLoopAllowed=sc5520RemLoopAllowed, sc5520DteCtsDelay=sc5520DteCtsDelay, sc5520DiagTestStatus=sc5520DiagTestStatus, sc5520RxcShortedAlm=sc5520RxcShortedAlm, sc5520AddRemoteAddress=sc5520AddRemoteAddress, sc5520VersionIndex=sc5520VersionIndex, sc5520SysUpTime=sc5520SysUpTime, sc5520UnitCfgIndex=sc5520UnitCfgIndex, sc5520TxcShortedAlm=sc5520TxcShortedAlm, sc5520EnableRemoteAlarm=sc5520EnableRemoteAlarm, sc5520AlarmHystTime=sc5520AlarmHystTime, sc5520PowerUpAlm=sc5520PowerUpAlm, sc5520SoftReset=sc5520SoftReset, sc5520DiagCfgEntry=sc5520DiagCfgEntry, sc5520AlarmData=sc5520AlarmData, sc5520DBUFailedAlm=sc5520DBUFailedAlm, sc5520MtpointRmRspIntrvl=sc5520MtpointRmRspIntrvl, sc5520StoredFirmwareStatus=sc5520StoredFirmwareStatus, sc5520NoResponseAlm=sc5520NoResponseAlm, sc5520DteCtsDelayExt=sc5520DteCtsDelayExt, sc5520FpTestAlm=sc5520FpTestAlm, sc5520DiagCfgIndex=sc5520DiagCfgIndex, sc5520DcdShortedAlm=sc5520DcdShortedAlm, sc5520FrontPanelEnable=sc5520FrontPanelEnable, sc5520DiagExtLineloop=sc5520DiagExtLineloop, sc5520UnitCfgTable=sc5520UnitCfgTable, sc5520RateBroadcast=sc5520RateBroadcast, sc5520StoredFirmwareRev=sc5520StoredFirmwareRev, sc5520BlinkINS=sc5520BlinkINS, sc5520CSULoopbackAlm=sc5520CSULoopbackAlm, sc5520DiagTestReset=sc5520DiagTestReset, sc5520DownloadingMode=sc5520DownloadingMode, sc5520RxdShortedAlm=sc5520RxdShortedAlm, sc5520VersionTable=sc5520VersionTable, sc5520DtePortType=sc5520DtePortType, sc5520RemLoopTimeout=sc5520RemLoopTimeout, sc5520CircuitType=sc5520CircuitType, sc5520MasterTable=sc5520MasterTable, sc5520VersionEntry=sc5520VersionEntry, sc5520EIALineLoop=sc5520EIALineLoop, sc5520DiagRxErrAlm=sc5520DiagRxErrAlm, sc5520TelcoLatchingLoop=sc5520TelcoLatchingLoop, sc5520TmShortedAlm=sc5520TmShortedAlm, sc5520DTRLossAlm=sc5520DTRLossAlm, sc5520=sc5520, sc5520WakeUpRemote=sc5520WakeUpRemote, sc5520EnableAllRemoteAlarms=sc5520EnableAllRemoteAlarms, sc5520DiagTestExceptions=sc5520DiagTestExceptions, sc5520DiagTimeDelay=sc5520DiagTimeDelay, sc5520MaintEntry=sc5520MaintEntry, sc5520PrivateStorage1=sc5520PrivateStorage1, sc5520MIBversion=sc5520MIBversion, sc5520UnitCfgEntry=sc5520UnitCfgEntry, sc5520DiagExtDataloop=sc5520DiagExtDataloop, sc5520SwitchActiveFirmware=sc5520SwitchActiveFirmware, sc5520DSRLossAlm=sc5520DSRLossAlm, sc5520ExcDiagEntry=sc5520ExcDiagEntry, sc5520DelRemoteAddress=sc5520DelRemoteAddress, sc5520HdlcInvert=sc5520HdlcInvert, sc5520BkPlaneFracIfIndex=sc5520BkPlaneFracIfIndex, sc5520DBUOnAlm=sc5520DBUOnAlm, sc5520DiagBlockErrors=sc5520DiagBlockErrors, sc5520MaintIndex=sc5520MaintIndex, sc5520ListOfRemotes=sc5520ListOfRemotes, sc5520DCDLossAlm=sc5520DCDLossAlm, sc5520PtToPtSentryTime=sc5520PtToPtSentryTime, sc5520PrivateStorage2=sc5520PrivateStorage2, sc5520PrivateStorage3=sc5520PrivateStorage3, sc5520DiagBitErrors=sc5520DiagBitErrors, sc5520DisableRemoteAlarm=sc5520DisableRemoteAlarm, sc5520DiagSendCode=sc5520DiagSendCode, sc5520DiagRemLoopWithSelf=sc5520DiagRemLoopWithSelf, sc5520ExcDiagTable=sc5520ExcDiagTable, sc5520BkPlaneFracNum=sc5520BkPlaneFracNum, sc5520DiagExtRemoteLoop=sc5520DiagExtRemoteLoop, sc5520MasterTableEntry=sc5520MasterTableEntry, sc5520DTPLossAlm=sc5520DTPLossAlm, sc5520TXDLossAlm=sc5520TXDLossAlm, sc5520RemLoopPattern=sc5520RemLoopPattern, sc5520LedStatus=sc5520LedStatus, sc5520ActiveFirmwareRev=sc5520ActiveFirmwareRev, sc5520DisableAllRemoteAlarms=sc5520DisableAllRemoteAlarms, sc5520RXDLossAlm=sc5520RXDLossAlm, sc5520DBURequestForScanAlm=sc5520DBURequestForScanAlm, sc5520Nms510CompatibilityMode=sc5520Nms510CompatibilityMode, sc5520ExcDiagIndex=sc5520ExcDiagIndex, sc5520FirmwareLevel=sc5520FirmwareLevel, sc5520EEChkSumErrAlm=sc5520EEChkSumErrAlm, sc5520DsrShortedAlm=sc5520DsrShortedAlm, sc5520DiagCfgTable=sc5520DiagCfgTable, sc5520CtsShortedAlm=sc5520CtsShortedAlm, sc5520FrontPanelInhibit=sc5520FrontPanelInhibit)

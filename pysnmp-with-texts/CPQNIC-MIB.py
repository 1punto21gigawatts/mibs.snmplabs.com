#
# PySNMP MIB module CPQNIC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CPQNIC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:27:44 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
cpqHoTrapFlags, compaq = mibBuilder.importSymbols("CPQHOST-MIB", "cpqHoTrapFlags", "compaq")
cpqSiServerSystemId, = mibBuilder.importSymbols("CPQSINFO-MIB", "cpqSiServerSystemId")
cpqSePciSlotBoardName, = mibBuilder.importSymbols("CPQSTDEQ-MIB", "cpqSePciSlotBoardName")
ipAdEntAddr, = mibBuilder.importSymbols("IP-MIB", "ipAdEntAddr")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
sysName, = mibBuilder.importSymbols("SNMPv2-MIB", "sysName")
Counter32, ModuleIdentity, TimeTicks, iso, Unsigned32, ObjectIdentity, Bits, NotificationType, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, IpAddress, MibIdentifier, NotificationType, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "TimeTicks", "iso", "Unsigned32", "ObjectIdentity", "Bits", "NotificationType", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "IpAddress", "MibIdentifier", "NotificationType", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cpqNic = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18))
cpqNicMibRev = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 1))
cpqNicComponent = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 2))
cpqNicInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 2, 1))
cpqNicIfLogMap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 2, 2))
cpqNicIfPhysAdapter = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 2, 3))
cpqNicOsCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4))
cpqNicIfVlanMap = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 2, 4))
cpqNicVirusThrottle = MibIdentifier((1, 3, 6, 1, 4, 1, 232, 18, 2, 5))
cpqNicMibRevMajor = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicMibRevMajor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicMibRevMajor.setDescription('The Major Revision level of the MIB. A change in the major revision level represents a major change in the architecture of the MIB. A change in the major revision level may indicate a significant change in the information supported and/or the meaning of the supported information. Correct interpretation of data may require a MIB document with the same major revision level.')
cpqNicMibRevMinor = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicMibRevMinor.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicMibRevMinor.setDescription('The Minor Revision level of the MIB. A change in the minor revision level may represent some minor additional support, no changes to any pre-existing information has occurred.')
cpqNicMibCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicMibCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicMibCondition.setDescription('The overall condition. This object represents the overall status of the system represented by this MIB.')
cpqNicOsCommonPollFreq = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpqNicOsCommonPollFreq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicOsCommonPollFreq.setDescription("The Insight Agent's polling frequency. The frequency, in seconds, at which the Insight Agent requests information from the device driver. A frequency of zero (0) indicates that the Insight Agent retrieves the information upon request of a management station, it does not poll the device driver at a specific interval. If the poll frequency is zero (0) all attempts to write to this object will fail. If the poll frequency is non-zero, setting this value will change the polling frequency of the Insight Agent. Setting the poll frequency to zero (0) will always fail. An agent may choose to fail any request to change the poll frequency to a value that would severely impact system performance.")
cpqNicOsCommonModuleTable = MibTable((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 2), )
if mibBuilder.loadTexts: cpqNicOsCommonModuleTable.setStatus('deprecated')
if mibBuilder.loadTexts: cpqNicOsCommonModuleTable.setDescription('A table of software modules that provide an interface to the device this MIB describes.')
cpqNicOsCommonModuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 2, 1), ).setIndexNames((0, "CPQNIC-MIB", "cpqNicOsCommonModuleIndex"))
if mibBuilder.loadTexts: cpqNicOsCommonModuleEntry.setStatus('deprecated')
if mibBuilder.loadTexts: cpqNicOsCommonModuleEntry.setDescription('A description of a software module that provides an interface to the device this MIB describes.')
cpqNicOsCommonModuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicOsCommonModuleIndex.setStatus('deprecated')
if mibBuilder.loadTexts: cpqNicOsCommonModuleIndex.setDescription('A unique index for this module description.')
cpqNicOsCommonModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicOsCommonModuleName.setStatus('deprecated')
if mibBuilder.loadTexts: cpqNicOsCommonModuleName.setDescription('The module name.')
cpqNicOsCommonModuleVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicOsCommonModuleVersion.setStatus('deprecated')
if mibBuilder.loadTexts: cpqNicOsCommonModuleVersion.setDescription('The module version in XX.YY format. Where XX is the major version number and YY is the minor version number. This field will be null (size 0) string if the agent cannot provide the module version.')
cpqNicOsCommonModuleDate = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 2, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicOsCommonModuleDate.setStatus('deprecated')
if mibBuilder.loadTexts: cpqNicOsCommonModuleDate.setDescription('The module date. field octets contents range ===== ====== ======= ===== 1 1-2 year 0..65536 2 3 month 1..12 3 4 day 1..31 4 5 hour 0..23 5 6 minute 0..59 6 7 second 0..60 (use 60 for leap-second) This field will be set to year = 0 if the agent cannot provide the module date. The hour, minute, and second field will be set to zero (0) if they are not relevant. The year field is set with the most significant octet first.')
cpqNicOsCommonModulePurpose = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicOsCommonModulePurpose.setStatus('deprecated')
if mibBuilder.loadTexts: cpqNicOsCommonModulePurpose.setDescription('The purpose of the module described in this entry.')
cpqNicIfLogMapTable = MibTable((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1), )
if mibBuilder.loadTexts: cpqNicIfLogMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapTable.setDescription('A table of interface to logical hardware mappings.')
cpqNicIfLogMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1), ).setIndexNames((0, "CPQNIC-MIB", "cpqNicIfLogMapIndex"))
if mibBuilder.loadTexts: cpqNicIfLogMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapEntry.setDescription('A mapping of an interface table entry to logical hardware.')
cpqNicIfLogMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapIndex.setDescription('An index that uniquely specifies this entry.')
cpqNicIfLogMapIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapIfNumber.setDescription("An OCTET STRING representing an array of MIB II Interface Numbers implemented by this logical adapter. Each entry is a 32-bit value, represented by 4 octets in LSB...MSB (Little-Endian) order. There may be 0 or more Interface Numbers on a particular logical adapter, depending on the operating system's assignment of Interface Numbers. There is an interface number field in the cpqNicIfPhysAdapterTable which may contain one or more interface numbers. For logical adapters with one Physical Adapter, the same Interface Number(s) may appear in both tables.")
cpqNicIfLogMapDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapDescription.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapDescription.setDescription('Description of the logical adapter. This string is NULL terminated.')
cpqNicIfLogMapGroupType = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("unknown", 1), ("none", 2), ("redundantPair", 3), ("nft", 4), ("alb", 5), ("fec", 6), ("gec", 7), ("ad", 8), ("slb", 9), ("tlb", 10), ("redundancySet", 11)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapGroupType.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapGroupType.setDescription('The type of Fault Tolerance supplied by this logical adapter. The following types of Fault Tolerance are supported: unknown(1) Indicates that the instrument agent does not recognize the controller. You may need to upgrade the instrument agent. none(2) Indicates the logical adapter is not fault tolerant. There is a single physical adapter associated with the logical adapter. redundantPair(3) Indicates that the logical adapter has two adapters associated with it. One adapter is active and the other adapter is a hot standby. No longer used. nft(4) Network Fault Tolerance. The logical adapter has two or more adapters associated with it. One adapter is active on the network and the other(s) are hot standby(s). alb(5) Adaptive Load Balancing. Indicates that the logical adapter has more than one physical adapter associated with it. One adapter transmits and receives, while the others only transmit. If the receiving adapter fails, one of the other adapters assumes this role. No longer used. fec(6) Fast EtherChannel. This allows all physical adapters associated with the logical adapter to both receive and transmit. This requires a switch that cooperates with the adapters. If any adapter fails, the load is spread among the remaining adapters. No longer used. gec(7) Gigabit EtherChannel. This allows all physical adapters associated with the logical adapter to both receive and transmit. This requires a gigabit switch that cooperates with the adapters. If any adapter fails, the load is spread among the remaining adapters. No longer used. ad(8) IEEE802.3ad Link Aggregation. This allows all physical adapters associated with the logical adapter to both receive and transmit. This requires a switch that cooperates with the adapters. If any adapter fails, the load is spread among the remaining adapters. No longer used. slb(9) Switch-assisted load balancing. This allows all physical adapters associated with the logical adapter to both receive and transmit. This requires a switch that cooperates with the adapters. If any adapter fails, the load is spread among the remaining adapters. Aggregates fec, gec, and ad. tlb(10) Transmit Load Balancing. Indicates that the logical adapter has more than one physical adapter associated with it. One adapter transmits and receives, while the others only transmit. If the receiving adapter fails, one of the other adapters assumes this role. Formerly alb. redundancySet(11) Indicates that the logical adapter has more than one adapter associated with it. This value is used when the type of the team could not be determined.')
cpqNicIfLogMapAdapterCount = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapAdapterCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapAdapterCount.setDescription('The number of physical adapters associated with this logical adapter.')
cpqNicIfLogMapAdapterOKCount = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapAdapterOKCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapAdapterOKCount.setDescription('The number of physical adapters associated with this logical adapter that have an OK condition.')
cpqNicIfLogMapPhysicalAdapters = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapPhysicalAdapters.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapPhysicalAdapters.setDescription('An array of octets corresponding to the indices in the cpqNicIfPhysAdapterTable of the physical adapters associated with this logical adapter. The number of octets is equal to cpqNicIfLogMapAdapterCount.')
cpqNicIfLogMapMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapMACAddress.setDescription('The MAC (physical) address that the logical adapter presents to the network.')
cpqNicIfLogMapSwitchoverMode = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("none", 2), ("manual", 3), ("switchOnFail", 4), ("preferredPrimary", 5), ("auto", 6), ("preferenceOrder", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapSwitchoverMode.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapSwitchoverMode.setDescription('The algorithm used to determine when to switch network traffic from one adapter to another. The following algorithms are supported: unknown(1) Indicates that the instrument agent does not recognize the controller. You may need to upgrade the instrument agent. none(2) Indicates the logical adapter is not fault tolerant. There is a single physical adapter associated with the logical adapter. manual(3) Indicates that the logical adapter has more than one physical adapter associated with it. In order to switch from the active adapter to a standby adapter, user action is required. switchOnFail(4) Indicates that the logical adapter has more than one physical adapter associated with it. If a failure of the active adapter is detected, network traffic will automatically switch to a standby adapter. The standby adapter will remain active until some action (manual switch, system restart) restores the primary adapter to active. preferredPrimary(5) Indicates that the logical adapter has more than one physical adapter associated with it. If a failure of the active adapter is detected, network traffic will automatically switch to a standby adapter. If the original primary adapter recovers from the failure, it will automatically become active again. auto(6) Indicates that the logical adapter is not in manual failover mode. preferenceOrder(7) Indicates that the logical adapter has more than one physical adapter associated with it. When a failure of the active adapter is detected, network traffic automatically switchs to one standby adapter. The relative priority of adapters are used to select the new primary adapter.')
cpqNicIfLogMapCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapCondition.setDescription('The condition of this interface. This value represents the overall condition of the logical adapter group. This value is driven by the cpqNicIfLogMapStatus object as follows: other(1) Indicates that the value of the Logical Map Status is unknown(1). ok(2) Indicates that the value of the Logical Map Status is ok(2). degraded(3) Indicates that the value of the Logical Map Status is either primaryFailed(3) or standbyFailed(4). The Logical adapter still functions in this state, but performance and redundancy are degraded. failed(4) Indicates that the value of the Logical Map Status is groupFailed(5). This indicates that all the adapters in the logical group have failed and no network traffic is occurring.')
cpqNicIfLogMapStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("primaryFailed", 3), ("standbyFailed", 4), ("groupFailed", 5), ("redundancyReduced", 6), ("redundancyLost", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapStatus.setDescription('The status of the logical group. The following values are valid for the logical group status: unknown(1) The instrument agent may not support this value. You may need to load a new instrument agent. ok(2) The adapter group is functioning properly. primaryFailed(3) The adapter specified as primary in the group has failed. the group is still functioning and one of the standby adapters has assumed the role of primary. Depending on the number of adapters in the group, redundancy may be lost. standbyFailed(4) An adapter specified as standby or secondary in the group has failed. the group is still functioning and one of the standby adapters has assumed the role of primary. Depending on the number of adapters in the group, redundancy may be lost. groupFailed(5) All adapters in the group have failed. Network connectivity has been lost for the group. This status will be returned for logical groups with a single physical adapter that has failed. redundancyReduced(6) Atleast one adapter in the team has failed but there are more than one adapter available. redundancyLost(7) Only one adapter in the team is functioning properly. If this adapter fails, the team will go to failed status.')
cpqNicIfLogMapNumSwitchovers = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapNumSwitchovers.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapNumSwitchovers.setDescription('The number of times a fault tolerant switchover has occurred. Switchovers occur because the primary adapter fails.')
cpqNicIfLogMapHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfLogMapHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the adapters. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqNicIfLogMapSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapSpeed.setDescription("An estimate of the interface's current bandwidth in bits per second. For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.")
cpqNicIfLogMapVlanCount = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapVlanCount.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapVlanCount.setDescription('The number of VLANs associated with this logical adapter.')
cpqNicIfLogMapVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapVlans.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapVlans.setDescription('An array of octets corresponding to the indices in the cpqNicIfVlanMapTable of the VLANs associated with this logical adapter. The number of octets is equal to cpqNicIfLogMapVlanCount.')
cpqNicIfLogMapLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapLastChange.setDescription('The time the underlying link associated with this interface changed its status from either link up to link down or link down to link up.')
cpqNicIfLogMapAdvancedTeaming = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapAdvancedTeaming.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapAdvancedTeaming.setDescription('This bitmap indicates the advanced features being used by the logical adapter (team). cpqNicIfLogMapAdvancedTeaming AND 1 is 1, Active Path Failover is enabled. cpqNicIfLogMapAdvancedTeaming AND 2 is 2, Fast Path Failover is enabled. cpqNicIfLogMapAdvancedTeaming AND 4 is 4, Static dual channel is enabled. cpqNicIfLogMapAdvancedTeaming AND 8 is 8, Dynamic dual channel is enabled. cpqNicIfLogMapAdvancedTeaming AND 16 is 16, Router Path Failover is enabled. ')
cpqNicIfLogMapSpeedMbps = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapSpeedMbps.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfLogMapSpeedMbps.setDescription("An estimate of the interface's current bandwidth in Megabits per second. For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.")
cpqNicIfLogMapIPV6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapIPV6Address.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfLogMapIPV6Address.setDescription('The CIDR(Classless Inter-Domain Routing) notation that the logical adapter presents to the network.')
cpqNicIfLogMapLACNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 1, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapLACNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfLogMapLACNumber.setDescription('Local Area Connection number that the logical adapter presents to the network.')
cpqNicIfLogMapOverallCondition = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfLogMapOverallCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfLogMapOverallCondition.setDescription('The overall condition of all interfaces. This object is the worst case of any individual interface. For example, if there is one degraded interface, this variable will have a value of degraded(3). If there is one failed interface, this variable will have a value of failed(4).')
cpqNicIfPhysAdapterTable = MibTable((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1), )
if mibBuilder.loadTexts: cpqNicIfPhysAdapterTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterTable.setDescription('A table of physical adapters.')
cpqNicIfPhysAdapterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1), ).setIndexNames((0, "CPQNIC-MIB", "cpqNicIfPhysAdapterIndex"))
if mibBuilder.loadTexts: cpqNicIfPhysAdapterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterEntry.setDescription('A physical adapter table entry.')
cpqNicIfPhysAdapterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIndex.setDescription('An index that uniquely specifies this entry.')
cpqNicIfPhysAdapterIfNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIfNumber.setDescription("An OCTET STRING representing an array of MIB II Interface Numbers implemented by this physical adapter. Each entry is a 32-bit value, represented by 4 octets in LSB...MSB (Little-Endian) order. There may be 0 or more Interface Numbers on a particular physical adapter, depending on the operating system's assignment of Interface Numbers. There is also an Interface Number field in the cpqNicIfLogMapTable which may contain one or more Interface Numbers. For logical adapters with one Physical Adapter, the same Interface Number(s) appear in both tables.")
cpqNicIfPhysAdapterRole = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("unknown", 1), ("primary", 2), ("secondary", 3), ("member", 4), ("txRx", 5), ("tx", 6), ("standby", 7), ("none", 8), ("notApplicable", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterRole.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterRole.setDescription('The role this physical adapter has in the logical group. The following values are valid: unknown(1) The role of the adapter could not be determined. This indicates a problem with the instrument agent. A new agent may need to be installed. primary(2) The adapter is the primary adapter in the group, or the group consists of a single adapter. The primary adapter in a Single Pair or NFT group handles all the network traffic unless it fails. The primary adapter in an ALB group receives all traffic. The physical address of this adapter is the default address of the group. In a FEC group, an arbitrary adapter is designated as primary, but all adapters are equal and participate fully on the network. secondary(3) In Single Pair and NFT groups, this adapter functions as a hot standby. No network traffic is handled by this adapter other than periodic test packets. In an ALB group, this adapter is in a secondary role and transmits packets to increase bandwidth. In an FEC group, this adapter participates fully in network traffic. member(4) The adapter is a member of a Switch Assisted Load Balancing Team. The adapter participates fully in network traffic. TxRx(5) The adapter can transmit and receive. Tx(6) The adapter can only transmit. standby(7) The adapter does not transmit or receive. It can go to TxRx or Tx when required. none(8) The adapter is not in use. notApplicable(255) The physical adapter is not a member of any group.')
cpqNicIfPhysAdapterMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterMACAddress.setDescription('The physical (MAC) address of the adapter. In some configurations this may be a null length octet string.')
cpqNicIfPhysAdapterSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSlot.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSlot.setDescription('The number of the slot containing the physical hardware that implements this interface. The number zero (0) indicates an embedded interface (on the system board). A value of -1 indicates an interface whose slot is unknown. Values may be unknown if the physical hardware has not been configured using the System Configuration Utility.')
cpqNicIfPhysAdapterIoAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIoAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIoAddr.setDescription('The base I/O address of the physical adapter. The number zero (0) indicates that the device does not use I/O mapped addresses or this information is unavailable.')
cpqNicIfPhysAdapterIrq = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIrq.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIrq.setDescription('The number of the IRQ (interrupt) used for this physical hardware interface. The number zero (0) indicates that this device does not use an IRQ or this information is unavailable.')
cpqNicIfPhysAdapterDma = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterDma.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterDma.setDescription('The number of the DMA channel used for this physical hardware interface. The number -1 indicates that this device does not use a DMA channel or this information is unavailable.')
cpqNicIfPhysAdapterMemAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterMemAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterMemAddr.setDescription('The base memory address used by this physical hardware interface. The number zero (0) indicates that this device does not use system memory or this information is unavailable.')
cpqNicIfPhysAdapterPort = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterPort.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterPort.setDescription('The port number of the interface for multi-port NICs. A port number of -1 indicates that the port could not be determined.')
cpqNicIfPhysAdapterDuplexState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("half", 2), ("full", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterDuplexState.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterDuplexState.setDescription('This variable describes the current duplex state of the adapter. A value of unknown indicates that the duplex state could not be determined.')
cpqNicIfPhysAdapterCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("ok", 2), ("degraded", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterCondition.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterCondition.setDescription('The condition of this physical adapter. This value is driven by the cpqNicIfPhysAdapterStatus object as follows: other(1) Indicates that the value of the Physical Adapter Status is unknown(1). ok(2) Indicates that the value of the Physical Adapter Status is ok(2). degraded(3) Defined for all condition variables, but is not applicable for single adapters. failed(4) Indicates that the value of the Physical Adapter Status is linkFailure(4).')
cpqNicIfPhysAdapterState = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("active", 2), ("standby", 3), ("failed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterState.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterState.setDescription('The fault tolerant state of this adapter. Although this value is valid for adapters that are not part of a fault tolerant group, it only provides additional information when the adapter participates in a group. The following values are valid: unknown(1) The fault tolerant state could not be determined. The instrument agent may need to be upgraded. active(2) The adapter is actively participating in the network. This state is displayed for adapters that are not part of a fault tolerant group and for adapters in a fault tolerant group that are not in the standby state. standby(3) The adapter is ready to assume network activity in case of a failure of the active adapter. failed(4) The adapter has failed and cannot participate on the network.')
cpqNicIfPhysAdapterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("ok", 2), ("generalFailure", 3), ("linkFailure", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterStatus.setDescription('The physical adapter status. The following values are valid: unknown(1) The instrument agent was not able to determine the status of the adapter. The instrument agent may need to be upgraded. ok(2) The physical adapter is operating properly. generalFailure(3) The physical adapter has failed. linkFailure(4) The physical adapter has lost link. Check the cable connections to this adapter.')
cpqNicIfPhysAdapterStatsValid = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterStatsValid.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterStatsValid.setDescription('This value indicates whether the following statistics in the table are accurate. Some adapters may not be able to report the statistics accurately, and the statistics should not be reported for these adapters. The following values are valid: true(1) The statistics are accurate. false(2) The statistics are not accurate and should not be used.')
cpqNicIfPhysAdapterGoodTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterGoodTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterGoodTransmits.setDescription('A count of frames successfully transmitted by the physical adapter.')
cpqNicIfPhysAdapterGoodReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterGoodReceives.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterGoodReceives.setDescription('A count of frames successfully received by the physical adapter.')
cpqNicIfPhysAdapterBadTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterBadTransmits.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterBadTransmits.setDescription('A count of frames that were not transmitted by the adapter because of an error. This counter is the sum of MIB items cpqNicIfPhysAdapterDeferredTransmissions cpqNicIfPhysAdapterLateCollisions, cpqNicIfPhysAdapterExcessiveCollisions, cpqNicIfPhysAdapterCarrierSenseErrors, and cpqNicIfPhysAdapterInternalMacTransmitErrors. If this counter increments frequently, check the more detailed error statistics and take appropriate action.')
cpqNicIfPhysAdapterBadReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterBadReceives.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterBadReceives.setDescription('A count of frames that were received by the adapter but which had an error. This counter is the sum of mib items cpqNicIfPhysAdapterAlignmentErrors, cpqNicIfPhysAdapterFCSErrors, cpqNicIfPhysAdapterFrameTooLongs, and cpqNicIfPhysAdapterInternalMacReceiveErrors. If this counter increments frequently, check the more detailed error statistics and take appropriate action.')
cpqNicIfPhysAdapterAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterAlignmentErrors.setDescription("A count of frames received on a particular interface that are not an integral number of octets in length and do not pass the FCS check. The alignment of a frame is checked by the receiver after the packet has failed the Cyclical Redundancy Check (CRC). Misaligned packets do not end on an 8-bit boundary. All packets contain a set number of bytes and must end after a defined number of bytes. Packets that do not end on a byte boundary fail the alignment check. Faulty components may be the cause of alignment errors. Check the following: Segment too long: Nodes at the far end of the cabling system transmit, unaware that a station at the other end has already gained control of the medium by transmitting the first 64 bytes of a frame. Failing cable: Packet data traveling through shorted or damaged cabling may become corrupt before reaching the destination station. Segment not grounded properly: Improper grounding of a segment may allow ground-induced noise to corrupt data flow. Improper termination: If a cable segment is not properly terminated, allowing the signal to be absorbed upon reaching the end of the segment, a partial signal will bounce back and collide with existing signals. Noisy cable: Interference or noise produced by motors or other devices can distort the signals and cause CRC/Alignment errors. Deaf/partially deaf node: A faulty station that cannot hear the activity is considered a deaf node. If you suspect a deaf node, replace the NIC. Failing repeater, transceiver, or controller: Repeaters, transceivers, and controllers can disrupt the network signal, transmit erroneous signals on the wire, or ignore incoming packets. Perform the following steps: 1. If your NIC is continuously transmitting, it causes erroneous signals, or 'jabber'. Replace a jabbering transmitter to ensure proper network performance. 2. Check your hub or switch. This component may be at fault. Use the diagnostics from the component manufacturer to help you determine if a problem exists.")
cpqNicIfPhysAdapterFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterFCSErrors.setDescription("A count of frames received on a particular interface that are an integral number of octets in length but do not pass the FCS check. Faulty components may be the cause of FCS errors. Check the following: Segment too long: Nodes at the far end of the cabling system transmit, unaware that a station at the other end has already gained control of the medium by transmitting the first 64 bytes of a frame. Failing cable: Packet data traveling through shorted or damaged cabling may become corrupt before reaching the destination station. Segment not grounded properly: Improper grounding of a segment may allow ground-induced noise to corrupt data flow. Improper termination: If a cable segment is not properly terminated, allowing the signal to be absorbed upon reaching the end of the segment, a partial signal will bounce back and collide with existing signals. Noisy cable: Interference or noise produced by motors or other devices can distort the signals and cause CRC/Alignment errors. Deaf/partially deaf node: A faulty station that cannot hear the activity is considered a deaf node. If you suspect a deaf node, replace the NIC. Failing repeater, transceiver, or controller: Repeaters, transceivers, and controllers can disrupt the network signal, transmit erroneous signals on the wire, or ignore incoming packets. Perform the following steps: 1. If your NIC is continuously transmitting, it causes erroneous signals, or 'jabber'. Replace a jabbering transmitter to ensure proper network performance. 2. Check your hub or switch. This component may be at fault. Use the diagnostics from the component manufacturer to help you determine if a problem exists.")
cpqNicIfPhysAdapterSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSingleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSingleCollisionFrames.setDescription('The number of single collision packets: This counter contains the number of packets that are involved in a single collision and are subsequently transmitted successfully. These errors show that the network has light to moderate traffic. If single collisions become more frequent, the count for multiple collisions escalates.')
cpqNicIfPhysAdapterMultipleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterMultipleCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterMultipleCollisionFrames.setDescription('The number of multiple collision packets: This counter contains the number of packets that are involved in multiple collisions and are subsequently transmitted successfully. These errors mean that the network is experiencing moderate to heavy traffic. If multiple collisions become more frequent, the count for excessive collisions escalates.')
cpqNicIfPhysAdapterDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterDeferredTransmissions.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterDeferredTransmissions.setDescription('The number of packets deferred before transmission: This counter contains the number of packets whose transmission was delayed on its first attempt because the medium was busy. Packets involved in any collisions are not counted. Frames that wait before transmission are counted. This statistic will be incremented often during normal operation on a busy network. Deferred transmissions occur when the network is extremely busy; so busy that the NIC did not try to transmit. High counts of multiple collisions and excessive collisions also occur. Deferred transmissions indicate that this segment of the LAN is overcrowded. Reduce the traffic by reorganizing the LAN. For example, if you have 100 stations on one Ethernet bus, break it into two Ethernet segments by adding a NIC to your server. In this way you can balance the load by putting 50 stations on one segment and 50 on the other. If a few isolated stations create the traffic, put them on a separate segment.')
cpqNicIfPhysAdapterLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterLateCollisions.setDescription("Late collisions may be a symptom of cabling problems. A late collision is one that occurred 64 bytes or more into the packet. Late collisions may be an indication that a segment is longer than allowed by the wiring specifications. A station will believe it has control of the cable segment if it has already transmitted 64 bytes. If another node at the far end of the segment has not yet seen the packet, and transmits, this packet will collide with the first transmission after the first 64 bytes have been sent. Ensure that your segment length does not exceed the maximum length allowed. Because the location of cabling problems can be very difficult to detect on an Ethernet network, you may want to 'shorten' an Ethernet segment (remove portions of the network to isolate problems) until the problems are no longer seen, and then expand the network until the problem recurs. If this counter increments quickly in a short period of time, it may mean that the network card is running in half duplex mode, but your hub or switch port is configured for full duplex mode. Compare your network card's configuration with the port's configuration. Late collisions are also included in other collision-related statistics.")
cpqNicIfPhysAdapterExcessiveCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterExcessiveCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterExcessiveCollisions.setDescription("The number of packets aborted during transmission due to excessive collisions: This counter contains the number of packets that, due to excessive collisions, are not transmitted successfully. A station may attempt to transmit up to 16 times before it must abort the attempt. Once the abort occurs, this counter increments. If you see an increase in deferred transmissions as well as excessive collisions, the network is extremely busy and this segment of the LAN is overcrowded. Reduce the traffic by reorganizing your LAN or adding a NIC to the server. For example, if you have 100 stations on one Ethernet bus, break it into two Ethernet buses by adding a NIC to your server. In this way you can balance the load by putting 50 stations on one bus and 50 on the other. If there are a few isolated stations creating the traffic, try placing them on a separate bus. Faulty components may be the cause of excessive collisions. Check the following: Segment too long: Nodes at the far end of the cabling system transmit, unaware that a station at the other end has already gained control of the medium by transmitting the first 64 bytes of a frame. Failing cable: Packet data traveling through shorted or damaged cabling may become corrupt before reaching the destination station. Segment not grounded properly: Improper grounding of a segment may allow ground-induced noise to corrupt data flow. Improper termination: If a cable segment is not properly terminated, allowing the signal to be absorbed upon reaching the end of the segment, a partial signal will bounce back and collide with existing signals. Noisy cable: Interference or noise produced by motors or other devices can distort the signals and cause CRC/Alignment errors. Deaf/partially deaf node: A faulty station that cannot hear the activity is considered a deaf node. If you suspect a deaf node, replace the NIC. Failing repeater, transceiver, or controller: Repeaters, transceivers, and controllers can disrupt the network signal, transmit erroneous signals on the wire, or ignore incoming packets. Perform the following steps: 1. If your NIC is continuously transmitting, it causes erroneous signals, or 'jabber.' Replace a jabbering transmitter to ensure proper network performance. 2. Check your hub or switch. This component may be at fault. Use the diagnostics from the component manufacturer to help you determine if a problem exists.")
cpqNicIfPhysAdapterInternalMacTransmitErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterInternalMacTransmitErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterInternalMacTransmitErrors.setDescription('A count of frames for which transmission on a particular interface fails due to an internal MAC sublayer transmit error. A frame is only counted by an instance of this object if it is not counted by the corresponding instance of either the cpqNicIfPhysAdapterLateCollisions object, the cpqNicIfPhysAdapterExcessiveCollisions object, or the cpqNicIfPhysAdapterCarrierSenseErrors object. The precise meaning of the count represented by an instance of this object is implementation- specific. In particular, an instance of this object may represent a count of transmission errors on a particular interface that are not otherwise counted.')
cpqNicIfPhysAdapterCarrierSenseErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterCarrierSenseErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterCarrierSenseErrors.setDescription('The number of packets transmitted with carrier sense errors: This counter contains the number of times that the carrier sense signal from the physical layer interface was not asserted or was de-asserted during transmission of a packet without collision. The carrier sense signal is an ongoing activity of a data station to detect whether or not another station is transmitting. Carrier sense errors are detected when a station transmits a frame and does not detect its own signal on the wire. If you receive carrier sense errors, check the following: Failing cable: Packet data traveling through shorted or damaged cabling may cause a signal loss. Ensure that your cable is working and plugged in properly. Segment not grounded properly: Improper grounding of a segment may allow ground-induced noise to interrupt the signal. Ensure that you have properly grounded all segments. Noisy cable: Interference or noise produced by motors or other devices can interrupt the signals. Deaf/partially deaf node: A faulty station that cannot hear the activity is considered a deaf node. If you suspect a deaf node, the network interface card should be replaced. Failing hub, switch, or controller: Repeaters, switches and controllers can disrupt the network signal, transmit erroneous signals on the wire, or ignore incoming packets. Perform the following steps: 1. Swap out the adapter, adapter cable, and adapter attachment point, one at a time. If you find a faulty component, replace it. 2. If none of the items listed above help you isolate the problem, you may need to replace the switch or hub. Use a network analyzer to isolate the problem area.')
cpqNicIfPhysAdapterFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterFrameTooLongs.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterFrameTooLongs.setDescription('A count of frames received on a particular interface that exceed the maximum permitted frame size.')
cpqNicIfPhysAdapterInternalMacReceiveErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterInternalMacReceiveErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterInternalMacReceiveErrors.setDescription('A count of frames for which reception on a particular interface fails due to an internal MAC sublayer receive error. A frame is only counted by an instance of this object if it is not counted by the corresponding instance of either the cpqNicIfPhysAdapterStatsFrameTooLongs object, the cpqNicIfPhysAdapterStatsAlignmentErrors object, or the cpqNicIfPhysAdapterStatsFCSErrors object. The precise meaning of the count represented by an instance of this object is implementation- specific. In particular, an instance of this object may represent a count of receive errors on a particular interface that are not otherwise counted.')
cpqNicIfPhysAdapterHwLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 31), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterHwLocation.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterHwLocation.setDescription('A text description of the hardware location, on complex multi SBB hardware only, for the physical adapter. A NULL string indicates that the hardware location could not be determined or is irrelevant.')
cpqNicIfPhysAdapterPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterPartNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterPartNumber.setDescription('A text description of the hardware part number.')
cpqNicIfPhysAdapterSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 33), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSpeed.setDescription("An estimate of the interface's current bandwidth in bits per second. For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.")
cpqNicIfPhysAdapterConfSpeedDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("other", 1), ("autoAuto", 2), ("ethernetHalf", 3), ("ethernetFull", 4), ("fastEthernetHalf", 5), ("fastEthernetFull", 6), ("gigEthernetHalf", 7), ("gigEthernetFull", 8), ("gig10EthernetFull", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterConfSpeedDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterConfSpeedDuplex.setDescription('The physical adapter configured speed and duplex. The following values are valid: other(1) The configured speed and duplex are unknown. autoAuto(2) Auto negotiate both speed and duplex. ethernetHalf(3), ethernetFull(4), fastEthernetHalf(5), fastEthernetFull(6), gigEthernetHalf(7), gigEthernetFull(8), gig10EthernetFull(9) Speed and duplex forced to the given value.')
cpqNicIfPhysAdapterAggregationGID = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterAggregationGID.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterAggregationGID.setDescription('Aggregation group number of the adapter. A value of -1 means the Aggregation group number could not be determined or not present.')
cpqNicIfPhysAdapterSpeedMbps = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 36), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSpeedMbps.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterSpeedMbps.setDescription("An estimate of the interface's current bandwidth in Megabits per second. For interfaces which do not vary in bandwidth or for those where no accurate estimation can be made, this object should contain the nominal bandwidth.")
cpqNicIfPhysAdapterInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterInOctets.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterInOctets.setDescription('A count of Octets Received on the physical adapter. This includes traffic generated due to different protocols like TCP/IP, DECNET etc')
cpqNicIfPhysAdapterOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterOutOctets.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterOutOctets.setDescription('A count of Octets Sent on the physical adapter. This includes traffic generated due to different protocols like TCP/IP, DECNET etc')
cpqNicIfPhysAdapterName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 39), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterName.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterName.setDescription('Name of the physical adapter. This string is NULL terminated.')
cpqNicIfPhysAdapterIoBayNo = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIoBayNo.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterIoBayNo.setDescription('Identifies the Interconnect Bay Number to which the adapter is connected in a Blade Environment. A value of -1 means the Interconnect Bay number could not be determined or its not a Blade Environment. cpqNicIfPhysAdapterSlot will reflect a Mezz number and cpqNicIfPhysAdapterPort will reflect Switch Port number when Interconnect Bay number is not -1.')
cpqNicIfPhysAdapterFWVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 1, 1, 41), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfPhysAdapterFWVersion.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfPhysAdapterFWVersion.setDescription('Firmware version of the physical adapter. This string is NULL terminated.')
cpqNicPhyAdapBaseMemTable = MibTable((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 2), )
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemTable.setStatus('optional')
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemTable.setDescription('A table of base memory used by a physical adapter.')
cpqNicPhyAdapBaseMemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 2, 1), ).setIndexNames((0, "CPQNIC-MIB", "cpqNicPhyAdapBaseMemIndex"))
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemEntry.setStatus('optional')
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemEntry.setDescription('A base memory table entry.')
cpqNicPhyAdapBaseMemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemIndex.setDescription('An index that uniquely specifies this entry.')
cpqNicPhyAdapBaseMemIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemIfIndex.setStatus('optional')
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemIfIndex.setDescription('An index ifTable. This identifies the physical adapter interface this Base memory address is associated with.')
cpqNicPhyAdapBaseMemAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemAddr.setStatus('optional')
if mibBuilder.loadTexts: cpqNicPhyAdapBaseMemAddr.setDescription('A base memory address used by the physical hardware interface associated.')
cpqNicIfVlanMapTable = MibTable((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1), )
if mibBuilder.loadTexts: cpqNicIfVlanMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfVlanMapTable.setDescription('A table of interface to VLAN mappings.')
cpqNicIfVlanMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1), ).setIndexNames((0, "CPQNIC-MIB", "cpqNicIfVlanMapIndex"))
if mibBuilder.loadTexts: cpqNicIfVlanMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfVlanMapEntry.setDescription('A mapping of an interface table entry to VLANs.')
cpqNicIfVlanMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfVlanMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfVlanMapIndex.setDescription('An index that uniquely specifies this entry.')
cpqNicIfVlanMapLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfVlanMapLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfVlanMapLogIndex.setDescription('An index into the logical map table. This identifies the logical adapter this VLAN is associated with.')
cpqNicIfVlanMapIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfVlanMapIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfVlanMapIfIndex.setDescription('An index ifTable. This identifies the MIB-II interface this VLAN is associated with.')
cpqNicIfVlanMapVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanId.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanId.setDescription('The ID of this VLAN.')
cpqNicIfVlanMapVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanName.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanName.setDescription('The name of this VLAN.')
cpqNicIfVlanMapVlanIPV6Address = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanIPV6Address.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanIPV6Address.setDescription('The CIDR(Classless Inter-Domain Routing) notation that the VLAN presents to the network.')
cpqNicIfVlanMapVlanLACNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 232, 18, 2, 4, 1, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanLACNumber.setStatus('optional')
if mibBuilder.loadTexts: cpqNicIfVlanMapVlanLACNumber.setDescription('Local Area Connection number that the VLAN presents to the network.')
cpqNicVtInstalled = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notInstalled", 1), ("installed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicVtInstalled.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicVtInstalled.setDescription('Indicates installation status of Virus Throttle Filter Driver')
cpqNicVtLicensed = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 2, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notLicensed", 1), ("licensed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicVtLicensed.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicVtLicensed.setDescription('Indicates license status of Virus Throttle Filter Driver')
cpqNicVtVirusActivity = MibScalar((1, 3, 6, 1, 4, 1, 232, 18, 2, 5, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notDetected", 1), ("detected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpqNicVtVirusActivity.setStatus('mandatory')
if mibBuilder.loadTexts: cpqNicVtVirusActivity.setDescription('Indicates virus activity detection status of Virus Throttle Filter Driver')
cpqNicConnectivityRestored = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18001)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"))
if mibBuilder.loadTexts: cpqNicConnectivityRestored.setDescription('This trap will be sent any time connectivity is restored to a logical adapter. This occurs when the physical adapter in a single adapter configuration returns to the OK condition or at least one physical adapter in a logical adapter group returns to the OK condition. This can be caused by replacement of a faulty cable or re-attaching a cable that was unplugged. User Action: None required.')
cpqNicConnectivityLost = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18002)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"))
if mibBuilder.loadTexts: cpqNicConnectivityLost.setDescription('This trap will be sent any time the status of a logical adapter changes to the Failed condition. This occurs when the adapter in a single adapter configuration fails, or when the last adapter in a redundant configuration fails. This can be caused by loss of link due to a cable being removed from the adapter or the Hub or Switch. Internal adapter, Hub, or Switch failures can also cause this condition. User Action: Check the cables to the adapter and the Hub or Switch. If no cable problems are found, the adapter, Hub, or Switch may need replacement.')
cpqNicRedundancyIncreased = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18003)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQNIC-MIB", "cpqNicIfLogMapAdapterOKCount"))
if mibBuilder.loadTexts: cpqNicRedundancyIncreased.setDescription('This trap will be sent any time a previously failed physical adapter in a connected logical adapter group returns to the OK condition. This trap is not sent when a logical adapter group has connectivity restored from a Failed condition. The cpqNicConnectivityRestored trap is sent instead. This can be caused by replacement of a faulty cable or re-attaching a cable that was unplugged. User Action: None required.')
cpqNicRedundancyReduced = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18004)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQNIC-MIB", "cpqNicIfLogMapAdapterOKCount"))
if mibBuilder.loadTexts: cpqNicRedundancyReduced.setDescription('This trap will be sent any time a physical adapter in a logical adapter group changes to the Failed condition, but at least one physical adapter remains in the OK condition.. This can be caused by loss of link due to a cable being removed from the adapter or the Hub or Switch. Internal adapter, Hub, or Switch failures can also cause this condition. User Action: Check the cables to the adapter and the Hub or Switch. If no cable problems are found, the adapter, Hub, or Switch may need replacement.')
cpqNic2ConnectivityRestored = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18005)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"))
if mibBuilder.loadTexts: cpqNic2ConnectivityRestored.setDescription('This trap will be sent any time connectivity is restored to a logical adapter. This occurs when the physical adapter in a single adapter configuration returns to the OK condition or at least one physical adapter in a logical adapter group returns to the OK condition. This can be caused by replacement of a faulty cable or re-attaching a cable that was unplugged. User Action: None required.')
cpqNic2ConnectivityLost = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18006)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"))
if mibBuilder.loadTexts: cpqNic2ConnectivityLost.setDescription('This trap will be sent any time the status of a logical adapter changes to the Failed condition. This occurs when the adapter in a single adapter configuration fails, or when the last adapter in a redundant configuration fails. This can be caused by loss of link due to a cable being removed from the adapter or the Hub or Switch. Internal adapter, Hub, or Switch failures can also cause this condition. User Action: Check the cables to the adapter and the Hub or Switch. If no cable problems are found, the adapter, Hub, or Switch may need replacement.')
cpqNic2RedundancyIncreased = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18007)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"), ("CPQNIC-MIB", "cpqNicIfLogMapAdapterOKCount"))
if mibBuilder.loadTexts: cpqNic2RedundancyIncreased.setDescription('This trap will be sent any time a previously failed physical adapter in a connected logical adapter group returns to the OK condition. This trap is not sent when a logical adapter group has connectivity restored from a Failed condition. The cpqNicConnectivityRestored trap is sent instead. This can be caused by replacement of a faulty cable or re-attaching a cable that was unplugged. User Action: None required.')
cpqNic2RedundancyReduced = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18008)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"), ("CPQNIC-MIB", "cpqNicIfLogMapAdapterOKCount"))
if mibBuilder.loadTexts: cpqNic2RedundancyReduced.setDescription('This trap will be sent any time a physical adapter in a logical adapter group changes to the Failed condition, but at least one physical adapter remains in the OK condition.. This can be caused by loss of link due to a cable being removed from the adapter or the Hub or Switch. Internal adapter, Hub, or Switch failures can also cause this condition. User Action: Check the cables to the adapter and the Hub or Switch. If no cable problems are found, the adapter, Hub, or Switch may need replacement.')
cpqNicVirusLikeActivityDetected = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18009)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqNicVirusLikeActivityDetected.setDescription('This trap will be sent when the Virus Throttle Filter Driver detects virus like activity. User Action: The system reporting this trap requires immediate attention.')
cpqNicVirusLikeActivityStopped = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18010)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQSINFO-MIB", "cpqSiServerSystemId"))
if mibBuilder.loadTexts: cpqNicVirusLikeActivityStopped.setDescription('This trap will be sent when the Virus Throttle Filter Driver no longer detects virus like activity. User Action: None required.')
cpqNic3ConnectivityRestored = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18011)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"), ("CPQNIC-MIB", "cpqNicIfLogMapIPV6Address"))
if mibBuilder.loadTexts: cpqNic3ConnectivityRestored.setDescription('This trap will be sent any time connectivity is restored to a logical adapter. This occurs when the physical adapter in a single adapter configuration returns to the OK condition or at least one physical adapter in a logical adapter group returns to the OK condition. This can be caused by replacement of a faulty cable or re-attaching a cable that was unplugged. User Action: None required.')
cpqNic3ConnectivityLost = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18012)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"), ("CPQNIC-MIB", "cpqNicIfLogMapIPV6Address"))
if mibBuilder.loadTexts: cpqNic3ConnectivityLost.setDescription('This trap will be sent any time the status of a logical adapter changes to the Failed condition. This occurs when the adapter in a single adapter configuration fails, or when the last adapter in a redundant configuration fails. This can be caused by loss of link due to a cable being removed from the adapter or the Hub or Switch. Internal adapter, Hub, or Switch failures can also cause this condition. User Action: Check the cables to the adapter and the Hub or Switch. If no cable problems are found, the adapter, Hub, or Switch may need replacement.')
cpqNic3RedundancyIncreased = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18013)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"), ("CPQNIC-MIB", "cpqNicIfLogMapIPV6Address"), ("CPQNIC-MIB", "cpqNicIfLogMapAdapterOKCount"))
if mibBuilder.loadTexts: cpqNic3RedundancyIncreased.setDescription('This trap will be sent any time a previously failed physical adapter in a connected logical adapter group returns to the OK condition. This trap is not sent when a logical adapter group has connectivity restored from a Failed condition. The cpqNicConnectivityRestored trap is sent instead. This can be caused by replacement of a faulty cable or re-attaching a cable that was unplugged. User Action: None required.')
cpqNic3RedundancyReduced = NotificationType((1, 3, 6, 1, 4, 1, 232) + (0,18014)).setObjects(("SNMPv2-MIB", "sysName"), ("CPQHOST-MIB", "cpqHoTrapFlags"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterSlot"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPort"), ("CPQSINFO-MIB", "cpqSiServerSystemId"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterStatus"), ("CPQSTDEQ-MIB", "cpqSePciSlotBoardName"), ("CPQNIC-MIB", "cpqNicIfPhysAdapterPartNumber"), ("IP-MIB", "ipAdEntAddr"), ("CPQNIC-MIB", "cpqNicIfLogMapIPV6Address"), ("CPQNIC-MIB", "cpqNicIfLogMapAdapterOKCount"))
if mibBuilder.loadTexts: cpqNic3RedundancyReduced.setDescription('This trap will be sent any time a physical adapter in a logical adapter group changes to the Failed condition, but at least one physical adapter remains in the OK condition.. This can be caused by loss of link due to a cable being removed from the adapter or the Hub or Switch. Internal adapter, Hub, or Switch failures can also cause this condition. User Action: Check the cables to the adapter and the Hub or Switch. If no cable problems are found, the adapter, Hub, or Switch may need replacement.')
mibBuilder.exportSymbols("CPQNIC-MIB", cpqNicRedundancyIncreased=cpqNicRedundancyIncreased, cpqNicRedundancyReduced=cpqNicRedundancyReduced, cpqNicVtLicensed=cpqNicVtLicensed, cpqNic3RedundancyReduced=cpqNic3RedundancyReduced, cpqNicIfPhysAdapterSingleCollisionFrames=cpqNicIfPhysAdapterSingleCollisionFrames, cpqNicIfLogMapSpeed=cpqNicIfLogMapSpeed, cpqNic2RedundancyReduced=cpqNic2RedundancyReduced, cpqNicIfPhysAdapterBadTransmits=cpqNicIfPhysAdapterBadTransmits, cpqNic2RedundancyIncreased=cpqNic2RedundancyIncreased, cpqNic2ConnectivityLost=cpqNic2ConnectivityLost, cpqNicIfLogMap=cpqNicIfLogMap, cpqNicIfVlanMap=cpqNicIfVlanMap, cpqNicIfLogMapCondition=cpqNicIfLogMapCondition, cpqNicIfPhysAdapterLateCollisions=cpqNicIfPhysAdapterLateCollisions, cpqNicIfPhysAdapterExcessiveCollisions=cpqNicIfPhysAdapterExcessiveCollisions, cpqNicIfLogMapIPV6Address=cpqNicIfLogMapIPV6Address, cpqNicOsCommon=cpqNicOsCommon, cpqNicOsCommonModulePurpose=cpqNicOsCommonModulePurpose, cpqNicIfLogMapLastChange=cpqNicIfLogMapLastChange, cpqNicIfPhysAdapterOutOctets=cpqNicIfPhysAdapterOutOctets, cpqNicIfLogMapAdapterCount=cpqNicIfLogMapAdapterCount, cpqNicIfPhysAdapterDuplexState=cpqNicIfPhysAdapterDuplexState, cpqNicConnectivityLost=cpqNicConnectivityLost, cpqNicIfPhysAdapterMACAddress=cpqNicIfPhysAdapterMACAddress, cpqNicIfPhysAdapterRole=cpqNicIfPhysAdapterRole, cpqNicVtVirusActivity=cpqNicVtVirusActivity, cpqNicIfPhysAdapterIndex=cpqNicIfPhysAdapterIndex, cpqNicIfLogMapVlanCount=cpqNicIfLogMapVlanCount, cpqNicIfPhysAdapterIrq=cpqNicIfPhysAdapterIrq, cpqNicIfPhysAdapterDma=cpqNicIfPhysAdapterDma, cpqNicPhyAdapBaseMemTable=cpqNicPhyAdapBaseMemTable, cpqNicIfVlanMapVlanLACNumber=cpqNicIfVlanMapVlanLACNumber, cpqNicIfVlanMapEntry=cpqNicIfVlanMapEntry, cpqNicIfLogMapGroupType=cpqNicIfLogMapGroupType, cpqNic3RedundancyIncreased=cpqNic3RedundancyIncreased, cpqNicIfPhysAdapterHwLocation=cpqNicIfPhysAdapterHwLocation, cpqNicMibRevMajor=cpqNicMibRevMajor, cpqNicIfPhysAdapterCarrierSenseErrors=cpqNicIfPhysAdapterCarrierSenseErrors, cpqNicIfVlanMapVlanIPV6Address=cpqNicIfVlanMapVlanIPV6Address, cpqNicIfPhysAdapterBadReceives=cpqNicIfPhysAdapterBadReceives, cpqNicIfPhysAdapterInternalMacReceiveErrors=cpqNicIfPhysAdapterInternalMacReceiveErrors, cpqNicIfVlanMapIfIndex=cpqNicIfVlanMapIfIndex, cpqNicInterface=cpqNicInterface, cpqNicVirusThrottle=cpqNicVirusThrottle, cpqNicIfLogMapHwLocation=cpqNicIfLogMapHwLocation, cpqNicIfPhysAdapterEntry=cpqNicIfPhysAdapterEntry, cpqNicIfLogMapDescription=cpqNicIfLogMapDescription, cpqNicIfPhysAdapterStatsValid=cpqNicIfPhysAdapterStatsValid, cpqNicIfLogMapEntry=cpqNicIfLogMapEntry, cpqNicIfPhysAdapterInternalMacTransmitErrors=cpqNicIfPhysAdapterInternalMacTransmitErrors, cpqNicVirusLikeActivityDetected=cpqNicVirusLikeActivityDetected, cpqNicVirusLikeActivityStopped=cpqNicVirusLikeActivityStopped, cpqNicMibCondition=cpqNicMibCondition, cpqNicIfLogMapAdapterOKCount=cpqNicIfLogMapAdapterOKCount, cpqNicIfPhysAdapterGoodReceives=cpqNicIfPhysAdapterGoodReceives, cpqNicIfPhysAdapterTable=cpqNicIfPhysAdapterTable, cpqNicIfLogMapPhysicalAdapters=cpqNicIfLogMapPhysicalAdapters, cpqNicIfPhysAdapterMemAddr=cpqNicIfPhysAdapterMemAddr, cpqNicIfLogMapTable=cpqNicIfLogMapTable, cpqNicIfPhysAdapterPartNumber=cpqNicIfPhysAdapterPartNumber, cpqNicIfPhysAdapterName=cpqNicIfPhysAdapterName, cpqNicPhyAdapBaseMemEntry=cpqNicPhyAdapBaseMemEntry, cpqNicIfPhysAdapterAlignmentErrors=cpqNicIfPhysAdapterAlignmentErrors, cpqNic2ConnectivityRestored=cpqNic2ConnectivityRestored, cpqNicIfPhysAdapterInOctets=cpqNicIfPhysAdapterInOctets, cpqNicOsCommonPollFreq=cpqNicOsCommonPollFreq, cpqNicIfVlanMapLogIndex=cpqNicIfVlanMapLogIndex, cpqNicIfPhysAdapterFrameTooLongs=cpqNicIfPhysAdapterFrameTooLongs, cpqNicIfPhysAdapterSpeedMbps=cpqNicIfPhysAdapterSpeedMbps, cpqNicIfLogMapSwitchoverMode=cpqNicIfLogMapSwitchoverMode, cpqNicIfVlanMapVlanId=cpqNicIfVlanMapVlanId, cpqNicOsCommonModuleDate=cpqNicOsCommonModuleDate, cpqNicIfPhysAdapterCondition=cpqNicIfPhysAdapterCondition, cpqNicIfPhysAdapterIoAddr=cpqNicIfPhysAdapterIoAddr, cpqNicIfLogMapNumSwitchovers=cpqNicIfLogMapNumSwitchovers, cpqNicOsCommonModuleIndex=cpqNicOsCommonModuleIndex, cpqNicMibRev=cpqNicMibRev, cpqNicIfPhysAdapterGoodTransmits=cpqNicIfPhysAdapterGoodTransmits, cpqNicIfPhysAdapterDeferredTransmissions=cpqNicIfPhysAdapterDeferredTransmissions, cpqNicIfPhysAdapterAggregationGID=cpqNicIfPhysAdapterAggregationGID, cpqNicIfPhysAdapterConfSpeedDuplex=cpqNicIfPhysAdapterConfSpeedDuplex, cpqNicIfPhysAdapterStatus=cpqNicIfPhysAdapterStatus, cpqNicIfLogMapIfNumber=cpqNicIfLogMapIfNumber, cpqNicIfPhysAdapterFWVersion=cpqNicIfPhysAdapterFWVersion, cpqNic=cpqNic, cpqNicPhyAdapBaseMemAddr=cpqNicPhyAdapBaseMemAddr, cpqNicIfVlanMapTable=cpqNicIfVlanMapTable, cpqNicIfLogMapVlans=cpqNicIfLogMapVlans, cpqNicIfPhysAdapter=cpqNicIfPhysAdapter, cpqNicOsCommonModuleVersion=cpqNicOsCommonModuleVersion, cpqNicComponent=cpqNicComponent, cpqNicIfLogMapSpeedMbps=cpqNicIfLogMapSpeedMbps, cpqNicMibRevMinor=cpqNicMibRevMinor, cpqNicIfPhysAdapterIfNumber=cpqNicIfPhysAdapterIfNumber, cpqNicIfLogMapOverallCondition=cpqNicIfLogMapOverallCondition, cpqNicConnectivityRestored=cpqNicConnectivityRestored, cpqNicIfPhysAdapterPort=cpqNicIfPhysAdapterPort, cpqNicIfPhysAdapterState=cpqNicIfPhysAdapterState, cpqNicIfPhysAdapterIoBayNo=cpqNicIfPhysAdapterIoBayNo, cpqNicIfPhysAdapterSlot=cpqNicIfPhysAdapterSlot, cpqNicOsCommonModuleTable=cpqNicOsCommonModuleTable, cpqNicIfLogMapMACAddress=cpqNicIfLogMapMACAddress, cpqNicPhyAdapBaseMemIfIndex=cpqNicPhyAdapBaseMemIfIndex, cpqNicIfVlanMapIndex=cpqNicIfVlanMapIndex, cpqNicPhyAdapBaseMemIndex=cpqNicPhyAdapBaseMemIndex, cpqNic3ConnectivityRestored=cpqNic3ConnectivityRestored, cpqNicIfLogMapAdvancedTeaming=cpqNicIfLogMapAdvancedTeaming, cpqNicIfLogMapStatus=cpqNicIfLogMapStatus, cpqNicOsCommonModuleEntry=cpqNicOsCommonModuleEntry, cpqNicIfLogMapIndex=cpqNicIfLogMapIndex, cpqNicIfPhysAdapterSpeed=cpqNicIfPhysAdapterSpeed, cpqNicOsCommonModuleName=cpqNicOsCommonModuleName, cpqNicIfPhysAdapterFCSErrors=cpqNicIfPhysAdapterFCSErrors, cpqNicIfLogMapLACNumber=cpqNicIfLogMapLACNumber, cpqNicVtInstalled=cpqNicVtInstalled, cpqNicIfPhysAdapterMultipleCollisionFrames=cpqNicIfPhysAdapterMultipleCollisionFrames, cpqNicIfVlanMapVlanName=cpqNicIfVlanMapVlanName, cpqNic3ConnectivityLost=cpqNic3ConnectivityLost)

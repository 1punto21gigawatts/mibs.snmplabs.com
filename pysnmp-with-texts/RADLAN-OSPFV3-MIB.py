#
# PySNMP MIB module RADLAN-OSPFV3-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RADLAN-OSPFV3-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:47:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
InterfaceIndex, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "InterfaceIndexOrZero")
InetAddressIPv6, InetAddressPrefixLength, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressIPv6", "InetAddressPrefixLength", "InetAddress", "InetAddressType")
Status, OspfAuthenticationType, Metric, HelloRange, BigMetric, PositiveInteger, UpToMaxAge, AreaID, DesignatedRouterPriority, RouterID, TOSType = mibBuilder.importSymbols("OSPF-MIB", "Status", "OspfAuthenticationType", "Metric", "HelloRange", "BigMetric", "PositiveInteger", "UpToMaxAge", "AreaID", "DesignatedRouterPriority", "RouterID", "TOSType")
Ospfv3LsaSequenceTC, Ospfv3LsaAgeTC, Ospfv3DeadIntervalRangeTC, Ospfv3AreaIdTC, Ospfv3LsIdTC, Ospfv3UpToRefreshIntervalTC, Ospfv3IfInstIdTC, Ospfv3RouterIdTC = mibBuilder.importSymbols("OSPFV3-MIB", "Ospfv3LsaSequenceTC", "Ospfv3LsaAgeTC", "Ospfv3DeadIntervalRangeTC", "Ospfv3AreaIdTC", "Ospfv3LsIdTC", "Ospfv3UpToRefreshIntervalTC", "Ospfv3IfInstIdTC", "Ospfv3RouterIdTC")
rnd, = mibBuilder.importSymbols("RADLAN-MIB", "rnd")
RlOspfRouterIdType, RlOspfFastHelloMultiplierRange, RlOspfRestartExitReason, RlOspfProcessID, RlOspfRestartHelperStatus = mibBuilder.importSymbols("RADLAN-OSPF-MIB", "RlOspfRouterIdType", "RlOspfFastHelloMultiplierRange", "RlOspfRestartExitReason", "RlOspfProcessID", "RlOspfRestartHelperStatus")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, IpAddress, Counter64, iso, Bits, ObjectIdentity, Gauge32, Counter32, mib_2, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, NotificationType, TimeTicks, MibIdentifier, Unsigned32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "IpAddress", "Counter64", "iso", "Bits", "ObjectIdentity", "Gauge32", "Counter32", "mib-2", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "NotificationType", "TimeTicks", "MibIdentifier", "Unsigned32")
TimeStamp, DisplayString, TextualConvention, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "TextualConvention", "RowStatus", "TruthValue")
rlOspfv3 = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 216))
rlOspfv3.setRevisions(('2011-05-04 17:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlOspfv3.setRevisionsDescriptions(('Initial version of this MIB.',))
if mibBuilder.loadTexts: rlOspfv3.setLastUpdated('201105041700Z')
if mibBuilder.loadTexts: rlOspfv3.setOrganization('Radlan Computer Communications Ltd.')
if mibBuilder.loadTexts: rlOspfv3.setContactInfo('radlan.com')
if mibBuilder.loadTexts: rlOspfv3.setDescription('The private MIB module definition for Multi Instance OSPF V3 for IPv6 MIB.')
class RlRouterID(TextualConvention, Unsigned32):
    reference = 'OSPF for IPv6, Appendix C.1, Global Parameters'
    description = "A 32-bit, unsigned integer uniquely identifying the router in the Autonomous System. To ensure uniqueness, this may default to the value of one of the router's IPv4 host addresses if IPv4 is configured on the router."
    status = 'current'
    displayHint = 'd'

class RlLsID(TextualConvention, Unsigned32):
    reference = 'OSPF Version 2, Section 12.1.4, Link State ID'
    description = 'A unique 32-bit identifier of the piece of the routing domain that is being described by a link state advertisement. In contrast to OSPFv2, the Link State ID (LSID) has no addressing semantics.'
    status = 'current'
    displayHint = 'd'

class RlOspfv3FastHelloMultiplierRange(TextualConvention, Integer32):
    description = 'The range of hello multipliers that determine how often Fast Hellos are exchanged.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(3, 20)

class RlOspfv3UpToRefreshInterval(TextualConvention, Integer32):
    description = 'The values configurable for variables bounded by the Refresh Interval.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 1800)

class RlOspfv3RestartHelperStatus(TextualConvention, Integer32):
    description = 'Indicates whether the router is acting as a hitless restart helper for a neighbor.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("notHelping", 1), ("helping", 2))

class RlOspfv3RestartExitReason(TextualConvention, Integer32):
    description = 'The reason for exiting an attempted graceful restart.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("inProgress", 2), ("completed", 3), ("timedOut", 4), ("topologyChanged", 5))

class RlOspfv3UpToRefreshIntervalTC(TextualConvention, Unsigned32):
    reference = 'OSPF Version 2, Appendix B, Architectural Constants'
    description = 'The values one might be able to configure for variables bounded by the Refresh Interval.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 65535)

rlOspfv3Instance = MibScalar((1, 3, 6, 1, 4, 1, 89, 216, 1), RlOspfProcessID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3Instance.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3Instance.setDescription('Selected OSPFv3 Process ID. Additional key value for old fashion usage of OSPF standard MIB to support multi OSPF instance.')
rlOspfv3GeneralGroupTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 2), )
if mibBuilder.loadTexts: rlOspfv3GeneralGroupTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3GeneralGroupTable.setDescription('OSPFv3 Instance General Variables')
rlOspfv3GeneralGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 2, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3ProcessId"))
if mibBuilder.loadTexts: rlOspfv3GeneralGroupEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3GeneralGroupEntry.setDescription('Information describing the configured global parame- ters to the Router OSPFv3 Process.')
rlOspfv3ProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3ProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ProcessId.setDescription('A 32-bit integer uniquely identifying an OSPFv3 process.')
rlOspfv3RouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 2), RouterID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3RouterId.setReference('OSPF for IPv6, Appendix C.1, Global Parameters')
if mibBuilder.loadTexts: rlOspfv3RouterId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RouterId.setDescription("A 32-bit unsigned integer uniquely identifying the router in the Autonomous System. To ensure uniqueness, this may default to the 32-bit unsigned integer representation of one of the router's IPv4 interface addresses (if IPv4 is configured on the router). This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.")
rlOspfv3AdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 3), Status()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3AdminStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AdminStatus.setDescription("The administrative status of OSPFv3 in the router. The value 'enabled' denotes that the OSPFv3 Process is active on at least one interface; 'disabled' disables it on all interfaces. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.")
rlOspfv3VersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("version3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VersionNumber.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VersionNumber.setDescription('The version number of OSPF for IPv6 is 3.')
rlOspfv3AreaBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaBdrRtrStatus.setReference('OSPF Version 2, Section 3, Splitting the AS into Areas')
if mibBuilder.loadTexts: rlOspfv3AreaBdrRtrStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaBdrRtrStatus.setDescription('A flag to denote whether this router is an area border router. The value of this object is true (1) when the router is an area border router.')
rlOspfv3ASBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3ASBdrRtrStatus.setReference('OSPF Version 2, Section 3.3, Classification of routers')
if mibBuilder.loadTexts: rlOspfv3ASBdrRtrStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ASBdrRtrStatus.setDescription('A flag to note whether this router is configured as an Autonomous System border router. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3AsScopeLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsScopeLsaCount.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsScopeLsaCount.setDescription('The number of AS-scope (e.g., AS-External) link state advertisements in the link state database.')
rlOspfv3AsScopeLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsScopeLsaCksumSum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsScopeLsaCksumSum.setDescription("The 32-bit unsigned sum of the LS checksums of the AS-scoped link state advertisements contained in the link state database. This sum can be used to determine if there has been a change in a router's link state database or to compare the link state database of two routers.")
rlOspfv3OriginateNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3OriginateNewLsas.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3OriginateNewLsas.setDescription('The number of new link state advertisements that have been originated. This number is incremented each time the router originates a new LSA. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of ospfv3DiscontinuityTime.')
rlOspfv3RxNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3RxNewLsas.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RxNewLsas.setDescription('The number of link state advertisements received that are determined to be new instantiations. This number does not include newer instantiations of self-originated link state advertisements. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of ospfv3DiscontinuityTime.')
rlOspfv3ExtLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3ExtLsaCount.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ExtLsaCount.setDescription('The number of External (LS type 0x4005) in the link state database.')
rlOspfv3ExtAreaLsdbLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3ExtAreaLsdbLimit.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ExtAreaLsdbLimit.setDescription("The maximum number of non-default AS-external-LSA entries that can be stored in the link state database. If the value is -1, then there is no limit. When the number of non-default AS-external-LSAs in a router's link state database reaches ospfv3ExtAreaLsdbLimit, the router enters Overflow state. The router never holds more than ospfv3ExtAreaLsdbLimit non-default AS-external-LSAs in its database. ospfv3ExtAreaLsdbLimit MUST be set identically in all routers attached to the OSPFv3 backbone and/or any regular OSPFv3 area (i.e., OSPFv3 stub areas and not-so-stubby-areas (NSSAs) are excluded). This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.")
rlOspfv3ExitOverflowInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 13), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3ExitOverflowInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ExitOverflowInterval.setDescription('The number of seconds that, after entering Overflow state, a router will attempt to leave Overflow state. This allows the router to again originate non-default, AS-External-LSAs. When set to 0, the router will not leave Overflow state until restarted. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3DemandExtensions = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3DemandExtensions.setReference('OSPF Version 2; Extending OSPF to Support Demand Circuits')
if mibBuilder.loadTexts: rlOspfv3DemandExtensions.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3DemandExtensions.setDescription("The router's support for demand circuits. The value of this object is true (1) when demand circuits are supported. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.")
rlOspfv3ReferenceBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 15), Unsigned32().clone(100000)).setUnits('kilobits per second').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3ReferenceBandwidth.setReference('OSPF Version 2, Appendix C.3, Router interface parameters')
if mibBuilder.loadTexts: rlOspfv3ReferenceBandwidth.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ReferenceBandwidth.setDescription('Reference bandwidth in kilobits per second for calculating default interface metrics. The default value is 100,000 KBPS (100 MBPS). This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3RestartSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("plannedOnly", 2), ("plannedAndUnplanned", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3RestartSupport.setReference('Graceful OSPF Restart, Appendix B.1, Global Parameters (Minimum subset)')
if mibBuilder.loadTexts: rlOspfv3RestartSupport.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartSupport.setDescription("The router's support for OSPF graceful restart. Options include no restart support, only planned restarts, or both planned and unplanned restarts. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.")
rlOspfv3RestartInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 17), Ospfv3UpToRefreshIntervalTC().clone(120)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3RestartInterval.setReference('Graceful OSPF Restart, Appendix B.1, Global Parameters (Minimum subset)')
if mibBuilder.loadTexts: rlOspfv3RestartInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartInterval.setDescription('Configured OSPF graceful restart timeout interval. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3RestartStrictLsaChecking = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 18), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3RestartStrictLsaChecking.setReference('Graceful OSPF Restart, Appendix B.2, Global Parameters (Optional)')
if mibBuilder.loadTexts: rlOspfv3RestartStrictLsaChecking.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartStrictLsaChecking.setDescription('Indicates if strict LSA checking is enabled for graceful restart. A value of true (1) indicates that strict LSA checking is enabled. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3RestartStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notRestarting", 1), ("plannedRestart", 2), ("unplannedRestart", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3RestartStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartStatus.setDescription('The current status of OSPF graceful restart capability.')
rlOspfv3RestartAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 20), Ospfv3UpToRefreshIntervalTC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3RestartAge.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartAge.setDescription('Remaining time in the current OSPF graceful restart interval.')
rlOspfv3RestartExitReason = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("inProgress", 2), ("completed", 3), ("timedOut", 4), ("topologyChanged", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3RestartExitReason.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartExitReason.setDescription('Describes the outcome of the last attempt at a graceful restart. none: no restart has yet been attempted. inProgress: a restart attempt is currently underway. completed: the last restart completed successfully. timedOut: the last restart timed out. topologyChanged: the last restart was aborted due to a topology change.')
rlOspfv3NotificationEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 22), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3NotificationEnable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NotificationEnable.setDescription('This object provides a coarse level of control over the generation of OSPFv3 notifications. If this object is set to true (1), then it enables the generation of OSPFv3 notifications. If it is set to false (2), these notifications are not generated. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3StubRouterSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 23), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3StubRouterSupport.setReference('OSPF Stub Router Advertisement')
if mibBuilder.loadTexts: rlOspfv3StubRouterSupport.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3StubRouterSupport.setDescription("The router's support for stub router functionality. An object value of true (1) indicates that stub router functionality is supported.")
rlOspfv3StubRouterAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("doNotAdvertise", 1), ("advertise", 2))).clone('doNotAdvertise')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3StubRouterAdvertisement.setReference('OSPF Stub Router Advertisement, Section 2, Proposed Solution')
if mibBuilder.loadTexts: rlOspfv3StubRouterAdvertisement.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3StubRouterAdvertisement.setDescription('This object controls the advertisement of stub LSAs by the router. The value doNotAdvertise (1) will result in the advertisement of standard LSAs and is the default value. This object is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3DiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 25), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3DiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3DiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one of this MIB's counters suffered a discontinuity. If no such discontinuities have occurred since the last re-initialization of the local management subsystem, then this object contains a zero value.")
rlOspfv3RestartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 26), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3RestartTime.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartTime.setDescription('The value of sysUpTime on the most recent occasion at which the ospfv3RestartExitReason was updated.')
rlOspfv3OperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("goingUp", 3), ("goingDown", 4), ("actFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3OperStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3OperStatus.setDescription('The current operational state of the OSPF in the router.')
rlOspfv3RowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 28), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3RowStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RowStatus.setDescription("This variable displays the status of the en- try. Setting it to 'invalid' has the effect of rendering it inoperative. The internal effect (row removal) is implementation dependent.")
rlOspfv3LogAdjacencyChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enable", 1), ("detail", 2), ("disable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3LogAdjacencyChanges.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LogAdjacencyChanges.setDescription('Configure the router to send a syslog message when an OSPF neighbor goes up or down. detail sends a syslog message for each state change, not just when a neighbor goes up or down')
rlOspfv3PassiveInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 30), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3PassiveInterface.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3PassiveInterface.setDescription('A flag to note whether to disable sending OSPF routing updates on all OSPF IP interfaces.')
rlOspfv3DefaultMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3DefaultMetric.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3DefaultMetric.setDescription('A default metric helps solve the problem of redistributing routes with incompatible metrics. Whenever metrics do not convert, using a default metric provides a reasonable substitute and enables the redistribution to proceed.')
rlOspfv3MaximumRedistPrefixNum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3MaximumRedistPrefixNum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3MaximumRedistPrefixNum.setDescription('Specifies the maximum number of IP prefixes that can be redistributed into OSPF.')
rlOspfv3MaximumRedistPrefixThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 33), Integer32().clone(75)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3MaximumRedistPrefixThreshold.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3MaximumRedistPrefixThreshold.setDescription('Threshold value, as a percentage, at which a warning message should be generated.')
rlOspfv3MaximumRedistPrefixWarningOnly = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 34), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3MaximumRedistPrefixWarningOnly.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3MaximumRedistPrefixWarningOnly.setDescription('Causes a warning message to be logged when the number of prefixes defined by the maximum argumenthas been exceeded. Additional redistribution is not prevented.')
rlOspfv3NextRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 35), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NextRouterId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NextRouterId.setDescription("A 32-bit integer uniquely identifying the of router in the Autonomous System after restart. By convention, to ensure uniqueness, this should default to the value of one of the router's IP interface addresses.")
rlOspfv3RouterIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 36), RlOspfRouterIdType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3RouterIdType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RouterIdType.setDescription('Type of router identifier - default value or manually set by user.')
rlOspfv3NextRouterIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 37), RlOspfRouterIdType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NextRouterIdType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NextRouterIdType.setDescription('Type of router identifier after restart - default value or manually set by user.')
rlOspfv3ASBdrRtrActualStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 38), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3ASBdrRtrActualStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ASBdrRtrActualStatus.setDescription('A flag to note whether this router is an Autonomous System Border Router. note: rlOspfASBdrRtrStatus field is the configuration and this filed is the actual ASBR status')
rlOspfv3CalcMaxDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 39), Unsigned32().clone(5000)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3CalcMaxDelay.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CalcMaxDelay.setDescription('The maximum delay before the Routing Table is recalculated following a change to the Link State Database. (Recalculation is delayed to reduce the frequency of recalculations of the Routing Table). This parameter has units of milliseconds. A value of 0 indicates that a routing calculation will immediately follow an update to the database.')
rlOspfv3RteMaxEqCostPaths = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 2, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3RteMaxEqCostPaths.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RteMaxEqCostPaths.setDescription('The maximum number of equal cost paths that are stored for each destination in the Routing Table.')
rlOspfv3AreaTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 3), )
if mibBuilder.loadTexts: rlOspfv3AreaTable.setReference('OSPF Version 2, Section 6, The Area Data Structure')
if mibBuilder.loadTexts: rlOspfv3AreaTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaTable.setDescription("Information describing the configured parameters and cumulative statistics of the router's attached areas. The interfaces and virtual links are configured as part of these areas. Area 0, by definition, is the backbone area.")
rlOspfv3AreaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 3, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaId"))
if mibBuilder.loadTexts: rlOspfv3AreaEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaEntry.setDescription("Information describing the configured parameters and cumulative statistics of one of the router's attached areas. The information in this table is persistent, and when written, the entity SHOULD save the a change to non-volatile storage.")
rlOspfv3AreaProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3AreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 2), AreaID())
if mibBuilder.loadTexts: rlOspfv3AreaId.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3AreaId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaId.setDescription('A 32-bit unsigned integer uniquely identifying an area. Area ID 0 is used for the OSPFv3 backbone.')
rlOspfv3AreaImportAsExtern = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("importExternal", 1), ("importNoExternal", 2), ("importNssa", 3))).clone('importExternal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaImportAsExtern.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3AreaImportAsExtern.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaImportAsExtern.setDescription('Indicates whether an area is a stub area, NSSA, or standard area. AS-scope LSAs are not imported into stub areas or NSSAs. NSSAs import AS-External data as NSSA LSAs that have Area-scope.')
rlOspfv3AreaSpfRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaSpfRuns.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaSpfRuns.setDescription("The number of times that the intra-area route table has been calculated using this area's link state database. This is typically done using Dijkstra's algorithm. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of rlOspfv3DiscontinuityTime.")
rlOspfv3AreaBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaBdrRtrCount.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaBdrRtrCount.setDescription('The total number of area border routers reachable within this area. This is initially zero, and is calculated in each Shortest Path First (SPF) pass.')
rlOspfv3AreaAsBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaAsBdrRtrCount.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAsBdrRtrCount.setDescription('The total number of Autonomous System border routers reachable within this area. This is initially zero, and is calculated in each SPF pass.')
rlOspfv3AreaScopeLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaScopeLsaCount.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaScopeLsaCount.setDescription("The total number of Area-scope link state advertisements in this area's link state database.")
rlOspfv3AreaScopeLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaScopeLsaCksumSum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaScopeLsaCksumSum.setDescription("The 32-bit unsigned sum of the Area-scope link state advertisements' LS checksums contained in this area's link state database. The sum can be used to determine if there has been a change in a router's link state database or to compare the link state database of two routers.")
rlOspfv3AreaSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAreaSummary", 1), ("sendAreaSummary", 2))).clone('sendAreaSummary')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaSummary.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaSummary.setDescription('The variable rlOspfv3AreaSummary controls the import of Inter-Area LSAs into stub and NSSA areas. It has no effect on other areas. If it is noAreaSummary, the router will neither originate nor propagate Inter-Area LSAs into the stub or NSSA area. It will only advertise a default route. If it is sendAreaSummary, the router will both summarize and propagate Inter-Area LSAs.')
rlOspfv3AreaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaRowStatus.setDescription('This object permits management of the table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
rlOspfv3AreaStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 11), BigMetric()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaStubMetric.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaStubMetric.setDescription('The metric value advertised for the default route into stub and NSSA areas. By default, this equals the least metric among the interfaces to other areas.')
rlOspfv3AreaNssaTranslatorRole = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("always", 1), ("candidate", 2))).clone('candidate')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorRole.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorRole.setDescription("Indicates an NSSA border router's policy to perform NSSA translation of NSSA-LSAs into AS-External-LSAs.")
rlOspfv3AreaNssaTranslatorState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("elected", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorState.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorState.setDescription("Indicates if and how an NSSA border router is performing NSSA translation of NSSA-LSAs into AS-External-LSAs. When this object is set to 'enabled', the NSSA border router's rlOspfv3AreaNssaTranslatorRole has been set to 'always'. When this object is set to 'elected', a candidate NSSA border router is translating NSSA-LSAs into AS-External-LSAs. When this object is set to 'disabled', a candidate NSSA Border router is NOT translating NSSA-LSAs into AS-External-LSAs.")
rlOspfv3AreaNssaTranslatorStabInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 14), Unsigned32().clone(40)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorStabInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorStabInterval.setDescription('The stability interval defined as the number of seconds after an elected translator determines its services are no longer required that it should continue to perform its translation duties.')
rlOspfv3AreaNssaTranslatorEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorEvents.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaNssaTranslatorEvents.setDescription('Indicates the number of Translator state changes that have occurred since the last start-up of the OSPFv3 routing process. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of rlOspfv3DiscontinuityTime.')
rlOspfv3AreaStubMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rlOspfv3Metric", 1), ("comparableCost", 2), ("nonComparable", 3))).clone('rlOspfv3Metric')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaStubMetricType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaStubMetricType.setDescription('This variable assigns the type of metric advertised as a default route.')
rlOspfv3AreaTEEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 17), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaTEEnabled.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaTEEnabled.setDescription('Indicates whether or not traffic engineering is enabled in the area. The object is set to the value true (1) to enable traffic engineering. Traffic engineering is disabled by default.')
rlOspfv3AreaAdminStat = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 18), Status().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaAdminStat.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAdminStat.setDescription("The OSPF Area's administrative status. The value formed on the area, and the in- terfaces associated with the area. The value 'disabled' denotes that the area is external to OSPF.")
rlOspfv3AreaOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("goingUp", 3), ("goingDown", 4), ("actFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaOperStatus.setDescription('The current operational state of the OSPF Area.')
rlOspfv3AreaFilterPrefixListIn = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3AreaFilterPrefixListIn.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaFilterPrefixListIn.setDescription('The prefix list is applied to prefixes advertised to the specified area from other areas.')
rlOspfv3AreaFilterPrefixListOut = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 3, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3AreaFilterPrefixListOut.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaFilterPrefixListOut.setDescription('The prefix list is applied to prefixes advertised out of the specified area to other areas.')
rlOspfv3AsLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 4), )
if mibBuilder.loadTexts: rlOspfv3AsLsdbTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbTable.setDescription("The OSPFv3 Process's AS-scope link state database (LSDB). The LSDB contains the AS-scope link state advertisements from throughout the areas that the device is attached to.")
rlOspfv3AsLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 4, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3AsLsdbProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AsLsdbType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AsLsdbRouterId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AsLsdbLsid"))
if mibBuilder.loadTexts: rlOspfv3AsLsdbEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbEntry.setDescription('A single AS-scope link state advertisement.')
rlOspfv3AsLsdbProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsLsdbProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3AsLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: rlOspfv3AsLsdbType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbType.setDescription('The type of the link state advertisement. Each link state type has a separate advertisement format. AS-scope LSAs not recognized by the router may be stored in the database.')
rlOspfv3AsLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 3), RouterID())
if mibBuilder.loadTexts: rlOspfv3AsLsdbRouterId.setReference('OSPF Version 2, Appendix C.1, Global parameters')
if mibBuilder.loadTexts: rlOspfv3AsLsdbRouterId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbRouterId.setDescription('The 32-bit number that uniquely identifies the originating router in the Autonomous System.')
rlOspfv3AsLsdbLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 4), RlLsID())
if mibBuilder.loadTexts: rlOspfv3AsLsdbLsid.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbLsid.setDescription('The Link State ID is an LS type-specific field containing a unique identifier; it identifies the piece of the routing domain that is being described by the advertisement. In contrast to OSPFv2, the LSID has no addressing semantics.')
rlOspfv3AsLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 5), Ospfv3LsaSequenceTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsLsdbSequence.setReference('OSPF Version 2, Section 12.1.6, LS sequence number')
if mibBuilder.loadTexts: rlOspfv3AsLsdbSequence.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbSequence.setDescription('The sequence number field is a signed 32-bit integer. It is used to detect old and duplicate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
rlOspfv3AsLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 6), Ospfv3LsaAgeTC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsLsdbAge.setReference('OSPF Version 2, Section 12.1.1, LS age; Extending OSPF to Support Demand Circuits, Section 2.2, The LS age field.')
if mibBuilder.loadTexts: rlOspfv3AsLsdbAge.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbAge.setDescription('This field is the age of the link state advertisement in seconds. The high-order bit of the LS age field is considered the DoNotAge bit for support of on-demand circuits.')
rlOspfv3AsLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsLsdbChecksum.setReference('OSPF Version 2, Section 12.1.7, LS checksum')
if mibBuilder.loadTexts: rlOspfv3AsLsdbChecksum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbChecksum.setDescription("This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connectionless datagrams; it is commonly referred to as the Fletcher checksum.")
rlOspfv3AsLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsLsdbAdvertisement.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbAdvertisement.setDescription('The entire link state advertisement, including its header.')
rlOspfv3AsLsdbTypeKnown = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 4, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AsLsdbTypeKnown.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AsLsdbTypeKnown.setDescription('The value true (1) indicates that the LSA type is recognized by this router.')
rlOspfv3AreaLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 5), )
if mibBuilder.loadTexts: rlOspfv3AreaLsdbTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbTable.setDescription("The OSPFv3 Process's Area-scope LSDB. The LSDB contains the Area-scope link state advertisements from throughout the area that the device is attached to.")
rlOspfv3AreaLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 5, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaLsdbProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaLsdbAreaId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaLsdbType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaLsdbRouterId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaLsdbLsid"))
if mibBuilder.loadTexts: rlOspfv3AreaLsdbEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbEntry.setDescription('A single Area-scope link state advertisement.')
rlOspfv3AreaLsdbProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaLsdbProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3AreaLsdbAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 2), AreaID())
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAreaId.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAreaId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAreaId.setDescription('The 32-bit identifier of the Area from which the LSA was received.')
rlOspfv3AreaLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: rlOspfv3AreaLsdbType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbType.setDescription('The type of the link state advertisement. Each link state type has a separate advertisement format. Area-scope LSAs unrecognized by the router are also stored in this database.')
rlOspfv3AreaLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 4), RouterID())
if mibBuilder.loadTexts: rlOspfv3AreaLsdbRouterId.setReference('OSPF Version 2, Appendix C.1, Global parameters')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbRouterId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbRouterId.setDescription('The 32-bit number that uniquely identifies the originating router in the Autonomous System.')
rlOspfv3AreaLsdbLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 5), RlLsID())
if mibBuilder.loadTexts: rlOspfv3AreaLsdbLsid.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbLsid.setDescription('The Link State ID is an LS type-specific field containing a unique identifier; it identifies the piece of the routing domain that is being described by the advertisement. In contrast to OSPFv2, the LSID has no addressing semantics.')
rlOspfv3AreaLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 6), Ospfv3LsaSequenceTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaLsdbSequence.setReference('OSPF Version 2, Section 12.1.6, LS sequence number')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbSequence.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbSequence.setDescription('The sequence number field is a signed 32-bit integer. It is used to detect old and duplicate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
rlOspfv3AreaLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 7), Ospfv3LsaAgeTC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAge.setReference('OSPF Version 2, Section 12.1.1, LS age; Extending OSPF to Support Demand Circuits, Section 2.2, The LS age field.')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAge.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAge.setDescription('This field is the age of the link state advertisement in seconds. The high-order bit of the LS age field is considered the DoNotAge bit for support of on-demand circuits.')
rlOspfv3AreaLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaLsdbChecksum.setReference('OSPF Version 2, Section 12.1.7, LS checksum')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbChecksum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbChecksum.setDescription("This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connectionless datagrams; it is commonly referred to as the Fletcher checksum.")
rlOspfv3AreaLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAdvertisement.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbAdvertisement.setDescription('The entire link state advertisement, including its header.')
rlOspfv3AreaLsdbTypeKnown = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 5, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaLsdbTypeKnown.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaLsdbTypeKnown.setDescription('The value true (1) indicates that the LSA type is recognized by this router.')
rlOspfv3LinkLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 6), )
if mibBuilder.loadTexts: rlOspfv3LinkLsdbTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbTable.setDescription("The OSPFv3 Process's Link-scope LSDB for non-virtual interfaces. The LSDB contains the Link-scope link state advertisements from the interfaces that the device is attached to.")
rlOspfv3LinkLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 6, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3LinkLsdbProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3LinkLsdbIfIndex"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3LinkLsdbIfInstId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3LinkLsdbType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3LinkLsdbRouterId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3LinkLsdbLsid"))
if mibBuilder.loadTexts: rlOspfv3LinkLsdbEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbEntry.setDescription('A single Link-scope link state advertisement.')
rlOspfv3LinkLsdbProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3LinkLsdbProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3LinkLsdbIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: rlOspfv3LinkLsdbIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbIfIndex.setDescription('The identifier of the link from which the LSA was received.')
rlOspfv3LinkLsdbIfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 3), Ospfv3IfInstIdTC())
if mibBuilder.loadTexts: rlOspfv3LinkLsdbIfInstId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbIfInstId.setDescription('The identifier of the interface instance from which the LSA was received.')
rlOspfv3LinkLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: rlOspfv3LinkLsdbType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbType.setDescription('The type of the link state advertisement. Each link state type has a separate advertisement format. Link-scope LSAs unrecognized by the router are also stored in this database.')
rlOspfv3LinkLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 5), RouterID())
if mibBuilder.loadTexts: rlOspfv3LinkLsdbRouterId.setReference('OSPF Version 2, Appendix C.1, Global parameters')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbRouterId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbRouterId.setDescription('The 32-bit number that uniquely identifies the originating router in the Autonomous System.')
rlOspfv3LinkLsdbLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 6), RlLsID())
if mibBuilder.loadTexts: rlOspfv3LinkLsdbLsid.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbLsid.setDescription('The Link State ID is an LS type-specific field containing a unique identifier; it identifies the piece of the routing domain that is being described by the advertisement. In contrast to OSPFv2, the LSID has no addressing semantics. However, in OSPFv3 the Link State ID always contains the flooding scope of the LSA.')
rlOspfv3LinkLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 7), Ospfv3LsaSequenceTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3LinkLsdbSequence.setReference('OSPF Version 2, Section 12.1.6, LS sequence number')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbSequence.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbSequence.setDescription('The sequence number field is a signed 32-bit integer. It is used to detect old and duplicate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
rlOspfv3LinkLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 8), Ospfv3LsaAgeTC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3LinkLsdbAge.setReference('OSPF Version 2, Section 12.1.1, LS age; Extending OSPF to Support Demand Circuits, Section 2.2, The LS age field.')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbAge.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbAge.setDescription('This field is the age of the link state advertisement in seconds. The high-order bit of the LS age field is considered the DoNotAge bit for support of on-demand circuits.')
rlOspfv3LinkLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3LinkLsdbChecksum.setReference('OSPF Version 2, Section 12.1.7, LS checksum')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbChecksum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbChecksum.setDescription("This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connectionless datagrams; it is commonly referred to as the Fletcher checksum.")
rlOspfv3LinkLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3LinkLsdbAdvertisement.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbAdvertisement.setDescription('The entire link state advertisement, including its header.')
rlOspfv3LinkLsdbTypeKnown = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 6, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3LinkLsdbTypeKnown.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LinkLsdbTypeKnown.setDescription('The value true (1) indicates that the LSA type is recognized by this router.')
rlOspfv3HostTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 7), )
if mibBuilder.loadTexts: rlOspfv3HostTable.setReference('OSPF Version 2, Appendix C.7, Host route parameters')
if mibBuilder.loadTexts: rlOspfv3HostTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostTable.setDescription('The Host/Metric Table indicates what hosts are directly attached to the router and their corresponding metrics.')
rlOspfv3HostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 7, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3HostProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3HostAddressType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3HostAddress"))
if mibBuilder.loadTexts: rlOspfv3HostEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostEntry.setDescription('A metric to be advertised when a given host is reachable. The information in this table is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3HostProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 7, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3HostProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3HostAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 7, 1, 2), InetAddressType())
if mibBuilder.loadTexts: rlOspfv3HostAddressType.setReference('OSPF Version 2, Appendix C.7, Host route parameters')
if mibBuilder.loadTexts: rlOspfv3HostAddressType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostAddressType.setDescription('The address type of rlOspfv3HostAddress. Only IPv6 global address type is expected.')
rlOspfv3HostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 7, 1, 3), InetAddress())
if mibBuilder.loadTexts: rlOspfv3HostAddress.setReference('OSPF Version 2, Appendix C.7, Host route parameters')
if mibBuilder.loadTexts: rlOspfv3HostAddress.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostAddress.setDescription('The IPv6 address of the host. Must be an IPv6 global address.')
rlOspfv3HostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 7, 1, 4), Metric()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3HostMetric.setReference('OSPF Version 2, Appendix C.7, Host route parameters')
if mibBuilder.loadTexts: rlOspfv3HostMetric.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostMetric.setDescription('The metric to be advertised.')
rlOspfv3HostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 7, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3HostRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostRowStatus.setDescription('This object permits management of the table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
rlOspfv3HostAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 7, 1, 6), AreaID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3HostAreaID.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3HostAreaID.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3HostAreaID.setDescription('The Area the host entry is to be found within. By default, the area for the subsuming OSPFv3 interface, or Area 0 if there is no subsuming interface.')
rlOspfv3IfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 8), )
if mibBuilder.loadTexts: rlOspfv3IfTable.setReference('OSPF for IPv6, Appendix C.3, Router Interface Parameters')
if mibBuilder.loadTexts: rlOspfv3IfTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfTable.setDescription('The OSPFv3 Interface Table describes the interfaces from the viewpoint of OSPFv3.')
rlOspfv3IfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 8, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3IfProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3IfIndex"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3IfInstId"))
if mibBuilder.loadTexts: rlOspfv3IfEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfEntry.setDescription('The OSPFv3 Interface Entry describes one interface from the viewpoint of OSPFv3. The information in this table is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3IfProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: rlOspfv3IfIndex.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfIndex.setDescription('The interface index of this OSPFv3 interface. It corresponds to the interface index of the IPv6 interface on which OSPFv3 is configured.')
rlOspfv3IfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 3), Ospfv3IfInstIdTC())
if mibBuilder.loadTexts: rlOspfv3IfInstId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfInstId.setDescription('Enables multiple interface instances of OSPFv3 to be run over a single link. Each interface instance would be assigned a separate ID. This ID has local link significance only.')
rlOspfv3IfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 4), AreaID()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfAreaId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfAreaId.setDescription('A 32-bit integer uniquely identifying the area to which the interface connects. Area ID 0 is used for the OSPFv3 backbone.')
rlOspfv3IfType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 5))).clone(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointToPoint", 3), ("pointToMultipoint", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfType.setDescription('The OSPFv3 interface type.')
rlOspfv3IfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 6), Status().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfAdminStatus.setDescription("The OSPFv3 interface's administrative status. The value formed on the interface; the interface will be advertised as an internal route to some area. The value 'disabled' denotes that the interface is external to OSPFv3. Note that a value of 'disabled' for the object rlOspfv3AdminStatus will override a value of 'enabled' for the interface.")
rlOspfv3IfRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 7), DesignatedRouterPriority().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfRtrPriority.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfRtrPriority.setDescription('The priority of this interface. Used in multi-access networks, this field is used in the designated-router election algorithm. The value 0 signifies that the router is not eligible to become the Designated Router on this particular network. In the event of a tie in this value, routers will use their Router ID as a tie breaker.')
rlOspfv3IfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 8), RlOspfv3UpToRefreshIntervalTC().clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfTransitDelay.setReference('OSPF for IPv6, Appendix C.3, Router Interface Parameters.')
if mibBuilder.loadTexts: rlOspfv3IfTransitDelay.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a Link State Update packet over this interface. LSAs contained in the update packet must have their age incremented by this amount before transmission. This value should take into account the transmission and propagation delays of the interface.')
rlOspfv3IfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 9), RlOspfv3UpToRefreshIntervalTC().clone(5)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfRetransInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfRetransInterval.setDescription('The number of seconds between link state advertisement retransmissions for adjacencies belonging to this interface. This value is also used when retransmitting database description and Link State Request packets.')
rlOspfv3IfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 10), HelloRange().clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfHelloInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfHelloInterval.setDescription('The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for all routers attached to a common network.')
rlOspfv3IfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 11), Ospfv3DeadIntervalRangeTC().clone(40)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfRtrDeadInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfRtrDeadInterval.setDescription("The number of seconds that a router's Hello packets have not been seen before its neighbors declare the router down on the interface. This should be some multiple of the Hello interval. This value must be the same for all routers attached to a common network.")
rlOspfv3IfPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 12), Unsigned32().clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfPollInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfPollInterval.setDescription('The larger time interval, in seconds, between the Hello packets sent to an inactive, non-broadcast multi-access neighbor.')
rlOspfv3IfState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("loopback", 2), ("waiting", 3), ("pointToPoint", 4), ("designatedRouter", 5), ("backupDesignatedRouter", 6), ("otherDesignatedRouter", 7), ("standby", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfState.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfState.setDescription("The OSPFv3 interface state. An interface may be in standby state if there are multiple interfaces on the link and another interface is active. The interface may be in Down state if the underlying IPv6 interface is down or if the admin status is 'disabled' either globally or for the interface.")
rlOspfv3IfDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 14), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfDesignatedRouter.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfDesignatedRouter.setDescription('The Router ID of the Designated Router.')
rlOspfv3IfBackupDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 15), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfBackupDesignatedRouter.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfBackupDesignatedRouter.setDescription('The Router ID of the Backup Designated Router.')
rlOspfv3IfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfEvents.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfEvents.setDescription('The number of times this OSPFv3 interface has changed its state or an error has occurred. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of rlOspfv3DiscontinuityTime.')
rlOspfv3IfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfRowStatus.setDescription('This object permits management of the table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
rlOspfv3IfDemand = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 18), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfDemand.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfDemand.setDescription('Indicates whether Demand OSPFv3 procedures (Hello suppression to FULL neighbors and setting the DoNotAge flag on propagated LSAs) should be performed on this interface.')
rlOspfv3IfMetricValue = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 19), Metric()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfMetricValue.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfMetricValue.setDescription("The metric assigned to this interface. The default value of the metric is 'Reference Bandwidth / ifSpeed'. The value of the reference bandwidth can be set in the rlOspfv3ReferenceBandwidth object.")
rlOspfv3IfLinkScopeLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfLinkScopeLsaCount.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfLinkScopeLsaCount.setDescription("The total number of Link-scope link state advertisements in this link's link state database.")
rlOspfv3IfLinkLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 21), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfLinkLsaCksumSum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfLinkLsaCksumSum.setDescription("The 32-bit unsigned sum of the Link-scope link state advertisements' LS checksums contained in this link's link state database. The sum can be used to determine if there has been a change in a router's link state database or to compare the link state database of two routers.")
rlOspfv3IfDemandNbrProbe = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 22), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfDemandNbrProbe.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfDemandNbrProbe.setDescription('Indicates whether or not neighbor probing is enabled to determine whether or not the neighbor is inactive. Neighbor probing is disabled by default.')
rlOspfv3IfDemandNbrProbeRetransLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 23), Unsigned32().clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfDemandNbrProbeRetransLimit.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfDemandNbrProbeRetransLimit.setDescription('The number of consecutive LSA retransmissions before the neighbor is deemed inactive and the neighbor adjacency is brought down.')
rlOspfv3IfDemandNbrProbeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 24), Unsigned32().clone(120)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfDemandNbrProbeInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfDemandNbrProbeInterval.setDescription('Defines how often the neighbor will be probed.')
rlOspfv3IfTEDisabled = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 25), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfTEDisabled.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfTEDisabled.setDescription('Indicates whether or not traffic engineering is disabled on the interface when traffic engineering is enabled in the area where the interface is attached. The object is set to the value true (1) to disable traffic engineering on the interface. Traffic engineering is enabled by default on the interface when traffic engineering is enabled in the area where the interface is attached.')
rlOspfv3IfLinkLSASuppression = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 26), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfLinkLSASuppression.setReference('OSPF for IPv6, Appendix C.3, Router Interface Parameters')
if mibBuilder.loadTexts: rlOspfv3IfLinkLSASuppression.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfLinkLSASuppression.setDescription('Specifies whether or not link LSA origination is suppressed for broadcast or NBMA interface types. The object is set to value true (1) to suppress the origination.')
rlOspfv3IfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("goingUp", 3), ("goingDown", 4), ("actFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3IfOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfOperStatus.setDescription('The current operational state of the OSPF interface.')
rlOspfv3IfPassive = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 28), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3IfPassive.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfPassive.setDescription('Indicates whether this interface is a passive interface. If set to TRUE, we suppress HELLO packets sent on and received from this interface. We will therefore advertise this interface in our LSAs but not run OSPF protocol over it.')
rlOspfv3IfLsaRefreshIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3599)).clone(1800)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3IfLsaRefreshIntvl.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfLsaRefreshIntvl.setDescription('Self-originated LSAs are periodically reflooded into the routing domain, to add to the robustness of the OSPF protocol. This value determines the interval between refreshes of LSAs that are only flooded over this interface, for example type-9 opaque LSAs, and is defaulted to the OSPF standard default of 1800 seconds (30 minutes).')
rlOspfv3IfFastHelloMultiplier = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 30), RlOspfv3FastHelloMultiplierRange().clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3IfFastHelloMultiplier.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfFastHelloMultiplier.setDescription('The number of Hellos that should be sent within 1 second when using Fast Hellos on this interface. This value does not have to be same for all routers attached to a common network, but it is advisable. Fast Hellos are configured using ospfPmIfRtrDeadInterval.')
rlOspfv3IfMtuIgnore = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 31), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3IfMtuIgnore.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfMtuIgnore.setDescription('This object controls whether DC-OSPF checks the MTU size on incoming Database Description packets. By default, if the received MTU size in a DB Description packet is higher than the MTU size configured on the incoming interface, the OSPF adjacency will not be established. If the interface is tunneled over, say, an MPLS network, then the administrator may not know the maximum MTU size and so can tell DC-OSPF to ignore the MTU size on incoming DB description packets.')
rlOspfv3IfNameLookup = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 8, 1, 32), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3IfNameLookup.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfNameLookup.setDescription('A flag to note whether to look up Domain Name System (DNS) names for use in all OSPF show EXEC command displays.')
rlOspfv3VirtIfTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 9), )
if mibBuilder.loadTexts: rlOspfv3VirtIfTable.setReference('OSPF for IPv6, Appendix C.4, Virtual Link Parameters')
if mibBuilder.loadTexts: rlOspfv3VirtIfTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfTable.setDescription("Information about this router's virtual interfaces that the OSPFv3 Process is configured to carry on.")
rlOspfv3VirtIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 9, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtIfProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtIfAreaId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtIfNeighbor"))
if mibBuilder.loadTexts: rlOspfv3VirtIfEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfEntry.setDescription('Information about a single virtual interface. The information in this table is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3VirtIfProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3VirtIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 2), AreaID())
if mibBuilder.loadTexts: rlOspfv3VirtIfAreaId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfAreaId.setDescription('The transit area that the virtual link traverses. By definition, this is not Area 0.')
rlOspfv3VirtIfNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 3), RouterID())
if mibBuilder.loadTexts: rlOspfv3VirtIfNeighbor.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfNeighbor.setDescription('The Router ID of the virtual neighbor.')
rlOspfv3VirtIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 4), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfIndex.setDescription("The local interface index assigned by the OSPFv3 Process to this OSPFv3 virtual interface. It is advertised in Hellos sent over the virtual link and in the router's router-LSAs.")
rlOspfv3VirtIfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 5), Ospfv3IfInstIdTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfInstId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfInstId.setDescription('The local Interface Instance ID assigned by the OSPFv3 Process to this OSPFv3 virtual interface.')
rlOspfv3VirtIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 6), RlOspfv3UpToRefreshIntervalTC().clone(1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3VirtIfTransitDelay.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a Link State Update packet over this interface.')
rlOspfv3VirtIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 7), RlOspfv3UpToRefreshIntervalTC().clone(5)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3VirtIfRetransInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfRetransInterval.setDescription('The number of seconds between link state advertisement retransmissions for adjacencies belonging to this interface. This value is also used when retransmitting database description and Link State Request packets. This value should be well over the expected round-trip time.')
rlOspfv3VirtIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 8), HelloRange().clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3VirtIfHelloInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfHelloInterval.setDescription('The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for the virtual neighbor.')
rlOspfv3VirtIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 9), Ospfv3DeadIntervalRangeTC().clone(60)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3VirtIfRtrDeadInterval.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfRtrDeadInterval.setDescription("The number of seconds that a router's Hello packets have not been seen before its neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for the virtual neighbor.")
rlOspfv3VirtIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("down", 1), ("pointToPoint", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfState.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfState.setDescription('OSPF virtual interface states. The same encoding as the ospfV3IfTable is used.')
rlOspfv3VirtIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfEvents.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfEvents.setDescription('The number of state changes or error events on this virtual link. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of rlOspfv3DiscontinuityTime.')
rlOspfv3VirtIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3VirtIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfRowStatus.setDescription('This object permits management of the table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
rlOspfv3VirtIfLinkScopeLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfLinkScopeLsaCount.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfLinkScopeLsaCount.setDescription("The total number of Link-scope link state advertisements in this virtual link's link state database.")
rlOspfv3VirtIfLinkLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 14), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfLinkLsaCksumSum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfLinkLsaCksumSum.setDescription("The 32-bit unsigned sum of the Link-scope link state advertisements' LS checksums contained in this virtual link's link state database. The sum can be used to determine if there has been a change in a router's link state database or to compare the link state database of two routers.")
rlOspfv3VirtIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 15), Status().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3VirtIfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfAdminStatus.setDescription('The desired administrative state of this virtual interface.')
rlOspfv3VirtIfOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 9, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("goingUp", 3), ("goingDown", 4), ("actFailed", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtIfOperStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfOperStatus.setDescription('The current operational state of this virtual interface.')
rlOspfv3NbrTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 10), )
if mibBuilder.loadTexts: rlOspfv3NbrTable.setReference('OSPF Version 2, Section 10, The Neighbor Data Structure')
if mibBuilder.loadTexts: rlOspfv3NbrTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrTable.setDescription('A table describing all neighbors in the locality of the OSPFv3 router.')
rlOspfv3NbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 10, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3NbrProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3NbrIfIndex"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3NbrIfInstId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3NbrRtrId"))
if mibBuilder.loadTexts: rlOspfv3NbrEntry.setReference('OSPF Version 2, Section 10, The Neighbor Data Structure')
if mibBuilder.loadTexts: rlOspfv3NbrEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrEntry.setDescription('The information regarding a single neighbor.')
rlOspfv3NbrProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3NbrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: rlOspfv3NbrIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrIfIndex.setDescription('The Local Link ID of the link over which the neighbor can be reached.')
rlOspfv3NbrIfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 3), Ospfv3IfInstIdTC())
if mibBuilder.loadTexts: rlOspfv3NbrIfInstId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrIfInstId.setDescription('Interface instance over which the neighbor can be reached. This ID has local link significance only.')
rlOspfv3NbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 4), RouterID())
if mibBuilder.loadTexts: rlOspfv3NbrRtrId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrRtrId.setDescription('A 32-bit unsigned integer uniquely identifying the neighboring router in the Autonomous System.')
rlOspfv3NbrAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrAddressType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrAddressType.setDescription('The address type of rlOspfv3NbrAddress. Only IPv6 addresses without zone index are expected.')
rlOspfv3NbrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrAddress.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrAddress.setDescription('The IPv6 address of the neighbor associated with the local link.')
rlOspfv3NbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrOptions.setReference('OSPF for IPv6, Appendix A.2, The Options Field')
if mibBuilder.loadTexts: rlOspfv3NbrOptions.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrOptions.setDescription("A bit mask corresponding to the neighbor's options field.")
rlOspfv3NbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 8), DesignatedRouterPriority()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrPriority.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrPriority.setDescription('The priority of this neighbor in the designated- router election algorithm. The value 0 signifies that the neighbor is not eligible to become the Designated Router on this particular network.')
rlOspfv3NbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrState.setReference('OSPF Version 2, Section 10.1, Neighbor states')
if mibBuilder.loadTexts: rlOspfv3NbrState.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrState.setDescription('The state of the relationship with this neighbor.')
rlOspfv3NbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrEvents.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrEvents.setDescription('The number of times this neighbor relationship has changed state or an error has occurred. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of rlOspfv3DiscontinuityTime.')
rlOspfv3NbrLsRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrLsRetransQLen.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrLsRetransQLen.setDescription('The current length of the retransmission queue.')
rlOspfv3NbrHelloSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrHelloSuppressed.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrHelloSuppressed.setDescription('Indicates whether Hellos are being suppressed to the neighbor.')
rlOspfv3NbrIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 13), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrIfId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrIfId.setDescription("The Interface ID that the neighbor advertises in its Hello packets on this link, that is, the neighbor's local interface index.")
rlOspfv3NbrRestartHelperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notHelping", 1), ("helping", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperStatus.setDescription('Indicates whether the router is acting as a graceful restart helper for the neighbor.')
rlOspfv3NbrRestartHelperAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 15), Ospfv3UpToRefreshIntervalTC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperAge.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperAge.setDescription('Remaining time in current OSPF graceful restart interval, if the router is acting as a restart helper for the neighbor.')
rlOspfv3NbrRestartHelperExitReason = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("inProgress", 2), ("completed", 3), ("timedOut", 4), ("topologyChanged", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperExitReason.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperExitReason.setDescription('Describes the outcome of the last attempt at acting as a graceful restart helper for the neighbor. none: no restart has yet been attempted. inProgress: a restart attempt is currently underway. completed: the last restart completed successfully. timedOut: the last restart timed out. topologyChanged: the last restart was aborted due to a topology change.')
rlOspfv3NbrDeadTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 17), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrDeadTime.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrDeadTime.setDescription('The time remaining in seconds within which we need to receive a hello packet from the neighbor or we declare the adjacency down. If fast hellos area in use, this value is always set to 1. If the oper_status is down or ospfPmNbrState is DOWN, then the value is set to zero and the field is not valid.')
rlOspfv3NbrAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 10, 1, 18), AreaID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3NbrAreaId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrAreaId.setDescription('The area to which the neighbor belongs. If the oper_status is down, then this value is set to zero and the field is not valid.')
rlOspfv3CfgNbrTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 11), )
if mibBuilder.loadTexts: rlOspfv3CfgNbrTable.setReference('OSPF Version 2, Section 10, The Neighbor Data Structure')
if mibBuilder.loadTexts: rlOspfv3CfgNbrTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrTable.setDescription('A table describing all configured neighbors. The Configured Neighbors table just gives OSPFv3 information for sending OSPFv3 packets to potential neighbors and is typically used on NBMA and Point-to-Multipoint networks. Once a Hello is received from a neighbor in the Configured Neighbor table, an entry for that neighbor is created in the Neighbor table and adjacency state is maintained there. Neighbors on multi-access or Point-to-Point networks can use multicast addressing, so only Neighbor table entries are created for them.')
rlOspfv3CfgNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 11, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspf3CfgNbrProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3CfgNbrIfIndex"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3CfgNbrIfInstId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3CfgNbrAddressType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3CfgNbrAddress"))
if mibBuilder.loadTexts: rlOspfv3CfgNbrEntry.setReference('OSPF Version 2, Section 10, The Neighbor Data Structure')
if mibBuilder.loadTexts: rlOspfv3CfgNbrEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrEntry.setDescription('The information regarding a single configured neighbor. The information in this table is persistent, and when written, the entity SHOULD save the change to non-volatile storage.')
rlOspf3CfgNbrProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 11, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspf3CfgNbrProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspf3CfgNbrProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3CfgNbrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 11, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: rlOspfv3CfgNbrIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrIfIndex.setDescription('The Local Link ID of the link over which the neighbor can be reached.')
rlOspfv3CfgNbrIfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 11, 1, 3), Ospfv3IfInstIdTC())
if mibBuilder.loadTexts: rlOspfv3CfgNbrIfInstId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrIfInstId.setDescription('Interface instance over which the neighbor can be reached. This ID has local link significance only.')
rlOspfv3CfgNbrAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 11, 1, 4), InetAddressType())
if mibBuilder.loadTexts: rlOspfv3CfgNbrAddressType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrAddressType.setDescription('The address type of rlOspfv3NbrAddress. Only IPv6 addresses without zone index are expected.')
rlOspfv3CfgNbrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 11, 1, 5), InetAddress())
if mibBuilder.loadTexts: rlOspfv3CfgNbrAddress.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrAddress.setDescription('The IPv6 address of the neighbor associated with the local link.')
rlOspfv3CfgNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 11, 1, 6), DesignatedRouterPriority().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3CfgNbrPriority.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrPriority.setDescription('The priority of this neighbor in the designated- router election algorithm. The value 0 signifies that the neighbor is not eligible to become the Designated Router on this particular network.')
rlOspfv3CfgNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 11, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3CfgNbrRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3CfgNbrRowStatus.setDescription('This object permits management of the table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
rlOspfv3VirtNbrTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 12), )
if mibBuilder.loadTexts: rlOspfv3VirtNbrTable.setReference('OSPF Version 2, Section 15, Virtual Links')
if mibBuilder.loadTexts: rlOspfv3VirtNbrTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrTable.setDescription('A table describing all virtual neighbors.')
rlOspfv3VirtNbrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 12, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtNbrProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtNbrArea"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtNbrRtrId"))
if mibBuilder.loadTexts: rlOspfv3VirtNbrEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrEntry.setDescription('Virtual neighbor information.')
rlOspfv3VirtNbrProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3VirtNbrArea = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 2), AreaID())
if mibBuilder.loadTexts: rlOspfv3VirtNbrArea.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrArea.setDescription('The transit area Identifier.')
rlOspfv3VirtNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 3), RouterID())
if mibBuilder.loadTexts: rlOspfv3VirtNbrRtrId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrRtrId.setDescription('A 32-bit integer uniquely identifying the neighboring router in the Autonomous System.')
rlOspfv3VirtNbrIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 4), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrIfIndex.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrIfIndex.setDescription('The local Interface ID for the virtual link over which the neighbor can be reached.')
rlOspfv3VirtNbrIfInstId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 5), Ospfv3IfInstIdTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrIfInstId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrIfInstId.setDescription('The interface instance for the virtual link over which the neighbor can be reached.')
rlOspfv3VirtNbrAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrAddressType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrAddressType.setDescription('The address type of rlOspfv3VirtNbrAddress. Only IPv6 addresses without zone index are expected.')
rlOspfv3VirtNbrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrAddress.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrAddress.setDescription('The IPv6 address advertised by this virtual neighbor. It must be a global scope address.')
rlOspfv3VirtNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrOptions.setReference('OSPF for IPv6, Appendix A.2, The Options Field')
if mibBuilder.loadTexts: rlOspfv3VirtNbrOptions.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrOptions.setDescription("A bit mask corresponding to the neighbor's options field.")
rlOspfv3VirtNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrState.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrState.setDescription('The state of the virtual neighbor relationship.')
rlOspfv3VirtNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrEvents.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrEvents.setDescription('The number of times this virtual link has changed its state or an error has occurred. Discontinuities in the value of this counter can occur at re-initialization of the management system and at other times as indicated by the value of rlOspfv3DiscontinuityTime.')
rlOspfv3VirtNbrLsRetransQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrLsRetransQLen.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrLsRetransQLen.setDescription('The current length of the retransmission queue.')
rlOspfv3VirtNbrHelloSuppressed = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 12), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrHelloSuppressed.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrHelloSuppressed.setDescription('Indicates whether Hellos are being suppressed to the neighbor.')
rlOspfv3VirtNbrIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 13), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrIfId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrIfId.setDescription("The Interface ID that the neighbor advertises in its Hello packets on this virtual link, that is, the neighbor's local Interface ID.")
rlOspfv3VirtNbrRestartHelperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notHelping", 1), ("helping", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperStatus.setDescription('Indicates whether the router is acting as a graceful restart helper for the neighbor.')
rlOspfv3VirtNbrRestartHelperAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 15), Ospfv3UpToRefreshIntervalTC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperAge.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperAge.setDescription('Remaining time in the current OSPF graceful restart interval, if the router is acting as a restart helper for the neighbor.')
rlOspfv3VirtNbrRestartHelperExitReason = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("inProgress", 2), ("completed", 3), ("timedOut", 4), ("topologyChanged", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperExitReason.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperExitReason.setDescription('Describes the outcome of the last attempt at acting as a graceful restart helper for the neighbor. none: no restart has yet been attempted. inProgress: a restart attempt is currently underway. completed: the last restart completed successfully. timedOut: the last restart timed out. topologyChanged: the last restart was aborted due to a topology change.')
rlOspfv3VirtNbrDeadTime = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 12, 1, 17), PositiveInteger()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtNbrDeadTime.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrDeadTime.setDescription('The time remaining in seconds within which we need to receive a hello packet from the neighbor or we declare the adjacency down. If fast hellos area in use, this value is always set to 1. If the oper_status is down or ospfPmVirtNbrState is DOWN, then the value is set to zero and the field is not valid.')
rlOspfv3AreaAggregateTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 13), )
if mibBuilder.loadTexts: rlOspfv3AreaAggregateTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateTable.setDescription("The Area Aggregate Table acts as an adjunct to the Area Table. It describes those address aggregates that are configured to be propagated from an area. Its purpose is to reduce the amount of information that is known beyond an area's borders. A range of IPv6 prefixes specified by a prefix / prefix length pair. Note that if ranges are configured such that one range subsumes another range, the most specific match is the preferred one.")
rlOspfv3AreaAggregateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 13, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaAggregateProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaAggregateAreaID"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaAggregateAreaLsdbType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaAggregatePrefixType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaAggregatePrefix"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3AreaAggregatePrefixLength"))
if mibBuilder.loadTexts: rlOspfv3AreaAggregateEntry.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateEntry.setDescription('A single area aggregate entry. Information in this table is persistent, and when this object is written, the entity SHOULD save the change to non-volatile storage.')
rlOspfv3AreaAggregateProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3AreaAggregateProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3AreaAggregateAreaID = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 2), AreaID())
if mibBuilder.loadTexts: rlOspfv3AreaAggregateAreaID.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateAreaID.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateAreaID.setDescription('The area the Address Aggregate is to be found within.')
rlOspfv3AreaAggregateAreaLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8195, 8199))).clone(namedValues=NamedValues(("interAreaPrefixLsa", 8195), ("nssaExternalLsa", 8199))))
if mibBuilder.loadTexts: rlOspfv3AreaAggregateAreaLsdbType.setReference('OSPF Version 2, Appendix A.4.1, The LSA header')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateAreaLsdbType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateAreaLsdbType.setDescription('The type of the Address Aggregate. This field specifies the Area LSDB type that this Address Aggregate applies to.')
rlOspfv3AreaAggregatePrefixType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 4), InetAddressType())
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefixType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefixType.setDescription('The prefix type of rlOspfv3AreaAggregatePrefix. Only IPv6 addresses are expected.')
rlOspfv3AreaAggregatePrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 5), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 16)))
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefix.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefix.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefix.setDescription('The IPv6 prefix.')
rlOspfv3AreaAggregatePrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 6), InetAddressPrefixLength().subtype(subtypeSpec=ValueRangeConstraint(3, 128))).setUnits('bits')
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefixLength.setReference('OSPF Version 2, Appendix C.2, Area parameters')
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefixLength.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregatePrefixLength.setDescription('The length of the prefix (in bits). A prefix can not be shorter than 3 bits.')
rlOspfv3AreaAggregateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaAggregateRowStatus.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateRowStatus.setDescription('This object permits management of the table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
rlOspfv3AreaAggregateEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("advertiseMatching", 1), ("doNotAdvertiseMatching", 2))).clone('advertiseMatching')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaAggregateEffect.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateEffect.setDescription('Prefixes subsumed by ranges will either trigger the advertisement of the indicated aggregate (advertiseMatching) or result in the prefix not being advertised at all outside the area.')
rlOspfv3AreaAggregateRouteTag = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 13, 1, 9), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlOspfv3AreaAggregateRouteTag.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3AreaAggregateRouteTag.setDescription('This tag is advertised only in the summarized As-External LSA when summarizing from NSSA-LSAs to AS-External-LSAs.')
rlOspfv3VirtLinkLsdbTable = MibTable((1, 3, 6, 1, 4, 1, 89, 216, 14), )
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbTable.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbTable.setDescription("The OSPFv3 Process's Link-scope LSDB for virtual interfaces. The LSDB contains the Link-scope link state advertisements from virtual interfaces.")
rlOspfv3VirtLinkLsdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 216, 14, 1), ).setIndexNames((0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtLinkLsdbProcessId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtLinkLsdbIfAreaId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtLinkLsdbIfNeighbor"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtLinkLsdbType"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtLinkLsdbRouterId"), (0, "RADLAN-OSPFV3-MIB", "rlOspfv3VirtLinkLsdbLsid"))
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbEntry.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbEntry.setDescription('A single Link-scope link state advertisement for a virtual interface.')
rlOspfv3VirtLinkLsdbProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 1), RlOspfProcessID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbProcessId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbProcessId.setDescription('A 32-bit integer uniquely identifying an OSPF process.')
rlOspfv3VirtLinkLsdbIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 2), AreaID())
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbIfAreaId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbIfAreaId.setDescription('The transit area that the virtual link traverses. By definition, this is not Area 0.')
rlOspfv3VirtLinkLsdbIfNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 3), RouterID())
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbIfNeighbor.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbIfNeighbor.setDescription('The Router ID of the virtual neighbor.')
rlOspfv3VirtLinkLsdbType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbType.setDescription('The type of the link state advertisement. Each link state type has a separate advertisement format. Link-scope LSAs unrecognized by the router are also stored in this database.')
rlOspfv3VirtLinkLsdbRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 5), RouterID())
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbRouterId.setReference('OSPF Version 2, Appendix C.1, Global parameters')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbRouterId.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbRouterId.setDescription('The 32-bit number that uniquely identifies the originating router in the Autonomous System.')
rlOspfv3VirtLinkLsdbLsid = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 6), RlLsID())
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbLsid.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbLsid.setDescription('The Link State ID is an LS type-specific field containing a unique identifier; it identifies the piece of the routing domain that is being described by the advertisement. In contrast to OSPFv2, the LSID has no addressing semantics.')
rlOspfv3VirtLinkLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 7), Ospfv3LsaSequenceTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbSequence.setReference('OSPF Version 2, Section 12.1.6, LS sequence number')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbSequence.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbSequence.setDescription('The sequence number field is a signed 32-bit integer. It is used to detect old and duplicate link state advertisements. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
rlOspfv3VirtLinkLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 8), Ospfv3LsaAgeTC()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbAge.setReference('OSPF Version 2, Section 12.1.1, LS age; Extending OSPF to Support Demand Circuits, Section 2.2, The LS age field.')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbAge.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbAge.setDescription('This field is the age of the link state advertisement in seconds. The high-order bit of the LS age field is considered the DoNotAge bit for support of on-demand circuits.')
rlOspfv3VirtLinkLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbChecksum.setReference('OSPF Version 2, Section 12.1.7, LS checksum')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbChecksum.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbChecksum.setDescription("This field is the checksum of the complete contents of the advertisement, excepting the age field. The age field is excepted so that an advertisement's age can be incremented without updating the checksum. The checksum used is the same that is used for ISO connectionless datagrams; it is commonly referred to as the Fletcher checksum.")
rlOspfv3VirtLinkLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbAdvertisement.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbAdvertisement.setDescription('The entire link state advertisement, including its header.')
rlOspfv3VirtLinkLsdbTypeKnown = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 216, 14, 1, 11), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbTypeKnown.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtLinkLsdbTypeKnown.setDescription('The value true (1) indicates that the LSA type is recognized by this router.')
rlOspfv3NotificationEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 216, 15))
rlOspfv3ConfigErrorType = MibScalar((1, 3, 6, 1, 4, 1, 89, 216, 15, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("badVersion", 1), ("areaMismatch", 2), ("unknownNbmaNbr", 3), ("unknownVirtualNbr", 4), ("helloIntervalMismatch", 5), ("deadIntervalMismatch", 6), ("optionMismatch", 7), ("mtuMismatch", 8), ("duplicateRouterId", 9), ("noError", 10)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rlOspfv3ConfigErrorType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3ConfigErrorType.setDescription('Potential types of configuration conflicts. Used by the rlOspfv3ConfigError and rlOspfv3ConfigVirtError notifications.')
rlOspfv3PacketType = MibScalar((1, 3, 6, 1, 4, 1, 89, 216, 15, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("hello", 1), ("dbDescript", 2), ("lsReq", 3), ("lsUpdate", 4), ("lsAck", 5), ("nullPacket", 6)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rlOspfv3PacketType.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3PacketType.setDescription('OSPFv3 packet types.')
rlOspfv3PacketSrc = MibScalar((1, 3, 6, 1, 4, 1, 89, 216, 15, 3), InetAddressIPv6()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: rlOspfv3PacketSrc.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3PacketSrc.setDescription('The IPv6 address of an inbound packet that cannot be identified by a neighbor instance. Only IPv6 addresses without zone index are expected.')
rlOspfv3Notifications = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 216, 16))
rlOspfv3VirtIfStateChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 1)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3VirtIfState"))
if mibBuilder.loadTexts: rlOspfv3VirtIfStateChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfStateChange.setDescription('An rlOspfv3VirtIfStateChange notification signifies that there has been a change in the state of an OSPFv3 virtual interface. This notification should be generated when the interface state regresses (e.g., goes from Point-to-Point to Down) or progresses to a terminal state (i.e., Point-to-Point).')
rlOspfv3NbrStateChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 2)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3NbrState"))
if mibBuilder.loadTexts: rlOspfv3NbrStateChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrStateChange.setDescription('An rlOspfv3NbrStateChange notification signifies that there has been a change in the state of a non-virtual OSPFv3 neighbor. This notification should be generated when the neighbor state regresses (e.g., goes from Attempt or Full to 1-Way or Down) or progresses to a terminal state (e.g., 2-Way or Full). When a neighbor transitions from or to Full on non-broadcast multi-access and broadcast networks, the notification should be generated by the Designated Router. A Designated Router transitioning to Down will be noted by ospfIfStateChange.')
rlOspfv3VirtNbrStateChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 3)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3VirtNbrState"))
if mibBuilder.loadTexts: rlOspfv3VirtNbrStateChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrStateChange.setDescription('An rlOspfv3VirtNbrStateChange notification signifies that there has been a change in the state of an OSPFv3 virtual neighbor. This notification should be generated when the neighbor state regresses (e.g., goes from Attempt or Full to 1-Way or Down) or progresses to a terminal state (e.g., Full).')
rlOspfv3IfConfigError = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 4)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3IfState"), ("RADLAN-OSPFV3-MIB", "rlOspfv3PacketSrc"), ("RADLAN-OSPFV3-MIB", "rlOspfv3ConfigErrorType"), ("RADLAN-OSPFV3-MIB", "rlOspfv3PacketType"))
if mibBuilder.loadTexts: rlOspfv3IfConfigError.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfConfigError.setDescription("An rlOspfv3IfConfigError notification signifies that a packet has been received on a non-virtual interface from a router whose configuration parameters conflict with this router's configuration parameters. Note that the event optionMismatch should cause a notification only if it prevents an adjacency from forming.")
rlOspfv3VirtIfConfigError = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 5)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3VirtIfState"), ("RADLAN-OSPFV3-MIB", "rlOspfv3ConfigErrorType"), ("RADLAN-OSPFV3-MIB", "rlOspfv3PacketType"))
if mibBuilder.loadTexts: rlOspfv3VirtIfConfigError.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfConfigError.setDescription("An rlOspfv3VirtIfConfigError notification signifies that a packet has been received on a virtual interface from a router whose configuration parameters conflict with this router's configuration parameters. Note that the event optionMismatch should cause a notification only if it prevents an adjacency from forming.")
rlOspfv3IfRxBadPacket = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 6)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3IfState"), ("RADLAN-OSPFV3-MIB", "rlOspfv3PacketSrc"), ("RADLAN-OSPFV3-MIB", "rlOspfv3PacketType"))
if mibBuilder.loadTexts: rlOspfv3IfRxBadPacket.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfRxBadPacket.setDescription('An rlOspfv3IfRxBadPacket notification signifies that an OSPFv3 packet that cannot be parsed has been received on a non-virtual interface.')
rlOspfv3VirtIfRxBadPacket = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 7)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3VirtIfState"), ("RADLAN-OSPFV3-MIB", "rlOspfv3PacketType"))
if mibBuilder.loadTexts: rlOspfv3VirtIfRxBadPacket.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtIfRxBadPacket.setDescription('An rlOspfv3VirtIfRxBadPacket notification signifies that an OSPFv3 packet that cannot be parsed has been received on a virtual interface.')
rlOspfv3LsdbOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 8)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3ExtAreaLsdbLimit"))
if mibBuilder.loadTexts: rlOspfv3LsdbOverflow.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LsdbOverflow.setDescription("An rlOspfv3LsdbOverflow notification signifies that the number of LSAs in the router's link state database has exceeded rlOspfv3ExtAreaLsdbLimit.")
rlOspfv3LsdbApproachingOverflow = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 9)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3ExtAreaLsdbLimit"))
if mibBuilder.loadTexts: rlOspfv3LsdbApproachingOverflow.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3LsdbApproachingOverflow.setDescription("An rlOspfv3LsdbApproachingOverflow notification signifies that the number of LSAs in the router's link state database has exceeded ninety percent of rlOspfv3ExtAreaLsdbLimit.")
rlOspfv3IfStateChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 10)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3IfState"))
if mibBuilder.loadTexts: rlOspfv3IfStateChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3IfStateChange.setDescription('An rlOspfv3IfStateChange notification signifies that there has been a change in the state of a non-virtual OSPFv3 interface. This notification should be generated when the interface state regresses (e.g., goes from DR to Down) or progresses to a terminal state (i.e., Point-to-Point, DR Other, DR, or Backup).')
rlOspfv3NssaTranslatorStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 11)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3AreaNssaTranslatorState"))
if mibBuilder.loadTexts: rlOspfv3NssaTranslatorStatusChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NssaTranslatorStatusChange.setDescription("An rlOspfv3NssaTranslatorStatusChange notification indicates that there has been a change in the router's ability to translate OSPFv3 NSSA LSAs into OSPFv3 External LSAs. This notification should be generated when the Translator Status transitions from or to any defined status on a per-area basis.")
rlOspfv3RestartStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 12)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3RestartStatus"), ("RADLAN-OSPFV3-MIB", "rlOspfv3RestartInterval"), ("RADLAN-OSPFV3-MIB", "rlOspfv3RestartExitReason"))
if mibBuilder.loadTexts: rlOspfv3RestartStatusChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3RestartStatusChange.setDescription('An rlOspfv3RestartStatusChange notification signifies that there has been a change in the graceful restart state for the router. This notification should be generated when the router restart status changes.')
rlOspfv3NbrRestartHelperStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 13)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3NbrRestartHelperStatus"), ("RADLAN-OSPFV3-MIB", "rlOspfv3NbrRestartHelperAge"), ("RADLAN-OSPFV3-MIB", "rlOspfv3NbrRestartHelperExitReason"))
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperStatusChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3NbrRestartHelperStatusChange.setDescription('An rlOspfv3NbrRestartHelperStatusChange notification signifies that there has been a change in the graceful restart helper state for the neighbor. This notification should be generated when the neighbor restart helper status transitions for a neighbor.')
rlOspfv3VirtNbrRestartHelperStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 89, 216, 16, 14)).setObjects(("RADLAN-OSPFV3-MIB", "rlOspfv3RouterId"), ("RADLAN-OSPFV3-MIB", "rlOspfv3VirtNbrRestartHelperStatus"), ("RADLAN-OSPFV3-MIB", "rlOspfv3VirtNbrRestartHelperAge"), ("RADLAN-OSPFV3-MIB", "rlOspfv3VirtNbrRestartHelperExitReason"))
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperStatusChange.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3VirtNbrRestartHelperStatusChange.setDescription('An rlOspfv3VirtNbrRestartHelperStatusChange notification signifies that there has been a change in the graceful restart helper state for the virtual neighbor. This notification should be generated when the virtual neighbor restart helper status transitions for a virtual neighbor.')
rlOspfv3EnableNotificationsOspfEvents = MibScalar((1, 3, 6, 1, 4, 1, 89, 216, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3EnableNotificationsOspfEvents.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3EnableNotificationsOspfEvents.setDescription('A bit mask indicating enable SNMP notifications for OSPF errors. Bit 0, if set, for authenticationFailure trap. enables only the ospfIfFailure trap. Allows SNMP notifications to be sent when a packet has been received on a nonvirtual interface from a neighbor router whose authentication key or authentication type conflicts with the authentication key or authentication type of this router. Bit 1, if set, for badPacket trap. enables only the ospfIfRxBadPacket trap. Allows SNMP notifications to be sent when an OSPF packet that has not been parsed has been received on a nonvirtual interface. Bit 2, if set, for configError trap. enables only the ospfIfConfigError trap. Sends SNMP notifications when a packet has been received in a nonvirtual interface from a neighbor router whose configuration parameters conflict with the configuration parameters of this router. Bit 3, if set, for virtAuthenticationFailure trap. enables only the ospfVirtIfFailure trap. Allows SNMP notifications to be sent when a packet has been received on a virtual interface from a neighbor router whose authentication key or authentication type conflicts with the authentication key or authentication type of this router. Bit 4, if set, for virtBadPacket trap. enables only the ospfVirtIfRxBadPacket trap. Allows SNMP notifications to be sent when an OSPF packet that has not been parsed has been received on a virtual interface. Bit 5, if set, for virtConfigError trap. enables only the ospfVirtIfConfigError trap. Sends SNMP notifications when a packet has been received in a virtual interface from a neighbor router whose configuration parameters conflict with the configuration parameters of this router.')
rlOspfv3EnableNotificationsOspfRateLimitSeconds = MibScalar((1, 3, 6, 1, 4, 1, 89, 216, 18), Integer32().clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3EnableNotificationsOspfRateLimitSeconds.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3EnableNotificationsOspfRateLimitSeconds.setDescription('Sets the rate limit window size, in seconds. A number from 2 to 60. The default value is 10.')
rlOspfv3EnableNotificationsOspfRateLimitTrapNumber = MibScalar((1, 3, 6, 1, 4, 1, 89, 216, 19), Integer32().clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlOspfv3EnableNotificationsOspfRateLimitTrapNumber.setStatus('current')
if mibBuilder.loadTexts: rlOspfv3EnableNotificationsOspfRateLimitTrapNumber.setDescription('Sets the maximum number of traps sent during the window time. A number from 0 to 300. The default number is 7.')
mibBuilder.exportSymbols("RADLAN-OSPFV3-MIB", rlOspfv3VirtNbrEntry=rlOspfv3VirtNbrEntry, rlOspfv3VirtIfAdminStatus=rlOspfv3VirtIfAdminStatus, rlOspfv3RestartInterval=rlOspfv3RestartInterval, rlOspfv3MaximumRedistPrefixNum=rlOspfv3MaximumRedistPrefixNum, rlOspfv3VersionNumber=rlOspfv3VersionNumber, rlOspfv3AreaNssaTranslatorEvents=rlOspfv3AreaNssaTranslatorEvents, rlOspfv3IfDemandNbrProbe=rlOspfv3IfDemandNbrProbe, rlOspfv3LinkLsdbIfIndex=rlOspfv3LinkLsdbIfIndex, rlOspfv3AreaLsdbLsid=rlOspfv3AreaLsdbLsid, rlOspfv3NextRouterId=rlOspfv3NextRouterId, rlOspfv3AsLsdbAge=rlOspfv3AsLsdbAge, rlOspfv3VirtNbrIfInstId=rlOspfv3VirtNbrIfInstId, rlOspfv3VirtLinkLsdbEntry=rlOspfv3VirtLinkLsdbEntry, rlOspfv3AreaLsdbAreaId=rlOspfv3AreaLsdbAreaId, rlOspfv3RxNewLsas=rlOspfv3RxNewLsas, rlOspfv3CfgNbrIfIndex=rlOspfv3CfgNbrIfIndex, rlOspfv3AreaScopeLsaCount=rlOspfv3AreaScopeLsaCount, rlOspfv3LinkLsdbChecksum=rlOspfv3LinkLsdbChecksum, rlOspfv3LinkLsdbIfInstId=rlOspfv3LinkLsdbIfInstId, rlOspfv3IfState=rlOspfv3IfState, rlOspfv3RestartStrictLsaChecking=rlOspfv3RestartStrictLsaChecking, rlOspfv3AreaOperStatus=rlOspfv3AreaOperStatus, rlOspfv3NssaTranslatorStatusChange=rlOspfv3NssaTranslatorStatusChange, rlOspfv3AreaLsdbAge=rlOspfv3AreaLsdbAge, rlOspfv3NbrIfId=rlOspfv3NbrIfId, rlOspfv3AsScopeLsaCksumSum=rlOspfv3AsScopeLsaCksumSum, rlOspfv3AreaLsdbAdvertisement=rlOspfv3AreaLsdbAdvertisement, rlOspfv3AreaAggregatePrefix=rlOspfv3AreaAggregatePrefix, rlOspfv3VirtLinkLsdbProcessId=rlOspfv3VirtLinkLsdbProcessId, rlOspfv3IfFastHelloMultiplier=rlOspfv3IfFastHelloMultiplier, rlOspfv3VirtLinkLsdbChecksum=rlOspfv3VirtLinkLsdbChecksum, rlOspfv3NbrIfIndex=rlOspfv3NbrIfIndex, rlOspfv3IfLinkLSASuppression=rlOspfv3IfLinkLSASuppression, rlOspfv3RestartExitReason=rlOspfv3RestartExitReason, rlOspfv3IfTEDisabled=rlOspfv3IfTEDisabled, PYSNMP_MODULE_ID=rlOspfv3, rlOspfv3AreaLsdbTypeKnown=rlOspfv3AreaLsdbTypeKnown, rlOspfv3VirtIfNeighbor=rlOspfv3VirtIfNeighbor, rlOspfv3RowStatus=rlOspfv3RowStatus, rlOspfv3NbrStateChange=rlOspfv3NbrStateChange, rlOspfv3VirtIfTable=rlOspfv3VirtIfTable, rlOspfv3ExtLsaCount=rlOspfv3ExtLsaCount, rlOspfv3NotificationEntry=rlOspfv3NotificationEntry, rlOspfv3VirtIfLinkScopeLsaCount=rlOspfv3VirtIfLinkScopeLsaCount, rlOspfv3CfgNbrIfInstId=rlOspfv3CfgNbrIfInstId, rlOspfv3MaximumRedistPrefixWarningOnly=rlOspfv3MaximumRedistPrefixWarningOnly, rlOspfv3IfDemand=rlOspfv3IfDemand, rlOspfv3VirtIfRetransInterval=rlOspfv3VirtIfRetransInterval, rlOspfv3VirtLinkLsdbSequence=rlOspfv3VirtLinkLsdbSequence, rlOspfv3IfLsaRefreshIntvl=rlOspfv3IfLsaRefreshIntvl, rlOspfv3AdminStatus=rlOspfv3AdminStatus, rlOspfv3NbrDeadTime=rlOspfv3NbrDeadTime, rlOspfv3HostTable=rlOspfv3HostTable, rlOspfv3LinkLsdbSequence=rlOspfv3LinkLsdbSequence, rlOspfv3VirtNbrState=rlOspfv3VirtNbrState, rlOspfv3VirtNbrRestartHelperExitReason=rlOspfv3VirtNbrRestartHelperExitReason, rlOspfv3AreaNssaTranslatorState=rlOspfv3AreaNssaTranslatorState, RlRouterID=RlRouterID, rlOspfv3IfOperStatus=rlOspfv3IfOperStatus, rlOspfv3VirtIfOperStatus=rlOspfv3VirtIfOperStatus, rlOspfv3HostMetric=rlOspfv3HostMetric, rlOspfv3IfRtrDeadInterval=rlOspfv3IfRtrDeadInterval, rlOspfv3LsdbApproachingOverflow=rlOspfv3LsdbApproachingOverflow, rlOspfv3StubRouterSupport=rlOspfv3StubRouterSupport, rlOspfv3HostAreaID=rlOspfv3HostAreaID, rlOspfv3AreaTEEnabled=rlOspfv3AreaTEEnabled, rlOspfv3AreaAsBdrRtrCount=rlOspfv3AreaAsBdrRtrCount, rlOspfv3IfLinkLsaCksumSum=rlOspfv3IfLinkLsaCksumSum, rlOspfv3NbrIfInstId=rlOspfv3NbrIfInstId, rlOspfv3VirtLinkLsdbIfNeighbor=rlOspfv3VirtLinkLsdbIfNeighbor, rlOspfv3HostEntry=rlOspfv3HostEntry, rlOspfv3AreaAggregateAreaLsdbType=rlOspfv3AreaAggregateAreaLsdbType, RlOspfv3FastHelloMultiplierRange=RlOspfv3FastHelloMultiplierRange, rlOspfv3VirtLinkLsdbLsid=rlOspfv3VirtLinkLsdbLsid, rlOspfv3CfgNbrRowStatus=rlOspfv3CfgNbrRowStatus, rlOspfv3AsLsdbProcessId=rlOspfv3AsLsdbProcessId, rlOspfv3VirtNbrRtrId=rlOspfv3VirtNbrRtrId, rlOspfv3VirtIfIndex=rlOspfv3VirtIfIndex, rlOspfv3AsLsdbTable=rlOspfv3AsLsdbTable, rlOspfv3IfDesignatedRouter=rlOspfv3IfDesignatedRouter, rlOspfv3NbrEntry=rlOspfv3NbrEntry, rlOspfv3AreaLsdbEntry=rlOspfv3AreaLsdbEntry, rlOspfv3AsLsdbType=rlOspfv3AsLsdbType, rlOspfv3ASBdrRtrStatus=rlOspfv3ASBdrRtrStatus, rlOspfv3NotificationEnable=rlOspfv3NotificationEnable, rlOspfv3AreaAggregateAreaID=rlOspfv3AreaAggregateAreaID, rlOspfv3AreaFilterPrefixListOut=rlOspfv3AreaFilterPrefixListOut, rlOspfv3NbrAreaId=rlOspfv3NbrAreaId, rlOspfv3AreaBdrRtrCount=rlOspfv3AreaBdrRtrCount, rlOspfv3AsLsdbAdvertisement=rlOspfv3AsLsdbAdvertisement, rlOspfv3HostAddressType=rlOspfv3HostAddressType, rlOspfv3IfLinkScopeLsaCount=rlOspfv3IfLinkScopeLsaCount, rlOspfv3GeneralGroupEntry=rlOspfv3GeneralGroupEntry, rlOspfv3IfMtuIgnore=rlOspfv3IfMtuIgnore, rlOspfv3PassiveInterface=rlOspfv3PassiveInterface, rlOspfv3VirtNbrHelloSuppressed=rlOspfv3VirtNbrHelloSuppressed, rlOspfv3PacketType=rlOspfv3PacketType, rlOspfv3IfPollInterval=rlOspfv3IfPollInterval, rlOspfv3LsdbOverflow=rlOspfv3LsdbOverflow, rlOspfv3IfType=rlOspfv3IfType, rlOspfv3NbrState=rlOspfv3NbrState, rlOspfv3AsLsdbLsid=rlOspfv3AsLsdbLsid, rlOspfv3LinkLsdbAdvertisement=rlOspfv3LinkLsdbAdvertisement, rlOspfv3VirtNbrArea=rlOspfv3VirtNbrArea, rlOspfv3NbrTable=rlOspfv3NbrTable, rlOspfv3Instance=rlOspfv3Instance, rlOspfv3LinkLsdbProcessId=rlOspfv3LinkLsdbProcessId, rlOspfv3IfRtrPriority=rlOspfv3IfRtrPriority, rlOspfv3IfBackupDesignatedRouter=rlOspfv3IfBackupDesignatedRouter, rlOspfv3RestartAge=rlOspfv3RestartAge, rlOspfv3VirtNbrAddressType=rlOspfv3VirtNbrAddressType, rlOspfv3AreaAggregateRouteTag=rlOspfv3AreaAggregateRouteTag, rlOspfv3AreaAdminStat=rlOspfv3AreaAdminStat, rlOspfv3RestartStatus=rlOspfv3RestartStatus, rlOspfv3IfRowStatus=rlOspfv3IfRowStatus, rlOspfv3LogAdjacencyChanges=rlOspfv3LogAdjacencyChanges, rlOspfv3AsScopeLsaCount=rlOspfv3AsScopeLsaCount, rlOspfv3VirtIfAreaId=rlOspfv3VirtIfAreaId, rlOspfv3EnableNotificationsOspfRateLimitTrapNumber=rlOspfv3EnableNotificationsOspfRateLimitTrapNumber, rlOspfv3VirtNbrOptions=rlOspfv3VirtNbrOptions, rlOspfv3IfTransitDelay=rlOspfv3IfTransitDelay, rlOspfv3VirtNbrRestartHelperStatusChange=rlOspfv3VirtNbrRestartHelperStatusChange, rlOspfv3HostAddress=rlOspfv3HostAddress, rlOspfv3IfHelloInterval=rlOspfv3IfHelloInterval, rlOspfv3VirtIfStateChange=rlOspfv3VirtIfStateChange, rlOspfv3AreaStubMetricType=rlOspfv3AreaStubMetricType, rlOspfv3Notifications=rlOspfv3Notifications, rlOspfv3AreaAggregateRowStatus=rlOspfv3AreaAggregateRowStatus, rlOspfv3HostProcessId=rlOspfv3HostProcessId, rlOspfv3AreaEntry=rlOspfv3AreaEntry, rlOspfv3AreaSummary=rlOspfv3AreaSummary, rlOspfv3VirtNbrLsRetransQLen=rlOspfv3VirtNbrLsRetransQLen, rlOspfv3HostRowStatus=rlOspfv3HostRowStatus, rlOspfv3GeneralGroupTable=rlOspfv3GeneralGroupTable, rlOspfv3MaximumRedistPrefixThreshold=rlOspfv3MaximumRedistPrefixThreshold, rlOspfv3AreaFilterPrefixListIn=rlOspfv3AreaFilterPrefixListIn, rlOspfv3IfStateChange=rlOspfv3IfStateChange, rlOspfv3NbrProcessId=rlOspfv3NbrProcessId, rlOspfv3AreaAggregateTable=rlOspfv3AreaAggregateTable, rlOspfv3IfEntry=rlOspfv3IfEntry, rlOspfv3IfEvents=rlOspfv3IfEvents, rlOspfv3VirtLinkLsdbAge=rlOspfv3VirtLinkLsdbAge, RlLsID=RlLsID, rlOspfv3IfAreaId=rlOspfv3IfAreaId, rlOspfv3IfNameLookup=rlOspfv3IfNameLookup, RlOspfv3UpToRefreshIntervalTC=RlOspfv3UpToRefreshIntervalTC, rlOspfv3VirtNbrTable=rlOspfv3VirtNbrTable, rlOspfv3IfIndex=rlOspfv3IfIndex, rlOspfv3PacketSrc=rlOspfv3PacketSrc, rlOspfv3VirtNbrAddress=rlOspfv3VirtNbrAddress, rlOspfv3AsLsdbEntry=rlOspfv3AsLsdbEntry, rlOspfv3AsLsdbChecksum=rlOspfv3AsLsdbChecksum, rlOspfv3CfgNbrAddress=rlOspfv3CfgNbrAddress, rlOspfv3VirtIfEvents=rlOspfv3VirtIfEvents, rlOspf3CfgNbrProcessId=rlOspf3CfgNbrProcessId, rlOspfv3AreaAggregateProcessId=rlOspfv3AreaAggregateProcessId, rlOspfv3AreaImportAsExtern=rlOspfv3AreaImportAsExtern, rlOspfv3AreaNssaTranslatorStabInterval=rlOspfv3AreaNssaTranslatorStabInterval, rlOspfv3NbrHelloSuppressed=rlOspfv3NbrHelloSuppressed, rlOspfv3VirtIfConfigError=rlOspfv3VirtIfConfigError, rlOspfv3NbrAddress=rlOspfv3NbrAddress, rlOspfv3RestartStatusChange=rlOspfv3RestartStatusChange, rlOspfv3IfAdminStatus=rlOspfv3IfAdminStatus, rlOspfv3IfRetransInterval=rlOspfv3IfRetransInterval, rlOspfv3VirtIfRtrDeadInterval=rlOspfv3VirtIfRtrDeadInterval, rlOspfv3VirtNbrRestartHelperStatus=rlOspfv3VirtNbrRestartHelperStatus, rlOspfv3ExitOverflowInterval=rlOspfv3ExitOverflowInterval, rlOspfv3NbrRestartHelperExitReason=rlOspfv3NbrRestartHelperExitReason, rlOspfv3NbrOptions=rlOspfv3NbrOptions, rlOspfv3VirtNbrStateChange=rlOspfv3VirtNbrStateChange, rlOspfv3ProcessId=rlOspfv3ProcessId, rlOspfv3RteMaxEqCostPaths=rlOspfv3RteMaxEqCostPaths, rlOspfv3CfgNbrAddressType=rlOspfv3CfgNbrAddressType, rlOspfv3ConfigErrorType=rlOspfv3ConfigErrorType, rlOspfv3IfRxBadPacket=rlOspfv3IfRxBadPacket, rlOspfv3VirtLinkLsdbAdvertisement=rlOspfv3VirtLinkLsdbAdvertisement, rlOspfv3VirtLinkLsdbTypeKnown=rlOspfv3VirtLinkLsdbTypeKnown, rlOspfv3=rlOspfv3, RlOspfv3UpToRefreshInterval=RlOspfv3UpToRefreshInterval, RlOspfv3RestartExitReason=RlOspfv3RestartExitReason, rlOspfv3NbrRtrId=rlOspfv3NbrRtrId, rlOspfv3OperStatus=rlOspfv3OperStatus, rlOspfv3AreaNssaTranslatorRole=rlOspfv3AreaNssaTranslatorRole, rlOspfv3ASBdrRtrActualStatus=rlOspfv3ASBdrRtrActualStatus, rlOspfv3AsLsdbTypeKnown=rlOspfv3AsLsdbTypeKnown, rlOspfv3CfgNbrTable=rlOspfv3CfgNbrTable, rlOspfv3LinkLsdbRouterId=rlOspfv3LinkLsdbRouterId, rlOspfv3AreaProcessId=rlOspfv3AreaProcessId, rlOspfv3DemandExtensions=rlOspfv3DemandExtensions, rlOspfv3AsLsdbSequence=rlOspfv3AsLsdbSequence, rlOspfv3AreaLsdbProcessId=rlOspfv3AreaLsdbProcessId, rlOspfv3VirtIfEntry=rlOspfv3VirtIfEntry, rlOspfv3NbrPriority=rlOspfv3NbrPriority, rlOspfv3VirtLinkLsdbType=rlOspfv3VirtLinkLsdbType, rlOspfv3StubRouterAdvertisement=rlOspfv3StubRouterAdvertisement, rlOspfv3AreaTable=rlOspfv3AreaTable, rlOspfv3VirtIfLinkLsaCksumSum=rlOspfv3VirtIfLinkLsaCksumSum, rlOspfv3LinkLsdbTable=rlOspfv3LinkLsdbTable, rlOspfv3OriginateNewLsas=rlOspfv3OriginateNewLsas, rlOspfv3CalcMaxDelay=rlOspfv3CalcMaxDelay, rlOspfv3AreaRowStatus=rlOspfv3AreaRowStatus, rlOspfv3VirtIfTransitDelay=rlOspfv3VirtIfTransitDelay, rlOspfv3AreaAggregatePrefixLength=rlOspfv3AreaAggregatePrefixLength, rlOspfv3ReferenceBandwidth=rlOspfv3ReferenceBandwidth, rlOspfv3IfMetricValue=rlOspfv3IfMetricValue, rlOspfv3NextRouterIdType=rlOspfv3NextRouterIdType, rlOspfv3VirtIfProcessId=rlOspfv3VirtIfProcessId, rlOspfv3VirtIfRowStatus=rlOspfv3VirtIfRowStatus, rlOspfv3CfgNbrPriority=rlOspfv3CfgNbrPriority, rlOspfv3AreaAggregatePrefixType=rlOspfv3AreaAggregatePrefixType, rlOspfv3IfDemandNbrProbeInterval=rlOspfv3IfDemandNbrProbeInterval, rlOspfv3VirtLinkLsdbTable=rlOspfv3VirtLinkLsdbTable, rlOspfv3EnableNotificationsOspfEvents=rlOspfv3EnableNotificationsOspfEvents, rlOspfv3NbrRestartHelperStatusChange=rlOspfv3NbrRestartHelperStatusChange, rlOspfv3AreaLsdbTable=rlOspfv3AreaLsdbTable, rlOspfv3NbrRestartHelperAge=rlOspfv3NbrRestartHelperAge, rlOspfv3AreaLsdbType=rlOspfv3AreaLsdbType, rlOspfv3ExtAreaLsdbLimit=rlOspfv3ExtAreaLsdbLimit, rlOspfv3IfInstId=rlOspfv3IfInstId, rlOspfv3NbrAddressType=rlOspfv3NbrAddressType, rlOspfv3RouterIdType=rlOspfv3RouterIdType, rlOspfv3AsLsdbRouterId=rlOspfv3AsLsdbRouterId, rlOspfv3RestartTime=rlOspfv3RestartTime, rlOspfv3DefaultMetric=rlOspfv3DefaultMetric, rlOspfv3VirtNbrDeadTime=rlOspfv3VirtNbrDeadTime, rlOspfv3AreaBdrRtrStatus=rlOspfv3AreaBdrRtrStatus, rlOspfv3LinkLsdbLsid=rlOspfv3LinkLsdbLsid, rlOspfv3LinkLsdbType=rlOspfv3LinkLsdbType, rlOspfv3IfPassive=rlOspfv3IfPassive, rlOspfv3LinkLsdbEntry=rlOspfv3LinkLsdbEntry, rlOspfv3VirtNbrIfIndex=rlOspfv3VirtNbrIfIndex, rlOspfv3AreaLsdbRouterId=rlOspfv3AreaLsdbRouterId, rlOspfv3LinkLsdbAge=rlOspfv3LinkLsdbAge, rlOspfv3IfConfigError=rlOspfv3IfConfigError, rlOspfv3RestartSupport=rlOspfv3RestartSupport, rlOspfv3IfTable=rlOspfv3IfTable, rlOspfv3AreaId=rlOspfv3AreaId, rlOspfv3IfDemandNbrProbeRetransLimit=rlOspfv3IfDemandNbrProbeRetransLimit, rlOspfv3AreaAggregateEntry=rlOspfv3AreaAggregateEntry, rlOspfv3AreaScopeLsaCksumSum=rlOspfv3AreaScopeLsaCksumSum, rlOspfv3VirtNbrIfId=rlOspfv3VirtNbrIfId, rlOspfv3VirtLinkLsdbRouterId=rlOspfv3VirtLinkLsdbRouterId, rlOspfv3NbrEvents=rlOspfv3NbrEvents, rlOspfv3VirtIfInstId=rlOspfv3VirtIfInstId, rlOspfv3VirtIfHelloInterval=rlOspfv3VirtIfHelloInterval, rlOspfv3AreaLsdbChecksum=rlOspfv3AreaLsdbChecksum, rlOspfv3RouterId=rlOspfv3RouterId, rlOspfv3VirtNbrEvents=rlOspfv3VirtNbrEvents, rlOspfv3VirtNbrRestartHelperAge=rlOspfv3VirtNbrRestartHelperAge, rlOspfv3DiscontinuityTime=rlOspfv3DiscontinuityTime, rlOspfv3NbrLsRetransQLen=rlOspfv3NbrLsRetransQLen, rlOspfv3AreaLsdbSequence=rlOspfv3AreaLsdbSequence, rlOspfv3VirtIfState=rlOspfv3VirtIfState, rlOspfv3AreaAggregateEffect=rlOspfv3AreaAggregateEffect)
mibBuilder.exportSymbols("RADLAN-OSPFV3-MIB", rlOspfv3LinkLsdbTypeKnown=rlOspfv3LinkLsdbTypeKnown, rlOspfv3EnableNotificationsOspfRateLimitSeconds=rlOspfv3EnableNotificationsOspfRateLimitSeconds, rlOspfv3IfProcessId=rlOspfv3IfProcessId, rlOspfv3AreaSpfRuns=rlOspfv3AreaSpfRuns, rlOspfv3CfgNbrEntry=rlOspfv3CfgNbrEntry, rlOspfv3NbrRestartHelperStatus=rlOspfv3NbrRestartHelperStatus, rlOspfv3VirtLinkLsdbIfAreaId=rlOspfv3VirtLinkLsdbIfAreaId, rlOspfv3AreaStubMetric=rlOspfv3AreaStubMetric, RlOspfv3RestartHelperStatus=RlOspfv3RestartHelperStatus, rlOspfv3VirtNbrProcessId=rlOspfv3VirtNbrProcessId, rlOspfv3VirtIfRxBadPacket=rlOspfv3VirtIfRxBadPacket)

#
# PySNMP MIB module STARTEK-PRIVATE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/STARTEK-PRIVATE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:11:01 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter64, ObjectIdentity, Counter32, NotificationType, Integer32, Bits, enterprises, Opaque, ModuleIdentity, MibIdentifier, Unsigned32, iso, IpAddress, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter64", "ObjectIdentity", "Counter32", "NotificationType", "Integer32", "Bits", "enterprises", "Opaque", "ModuleIdentity", "MibIdentifier", "Unsigned32", "iso", "IpAddress", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
startek = MibIdentifier((1, 3, 6, 1, 4, 1, 260))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1))
maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 2))
fSeries = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2))
stackable = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 3))
m828Series = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 1))
m828Hubs = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 1, 1))
m828HubNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubNumber.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubNumber.setDescription('The number of items in hub table.')
m828HubTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2), )
if mibBuilder.loadTexts: m828HubTable.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubTable.setDescription('A table which maintains a list of all of the intelligent m828 series hubs on the ring being managed by the addressed agent. This table is indexed by the RS485 OOB address of the m828 series intelligent hubs.')
m828HubTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "m828HubTableIndex"))
if mibBuilder.loadTexts: m828HubTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubTableEntry.setDescription('An entry in the m828HubTable.')
m828HubTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubTableIndex.setDescription('The index for this hub entry.')
m828HubModel = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("model-4", 1), ("model-5", 2), ("model-6", 3), ("model-7", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubModel.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubModel.setDescription('The model number of the m828 series hub being managed.')
m828Hub485Address = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828Hub485Address.setStatus('mandatory')
if mibBuilder.loadTexts: m828Hub485Address.setDescription('The 4 hex digit address used on the RS485 serial OOB management channel.')
m828HubRiFTolSw = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRiFTolSw.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRiFTolSw.setDescription('The status of the Ring In fault tolerance switch on the front panel of the hub.')
m828HubRiFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: m828HubRiFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRiFTolState.setDescription('This parameter controls the Ring In (RI) fault tolerance behavior. The default value for this parameter is the same setting as is present for m828HubRiFTolSw. SETTING this parameter overrides the value derived from m828HubRiFTolSw. Off(1) means that phantom currentis not used on the corresponding RI interface as a condition for main ring link insertion. On (2) means that phantom current is used on the corresponding RI interface as a condition for main ring link insertion. The preffered setting for this parameter is on (2).')
m828HubRiMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: m828HubRiMask.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRiMask.setDescription('Administrative status for this Ring In port. By setting this parameter, a remote manager can control the partitioning of this port.')
m828HubRiPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRiPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRiPhDet.setDescription('This parameter describes the phantom detect status for this Ring In port.')
m828HubRiNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRiNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRiNsrtStatus.setDescription('Insertion status for this Ring In port.')
m828HubRiBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRiBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRiBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
m828RiNeighborType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("series828", 1), ("fSeries", 2), ("tokenRingMAC", 3), ("none", 4), ("stackable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828RiNeighborType.setStatus('mandatory')
if mibBuilder.loadTexts: m828RiNeighborType.setDescription('This parameter indicates the type of nearest neighbor on the Ring In port.')
m828RiNeighborAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828RiNeighborAddr.setStatus('mandatory')
if mibBuilder.loadTexts: m828RiNeighborAddr.setDescription('The address of the nearest neighbor on the Ring In port.')
m828RiTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 12), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828RiTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: m828RiTimeStamp.setDescription('The time the status of Ring In (was) last changed.')
m828HubRoFTolSw = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRoFTolSw.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRoFTolSw.setDescription('The state of the Ring Out Fault Tolerance switch on the front panel of the unit.')
m828HubRoFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: m828HubRoFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRoFTolState.setDescription('This parameter controls the Ring Out(RO) fault tolerance behavior. The default value for this parameter is the same setting as is present for m828HubRoFTolSw. SETTING this parameter overrides the value derived from m828HubRoFTolSw. Off(1) means that phantom currentis not used on the corresponding RO interface as a condition for main ring link insertion. On (2) means that phantom current is used on the corresponding RO interface as a condition for main ring link insertion. The preffered setting for this parameter is on (2).')
m828HubRoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: m828HubRoMask.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRoMask.setDescription('Administrative status for this Ring Out port. By setting this parameter, a remote manager can control the partitioning of this port.')
m828HubRoPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wireFault", 1), ("phantOk", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRoPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRoPhDet.setDescription('This parameter describes the phantom detect status for this Ring Out port.')
m828HubRoNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRoNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRoNsrtStatus.setDescription('Insertion status for this Ring Out port.')
m828HubRoBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubRoBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRoBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
m828RoNeighborType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("series828", 1), ("fSeries", 2), ("tokenRingMAC", 3), ("none", 4), ("stackable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828RoNeighborType.setStatus('mandatory')
if mibBuilder.loadTexts: m828RoNeighborType.setDescription('This parameter indicates the type of nearest neighbor on the Ring Out port.')
m828RoNeighborAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 20), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828RoNeighborAddr.setStatus('mandatory')
if mibBuilder.loadTexts: m828RoNeighborAddr.setDescription('The address of the nearest neighbor on the Ring Out port.')
m828RoTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 21), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828RoTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: m828RoTimeStamp.setDescription('The time the status of Ring Out (was) last changed.')
m828HubDataRateSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("s4Mbps", 1), ("s16Mbps", 2), ("noSwitch", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubDataRateSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubDataRateSwitch.setDescription('Setting of this parameter changes the data rate of this unit. A value of noSwitch(3) indicates that the setting of the data rate is not available on this unit.')
m828HubDataRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("s4Mbps", 1), ("s16Mbps", 2), ("autoConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: m828HubDataRateState.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubDataRateState.setDescription('This parameter indicates the current data rate of this unit.')
m828HubDataRateTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 24), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubDataRateTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubDataRateTimeStamp.setDescription('The time the data rate status (was) last changed.')
m828HubMgmtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operational", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubMgmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubMgmtStatus.setDescription('The operational status of this unit.')
m828HubProxyAgentID = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 26), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubProxyAgentID.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubProxyAgentID.setDescription('The physical layer MAC Address of the agent.')
m828HubCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubCodeVersion.setDescription('The firmware version number of this unit.')
m828HubRawCommandData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 2, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: m828HubRawCommandData.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubRawCommandData.setDescription('This is used to send raw 485 serial data to this unit.')
m828HubLobeNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubLobeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeNumber.setDescription('The number of items in the hub lobe table.')
m828HubLobeTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4), )
if mibBuilder.loadTexts: m828HubLobeTable.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeTable.setDescription('A table which contains the control and status information for the lobes.')
m828HubLobeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "m828HubIndex"), (0, "STARTEK-PRIVATE-MIB", "m828HubLobePort"))
if mibBuilder.loadTexts: m828HubLobeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeEntry.setDescription('A collection of control and status parameters kept for each lobe.')
m828HubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubIndex.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubIndex.setDescription('The index into the m828HubTable of the mau this lobe is on.')
m828HubLobePort = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubLobePort.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobePort.setDescription('The port of the mau this lobe is on.')
m828HubLobePhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubLobePhDet.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobePhDet.setDescription('Phantom current status for this lobe port. A value of 1 corresponds to no phantom current detected. A value of 2 corresponds to phantom presence.')
m828HubLobeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolated", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: m828HubLobeMask.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeMask.setDescription('Administrative status for this lobe port. By setting this parameter, a remote manager can control access to the lobe port.')
m828HubLobeNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubLobeNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeNsrtStatus.setDescription('Actual insertion status for this lobe port. A 1 value means that the corresponding station is not connected to the ring. A 2 value means that the corresponding station is connected to the ring.')
m828HubLobeMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubLobeMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeMacAddr.setDescription('The MAC layer address of the station which is attached to the corresponding lobe port.')
m828HubLobeBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubLobeBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
m828HubLobeTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 1, 1, 4, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: m828HubLobeTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: m828HubLobeTimeStamp.setDescription('The time the status of this lobe (was) last changed.')
fChassis = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2, 1))
fTRMainRing = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2, 2))
fTRLobe = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2, 3))
fEthernet = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2, 4))
fFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2, 5))
fTwx = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2, 6))
fChassisNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fChassisNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fChassisNumber.setDescription('The number of chassis in table')
fChassisTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 1, 2), )
if mibBuilder.loadTexts: fChassisTable.setStatus('mandatory')
if mibBuilder.loadTexts: fChassisTable.setDescription('A table which describes which modules are plugged into which slots of the chassis.')
fChassisTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 1, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "fChassisIndex"))
if mibBuilder.loadTexts: fChassisTableEntry.setStatus('mandatory')
fChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fChassisIndex.setDescription('Index of this entry')
fChassisModel = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("twoslot-10100", 1), ("fiveslot-10101", 2), ("fiveslotredundant-10102", 3), ("reserved4", 4), ("reserved5", 5), ("reserved6", 6), ("reserved7", 7), ("reserved8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fChassisModel.setStatus('mandatory')
if mibBuilder.loadTexts: fChassisModel.setDescription('The model number of the f series chassis in which the addressed management agent is installed.')
fChassisPowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singleSupOK", 1), ("dualSupOK", 2), ("dualSup-BSupBAD", 3), ("dualSup-ASupBAD", 4), ("illegal", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fChassisPowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fChassisPowStatus.setDescription('The status of the power supply or supplies in the chassis.')
fChassisLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("external", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fChassisLocation.setStatus('mandatory')
if mibBuilder.loadTexts: fChassisLocation.setDescription('The location of the chassis.')
fTRMainRingNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingNumber.setDescription('The number of the ring.')
fTRMainRingTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2), )
if mibBuilder.loadTexts: fTRMainRingTable.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingTable.setDescription('A table which maintains a list of all of the intelligent Focus series hubs on the ring being managed by the addressed agent. This table is INDEXed by the RS485 OOB address of the Focus series intelligent hubs.')
fTRMainRingTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "fTRMainRingTableIndex"))
if mibBuilder.loadTexts: fTRMainRingTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingTableEntry.setDescription('An entry in the fTRMainRingTable')
fTRMainRingTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingTableIndex.setDescription('The index for this ring entry.')
fTRMainRingModel = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("f10154RiRoExpModule", 1), ("f10155RiRoFiberExpModule", 2), ("f10150RiRoExpModuleAgent", 3), ("f10151RiRoFiberExpModuleAgent", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingModel.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingModel.setDescription('The model number of the Focus series hub being managed.')
fTRMainRing485Address = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRing485Address.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRing485Address.setDescription('The 6 hex digit address used on the RS485 serial OOB management channel.')
fTRMainRingSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingSlotIndex.setDescription('The slot id.')
fTRMainRingChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingChassisIndex.setDescription('The index of the chassis the card is in.')
fTRMainRingRiFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingRiFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiFTolState.setDescription('This parameter controls the Ring In (RI) fault tolerance behavior. Off(1) means that phantom current is not used on the corresponding RI interface as a condition for main ring link insertion. On (2) means that phantom current is used on the corresponding RI interface as a condition for main ring link insertion. The preferred setting for this parameter is on (2).')
fTRMainRingRiMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingRiMask.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiMask.setDescription('Administrative status for this Ring In port. By setting this parameter, a remote manager can control the partitioning of this port.')
fTRMainRingRiPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRiPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiPhDet.setDescription('This parameter describes the phantom detect status of the Ring In port.')
fTRMainRingRiNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRiNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiNsrtStatus.setDescription('Insertion status for this Ring In port.')
fTRMainRingRiBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRiBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
fTRMainRingRiCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("copper", 1), ("fiber", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRiCableType.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiCableType.setDescription('This parameter indicates the type of physical cabling used for the network interface on the Ring In port.')
fTRMainRingRiNghbrType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("series828", 1), ("fSeries", 2), ("tokenRingMAC", 3), ("none", 4), ("stackable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRiNghbrType.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiNghbrType.setDescription('This parameter indicates the type of nearest neighbor on the Ring In port.')
fTRMainRingRiNghbrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 13), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRiNghbrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiNghbrAddr.setDescription('The address of the nearest neighbor on the Ring In port.')
fTRMainRingRiTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 14), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRiTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRiTimeStamp.setDescription('The time the status of Ring In (was) last changed.')
fTRMainRingRoFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingRoFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoFTolState.setDescription('This controls the Ring Out (RO) fault tolerance behavior. Off(1) means that phantom current is not used on the corresponding RO interface as a condition for main ring link insertion. On (2) means tha phantom current is used on the corresponding RO interface as a condition for main ring link insertion. The preferred setting for this parameter is on (2).')
fTRMainRingRoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingRoMask.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoMask.setDescription('Administrative status for this Ring Out port. By setting this parameter, a remote manager can control the partitioning of this port.')
fTRMainRingRoPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wireFault", 1), ("phantOk", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRoPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoPhDet.setDescription('This parameter describes the phantom detect status for this Ring Out port.')
fTRMainRingRoNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRoNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoNsrtStatus.setDescription('Insertion status for this Ring Out port.')
fTRMainRingRoBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRoBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
fTRMainRingRoCableType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("copper", 1), ("fiber", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRoCableType.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoCableType.setDescription('This parameter indicates the type of physical cabling used for the network interface on the Ring Out port.')
fTRMainRingRoNghbrType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("series828", 1), ("fSeries", 2), ("tokenRingMAC", 3), ("none", 4), ("stackable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRoNghbrType.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoNghbrType.setDescription('This parameter indicates the type of nearest neighbor on the Ring Out port.')
fTRMainRingRoNghbrAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 22), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRoNghbrAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoNghbrAddr.setDescription('The address of the nearest neighbor on the Ring Out port.')
fTRMainRingRoTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 23), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingRoTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRoTimeStamp.setDescription('The time the status of Ring Out (was) last changed.')
fTRMainRingDataRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("s4Mbps", 1), ("s16Mbps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingDataRateState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingDataRateState.setDescription('This parameter indicates the current data rate of this unit.')
fTRMainRingDataRateTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 25), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingDataRateTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingDataRateTimeStamp.setDescription('The time the data rate status (was) last changed.')
fTRMainRingBkPlnNsrtState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inserted", 1), ("bypassed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingBkPlnNsrtState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingBkPlnNsrtState.setDescription('Backplane insertion status for this unit.')
fTRMainRingBkPlnTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 27), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingBkPlnTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingBkPlnTimeStamp.setDescription('The time the backplane insert status (was) last changed.')
fTRMainRingLobePhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingLobePhDet.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingLobePhDet.setDescription('Phantom current status for this lobe port. A value of 1 corresponds to no phantom current detected. A value of 2 corresponds to phantom presence.')
fTRMainRingLobeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolated", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingLobeMask.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingLobeMask.setDescription('Administrative status for this lobe port. By setting this parameter, a remote manager can control access to the lobe port.')
fTRMainRingLobeNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingLobeNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingLobeNsrtStatus.setDescription('Actual insertion status for this lobe port. A 1 value means that the corresponding station is not connected to the ring. A 2 value means that the corresponding station is connected to the ring.')
fTRMainRingLobeMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingLobeMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingLobeMacAddr.setDescription('The MAC layer address of the station which is attached to the corresponding lobe port.')
fTRMainRingLobeBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingLobeBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingLobeBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
fTRMainRingLobeTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 33), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingLobeTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingLobeTimeStamp.setDescription('The time the status of this lobe (was) last changed.')
fTRMainRingMgmtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operational", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingMgmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingMgmtStatus.setDescription('The operational status of this unit.')
fTRMainRingProxyAgentID = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 35), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingProxyAgentID.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingProxyAgentID.setDescription('The physical layer MAC Address of the agent.')
fTRMainRingAttachedAgentType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tokenring", 1), ("tokenring-ethernet", 2), ("reserved", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingAttachedAgentType.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingAttachedAgentType.setDescription('The type of the attached agent.')
fTRMainRingAttachedAgentState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("not-applicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingAttachedAgentState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingAttachedAgentState.setDescription('The state of the attached agent.')
fTRMainRingTemperatureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingTemperatureStatus.setDescription('The temperature status of this unit.')
fTRMainRingAutoRecovControl = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("reset", 3), ("unknown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingAutoRecovControl.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingAutoRecovControl.setDescription('This parameter controls the auto recovery operation of this unit.')
fTRMainRingAutoRecovRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingAutoRecovRetries.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingAutoRecovRetries.setDescription('The number of Auto Recoveries performed by this unit.')
fTRMainRingCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 41), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingCodeVersion.setDescription('The firmware version number of this unit.')
fTRMainRingAutoRecovState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in-recovery", 1), ("normal", 2), ("halted", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingAutoRecovState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingAutoRecovState.setDescription('The auto recovery state of this unit.')
fTRMainRingRawCommandData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 43), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingRawCommandData.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingRawCommandData.setDescription('This is used to send raw 485 serial data to this unit.')
fTRMainRingPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singleSupOK", 1), ("dualSupOK", 2), ("dualSup-BSupBAD", 3), ("dualSup-ASupBAD", 4), ("illegal", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingPowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingPowerStatus.setDescription('The status of the power supply as seen by this unit.')
fTRMainRingCageType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("twoslot-10100", 1), ("fiveslot-10101", 2), ("fiveslotredundant-10102", 3), ("reserved4", 4), ("reserved5", 5), ("reserved6", 6), ("reserved7", 7), ("reserved8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRMainRingCageType.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingCageType.setDescription('The model number of the f series chassis the card is is.')
fTRMainRingAutoRecovMode = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 2, 2, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("selfEnabling", 1), ("non-selfEnabling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRMainRingAutoRecovMode.setStatus('mandatory')
if mibBuilder.loadTexts: fTRMainRingAutoRecovMode.setDescription('This parameter describes the auto recovery mode.')
fTRLobeNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeNumber.setDescription('The number of items in the lobe table')
fTRLobeTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2), )
if mibBuilder.loadTexts: fTRLobeTable.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeTable.setDescription('A table which maintains a list of all of the intelligent Focus series hubs on the ring being managed by the addressed agent. This table is INDEXed by the RS485 OOB address of the Focus series intelligent hubs.')
fTRLobeTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "fTRLobeTableIndex"))
if mibBuilder.loadTexts: fTRLobeTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeTableEntry.setDescription('An entry in the fTRLobeTable')
fTRLobeTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeTableIndex.setDescription('The index for this lobe entry')
fTRLobeModel = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("f10157trPassiveMau", 1), ("f10158trActiveMau", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeModel.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeModel.setDescription('The Mau type of the Focus series lobe being managed.')
fTRLobe485Address = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobe485Address.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobe485Address.setDescription('The 6 hex digit address used on the RS485 serial OOB management channel.')
fTRLobeSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeSlotIndex.setDescription('The slot id.')
fTRLobeChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeChassisIndex.setDescription('The index of the chassis the card is in.')
fTRLobeDataRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("s4Mbps", 1), ("s16Mbps", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRLobeDataRateState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeDataRateState.setDescription('This parameter indicates the current data rate of this unit.')
fTRLobeDataRateTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeDataRateTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeDataRateTimeStamp.setDescription('The time the data rate status (was) last changed.')
fTRLobeBkPlnNsrtState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inserted", 1), ("bypassed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRLobeBkPlnNsrtState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeBkPlnNsrtState.setDescription('Backplane insertion status for this unit.')
fTRLobeBkPlnTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeBkPlnTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeBkPlnTimeStamp.setDescription('The time the backplane insert status (was) last changed.')
fTRLobeMgmtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operational", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeMgmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeMgmtStatus.setDescription('The operational status of this unit.')
fTRLobeProxyAgentID = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeProxyAgentID.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeProxyAgentID.setDescription('The physical layer MAC Address of the agent.')
fTRLobeTemperatureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeTemperatureStatus.setDescription('The temperature status of this unit.')
fTRLobeAutoRecovControl = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("reset", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRLobeAutoRecovControl.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeAutoRecovControl.setDescription('This parameter controls the auto recovery operation of this unit.')
fTRLobeAutoRecovMode = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("selfEnabling", 1), ("non-selfEnabling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRLobeAutoRecovMode.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeAutoRecovMode.setDescription('This parameter describes the auto recovery mode.')
fTRLobeAutoRecovRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRLobeAutoRecovRetries.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeAutoRecovRetries.setDescription('The number of Auto Recoveries performed by this unit.')
fTRLobeCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeCodeVersion.setDescription('The firmware version number of this unit.')
fTRLobeAutoRecovState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in-recovery", 1), ("normal", 2), ("halted", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeAutoRecovState.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeAutoRecovState.setDescription('The auto recovery state of this unit.')
fTRLobeRawCommandData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRLobeRawCommandData.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeRawCommandData.setDescription('This is used to send raw 485 serial data to this unit.')
fTRLobePowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singleSupOK", 1), ("dualSupOK", 2), ("dualSup-BSupBAD", 3), ("dualSup-ASupBAD", 4), ("illegal", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobePowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobePowerStatus.setDescription('The status of the power supply as seen by this unit.')
fTRLobeCageType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("twoslot-10100", 1), ("fiveslot-10101", 2), ("fiveslotredundant-10102", 3), ("reserved4", 4), ("reserved5", 5), ("reserved6", 6), ("reserved7", 7), ("reserved8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeCageType.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeCageType.setDescription('The model number of the fseries chassis the card is is.')
fTRLobeConnectNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectNumber.setDescription('The number of items in connection table')
fTRLobeConnectTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4), )
if mibBuilder.loadTexts: fTRLobeConnectTable.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectTable.setDescription('A table which contains the control and status information for the lobes.')
fTRLobeConnectEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "fTRLobeIndex"), (0, "STARTEK-PRIVATE-MIB", "fTRLobeConnectPort"))
if mibBuilder.loadTexts: fTRLobeConnectEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectEntry.setDescription('A collection of control and status parameters kept for each lobe.')
fTRLobeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeIndex.setDescription('The index into the fTRLobeTable of the mau this lobe is on.')
fTRLobeConnectPort = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectPort.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectPort.setDescription('The port of the mau this lobe is on.')
fTRLobeConnectPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectPhDet.setDescription('Phantom current status for this lobe port. A value of 1 corresponds to no phantom current detected. A value of 2 corresponds to phantom presence.')
fTRLobeConnectMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolated", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fTRLobeConnectMask.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectMask.setDescription('Administrative status for this lobe port. By setting this parameter, a remote manager can control access to the lobe port.')
fTRLobeConnectNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectNsrtStatus.setDescription('Actual insertion status for this lobe port. A 1 value means that the corresponding station is not connected to the ring. A 2 value means that the corresponding station is connected to the ring.')
fTRLobeConnectMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectMacAddr.setDescription('The MAC layer address of the station which is attached to the corresponding lobe port.')
fTRLobeConnectBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
fTRLobeConnectBcnRemCause = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-removal", 1), ("phantom-error", 2), ("no-carrier", 3), ("bad-rate", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectBcnRemCause.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectBcnRemCause.setDescription('This parameter describes the cause of any automatic beacon removal')
fTRLobeConnectTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 3, 4, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fTRLobeConnectTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fTRLobeConnectTimeStamp.setDescription('The time the status of this lobe (was) last changed.')
fEthernetNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetNumber.setDescription('The number of items in concentrator table')
fEthernetTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2), )
if mibBuilder.loadTexts: fEthernetTable.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetTable.setDescription('A table which maintains a list of all of the Focus series ethernet concentrators in the repeater being managed by the addressed agent. This table is INDEXed by the repeater group id of the Focus series ethernet concentrators.')
fEthernetTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "fEthernetTableIndex"))
if mibBuilder.loadTexts: fEthernetTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetTableEntry.setDescription('An entry in the fEthernetTable')
fEthernetTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetTableIndex.setDescription('The index for this hub entry.')
fEthernetModel = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("f10160", 1), ("f10161", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetModel.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetModel.setDescription('The model number of the Focus series ethernet concentrator being managed.')
fEthernet485Address = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernet485Address.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernet485Address.setDescription('The 6 hex digit address used on the RS485 serial OOB management channel.')
fEthernetSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetSlotIndex.setDescription('The slot id.')
fEthernetChassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetChassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetChassisIndex.setDescription('The index of the chassis the card is in.')
fEthernetBkPlnNsrtState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inserted", 1), ("bypassed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fEthernetBkPlnNsrtState.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetBkPlnNsrtState.setDescription('Backplane insertion status for this unit.')
fEthernetBkPlnTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetBkPlnTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetBkPlnTimeStamp.setDescription('The time the backplane insert status (was) last changed.')
fEthernetMgmtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operational", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetMgmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetMgmtStatus.setDescription('The operational status of this unit.')
fEthernetProxyAgentID = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetProxyAgentID.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetProxyAgentID.setDescription('The physical layer MAC Address of the agent.')
fEthernetTemperatureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetTemperatureStatus.setDescription('The temperature status of this unit.')
fEthernetCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetCodeVersion.setDescription('The firmware version number of this unit.')
fEthernetRawCommandData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fEthernetRawCommandData.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetRawCommandData.setDescription('This is used to send raw 485 serial data to this unit.')
fEthernetPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("singleSupOK", 1), ("dualSupOK", 2), ("dualSup-BSupBAD", 3), ("dualSup-ASupBAD", 4), ("illegal", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetPowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetPowerStatus.setDescription('The status of the power supply as seen by this unit.')
fEthernetCageType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("twoslot-10100", 1), ("fiveslot-10101", 2), ("fiveslotredundant-10102", 3), ("reserved4", 4), ("reserved5", 5), ("reserved6", 6), ("reserved7", 7), ("reserved8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fEthernetCageType.setStatus('mandatory')
if mibBuilder.loadTexts: fEthernetCageType.setDescription('The model number of the fseries chassis the card is is.')
rmonAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 2, 7))
rmonAgentDescription = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentDescription.setDescription('The text name for this agent.')
rmonAgentID = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentID.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentID.setDescription('The text name for this agent.')
rmonAgentOOBNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentOOBNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentOOBNumber.setDescription('The number of items in connection table')
rmonAgentOOBTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 4), )
if mibBuilder.loadTexts: rmonAgentOOBTable.setStatus('mandatory')
rmonAgentOOBTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 4, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "rmonAgentOOBTableIndex"))
if mibBuilder.loadTexts: rmonAgentOOBTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentOOBTableEntry.setDescription('An entry in the rmonAgentOOBTable.')
rmonAgentOOBTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentOOBTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentOOBTableIndex.setDescription('The index of this entry.')
rmonAgentOOBTableDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentOOBTableDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentOOBTableDescription.setDescription('The text description of this OOB (Out Of Band) table.')
rmonAgentOOBTableData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 4, 1, 3), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentOOBTableData.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentOOBTableData.setDescription('An opaque data structure used for management.')
rmonAgentOOBRawDataCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentOOBRawDataCommand.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentOOBRawDataCommand.setDescription('Raw method of sending data on channel.')
rmonAgentIBNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBNumber.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBNumber.setDescription('The number of items in the connection table.')
rmonAgentIBTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6), )
if mibBuilder.loadTexts: rmonAgentIBTable.setStatus('mandatory')
rmonAgentIBTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "rmonAgentIBTableIndex"))
if mibBuilder.loadTexts: rmonAgentIBTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBTableEntry.setDescription('An entry in the rmonAgentIBTable.')
rmonAgentIBTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBTableIndex.setStatus('mandatory')
rmonAgentIBTableDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentIBTableDescription.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBTableDescription.setDescription('The text description of this IB (In Band) Table.')
rmonAgentIBNetworkType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tokenring", 1), ("ethernet", 2), ("fddi", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBNetworkType.setStatus('mandatory')
rmonAgentIBSampleInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 4), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentIBSampleInterval.setStatus('mandatory')
rmonAgentIBMacFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMacFrames.setStatus('mandatory')
rmonAgentIBDataFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBDataFrames.setStatus('mandatory')
rmonAgentIBMacBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMacBytes.setStatus('mandatory')
rmonAgentIBDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBDataBytes.setStatus('mandatory')
rmonAgentIBUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBUtilization.setStatus('mandatory')
rmonAgentIBMACUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACUtilization.setStatus('mandatory')
rmonAgentIBNonMACUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBNonMACUtilization.setStatus('mandatory')
rmonAgentIBMACData0 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 12), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData0.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData0.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData1 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 13), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData1.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData1.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData2 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 14), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData2.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData2.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData3 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 15), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData3.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData3.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData4 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 16), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData4.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData4.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData5 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 17), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData5.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData5.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData6 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 18), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData6.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData6.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData7 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 19), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData7.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData7.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData8 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 20), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData8.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData8.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData9 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 21), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData9.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData9.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData10 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 22), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData10.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData10.setDescription('An opaque data structure used for management.')
rmonAgentIBMACData11 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 6, 1, 23), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentIBMACData11.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIBMACData11.setDescription('An opaque data structure used for management.')
rmonAgentMonitorCommand = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentMonitorCommand.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentMonitorCommand.setDescription('A method of sending raw commands to the agent monitor.')
rmonAgentMonitorResponse = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentMonitorResponse.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentMonitorResponse.setDescription('This parameter contains the text response to an agent monitor command.')
rmonAgentDownloadData = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentDownloadData.setStatus('mandatory')
rmonAgentNoMapOid = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 10), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentNoMapOid.setStatus('mandatory')
rmonAgentMACStatTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 11), )
if mibBuilder.loadTexts: rmonAgentMACStatTable.setStatus('mandatory')
pysmiFakeCol1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 11, 1) + (1000, ), Integer32())
pysmiFakeCol1001 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 11, 1) + (1001, ), Integer32())
rmonAgentMACStatTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 11, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "pysmiFakeCol1000"), (0, "STARTEK-PRIVATE-MIB", "pysmiFakeCol1001"))
if mibBuilder.loadTexts: rmonAgentMACStatTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentMACStatTableEntry.setDescription('An entry in the rmonAgentIBTable.')
rmonAgentMACStatTableData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 11, 1, 1), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAgentMACStatTableData.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentMACStatTableData.setDescription('An opaque data structure used for management.')
rmonAgentIPAdressControl = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 2, 7, 12), Opaque()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAgentIPAdressControl.setStatus('mandatory')
if mibBuilder.loadTexts: rmonAgentIPAdressControl.setDescription('An opaque data structure used for management.')
stackableHubs = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 3, 1))
stackableHubNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubNumber.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubNumber.setDescription('The number of items in hub table')
stackableHubTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2), )
if mibBuilder.loadTexts: stackableHubTable.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubTable.setDescription('A table which maintains a list of all of the intelligent stackable series hubs on the ring being managed by the addressed agent. This table is indexed by the RS485 OOB address of the stackable series intelligent hubs.')
stackableHubTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "stackableHubTableIndex"))
if mibBuilder.loadTexts: stackableHubTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubTableEntry.setDescription('An entry in the stackableHubTable.')
stackableHubTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubTableIndex.setDescription('The index for this hub entry')
stackableHubModel = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("standard-issue", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubModel.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubModel.setDescription('The model number of the stackable series hub being managed.')
stackableHub485Address = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHub485Address.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHub485Address.setDescription('The 6 hex digit address used on the RS485 serial OOB management channel.')
stackableHubRiFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubRiFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiFTolState.setDescription('This parameter controls the Ring In (RI) fault tolerance behavior. Off(1) means that phantom current is not used on the corresponding RI interface as a condition for main ring link insertion. On (2) means tha phantom current is used on the corresponding RI interface as a condition for main ring link insertion. The preferred setting for this parameter is on (2).')
stackableHubRiMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubRiMask.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiMask.setDescription('Administrative status for this Ring In port. By setting this parameter, a remote manager can control the partitioning of this port.')
stackableHubRiPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRiPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiPhDet.setDescription('This parameter describes the phantom detect status for this Ring In port.')
stackableHubRiNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRiNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiNsrtStatus.setDescription('Insertion status for this Ring In port.')
stackableHubRiBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRiBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
stackableHubRiNeighborType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("series828", 1), ("fSeries", 2), ("tokenRingMAC", 3), ("none", 4), ("stackable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRiNeighborType.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiNeighborType.setDescription('This parameter indicates the type of nearest neighbor on the Ring In port.')
stackableHubRiNeighborAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRiNeighborAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiNeighborAddr.setDescription('The address of the nearest neighbor on the Ring In port.')
stackableHubRiTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRiTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRiTimeStamp.setDescription('The time the status of Ring In (was) last changed.')
stackableHubRoFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubRoFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoFTolState.setDescription('This parameter controls the Ring Out(RO) fault tolerance behavior. Off(1) means that phantom current is not used on the corresponding RO interface as a condition for main ring link insertion. On (2) means tha phantom current is used on the corresponding RO interface as a condition for main ring link insertion. The preferred setting for this parameter is on (2).')
stackableHubRoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubRoMask.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoMask.setDescription('Administrative status for this Ring Out port. By setting this parameter, a remote manager can control the partitioning of this port.')
stackableHubRoPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("wireFault", 1), ("phantOk", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRoPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoPhDet.setDescription('This parameter describes the phantom detect status for this Ring Out port.')
stackableHubRoNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRoNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoNsrtStatus.setDescription('Insertion status for this Ring Out port.')
stackableHubRoBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRoBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
stackableHubRoNeighborType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("series828", 1), ("fSeries", 2), ("tokenRingMAC", 3), ("none", 4), ("stackable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRoNeighborType.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoNeighborType.setDescription('This parameter indicates the type of nearest neighbor on the Ring Out port.')
stackableHubRoNeighborAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRoNeighborAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoNeighborAddr.setDescription('The address of the nearest neighbor on the Ring Out port.')
stackableHubRoTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 19), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubRoTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRoTimeStamp.setDescription('The time the status of Ring Out (was) last changed.')
stackableHubDataRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("s4Mbps", 1), ("s16Mbps", 2), ("autoConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubDataRateState.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubDataRateState.setDescription('This parameter indicates the current data rate of this unit.')
stackableHubDataRateTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 21), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubDataRateTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubDataRateTimeStamp.setDescription('The time the data rate status (was) last changed.')
stackableHubMgmtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operational", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubMgmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubMgmtStatus.setDescription('The operational status of this unit.')
stackableHubProxyAgentID = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubProxyAgentID.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubProxyAgentID.setDescription('The physical layer MAC Address of the agent.')
stackableHubAttachedAgentType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("tokenring", 1), ("tokenring-ethernet", 2), ("reserved", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubAttachedAgentType.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubAttachedAgentType.setDescription('The type of the attached agent.')
stackableHubAttachedAgentState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("not-applicable", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubAttachedAgentState.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubAttachedAgentState.setDescription('The state of the attached agent.')
stackableHubTemperatureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubTemperatureStatus.setDescription('The temperature status of this unit.')
stackableHubAutoRecovControl = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("reset", 3), ("unknown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubAutoRecovControl.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubAutoRecovControl.setDescription('This parameter controls the auto recovery operation of this unit.')
stackableHubAutoRecovRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubAutoRecovRetries.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubAutoRecovRetries.setDescription('The number of Auto Recoveries performed by this unit.')
stackableHubCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubCodeVersion.setDescription('The firmware version number of this unit.')
stackableHubAutoRecovState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in-recovery", 1), ("normal", 2), ("halted", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubAutoRecovState.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubAutoRecovState.setDescription('The auto recovery state of this unit.')
stackableHubRawCommandData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 31), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubRawCommandData.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubRawCommandData.setDescription('This is used to send raw 485 serial data to this unit.')
stackableHubAutoRecovMode = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("selfEnabling", 1), ("non-selfEnabling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubAutoRecovMode.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubAutoRecovMode.setDescription('This parameter describes the auto recovery mode.')
stackableHubLobeNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeNumber.setDescription('The number of items in the hub lobe table.')
stackableHubLobeTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4), )
if mibBuilder.loadTexts: stackableHubLobeTable.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeTable.setDescription('A table which contains the control and status information for the lobes.')
stackableHubLobeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "stackableHubIndex"), (0, "STARTEK-PRIVATE-MIB", "stackableHubLobePort"))
if mibBuilder.loadTexts: stackableHubLobeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeEntry.setDescription('A collection of control and status parameters kept for each lobe.')
stackableHubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubIndex.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubIndex.setDescription('The index into the stackableHubTable of the mau this lobe is on.')
stackableHubLobePort = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobePort.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobePort.setDescription('The port of the mau this lobe is on.')
stackableHubLobePhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobePhDet.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobePhDet.setDescription('Phantom current status for this lobe port. A value of 1 corresponds to no phantom current detected. A value of 2 corresponds to phantom presence.')
stackableHubLobeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolated", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stackableHubLobeMask.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeMask.setDescription('Administrative status for this lobe port. By setting this parameter, a remote manager can control access to the lobe port.')
stackableHubLobeNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobeNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeNsrtStatus.setDescription('Actual insertion status for this lobe port. A 1 value means that the corresponding station is not connected to the ring. A 2 value means that the corresponding station is connected to the ring.')
stackableHubLobeMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobeMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeMacAddr.setDescription('The MAC layer address of the station which is attached to the corresponding lobe port.')
stackableHubLobeBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobeBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
stackableHubLobeBcnRemCause = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-removal", 1), ("phantom-error", 2), ("no-carrier", 3), ("bad-rate", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobeBcnRemCause.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeBcnRemCause.setDescription('This parameter describes the cause of any automatic beacon removal operations performed by the agent on this port.')
stackableHubLobeTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 1, 4, 1, 9), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: stackableHubLobeTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: stackableHubLobeTimeStamp.setDescription('The time the status of this lobe (was) last changed.')
superStackHubs = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 1, 3, 2))
superStackHubNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubNumber.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubNumber.setDescription('The number of items in hub table')
superStackHubTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2), )
if mibBuilder.loadTexts: superStackHubTable.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubTable.setDescription('A table which maintains a list of all of the intelligent superStack series hubs on the ring being managed by the addressed agent. This table is indexed by the RS485 OOB address of the superStack series intelligent hubs.')
superStackHubTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "superStackHubTableIndex"))
if mibBuilder.loadTexts: superStackHubTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubTableEntry.setDescription('An entry in the superStackHubTable.')
superStackHubTableIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubTableIndex.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubTableIndex.setDescription('The index for this hub entry')
superStackHubModel = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active-12-port-base-mau", 1), ("active-24-port-expansion-mau", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubModel.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubModel.setDescription('The model number of the superStack series hub being managed.')
superStackHub485Address = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHub485Address.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHub485Address.setDescription('The 6 hex digit address used on the RS485 serial OOB management channel.')
superStackHubStackPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubStackPosition.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubStackPosition.setDescription('The integer position in a stack of units. The top position is 1.')
superStackRiConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-ring-in-configured", 1), ("copper-ring-in-configured", 2), ("fiber-ring-in-configured", 3), ("copper-ring-in-disabled", 4), ("fiber-ring-in-disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackRiConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: superStackRiConfiguration.setDescription('This parameter describes the physical configured state of Ring In. Ring In is disabled if there is another Ring In within the cascaded stack of hubs.')
superStackHubRiFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubRiFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRiFTolState.setDescription('This parameter controls the Ring In (RI) fault tolerance behavior. Off(1) means that phantom current is not used on the corresponding RI interface as a condition for main ring link insertion. On (2) means tha phantom current is used on the corresponding RI interface as a condition for main ring link insertion. The preferred setting for this parameter is on (2).')
superStackHubRiMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubRiMask.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRiMask.setDescription('Administrative status for this Ring In port. By setting this parameter, a remote manager can control the partitioning of this port.')
superStackHubRiPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRiPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRiPhDet.setDescription('This parameter describes the phantom detect status for this Ring In port.')
superStackHubRiNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRiNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRiNsrtStatus.setDescription('Insertion status for this Ring In port.')
superStackHubRiBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRiBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRiBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
superStackRoConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-ring-out-configured", 1), ("copper-ring-out-configured", 2), ("fiber-ring-out-configured", 3), ("copper-ring-out-disabled", 4), ("fiber-ring-out-disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackRoConfiguration.setStatus('mandatory')
if mibBuilder.loadTexts: superStackRoConfiguration.setDescription('This parameter describes the physical configured state of Ring Out. Ring Out is disabled if there is another Ring Out within the cascaded stack of hubs.')
superStackHubRoFTolState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubRoFTolState.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRoFTolState.setDescription('This parameter controls the Ring Out(RO) fault tolerance behavior. Off(1) means that phantom current is not used on the corresponding RO interface as a condition for main ring link insertion. On (2) means tha phantom current is used on the corresponding RO interface as a condition for main ring link insertion. The preferred setting for this parameter is on (2).')
superStackHubRoMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubRoMask.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRoMask.setDescription('Administrative status for this Ring Out port. By setting this parameter, a remote manager can control the partitioning of this port.')
superStackHubRoPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRoPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRoPhDet.setDescription('This parameter describes the phantom detect status for this Ring Out port.')
superStackHubRoNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRoNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRoNsrtStatus.setDescription('Insertion status for this Ring Out port.')
superStackHubRoBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRoBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRoBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
superStackHubCascadeUpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubCascadeUpMask.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeUpMask.setDescription('Administrative status for this Cascade Up connection. By setting this parameter, a remote manager can control the partitioning of this port.')
superStackHubCascadeUpPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubCascadeUpPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeUpPhDet.setDescription('This parameter describes the phantom detect status for this Cascade Up connection.')
superStackHubCascadeUpNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubCascadeUpNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeUpNsrtStatus.setDescription('Insertion status for this Cascade Up connection.')
superStackHubCascadeUpBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubCascadeUpBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeUpBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this connection. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
superStackHubCascadeDownMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolate", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubCascadeDownMask.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeDownMask.setDescription('Administrative status for this Cascade Down connection. By setting this parameter, a remote manager can control the partitioning of this port.')
superStackHubCascadeDownPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubCascadeDownPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeDownPhDet.setDescription('This parameter describes the phantom detect status for this Cascade Down connection.')
superStackHubCascadeDownNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubCascadeDownNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeDownNsrtStatus.setDescription('Insertion status for this Cascade Down connection.')
superStackHubCascadeDownBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubCascadeDownBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCascadeDownBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this connection. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
superStackHubDataRateState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("s4Mbps", 1), ("s16Mbps", 2), ("autoConfig", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubDataRateState.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubDataRateState.setDescription('This parameter indicates the current data rate of this unit.')
superStackHubDeviceTimeStamp = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 26), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubDeviceTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubDeviceTimeStamp.setDescription('The time the data rate status (was) last changed.')
superStackHubMgmtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("operational", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubMgmtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubMgmtStatus.setDescription('The operational status of this unit.')
superStackHubProxyAgentID = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubProxyAgentID.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubProxyAgentID.setDescription('The physical layer MAC Address of the agent.')
superStackHubAttachedAgentType = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("unknown", 2), ("basic-68000", 3), ("advanced-960", 4), ("reserved1", 5), ("reserved2", 6), ("reserved3", 7), ("reserved4", 8), ("reserved5", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubAttachedAgentType.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubAttachedAgentType.setDescription('The type of the attached agent.')
superStackHubAttachedAgentState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("not-applicable", 1), ("normal", 2), ("duplicate-detected", 3), ("management-disabled", 4), ("hardware-faulted", 5), ("agent-MAC-auto-isolated", 6), ("agent-MAC-mgmt-isolated", 7), ("reserved1", 8), ("reserved2", 9), ("reserved3", 10), ("reserved4", 11), ("reserved5", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubAttachedAgentState.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubAttachedAgentState.setDescription('The state of the attached agent.')
superStackHubAttachedAgentControl = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2), ("enable-MAC-insertion", 3), ("isolate-MAC-insertion", 4), ("read-value", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubAttachedAgentControl.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubAttachedAgentControl.setDescription('This parameter allows control of the agent. Disabling the agent causes it to stop communicating (via the cascade) with other devices but it still allows for insertion of the MAC. The enable/isolate-MAC-insertion commands cause the agents MAC to be inserted or looped back respectively. this unit.')
superStackHubTemperatureStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubTemperatureStatus.setDescription('The temperature status of this unit.')
superStackHubPowerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal-AC-power", 1), ("normal-redundant-DC-power", 2), ("non-redundant-DC-power", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubPowerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubPowerStatus.setDescription('The power status of this unit.')
superStackHubAutoRecovControl = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("reset", 3), ("unknown", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubAutoRecovControl.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubAutoRecovControl.setDescription('This parameter controls the auto recovery operation of this unit.')
superStackHubAutoRecovRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubAutoRecovRetries.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubAutoRecovRetries.setDescription('The number of Auto Recoveries performed by this unit.')
superStackHubCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 36), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubCodeVersion.setDescription('The firmware version number of this unit.')
superStackHubAutoRecovState = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in-recovery", 1), ("normal", 2), ("halted", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubAutoRecovState.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubAutoRecovState.setDescription('The current auto recovery state of this unit.')
superStackHubRawCommandData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 38), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubRawCommandData.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRawCommandData.setDescription('This is used to send raw 485 serial data to this unit.')
superStackHubAutoRecovMode = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("selfEnabling", 1), ("non-selfEnabling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubAutoRecovMode.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubAutoRecovMode.setDescription('This parameter describes the auto recovery mode.')
superStackHubRouterPortPhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRouterPortPhDet.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRouterPortPhDet.setDescription('Phantom current status for the router port on rear. A value of 1 corresponds to no phantom current detected. A value of 2 corresponds to phantom presence.')
superStackHubRouterPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolated", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubRouterPortMask.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRouterPortMask.setDescription('Administrative status for the router port on rear. By setting this parameter, a remote manager can control access to the lobe port.')
superStackHubRouterPortNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRouterPortNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRouterPortNsrtStatus.setDescription('Actual insertion status for the router port on rear. A 1 value means that the corresponding station is not connected to the ring. A 2 value means that the corresponding station is connected to the ring.')
superStackHubRouterPortMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 43), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRouterPortMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRouterPortMacAddr.setDescription('The MAC layer address of the station which is attached to the router port on rear.')
superStackHubRouterPortBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 44), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRouterPortBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRouterPortBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on the router port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
superStackHubRouterPortBcnRemCause = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 2, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-removal", 1), ("phantom-error", 2), ("no-carrier", 3), ("bad-rate", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubRouterPortBcnRemCause.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubRouterPortBcnRemCause.setDescription('This parameter describes the cause of any automatic beacon removal operations performed by the agent on this port.')
superStackHubLobeNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeNumber.setDescription('The number of items in the hub lobe table.')
superStackHubLobeTable = MibTable((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4), )
if mibBuilder.loadTexts: superStackHubLobeTable.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeTable.setDescription('A table which contains the control and status information for the lobes.')
superStackHubLobeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "superStackHubIndex"), (0, "STARTEK-PRIVATE-MIB", "superStackHubLobePort"))
if mibBuilder.loadTexts: superStackHubLobeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeEntry.setDescription('A collection of control and status parameters kept for each lobe.')
superStackHubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubIndex.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubIndex.setDescription('The index into the superStackHubTable of the mau this lobe is on.')
superStackHubLobePort = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobePort.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobePort.setDescription('The port of the mau this lobe is on.')
superStackHubLobeConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("user-normal", 1), ("ring-out-unused", 2), ("ring-in-unused", 3), ("unknown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobeConfig.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeConfig.setDescription('The hardware configuration of the port.')
superStackHubLobePhDet = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noPhantom", 1), ("phantDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobePhDet.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobePhDet.setDescription('Phantom current status for this lobe port. A value of 1 corresponds to no phantom current detected. A value of 2 corresponds to phantom presence.')
superStackHubLobeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("isolated", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: superStackHubLobeMask.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeMask.setDescription('Administrative status for this lobe port. By setting this parameter, a remote manager can control access to the lobe port.')
superStackHubLobeNsrtStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bypassed", 1), ("inserted", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobeNsrtStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeNsrtStatus.setDescription('Actual insertion status for this lobe port. A 1 value means that the corresponding station is not connected to the ring. A 2 value means that the corresponding station is connected to the ring.')
superStackHubLobeMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobeMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeMacAddr.setDescription('The MAC layer address of the station which is attached to the corresponding lobe port.')
superStackHubLobeBcnRemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ok", 1), ("autoIsolated", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobeBcnRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeBcnRemStatus.setDescription('This parameter describes the result of any automatic beacon removal operations performed by the agent on this port. Automatic beacon removal operations consist of agent-initiated isolation of a lobe port in order to remove the cause of a persistent beaconing condition.')
superStackHubLobeBcnRemCause = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 1, 3, 2, 4, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-removal", 1), ("phantom-error", 2), ("no-carrier", 3), ("bad-rate", 4), ("unknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: superStackHubLobeBcnRemCause.setStatus('mandatory')
if mibBuilder.loadTexts: superStackHubLobeBcnRemCause.setDescription('This parameter describes the cause of any automatic beacon removal operations performed by the agent on this port.')
managers = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 2, 1))
mgrNumber = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mgrNumber.setDescription('The number of managers in the manager table.')
mgrAutoAdd = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrAutoAdd.setStatus('mandatory')
if mibBuilder.loadTexts: mgrAutoAdd.setDescription('This variable indicates whether any manager that communicates with the agent should be added to the manager table.')
mgrAutoAge = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrAutoAge.setStatus('mandatory')
if mibBuilder.loadTexts: mgrAutoAge.setDescription("When mgrAutoAdd is enabled, this variable then indicates whether manager entries should be deleted after 'mgrAgeInterval' ticks. This variable has no effect when mgrAutoAdd is disabled.")
mgrAgeInterval = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 1, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrAgeInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mgrAgeInterval.setDescription('This is the aging interval.')
mgrTable = MibTable((1, 3, 6, 1, 4, 1, 260, 2, 1, 5), )
if mibBuilder.loadTexts: mgrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mgrTable.setDescription('A list of managers.')
mgrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "mgrIndex"))
if mibBuilder.loadTexts: mgrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mgrEntry.setDescription('A manager entry.')
mgrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mgrIndex.setDescription('The Index number of the Manager Entry.')
mgrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mgrIpAddr.setDescription('The IP address of the manager.')
mgrCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrCommunity.setStatus('mandatory')
if mibBuilder.loadTexts: mgrCommunity.setDescription('The Community of the manager.')
mgrTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1, 4), TimeTicks()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: mgrTimeStamp.setDescription('Time of last communication with the manager.')
mgrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mgrStatus.setDescription('The Status of this Entry.')
mgrPhysAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrPhysAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mgrPhysAddr.setDescription('The physical address of the manager entry.')
mgrInterfaceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 1, 5, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgrInterfaceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mgrInterfaceIndex.setDescription('The Interface Index of the manager entry.')
versions = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 2, 2))
configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 2, 3))
versionHardware = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 2, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: versionHardware.setStatus('mandatory')
if mibBuilder.loadTexts: versionHardware.setDescription('The Version of hardware release.')
versionEPROMFirmware = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: versionEPROMFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: versionEPROMFirmware.setDescription('The Version of EPROM release.')
versionFLASHFirmware = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 2, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: versionFLASHFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: versionFLASHFirmware.setDescription('The Version of FLASH release.')
configEPROMSize = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configEPROMSize.setStatus('mandatory')
if mibBuilder.loadTexts: configEPROMSize.setDescription('The Quantity of EPROM installed (number of bytes).')
configFLASHSize = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configFLASHSize.setStatus('mandatory')
if mibBuilder.loadTexts: configFLASHSize.setDescription('The Quantity of FLASH installed (number of bytes).')
configFLASHCount = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configFLASHCount.setStatus('mandatory')
if mibBuilder.loadTexts: configFLASHCount.setDescription('The Quantity of FLASH installed (number of ICs).')
configDRAMSize = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configDRAMSize.setStatus('mandatory')
if mibBuilder.loadTexts: configDRAMSize.setDescription('The Quantity of DRAM installed (number of bytes).')
configDRAMCount = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configDRAMCount.setStatus('mandatory')
if mibBuilder.loadTexts: configDRAMCount.setDescription('The Quantity of DRAM installed (number of SIMMs).')
configRS232Number = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configRS232Number.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232Number.setDescription('The Number of RS-232 ports in the RS-232 port table.')
configRS232PortTable = MibTable((1, 3, 6, 1, 4, 1, 260, 2, 3, 7), )
if mibBuilder.loadTexts: configRS232PortTable.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232PortTable.setDescription('A list of port entries. The number of entries is given by the value of configRS232Number.')
configRS232PortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "configRS232PortIndex"))
if mibBuilder.loadTexts: configRS232PortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232PortEntry.setDescription('Status and parameter values for a port.')
configRS232PortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configRS232PortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232PortIndex.setDescription('A unique value for each port.')
configRS232PortName = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: configRS232PortName.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232PortName.setDescription('A text description of the port, i.e. COM1.')
configRS232BaudRate = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("b1200", 1), ("b2400", 2), ("b4800", 3), ("b9600", 4), ("b19200", 5), ("b38400", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRS232BaudRate.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232BaudRate.setDescription('The baudrate at which the port is operating.')
configRS232ModemStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("modemDetected", 1), ("autobauding", 2), ("noModemDetected", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configRS232ModemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232ModemStatus.setDescription('The current status of the modem port connection.')
configRS232ConnectionStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("connected", 1), ("connectionWait", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configRS232ConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232ConnectionStatus.setDescription('The current status of the modem data connection.')
configRS232ModemConfigString = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 40))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRS232ModemConfigString.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232ModemConfigString.setDescription('A user-configurable ASCII string used to initialize a modem on this port. If this string is set to Z, the Star-Tek Agent sends ATZ<CR> to the modem during configuration.')
configRS232OutputData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 42))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRS232OutputData.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232OutputData.setDescription('Raw data to be sent out this port. Data can only be sent if the ConnectionStatus is connectionWait.')
configRS232InputData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configRS232InputData.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232InputData.setDescription('The response, if any, to the output data.')
configRS232HardwareFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 3, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configRS232HardwareFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: configRS232HardwareFlowControl.setDescription('Controls the use of RTS-CTS hardware flow control during modem connections.')
configMonitorMode = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("monitor", 1), ("slip", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMonitorMode.setStatus('mandatory')
if mibBuilder.loadTexts: configMonitorMode.setDescription('The mode of operation of the monitor port. The monitor port is COM2 (if present, COM1 if not).')
configMonitorInput = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMonitorInput.setStatus('mandatory')
if mibBuilder.loadTexts: configMonitorInput.setDescription('Controls whether the monitor function will accept input.')
configMonitorDiags = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configMonitorDiags.setStatus('mandatory')
if mibBuilder.loadTexts: configMonitorDiags.setDescription('Controls whether the monitor function will produce diagnostic output.')
configParseControl = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("parseAll", 1), ("parseMost", 2), ("parseLess", 3), ("parseNone", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configParseControl.setStatus('mandatory')
if mibBuilder.loadTexts: configParseControl.setDescription('Controls the degree to which frames are copied and parsed. Under high network loads this control can be used to prevent agent overload.')
configBootSource = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("eprom", 1), ("flash", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configBootSource.setStatus('mandatory')
if mibBuilder.loadTexts: configBootSource.setDescription('Describes where the agent is executing code from.')
security = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 2, 4))
securityControl = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityControl.setStatus('mandatory')
if mibBuilder.loadTexts: securityControl.setDescription('This controls whether security is enabled or disabled.')
securityMacAddressTable = MibTable((1, 3, 6, 1, 4, 1, 260, 2, 4, 2), )
if mibBuilder.loadTexts: securityMacAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: securityMacAddressTable.setDescription('A table which maintains a list of MacAddresses which are from the local ring, along with a control field which specifies whether it is allowed or disallowed access to the local ring and a counter which tracks the number of times that address has been disallowed access to the ring.')
pysmiFakeCol1002 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 4, 2, 1) + (1002, ), Integer32())
securityMacAddressTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 2, 4, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "pysmiFakeCol1002"))
if mibBuilder.loadTexts: securityMacAddressTableEntry.setStatus('mandatory')
if mibBuilder.loadTexts: securityMacAddressTableEntry.setDescription('An entry in the securityMacAddressTable.')
securityMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 4, 2, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: securityMacAddress.setDescription('The Token Ring Mac Address for this entry.')
securityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allowed", 1), ("disallowed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: securityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: securityStatus.setDescription('Specifies whether this address is allowed or disallowed to be on the local ring.')
securityLockoutCount = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 2, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: securityLockoutCount.setStatus('mandatory')
if mibBuilder.loadTexts: securityLockoutCount.setDescription('The number of times this address was disallowed on the local ring.')
recovery = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 2, 5))
recoveryControl = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: recoveryControl.setStatus('mandatory')
if mibBuilder.loadTexts: recoveryControl.setDescription('This variable controls whether or not this agent will Accelerate the token-ring recovery process. Enabled by default. ')
recovery828Support = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 5, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: recovery828Support.setStatus('mandatory')
if mibBuilder.loadTexts: recovery828Support.setDescription('This variable controls whether this agent will perform Accelerated Recovery on model 828 devices. Disabled by default. ')
recoveryRetryLimit = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 5, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: recoveryRetryLimit.setStatus('mandatory')
if mibBuilder.loadTexts: recoveryRetryLimit.setDescription('This variable controls the maximum number of Accelerated Recovery events that will be attempted within recoveryRetryTimePeriod seconds of each other.')
recoveryRetryTimePeriod = MibScalar((1, 3, 6, 1, 4, 1, 260, 2, 5, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: recoveryRetryTimePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: recoveryRetryTimePeriod.setDescription('The number of seconds which must elapse between Recovery events in order for them to be considered non-related and non-limited.')
rmonextns = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 4))
stationstatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 4, 1))
stationhistory = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 4, 2))
trHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 260, 4, 2, 1), )
if mibBuilder.loadTexts: trHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryTable.setDescription('A list of Token Ring history entries.')
trHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "trHistoryIndex"), (0, "STARTEK-PRIVATE-MIB", "trHistorySampleIndex"))
if mibBuilder.loadTexts: trHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryEntry.setDescription('An historical sample of Token Ring statistics on a particular Token Ring interface (on a per station basis). This sample is associated with the historyControlEntry which set up the parameters for a regular collection of these samples.')
trHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of historyControlIndex.')
trHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistorySampleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: trHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same historyControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
trHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryIntervalStart.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryIntervalStart.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured. If the probe keeps track of the time of day, it should start the first sample of the history at a time such that when the next hour of the day begins, a sample is started at that instant. Note that following this rule may require the probe to delay collecting the first sample of the history, as each sample must be of the same interval. Also note that the sample which is currently being collected is not accessible in this table until the end of its interval.')
trHistoryInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryInPkts.setDescription('The number of packets (including error packets) received by this station, during this sampling interval.')
trHistoryOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOutPkts.setDescription('The number of packets (including error packets) transmitted by this station, during this sampling interval.')
trHistoryInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryInOctets.setDescription('The total number of octets of data (including those in bad packets) received on the network (excluding framing bits but including FCS octets) by this station, during this sampling interval.')
trHistoryOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOutOctets.setDescription('The total number of octets of data (including those in bad packets) transmitted on the network (excluding framing bits but including FCS octets) by this station, during this sampling interval.')
trHistoryOutBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryOutBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOutBroadcastPkts.setDescription('The total number of good packets transmitted on the network that were directed to the broadcast address by this station, during this sampling interval.')
trHistoryOutMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryOutMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOutMulticastPkts.setDescription('The total number of good packets transmitted on the network that were directed to a multicast address by this station, during this sampling interval. Note that this number does not include packets addressed to the broadcast address.')
trHistoryClaimTokenPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryClaimTokenPkts.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryClaimTokenPkts.setDescription('The total number of Claim Token MAC packets detected by this station during this sampling interval.')
trHistoryInLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryInLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryInLineErrors.setDescription('The total number of line errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryOutLineErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryOutLineErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOutLineErrors.setDescription('The total number of line errors reported in error reporting packets sent by the nearest active downstream neighbor of this station and detected by the probe during this sampling interval.')
trHistoryInternalErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryInternalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryInternalErrors.setDescription('The total number of adapter internal errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryInBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryInBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryInBurstErrors.setDescription('The total number of burst errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryOutBurstErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryOutBurstErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOutBurstErrors.setDescription('The total number of burst errors reported in error reporting packets sent by the nearest active downstream neighbor of this station and detected by the probe, during this sampling interval.')
trHistoryACErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryACErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryACErrors.setDescription('The total number of AC (Address Copied) errors reported in error reporting packets sent by the nearest active downstream neighbor of this station and detected by the probe during this sampling interval.')
trHistoryAbortErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryAbortErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryAbortErrors.setDescription('The total number of abort delimiters reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryLostFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryLostFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryLostFrameErrors.setDescription('The total number of lost frame errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryCongestionErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryCongestionErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryCongestionErrors.setDescription('The total number of receive congestion errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryFrameCopiedErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryFrameCopiedErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryFrameCopiedErrors.setDescription('The total number of frame copied errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryFrequencyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryFrequencyErrors.setStatus('optional')
if mibBuilder.loadTexts: trHistoryFrequencyErrors.setDescription('The total number of frequency errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryTokenErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryTokenErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryTokenErrors.setDescription('The total number of token errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryInBeaconErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryInBeaconErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryInBeaconErrors.setDescription('The total number of beacon frames sent by this station and detected by the probe, during this sampling interval.')
trHistoryOutBeaconErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryOutBeaconErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOutBeaconErrors.setDescription('The total number of beacon frames detected by the probe, that name this station as the NAUN, during this sampling interval.')
trHistoryInsertions = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryInsertions.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryInsertions.setDescription('The number of times the probe detected this station inserting onto the ring during this sampling interval.')
trHistorySoftErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistorySoftErrors.setStatus('mandatory')
if mibBuilder.loadTexts: trHistorySoftErrors.setDescription('The number of soft errors reported by this station in error reporting packets detected by the probe during this sampling interval.')
trHistoryOpaqueTable = MibTable((1, 3, 6, 1, 4, 1, 260, 4, 2, 2), )
if mibBuilder.loadTexts: trHistoryOpaqueTable.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOpaqueTable.setDescription('A list of Token Ring history entries.')
pysmiFakeCol1003 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 2, 1) + (1003, ), Integer32())
pysmiFakeCol1004 = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 2, 1) + (1004, ), Integer32())
trHistoryOpaqueEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 4, 2, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "pysmiFakeCol1003"), (0, "STARTEK-PRIVATE-MIB", "pysmiFakeCol1004"))
if mibBuilder.loadTexts: trHistoryOpaqueEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryOpaqueEntry.setDescription('An historical sample of Token Ring statistics on a particular Token Ring interface. This sample is associated with the historyControlEntry which set up the parameters for a regular collection of these samples.')
trHistoryTableData = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 2, 2, 1, 1), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trHistoryTableData.setStatus('mandatory')
if mibBuilder.loadTexts: trHistoryTableData.setDescription('An opaque data structure used for management.')
protocolstatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 260, 4, 3))
protocolData = MibScalar((1, 3, 6, 1, 4, 1, 260, 4, 3, 1), Opaque()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolData.setStatus('mandatory')
if mibBuilder.loadTexts: protocolData.setDescription('An opaque data structure used for data retrival.')
protocolStatsTable = MibTable((1, 3, 6, 1, 4, 1, 260, 4, 3, 2), )
if mibBuilder.loadTexts: protocolStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: protocolStatsTable.setDescription('A list of protocol statistics entries.')
protocolStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 260, 4, 3, 2, 1), ).setIndexNames((0, "STARTEK-PRIVATE-MIB", "protocolIfIndex"), (0, "STARTEK-PRIVATE-MIB", "protocolID"))
if mibBuilder.loadTexts: protocolStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: protocolStatsEntry.setDescription('An entry in the protocolStatsTable.')
protocolIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: protocolIfIndex.setDescription('The value of this object uniquely identifies the interface on this remote network monitoring device on which this station was detected. The interface identified by a particular value of this object is the same interface as identified by the same value of the ifindex object, defined in [4,6].')
protocolID = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82))).clone(namedValues=NamedValues(("all-packets", 1), ("unknown-protocols", 2), ("ieee8025-mac-protocol", 3), ("ieee8025-source-routed-packets", 4), ("ieee8025-nonsource-routed-packets", 5), ("dix-ethernet-packets", 6), ("ieee8022-llc-protocol", 7), ("ieee8022-llc-snap", 8), ("ip", 9), ("ip-icmp", 10), ("ip-gcp", 11), ("ip-tcp", 12), ("ip-egp", 13), ("ip-igp", 14), ("ip-chaos", 15), ("ip-udp", 16), ("ip-tp4", 17), ("ip-other", 18), ("arp", 19), ("netware-ipx", 20), ("llc-null-sap", 21), ("llc-individual-mgmt-sap", 22), ("llc-group-mgmt-sap", 23), ("llc-individual-sna-path-ctrl-sap", 24), ("llc-group-sna-path-ctrl-sap", 25), ("llc-arpanet-ip-sap", 26), ("llc-3com-xns-sap", 27), ("llc-netbios-sap", 28), ("llc-individual-lan-mgmt-sap", 29), ("llc-group-lan-mgmt-sap", 30), ("llc-remote-program-load-sap", 31), ("llc-iso-network-layer-sap", 32), ("llc-global-sap", 33), ("other-llc-sap", 34), ("chaosnet", 35), ("banyan-vines", 36), ("decnet", 37), ("dec-lat", 38), ("dec-lanbridge", 39), ("appletalk", 40), ("xerox-3com", 41), ("ipx-uknown", 42), ("ipx-routinginformationpacket", 43), ("ipx-echopacket", 44), ("ipx-errorpacket", 45), ("ipx-packetexchangeprotocol", 46), ("ipx-sequencedpacketprotocol", 47), ("ipx-netwarecoreprotocol", 48), ("ipx-other", 49), ("ncp", 50), ("ncp-create", 51), ("ncp-request", 52), ("ncp-reply", 53), ("ncp-destroyserviceconnection", 54), ("ncp-requestinprogressresponse", 55), ("ncp-other", 56), ("sap-generalservicequery", 57), ("sap-generalserviceresponse", 58), ("sap-nearestserverquery", 59), ("sap-nearestserverresponse", 60), ("llc-startekdiscovery", 61), ("reserved62", 62), ("reserved63", 63), ("reserved64", 64), ("reserved65", 65), ("reserved66", 66), ("reserved67", 67), ("reserved68", 68), ("reserved69", 69), ("reserved70", 70), ("reserved71", 71), ("reserved72", 72), ("reserved73", 73), ("reserved74", 74), ("reserved75", 75), ("reserved76", 76), ("reserved77", 77), ("reserved78", 78), ("reserved79", 79), ("reserved80", 80), ("reserved81", 81), ("reserved82", 82)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolID.setStatus('mandatory')
if mibBuilder.loadTexts: protocolID.setDescription('The value of this object uniquely identifies the protocol whose counters are tracked by this table entry.')
protocolPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolPkts.setStatus('mandatory')
if mibBuilder.loadTexts: protocolPkts.setDescription('The number of packets received for this protocol.')
protocolOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 260, 4, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: protocolOctets.setStatus('mandatory')
if mibBuilder.loadTexts: protocolOctets.setDescription('The number of octets received for this protocol.')
mibBuilder.exportSymbols("STARTEK-PRIVATE-MIB", trHistoryFrequencyErrors=trHistoryFrequencyErrors, fTRMainRing=fTRMainRing, superStackHubCascadeDownPhDet=superStackHubCascadeDownPhDet, fTRLobeIndex=fTRLobeIndex, fTRMainRingRoNsrtStatus=fTRMainRingRoNsrtStatus, fEthernetTemperatureStatus=fEthernetTemperatureStatus, configParseControl=configParseControl, rmonAgentIBMacBytes=rmonAgentIBMacBytes, stackableHubDataRateState=stackableHubDataRateState, m828HubRoBcnRemStatus=m828HubRoBcnRemStatus, trHistoryOutLineErrors=trHistoryOutLineErrors, rmonAgentIBMacFrames=rmonAgentIBMacFrames, securityStatus=securityStatus, superStackHubRoFTolState=superStackHubRoFTolState, trHistoryOutOctets=trHistoryOutOctets, fChassisIndex=fChassisIndex, superStackHubLobeTable=superStackHubLobeTable, configRS232PortTable=configRS232PortTable, securityMacAddressTableEntry=securityMacAddressTableEntry, superStackHubStackPosition=superStackHubStackPosition, fTRLobePowerStatus=fTRLobePowerStatus, superStackHubIndex=superStackHubIndex, rmonAgentIBMACData7=rmonAgentIBMACData7, stackableHubRoNeighborAddr=stackableHubRoNeighborAddr, fTRMainRingBkPlnNsrtState=fTRMainRingBkPlnNsrtState, protocolStatsEntry=protocolStatsEntry, trHistoryOpaqueEntry=trHistoryOpaqueEntry, trHistoryTableData=trHistoryTableData, protocolPkts=protocolPkts, rmonAgentIBMACData8=rmonAgentIBMACData8, m828HubMgmtStatus=m828HubMgmtStatus, securityLockoutCount=securityLockoutCount, fChassisTableEntry=fChassisTableEntry, m828HubDataRateSwitch=m828HubDataRateSwitch, fTRLobeConnectMacAddr=fTRLobeConnectMacAddr, pysmiFakeCol1001=pysmiFakeCol1001, rmonAgentIBDataBytes=rmonAgentIBDataBytes, fChassisTable=fChassisTable, pysmiFakeCol1003=pysmiFakeCol1003, fTRLobeBkPlnNsrtState=fTRLobeBkPlnNsrtState, trHistoryInBeaconErrors=trHistoryInBeaconErrors, recoveryRetryLimit=recoveryRetryLimit, stackableHubModel=stackableHubModel, fTRMainRingPowerStatus=fTRMainRingPowerStatus, configRS232ConnectionStatus=configRS232ConnectionStatus, fTRMainRingRoNghbrType=fTRMainRingRoNghbrType, superStackHubCascadeDownBcnRemStatus=superStackHubCascadeDownBcnRemStatus, configEPROMSize=configEPROMSize, rmonAgentOOBTableIndex=rmonAgentOOBTableIndex, fChassis=fChassis, m828HubLobeTable=m828HubLobeTable, stackableHubAttachedAgentType=stackableHubAttachedAgentType, stackableHubLobeMacAddr=stackableHubLobeMacAddr, pysmiFakeCol1002=pysmiFakeCol1002, trHistorySoftErrors=trHistorySoftErrors, superStackHubCodeVersion=superStackHubCodeVersion, m828HubCodeVersion=m828HubCodeVersion, fTRLobeTemperatureStatus=fTRLobeTemperatureStatus, fTRLobeAutoRecovControl=fTRLobeAutoRecovControl, rmonAgentMACStatTableData=rmonAgentMACStatTableData, stackableHubRoNsrtStatus=stackableHubRoNsrtStatus, trHistoryInternalErrors=trHistoryInternalErrors, stackableHubDataRateTimeStamp=stackableHubDataRateTimeStamp, stackableHubTableEntry=stackableHubTableEntry, recoveryRetryTimePeriod=recoveryRetryTimePeriod, fTRMainRingLobeBcnRemStatus=fTRMainRingLobeBcnRemStatus, fTRMainRingRiTimeStamp=fTRMainRingRiTimeStamp, fTRMainRingMgmtStatus=fTRMainRingMgmtStatus, trHistoryClaimTokenPkts=trHistoryClaimTokenPkts, configRS232ModemStatus=configRS232ModemStatus, configMonitorMode=configMonitorMode, fEthernet=fEthernet, rmonAgentIBMACData6=rmonAgentIBMACData6, fTRLobeAutoRecovState=fTRLobeAutoRecovState, trHistoryOutPkts=trHistoryOutPkts, fTRLobeAutoRecovMode=fTRLobeAutoRecovMode, stackableHubAutoRecovState=stackableHubAutoRecovState, trHistoryInBurstErrors=trHistoryInBurstErrors, fTRMainRingAutoRecovState=fTRMainRingAutoRecovState, trHistoryTokenErrors=trHistoryTokenErrors, stackableHubMgmtStatus=stackableHubMgmtStatus, fEthernetMgmtStatus=fEthernetMgmtStatus, rmonAgentIBTable=rmonAgentIBTable, stackableHubAutoRecovControl=stackableHubAutoRecovControl, superStackHubRouterPortBcnRemCause=superStackHubRouterPortBcnRemCause, fTRLobeAutoRecovRetries=fTRLobeAutoRecovRetries, mgrIndex=mgrIndex, trHistoryOpaqueTable=trHistoryOpaqueTable, superStackHubAutoRecovState=superStackHubAutoRecovState, fTRMainRingRoMask=fTRMainRingRoMask, pysmiFakeCol1000=pysmiFakeCol1000, stackableHubProxyAgentID=stackableHubProxyAgentID, superStackHubLobePort=superStackHubLobePort, trHistoryOutBurstErrors=trHistoryOutBurstErrors, configRS232PortEntry=configRS232PortEntry, stackableHubLobeNsrtStatus=stackableHubLobeNsrtStatus, configDRAMCount=configDRAMCount, pysmiFakeCol1004=pysmiFakeCol1004, trHistoryOutBeaconErrors=trHistoryOutBeaconErrors, stationstatistics=stationstatistics, security=security, stackableHubTemperatureStatus=stackableHubTemperatureStatus, fTRLobeConnectBcnRemStatus=fTRLobeConnectBcnRemStatus, mgrStatus=mgrStatus, rmonAgentIBMACData2=rmonAgentIBMACData2, mgrCommunity=mgrCommunity, mgrIpAddr=mgrIpAddr, superStackHubAttachedAgentType=superStackHubAttachedAgentType, stackableHubLobeTable=stackableHubLobeTable, fTRLobeConnectBcnRemCause=fTRLobeConnectBcnRemCause, superStackHubRiPhDet=superStackHubRiPhDet, trHistoryAbortErrors=trHistoryAbortErrors, fTRMainRingCodeVersion=fTRMainRingCodeVersion, superStackHubs=superStackHubs, mgrPhysAddr=mgrPhysAddr, superStackHubRouterPortPhDet=superStackHubRouterPortPhDet, stackableHubRiNsrtStatus=stackableHubRiNsrtStatus, fTRLobeSlotIndex=fTRLobeSlotIndex, fTRMainRingAutoRecovControl=fTRMainRingAutoRecovControl, mgrNumber=mgrNumber, stationhistory=stationhistory, fTRMainRingRoFTolState=fTRMainRingRoFTolState, superStackHubRiMask=superStackHubRiMask, superStackHubRouterPortMacAddr=superStackHubRouterPortMacAddr, superStackHubPowerStatus=superStackHubPowerStatus, m828HubRoNsrtStatus=m828HubRoNsrtStatus, superStackHubLobeConfig=superStackHubLobeConfig, stackableHubCodeVersion=stackableHubCodeVersion, rmonAgentIBMACData0=rmonAgentIBMACData0, trHistoryOutBroadcastPkts=trHistoryOutBroadcastPkts, fChassisModel=fChassisModel, rmonAgentOOBTableEntry=rmonAgentOOBTableEntry, superStackHubAttachedAgentState=superStackHubAttachedAgentState, fEthernetSlotIndex=fEthernetSlotIndex, m828RiNeighborType=m828RiNeighborType, configuration=configuration, fTRMainRingProxyAgentID=fTRMainRingProxyAgentID, configMonitorDiags=configMonitorDiags, fTRMainRingSlotIndex=fTRMainRingSlotIndex, superStackHubAttachedAgentControl=superStackHubAttachedAgentControl, fTRMainRingRiNghbrType=fTRMainRingRiNghbrType, protocolID=protocolID, fTRLobeConnectNumber=fTRLobeConnectNumber, protocolOctets=protocolOctets, m828HubLobeMask=m828HubLobeMask, m828HubLobePort=m828HubLobePort, superStackHubTable=superStackHubTable, fTRMainRingAttachedAgentType=fTRMainRingAttachedAgentType, fTRMainRingRoBcnRemStatus=fTRMainRingRoBcnRemStatus, fEthernetTable=fEthernetTable, mgrAutoAge=mgrAutoAge, rmonAgentIBTableIndex=rmonAgentIBTableIndex, m828RoNeighborAddr=m828RoNeighborAddr, configRS232OutputData=configRS232OutputData, stackableHubRoMask=stackableHubRoMask, fTRLobeModel=fTRLobeModel, rmonAgentOOBNumber=rmonAgentOOBNumber, versionHardware=versionHardware, stackableHubRiPhDet=stackableHubRiPhDet, fTRMainRingDataRateState=fTRMainRingDataRateState, trHistoryCongestionErrors=trHistoryCongestionErrors, superStackHub485Address=superStackHub485Address, fTRMainRingRoNghbrAddr=fTRMainRingRoNghbrAddr, rmonAgentMonitorCommand=rmonAgentMonitorCommand, fTRLobeRawCommandData=fTRLobeRawCommandData, protocolStatsTable=protocolStatsTable, fEthernetNumber=fEthernetNumber, m828HubDataRateState=m828HubDataRateState, fEthernetCageType=fEthernetCageType, m828HubRiNsrtStatus=m828HubRiNsrtStatus, fTRMainRingLobeTimeStamp=fTRMainRingLobeTimeStamp, rmonAgentIBMACData3=rmonAgentIBMACData3, rmonAgentIBMACData9=rmonAgentIBMACData9, fTRLobeDataRateTimeStamp=fTRLobeDataRateTimeStamp, superStackHubRoMask=superStackHubRoMask, stackableHubAutoRecovRetries=stackableHubAutoRecovRetries, fTRMainRingLobePhDet=fTRMainRingLobePhDet, fTRLobeMgmtStatus=fTRLobeMgmtStatus, m828RoNeighborType=m828RoNeighborType, fEthernetBkPlnTimeStamp=fEthernetBkPlnTimeStamp, superStackHubDeviceTimeStamp=superStackHubDeviceTimeStamp, trHistoryTable=trHistoryTable, rmonAgentIBMACData1=rmonAgentIBMACData1, fTRMainRingAutoRecovRetries=fTRMainRingAutoRecovRetries, m828HubRiBcnRemStatus=m828HubRiBcnRemStatus, fTRMainRingRoPhDet=fTRMainRingRoPhDet, recovery828Support=recovery828Support, fTRLobeTableIndex=fTRLobeTableIndex, stackableHubRiNeighborType=stackableHubRiNeighborType, fTRMainRingCageType=fTRMainRingCageType, versions=versions, fTRMainRingRawCommandData=fTRMainRingRawCommandData, m828HubTableEntry=m828HubTableEntry, rmonAgentIBSampleInterval=rmonAgentIBSampleInterval, rmonAgentIBMACData11=rmonAgentIBMACData11, superStackHubRiBcnRemStatus=superStackHubRiBcnRemStatus, fTRLobeTableEntry=fTRLobeTableEntry, fTRLobeConnectEntry=fTRLobeConnectEntry, trHistoryIntervalStart=trHistoryIntervalStart, trHistoryInsertions=trHistoryInsertions, configBootSource=configBootSource, rmonAgentNoMapOid=rmonAgentNoMapOid, mgrAgeInterval=mgrAgeInterval, versionFLASHFirmware=versionFLASHFirmware, stackableHubRiBcnRemStatus=stackableHubRiBcnRemStatus, m828HubIndex=m828HubIndex, rmonextns=rmonextns, rmonAgentIBTableDescription=rmonAgentIBTableDescription, fTRMainRingAutoRecovMode=fTRMainRingAutoRecovMode, fChassisPowStatus=fChassisPowStatus, mgrEntry=mgrEntry, fTRLobeCageType=fTRLobeCageType, fTwx=fTwx, m828HubLobeTimeStamp=m828HubLobeTimeStamp, protocolData=protocolData, fTRLobeChassisIndex=fTRLobeChassisIndex, stackableHubRiMask=stackableHubRiMask, superStackHubLobePhDet=superStackHubLobePhDet, stackableHubIndex=stackableHubIndex, m828Hubs=m828Hubs, products=products, m828RiTimeStamp=m828RiTimeStamp, superStackHubRawCommandData=superStackHubRawCommandData, stackableHubRoFTolState=stackableHubRoFTolState, fEthernetModel=fEthernetModel, stackableHubNumber=stackableHubNumber, fEthernetTableEntry=fEthernetTableEntry, superStackHubCascadeUpBcnRemStatus=superStackHubCascadeUpBcnRemStatus, fSeries=fSeries, m828HubProxyAgentID=m828HubProxyAgentID, configRS232InputData=configRS232InputData, trHistoryFrameCopiedErrors=trHistoryFrameCopiedErrors, fTRMainRingRiFTolState=fTRMainRingRiFTolState, superStackHubLobeBcnRemCause=superStackHubLobeBcnRemCause, fTRMainRingModel=fTRMainRingModel, fEthernet485Address=fEthernet485Address, fTRMainRingLobeNsrtStatus=fTRMainRingLobeNsrtStatus, fTRMainRingRiPhDet=fTRMainRingRiPhDet, superStackHubCascadeUpMask=superStackHubCascadeUpMask, configRS232PortIndex=configRS232PortIndex, fEthernetPowerStatus=fEthernetPowerStatus, securityMacAddressTable=securityMacAddressTable, fTRMainRingRiMask=fTRMainRingRiMask, fTRMainRingRiNsrtStatus=fTRMainRingRiNsrtStatus, configRS232Number=configRS232Number, rmonAgentIBUtilization=rmonAgentIBUtilization, rmonAgentIBNonMACUtilization=rmonAgentIBNonMACUtilization, trHistoryLostFrameErrors=trHistoryLostFrameErrors, superStackHubAutoRecovMode=superStackHubAutoRecovMode, m828RiNeighborAddr=m828RiNeighborAddr, fTRLobeConnectTable=fTRLobeConnectTable, fTRMainRingRiBcnRemStatus=fTRMainRingRiBcnRemStatus, superStackHubRouterPortNsrtStatus=superStackHubRouterPortNsrtStatus, stackableHubTableIndex=stackableHubTableIndex)
mibBuilder.exportSymbols("STARTEK-PRIVATE-MIB", rmonAgentID=rmonAgentID, m828HubTable=m828HubTable, rmonAgentMACStatTable=rmonAgentMACStatTable, fTRLobeCodeVersion=fTRLobeCodeVersion, superStackHubLobeMask=superStackHubLobeMask, fEthernetBkPlnNsrtState=fEthernetBkPlnNsrtState, recoveryControl=recoveryControl, m828HubRawCommandData=m828HubRawCommandData, fEthernetRawCommandData=fEthernetRawCommandData, superStackHubLobeBcnRemStatus=superStackHubLobeBcnRemStatus, rmonAgentIBMACData5=rmonAgentIBMACData5, fFddi=fFddi, fTRLobeNumber=fTRLobeNumber, mgrAutoAdd=mgrAutoAdd, stackableHubLobeBcnRemCause=stackableHubLobeBcnRemCause, configFLASHSize=configFLASHSize, fEthernetChassisIndex=fEthernetChassisIndex, rmonAgentDescription=rmonAgentDescription, rmonAgentIBMACUtilization=rmonAgentIBMACUtilization, stackableHubLobeNumber=stackableHubLobeNumber, superStackHubCascadeDownMask=superStackHubCascadeDownMask, superStackHubRoNsrtStatus=superStackHubRoNsrtStatus, superStackHubTableIndex=superStackHubTableIndex, configFLASHCount=configFLASHCount, configMonitorInput=configMonitorInput, trHistorySampleIndex=trHistorySampleIndex, fTRLobeConnectMask=fTRLobeConnectMask, rmonAgentOOBTable=rmonAgentOOBTable, fTRLobe=fTRLobe, m828HubLobeBcnRemStatus=m828HubLobeBcnRemStatus, stackableHub485Address=stackableHub485Address, rmonAgentIBNetworkType=rmonAgentIBNetworkType, stackableHubAttachedAgentState=stackableHubAttachedAgentState, stackableHubLobeTimeStamp=stackableHubLobeTimeStamp, superStackHubMgmtStatus=superStackHubMgmtStatus, rmonAgentDownloadData=rmonAgentDownloadData, m828HubRiMask=m828HubRiMask, m828HubLobeNsrtStatus=m828HubLobeNsrtStatus, trHistoryOutMulticastPkts=trHistoryOutMulticastPkts, trHistoryInLineErrors=trHistoryInLineErrors, m828HubTableIndex=m828HubTableIndex, trHistoryInPkts=trHistoryInPkts, managers=managers, fEthernetTableIndex=fEthernetTableIndex, m828HubRiFTolSw=m828HubRiFTolSw, stackableHubLobeEntry=stackableHubLobeEntry, configRS232HardwareFlowControl=configRS232HardwareFlowControl, fTRMainRingDataRateTimeStamp=fTRMainRingDataRateTimeStamp, rmonAgentIBNumber=rmonAgentIBNumber, superStackHubCascadeDownNsrtStatus=superStackHubCascadeDownNsrtStatus, fTRMainRingAttachedAgentState=fTRMainRingAttachedAgentState, stackableHubs=stackableHubs, startek=startek, m828HubNumber=m828HubNumber, superStackHubRoBcnRemStatus=superStackHubRoBcnRemStatus, m828HubRoPhDet=m828HubRoPhDet, rmonAgentIPAdressControl=rmonAgentIPAdressControl, stackableHubRoNeighborType=stackableHubRoNeighborType, fTRMainRingRiCableType=fTRMainRingRiCableType, m828HubDataRateTimeStamp=m828HubDataRateTimeStamp, superStackHubProxyAgentID=superStackHubProxyAgentID, rmonAgentOOBTableData=rmonAgentOOBTableData, recovery=recovery, fTRLobeBkPlnTimeStamp=fTRLobeBkPlnTimeStamp, rmonAgentMACStatTableEntry=rmonAgentMACStatTableEntry, rmonAgentOOBTableDescription=rmonAgentOOBTableDescription, protocolIfIndex=protocolIfIndex, fTRLobe485Address=fTRLobe485Address, superStackHubTableEntry=superStackHubTableEntry, m828HubRoFTolSw=m828HubRoFTolSw, rmonAgentIBMACData4=rmonAgentIBMACData4, superStackHubCascadeUpNsrtStatus=superStackHubCascadeUpNsrtStatus, stackableHubRoTimeStamp=stackableHubRoTimeStamp, securityMacAddress=securityMacAddress, stackableHubRiFTolState=stackableHubRiFTolState, stackableHubAutoRecovMode=stackableHubAutoRecovMode, superStackRoConfiguration=superStackRoConfiguration, fTRLobeDataRateState=fTRLobeDataRateState, superStackHubRouterPortMask=superStackHubRouterPortMask, m828HubLobeNumber=m828HubLobeNumber, fTRMainRingTableEntry=fTRMainRingTableEntry, stackableHubTable=stackableHubTable, trHistoryACErrors=trHistoryACErrors, superStackHubAutoRecovControl=superStackHubAutoRecovControl, stackableHubRiNeighborAddr=stackableHubRiNeighborAddr, versionEPROMFirmware=versionEPROMFirmware, fTRMainRingTable=fTRMainRingTable, fTRMainRingRoTimeStamp=fTRMainRingRoTimeStamp, m828HubRiFTolState=m828HubRiFTolState, superStackHubCascadeUpPhDet=superStackHubCascadeUpPhDet, stackableHubRiTimeStamp=stackableHubRiTimeStamp, m828Hub485Address=m828Hub485Address, fTRMainRingTemperatureStatus=fTRMainRingTemperatureStatus, stackableHubLobeBcnRemStatus=stackableHubLobeBcnRemStatus, stackable=stackable, m828HubModel=m828HubModel, securityControl=securityControl, superStackHubLobeMacAddr=superStackHubLobeMacAddr, superStackHubLobeNumber=superStackHubLobeNumber, configRS232ModemConfigString=configRS232ModemConfigString, rmonAgentIBTableEntry=rmonAgentIBTableEntry, mgrTimeStamp=mgrTimeStamp, superStackHubAutoRecovRetries=superStackHubAutoRecovRetries, fTRMainRingRiNghbrAddr=fTRMainRingRiNghbrAddr, fChassisNumber=fChassisNumber, rmonAgentMonitorResponse=rmonAgentMonitorResponse, superStackHubLobeNsrtStatus=superStackHubLobeNsrtStatus, maintenance=maintenance, stackableHubRoPhDet=stackableHubRoPhDet, configRS232BaudRate=configRS232BaudRate, fTRLobeConnectPort=fTRLobeConnectPort, rmonAgentOOBRawDataCommand=rmonAgentOOBRawDataCommand, mgrTable=mgrTable, fTRMainRingNumber=fTRMainRingNumber, m828HubRiPhDet=m828HubRiPhDet, rmonAgentIBMACData10=rmonAgentIBMACData10, m828HubRoFTolState=m828HubRoFTolState, trHistoryEntry=trHistoryEntry, trHistoryIndex=trHistoryIndex, fTRMainRingTableIndex=fTRMainRingTableIndex, protocolstatistics=protocolstatistics, superStackHubLobeEntry=superStackHubLobeEntry, rmonAgentIBDataFrames=rmonAgentIBDataFrames, fEthernetCodeVersion=fEthernetCodeVersion, configDRAMSize=configDRAMSize, m828HubLobeMacAddr=m828HubLobeMacAddr, superStackHubRoPhDet=superStackHubRoPhDet, fTRLobeTable=fTRLobeTable, stackableHubRoBcnRemStatus=stackableHubRoBcnRemStatus, fTRMainRingRoCableType=fTRMainRingRoCableType, stackableHubRawCommandData=stackableHubRawCommandData, stackableHubLobePhDet=stackableHubLobePhDet, m828Series=m828Series, fTRMainRingBkPlnTimeStamp=fTRMainRingBkPlnTimeStamp, configRS232PortName=configRS232PortName, fTRMainRing485Address=fTRMainRing485Address, fTRMainRingLobeMask=fTRMainRingLobeMask, m828HubRoMask=m828HubRoMask, fTRMainRingChassisIndex=fTRMainRingChassisIndex, superStackHubNumber=superStackHubNumber, superStackHubDataRateState=superStackHubDataRateState, rmonAgent=rmonAgent, fTRMainRingLobeMacAddr=fTRMainRingLobeMacAddr, trHistoryInOctets=trHistoryInOctets, superStackHubModel=superStackHubModel, superStackHubRouterPortBcnRemStatus=superStackHubRouterPortBcnRemStatus, superStackHubRiFTolState=superStackHubRiFTolState, m828RoTimeStamp=m828RoTimeStamp, m828HubLobeEntry=m828HubLobeEntry, mgrInterfaceIndex=mgrInterfaceIndex, superStackHubRiNsrtStatus=superStackHubRiNsrtStatus, fTRLobeProxyAgentID=fTRLobeProxyAgentID, m828HubLobePhDet=m828HubLobePhDet, fTRLobeConnectPhDet=fTRLobeConnectPhDet, fTRLobeConnectNsrtStatus=fTRLobeConnectNsrtStatus, fEthernetProxyAgentID=fEthernetProxyAgentID, stackableHubLobePort=stackableHubLobePort, stackableHubLobeMask=stackableHubLobeMask, superStackRiConfiguration=superStackRiConfiguration, superStackHubTemperatureStatus=superStackHubTemperatureStatus, fChassisLocation=fChassisLocation, fTRLobeConnectTimeStamp=fTRLobeConnectTimeStamp)

#
# PySNMP MIB module DNS-RESOLVER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DNS-RESOLVER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:22:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint")
DnsNameAsIndex, dns, DnsType, DnsOpCode, DnsTime, DnsName, DnsClass = mibBuilder.importSymbols("DNS-SERVER-MIB", "DnsNameAsIndex", "dns", "DnsType", "DnsOpCode", "DnsTime", "DnsName", "DnsClass")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
TimeTicks, iso, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Integer32, Bits, MibIdentifier, ObjectIdentity, NotificationType, Gauge32, Counter32, IpAddress, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "iso", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Integer32", "Bits", "MibIdentifier", "ObjectIdentity", "NotificationType", "Gauge32", "Counter32", "IpAddress", "ModuleIdentity")
RowStatus, TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "TextualConvention", "DisplayString")
dnsResMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 32, 2))
if mibBuilder.loadTexts: dnsResMIB.setLastUpdated('9401282250Z')
if mibBuilder.loadTexts: dnsResMIB.setOrganization('IETF DNS Working Group')
if mibBuilder.loadTexts: dnsResMIB.setContactInfo(' Rob Austein Postal: Epilogue Technology Corporation 268 Main Street, Suite 283 North Reading, MA 10864 US Tel: +1 617 245 0804 Fax: +1 617 245 8122 E-Mail: sra@epilogue.com Jon Saperia Postal: Digital Equipment Corporation 110 Spit Brook Road ZKO1-3/H18 Nashua, NH 03062-2698 US Tel: +1 603 881 0480 Fax: +1 603 881 0120 E-mail: saperia@zko.dec.com')
if mibBuilder.loadTexts: dnsResMIB.setDescription('The MIB module for entities implementing the client (resolver) side of the Domain Name System (DNS) protocol.')
dnsResMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 1))
dnsResConfig = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 1, 1))
dnsResCounter = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 1, 2))
dnsResLameDelegation = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 1, 3))
dnsResCache = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 1, 4))
dnsResNCache = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 1, 5))
dnsResOptCounter = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 1, 6))
class DnsQClass(TextualConvention, Integer32):
    reference = 'RFC-1035 section 3.2.5.'
    description = 'This data type is used to represent the QClass values which appear in Resource Records in the DNS. A 16-bit unsigned integer is used to allow room for new QClass records to be defined. Existing standard QClasses are listed in the DNS specification.'
    status = 'current'
    displayHint = '2d'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class DnsQType(TextualConvention, Integer32):
    reference = 'RFC-1035 section 3.2.3.'
    description = 'This data type is used to represent the QType values which appear in Resource Records in the DNS. A 16-bit unsigned integer is used to allow room for new QType records to be defined. Existing standard QTypes are listed in the DNS specification.'
    status = 'current'
    displayHint = '2d'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

class DnsRespCode(TextualConvention, Integer32):
    reference = 'RFC-1035 section 4.1.1.'
    description = 'This data type is used to represent the DNS RCODE value in DNS response messages. Existing standard RCODE values are listed in the DNS specifications.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 15)

dnsResConfigImplementIdent = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResConfigImplementIdent.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigImplementIdent.setDescription("The implementation identification string for the resolver software in use on the system, for example; `RES-2.1'")
dnsResConfigService = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("recursiveOnly", 1), ("iterativeOnly", 2), ("recursiveAndIterative", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResConfigService.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigService.setDescription('Kind of DNS resolution service provided: recursiveOnly(1) indicates a stub resolver. iterativeOnly(2) indicates a normal full service resolver. recursiveAndIterative(3) indicates a full-service resolver which performs a mix of recursive and iterative queries.')
dnsResConfigMaxCnames = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResConfigMaxCnames.setReference('RFC-1035 section 7.1.')
if mibBuilder.loadTexts: dnsResConfigMaxCnames.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigMaxCnames.setDescription("Limit on how many CNAMEs the resolver should allow before deciding that there's a CNAME loop. Zero means that resolver has no explicit CNAME limit.")
dnsResConfigSbeltTable = MibTable((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4), )
if mibBuilder.loadTexts: dnsResConfigSbeltTable.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltTable.setDescription("Table of safety belt information used by the resolver when it hasn't got any better idea of where to send a query, such as when the resolver is booting or is a stub resolver.")
dnsResConfigSbeltEntry = MibTableRow((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1), ).setIndexNames((0, "DNS-RESOLVER-MIB", "dnsResConfigSbeltAddr"), (0, "DNS-RESOLVER-MIB", "dnsResConfigSbeltSubTree"), (0, "DNS-RESOLVER-MIB", "dnsResConfigSbeltClass"))
if mibBuilder.loadTexts: dnsResConfigSbeltEntry.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltEntry.setDescription("An entry in the resolver's Sbelt table. Rows may be created or deleted at any time by the DNS resolver and by SNMP SET requests. Whether the values changed via SNMP are saved in stable storage across `reset' operations is implementation-specific.")
dnsResConfigSbeltAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1, 1), IpAddress())
if mibBuilder.loadTexts: dnsResConfigSbeltAddr.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltAddr.setDescription('The IP address of the Sbelt name server identified by this row of the table.')
dnsResConfigSbeltName = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1, 2), DnsName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dnsResConfigSbeltName.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltName.setDescription('The DNS name of a Sbelt nameserver identified by this row of the table. A zero-length string indicates that the name is not known by the resolver.')
dnsResConfigSbeltRecursion = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("iterative", 1), ("recursive", 2), ("recursiveAndIterative", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dnsResConfigSbeltRecursion.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltRecursion.setDescription('Kind of queries resolver will be sending to the name server identified in this row of the table: iterative(1) indicates that resolver will be directing iterative queries to this name server (RD bit turned off). recursive(2) indicates that resolver will be directing recursive queries to this name server (RD bit turned on). recursiveAndIterative(3) indicates that the resolver will be directing both recursive and iterative queries to the server identified in this row of the table.')
dnsResConfigSbeltPref = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dnsResConfigSbeltPref.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltPref.setDescription('This value identifies the preference for the name server identified in this row of the table. The lower the value, the more desirable the resolver considers this server.')
dnsResConfigSbeltSubTree = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1, 5), DnsNameAsIndex())
if mibBuilder.loadTexts: dnsResConfigSbeltSubTree.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltSubTree.setDescription('Queries sent to the name server identified by this row of the table are limited to those for names in the name subtree identified by this variable. If no such limitation applies, the value of this variable is the name of the root domain (a DNS name consisting of a single zero octet).')
dnsResConfigSbeltClass = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1, 6), DnsClass())
if mibBuilder.loadTexts: dnsResConfigSbeltClass.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltClass.setDescription('The class of DNS queries that will be sent to the server identified by this row of the table.')
dnsResConfigSbeltStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 4, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: dnsResConfigSbeltStatus.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigSbeltStatus.setDescription('Row status column for this row of the Sbelt table.')
dnsResConfigUpTime = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 5), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResConfigUpTime.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigUpTime.setDescription('If the resolver has a persistent state (e.g., a process), this value will be the time elapsed since it started. For software without persistant state, this value will be 0.')
dnsResConfigResetTime = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 6), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResConfigResetTime.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigResetTime.setDescription("If the resolver has a persistent state (e.g., a process) and supports a `reset' operation (e.g., can be told to re-read configuration files), this value will be the time elapsed since the last time the resolver was `reset.' For software that does not have persistence or does not support a `reset' operation, this value will be zero.")
dnsResConfigReset = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("reset", 2), ("initializing", 3), ("running", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResConfigReset.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigReset.setDescription('Status/action object to reinitialize any persistant resolver state. When set to reset(2), any persistant resolver state (such as a process) is reinitialized as if the resolver had just been started. This value will never be returned by a read operation. When read, one of the following values will be returned: other(1) - resolver in some unknown state; initializing(3) - resolver (re)initializing; running(4) - resolver currently running.')
dnsResCounterByOpcodeTable = MibTable((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 3), )
if mibBuilder.loadTexts: dnsResCounterByOpcodeTable.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByOpcodeTable.setDescription('Table of the current count of resolver queries and answers.')
dnsResCounterByOpcodeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 3, 1), ).setIndexNames((0, "DNS-RESOLVER-MIB", "dnsResCounterByOpcodeCode"))
if mibBuilder.loadTexts: dnsResCounterByOpcodeEntry.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByOpcodeEntry.setDescription('Entry in the resolver counter table. Entries are indexed by DNS OpCode.')
dnsResCounterByOpcodeCode = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 3, 1, 1), DnsOpCode())
if mibBuilder.loadTexts: dnsResCounterByOpcodeCode.setReference('RFC-1035 section 4.1.1.')
if mibBuilder.loadTexts: dnsResCounterByOpcodeCode.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByOpcodeCode.setDescription('The index to this table. The OpCodes that have already been defined are found in RFC-1035.')
dnsResCounterByOpcodeQueries = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterByOpcodeQueries.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByOpcodeQueries.setDescription('Total number of queries that have sent out by the resolver since initialization for the OpCode which is the index to this row of the table.')
dnsResCounterByOpcodeResponses = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterByOpcodeResponses.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByOpcodeResponses.setDescription('Total number of responses that have been received by the resolver since initialization for the OpCode which is the index to this row of the table.')
dnsResCounterByRcodeTable = MibTable((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 4), )
if mibBuilder.loadTexts: dnsResCounterByRcodeTable.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByRcodeTable.setDescription('Table of the current count of responses to resolver queries.')
dnsResCounterByRcodeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 4, 1), ).setIndexNames((0, "DNS-RESOLVER-MIB", "dnsResCounterByRcodeCode"))
if mibBuilder.loadTexts: dnsResCounterByRcodeEntry.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByRcodeEntry.setDescription('Entry in the resolver response table. Entries are indexed by DNS response code.')
dnsResCounterByRcodeCode = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 4, 1, 1), DnsRespCode())
if mibBuilder.loadTexts: dnsResCounterByRcodeCode.setReference('RFC-1035 section 4.1.1.')
if mibBuilder.loadTexts: dnsResCounterByRcodeCode.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByRcodeCode.setDescription('The index to this table. The Response Codes that have already been defined are found in RFC-1035.')
dnsResCounterByRcodeResponses = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 4, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterByRcodeResponses.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterByRcodeResponses.setDescription('Number of responses the resolver has received for the response code value which identifies this row of the table.')
dnsResCounterNonAuthDataResps = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterNonAuthDataResps.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterNonAuthDataResps.setDescription('Number of requests made by the resolver for which a non-authoritative answer (cached data) was received.')
dnsResCounterNonAuthNoDataResps = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterNonAuthNoDataResps.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterNonAuthNoDataResps.setDescription('Number of requests made by the resolver for which a non-authoritative answer - no such data response (empty answer) was received.')
dnsResCounterMartians = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterMartians.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterMartians.setDescription('Number of responses received which were received from servers that the resolver does not think it asked.')
dnsResCounterRecdResponses = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterRecdResponses.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterRecdResponses.setDescription('Number of responses received to all queries.')
dnsResCounterUnparseResps = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterUnparseResps.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterUnparseResps.setDescription('Number of responses received which were unparseable.')
dnsResCounterFallbacks = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCounterFallbacks.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterFallbacks.setDescription('Number of times the resolver had to fall back to its seat belt information.')
dnsResLameDelegationOverflows = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResLameDelegationOverflows.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationOverflows.setDescription('Number of times the resolver attempted to add an entry to the Lame Delegation table but was unable to for some reason such as space constraints.')
dnsResLameDelegationTable = MibTable((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 2), )
if mibBuilder.loadTexts: dnsResLameDelegationTable.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationTable.setDescription('Table of name servers returning lame delegations. A lame delegation has occured when a parent zone delegates authority for a child zone to a server that appears not to think that it is authoritative for the child zone in question.')
dnsResLameDelegationEntry = MibTableRow((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 2, 1), ).setIndexNames((0, "DNS-RESOLVER-MIB", "dnsResLameDelegationSource"), (0, "DNS-RESOLVER-MIB", "dnsResLameDelegationName"), (0, "DNS-RESOLVER-MIB", "dnsResLameDelegationClass"))
if mibBuilder.loadTexts: dnsResLameDelegationEntry.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationEntry.setDescription('Entry in lame delegation table. Only the resolver may create rows in this table. SNMP SET requests may be used to delete rows.')
dnsResLameDelegationSource = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 2, 1, 1), IpAddress())
if mibBuilder.loadTexts: dnsResLameDelegationSource.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationSource.setDescription('Source of lame delegation.')
dnsResLameDelegationName = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 2, 1, 2), DnsNameAsIndex())
if mibBuilder.loadTexts: dnsResLameDelegationName.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationName.setDescription('DNS name for which lame delegation was received.')
dnsResLameDelegationClass = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 2, 1, 3), DnsClass())
if mibBuilder.loadTexts: dnsResLameDelegationClass.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationClass.setDescription('DNS class of received lame delegation.')
dnsResLameDelegationCounts = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResLameDelegationCounts.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationCounts.setDescription('How many times this lame delegation has been received.')
dnsResLameDelegationStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 3, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResLameDelegationStatus.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationStatus.setDescription('Status column for the lame delegation table. Since only the agent (DNS resolver) creates rows in this table, the only values that a manager may write to this variable are active(1) and destroy(6).')
dnsResCacheStatus = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResCacheStatus.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheStatus.setDescription("Status/action for the resolver's cache. enabled(1) means that the use of the cache is allowed. Query operations can return this state. disabled(2) means that the cache is not being used. Query operations can return this state. Setting this variable to clear(3) deletes the entire contents of the resolver's cache, but does not otherwise change the resolver's state. The status will retain its previous value from before the clear operation (i.e., enabled(1) or disabled(2)). The value of clear(3) can NOT be returned by a query operation.")
dnsResCacheMaxTTL = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 2), DnsTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResCacheMaxTTL.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheMaxTTL.setDescription('Maximum Time-To-Live for RRs in this cache. If the resolver does not implement a TTL ceiling, the value of this field should be zero.')
dnsResCacheGoodCaches = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheGoodCaches.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheGoodCaches.setDescription('Number of RRs the resolver has cached successfully.')
dnsResCacheBadCaches = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheBadCaches.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheBadCaches.setDescription("Number of RRs the resolver has refused to cache because they appear to be dangerous or irrelevant. E.g., RRs with suspiciously high TTLs, unsolicited root information, or that just don't appear to be relevant to the question the resolver asked.")
dnsResCacheRRTable = MibTable((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5), )
if mibBuilder.loadTexts: dnsResCacheRRTable.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRTable.setDescription("This table contains information about all the resource records currently in the resolver's cache.")
dnsResCacheRREntry = MibTableRow((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1), ).setIndexNames((0, "DNS-RESOLVER-MIB", "dnsResCacheRRName"), (0, "DNS-RESOLVER-MIB", "dnsResCacheRRClass"), (0, "DNS-RESOLVER-MIB", "dnsResCacheRRType"), (0, "DNS-RESOLVER-MIB", "dnsResCacheRRIndex"))
if mibBuilder.loadTexts: dnsResCacheRREntry.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRREntry.setDescription("An entry in the resolvers's cache. Rows may be created only by the resolver. SNMP SET requests may be used to delete rows.")
dnsResCacheRRName = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: dnsResCacheRRName.setReference('RFC-1034 section 3.6.')
if mibBuilder.loadTexts: dnsResCacheRRName.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRName.setDescription('Owner name of the Resource Record in the cache which is identified in this row of the table. As described in RFC-1034, the owner of the record is the domain name were the RR is found.')
dnsResCacheRRClass = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 2), DnsClass())
if mibBuilder.loadTexts: dnsResCacheRRClass.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRClass.setDescription('DNS class of the Resource Record in the cache which is identified in this row of the table.')
dnsResCacheRRType = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 3), DnsType())
if mibBuilder.loadTexts: dnsResCacheRRType.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRType.setDescription('DNS type of the Resource Record in the cache which is identified in this row of the table.')
dnsResCacheRRTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 4), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRTTL.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRTTL.setDescription('Time-To-Live of RR in DNS cache. This is the initial TTL value which was received with the RR when it was originally received.')
dnsResCacheRRElapsedTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 5), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRElapsedTTL.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRElapsedTTL.setDescription('Elapsed seconds since RR was received.')
dnsResCacheRRSource = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRSource.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRSource.setDescription('Host from which RR was received, 0.0.0.0 if unknown.')
dnsResCacheRRData = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRData.setReference('RFC-1035 section 3.2.1.')
if mibBuilder.loadTexts: dnsResCacheRRData.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRData.setDescription('RDATA portion of a cached RR. The value is in the format defined for the particular DNS class and type of the resource record.')
dnsResCacheRRStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResCacheRRStatus.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRStatus.setDescription('Status column for the resolver cache table. Since only the agent (DNS resolver) creates rows in this table, the only values that a manager may write to this variable are active(1) and destroy(6).')
dnsResCacheRRIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 9), Integer32())
if mibBuilder.loadTexts: dnsResCacheRRIndex.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRIndex.setDescription('A value which makes entries in the table unique when the other index values (dnsResCacheRRName, dnsResCacheRRClass, and dnsResCacheRRType) do not provide a unique index.')
dnsResCacheRRPrettyName = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 4, 5, 1, 10), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResCacheRRPrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: dnsResCacheRRPrettyName.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheRRPrettyName.setDescription('Name of the RR at this row in the table. This is identical to the dnsResCacheRRName variable, except that character case is preserved in this variable, per DNS conventions.')
dnsResNCacheStatus = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResNCacheStatus.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheStatus.setDescription("Status/action for the resolver's negative response cache. enabled(1) means that the use of the negative response cache is allowed. Query operations can return this state. disabled(2) means that the negative response cache is not being used. Query operations can return this state. Setting this variable to clear(3) deletes the entire contents of the resolver's negative response cache. The status will retain its previous value from before the clear operation (i.e., enabled(1) or disabled(2)). The value of clear(3) can NOT be returned by a query operation.")
dnsResNCacheMaxTTL = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 2), DnsTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResNCacheMaxTTL.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheMaxTTL.setDescription('Maximum Time-To-Live for cached authoritative errors. If the resolver does not implement a TTL ceiling, the value of this field should be zero.')
dnsResNCacheGoodNCaches = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheGoodNCaches.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheGoodNCaches.setDescription('Number of authoritative errors the resolver has cached successfully.')
dnsResNCacheBadNCaches = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheBadNCaches.setReference('RFC-1034 section 4.3.4.')
if mibBuilder.loadTexts: dnsResNCacheBadNCaches.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheBadNCaches.setDescription('Number of authoritative errors the resolver would have liked to cache but was unable to because the appropriate SOA RR was not supplied or looked suspicious.')
dnsResNCacheErrTable = MibTable((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5), )
if mibBuilder.loadTexts: dnsResNCacheErrTable.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrTable.setDescription("The resolver's negative response cache. This table contains information about authoritative errors that have been cached by the resolver.")
dnsResNCacheErrEntry = MibTableRow((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1), ).setIndexNames((0, "DNS-RESOLVER-MIB", "dnsResNCacheErrQName"), (0, "DNS-RESOLVER-MIB", "dnsResNCacheErrQClass"), (0, "DNS-RESOLVER-MIB", "dnsResNCacheErrQType"), (0, "DNS-RESOLVER-MIB", "dnsResNCacheErrIndex"))
if mibBuilder.loadTexts: dnsResNCacheErrEntry.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrEntry.setDescription("An entry in the resolver's negative response cache table. Only the resolver can create rows. SNMP SET requests may be used to delete rows.")
dnsResNCacheErrQName = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 1), DnsNameAsIndex())
if mibBuilder.loadTexts: dnsResNCacheErrQName.setReference('RFC-1034 section 3.7.1.')
if mibBuilder.loadTexts: dnsResNCacheErrQName.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrQName.setDescription('QNAME associated with a cached authoritative error.')
dnsResNCacheErrQClass = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 2), DnsQClass())
if mibBuilder.loadTexts: dnsResNCacheErrQClass.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrQClass.setDescription('DNS QCLASS associated with a cached authoritative error.')
dnsResNCacheErrQType = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 3), DnsQType())
if mibBuilder.loadTexts: dnsResNCacheErrQType.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrQType.setDescription('DNS QTYPE associated with a cached authoritative error.')
dnsResNCacheErrTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 4), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheErrTTL.setReference('RFC-1034 section 4.3.4.')
if mibBuilder.loadTexts: dnsResNCacheErrTTL.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrTTL.setDescription('Time-To-Live of a cached authoritative error at the time of the error, it should not be decremented by the number of seconds since it was received. This should be the TTL as copied from the MINIMUM field of the SOA that accompanied the authoritative error, or a smaller value if the resolver implements a ceiling on negative response cache TTLs.')
dnsResNCacheErrElapsedTTL = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 5), DnsTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheErrElapsedTTL.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrElapsedTTL.setDescription('Elapsed seconds since authoritative error was received.')
dnsResNCacheErrSource = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheErrSource.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrSource.setDescription('Host which sent the authoritative error, 0.0.0.0 if unknown.')
dnsResNCacheErrCode = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nonexistantName", 1), ("noData", 2), ("other", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheErrCode.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrCode.setDescription('The authoritative error that has been cached: nonexistantName(1) indicates an authoritative name error (RCODE = 3). noData(2) indicates an authoritative response with no error (RCODE = 0) and no relevant data. other(3) indicates some other cached authoritative error. At present, no such errors are known to exist.')
dnsResNCacheErrStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dnsResNCacheErrStatus.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrStatus.setDescription('Status column for the resolver negative response cache table. Since only the agent (DNS resolver) creates rows in this table, the only values that a manager may write to this variable are active(1) and destroy(6).')
dnsResNCacheErrIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheErrIndex.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrIndex.setDescription('A value which makes entries in the table unique when the other index values (dnsResNCacheErrQName, dnsResNCacheErrQClass, and dnsResNCacheErrQType) do not provide a unique index.')
dnsResNCacheErrPrettyName = MibTableColumn((1, 3, 6, 1, 2, 1, 32, 2, 1, 5, 5, 1, 10), DnsName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResNCacheErrPrettyName.setReference('RFC-1035 section 2.3.3.')
if mibBuilder.loadTexts: dnsResNCacheErrPrettyName.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheErrPrettyName.setDescription('QNAME associated with this row in the table. This is identical to the dnsResNCacheErrQName variable, except that character case is preserved in this variable, per DNS conventions.')
dnsResOptCounterReferals = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResOptCounterReferals.setStatus('current')
if mibBuilder.loadTexts: dnsResOptCounterReferals.setDescription('Number of responses which were received from servers redirecting query to another server.')
dnsResOptCounterRetrans = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResOptCounterRetrans.setStatus('current')
if mibBuilder.loadTexts: dnsResOptCounterRetrans.setDescription('Number requests retransmitted for all reasons.')
dnsResOptCounterNoResponses = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResOptCounterNoResponses.setStatus('current')
if mibBuilder.loadTexts: dnsResOptCounterNoResponses.setDescription('Number of queries that were retransmitted because of no response.')
dnsResOptCounterRootRetrans = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResOptCounterRootRetrans.setStatus('current')
if mibBuilder.loadTexts: dnsResOptCounterRootRetrans.setDescription('Number of queries that were retransmitted that were to root servers.')
dnsResOptCounterInternals = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResOptCounterInternals.setStatus('current')
if mibBuilder.loadTexts: dnsResOptCounterInternals.setDescription('Number of requests internally generated by the resolver.')
dnsResOptCounterInternalTimeOuts = MibScalar((1, 3, 6, 1, 2, 1, 32, 2, 1, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dnsResOptCounterInternalTimeOuts.setStatus('current')
if mibBuilder.loadTexts: dnsResOptCounterInternalTimeOuts.setDescription('Number of requests internally generated which timed out.')
dnsResMIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 2))
dnsResConfigGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 32, 2, 2, 1)).setObjects(("DNS-RESOLVER-MIB", "dnsResConfigImplementIdent"), ("DNS-RESOLVER-MIB", "dnsResConfigService"), ("DNS-RESOLVER-MIB", "dnsResConfigMaxCnames"), ("DNS-RESOLVER-MIB", "dnsResConfigSbeltName"), ("DNS-RESOLVER-MIB", "dnsResConfigSbeltRecursion"), ("DNS-RESOLVER-MIB", "dnsResConfigSbeltPref"), ("DNS-RESOLVER-MIB", "dnsResConfigSbeltStatus"), ("DNS-RESOLVER-MIB", "dnsResConfigUpTime"), ("DNS-RESOLVER-MIB", "dnsResConfigResetTime"), ("DNS-RESOLVER-MIB", "dnsResConfigReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dnsResConfigGroup = dnsResConfigGroup.setStatus('current')
if mibBuilder.loadTexts: dnsResConfigGroup.setDescription('A collection of objects providing basic configuration information for a DNS resolver implementation.')
dnsResCounterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 32, 2, 2, 2)).setObjects(("DNS-RESOLVER-MIB", "dnsResCounterByOpcodeQueries"), ("DNS-RESOLVER-MIB", "dnsResCounterByOpcodeResponses"), ("DNS-RESOLVER-MIB", "dnsResCounterByRcodeResponses"), ("DNS-RESOLVER-MIB", "dnsResCounterNonAuthDataResps"), ("DNS-RESOLVER-MIB", "dnsResCounterNonAuthNoDataResps"), ("DNS-RESOLVER-MIB", "dnsResCounterMartians"), ("DNS-RESOLVER-MIB", "dnsResCounterRecdResponses"), ("DNS-RESOLVER-MIB", "dnsResCounterUnparseResps"), ("DNS-RESOLVER-MIB", "dnsResCounterFallbacks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dnsResCounterGroup = dnsResCounterGroup.setStatus('current')
if mibBuilder.loadTexts: dnsResCounterGroup.setDescription('A collection of objects providing basic instrumentation of a DNS resolver implementation.')
dnsResLameDelegationGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 32, 2, 2, 3)).setObjects(("DNS-RESOLVER-MIB", "dnsResLameDelegationOverflows"), ("DNS-RESOLVER-MIB", "dnsResLameDelegationCounts"), ("DNS-RESOLVER-MIB", "dnsResLameDelegationStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dnsResLameDelegationGroup = dnsResLameDelegationGroup.setStatus('current')
if mibBuilder.loadTexts: dnsResLameDelegationGroup.setDescription("A collection of objects providing instrumentation of `lame delegation' failures.")
dnsResCacheGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 32, 2, 2, 4)).setObjects(("DNS-RESOLVER-MIB", "dnsResCacheStatus"), ("DNS-RESOLVER-MIB", "dnsResCacheMaxTTL"), ("DNS-RESOLVER-MIB", "dnsResCacheGoodCaches"), ("DNS-RESOLVER-MIB", "dnsResCacheBadCaches"), ("DNS-RESOLVER-MIB", "dnsResCacheRRTTL"), ("DNS-RESOLVER-MIB", "dnsResCacheRRElapsedTTL"), ("DNS-RESOLVER-MIB", "dnsResCacheRRSource"), ("DNS-RESOLVER-MIB", "dnsResCacheRRData"), ("DNS-RESOLVER-MIB", "dnsResCacheRRStatus"), ("DNS-RESOLVER-MIB", "dnsResCacheRRPrettyName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dnsResCacheGroup = dnsResCacheGroup.setStatus('current')
if mibBuilder.loadTexts: dnsResCacheGroup.setDescription("A collection of objects providing access to and control of a DNS resolver's cache.")
dnsResNCacheGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 32, 2, 2, 5)).setObjects(("DNS-RESOLVER-MIB", "dnsResNCacheStatus"), ("DNS-RESOLVER-MIB", "dnsResNCacheMaxTTL"), ("DNS-RESOLVER-MIB", "dnsResNCacheGoodNCaches"), ("DNS-RESOLVER-MIB", "dnsResNCacheBadNCaches"), ("DNS-RESOLVER-MIB", "dnsResNCacheErrTTL"), ("DNS-RESOLVER-MIB", "dnsResNCacheErrElapsedTTL"), ("DNS-RESOLVER-MIB", "dnsResNCacheErrSource"), ("DNS-RESOLVER-MIB", "dnsResNCacheErrCode"), ("DNS-RESOLVER-MIB", "dnsResNCacheErrStatus"), ("DNS-RESOLVER-MIB", "dnsResNCacheErrIndex"), ("DNS-RESOLVER-MIB", "dnsResNCacheErrPrettyName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dnsResNCacheGroup = dnsResNCacheGroup.setStatus('current')
if mibBuilder.loadTexts: dnsResNCacheGroup.setDescription("A collection of objects providing access to and control of a DNS resolver's negative response cache.")
dnsResOptCounterGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 32, 2, 2, 6)).setObjects(("DNS-RESOLVER-MIB", "dnsResOptCounterReferals"), ("DNS-RESOLVER-MIB", "dnsResOptCounterRetrans"), ("DNS-RESOLVER-MIB", "dnsResOptCounterNoResponses"), ("DNS-RESOLVER-MIB", "dnsResOptCounterRootRetrans"), ("DNS-RESOLVER-MIB", "dnsResOptCounterInternals"), ("DNS-RESOLVER-MIB", "dnsResOptCounterInternalTimeOuts"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dnsResOptCounterGroup = dnsResOptCounterGroup.setStatus('current')
if mibBuilder.loadTexts: dnsResOptCounterGroup.setDescription('A collection of objects providing further instrumentation applicable to many but not all DNS resolvers.')
dnsResMIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 32, 2, 3))
dnsResMIBCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 32, 2, 3, 1)).setObjects(("DNS-RESOLVER-MIB", "dnsResConfigGroup"), ("DNS-RESOLVER-MIB", "dnsResCounterGroup"), ("DNS-RESOLVER-MIB", "dnsResCacheGroup"), ("DNS-RESOLVER-MIB", "dnsResNCacheGroup"), ("DNS-RESOLVER-MIB", "dnsResLameDelegationGroup"), ("DNS-RESOLVER-MIB", "dnsResOptCounterGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    dnsResMIBCompliance = dnsResMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: dnsResMIBCompliance.setDescription('The compliance statement for agents implementing the DNS resolver MIB extensions.')
mibBuilder.exportSymbols("DNS-RESOLVER-MIB", dnsResOptCounter=dnsResOptCounter, dnsResLameDelegationGroup=dnsResLameDelegationGroup, dnsResConfigSbeltRecursion=dnsResConfigSbeltRecursion, dnsResCacheRRIndex=dnsResCacheRRIndex, dnsResConfigService=dnsResConfigService, dnsResCounterByOpcodeCode=dnsResCounterByOpcodeCode, dnsResLameDelegationOverflows=dnsResLameDelegationOverflows, dnsResLameDelegationEntry=dnsResLameDelegationEntry, dnsResMIBCompliances=dnsResMIBCompliances, dnsResCounterGroup=dnsResCounterGroup, dnsResCounterByRcodeResponses=dnsResCounterByRcodeResponses, dnsResMIBObjects=dnsResMIBObjects, dnsResCounterByRcodeTable=dnsResCounterByRcodeTable, dnsResConfigSbeltClass=dnsResConfigSbeltClass, dnsResConfigSbeltPref=dnsResConfigSbeltPref, dnsResConfigMaxCnames=dnsResConfigMaxCnames, dnsResNCacheErrTTL=dnsResNCacheErrTTL, dnsResCacheStatus=dnsResCacheStatus, dnsResMIBCompliance=dnsResMIBCompliance, dnsResNCache=dnsResNCache, dnsResCacheRRName=dnsResCacheRRName, dnsResNCacheErrEntry=dnsResNCacheErrEntry, dnsResCounterByRcodeCode=dnsResCounterByRcodeCode, dnsResNCacheErrIndex=dnsResNCacheErrIndex, dnsResCacheRRTTL=dnsResCacheRRTTL, dnsResNCacheGroup=dnsResNCacheGroup, dnsResNCacheMaxTTL=dnsResNCacheMaxTTL, dnsResCacheRRStatus=dnsResCacheRRStatus, dnsResCounterRecdResponses=dnsResCounterRecdResponses, dnsResConfigGroup=dnsResConfigGroup, dnsResNCacheErrQClass=dnsResNCacheErrQClass, dnsResCacheRREntry=dnsResCacheRREntry, dnsResOptCounterGroup=dnsResOptCounterGroup, dnsResCacheGoodCaches=dnsResCacheGoodCaches, DnsQType=DnsQType, DnsQClass=DnsQClass, dnsResConfigSbeltName=dnsResConfigSbeltName, dnsResMIB=dnsResMIB, dnsResConfigSbeltAddr=dnsResConfigSbeltAddr, PYSNMP_MODULE_ID=dnsResMIB, dnsResLameDelegationCounts=dnsResLameDelegationCounts, dnsResNCacheErrTable=dnsResNCacheErrTable, dnsResCounterByOpcodeResponses=dnsResCounterByOpcodeResponses, dnsResCacheBadCaches=dnsResCacheBadCaches, dnsResCacheRRTable=dnsResCacheRRTable, dnsResConfigImplementIdent=dnsResConfigImplementIdent, dnsResCacheRRElapsedTTL=dnsResCacheRRElapsedTTL, dnsResOptCounterReferals=dnsResOptCounterReferals, dnsResCounterNonAuthDataResps=dnsResCounterNonAuthDataResps, dnsResCacheRRSource=dnsResCacheRRSource, dnsResCacheMaxTTL=dnsResCacheMaxTTL, dnsResCounterByOpcodeTable=dnsResCounterByOpcodeTable, dnsResMIBGroups=dnsResMIBGroups, dnsResCacheRRPrettyName=dnsResCacheRRPrettyName, dnsResConfigResetTime=dnsResConfigResetTime, dnsResLameDelegationTable=dnsResLameDelegationTable, dnsResConfigReset=dnsResConfigReset, dnsResConfig=dnsResConfig, dnsResConfigSbeltTable=dnsResConfigSbeltTable, dnsResCacheRRData=dnsResCacheRRData, dnsResNCacheBadNCaches=dnsResNCacheBadNCaches, dnsResConfigSbeltEntry=dnsResConfigSbeltEntry, dnsResLameDelegation=dnsResLameDelegation, dnsResOptCounterNoResponses=dnsResOptCounterNoResponses, dnsResNCacheErrCode=dnsResNCacheErrCode, dnsResConfigUpTime=dnsResConfigUpTime, dnsResLameDelegationSource=dnsResLameDelegationSource, dnsResConfigSbeltSubTree=dnsResConfigSbeltSubTree, dnsResNCacheErrElapsedTTL=dnsResNCacheErrElapsedTTL, dnsResCounterByOpcodeQueries=dnsResCounterByOpcodeQueries, dnsResNCacheErrStatus=dnsResNCacheErrStatus, dnsResOptCounterInternalTimeOuts=dnsResOptCounterInternalTimeOuts, dnsResCacheRRClass=dnsResCacheRRClass, dnsResNCacheErrSource=dnsResNCacheErrSource, dnsResLameDelegationClass=dnsResLameDelegationClass, dnsResCounterFallbacks=dnsResCounterFallbacks, dnsResCacheRRType=dnsResCacheRRType, dnsResOptCounterInternals=dnsResOptCounterInternals, dnsResCache=dnsResCache, dnsResNCacheErrQName=dnsResNCacheErrQName, dnsResNCacheErrQType=dnsResNCacheErrQType, dnsResNCacheGoodNCaches=dnsResNCacheGoodNCaches, dnsResCounterUnparseResps=dnsResCounterUnparseResps, dnsResNCacheErrPrettyName=dnsResNCacheErrPrettyName, dnsResConfigSbeltStatus=dnsResConfigSbeltStatus, dnsResLameDelegationName=dnsResLameDelegationName, DnsRespCode=DnsRespCode, dnsResCounterNonAuthNoDataResps=dnsResCounterNonAuthNoDataResps, dnsResNCacheStatus=dnsResNCacheStatus, dnsResLameDelegationStatus=dnsResLameDelegationStatus, dnsResCounterByRcodeEntry=dnsResCounterByRcodeEntry, dnsResOptCounterRootRetrans=dnsResOptCounterRootRetrans, dnsResCacheGroup=dnsResCacheGroup, dnsResCounterMartians=dnsResCounterMartians, dnsResCounterByOpcodeEntry=dnsResCounterByOpcodeEntry, dnsResCounter=dnsResCounter, dnsResOptCounterRetrans=dnsResOptCounterRetrans)

#
# PySNMP MIB module SWITCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SWITCH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:13:16 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, iso, Counter32, NotificationType, Bits, IpAddress, TimeTicks, MibIdentifier, enterprises, Unsigned32, ModuleIdentity, Gauge32, Integer32, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "iso", "Counter32", "NotificationType", "Bits", "IpAddress", "TimeTicks", "MibIdentifier", "enterprises", "Unsigned32", "ModuleIdentity", "Gauge32", "Integer32", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

vendor = MibIdentifier((1, 3, 6, 1, 4, 1, 295))
ethernetSwitchingDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3))
deviceHardware = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 1))
deviceChassis = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 1, 1))
devicePort = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 1, 2))
ethernetPort = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 1, 2, 1))
waveBusPort = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 1, 2, 2))
fddiPort = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 1, 2, 3))
deviceSoftware = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 2))
deviceInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 295, 3, 2, 1))
chassisTable = MibTable((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1), )
if mibBuilder.loadTexts: chassisTable.setStatus('mandatory')
if mibBuilder.loadTexts: chassisTable.setDescription('Information about the unit.')
chassisEntry = MibTableRow((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1), ).setIndexNames((0, "SWITCH-MIB", "chassisIndex"))
if mibBuilder.loadTexts: chassisEntry.setStatus('mandatory')
if mibBuilder.loadTexts: chassisEntry.setDescription('Identification information about the unit.')
chassisProductCode = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisProductCode.setStatus('mandatory')
if mibBuilder.loadTexts: chassisProductCode.setDescription('An ASCII string giving the product code of the unit.')
chassisSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: chassisSerialNumber.setDescription("An ASCII string giving the unit's serial number.")
chassisPlaceOfManufacture = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ottawa", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPlaceOfManufacture.setStatus('mandatory')
if mibBuilder.loadTexts: chassisPlaceOfManufacture.setDescription('A number identifying where the unit was built.')
chassisDateOfManufacture = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisDateOfManufacture.setStatus('mandatory')
if mibBuilder.loadTexts: chassisDateOfManufacture.setDescription('An ASCII string giving the date of manufacture of the unit.')
chassisMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: chassisMacAddress.setDescription('The IEEE 802 MAC address of the unit.')
chassisCodeVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: chassisCodeVersion.setDescription('An ASCII string giving the version number of the control software.')
chassisBpeEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisBpeEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: chassisBpeEnabled.setDescription('Setting this variable to TRUE (1) causes the bridge protocol engine to perform the Spanning Tree Protocol as defined in IEEE802.1d. Setting this variable to FALSE (0) causes the BPE to stop performing the Spanning Tree Protocol. The value of this variable when the unit starts operating is 1.')
chassisEraseSnmpConfigInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisEraseSnmpConfigInfo.setStatus('mandatory')
if mibBuilder.loadTexts: chassisEraseSnmpConfigInfo.setDescription('Setting this variable to TRUE (1) causes the unit to erase its SNMP configuration information both from memory and from permanent store. The unit the requests new configuration information using the BOOTP protocol. Setting this variable to any other value has no effect. This variable will always return 0 when read.')
chassisRestoreDot1dDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisRestoreDot1dDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: chassisRestoreDot1dDefaults.setDescription('Setting this variable to TRUE (1) causes the BPE to restore the default spanning tree values given in the IEEE 802.1d specification. This resets all writeable Bridge MIB variables in the dot1dStp group of the Bridge MIB. Setting the variable to any other value has no effect. This variable will always return 0 when read.')
chassisPerformReset = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisPerformReset.setStatus('mandatory')
if mibBuilder.loadTexts: chassisPerformReset.setDescription('Setting this variable to TRUE (1) causes the unit to perform a cold restart. As a result of this action a coldRestart trap will be sent. Setting this variable to any other value has no effect. This variable will always return 0 when read.')
chassisIdentPressed = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisIdentPressed.setStatus('mandatory')
if mibBuilder.loadTexts: chassisIdentPressed.setDescription('This variable is TRUE (1) if the IDENTIFY button on the chassis has been pressed since the variable was last read. After this variable has been read it will be set to 0.')
chassisAgeFilterDatabase = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisAgeFilterDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: chassisAgeFilterDatabase.setDescription('Setting this variable to FALSE (0) causes the unit to stop aging out entries from its filter database. Setting this variable to TRUE (1) causes the unit to age out filter database entries as defined in IEEE 802.1D. This variable is set to 0 whenever the unit restarts.')
chassisClearStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisClearStatistics.setStatus('mandatory')
if mibBuilder.loadTexts: chassisClearStatistics.setDescription('Setting this variable to TRUE (1) clears the traffic statistics accumulators. Setting this variable to any other value has no effect. The variable always returns 0 when read.')
chassisTcpKeepAlivesEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisTcpKeepAlivesEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: chassisTcpKeepAlivesEnabled.setDescription('Setting this variable to TRUE (1) causes keep alive packets to be transmitted on an idle TCP connection. The period of the keep alive packets is defined by the MIB variable chassisTcpKeepAlivePeriod. Setting this variable to FALSE (0) stops keep alives from being transmitted. The default value of this variable is FALSE (0).')
chassisTcpKeepAlivePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: chassisTcpKeepAlivePeriod.setStatus('mandatory')
if mibBuilder.loadTexts: chassisTcpKeepAlivePeriod.setDescription('This variable defines the time period in seconds between keep alive packets transmitted on an idle TCP connection. This value must be equal to or greater than 30 seconds and less than or equal to 24 hours (86,400) seconds. The MIB value tcpKeepAlivesEnabled must be set TRUE (1) in order for the keep alive packets to be transmitted. The default value of this variable is 2 hours (7,200) seconds.')
chassisIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 1, 1, 100), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisIndex.setStatus('mandatory')
if mibBuilder.loadTexts: chassisIndex.setDescription('This is a dummy variable which provides a meta-index for the Chassis Information Table.')
portTable = MibTable((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2), )
if mibBuilder.loadTexts: portTable.setStatus('mandatory')
if mibBuilder.loadTexts: portTable.setDescription('Identification information about the ports.')
portEntry = MibTableRow((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1), ).setIndexNames((0, "SWITCH-MIB", "portIndex"))
if mibBuilder.loadTexts: portEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portEntry.setDescription('Identification information about a particular port.')
portIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portIndex.setDescription('The number of the port to which the management information applies.')
portProductCode = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portProductCode.setStatus('mandatory')
if mibBuilder.loadTexts: portProductCode.setDescription('An ASCII string giving the product code of the card on which this port is located.')
portSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: portSerialNumber.setDescription('An ASCII string giving the serial number of the card on which this port is located.')
portPlaceOfManufacture = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ottawa", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPlaceOfManufacture.setStatus('mandatory')
if mibBuilder.loadTexts: portPlaceOfManufacture.setDescription('A number identifying where the card on which this port is located was built.')
portDateOfManufacture = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDateOfManufacture.setStatus('mandatory')
if mibBuilder.loadTexts: portDateOfManufacture.setDescription('An ASCII string giving the date of manufacture of the card on which this port is located.')
portState = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portState.setStatus('mandatory')
if mibBuilder.loadTexts: portState.setDescription("An ASCII string giving the port's operational state.")
portHighSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portHighSensitivity.setStatus('mandatory')
if mibBuilder.loadTexts: portHighSensitivity.setDescription('This variable is only valid if the port is an Ethernet port. If this variable is set to TRUE (1), the receiver of the Ethernet NIC controlling the port is set to high sensitivity. If the variable is set to 0, the port is set to normal sensitivity. If the ports on both ends of the 10BaseT link are set to high sensitivity, the maximum permissable length of the link is increased from 100 meters to 120 meters. Caution: a high sensitivity receiver may be overdriven by transmitters closer than 100 meters. This variable is 0 when the unit is powered up for the first time. Changes to this variable are preserved across system restarts.')
portRestoreFddiMibDefaults = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRestoreFddiMibDefaults.setStatus('mandatory')
if mibBuilder.loadTexts: portRestoreFddiMibDefaults.setDescription('This variable is ony valid if the port is an FDDI station. Setting this variable to TRUE (1) causes the agent to restore the default MIB values given in the ANSI X3T9.5/84-49 Rev 7.2 specification. This resets all writable FDDI MIB variables. Setting the variable to any other value has no effect. This variable will always return 0 when read.')
portTranslateAllEthertypes = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTranslateAllEthertypes.setStatus('mandatory')
if mibBuilder.loadTexts: portTranslateAllEthertypes.setDescription('This variable is only valid if the port is an FDDI port. If this variable is set to TRUE (1), the Bridge Tunnel Encapsulation Protocol will be applied to frames containing any Ethertypes, not just the ones in the Selective Translation Table. If this variable is set to FALSE (0), the protocol will only be applied to Ethertypes in the translation table.')
portTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: portTxFrames.setDescription('This counter is incremented by one for each frame transmitted to the network segment attached to the port.')
portRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: portRxFrames.setDescription('This counter is incremented by one for each valid frame received from the network segment attached to the port.')
portFcsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFcsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: portFcsErrors.setDescription('This counter is incremented by one for each received frame which failed its FCS check.')
portFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: portFilterDiscards.setDescription("The number of frames received on this port which have been discarded due to the filtering action of the port's bridge circuit.")
portDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: portDelayExceededDiscards.setDescription('The number of frames discarded by this port due to excessive transit delay through the unit. It reports the same value as the object dot1dBasePortDelayExceededDiscards in the Bridge MIB (RFC 1493).')
portMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: portMtuExceededDiscards.setDescription('The number of frames discarded by this port due to excessive size. It is the same value reported in the object dot1dBasePortMtuExceededDiscards in the Bridge MIB (RFC 1493).')
portFddiTooLongNonIpFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFddiTooLongNonIpFrames.setStatus('mandatory')
if mibBuilder.loadTexts: portFddiTooLongNonIpFrames.setDescription('The number of unfragmentable (non-IP) frames greater than ethernet length (1514 bytes) discarded by this port. This object is valid only for FDDI ports.')
portConnected = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portConnected.setStatus('mandatory')
if mibBuilder.loadTexts: portConnected.setDescription('The variable is TRUE (1) if the port is connected to a network segment. The variable is FALSE (0) if the port is not connected to a network segment.')
sttTable = MibTable((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3), )
if mibBuilder.loadTexts: sttTable.setStatus('mandatory')
if mibBuilder.loadTexts: sttTable.setDescription('The Selective Translation Table as defined in IEEE 802.1h.')
sttEntry = MibTableRow((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1), ).setIndexNames((0, "SWITCH-MIB", "sttPortIndex"))
if mibBuilder.loadTexts: sttEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sttEntry.setDescription('One entry in the Selective Translation Table.')
sttPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sttPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sttPortIndex.setDescription('The table index - the port number on which the STT resides.')
sttEthertype1 = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sttEthertype1.setStatus('mandatory')
if mibBuilder.loadTexts: sttEthertype1.setDescription('The first Ethertype for which the Bridge Tunnel Encapsulation Protocol should be used.')
sttEntryValid1 = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sttEntryValid1.setStatus('mandatory')
if mibBuilder.loadTexts: sttEntryValid1.setDescription('If this variable is set to TRUE (1), the Bridge Tunnel Encapsulation Protocol will be applied to frames containing the first Ethertype. If this variable is set to FALSE (0), the protocol will not be applied to the Ethertype.')
sttEthertype2 = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sttEthertype2.setStatus('mandatory')
if mibBuilder.loadTexts: sttEthertype2.setDescription('The second Ethertype for which the Bridge Tunnel Encapsulation Protocol should be used.')
sttEntryValid2 = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sttEntryValid2.setStatus('mandatory')
if mibBuilder.loadTexts: sttEntryValid2.setDescription('If this variable is set to TRUE (1), the Bridge Tunnel Encapsulation Protocol will be applied to frames containing the second Ethertype. If this variable is set to FALSE (0), the protocol will not be applied to the Ethertype.')
sttEthertype3 = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sttEthertype3.setStatus('mandatory')
if mibBuilder.loadTexts: sttEthertype3.setDescription('The third Ethertype for which the Bridge Tunnel Encapsulation Protocol should be used.')
sttEntryValid3 = MibTableColumn((1, 3, 6, 1, 4, 1, 295, 3, 2, 1, 3, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sttEntryValid3.setStatus('mandatory')
if mibBuilder.loadTexts: sttEntryValid3.setDescription('If this variable is set to TRUE (1), the Bridge Tunnel Encapsulation Protocol will be applied to frames containing the third Ethertype. If this variable is set to FALSE (0), the protocol will not be applied to the Ethertype.')
touched = NotificationType((1, 3, 6, 1, 4, 1, 295) + (0,9)).setObjects(("SWITCH-MIB", "chassisIdentPressed"))
if mibBuilder.loadTexts: touched.setDescription('This trap is generated when the IDENTIFY button is pressed. The agent throttles the generation of consecutive touched traps so that there is at least a two second gap between them.')
mibBuilder.exportSymbols("SWITCH-MIB", ethernetSwitchingDevice=ethernetSwitchingDevice, portRestoreFddiMibDefaults=portRestoreFddiMibDefaults, devicePort=devicePort, sttEntryValid2=sttEntryValid2, deviceHardware=deviceHardware, vendor=vendor, portTable=portTable, MacAddress=MacAddress, sttEthertype3=sttEthertype3, touched=touched, chassisSerialNumber=chassisSerialNumber, ethernetPort=ethernetPort, portHighSensitivity=portHighSensitivity, chassisAgeFilterDatabase=chassisAgeFilterDatabase, chassisRestoreDot1dDefaults=chassisRestoreDot1dDefaults, portIndex=portIndex, portRxFrames=portRxFrames, chassisDateOfManufacture=chassisDateOfManufacture, chassisPerformReset=chassisPerformReset, chassisTcpKeepAlivePeriod=chassisTcpKeepAlivePeriod, portFilterDiscards=portFilterDiscards, portFddiTooLongNonIpFrames=portFddiTooLongNonIpFrames, portPlaceOfManufacture=portPlaceOfManufacture, deviceSoftware=deviceSoftware, sttPortIndex=sttPortIndex, portState=portState, portProductCode=portProductCode, chassisEntry=chassisEntry, chassisEraseSnmpConfigInfo=chassisEraseSnmpConfigInfo, portTxFrames=portTxFrames, sttTable=sttTable, deviceInfo=deviceInfo, chassisIndex=chassisIndex, sttEntryValid1=sttEntryValid1, chassisProductCode=chassisProductCode, waveBusPort=waveBusPort, portMtuExceededDiscards=portMtuExceededDiscards, chassisTcpKeepAlivesEnabled=chassisTcpKeepAlivesEnabled, chassisTable=chassisTable, chassisBpeEnabled=chassisBpeEnabled, fddiPort=fddiPort, portFcsErrors=portFcsErrors, chassisMacAddress=chassisMacAddress, portEntry=portEntry, sttEntryValid3=sttEntryValid3, chassisIdentPressed=chassisIdentPressed, portDateOfManufacture=portDateOfManufacture, chassisClearStatistics=chassisClearStatistics, sttEthertype2=sttEthertype2, portConnected=portConnected, portDelayExceededDiscards=portDelayExceededDiscards, sttEntry=sttEntry, deviceChassis=deviceChassis, portTranslateAllEthertypes=portTranslateAllEthertypes, sttEthertype1=sttEthertype1, chassisPlaceOfManufacture=chassisPlaceOfManufacture, portSerialNumber=portSerialNumber, chassisCodeVersion=chassisCodeVersion)

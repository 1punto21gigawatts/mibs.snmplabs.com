#
# PySNMP MIB module ZYXEL-accessSwitch-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZYXEL-accessSwitch-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:52:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, TimeTicks, Counter32, enterprises, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, MibIdentifier, IpAddress, Bits, ObjectIdentity, NotificationType, Integer32, iso, Gauge32, Counter64, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "TimeTicks", "Counter32", "enterprises", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "MibIdentifier", "IpAddress", "Bits", "ObjectIdentity", "NotificationType", "Integer32", "iso", "Gauge32", "Counter64", "NotificationType")
DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "RowStatus", "TextualConvention")
zyxel = MibIdentifier((1, 3, 6, 1, 4, 1, 890))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 890, 1))
accessSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 890, 1, 5))
accessSwitchCommon = MibIdentifier((1, 3, 6, 1, 4, 1, 890, 1, 5, 1))
accessSwitchMgnt = MibIdentifier((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1))
accessSwitchSystemCurrentStatus = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSystemCurrentStatus.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSystemCurrentStatus.setDescription('This variable indicates the status of the system. The sysCurrentStatus is a bit map represented as a sum, therefore, it can represent multiple defects simultaneously. The sysNoDefect should be set if and only if no other flag is set. The various bit positions are: 1 sysNoDefect 2 sysOverHeat 3 sysFanRpmLow 4 sysVoltageLow 5 sysThermalSensorFailure')
accessSwitchProblemCause = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchProblemCause.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchProblemCause.setDescription('The variable is the description of sytsem problem.')
accessSwitchSystemTemperature = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSystemTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSystemTemperature.setDescription('The variable is the current temperature in Celsius of the system.')
accessSwitchFanRpmTable = MibTable((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4), )
if mibBuilder.loadTexts: accessSwitchFanRpmTable.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmTable.setDescription('A table that contains rpm information about the fans.')
accessSwitchFanRpmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4, 1), ).setIndexNames((0, "ZYXEL-accessSwitch-MIB", "accessSwitchFanRpmIndex"))
if mibBuilder.loadTexts: accessSwitchFanRpmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmEntry.setDescription('A list of rpm information for each fan.')
accessSwitchFanRpmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchFanRpmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmIndex.setDescription('The identity of the fan.')
accessSwitchFanRpmCurValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchFanRpmCurValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmCurValue.setDescription('The current rpm of the fan.')
accessSwitchFanRpmMaxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchFanRpmMaxValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmMaxValue.setDescription('The maximum rpm ever performed by the fan.')
accessSwitchFanRpmMinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchFanRpmMinValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmMinValue.setDescription('The minimum rpm ever performed by the fan.')
accessSwitchFanRpmLowThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchFanRpmLowThresh.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmLowThresh.setDescription('The low threshold of the rpm of the fan. If the current rpm is less than the threshold, the device will initiate the fanRpmLow trap.')
accessSwitchFanRpmDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 4, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchFanRpmDescr.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFanRpmDescr.setDescription('The description of the fan (e.g. location, function, etc.).')
accessSwitchVoltageTable = MibTable((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5), )
if mibBuilder.loadTexts: accessSwitchVoltageTable.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageTable.setDescription('A table that contains voltage information about the system.')
accessSwitchVoltageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1), ).setIndexNames((0, "ZYXEL-accessSwitch-MIB", "accessSwitchVoltageIndex"))
if mibBuilder.loadTexts: accessSwitchVoltageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageEntry.setDescription('A list of voltage information for each sensor.')
accessSwitchVoltageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchVoltageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageIndex.setDescription('The identity of the sensor.')
accessSwitchVoltageCurValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchVoltageCurValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageCurValue.setDescription('The current voltage detected by the sensor (in milli-voltage).')
accessSwitchVoltageMaxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchVoltageMaxValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageMaxValue.setDescription('The maximum voltage ever detected by the sensor (in milli-voltage).')
accessSwitchVoltageMinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchVoltageMinValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageMinValue.setDescription('The minimum voltage ever detected by the sensor (in milli-voltage).')
accessSwitchVoltageNominalValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchVoltageNominalValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageNominalValue.setDescription('The nominal voltage which the power should supply (in milli-voltage).')
accessSwitchVoltageLowThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchVoltageLowThresh.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageLowThresh.setDescription('The low threshold of the voltage. If the current voltage is less than the threshold, the device will initiate the voltageLow trap.')
accessSwitchVoltageDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 5, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchVoltageDescr.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchVoltageDescr.setDescription('The description of the voltage (e.g. location, nominal value, etc.).')
accessSwitchSysTempTable = MibTable((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6), )
if mibBuilder.loadTexts: accessSwitchSysTempTable.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempTable.setDescription('A table that contains temperature information about system.')
accessSwitchSysTempEntry = MibTableRow((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6, 1), ).setIndexNames((0, "ZYXEL-accessSwitch-MIB", "accessSwitchSysTempIndex"))
if mibBuilder.loadTexts: accessSwitchSysTempEntry.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempEntry.setDescription('A list of temperature information for each sensor.')
accessSwitchSysTempIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSysTempIndex.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempIndex.setDescription('The identity of the sensor.')
accessSwitchSysTempCurValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSysTempCurValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempCurValue.setDescription('The current temperature detected in Celsius by the sensor.')
accessSwitchSysTempMaxValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSysTempMaxValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempMaxValue.setDescription('The maximum temperature ever detected in Celsius by the sensor.')
accessSwitchSysTempMinValue = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSysTempMinValue.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempMinValue.setDescription('The minimum temperature ever detected in Celsius by the sensor.')
accessSwitchSysTempHighThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSysTempHighThresh.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempHighThresh.setDescription('The high threshold of the temperature in Celsius. If the current temperature is higher than the threshold, the device will initiate the overheat trap.')
accessSwitchSysTempDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 6, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchSysTempDescr.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSysTempDescr.setDescription('The description of the temperature sensor (e.g. location, function, etc.).')
accessSwitchMaintenance = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessSwitchMaintenance.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchMaintenance.setDescription('The managed object is for system maintenance. When the EMS wants to trigger the system maitenance operation, the EMS shall send SNMP-SET message to set the corresponding bit value to be 1. The various bit positions are: BIT 1: config save BIT 2: reset BIT 3: local loopback test BIT 4: remote loopback test')
accessSwitchMaintenancePort = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessSwitchMaintenancePort.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchMaintenancePort.setDescription('The port which the maintenance operation should be performed on. The value of 0 means the maintenance should be performed on the system.')
accessSwitchMaxNumOfStaticVlans = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchMaxNumOfStaticVlans.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchMaxNumOfStaticVlans.setDescription('The maximum number of static VLANs which the system supports')
class ASSlotNum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("slot1", 1), ("slot2", 2))

class ASModuleType(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("aes-100", 1), ("aes-100-1", 2), ("aam1008-61", 3), ("aam1008-63", 4), ("sam1008", 5))

acccessSwitchChassisId = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acccessSwitchChassisId.setStatus('mandatory')
if mibBuilder.loadTexts: acccessSwitchChassisId.setDescription('The chassis Id of the module')
accessSwitchSlotId = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 11), ASSlotNum()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessSwitchSlotId.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchSlotId.setDescription('The slot Id of the module')
accessSwitchModuleType = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 12), ASModuleType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchModuleType.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchModuleType.setDescription('The type of the module')
accessSwitchFWVersion = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchFWVersion.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchFWVersion.setDescription('The firmware version of the access switch.')
accessSwitchDriverVersion = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 14), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchDriverVersion.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchDriverVersion.setDescription('The driver version of the access port in this access switch')
accessSwitchModemCodeVersion = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 15), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: accessSwitchModemCodeVersion.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchModemCodeVersion.setDescription('The modem code version of the access port in this access switch')
accessSwitchDSLConfOps = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessSwitchDSLConfOps.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchDSLConfOps.setDescription('The managed object is for xDSL line configuration. When the EMS wants to issue the desired operation, the EMS shall send SNMP-SET message to set the corresponding bit value to be 1. The various bit positions are: BIT 1: enable port BIT 2: disable port BIT 3: set DSL mode BIT 4: set profile')
accessSwitchDSLConfTarget = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessSwitchDSLConfTarget.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchDSLConfTarget.setDescription('The managed object is used for identify the target on which the line configuration should be performed. The target is encoded as: Byte 1~4: reserved Byte 5~7: each octet specifies a set of eight ports, with the first octet specifying ports 1 through 8, etc. Byte 8~10: reserved')
accessSwitchDSLConfProfileName = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessSwitchDSLConfProfileName.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchDSLConfProfileName.setDescription('The DSL profile name')
accessSwitchDSLConfMode = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: accessSwitchDSLConfMode.setStatus('mandatory')
if mibBuilder.loadTexts: accessSwitchDSLConfMode.setDescription('The DSL mode. The semantic for each bit is: Bit 1: ADSL, G.lite Bit 2: ADSL, G.dmt Bit 3: ADSL, T1.413 Bit 4: ADSL, Auto')
asPacketForwardingTable = MibTable((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 20), )
if mibBuilder.loadTexts: asPacketForwardingTable.setStatus('mandatory')
if mibBuilder.loadTexts: asPacketForwardingTable.setDescription('This table includes the configuration of packet forwarding.')
asPacketForwardingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 20, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: asPacketForwardingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asPacketForwardingEntry.setDescription('An entry in asPacketForwardingTable.')
asPacketForwardingPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 20, 1, 1), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asPacketForwardingPortList.setStatus('mandatory')
if mibBuilder.loadTexts: asPacketForwardingPortList.setDescription('The list defines the ports to which the packets will be forwarded.')
asDhcpRelayEnable = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDhcpRelayEnable.setStatus('mandatory')
if mibBuilder.loadTexts: asDhcpRelayEnable.setDescription('Enable/disable DHCP relay function.')
asDhcpRelayOption82Enable = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDhcpRelayOption82Enable.setStatus('mandatory')
if mibBuilder.loadTexts: asDhcpRelayOption82Enable.setDescription('Enable/disable the relay agent information option.')
asDhcpRelayOption82Info = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 23), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDhcpRelayOption82Info.setStatus('mandatory')
if mibBuilder.loadTexts: asDhcpRelayOption82Info.setDescription('User specific relay agent information.')
asMaxNumOfDhcpServers = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asMaxNumOfDhcpServers.setStatus('mandatory')
if mibBuilder.loadTexts: asMaxNumOfDhcpServers.setDescription('The maximum number of DHCP servers.')
asDhcpServerTable = MibTable((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 25), )
if mibBuilder.loadTexts: asDhcpServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: asDhcpServerTable.setDescription('A table that contains DHCP server information.')
asDhcpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 25, 1), ).setIndexNames((0, "ZYXEL-accessSwitch-MIB", "asDhcpServerIp"))
if mibBuilder.loadTexts: asDhcpServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asDhcpServerEntry.setDescription('The entry of DHCP server table.')
asDhcpServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 25, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDhcpServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: asDhcpServerIp.setDescription('The IP address of the DHCP server.')
asDhcpServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 25, 1, 2), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDhcpServerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: asDhcpServerRowStatus.setDescription('The row status of the DHCP server entry.')
asMaxNumberOfRadiusServers = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asMaxNumberOfRadiusServers.setStatus('mandatory')
if mibBuilder.loadTexts: asMaxNumberOfRadiusServers.setDescription('The max number of the RADIUS Servers.')
asRadiusServerTable = MibTable((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 29), )
if mibBuilder.loadTexts: asRadiusServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: asRadiusServerTable.setDescription('A table that contains Radius Server information.')
asRadiusServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 29, 1), ).setIndexNames((0, "ZYXEL-accessSwitch-MIB", "asRadiusServerIndex"))
if mibBuilder.loadTexts: asRadiusServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asRadiusServerEntry.setDescription('The entry of Radius Server table.')
asRadiusServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 29, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: asRadiusServerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: asRadiusServerIndex.setDescription('The identity of the RADIUS server.')
asRadiusServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 29, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asRadiusServerIp.setStatus('mandatory')
if mibBuilder.loadTexts: asRadiusServerIp.setDescription('The IP address of the Radius Server.')
asRadiusServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 29, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asRadiusServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: asRadiusServerPort.setDescription('The UDP port of the Radius Server.')
asRadiusSharedSecret = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 29, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asRadiusSharedSecret.setStatus('mandatory')
if mibBuilder.loadTexts: asRadiusSharedSecret.setDescription('The shared secret of the Radius Server.')
asRadiusServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 29, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asRadiusServerRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: asRadiusServerRowStatus.setDescription('The row status of the Radius Server entry.')
asDot1xEnable = MibScalar((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDot1xEnable.setStatus('mandatory')
if mibBuilder.loadTexts: asDot1xEnable.setDescription('Enable/disable the 802.1x function.')
asDot1xPortTable = MibTable((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 31), )
if mibBuilder.loadTexts: asDot1xPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: asDot1xPortTable.setDescription('This table includes the configuration of 802.1x.')
asDot1xPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 31, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: asDot1xPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: asDot1xPortEntry.setDescription('An entry in asDot1xPortTable.')
asDot1xPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 31, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDot1xPortEnable.setStatus('mandatory')
if mibBuilder.loadTexts: asDot1xPortEnable.setDescription('The option defines if the port enables 802.1x settings.')
asDot1xPortControl = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 31, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("forceAuth", 2), ("forceUnAuth", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDot1xPortControl.setStatus('mandatory')
if mibBuilder.loadTexts: asDot1xPortControl.setDescription('The configuration defines the 802.1x port control type.')
asDot1xPortReAuthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 31, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDot1xPortReAuthEnable.setStatus('mandatory')
if mibBuilder.loadTexts: asDot1xPortReAuthEnable.setDescription('The option defines if the port enables 802.1x re-authentication.')
asDot1xPortReAuthPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 890, 1, 5, 1, 1, 31, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: asDot1xPortReAuthPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: asDot1xPortReAuthPeriod.setDescription('The configuration defines the 802.1x re-authentication period for each port.')
reboot = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,1)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchProblemCause"))
if mibBuilder.loadTexts: reboot.setDescription('Send a message to the manager that the system is going to reboot. The variable is the reason why the system reboots.')
systemShutdown = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,2)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchProblemCause"))
if mibBuilder.loadTexts: systemShutdown.setDescription('Send a message to the manager that the system is going to shutdown. The variable is the reason that causes the system to shutdown.')
overheat = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,3)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchSysTempIndex"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSysTempCurValue"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSystemCurrentStatus"))
if mibBuilder.loadTexts: overheat.setDescription('Send a message to the manager that the system is overheated. The variable in the binding list is the current temperature in Celsius of the system.')
overheatOver = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,4)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchSysTempIndex"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSysTempCurValue"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSystemCurrentStatus"))
if mibBuilder.loadTexts: overheatOver.setDescription('Send a message to the manager that the overheated condition is over. The variable in the binding list is the current temperature in Celsius of the system.')
errLog = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,5)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchProblemCause"))
if mibBuilder.loadTexts: errLog.setDescription('Send a message to the manager that an error log is created in system. The variable in the binding list is the content of the error log.')
fanRpmLow = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,6)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchFanRpmIndex"), ("ZYXEL-accessSwitch-MIB", "accessSwitchFanRpmCurValue"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSystemCurrentStatus"))
if mibBuilder.loadTexts: fanRpmLow.setDescription('Send a message to the manager that the rpm of the fan is too low. The variable in the binding list is the current rpm of the fan.')
fanRpmNormal = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,7)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchFanRpmIndex"), ("ZYXEL-accessSwitch-MIB", "accessSwitchFanRpmCurValue"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSystemCurrentStatus"))
if mibBuilder.loadTexts: fanRpmNormal.setDescription('Send a message to the manager that the low-rpm condition of the fan is over. The variable in the binding list is the current rpm of the fan.')
voltageOutOfRange = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,8)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchVoltageIndex"), ("ZYXEL-accessSwitch-MIB", "accessSwitchVoltageCurValue"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSystemCurrentStatus"))
if mibBuilder.loadTexts: voltageOutOfRange.setDescription('Send a message to the manager that the voltage of the system is out of range. The variable in the binding list is the current voltage in volt of the system.')
voltageNormal = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,9)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchVoltageIndex"), ("ZYXEL-accessSwitch-MIB", "accessSwitchVoltageCurValue"), ("ZYXEL-accessSwitch-MIB", "accessSwitchSystemCurrentStatus"))
if mibBuilder.loadTexts: voltageNormal.setDescription('Send a message to the manager that the low-voltage condition is over. The variable in the binding list is the current voltage in volt of the system.')
systemMaintenanceFailure = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,10)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchProblemCause"))
if mibBuilder.loadTexts: systemMaintenanceFailure.setDescription('Send a message to the manager that the system maintence operation fail. The variable in the variable binding indicates the problem.')
configChange = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,11)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchProblemCause"))
if mibBuilder.loadTexts: configChange.setDescription('Send a message to the manager that the system configuration data is changed.')
thermalSensorFailure = NotificationType((1, 3, 6, 1, 4, 1, 890, 1, 5) + (0,12)).setObjects(("ZYXEL-accessSwitch-MIB", "accessSwitchProblemCause"))
if mibBuilder.loadTexts: thermalSensorFailure.setDescription('The trap signifies that the thermal sensor failed.')
mibBuilder.exportSymbols("ZYXEL-accessSwitch-MIB", accessSwitchFanRpmMaxValue=accessSwitchFanRpmMaxValue, products=products, accessSwitchVoltageMinValue=accessSwitchVoltageMinValue, asDot1xPortEnable=asDot1xPortEnable, asDhcpServerEntry=asDhcpServerEntry, asRadiusServerTable=asRadiusServerTable, accessSwitchVoltageCurValue=accessSwitchVoltageCurValue, zyxel=zyxel, accessSwitchSystemCurrentStatus=accessSwitchSystemCurrentStatus, accessSwitchFanRpmDescr=accessSwitchFanRpmDescr, asDot1xPortReAuthPeriod=asDot1xPortReAuthPeriod, accessSwitchSysTempMaxValue=accessSwitchSysTempMaxValue, accessSwitchSysTempEntry=accessSwitchSysTempEntry, accessSwitchModuleType=accessSwitchModuleType, systemMaintenanceFailure=systemMaintenanceFailure, accessSwitchMgnt=accessSwitchMgnt, accessSwitchVoltageTable=accessSwitchVoltageTable, asDot1xPortEntry=asDot1xPortEntry, asMaxNumOfDhcpServers=asMaxNumOfDhcpServers, asDot1xEnable=asDot1xEnable, accessSwitchDSLConfProfileName=accessSwitchDSLConfProfileName, asRadiusServerEntry=asRadiusServerEntry, asDhcpServerTable=asDhcpServerTable, voltageOutOfRange=voltageOutOfRange, accessSwitchFanRpmTable=accessSwitchFanRpmTable, asDhcpRelayOption82Info=asDhcpRelayOption82Info, accessSwitchMaxNumOfStaticVlans=accessSwitchMaxNumOfStaticVlans, accessSwitchFanRpmEntry=accessSwitchFanRpmEntry, accessSwitchCommon=accessSwitchCommon, accessSwitchSysTempHighThresh=accessSwitchSysTempHighThresh, accessSwitchVoltageDescr=accessSwitchVoltageDescr, errLog=errLog, accessSwitchVoltageLowThresh=accessSwitchVoltageLowThresh, accessSwitchSysTempDescr=accessSwitchSysTempDescr, overheat=overheat, accessSwitchSystemTemperature=accessSwitchSystemTemperature, voltageNormal=voltageNormal, reboot=reboot, accessSwitchFanRpmLowThresh=accessSwitchFanRpmLowThresh, accessSwitchDSLConfOps=accessSwitchDSLConfOps, asPacketForwardingTable=asPacketForwardingTable, accessSwitchMaintenancePort=accessSwitchMaintenancePort, asPacketForwardingEntry=asPacketForwardingEntry, fanRpmNormal=fanRpmNormal, fanRpmLow=fanRpmLow, asMaxNumberOfRadiusServers=asMaxNumberOfRadiusServers, systemShutdown=systemShutdown, asRadiusSharedSecret=asRadiusSharedSecret, asDhcpRelayOption82Enable=asDhcpRelayOption82Enable, accessSwitchFanRpmMinValue=accessSwitchFanRpmMinValue, accessSwitchVoltageEntry=accessSwitchVoltageEntry, asRadiusServerIp=asRadiusServerIp, asDhcpRelayEnable=asDhcpRelayEnable, accessSwitchDSLConfMode=accessSwitchDSLConfMode, accessSwitchModemCodeVersion=accessSwitchModemCodeVersion, accessSwitchVoltageNominalValue=accessSwitchVoltageNominalValue, asRadiusServerIndex=asRadiusServerIndex, asRadiusServerRowStatus=asRadiusServerRowStatus, accessSwitchDSLConfTarget=accessSwitchDSLConfTarget, overheatOver=overheatOver, accessSwitch=accessSwitch, acccessSwitchChassisId=acccessSwitchChassisId, accessSwitchDriverVersion=accessSwitchDriverVersion, asDot1xPortReAuthEnable=asDot1xPortReAuthEnable, ASSlotNum=ASSlotNum, accessSwitchFanRpmIndex=accessSwitchFanRpmIndex, configChange=configChange, accessSwitchSysTempCurValue=accessSwitchSysTempCurValue, asDot1xPortControl=asDot1xPortControl, asDhcpServerRowStatus=asDhcpServerRowStatus, accessSwitchSysTempIndex=accessSwitchSysTempIndex, accessSwitchFWVersion=accessSwitchFWVersion, accessSwitchProblemCause=accessSwitchProblemCause, ASModuleType=ASModuleType, accessSwitchFanRpmCurValue=accessSwitchFanRpmCurValue, accessSwitchVoltageMaxValue=accessSwitchVoltageMaxValue, asDhcpServerIp=asDhcpServerIp, accessSwitchMaintenance=accessSwitchMaintenance, accessSwitchVoltageIndex=accessSwitchVoltageIndex, accessSwitchSysTempMinValue=accessSwitchSysTempMinValue, asPacketForwardingPortList=asPacketForwardingPortList, asRadiusServerPort=asRadiusServerPort, thermalSensorFailure=thermalSensorFailure, accessSwitchSlotId=accessSwitchSlotId, accessSwitchSysTempTable=accessSwitchSysTempTable, asDot1xPortTable=asDot1xPortTable)

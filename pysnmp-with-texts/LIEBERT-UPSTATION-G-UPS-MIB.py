#
# PySNMP MIB module LIEBERT-UPSTATION-G-UPS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LIEBERT-UPSTATION-G-UPS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:06:58 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
sysUpTime, = mibBuilder.importSymbols("SNMPv2-MIB", "sysUpTime")
MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter64, Unsigned32, ObjectIdentity, TimeTicks, enterprises, iso, Bits, Integer32, ModuleIdentity, IpAddress, MibIdentifier, NotificationType, Counter32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter64", "Unsigned32", "ObjectIdentity", "TimeTicks", "enterprises", "iso", "Bits", "Integer32", "ModuleIdentity", "IpAddress", "MibIdentifier", "NotificationType", "Counter32", "NotificationType")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
emerson = MibIdentifier((1, 3, 6, 1, 4, 1, 476))
liebertCorp = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1))
liebertUps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1))
luExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1))
luExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 2))
luPrivate = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 3))
luCore = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1))
lcUpsIdent = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1))
lcUpsIdentManufacturer = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentManufacturer.setDescription('The UPS manufacturer.')
lcUpsIdentModel = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsIdentModel.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentModel.setDescription('The UPS Model designation.')
lcUpsIdentSoftwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(255, 255)).setFixedLength(255)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSoftwareVersion.setDescription('The UPS SNMP Agent software version.')
lcUpsIdentSpecific = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsIdentSpecific.setStatus('optional')
if mibBuilder.loadTexts: lcUpsIdentSpecific.setDescription('A reference to MIB definitions specific to the particular UPS being managed. This object is used to locate the product-specific MIB for this device. If this information is not present, its value should be the OBJECT IDENTIFIER { 0 0 }, which is a syntactically valid object identifier, and any conformant implementation of ASN.1 and BER must be able to generate and recognize this value.')
lcUpsBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2))
lcUpsBatTimeRemaining = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTimeRemaining.setDescription('The estimated time to depletion of battery charge. (Unit of measure: Minute)')
lcUpsBatTemperature = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatTemperature.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatTemperature.setDescription('The battery temperature. (Unit of measure: Degree, Centigrade)')
lcUpsBatVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatVoltage.setDescription('The current battery voltage. (Unit of measure: volt)')
lcUpsBatCurrent = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatCurrent.setDescription('The current battery discharging/charging current. (Unit of measure: Amp)')
lcUpsBatCapacity = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 2, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsBatCapacity.setStatus('optional')
if mibBuilder.loadTexts: lcUpsBatCapacity.setDescription('The current battery capacity in percentage of total available.')
lcUpsInput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3))
lcUpsInputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputFrequency.setDescription('The current input frequency. (Unit of measure: Hertz)')
lcUpsInputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputNumLines.setDescription('The number of input lines utilized in this device. This entry indicates the number of rows in the input table.')
lcUpsInputTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6), )
if mibBuilder.loadTexts: lcUpsInputTable.setStatus('optional')
lcUpsInputEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-G-UPS-MIB", "lcUpsInputLine"))
if mibBuilder.loadTexts: lcUpsInputEntry.setStatus('optional')
lcUpsInputLine = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputLine.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputLine.setDescription('The input Line.')
lcUpsInputVoltage = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputVoltage.setDescription('The input voltage. (Unit of measure: Volt)')
lcUpsInputCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputCurrent.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputCurrent.setDescription('The input current. (Unit of measure: Amp)')
lcUpsInputVA = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 3, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInputVA.setDescription('The input volt-amps.')
lcUpsOutput = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4))
lcUpsOutputFrequency = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputFrequency.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputFrequency.setDescription('The current output frequency. (Unit of measure: Hertz)')
lcUpsOutputNumLines = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 4, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsOutputNumLines.setStatus('optional')
if mibBuilder.loadTexts: lcUpsOutputNumLines.setDescription('The number of output lines utilized in this device. This entry indicates the number of rows in the output table.')
lcUpsInverter = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5))
lcUpsInverterStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("on", 2), ("off", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInverterStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInverterStatus.setDescription('The state of the inverter. Unknown is returned if the state can not be determined.')
lcUpsInverterTemp = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 5, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-32768, 32767))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsInverterTemp.setStatus('optional')
if mibBuilder.loadTexts: lcUpsInverterTemp.setDescription('The temperature of the inverter. (Unit of measure: degree, Centigrade)')
lcUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6))
lcUpsAlarms = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarms.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarms.setDescription('The current number of alarm conditions.')
lcUpsAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2), )
if mibBuilder.loadTexts: lcUpsAlarmTable.setStatus('optional')
lcUpsAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1), ).setIndexNames((0, "LIEBERT-UPSTATION-G-UPS-MIB", "lcUpsAlarmId"))
if mibBuilder.loadTexts: lcUpsAlarmEntry.setStatus('optional')
lcUpsAlarmId = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmId.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmId.setDescription('A unique identifier for an alarm condition. This value must remain constant between agent initializations.')
lcUpsAlarmDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmDescr.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmDescr.setDescription('A reference to an alarm description object. The object referenced should not be accessible, but rather be used to provide a unique description of the alarm condition.')
lcUpsAlarmTime = MibTableColumn((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 2, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsAlarmTime.setStatus('optional')
if mibBuilder.loadTexts: lcUpsAlarmTime.setDescription('The value of sysUpTime when the alarm condition occured.')
lcUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3))
lcUpsAlarmLowBatteryWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 1))
lcUpsAlarmLowBatteryShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 2))
lcUpsAlarmUtilFailed = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 3))
lcUpsAlarmOverTempWarning = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 4))
lcUpsAlarmOverTempShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 5))
lcUpsAlarmOutputOverloadShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 7))
lcUpsAlarmInputOverVoltage = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 8))
lcUpsAlarmBatteryBad = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 9))
lcUpsAlarmOnBattery = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 10))
lcUpsAlarmStopNoticeIssued = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 11))
lcUpsAlarmUpsOff = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 6, 3, 12))
lcUpsTest = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7))
lcUpsTestBattery = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("start", 2), ("abort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsTestBattery.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBattery.setDescription("Setting this variable to 'start' will initiate the battery test. Setting this variable to 'abort' will stop the battery test if the test is in- progress, otherwise it has no effect. Setting this variable to 'unknown' has no effect. Reading this variable will always result in a return value of 'unknown'. If 'lcUpsTestBatteryStatus' is 'failed' the test may not be performed again and the status will remain in the failure state.")
lcUpsTestBatteryStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("sysFailure", 5), ("notSupported", 6), ("inhibited", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestBatteryStatus.setDescription('The status of the battery test.')
lcUpsTestDiag = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("start", 2), ("abort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsTestDiag.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestDiag.setDescription("Setting this variable to 'start' will initiate the diagnostics test. Setting this variable to 'abort' will stop the diagnostics test if the test is in-progress, otherwise it has no effect. Setting this variable to 'unknown' has no effect. Reading this variable will always result in a return value of 'unknown'.")
lcUpsTestDiagStatus = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("passed", 2), ("failed", 3), ("inProgress", 4), ("sysFailure", 5), ("notSupported", 6), ("inhibited", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lcUpsTestDiagStatus.setStatus('optional')
if mibBuilder.loadTexts: lcUpsTestDiagStatus.setDescription('The status of the diagnostics test.')
lcUpsControl = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8))
lcUpsControlOutputOffDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn off the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOffTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOnDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnDelay.setDescription("Setting this object causes the agent to instruct the UPS to turn on the output after the indicated number of seconds. The agent counts down the number of seconds until the event will take place. The agent issues an lcUpsOutputOnTrap when the countdown finishes. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value cancel.")
lcUpsControlOutputOffTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOffTrapDelay.setDescription("When 'lcUpsControlOutputOffDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOffWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlOutputOnTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlOutputOnTrapDelay.setDescription("When 'lcUpsControlOutputOnDelay' reaches a value less than or equal to this object's value, an lcUpsOutputOnWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlUnixShutdownDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownDelay.setDescription("Setting this object causes the agent to instruct the UPS to perform a UNIX Shutdown in the indicated number of seconds. The agent counts down the number of seconds until the event will take place. A Unix shutdown is only valid if the UPS is on Battery. During a UNIX Shutdown, the UPS will turn off the output even if the Utility comes back on line before the shutdown time arrives. Note that different models have different clock resolutions, usually greater than 1 second. As a result, the command will only be accurate to the resolution of the UPS's clock. The command can be cancelled by setting lcUpsControlCancelCommand to the value 'cancel'.")
lcUpsControlUnixShutdownTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlUnixShutdownTrapDelay.setDescription("When 'lcUpsControlUnixShutdownDelay' reaches a value less than or equal to this object's value, an lcUpsUnixShutdownWarningTrap will be produced and this object will be reset to 0.")
lcUpsControlCancelCommands = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unknown", 1), ("cancel", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlCancelCommands.setDescription("Setting this variable to 'cancel' will cause the agent to issue instructions to the UPS to cancel all outstanding commands, such as lcUpsControlOutputOff, lcUpsControlOutputOn, lcUpsControlUnixShutdown.")
lcUpsControlRebootAgentDelay = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 8, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setStatus('optional')
if mibBuilder.loadTexts: lcUpsControlRebootAgentDelay.setDescription('Setting this object causes the agent to reboot after the indicated number of seconds have expired. The value will count down until the event takes place. The command can be cancelled by setting lcUpsControlCancleCommand to the value cancel.')
lcUpsNominal = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9))
lcUpsNominalOutputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVoltage.setDescription('The nominal output voltage. (Unit of measure: volt)')
lcUpsNominalInputVoltage = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputVoltage.setDescription('The nominal input voltage. (Unit of measure: volt)')
lcUpsNominalOutputVA = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputVA.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputVA.setDescription('The nominal Volt-Amp rating.')
lcUpsNominalOutputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalOutputFreq.setDescription('The nominal output frequency. (Unit of measure: Hertz)')
lcUpsNominalInputFreq = MibScalar((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 9, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setStatus('optional')
if mibBuilder.loadTexts: lcUpsNominalInputFreq.setDescription('The nominal input frequency. (Unit of measure: Hertz)')
lcUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11))
lcUpsOverloadShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,2)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverloadShutdownTrap.setDescription("An lcUpsOverloadShutdownTrap signifies that the UPS has detected an Overload condition where the output load has exceeded the UPS's rated capacity and has shut off the output.")
lcUpsOnBatteryTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOnBatteryTrap.setDescription('An lcUpsOnBatteryTrap signifies that the UPS is currently on Battery Power.')
lcUpsLowBatteryWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLowBatteryWarningTrap.setDescription('An lcUpsLowBatteryWarningTrap signifies that the UPS has entered a Low Battery state.')
lcUpsLowBatteryShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,5)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsLowBatteryShutdownTrap.setDescription('An lcUpsLowBatteryShutdownTrap signifies that the UPS has shut off the output due to a Low Battery state.')
lcUpsUtilPowerFailedTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,6)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerFailedTrap.setDescription('An lcUpsUtilPowerFailedTrap signifies that the utility power input to the UPS has been lost.')
lcUpsUtilPowerRestoredTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,7)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUtilPowerRestoredTrap.setDescription('An lcUpsUtilPowerRestoredTrap signifies that the utility power has been restored to the UPS.')
lcUpsInputOverVoltageTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,8)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsInputOverVoltageTrap.setDescription('An lcUpsInputOverVoltageTrap signifies that the UPS has detected a high input voltage condition.')
lcUpsOverTempWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,9)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverTempWarningTrap.setDescription('An lcUpsOverTempWarningTrap signifies that the UPS has detected a excessive temperature condition.')
lcUpsOverTempShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,10)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOverTempShutdownTrap.setDescription('An lcUpsOverTempShutdownTrap signifies that the UPS has detected a excessive temperature condition and shut off the output.')
lcUpsAlarmTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,11)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsAlarmTrap.setDescription('An Alarm condition has occurred and is being reported in the lcUpsAlarmTable.')
lcUpsOutputOffTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,12)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffTrap.setDescription('An lcUpsOutputOffTrap is sent when the UPS turns all of its output off, either at the inverter or via a relay.')
lcUpsOutputOffWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,13)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOffWarningTrap.setDescription('An lcUpsOutputOffWarningTrap is sent when the lcUpsControlOutputOffDelay reaches the value of lcUpsControlOutputOffTrapDelay.')
lcUpsOutputOnTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,14)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnTrap.setDescription('An lcUpsOutputOnTrap is sent when the UPS turns all of its output back on, either at the inverter or via a relay.')
lcUpsOutputOnWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,15)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsOutputOnWarningTrap.setDescription('An lcUpsOutputOnWarningTrap is sent when the lcUpsControlOutputOnDelay reaches the value of lcUpsControlOutputOnTrapDelay.')
lcUpsUnixShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,16)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownTrap.setDescription('An lcUpsUnixShutodwnTrap is sent 2 seconds before the UPS is scheduled to perform a Unix Shutdown.')
lcUpsUnixShutdownWarningTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 1, 11) + (0,17)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lcUpsUnixShutdownWarningTrap.setDescription('An lcUpsUnixShutdownWarningTrap is sent when the lcUpsControlUnixShudownDelay reaches the value of lcUpsControlUnixShutdownTrapDelay.')
luUPStationG = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4))
lgUpsAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6))
lgUpsAlarmConditions = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1))
lgUpsAlarmDCOverVoltageShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 1))
lgUpsAlarmOutputShortShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 2))
lgUpsAlarmLNReversedShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 3))
lgUpsAlarmRemoteShutdown = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 4))
lgUpsAlarmInputUVOnStartup = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 5))
lgUpsAlarmPFCFailedOnStartup = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 6, 1, 6))
lgUpsTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11))
lgUpsDCOverVoltageShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,1)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsDCOverVoltageShutdownTrap.setDescription('An lgUpsDCOverVoltageShutdownTrap signifies that the UPS has detected that battery voltage is over the nominal level.')
lgUpsOutputShortShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,2)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsOutputShortShutdownTrap.setDescription('An lgUpsOutputShortShutdownTrap signifies that the UPS has detected a short circuit across the output.')
lgUpsLNReversedShutdownTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,3)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsLNReversedShutdownTrap.setDescription('An lgUpsLNReversedShutdownTrap signifies that the UPS has detected that Line and Neutral have been reversed.')
lgUpsInputUVOnStartupTrap = NotificationType((1, 3, 6, 1, 4, 1, 476, 1, 1, 1, 4, 11) + (0,4)).setObjects(("SNMPv2-MIB", "sysUpTime"))
if mibBuilder.loadTexts: lgUpsInputUVOnStartupTrap.setDescription('An lgUpsInputUVOnStartupTrap signifies that the UPS detected a low voltage condition upon system startup.')
mibBuilder.exportSymbols("LIEBERT-UPSTATION-G-UPS-MIB", lcUpsAlarmUpsOff=lcUpsAlarmUpsOff, lcUpsIdentSpecific=lcUpsIdentSpecific, lgUpsAlarmRemoteShutdown=lgUpsAlarmRemoteShutdown, lcUpsOnBatteryTrap=lcUpsOnBatteryTrap, lgUpsAlarmPFCFailedOnStartup=lgUpsAlarmPFCFailedOnStartup, lgUpsAlarmInputUVOnStartup=lgUpsAlarmInputUVOnStartup, lcUpsAlarmStopNoticeIssued=lcUpsAlarmStopNoticeIssued, lcUpsAlarmConditions=lcUpsAlarmConditions, lcUpsNominalInputVoltage=lcUpsNominalInputVoltage, lgUpsAlarm=lgUpsAlarm, lcUpsAlarmOnBattery=lcUpsAlarmOnBattery, lcUpsAlarms=lcUpsAlarms, lgUpsTraps=lgUpsTraps, lcUpsInputVA=lcUpsInputVA, lcUpsTest=lcUpsTest, lcUpsOutputOffWarningTrap=lcUpsOutputOffWarningTrap, lcUpsOutputOnWarningTrap=lcUpsOutputOnWarningTrap, lcUpsAlarmOverTempWarning=lcUpsAlarmOverTempWarning, lcUpsInputEntry=lcUpsInputEntry, lcUpsInputCurrent=lcUpsInputCurrent, liebertUps=liebertUps, lcUpsTestBatteryStatus=lcUpsTestBatteryStatus, lcUpsTraps=lcUpsTraps, lcUpsNominalOutputVoltage=lcUpsNominalOutputVoltage, lgUpsOutputShortShutdownTrap=lgUpsOutputShortShutdownTrap, luCore=luCore, lcUpsInputTable=lcUpsInputTable, lgUpsAlarmDCOverVoltageShutdown=lgUpsAlarmDCOverVoltageShutdown, lcUpsInputLine=lcUpsInputLine, lcUpsOutput=lcUpsOutput, lcUpsBatTimeRemaining=lcUpsBatTimeRemaining, lcUpsControlOutputOnDelay=lcUpsControlOutputOnDelay, emerson=emerson, lgUpsLNReversedShutdownTrap=lgUpsLNReversedShutdownTrap, lcUpsOutputFrequency=lcUpsOutputFrequency, lcUpsTestBattery=lcUpsTestBattery, lcUpsInverterStatus=lcUpsInverterStatus, lcUpsOutputNumLines=lcUpsOutputNumLines, lcUpsNominalInputFreq=lcUpsNominalInputFreq, lcUpsBatTemperature=lcUpsBatTemperature, lgUpsAlarmConditions=lgUpsAlarmConditions, lcUpsOverloadShutdownTrap=lcUpsOverloadShutdownTrap, liebertCorp=liebertCorp, lcUpsBatCurrent=lcUpsBatCurrent, lcUpsUtilPowerFailedTrap=lcUpsUtilPowerFailedTrap, lcUpsAlarmEntry=lcUpsAlarmEntry, luExperimental=luExperimental, luPrivate=luPrivate, lcUpsTestDiag=lcUpsTestDiag, lcUpsControlUnixShutdownTrapDelay=lcUpsControlUnixShutdownTrapDelay, lcUpsInput=lcUpsInput, lcUpsControl=lcUpsControl, lcUpsInverterTemp=lcUpsInverterTemp, lgUpsAlarmOutputShortShutdown=lgUpsAlarmOutputShortShutdown, lcUpsOutputOffTrap=lcUpsOutputOffTrap, lcUpsIdentSoftwareVersion=lcUpsIdentSoftwareVersion, lcUpsAlarmOutputOverloadShutdown=lcUpsAlarmOutputOverloadShutdown, lcUpsInputNumLines=lcUpsInputNumLines, lcUpsControlCancelCommands=lcUpsControlCancelCommands, lcUpsControlOutputOnTrapDelay=lcUpsControlOutputOnTrapDelay, lcUpsAlarmTable=lcUpsAlarmTable, lcUpsAlarmTime=lcUpsAlarmTime, lcUpsAlarmLowBatteryShutdown=lcUpsAlarmLowBatteryShutdown, lcUpsBattery=lcUpsBattery, lcUpsUnixShutdownTrap=lcUpsUnixShutdownTrap, lcUpsAlarm=lcUpsAlarm, lcUpsControlOutputOffTrapDelay=lcUpsControlOutputOffTrapDelay, lcUpsControlUnixShutdownDelay=lcUpsControlUnixShutdownDelay, lcUpsUnixShutdownWarningTrap=lcUpsUnixShutdownWarningTrap, lcUpsAlarmLowBatteryWarning=lcUpsAlarmLowBatteryWarning, lcUpsIdent=lcUpsIdent, lcUpsControlRebootAgentDelay=lcUpsControlRebootAgentDelay, lgUpsInputUVOnStartupTrap=lgUpsInputUVOnStartupTrap, luExtensions=luExtensions, lcUpsOutputOnTrap=lcUpsOutputOnTrap, lcUpsAlarmId=lcUpsAlarmId, lcUpsTestDiagStatus=lcUpsTestDiagStatus, lcUpsControlOutputOffDelay=lcUpsControlOutputOffDelay, lcUpsAlarmDescr=lcUpsAlarmDescr, lcUpsBatCapacity=lcUpsBatCapacity, lcUpsNominalOutputFreq=lcUpsNominalOutputFreq, lcUpsOverTempShutdownTrap=lcUpsOverTempShutdownTrap, lcUpsLowBatteryShutdownTrap=lcUpsLowBatteryShutdownTrap, lcUpsInputOverVoltageTrap=lcUpsInputOverVoltageTrap, lcUpsAlarmUtilFailed=lcUpsAlarmUtilFailed, lgUpsAlarmLNReversedShutdown=lgUpsAlarmLNReversedShutdown, lcUpsInputVoltage=lcUpsInputVoltage, lcUpsAlarmTrap=lcUpsAlarmTrap, lcUpsIdentManufacturer=lcUpsIdentManufacturer, lcUpsInputFrequency=lcUpsInputFrequency, lcUpsInverter=lcUpsInverter, lcUpsOverTempWarningTrap=lcUpsOverTempWarningTrap, lcUpsAlarmBatteryBad=lcUpsAlarmBatteryBad, lcUpsBatVoltage=lcUpsBatVoltage, lcUpsUtilPowerRestoredTrap=lcUpsUtilPowerRestoredTrap, lcUpsAlarmInputOverVoltage=lcUpsAlarmInputOverVoltage, lcUpsNominalOutputVA=lcUpsNominalOutputVA, lcUpsLowBatteryWarningTrap=lcUpsLowBatteryWarningTrap, lcUpsIdentModel=lcUpsIdentModel, lcUpsAlarmOverTempShutdown=lcUpsAlarmOverTempShutdown, lcUpsNominal=lcUpsNominal, lgUpsDCOverVoltageShutdownTrap=lgUpsDCOverVoltageShutdownTrap, luUPStationG=luUPStationG)

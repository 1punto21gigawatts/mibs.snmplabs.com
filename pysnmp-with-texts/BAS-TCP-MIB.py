#
# PySNMP MIB module BAS-TCP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BAS-TCP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:34:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint")
BasSlotId, basAliasTcp, BasChassisId, BasInterfaceId, BasLogicalPortId = mibBuilder.importSymbols("BAS-MIB", "BasSlotId", "basAliasTcp", "BasChassisId", "BasInterfaceId", "BasLogicalPortId")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, Integer32, IpAddress, NotificationType, Bits, Counter64, Unsigned32, ModuleIdentity, TimeTicks, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Integer32", "IpAddress", "NotificationType", "Bits", "Counter64", "Unsigned32", "ModuleIdentity", "TimeTicks", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "MibIdentifier")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
basAliasTcpMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1))
if mibBuilder.loadTexts: basAliasTcpMib.setLastUpdated('9810071415Z')
if mibBuilder.loadTexts: basAliasTcpMib.setOrganization('Broadband Access Systems')
if mibBuilder.loadTexts: basAliasTcpMib.setContactInfo(' Tech Support Broadband Access Systems 201 Forest Street Marlboro, MA 01752 U.S.A. 508-485-8200 support@basystems.com')
if mibBuilder.loadTexts: basAliasTcpMib.setDescription('This module defines the MIB objects for a Broadband Access System IP Forwarding component.')
basTcpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1))
basTcpTable = MibTable((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1), )
if mibBuilder.loadTexts: basTcpTable.setStatus('current')
if mibBuilder.loadTexts: basTcpTable.setDescription('A list of TCP stats')
basTcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1), ).setIndexNames((0, "BAS-TCP-MIB", "basTcpChassis"), (0, "BAS-TCP-MIB", "basTcpSlot"), (0, "BAS-TCP-MIB", "basTcpIf"), (0, "BAS-TCP-MIB", "basTcpLPort"))
if mibBuilder.loadTexts: basTcpEntry.setStatus('current')
if mibBuilder.loadTexts: basTcpEntry.setDescription('Objects for the TCP mib.')
basTcpRtoAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("constant", 2), ("rsre", 3), ("vanj", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpRtoAlgorithm.setStatus('current')
if mibBuilder.loadTexts: basTcpRtoAlgorithm.setDescription('The algorithm used to determine the timeout value used for retransmitting unacknowledged octets.')
basTcpRtoMin = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 2), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpRtoMin.setStatus('current')
if mibBuilder.loadTexts: basTcpRtoMin.setDescription('The minimum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout. In particular, when the timeout algorithm is rsre(3), an object of this type has the semantics of the LBOUND quantity described in RFC 793.')
basTcpRtoMax = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 3), Integer32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpRtoMax.setStatus('current')
if mibBuilder.loadTexts: basTcpRtoMax.setDescription('The maximum value permitted by a TCP implementation for the retransmission timeout, measured in milliseconds. More refined semantics for objects of this type depend upon the algorithm used to determine the retransmission timeout. In particular, when the timeout algorithm is rsre(3), an object of this type has the semantics of the UBOUND quantity described in RFC 793.')
basTcpMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpMaxConn.setStatus('current')
if mibBuilder.loadTexts: basTcpMaxConn.setDescription('The limit on the total number of TCP connections the entity can support. In entities where the maximum number of connections is dynamic, this object should contain the value -1.')
basTcpActiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpActiveOpens.setStatus('current')
if mibBuilder.loadTexts: basTcpActiveOpens.setDescription('The number of times TCP connections have made a direct transition to the SYN-SENT state from the CLOSED state.')
basTcpPassiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpPassiveOpens.setStatus('current')
if mibBuilder.loadTexts: basTcpPassiveOpens.setDescription('The number of times TCP connections have made a direct transition to the SYN-RCVD state from the LISTEN state.')
basTcpAttemptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpAttemptFails.setStatus('current')
if mibBuilder.loadTexts: basTcpAttemptFails.setDescription('The number of times TCP connections have made a direct transition to the CLOSED state from either the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.')
basTcpEstabResets = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpEstabResets.setStatus('current')
if mibBuilder.loadTexts: basTcpEstabResets.setDescription('The number of times TCP connections have made a direct transition to the CLOSED state from either the ESTABLISHED state or the CLOSE-WAIT state.')
basTcpCurrEstab = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpCurrEstab.setStatus('current')
if mibBuilder.loadTexts: basTcpCurrEstab.setDescription('The number of TCP connections for which the current state is either ESTABLISHED or CLOSE- WAIT.')
basTcpInSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpInSegs.setStatus('current')
if mibBuilder.loadTexts: basTcpInSegs.setDescription('The total number of segments received, including those received in error. This count includes segments received on currently established connections.')
basTcpOutSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpOutSegs.setStatus('current')
if mibBuilder.loadTexts: basTcpOutSegs.setDescription('The total number of segments sent, including those on current connections but excluding those containing only retransmitted octets.')
basTcpRetransSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpRetransSegs.setStatus('current')
if mibBuilder.loadTexts: basTcpRetransSegs.setDescription('The total number of segments retransmitted - that is, the number of TCP segments transmitted containing one or more previously transmitted octets.')
basTcpChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 13), BasChassisId())
if mibBuilder.loadTexts: basTcpChassis.setStatus('current')
if mibBuilder.loadTexts: basTcpChassis.setDescription('The BAS Chassis ID of the Route Server.')
basTcpSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 14), BasSlotId())
if mibBuilder.loadTexts: basTcpSlot.setStatus('current')
if mibBuilder.loadTexts: basTcpSlot.setDescription('The BAS Slot ID of the Route Server.')
basTcpIf = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 15), BasInterfaceId())
if mibBuilder.loadTexts: basTcpIf.setStatus('current')
if mibBuilder.loadTexts: basTcpIf.setDescription('The BAS interface ID of the Route Server.')
basTcpLPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 1, 1, 16), BasLogicalPortId())
if mibBuilder.loadTexts: basTcpLPort.setStatus('current')
if mibBuilder.loadTexts: basTcpLPort.setDescription('The BAS logical port ID of the Route Server.')
basTcpConnTable = MibTable((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2), )
if mibBuilder.loadTexts: basTcpConnTable.setStatus('current')
if mibBuilder.loadTexts: basTcpConnTable.setDescription('A table containing TCP connection-specific information.')
basTcpConnEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1), ).setIndexNames((0, "BAS-TCP-MIB", "basTcpConnChassis"), (0, "BAS-TCP-MIB", "basTcpConnSlot"), (0, "BAS-TCP-MIB", "basTcpConnIf"), (0, "BAS-TCP-MIB", "basTcpConnLPort"), (0, "BAS-TCP-MIB", "basTcpConnLocalAddress"), (0, "BAS-TCP-MIB", "basTcpConnLocalPort"), (0, "BAS-TCP-MIB", "basTcpConnRemAddress"), (0, "BAS-TCP-MIB", "basTcpConnRemPort"))
if mibBuilder.loadTexts: basTcpConnEntry.setStatus('current')
if mibBuilder.loadTexts: basTcpConnEntry.setDescription('A conceptual row of the tcpConnTable containing information about a particular current TCP connection. Each row of this table is transient, in that it ceases to exist when (or soon after) the connection makes the transition to the CLOSED state.')
basTcpConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("closed", 1), ("listen", 2), ("synSent", 3), ("synReceived", 4), ("established", 5), ("finWait1", 6), ("finWait2", 7), ("closeWait", 8), ("lastAck", 9), ("closing", 10), ("timeWait", 11), ("deleteTCB", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: basTcpConnState.setStatus('current')
if mibBuilder.loadTexts: basTcpConnState.setDescription("The state of this TCP connection. The only value which may be set by a management station is deleteTCB(12). Accordingly, it is appropriate for an agent to return a `badValue' response if a management station attempts to set this object to any other value. If a management station sets this object to the value deleteTCB(12), then this has the effect of deleting the TCB (as defined in RFC 793) of the corresponding connection on the managed node, resulting in immediate termination of the connection. As an implementation-specific option, a RST segment may be sent from the managed node to the other TCP endpoint (note however that RST segments are not sent reliably).")
basTcpConnLocalAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpConnLocalAddress.setStatus('current')
if mibBuilder.loadTexts: basTcpConnLocalAddress.setDescription('The local IP address for this TCP connection. In the case of a connection in the listen state which is willing to accept connections for any IP interface associated with the node, the value 0.0.0.0 is used.')
basTcpConnLocalPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpConnLocalPort.setStatus('current')
if mibBuilder.loadTexts: basTcpConnLocalPort.setDescription('The local port number for this TCP connection.')
basTcpConnRemAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpConnRemAddress.setStatus('current')
if mibBuilder.loadTexts: basTcpConnRemAddress.setDescription('The remote IP address for this TCP connection.')
basTcpConnRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpConnRemPort.setStatus('current')
if mibBuilder.loadTexts: basTcpConnRemPort.setDescription('The remote port number for this TCP connection.')
basTcpConnChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 6), BasChassisId())
if mibBuilder.loadTexts: basTcpConnChassis.setStatus('current')
if mibBuilder.loadTexts: basTcpConnChassis.setDescription('The BAS Chassis ID of the Route Server.')
basTcpConnSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 7), BasSlotId())
if mibBuilder.loadTexts: basTcpConnSlot.setStatus('current')
if mibBuilder.loadTexts: basTcpConnSlot.setDescription('The BAS Slot ID of the Route Server.')
basTcpConnIf = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 8), BasInterfaceId())
if mibBuilder.loadTexts: basTcpConnIf.setStatus('current')
if mibBuilder.loadTexts: basTcpConnIf.setDescription('The BAS interface ID of the Route Server.')
basTcpConnLPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 2, 1, 9), BasLogicalPortId())
if mibBuilder.loadTexts: basTcpConnLPort.setStatus('current')
if mibBuilder.loadTexts: basTcpConnLPort.setDescription('The BAS logical port ID of the Route Server.')
basTcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3), )
if mibBuilder.loadTexts: basTcpStatsTable.setStatus('current')
if mibBuilder.loadTexts: basTcpStatsTable.setDescription('A list of Route Server forwarding table distribution mechanism statistics.')
basTcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3, 1), ).setIndexNames((0, "BAS-TCP-MIB", "basTcpStatsChassis"), (0, "BAS-TCP-MIB", "basTcpStatsSlot"), (0, "BAS-TCP-MIB", "basTcpStatsIf"), (0, "BAS-TCP-MIB", "basTcpStatsLPort"))
if mibBuilder.loadTexts: basTcpStatsEntry.setStatus('current')
if mibBuilder.loadTexts: basTcpStatsEntry.setDescription('Objects for the TCP mib.')
basTcpInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpInErrs.setStatus('current')
if mibBuilder.loadTexts: basTcpInErrs.setDescription('The total number of segments received in error (e.g., bad TCP checksums).')
basTcpOutRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: basTcpOutRsts.setStatus('current')
if mibBuilder.loadTexts: basTcpOutRsts.setDescription('The number of TCP segments sent containing the RST flag.')
basTcpStatsChassis = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3, 1, 3), BasChassisId())
if mibBuilder.loadTexts: basTcpStatsChassis.setStatus('current')
if mibBuilder.loadTexts: basTcpStatsChassis.setDescription('The BAS Chassis ID of the Route Server.')
basTcpStatsSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3, 1, 4), BasSlotId())
if mibBuilder.loadTexts: basTcpStatsSlot.setStatus('current')
if mibBuilder.loadTexts: basTcpStatsSlot.setDescription('The BAS Slot ID of the Route Server.')
basTcpStatsIf = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3, 1, 5), BasInterfaceId())
if mibBuilder.loadTexts: basTcpStatsIf.setStatus('current')
if mibBuilder.loadTexts: basTcpStatsIf.setDescription('The BAS interface ID of the Route Server.')
basTcpStatsLPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3493, 2, 7, 3, 1, 1, 3, 1, 6), BasLogicalPortId())
if mibBuilder.loadTexts: basTcpStatsLPort.setStatus('current')
if mibBuilder.loadTexts: basTcpStatsLPort.setDescription('The BAS logical port ID of the Route Server.')
mibBuilder.exportSymbols("BAS-TCP-MIB", basTcpStatsTable=basTcpStatsTable, basTcpChassis=basTcpChassis, basTcpConnLocalAddress=basTcpConnLocalAddress, basAliasTcpMib=basAliasTcpMib, basTcpObjects=basTcpObjects, basTcpEstabResets=basTcpEstabResets, basTcpConnRemAddress=basTcpConnRemAddress, basTcpSlot=basTcpSlot, basTcpConnRemPort=basTcpConnRemPort, basTcpConnChassis=basTcpConnChassis, basTcpConnEntry=basTcpConnEntry, basTcpRetransSegs=basTcpRetransSegs, basTcpConnTable=basTcpConnTable, basTcpConnLPort=basTcpConnLPort, basTcpInErrs=basTcpInErrs, basTcpRtoMax=basTcpRtoMax, basTcpConnState=basTcpConnState, basTcpCurrEstab=basTcpCurrEstab, basTcpEntry=basTcpEntry, basTcpTable=basTcpTable, basTcpAttemptFails=basTcpAttemptFails, basTcpIf=basTcpIf, basTcpActiveOpens=basTcpActiveOpens, basTcpStatsLPort=basTcpStatsLPort, basTcpConnIf=basTcpConnIf, basTcpOutSegs=basTcpOutSegs, PYSNMP_MODULE_ID=basAliasTcpMib, basTcpInSegs=basTcpInSegs, basTcpStatsSlot=basTcpStatsSlot, basTcpConnLocalPort=basTcpConnLocalPort, basTcpRtoAlgorithm=basTcpRtoAlgorithm, basTcpRtoMin=basTcpRtoMin, basTcpPassiveOpens=basTcpPassiveOpens, basTcpStatsChassis=basTcpStatsChassis, basTcpMaxConn=basTcpMaxConn, basTcpStatsEntry=basTcpStatsEntry, basTcpLPort=basTcpLPort, basTcpStatsIf=basTcpStatsIf, basTcpConnSlot=basTcpConnSlot, basTcpOutRsts=basTcpOutRsts)

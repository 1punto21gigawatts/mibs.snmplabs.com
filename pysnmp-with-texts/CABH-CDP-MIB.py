#
# PySNMP MIB module CABH-CDP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CABH-CDP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:43:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
clabProjCableHome, = mibBuilder.importSymbols("CLAB-DEF-MIB", "clabProjCableHome")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
iso, NotificationType, ModuleIdentity, Gauge32, MibIdentifier, Integer32, TimeTicks, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Counter32, Bits, Unsigned32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "NotificationType", "ModuleIdentity", "Gauge32", "MibIdentifier", "Integer32", "TimeTicks", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Counter32", "Bits", "Unsigned32", "ObjectIdentity")
TextualConvention, DisplayString, PhysAddress, TimeStamp, DateAndTime, RowStatus, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress", "TimeStamp", "DateAndTime", "RowStatus", "TruthValue")
cabhCdpMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4))
if mibBuilder.loadTexts: cabhCdpMib.setLastUpdated('200412160000Z')
if mibBuilder.loadTexts: cabhCdpMib.setOrganization('CableLabs Broadband Access Department')
if mibBuilder.loadTexts: cabhCdpMib.setContactInfo('Kevin Luehrs Postal: Cable Television Laboratories, Inc. 858 Coal Creek Circle Louisville, Colorado 80027 U.S.A. Phone: +1 303-661-9100 Fax: +1 303-661-9199 E-mail: k.luehrs@cablelabs.com; mibs@cablelabs.com')
if mibBuilder.loadTexts: cabhCdpMib.setDescription('This MIB module supplies the basic management objects for the CableHome DHCP Portal (CDP) portion of the PS database.')
cabhCdpObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1))
cabhCdpBase = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1))
cabhCdpAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2))
cabhCdpServer = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3))
cabhCdpSetToFactory = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpSetToFactory.setStatus('current')
if mibBuilder.loadTexts: cabhCdpSetToFactory.setDescription('Reading this object always returns false(2). When the cabhCdpSetToFactory object is set to true(1), the PS must take the following actions: 1. Clear all cabhCdpLanAddrEntries in the CDP LAN Address Table. 2. The CDS must offer the factory default DHCP options at the next lease renewal time. 3. Reset the following objects to their factory default values: cabhCdpLanTransThreshold, cabhCdpLanTransAction, cabhCdpWanDataIpAddrCount, cabhCdpTimeOffsetSelection, cabhCdpSnmpSetTimeOffset, cabhCdpDaylightSavingTimeEnable, cabhCdpLanPoolStartType, cabhCdpLanPoolStart, cabhCdpLanPoolEndType, cabhCdpLanPoolEnd, cabhCdpServerNetworkNumberType, cabhCdpServerNetworkNumber, cabhCdpServerSubnetMaskType, cabhCdpServerSubnetMask, cabhCdpServerTimeOffset, cabhCdpServerRouterType, cabhCdpServerRouter, cabhCdpServerDnsAddressType, cabhCdpServerDnsAddress, cabhCdpServerSyslogAddressType, cabhCdpServerSyslogAddress, cabhCdpServerDomainName, cabhCdpServerTTL, cabhCdpServerInterfaceMTU, cabhCdpServerVendorSpecific, cabhCdpServerLeaseTime, cabhCdpServerDhcpAddressType, cabhCdpServerDhcpAddress, cabhCdpServerCommitStatus')
cabhCdpLanTransCurCount = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpLanTransCurCount.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanTransCurCount.setDescription('The current number of active leases in the cabhCdpLanAddrTable (the number of row entries in the table that have a cabhCdpLanAddrMethod value of reservationActive(2) or dynamicActive (4)). This count does not include expired leases or reservations not associated with a current lease.')
cabhCdpLanTransThreshold = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65533))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpLanTransThreshold.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanTransThreshold.setDescription('The threshold number of LAN-Trans IP addresses allocated or assigned above which the PS generates an alarm condition. Whenever an attempt is made to allocate a LAN-Trans IP address when cabhCdpLanTransCurCount is greater than or equal to cabhCdpLanTransThreshold, an event is generated. A value of 0 indicates that the CDP sets the threshold at the highest number of addresses in the LAN address pool.')
cabhCdpLanTransAction = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("noAssignment", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpLanTransAction.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanTransAction.setDescription('The action taken when the CDS assigns a LAN-Trans address and the number of LAN-Trans addresses assigned (cabhCdpLanTransCurCount) is greater than the threshold (cabhCdpLanTransThreshold) The actions are as follows: normal - assign a LAN-Trans IP address as would normally occur if the threshold was not exceeded. noAssignment - do not assign a LAN-Trans IP address.')
cabhCdpWanDataIpAddrCount = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpWanDataIpAddrCount.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataIpAddrCount.setDescription("This is the number of WAN-Data IP addresses the PS's CDC must attempt to acquire via DHCP. When this MIB object is incremented the CDC MUST immediately attempt to acquire additional WAN-Data IP addresses. When this MIB object is decremented the CDC MUST not renew the leases for the appropriate number of WAN-Data IP addresses.")
cabhCdpLastSetToFactory = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 6), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpLastSetToFactory.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLastSetToFactory.setDescription('The value of sysUpTime when cabhCdpSetToFactory was last set to true. Zero if never reset.')
cabhCdpTimeOffsetSelection = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("useDhcpOption2", 1), ("useSnmpSetOffset", 2))).clone('useDhcpOption2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpTimeOffsetSelection.setStatus('current')
if mibBuilder.loadTexts: cabhCdpTimeOffsetSelection.setDescription('This object selects the source to be used by the PS in determining the time offset to the time of day acquired from the time server. It is intended to be used in cases where the time zone information provisioned by the ToD server or DHCP Server (in DHCP Option 2) is different from the time zone where the provisioned device is physically located. Setting this object to useDhcpOption2(1) configures the PS to use the value of DHCP Option 2 from the DHCP ACK message for time of day offset. Setting this object to useSnmpSetOffset(2) configures the PS to use the value of cabhCdpServerSnmpSetTimeOffset for time of day offset, and to ignore DHCP Option 2. When the value of this object is changed the PS MUST immediately begin using the time offset specified by the value of this object, regardless of which time offset the PS was using before the update occurred.')
cabhCdpSnmpSetTimeOffset = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-43200, 46800))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpSnmpSetTimeOffset.setStatus('current')
if mibBuilder.loadTexts: cabhCdpSnmpSetTimeOffset.setDescription("This object is intended to be used in cases where the service provider's provisioning system serves devices in multiple time zones, or for other times when the service provider wants UTC time offset to be provisioned in a device other than from the ToD server or from the DHCP Server (in DHCP Option 2). This object allows a manager to set a value for UTC time offset. If DHCP Option 2 is not present in the DHCP ACK message, or if the value of DHCP Option 2 is null, and time offset information is not provided in the response received from the time of day server, the PS MUST add the value of cabhCdpServerTimeOffset to the UTC time acquired from the time of day server to create the current time of day. If the value of cabhCdpServerTimeOffsetSelection is useSnmpSetOffset(2), the PS adds the value of cabhCdpServerSnmpSetTimeOffset to the UTC time acquired from the time of day server to create the current time of day. If the value of cabhCdpServerTimeOffsetSelection is useDhcpOption2(1) the PS ignores cabhCdpServerSnmpSetTimeOffset.")
cabhCdpDaylightSavingTimeEnable = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpDaylightSavingTimeEnable.setStatus('current')
if mibBuilder.loadTexts: cabhCdpDaylightSavingTimeEnable.setDescription('This object allows a manager to configure the PS to adjust the current time of day based on Daylight Saving Time. If the value of this object is enabled(1), the PS adds 3600 seconds and the time offset specified by cabhCdpServerTimeOffsetSelection to the UTC time acquired from the time of day server to create the current time of day during Daylight Saving Time, and adds only the time offset specified by cabhCdpServerTimeOffsetSelection to the UTC time acquired from the time of day server during standard time. The PS is responsible for knowing the date and time of each transition between Daylight Saving Time and standard time. If the value of this object is disabled(2), the PS adds only the time offset specified by cabhCdpServerTimeOffsetSelection to the UTC time acquired from the time of day server.')
cabhCdpLanAddrTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1), )
if mibBuilder.loadTexts: cabhCdpLanAddrTable.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrTable.setDescription("This table is a list of LAN-Trans realm parameters. This table has one row entry for each allocated LAN-Trans IP address. Each row must have at least a valid cabhCdpLanAddrMethod, a cabhCdpLanAddrIpType, a unique cabhCdpLanAddrIp, and a unique cabhCdpLanAddrClientId value. Static/Manual address assignment: To create a new DHCP address reservation, the NMS creates a row with: an index comprised of a new cabhCdpLanAddrIp and its cabhCdpLanAddrIpType, a new unique cabhCdpLanAddrClientID, (an empty LeaseCreateTime and empty LeaseExpireTime,) and a cabhCdpLanDataAddrRowStatus of createAndGo(4). If the syntax and values of the new row - indicating a reservation - are valid, the PS must set cabhCdpLanAddrMethod to reservationInactive(1) and cabhCdpLanDataAddrRowStatus to active(1). When the PS grants a lease for a reserved IP, it must set the cabhCdpLanAddrMethod object for that row to reservationActive(2). When a lease for a reserved IP expires, the PS must set the corresponding row's cabhCdpLanAddrMethod object to reservationInactive(1). For row entries that represent lease reservations - rows in which the cabhCdpLanAddrMethod object has a value of either reservationInactive(1) or reservationActive(2) - the cabhCdpLanAddrIpType, cabhCdpLanAddrIp, cabhCdpLanAddrClientID, cabhCdpLanAddrMethod, and cabhCdpLanAddrHostName object values must persist across PS reboots. Dynamic address assignment: When the PS grants a lease for a non-reserved IP, it must set the cabhCdpLanAddrMethod object for that row to dynamicActive(4). When a lease for a non-reserved IP expires, the PS must set the corresponding row's cabhCdpLanAddrMethod object to dynamicInactive(3). The PS must create new row entries using cabhCdpLanAddrIp values that are unique to this table. If all cabhCdpLanAddrIp values in the range defined by cabhCdpLanPoolStart and cabhCdpLanPoolEnd are in use in this table, the PS may overwrite the cabhCdpLanAddrClientId of a row that has a cabhCdpLanAddrMethod object with a value of dynamicInactive(3) with a new cabhCdpLanAddrClientId value and use that cabhCdpLanAddrIp as part of a new lease. For row entries that represent active leases - rows in which the cabhCdpLanAddrMethod object has a value of dynamicActive(4) - the cabhCdpLanAddrIpType, cabhCdpLanAddrIp, cabhCdpLanAddrClientID, cabhCdpLanAddrMethod, and cabhCdpLanAddrHostName object values must persist across PS reboots.")
cabhCdpLanAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1), ).setIndexNames((0, "CABH-CDP-MIB", "cabhCdpLanAddrIpType"), (0, "CABH-CDP-MIB", "cabhCdpLanAddrIp"))
if mibBuilder.loadTexts: cabhCdpLanAddrEntry.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrEntry.setDescription('List of general parameters pertaining to LAN-Trans IP address reservations and leases.')
cabhCdpLanAddrIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cabhCdpLanAddrIpType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrIpType.setDescription('The type of IP address assigned to the LAN IP Device in the LAN-Trans Realm.')
cabhCdpLanAddrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 2), InetAddress())
if mibBuilder.loadTexts: cabhCdpLanAddrIp.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrIp.setDescription('The address assigned to the LAN IP Device. This parameter is entered by the CDP when the CDS grants a lease to a LAN IP Device in the LAN-Trans realm and creates a row in this table. Alternatively, this parameter can be entered by the NMS through the CMP, when the NMS creates a new DHCP address reservation. Each cabhCdpLanAddrIp in the table must fall within the range of IPs defined inclusively by cabhCdpLanPoolStart and cabhCdpLanPoolEnd. The PS must return an inconsistentValue error if the NMS attempts to create a row entry with a cabhCdpLanAddrIP value that falls outside of this range or is not unique from all existing cabhCdpLanAddrIP entries in this table. The address type of this object is specified by cabhCdpLanAddrIpType.')
cabhCdpLanAddrClientID = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 3), PhysAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cabhCdpLanAddrClientID.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrClientID.setDescription("The client's (i.e., LAN IP Device's) hardware address as indicated in the chaddr field of its DHCP REQUEST message. There is a one-to-one relationship between the hardware address and the LAN IP Device. This parameter is entered by the PS (CDP) when the CDS grants a lease to a LAN IP Device in the LAN-Trans realm and creates a row in this table. Alternatively this parameter can be created by the NMS through the CMP, when the NMS creates a new DHCP address reservation by accessing the cabhCdpLanDataAddrRowStatus object with an index comprised of a unique cabhCdpLanAddrIp and creating a row with a unique cabhCdpLanAddrClientID.")
cabhCdpLanAddrLeaseCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 4), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpLanAddrLeaseCreateTime.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrLeaseCreateTime.setDescription('This is the date and time when the LAN IP lease was created (if it has not yet been renewed) or last renewed. This MIB object contains a zero valued 11 byte string when a reservation is created for a LAN IP address and it maintains this value until the LAN IP Device acquires its lease and cabhCdpLanAddrMethod becomes reservationActive(2).')
cabhCdpLanAddrLeaseExpireTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 5), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpLanAddrLeaseExpireTime.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrLeaseExpireTime.setDescription('This is the date and time when the LAN IP address lease expired or will expire. This MIB object contains a zero valued 11 byte string when a reservation is created for a LAN IP address and it maintains this value until the LAN IP Device acquires its lease and cabhCdpLanAddrMethod becomes reservationActive(2).')
cabhCdpLanAddrMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("mgmtReservationInactive", 1), ("mgmtReservationActive", 2), ("dynamicInactive", 3), ("dynamicActive", 4), ("psReservationInactive", 5), ("psReservationActive", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpLanAddrMethod.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrMethod.setDescription('The IP allocation method indicated by this row. The value of mgmtReservationInactive(1) indicates an externally provisioned IP address reservation that has not yet been leased or that has an expired lease. This indicates an IP address lease reservation created either by an operator or a user. The value of mgmtReservationActive(2) indicates an externally provisioned IP address reservation that has an active lease. This indicates an IP address lease reservation created either by an operator or a user. The value of dynamicInactive(3) indicates an IP address that was once dynamically assigned to a LAN-Trans by the PS device but currently has an expired lease. The value of dynamicActive(4)indicates an IP Address that was dynamically assigned to a LAN-Trans device by the PS and has a current active lease. The value of psReservationInactive(5) indicates an IP address reservation created by some internal process of the PS and has not yet been leased or has an expired lease. The value of psReservationActive(6) indicates an IP address reservation created by some internal process of the PS that has an active lease.')
cabhCdpLanAddrHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpLanAddrHostName.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrHostName.setDescription('This is the Host Name of the LAN IP address, based on DCHP option 12.')
cabhCdpLanAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cabhCdpLanAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanAddrRowStatus.setDescription("The RowStatus interlock for creation and deletion of row entries. The PS must not allow the NMS to set RowStatus to notInService(2). The PS must assign a RowStatus of notInService(2) to any new row entry created with a non-unique, cabhCdpLanAddrClientID value. The PS must assign a RowStatus of notReady(3) to any new row entry created without a cabhCdpLanAddrClientID. The PS will prevent modification of this table's columns and return an inconsistentValue error, if the NMS attempts to make such modifications while the RowStatus is active(1).")
cabhCdpWanDataAddrTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2), )
if mibBuilder.loadTexts: cabhCdpWanDataAddrTable.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrTable.setDescription('This table contains WAN-Data address realm information.')
cabhCdpWanDataAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1), ).setIndexNames((0, "CABH-CDP-MIB", "cabhCdpWanDataAddrIndex"))
if mibBuilder.loadTexts: cabhCdpWanDataAddrEntry.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrEntry.setDescription('List of general parameter for CDP WAN-Data address realm.')
cabhCdpWanDataAddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cabhCdpWanDataAddrIndex.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrIndex.setDescription('Index into table.')
cabhCdpWanDataAddrClientId = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cabhCdpWanDataAddrClientId.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrClientId.setDescription('A unique WAN-Data ClientID used when attempting to acquire a WAN-Data IP Address via DHCP.')
cabhCdpWanDataAddrIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 3), InetAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpWanDataAddrIpType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrIpType.setDescription('The address type assigned on the WAN-Data side.')
cabhCdpWanDataAddrIp = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpWanDataAddrIp.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrIp.setDescription('The address assigned on the WAN-Data side.')
cabhCdpWanDataAddrRenewalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpWanDataAddrRenewalTime.setStatus('deprecated')
if mibBuilder.loadTexts: cabhCdpWanDataAddrRenewalTime.setDescription('This is the time remaining before the lease expires. This is based on DHCP Option 51.')
cabhCdpWanDataAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cabhCdpWanDataAddrRowStatus.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrRowStatus.setDescription('The RowStatus interlock for creation and deletion of row entries. Any writable object in a row can be modified at any time while the row is active(1). The PS must assign a RowStatus of notInService(2) to any new row entry created with a cabhCdpWanDataAddrClientId that is not unique within this table.')
cabhCdpWanDataAddrLeaseCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpWanDataAddrLeaseCreateTime.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrLeaseCreateTime.setDescription('This is the date and time when the WAN-Data address lease was created (if it has not yet been renewed) or last renewed.')
cabhCdpWanDataAddrLeaseExpireTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 2, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpWanDataAddrLeaseExpireTime.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDataAddrLeaseExpireTime.setDescription('This is the date and time when the WAN-Data address lease expired or will expire.')
cabhCdpWanDnsServerTable = MibTable((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 3), )
if mibBuilder.loadTexts: cabhCdpWanDnsServerTable.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDnsServerTable.setDescription("This table contains the IP addresses of cable network and Internet DNS servers, in the order of preference in which the PS's CNP will query them, when it cannot resolve a DNS query using local information. Entries in this table are updated with the information contained in DHCP Option 6, received during both the WAN-Man and WAN-Data IP acquisition processes.")
cabhCdpWanDnsServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 3, 1), ).setIndexNames((0, "CABH-CDP-MIB", "cabhCdpWanDnsServerOrder"))
if mibBuilder.loadTexts: cabhCdpWanDnsServerEntry.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDnsServerEntry.setDescription('List of cable network and Internet DNS servers.')
cabhCdpWanDnsServerOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2), ("tertiary", 3))))
if mibBuilder.loadTexts: cabhCdpWanDnsServerOrder.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDnsServerOrder.setDescription('The order of preference for cable network and Internet DNS servers, as listed in DHCP option 6 (Domain Server). Any time the CDC receives valid IP address information within DHCP Option 6, as part of lease acquisition or renewal of a WAN-Man or WAN-Data IP, it must update this information into this table. As entries in DHCP Option 6 are listed in order of preference, the highest priority entry in DHCP Option 6 must correspond to the row with a cabhCdpWanDnsServerOrder with a value of 1. If DHCP Option 6 contains 1 valid IP address, the PS MUST update the row with a cabhCdpWanDnsServerOrder value of 1 and MUST NOT modify rows with cabhCdpWanDnsServerOrder values of 2 & 3 (if they exist). If DHCP Option 6 contains 2 valid IP addresses, the PS MUST update the rows with cabhCdpWanDnsServerOrder values of 1 and 2 and MUST NOT modify the row with cabhCdpWanDnsServerOrder value of 3 (if it exists). If DHCP Option 6 contains 3 valid IP addresses, the PS MUST update rows with cabhCdpWanDnsServerOrder values of 1, 2, and 3. Any DNS server information included in DHCP Option 6 beyond primary, secondary and tertiary will not be represented in this table.')
cabhCdpWanDnsServerIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 3, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpWanDnsServerIpType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDnsServerIpType.setDescription('This parameter indicates the IP address type of a WAN DNS server.')
cabhCdpWanDnsServerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 2, 3, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpWanDnsServerIp.setStatus('current')
if mibBuilder.loadTexts: cabhCdpWanDnsServerIp.setDescription('This parameter indicates the IP address of a WAN DNS server. The type of this address is specified by cabhCdpWanDnsServerIpType.')
cabhCdpLanPoolStartType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 1), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpLanPoolStartType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanPoolStartType.setDescription('The Address type of the start of range LAN Trans IP Addresses.')
cabhCdpLanPoolStart = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 2), InetAddress().clone(hexValue="c0a8000a")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpLanPoolStart.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanPoolStart.setDescription('The start of range LAN Trans IP Addresses. The type of this address is specified by cabhCdpLanPoolStartType.')
cabhCdpLanPoolEndType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 3), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpLanPoolEndType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanPoolEndType.setDescription('The Address type of the end of range LAN Trans IP Addresses.')
cabhCdpLanPoolEnd = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 4), InetAddress().clone(hexValue="c0a800fe")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpLanPoolEnd.setStatus('current')
if mibBuilder.loadTexts: cabhCdpLanPoolEnd.setDescription('The end of range for LAN-Trans IP Addresses. The type of this address is specified by cabhCdpLanPoolEndType.')
cabhCdpServerNetworkNumberType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 5), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerNetworkNumberType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerNetworkNumberType.setDescription('The IP address type of the LAN-Trans network number.')
cabhCdpServerNetworkNumber = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 6), InetAddress().clone(hexValue="c0a80000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerNetworkNumber.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerNetworkNumber.setDescription('The LAN-Trans network number. The type of this address is specified by cabhCdpServerNetworkNumberType.')
cabhCdpServerSubnetMaskType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 7), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerSubnetMaskType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerSubnetMaskType.setDescription('Type of LAN-Trans Subnet Mask.')
cabhCdpServerSubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 8), InetAddress().clone(hexValue="ffffff00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerSubnetMask.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerSubnetMask.setDescription('The PS MUST provide the value of this MIB object in the Option 1 (Subnet Mask) of DHCP OFFER and ACK messages sent to a LAN IP Device.')
cabhCdpServerTimeOffset = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-86400, 86400))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerTimeOffset.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerTimeOffset.setDescription('The PS MUST provide the value of this MIB object in the Option 2 (Time Offset from Coordinated Universal Time-UTC) in the DHCP OFFER and ACK messages sent to the LAN IP Device.')
cabhCdpServerRouterType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 10), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerRouterType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerRouterType.setDescription('Type of Address, Router for the LAN-Trans address realm.')
cabhCdpServerRouter = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 11), InetAddress().clone(hexValue="c0a80001")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerRouter.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerRouter.setDescription('The type of this address is specified by cabhCdpServerRouterType. The PS MUST provide the value of this MIB object in the Option 3 (Router IP address) of the DHCP OFFER and ACK messages sent to the LAN IP Device.')
cabhCdpServerDnsAddressType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 12), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerDnsAddressType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerDnsAddressType.setDescription('The Type of IP Addresses of the LAN-Trans address realm DNS servers.')
cabhCdpServerDnsAddress = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 13), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerDnsAddress.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerDnsAddress.setDescription('The default value of this MIB object is the same as the value of the cabhCdpServerRouter object. The NMS may set the value of this object to a value different than the value of cabhCdpServerRouter (e.g. DNS server in the cable data network) so that a LAN IP Device can direct its DNS queries to a server other than the PS DNS server. The type of this address is specified by cabhCdpServerDnsAddressType. The PS MUST provide the value of this MIB object in the Option 6 (Domain Name Server) of DHCP OFFER and ACK messages sent to a LAN IP Device.')
cabhCdpServerSyslogAddressType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 14), InetAddressType().clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerSyslogAddressType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerSyslogAddressType.setDescription('The Type of IP Address of the LAN-Trans SYSLOG servers.')
cabhCdpServerSyslogAddress = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 15), InetAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerSyslogAddress.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerSyslogAddress.setDescription('If the value of this object is nonzero the PS will include the value of this object in DHCP Option 7 (Log Servers) in DHCP OFFER and DHCP ACK messages sent to the LAN IP Device.')
cabhCdpServerDomainName = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerDomainName.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerDomainName.setDescription('The PS MUST provide the value of this MIB object in the Option 15 (Domain Name Option) of the DHCP OFFER and ACK messages sent to the LAN IP Device.')
cabhCdpServerTTL = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerTTL.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerTTL.setDescription('The PS MUST provide the value of this MIB object in the Option 23 (Default IP TTL) of DHCP OFFER and ACK messages sent to a LAN IP Device.')
cabhCdpServerInterfaceMTU = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(68, 4096), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerInterfaceMTU.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerInterfaceMTU.setDescription('The PS MUST provide the value of this MIB object in the Option 26 (Interface MTU Option) of the DHCP OFFER and ACK messages sent to the LAN IP Device. If the value of this object is 0, the PS must not include this option in its DHCP OFFER or DHCP ACK messages to LAN IP Devices.')
cabhCdpServerVendorSpecific = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 19), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerVendorSpecific.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerVendorSpecific.setDescription("The PS MUST provide the value of this MIB object in the Option 43 (Vendor Specific Information) of the DHCP OFFER and ACK messages sent to the LAN IP Device. If the value of this object is ' 'h then the PS MUST NOT include this option in its DHCP OFFER or DHCP ACK messages to LAN IP Devices.")
cabhCdpServerLeaseTime = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 20), Unsigned32().clone(3600)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerLeaseTime.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerLeaseTime.setDescription('The PS MUST provide the value of this MIB object in the Option 51 (IP Address lease time) of the DHCP OFFER and ACK messages sent to the LAN IP Device.')
cabhCdpServerDhcpAddressType = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 21), InetAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpServerDhcpAddressType.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerDhcpAddressType.setDescription('Type of LAN DHCP server IP address. The IP address of LAN DHCP server is provided by the PS in option 54 of DHCP OFFER or ACK.')
cabhCdpServerDhcpAddress = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 22), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpServerDhcpAddress.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerDhcpAddress.setDescription('The value of this MIB object is always the same as the value of the cabhCdpServerRouter object. The type of this address is specified by cabhCdpServerDhcpAddressType. The PS MUST provide the value of this MIB object in the Option 54 (DHCP server identifier) field of DHCP OFFER and ACK messages sent to a LAN IP device.')
cabhCdpServerControl = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("restoreConfig", 1), ("commitConfig", 2))).clone('restoreConfig')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerControl.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerControl.setDescription('The control for the CDS (DHCP Server) configuration. All changes to the cabhCdpServer mib objects are reflected when reading the value of the mib objects; however, those changes are NOT applied to the running configuration of the CDS until they are successfully committed via use of the cabhCdpServerControl object. If changes are made to the cabhCdpServer mib objects which are not yet successfully committed to the CDS, the cabhCdpServerControl object can be used to rollback all changes to the last valid CDS configuration and discard all intermediate changes. restoreConfig - Setting cabhCdpServerControl to this value will cause any changes to the cabhCdpServer objects not yet committed be reset to the values from the current running configuration of the CDS. commitConfig - Setting cabhCdpServerControl to this value will cause the CDS to validate and apply the valid cabhCdpServer mib settings to its running configuration. The cabhCdpServerCommitStatus object will detail the status of this operation.')
cabhCdpServerCommitStatus = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("commitSucceeded", 1), ("commitNeeded", 2), ("commitFailed", 3))).clone('commitSucceeded')).setMaxAccess("readonly")
if mibBuilder.loadTexts: cabhCdpServerCommitStatus.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerCommitStatus.setDescription('Indicates the status of committing the current cabhCdpServer mib object values to the running configuration of the CDS (DHCP Server). commitSucceeded - indicates the current cabhCdpServer mib object values are valid and have been successfully committed to the running configuration of the CDS. commitNeeded - indicates that the value of one or more objects in cabhCdpServer mib group have been changed but not yet committed to the running configuration of the CDS. commitFailed - indicates the PS was unable to commit the cabhCdpServer mib object values to the running configuration of the CDS due to conflicts in those values.')
cabhCdpServerUseCableDataNwDnsAddr = MibScalar((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 1, 3, 25), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cabhCdpServerUseCableDataNwDnsAddr.setStatus('current')
if mibBuilder.loadTexts: cabhCdpServerUseCableDataNwDnsAddr.setDescription('If the value of this object is false(2), the PS will provide the DNS Server IP address as specified in cabhCdpServerDnsAddress MIB object in the Option 6 (Domain Name Server), of the DHCP OFFER and ACK messages sent to a LAN IP Device. When the object cabhCdpServerUseCableDataNwDnsAddr is set to true(1), the PS must take the following actions: The PS will provide in Option 6 (Domain Name Server), of the DHCP OFFER and ACK messages sent to a LAN IP Device, the DNS server address(es) which is/are being used by the PS itself, i.e., the DNS server address(es) provided to the PS in DHCP Option 6 and made available through PS MIB object cabhCdpWanDnsServerIp. The LAN IP Device can then direct its DNS queries to a server other than the PS DNS server. The PS MUST provide the value of this.')
cabhCdpNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 2))
cabhCdpNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 2, 0))
cabhCdpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 3))
cabhCdpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 3, 1))
cabhCdpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 3, 2))
cabhCdpBasicCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 3, 1, 3)).setObjects(("CABH-CDP-MIB", "cabhCdpGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cabhCdpBasicCompliance = cabhCdpBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: cabhCdpBasicCompliance.setDescription('The compliance statement for devices that implement the CableHome Portal Services functionality.')
cabhCdpGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4491, 2, 4, 4, 3, 2, 1)).setObjects(("CABH-CDP-MIB", "cabhCdpSetToFactory"), ("CABH-CDP-MIB", "cabhCdpLanTransCurCount"), ("CABH-CDP-MIB", "cabhCdpLanTransThreshold"), ("CABH-CDP-MIB", "cabhCdpLanTransAction"), ("CABH-CDP-MIB", "cabhCdpWanDataIpAddrCount"), ("CABH-CDP-MIB", "cabhCdpLastSetToFactory"), ("CABH-CDP-MIB", "cabhCdpTimeOffsetSelection"), ("CABH-CDP-MIB", "cabhCdpSnmpSetTimeOffset"), ("CABH-CDP-MIB", "cabhCdpDaylightSavingTimeEnable"), ("CABH-CDP-MIB", "cabhCdpLanAddrClientID"), ("CABH-CDP-MIB", "cabhCdpLanAddrLeaseCreateTime"), ("CABH-CDP-MIB", "cabhCdpLanAddrLeaseExpireTime"), ("CABH-CDP-MIB", "cabhCdpLanAddrMethod"), ("CABH-CDP-MIB", "cabhCdpLanAddrHostName"), ("CABH-CDP-MIB", "cabhCdpLanAddrRowStatus"), ("CABH-CDP-MIB", "cabhCdpWanDataAddrClientId"), ("CABH-CDP-MIB", "cabhCdpWanDataAddrIpType"), ("CABH-CDP-MIB", "cabhCdpWanDataAddrIp"), ("CABH-CDP-MIB", "cabhCdpWanDataAddrRowStatus"), ("CABH-CDP-MIB", "cabhCdpWanDataAddrLeaseCreateTime"), ("CABH-CDP-MIB", "cabhCdpWanDataAddrLeaseExpireTime"), ("CABH-CDP-MIB", "cabhCdpWanDnsServerIpType"), ("CABH-CDP-MIB", "cabhCdpWanDnsServerIp"), ("CABH-CDP-MIB", "cabhCdpLanPoolStartType"), ("CABH-CDP-MIB", "cabhCdpLanPoolStart"), ("CABH-CDP-MIB", "cabhCdpLanPoolEndType"), ("CABH-CDP-MIB", "cabhCdpLanPoolEnd"), ("CABH-CDP-MIB", "cabhCdpServerNetworkNumberType"), ("CABH-CDP-MIB", "cabhCdpServerNetworkNumber"), ("CABH-CDP-MIB", "cabhCdpServerSubnetMaskType"), ("CABH-CDP-MIB", "cabhCdpServerSubnetMask"), ("CABH-CDP-MIB", "cabhCdpServerTimeOffset"), ("CABH-CDP-MIB", "cabhCdpServerRouterType"), ("CABH-CDP-MIB", "cabhCdpServerRouter"), ("CABH-CDP-MIB", "cabhCdpServerDnsAddressType"), ("CABH-CDP-MIB", "cabhCdpServerDnsAddress"), ("CABH-CDP-MIB", "cabhCdpServerSyslogAddressType"), ("CABH-CDP-MIB", "cabhCdpServerSyslogAddress"), ("CABH-CDP-MIB", "cabhCdpServerDomainName"), ("CABH-CDP-MIB", "cabhCdpServerTTL"), ("CABH-CDP-MIB", "cabhCdpServerInterfaceMTU"), ("CABH-CDP-MIB", "cabhCdpServerVendorSpecific"), ("CABH-CDP-MIB", "cabhCdpServerLeaseTime"), ("CABH-CDP-MIB", "cabhCdpServerDhcpAddressType"), ("CABH-CDP-MIB", "cabhCdpServerDhcpAddress"), ("CABH-CDP-MIB", "cabhCdpServerControl"), ("CABH-CDP-MIB", "cabhCdpServerCommitStatus"), ("CABH-CDP-MIB", "cabhCdpServerUseCableDataNwDnsAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cabhCdpGroup = cabhCdpGroup.setStatus('current')
if mibBuilder.loadTexts: cabhCdpGroup.setDescription('Group of objects for CableHome CDP MIB.')
mibBuilder.exportSymbols("CABH-CDP-MIB", cabhCdpWanDataAddrRenewalTime=cabhCdpWanDataAddrRenewalTime, cabhCdpWanDataAddrTable=cabhCdpWanDataAddrTable, cabhCdpDaylightSavingTimeEnable=cabhCdpDaylightSavingTimeEnable, cabhCdpWanDataAddrIp=cabhCdpWanDataAddrIp, cabhCdpServerSubnetMaskType=cabhCdpServerSubnetMaskType, cabhCdpLanTransThreshold=cabhCdpLanTransThreshold, cabhCdpCompliances=cabhCdpCompliances, cabhCdpTimeOffsetSelection=cabhCdpTimeOffsetSelection, cabhCdpLanAddrIp=cabhCdpLanAddrIp, cabhCdpLanPoolEndType=cabhCdpLanPoolEndType, cabhCdpWanDnsServerTable=cabhCdpWanDnsServerTable, cabhCdpServer=cabhCdpServer, cabhCdpWanDataIpAddrCount=cabhCdpWanDataIpAddrCount, cabhCdpWanDnsServerIpType=cabhCdpWanDnsServerIpType, cabhCdpServerControl=cabhCdpServerControl, cabhCdpWanDataAddrLeaseCreateTime=cabhCdpWanDataAddrLeaseCreateTime, cabhCdpGroups=cabhCdpGroups, cabhCdpLanAddrIpType=cabhCdpLanAddrIpType, cabhCdpServerNetworkNumberType=cabhCdpServerNetworkNumberType, cabhCdpServerDhcpAddress=cabhCdpServerDhcpAddress, cabhCdpServerDnsAddressType=cabhCdpServerDnsAddressType, cabhCdpLanAddrLeaseExpireTime=cabhCdpLanAddrLeaseExpireTime, cabhCdpLanAddrHostName=cabhCdpLanAddrHostName, cabhCdpLastSetToFactory=cabhCdpLastSetToFactory, cabhCdpServerRouterType=cabhCdpServerRouterType, cabhCdpWanDataAddrIpType=cabhCdpWanDataAddrIpType, cabhCdpServerSyslogAddressType=cabhCdpServerSyslogAddressType, cabhCdpSetToFactory=cabhCdpSetToFactory, cabhCdpServerTTL=cabhCdpServerTTL, cabhCdpNotification=cabhCdpNotification, cabhCdpLanTransCurCount=cabhCdpLanTransCurCount, cabhCdpLanAddrEntry=cabhCdpLanAddrEntry, cabhCdpLanPoolStart=cabhCdpLanPoolStart, cabhCdpServerVendorSpecific=cabhCdpServerVendorSpecific, cabhCdpServerLeaseTime=cabhCdpServerLeaseTime, cabhCdpWanDnsServerOrder=cabhCdpWanDnsServerOrder, cabhCdpWanDnsServerEntry=cabhCdpWanDnsServerEntry, cabhCdpLanPoolEnd=cabhCdpLanPoolEnd, cabhCdpServerNetworkNumber=cabhCdpServerNetworkNumber, cabhCdpBasicCompliance=cabhCdpBasicCompliance, cabhCdpServerDhcpAddressType=cabhCdpServerDhcpAddressType, cabhCdpWanDataAddrEntry=cabhCdpWanDataAddrEntry, cabhCdpLanAddrRowStatus=cabhCdpLanAddrRowStatus, cabhCdpServerUseCableDataNwDnsAddr=cabhCdpServerUseCableDataNwDnsAddr, cabhCdpLanAddrMethod=cabhCdpLanAddrMethod, cabhCdpNotifications=cabhCdpNotifications, cabhCdpWanDataAddrRowStatus=cabhCdpWanDataAddrRowStatus, cabhCdpWanDataAddrClientId=cabhCdpWanDataAddrClientId, cabhCdpObjects=cabhCdpObjects, cabhCdpServerTimeOffset=cabhCdpServerTimeOffset, cabhCdpLanAddrClientID=cabhCdpLanAddrClientID, cabhCdpSnmpSetTimeOffset=cabhCdpSnmpSetTimeOffset, cabhCdpBase=cabhCdpBase, cabhCdpAddr=cabhCdpAddr, cabhCdpServerDnsAddress=cabhCdpServerDnsAddress, PYSNMP_MODULE_ID=cabhCdpMib, cabhCdpWanDataAddrLeaseExpireTime=cabhCdpWanDataAddrLeaseExpireTime, cabhCdpWanDnsServerIp=cabhCdpWanDnsServerIp, cabhCdpLanAddrLeaseCreateTime=cabhCdpLanAddrLeaseCreateTime, cabhCdpServerSubnetMask=cabhCdpServerSubnetMask, cabhCdpLanAddrTable=cabhCdpLanAddrTable, cabhCdpServerCommitStatus=cabhCdpServerCommitStatus, cabhCdpConformance=cabhCdpConformance, cabhCdpServerDomainName=cabhCdpServerDomainName, cabhCdpGroup=cabhCdpGroup, cabhCdpServerRouter=cabhCdpServerRouter, cabhCdpWanDataAddrIndex=cabhCdpWanDataAddrIndex, cabhCdpLanPoolStartType=cabhCdpLanPoolStartType, cabhCdpLanTransAction=cabhCdpLanTransAction, cabhCdpServerInterfaceMTU=cabhCdpServerInterfaceMTU, cabhCdpServerSyslogAddress=cabhCdpServerSyslogAddress, cabhCdpMib=cabhCdpMib)

#
# PySNMP MIB module DGS-1100-10ME_A1 (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DGS-1100-10ME_A1
# Produced by pysmi-0.3.4 at Wed May  1 12:42:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
dot1dBridge, dot1dBasePort, dot1dBasePortEntry = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBridge", "dot1dBasePort", "dot1dBasePortEntry")
AddressFamilyNumbers, = mibBuilder.importSymbols("IANA-ADDRESS-FAMILY-NUMBERS-MIB", "AddressFamilyNumbers")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
VlanId, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId")
SnmpEngineID, SnmpAdminString, SnmpSecurityLevel = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpEngineID", "SnmpAdminString", "SnmpSecurityLevel")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, iso, Counter64, ObjectIdentity, NotificationType, IpAddress, Counter32, Unsigned32, Bits, Gauge32, enterprises, ModuleIdentity, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "iso", "Counter64", "ObjectIdentity", "NotificationType", "IpAddress", "Counter32", "Unsigned32", "Bits", "Gauge32", "enterprises", "ModuleIdentity", "TimeTicks")
MacAddress, TextualConvention, TruthValue, RowStatus, TimeStamp, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TextualConvention", "TruthValue", "RowStatus", "TimeStamp", "DisplayString")
d_link = MibIdentifier((1, 3, 6, 1, 4, 1, 171)).setLabel("d-link")
dlink_products = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10)).setLabel("dlink-products")
dlink_DGS1100SeriesProd = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134)).setLabel("dlink-DGS1100SeriesProd")
dgs_1100_10ME = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2)).setLabel("dgs-1100-10ME")
dgs_1100_10ME_A1 = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1)).setLabel("dgs-1100-10ME_A1")
class VlanIndex(TextualConvention, Unsigned32):
    description = 'A value used to index per-VLAN tables: values of 0 and 4095 are not permitted; if the value is between 1 and 4094 inclusive, it represents an IEEE 802.1Q VLAN-ID with global scope within a given bridged domain (see VlanId textual convention). If the value is greater than 4095 then it represents a VLAN with scope local to the particular agent, i.e. one without a global VLAN-ID assigned to it. Such VLANs are outside the scope of IEEE 802.1Q but it is convenient to be able to manage them in the same way using this MIB.'
    status = 'current'

class PortList(TextualConvention, OctetString):
    description = "Each octet within this value specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the bridge is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'."
    status = 'current'

class BridgeId(TextualConvention, OctetString):
    description = "The Bridge-Identifier as used in the Spanning Tree Protocol to uniquely identify a bridge. Its first two octets (in network byte order) contain a priority value and its last 6 octets contain the MAC address used to refer to a bridge in a unique fashion (typically, the numerically smallest MAC address of all ports on the bridge). Several objects in this MIB module represent values of timers used by the Spanning Tree Protocol. In this MIB, these timers have values in units of hundreths of a second (i.e. 1/100 secs). These timers, when stored in a Spanning Tree Protocol's BPDU, are in units of 1/256 seconds. Note, however, that 802.1D-1990 specifies a settable granularity of no more than 1 second for these timers. To avoid ambiguity, a data type is defined here as a textual convention and all representation of these timers in this MIB module are defined using this data type. An algorithm is also defined for converting between the different units, to ensure a timer's value is not distorted by multiple conversions."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

class Timeout(TextualConvention, Integer32):
    description = 'A STP timer in units of 1/100 seconds To convert a Timeout value into a value in units of 1/256 seconds, the following algorithm should be used: b = floor( (n * 256) / 100) where: floor = quotient [ignore remainder] n is the value in 1/100 second units b is the value in 1/256 second units To convert the value from 1/256 second units back to 1/100 seconds, the following algorithm should be used: n = ceiling( (b * 100) / 256) where: ceiling = quotient [if remainder is 0], or quotient + 1 [if remainder is non-zero] n is the value in 1/100 second units b is the value in 1/256 second units Note: it is important that the arithmetic operations are done in the order specified (i.e., multiply first, divide second).'
    status = 'current'
    displayHint = 'd4'

class OwnerString(DisplayString):
    description = "This data type is used to model an administratively assigned name of the owner of a resource. Implementations must accept values composed of well-formed NVT ASCII sequences. In addition, implementations should accept values composed of well-formed UTF-8 sequences. It is suggested that this name contain one or more of the following: IP address, management station name, network manager's name, location, or phone number. In some cases the agent itself will be the owner of an entry. In these cases, this string shall be set to a string starting with 'monitor'. SNMP access control is articulated entirely in terms of the contents of MIB views; access to a particular SNMP object instance depends only upon its presence or absence in a particular MIB view and never upon its value or the value of related object instances. Thus, objects of this type afford resolution of resource contention only among cooperating managers; they realize no access control function with respect to uncooperative parties."
    status = 'current'
    subtypeSpec = DisplayString.subtypeSpec + ValueSizeConstraint(0, 32)

class RmonStatus(TextualConvention, Integer32):
    description = 'The status of a table entry. Setting this object to the value invalid(4) has the effect of invalidating the corresponding entry. That is, it effectively disassociates the mapping identified with said entry. It is an implementation-specific matter as to whether the agent removes an invalidated entry from the table. Accordingly, management stations must be prepared to receive tabular information from agents that corresponds to entries currently not in use. Proper interpretation of such entries requires examination of the relevant RmonStatus object. An existing instance of this object cannot be set to createRequest(2). This object may only be set to createRequest(2) when this instance is created. When this object is created, the agent may wish to create supplemental object instances with default values to complete a conceptual row in this table. Because the creation of these default objects is entirely at the option of the agent, the manager must not assume that any will be created, but may make use of any that are created. Immediately after completing the create operation, the agent must set this object to underCreation(3). When in the underCreation(3) state, an entry is allowed to exist in a possibly incomplete, possibly inconsistent state, usually to allow it to be modified in multiple PDUs. When in this state, an entry is not fully active. Entries shall exist in the underCreation(3) state until the management station is finished configuring the entry and sets this object to valid(1) or aborts, setting this object to invalid(4). If the agent determines that an entry has been in the underCreation(3) state for an abnormally long time, it may decide that the management station has crashed. If the agent makes this decision, it may set this object to invalid(4) to reclaim the entry. A prudent agent will understand that the management station may need to wait for human input and will allow for that possibility in its determination of this abnormally long period. An entry in the valid(1) state is fully configured and consistent and fully represents the configuration or operation such a row is intended to represent. For example, it could be a statistical function that is configured and active, or a filter that is available in the list of filters processed by the packet capture process. A manager is restricted to changing the state of an entry in the following ways: To: valid createRequest underCreation invalid From: valid OK NO OK OK createRequest N/A N/A N/A N/A underCreation OK NO OK OK invalid NO NO NO OK nonExistent NO OK NO OK In the table above, it is not applicable to move the state from the createRequest state to any other state because the manager will never find the variable in that state. The nonExistent state is not a value of the enumeration, rather it means that the entryStatus variable does not exist at all. An agent may allow an entryStatus variable to change state in additional ways, so long as the semantics of the states are followed. This allowance is made to ease the implementation of the agent and is made despite the fact that managers should never exercise these additional state transitions.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("valid", 1), ("createRequest", 2), ("underCreation", 3), ("invalid", 4))

class OperationResponseStatus(TextualConvention, Integer32):
    description = 'Used to report the result of an operation: responseReceived(1) - Operation is completed successfully. unknown(2) - Operation failed due to unknown error. internalError(3) - An implementation detected an error in its own processing that caused an operation to fail. requestTimedOut(4) - Operation failed to receive a valid reply within the time limit imposed on it. unknownDestinationAddress(5) - Invalid destination address. noRouteToTarget(6) - Could not find a route to target. interfaceInactiveToTarget(7) - The interface to be used in sending a probe is inactive, and an alternate route does not exist. arpFailure(8) - Unable to resolve a target address to a media-specific address. maxConcurrentLimitReached(9) - The maximum number of concurrent active operations would have been exceeded if the corresponding operation was allowed. unableToResolveDnsName(10) - The DNS name specified was unable to be mapped to an IP address. invalidHostAddress(11) - The IP address for a host has been determined to be invalid. Examples of this are broadcast or multicast addresses.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))
    namedValues = NamedValues(("responseReceived", 1), ("unknown", 2), ("internalError", 3), ("requestTimedOut", 4), ("unknownDestinationAddress", 5), ("noRouteToTarget", 6), ("interfaceInactiveToTarget", 7), ("arpFailure", 8), ("maxConcurrentLimitReached", 9), ("unableToResolveDnsName", 10), ("invalidHostAddress", 11))

class LldpChassisIdSubtype(TextualConvention, Integer32):
    description = "This TC describes the source of a chassis identifier. The enumeration 'chassisComponent(1)' represents a chassis identifier based on the value of entPhysicalAlias object (defined in IETF RFC 2737) for a chassis component (i.e., an entPhysicalClass value of 'chassis(3)'). The enumeration 'interfaceAlias(2)' represents a chassis identifier based on the value of ifAlias object (defined in IETF RFC 2863) for an interface on the containing chassis. The enumeration 'portComponent(3)' represents a chassis identifier based on the value of entPhysicalAlias object (defined in IETF RFC 2737) for a port or backplane component (i.e., entPhysicalClass value of 'port(10)' or 'backplane(4)'), within the containing chassis. The enumeration 'macAddress(4)' represents a chassis identifier based on the value of a unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order), of a port on the containing chassis as defined in IEEE Std 802-2001. The enumeration 'networkAddress(5)' represents a chassis identifier based on a network address, associated with a particular chassis. The encoded address is actually composed of two fields. The first field is a single octet, representing the IANA AddressFamilyNumbers value for the specific address type, and the second field is the network address value. The enumeration 'interfaceName(6)' represents a chassis identifier based on the value of ifName object (defined in IETF RFC 2863) for an interface on the containing chassis. The enumeration 'local(7)' represents a chassis identifier based on a locally defined value."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("chassisComponent", 1), ("interfaceAlias", 2), ("portComponent", 3), ("macAddress", 4), ("networkAddress", 5), ("interfaceName", 6), ("local", 7))

class LldpChassisId(TextualConvention, OctetString):
    description = "This TC describes the format of a chassis identifier string. Objects of this type are always used with an associated LldpChassisIdSubtype object, which identifies the format of the particular LldpChassisId object instance. If the associated LldpChassisIdSubtype object has a value of 'chassisComponent(1)', then the octet string identifies a particular instance of the entPhysicalAlias object (defined in IETF RFC 2737) for a chassis component (i.e., an entPhysicalClass value of 'chassis(3)'). If the associated LldpChassisIdSubtype object has a value of 'interfaceAlias(2)', then the octet string identifies a particular instance of the ifAlias object (defined in IETF RFC 2863) for an interface on the containing chassis. If the particular ifAlias object does not contain any values, another chassis identifier type should be used. If the associated LldpChassisIdSubtype object has a value of 'portComponent(3)', then the octet string identifies a particular instance of the entPhysicalAlias object (defined in IETF RFC 2737) for a port or backplane component within the containing chassis. If the associated LldpChassisIdSubtype object has a value of 'macAddress(4)', then this string identifies a particular unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order), of a port on the containing chassis as defined in IEEE Std 802-2001. If the associated LldpChassisIdSubtype object has a value of 'networkAddress(5)', then this string identifies a particular network address, encoded in network byte order, associated with one or more ports on the containing chassis. The first octet contains the IANA Address Family Numbers enumeration value for the specific address type, and octets 2 through N contain the network address value in network byte order. If the associated LldpChassisIdSubtype object has a value of 'interfaceName(6)', then the octet string identifies a particular instance of the ifName object (defined in IETF RFC 2863) for an interface on the containing chassis. If the particular ifName object does not contain any values, another chassis identifier type should be used. If the associated LldpChassisIdSubtype object has a value of 'local(7)', then this string identifies a locally assigned Chassis ID."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class LldpPortIdSubtype(TextualConvention, Integer32):
    description = "This TC describes the source of a particular type of port identifier used in the LLDP MIB. The enumeration 'interfaceAlias(1)' represents a port identifier based on the ifAlias MIB object, defined in IETF RFC 2863. The enumeration 'portComponent(2)' represents a port identifier based on the value of entPhysicalAlias (defined in IETF RFC 2737) for a port component (i.e., entPhysicalClass value of 'port(10)'), within the containing chassis. The enumeration 'macAddress(3)' represents a port identifier based on a unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order), which has been detected by the agent and associated with a particular port (IEEE Std 802-2001). The enumeration 'networkAddress(4)' represents a port identifier based on a network address, detected by the agent and associated with a particular port. The enumeration 'interfaceName(5)' represents a port identifier based on the ifName MIB object, defined in IETF RFC 2863. The enumeration 'agentCircuitId(6)' represents a port identifier based on the agent-local identifier of the circuit (defined in RFC 3046), detected by the agent and associated with a particular port. The enumeration 'local(7)' represents a port identifier based on a value locally assigned."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("interfaceAlias", 1), ("portComponent", 2), ("macAddress", 3), ("networkAddress", 4), ("interfaceName", 5), ("agentCircuitId", 6), ("local", 7))

class LldpPortId(TextualConvention, OctetString):
    description = "This TC describes the format of a port identifier string. Objects of this type are always used with an associated LldpPortIdSubtype object, which identifies the format of the particular LldpPortId object instance. If the associated LldpPortIdSubtype object has a value of 'interfaceAlias(1)', then the octet string identifies a particular instance of the ifAlias object (defined in IETF RFC 2863). If the particular ifAlias object does not contain any values, another port identifier type should be used. If the associated LldpPortIdSubtype object has a value of 'portComponent(2)', then the octet string identifies a particular instance of the entPhysicalAlias object (defined in IETF RFC 2737) for a port or backplane component. If the associated LldpPortIdSubtype object has a value of 'macAddress(3)', then this string identifies a particular unicast source address (encoded in network byte order and IEEE 802.3 canonical bit order) associated with the port (IEEE Std 802-2001). If the associated LldpPortIdSubtype object has a value of 'networkAddress(4)', then this string identifies a network address associated with the port. The first octet contains the IANA AddressFamilyNumbers enumeration value for the specific address type, and octets 2 through N contain the networkAddress address value in network byte order. If the associated LldpPortIdSubtype object has a value of 'interfaceName(5)', then the octet string identifies a particular instance of the ifName object (defined in IETF RFC 2863). If the particular ifName object does not contain any values, another port identifier type should be used. If the associated LldpPortIdSubtype object has a value of 'agentCircuitId(6)', then this string identifies a agent-local identifier of the circuit (defined in RFC 3046). If the associated LldpPortIdSubtype object has a value of 'local(7)', then this string identifies a locally assigned port ID."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 255)

class LldpManAddrIfSubtype(TextualConvention, Integer32):
    reference = 'IEEE 802.1AB-2005 9.5.9.5'
    description = "This TC describes the basis of a particular type of interface associated with the management address. The enumeration 'unknown(1)' represents the case where the interface is not known. The enumeration 'ifIndex(2)' represents interface identifier based on the ifIndex MIB object. The enumeration 'systemPortNumber(3)' represents interface identifier based on the system port numbering convention."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("unknown", 1), ("ifIndex", 2), ("systemPortNumber", 3))

class LldpManAddress(TextualConvention, OctetString):
    description = 'The value of a management address associated with the LLDP agent that may be used to reach higher layer entities to assist discovery by network management. It should be noted that appropriate security credentials, such as SNMP engineId, may be required to access the LLDP agent using a management address. These necessary credentials should be known by the network management and the objects associated with the credentials are not included in the LLDP agent.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 31)

class LldpSystemCapabilitiesMap(TextualConvention, Bits):
    description = "This TC describes the system capabilities. The bit 'other(0)' indicates that the system has capabilities other than those listed below. The bit 'repeater(1)' indicates that the system has repeater capability. The bit 'bridge(2)' indicates that the system has bridge capability. The bit 'wlanAccessPoint(3)' indicates that the system has WLAN access point capability. The bit 'router(4)' indicates that the system has router capability. The bit 'telephone(5)' indicates that the system has telephone capability. The bit 'docsisCableDevice(6)' indicates that the system has DOCSIS Cable Device capability (IETF RFC 2669 & 2670). The bit 'stationOnly(7)' indicates that the system has only station capability and nothing else."
    status = 'current'
    namedValues = NamedValues(("other", 0), ("repeater", 1), ("bridge", 2), ("wlanAccessPoint", 3), ("router", 4), ("telephone", 5), ("docsisCableDevice", 6), ("stationOnly", 7))

class LldpPortNumber(TextualConvention, Integer32):
    description = "Each port contained in the chassis (that is known to the LLDP agent) is uniquely identified by a port number. A port number has no mandatory relationship to an InterfaceIndex object (of the interfaces MIB, IETF RFC 2863). If the LLDP agent is a IEEE 802.1D, IEEE 802.1Q bridge, the LldpPortNumber will have the same value as the dot1dBasePort object (defined in IETF RFC 1493) associated corresponding bridge port. If the system hosting LLDP agent is not an IEEE 802.1D or an IEEE 802.1Q bridge, the LldpPortNumber will have the same value as the corresponding interface's InterfaceIndex object. Port numbers should be in the range of 1 and 4096 since a particular port is also represented by the corresponding port number bit in LldpPortList."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 4096)

class LldpPortList(TextualConvention, OctetString):
    reference = 'IETF RFC 2674 section 5'
    description = "Each octet within this value specifies a set of eight ports, with the first octet specifying ports 1 through 8, the second octet specifying ports 9 through 16, etc. Within each octet, the most significant bit represents the lowest numbered port, and the least significant bit represents the highest numbered port. Thus, each port of the system is represented by a single bit within the value of this object. If that bit has a value of '1' then that port is included in the set of ports; the port is not included if its bit has a value of '0'."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 512)

class TimeFilter(TextualConvention, TimeTicks):
    description = "To be used for the index to a table. Allows an application to download only those rows changed since a particular time. Note that this is not a history mechanism. Only current values of underlying objects are returned; saved instance values associated with particular values of sysUpTime are not. An entry is considered changed if the value of any object in the entry changes, if the row is created, or if any object in the entry is created or deleted. Note that deleted entries cannot be detected or downloaded. A time-filtered conceptual table is created by inserting a single object of SYNTAX TimeFilter as the first INDEX component in a copy of an existing basic conceptual table (i.e., any SEQUENCE without a TimeFilter INDEX component). Thus, for each conceptual entry 'I' in the basic table, there exists N conceptual entries in the time-filtered version, indexed N.I, where 'N' is equal to the value of sysUpTime. When an application retrieves conceptual instances from a time-filtered table, and an INDEX value is provided for the TimeFilter INDEX component 'N', the agent will only consider returning basic conceptual entries (e.g., 'fooColumn.N.I') if any column within the basic conceptual entry has changed since sysUpTime 'N'. If not, the basic conceptual entry will be ignored for the particular retrieval operation. When sysUpTime is equal to zero, this table shall be empty. One conceptual entry exists for each past value of sysUpTime, except that the whole table is purged should sysUpTime wrap. As an entry in a time-filtered table is updated (i.e., one of the columns in the basic conceptual table is changed), new conceptual entries are also created in the time-filtered version (which still shares the now updated object values with all other instances). The number of unique time-filtered instances that are created is determined by the value of sysUpTime at which the basic entry was last updated. One unique instance will exist for each value of sysUpTime at the last update time for the row. However, a new TimeFilter index instance is created for each new sysUpTime value. The TimeFilter index values not associated with entry updates are called duplicate time-filtered instances. After some deployment experience, it has been determined that a time-filtered table is more efficient if the agent stops a MIB walk operation by skipping over rows with a TimeFilter index value higher than the value in the received GetNext/GetBulk request. That is, instead of incrementing a TimeFilter index value, the agent will continue to the next object or table. As a consequence, GetNext or GetBulk operations will provide only one pass through a time-filtered table. It is suggested that an agent implement a time-filtered table in this manner to improve performance and avoid a MIB walk getting stuck in time-filtered tables. It is, however, still acceptable for an agent to implement a time-filtered table in the traditional manner (i.e., every conceptual time-filtered instance is returned in GetNext and GetBulk PDU responses), and management applications must be able to deal with such traditional implementations. See the appendix for further discussion of this textual convention. The following example is provided to demonstrate TimeFilter behavior: Consider the following basic conceptual table, basicFooTable. (Note that the basic version of a time-filtered table may not actually be defined.) basicFooTable: basicFooTable ... INDEX { fooIndex } BasicFooEntry { fooIndex Integer32, fooCounts Counter32 } For this example, the basicFooTable contains two static conceptual entries (fooIndex equals '1' and '2'), created at time zero. It also contains one dynamic conceptual entry (fooIndex equals '3'), which is created at time '3' and deleted at time '7'. The time-filtered version of the basicFooTable could be defined as follows: FooTable: fooTable ... INDEX { fooTimeMark, fooIndex } FooEntry { fooTimeMark TimeFilter, fooIndex Integer32, fooCounts Counter32 } Note that entries exist in the time-filtered conceptual table only if they actually exist in the underlying (basic) table. For this example, the fooTable will have three underlying basic entries (fooIndex == 1, 2, and 3), with the following activity (for sysUpTime equal 0 to 9): - fooEntry.N.1 is created at time '0' and most recently updated at time '6' to the value '5'. - fooEntry.N.2 is created at time '0' and most recently updated at time '8' to the value '9'. - fooEntry.N.3 is created at time '3', updated at time '5' to the value '17', and deleted at time '7'. The following tables show the values that would be returned for MIB walk operations with various TimeFilter values, done at different times. An application issues a retrieval request at time 'T', with a TimeFilter value, 'N' (typically set to a lower value, such as the value of sysUpTime at the last polling cycle). The following values would be returned in a MIB walk of fooCounts.N if T equals '0' and N equals '0': fooCounts.N.I Value ========================== fooCounts.0.1 0 fooCounts.0.2 0 Note that nothing is returned for fooCounts.0.3, since that entry does not exist at sysUpTime equals '0'. The following values would be returned in a full (traditional) MIB walk of fooCounts.N if T equals '3' and N equals '0': fooCounts.N.I Value ======================= fooCounts.0.1 0 fooCounts.0.2 0 fooCounts.0.3 0 fooCounts.1.3 0 fooCounts.2.3 0 fooCounts.3.3 0 Note that there are no instances for T equals 1 or 2 for the first two values of N, as these entries did not change since they were created at time '0'. Note that the current value for 'fooCounts.N.3' is returned here, even for values of N less than '3' (when the entry was created). The agent only considers the current existence of an entry in the TimeFilter algorithm, not the time when the entry was created. Note that the instances 'fooCounts.0.3', 'fooCounts.1.3', and 'fooCounts.2.3' are duplicates and can be suppressed by the agent in a MIB walk. The following values would be returned in a full (traditional) MIB walk of fooCounts.N if T equals '6' and N equals '3': fooCounts.N.I Value ======================= fooCounts.3.1 5 fooCounts.3.3 17 fooCounts.4.1 5 fooCounts.4.3 17 fooCounts.5.1 5 fooCounts.5.3 17 fooCounts.6.1 5 Note that no instances for entry 'fooCounts.N.2' are returned, since it has not changed since time '3'. Note that all instances except 'fooCounts.5.3' and 'fooCounts.6.1' are duplicates and can be suppressed by the agent in a MIB walk. The following values would be returned in a full (traditional) MIB walk of fooCounts.N if T equals '9' and N equals '6': fooCounts.N.I Value ======================= fooCounts.6.1 5 fooCounts.6.2 9 fooCounts.7.2 9 fooCounts.8.2 9 Note that no instances for entry 'fooCounts.N.3' are returned, since it was deleted at time '7'. Note that instances 'fooCounts.6.2' and 'fooCounts.7.2' are duplicates and can be suppressed by the agent in a MIB walk."
    status = 'current'

class LldpPowerPortClass(TextualConvention, Integer32):
    description = 'This TC describes the Power over Ethernet (PoE) port class.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("pClassPSE", 1), ("pClassPD", 2))

class LldpLinkAggStatusMap(TextualConvention, Bits):
    description = "This TC describes the link aggregation status. The bit 'aggCapable(0)' indicates the link is capable of being aggregated. The bit 'aggEnabled(1)' indicates the link is currently in aggregation."
    status = 'current'
    namedValues = NamedValues(("aggCapable", 0), ("aggEnabled", 1))

class ZeroBasedCounter32(TextualConvention, Gauge32):
    description = 'This TC describes an object that counts events with the following semantics: objects of this type will be set to zero(0) on creation and will thereafter count appropriate events, wrapping back to zero(0) when the value 2^32 is reached. Provided that an application discovers the new object within the minimum time to wrap, it can use the initial value as a delta since it last polled the table of which this object is part. It is important for a management station to be aware of this minimum time and the actual time between polls, and to discard data if the actual time is too long or there is no defined minimum time. Typically, this TC is used in tables where the INDEX space is constantly changing and/or the TimeFilter mechanism is in use.'
    status = 'current'

class Ipv6Address(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 addresses. This is a binary string of 16 octets in network byte-order.'
    status = 'current'
    displayHint = '2x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(16, 16)
    fixedLength = 16

companySystem = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1))
sysPort = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100))
companyIpifGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2))
companyTftpGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3))
companyUserAccount = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4))
companySNMP = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5))
companyDot1qVlanGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7))
companyStaticMac = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9))
companyIgsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10))
companyQoSGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12))
companyTrafficMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13))
companySecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14))
sysPortSecurity = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2))
sysTrafficSegmentation = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 9))
sysSecurityAAC = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11))
sysTrustedHost = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 13))
companyArp = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15))
companySyslog = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16))
companyLBD = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17))
companyMirror = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18))
companyStaticMcast = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 19))
companySNTPSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20))
companyRMON = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22))
companyPnacGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23))
sysPnacRadiusServer = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4))
companyGuestVLAN = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 24))
companyMacNotify = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25))
companyISMVLAN = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27))
companyDHCPRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28))
companyDHCPLocalRelay = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 29))
companyGreenSetting = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31))
companyLLDP = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32))
companyCableDiagnostic = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35))
companyQinQ = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37))
companyTimeRangeMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38))
companyLimitIP = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45))
companyMulticastFilter = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 49))
companyIPv6Neighbor = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50))
companyEoam = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51))
companyDuld = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52))
companyEee = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 60))
companyDHCPv6Relay = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86))
companyMldsGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88))
companyTraceRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90))
companyPPPoE = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98))
companyStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99))
companyPing = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100))
companyDDP = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 101))
companySession = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102))
companyACL = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103))
companyCPUACL = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104))
sysIpifSupportV4V6Info = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7))
ipv4AddrCfgMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("manual", 1), ("dynamic", 2))).clone('manual')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv4AddrCfgMode.setStatus('current')
if mibBuilder.loadTexts: ipv4AddrCfgMode.setDescription("Specifies the means by which the default interface in the device gets the IP address. If 'manual' mode is selected, the default interface takes the default IPv4 address configured in the system. If 'dynamic' mode is selected, the default interface gets the IP address through dynamic IP address configuration protocols such as RARP client, BootP client, DHCP Client, etc. If the system fails to get the IP address dynamically through all the above protocols, the default interface uses the default IPv4 address configured in the system.")
ipv4Address = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv4Address.setStatus('current')
if mibBuilder.loadTexts: ipv4Address.setDescription('Default IP Address of the system. This IP address, if modified, will take effect only when the configuration is stored & restored.')
ipv4SubnetMask = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv4SubnetMask.setStatus('current')
if mibBuilder.loadTexts: ipv4SubnetMask.setDescription('IP subnet mask for the default IP address. This subnet mask, if modified, will take effect only when the configuration is stored & restored.')
ipv4DefaultGateway = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv4DefaultGateway.setStatus('current')
if mibBuilder.loadTexts: ipv4DefaultGateway.setDescription('Gateway')
dhcpOption12Status = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpOption12Status.setStatus('current')
if mibBuilder.loadTexts: dhcpOption12Status.setDescription('Status of DHCP Option12')
dhcpOption12HostName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpOption12HostName.setStatus('current')
if mibBuilder.loadTexts: dhcpOption12HostName.setDescription('Host name in DHCP option 12')
ipv6GlobalStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6GlobalStatus.setStatus('current')
if mibBuilder.loadTexts: ipv6GlobalStatus.setDescription('The state of IPv6 function.')
ipv6DHCPStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6DHCPStatus.setStatus('current')
if mibBuilder.loadTexts: ipv6DHCPStatus.setDescription('The state of DHCPv6 that you want this interface to be in.')
ipv6AutolinkloStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6AutolinkloStatus.setStatus('current')
if mibBuilder.loadTexts: ipv6AutolinkloStatus.setDescription('This object is to set the status of ipv6 link local address auto-generated. if set enabled, system will auto-generate a link-local ipv6 address by switch base mac addree. if set disabled, link-local address will be configured by mannual.')
ipv6NSRetransmitTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6NSRetransmitTime.setStatus('current')
if mibBuilder.loadTexts: ipv6NSRetransmitTime.setDescription("The NS's retransmit time that you want this interface to be in")
ipv6DefaultRouteTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 13), )
if mibBuilder.loadTexts: ipv6DefaultRouteTable.setStatus('current')
if mibBuilder.loadTexts: ipv6DefaultRouteTable.setDescription('This table contains dynamic routes that are learnt through dynamic routing protocol as well as local routes derived from configured address prefixes and statically configured routes.')
ipv6DefaultRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 13, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "ipv6DefaultRouteProtocol"), (0, "DGS-1100-10ME_A1", "ipv6DefaultRouteNextHop"))
if mibBuilder.loadTexts: ipv6DefaultRouteEntry.setStatus('current')
if mibBuilder.loadTexts: ipv6DefaultRouteEntry.setDescription('An entry in the IPv6 Routing Table. An entry can be created by means of the routing protocol, derived from configured address prefixes as well as statically configured. There can be a static route as well as dynamic routes with the same destination and prefix length.')
ipv6DefaultRouteProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4))).clone(namedValues=NamedValues(("static", 3), ("dynamic", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6DefaultRouteProtocol.setStatus('current')
if mibBuilder.loadTexts: ipv6DefaultRouteProtocol.setDescription('The routing mechanism via which this route was learned. If it has value local(2), it indicates this route was derived from a configured address prefix.')
ipv6DefaultRouteNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 13, 1, 4), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6DefaultRouteNextHop.setStatus('current')
if mibBuilder.loadTexts: ipv6DefaultRouteNextHop.setDescription('Next hop IPv6 Address for this route. For direct routes it has the value ::0.')
ipv6DefaultRouteIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 13, 1, 5), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6DefaultRouteIfIndex.setStatus('current')
if mibBuilder.loadTexts: ipv6DefaultRouteIfIndex.setDescription('The index value which uniquely identifies the interface through which the next hop of this route should be reached. The interface identified by a particular value of this index is the same interface as identified by the same value of ipv6IfIndex.')
ipv6DefaultRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 13, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6DefaultRouteMetric.setStatus('current')
if mibBuilder.loadTexts: ipv6DefaultRouteMetric.setDescription('The routing metric associated with this route.')
ipv6DefaultRouteAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 13, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ipv6DefaultRouteAdminStatus.setStatus('current')
if mibBuilder.loadTexts: ipv6DefaultRouteAdminStatus.setDescription('Administrative Status of the route. This object is used to create or delete the route entry. The ipv6DefaultRouteIfIndex needs to be set, before the route entry is made active. CreateAndGo is not supported.')
ipv6AddressTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 14), )
if mibBuilder.loadTexts: ipv6AddressTable.setStatus('current')
if mibBuilder.loadTexts: ipv6AddressTable.setDescription('A list of interface entries.')
ipv6AddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 14, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "ipv6AddressMainIndex"), (0, "DGS-1100-10ME_A1", "ipv6AddressIpAddr"), (0, "DGS-1100-10ME_A1", "ipv6AddressIpPrefix"))
if mibBuilder.loadTexts: ipv6AddressEntry.setStatus('current')
if mibBuilder.loadTexts: ipv6AddressEntry.setDescription('An entry containing management information applicable to a particular interface.')
ipv6AddressMainIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 14, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6AddressMainIndex.setStatus('current')
if mibBuilder.loadTexts: ipv6AddressMainIndex.setDescription('The index of this IPv6 entry.')
ipv6AddressIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 14, 1, 2), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6AddressIpAddr.setStatus('current')
if mibBuilder.loadTexts: ipv6AddressIpAddr.setDescription('The ip address of this IPv6 entry.')
ipv6AddressIpPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 14, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6AddressIpPrefix.setStatus('current')
if mibBuilder.loadTexts: ipv6AddressIpPrefix.setDescription('The ip prefix of this IPv6 entry.')
ipv6AddressIpType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 14, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("unicast", 1), ("linklocal", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6AddressIpType.setStatus('current')
if mibBuilder.loadTexts: ipv6AddressIpType.setDescription('The ip type of this IPv6 entry.')
ipv6AddressRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 14, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6AddressRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipv6AddressRowStatus.setDescription('The status of an entry. Only a subset of the rowstatus variables (active, createAndWait, destroy) are available.')
dhcpRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 7, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRetryCount.setStatus('current')
if mibBuilder.loadTexts: dhcpRetryCount.setDescription('Retry count of dhcp.')
sysIpifTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 8))
ipifDuplicateIPDetected = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 2, 8, 1))
if mibBuilder.loadTexts: ipifDuplicateIPDetected.setStatus('current')
if mibBuilder.loadTexts: ipifDuplicateIPDetected.setDescription('This is a trap that will send to snmp manager,and it will be generated when device receive a gratuitous arp packet and ip address is the same as the one of device.')
sysIPv6neighborTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50, 1), )
if mibBuilder.loadTexts: sysIPv6neighborTable.setStatus('current')
if mibBuilder.loadTexts: sysIPv6neighborTable.setDescription('A list of the Neighbor Cache Table.')
ipv6NeighborEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "ipv6NeighborIndex"), (0, "DGS-1100-10ME_A1", "ipv6NeighborAddr"))
if mibBuilder.loadTexts: ipv6NeighborEntry.setStatus('current')
if mibBuilder.loadTexts: ipv6NeighborEntry.setDescription('A Neighbor cache entry containing the ifindex and ipv6 addr.')
ipv6NeighborIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6NeighborIndex.setStatus('current')
if mibBuilder.loadTexts: ipv6NeighborIndex.setDescription('The interface index of the Neighbor entry.')
ipv6NeighborAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50, 1, 1, 2), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6NeighborAddr.setStatus('current')
if mibBuilder.loadTexts: ipv6NeighborAddr.setDescription('Allows the entry of an IP address that will be a Neighbor entry into the Neighbor Cache Table.')
ipv6NeighborMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50, 1, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6NeighborMacAddr.setStatus('current')
if mibBuilder.loadTexts: ipv6NeighborMacAddr.setDescription('The MAC address associated of the Neighbor entry.')
ipv6NeighborCacheState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("static", 1), ("reachable", 2), ("incomplete", 3), ("stale", 4), ("delay", 5), ("probe", 6), ("notinservice", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipv6NeighborCacheState.setStatus('current')
if mibBuilder.loadTexts: ipv6NeighborCacheState.setDescription('The type associated of the Neighbor entry.')
ipv6NeighborRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 50, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ipv6NeighborRowStatus.setStatus('current')
if mibBuilder.loadTexts: ipv6NeighborRowStatus.setDescription('The status of an entry in the Neighbor Cache Table. Only a subset of the rowstatus variables (active, createAndWait, destroy) are available.')
sysDuld = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1))
duldTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1), )
if mibBuilder.loadTexts: duldTable.setStatus('current')
if mibBuilder.loadTexts: duldTable.setDescription('A table that contains DULD mode information about each port.')
duldEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "duldIfIndex"))
if mibBuilder.loadTexts: duldEntry.setStatus('current')
if mibBuilder.loadTexts: duldEntry.setDescription('A list of DULD mode information for each port.')
duldIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: duldIfIndex.setStatus('current')
if mibBuilder.loadTexts: duldIfIndex.setDescription('The index of the port. ')
duldState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: duldState.setStatus('current')
if mibBuilder.loadTexts: duldState.setDescription('Sets the DULD admin state enabled or disabled.')
duldOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: duldOperState.setStatus('current')
if mibBuilder.loadTexts: duldOperState.setDescription('Gets the DULD Oper state enabled or disabled.')
duldMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("shutdown", 1), ("normal", 2))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: duldMode.setStatus('current')
if mibBuilder.loadTexts: duldMode.setDescription('Sets the DULD mode as shutdown or normal.')
duldLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unknown", 1), ("bidirectional", 2), ("txFault", 3), ("rxFault", 4), ("linkDown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: duldLinkStatus.setStatus('current')
if mibBuilder.loadTexts: duldLinkStatus.setDescription('Gets the DULD link status.')
duldDiscoveryTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 52, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: duldDiscoveryTime.setStatus('current')
if mibBuilder.loadTexts: duldDiscoveryTime.setDescription('Sets the DULD discovery time.')
sysGreenLEDShutoff = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 1))
sysGreenPortShutoff = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 2))
sysGreenSystemHibernation = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 4))
greenLEDShutoffPortList = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 1, 1), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenLEDShutoffPortList.setStatus('current')
if mibBuilder.loadTexts: greenLEDShutoffPortList.setDescription('Provides control to LED port.')
greenLEDShutoffState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenLEDShutoffState.setStatus('current')
if mibBuilder.loadTexts: greenLEDShutoffState.setDescription('Enable/Disable Green LED function. Default is disabled.')
greenLEDShutoffTimeProfile1 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenLEDShutoffTimeProfile1.setStatus('current')
if mibBuilder.loadTexts: greenLEDShutoffTimeProfile1.setDescription("The time profile name associated with the Schedule entry (e.g., `abc, bbb').")
greenLEDShutoffTimeProfile2 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenLEDShutoffTimeProfile2.setStatus('current')
if mibBuilder.loadTexts: greenLEDShutoffTimeProfile2.setDescription("The time profile name associated with the Schedule entry (e.g., `abc, bbb').")
greenPortShutoffPortList = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 2, 1), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenPortShutoffPortList.setStatus('current')
if mibBuilder.loadTexts: greenPortShutoffPortList.setDescription('Provides control to LED port.')
greenPortShutoffState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenPortShutoffState.setStatus('current')
if mibBuilder.loadTexts: greenPortShutoffState.setDescription('Enable/Disable Green LED function. Default is disabled.')
greenPortShutoffTimeProfile1 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 2, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenPortShutoffTimeProfile1.setStatus('current')
if mibBuilder.loadTexts: greenPortShutoffTimeProfile1.setDescription("The time profile name associated with the Schedule entry (e.g., `abc, bbb').")
greenPortShutoffTimeProfile2 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenPortShutoffTimeProfile2.setStatus('current')
if mibBuilder.loadTexts: greenPortShutoffTimeProfile2.setDescription("The time profile name associated with the Schedule entry (e.g., `abc, bbb').")
greenSystemHibernationState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenSystemHibernationState.setStatus('current')
if mibBuilder.loadTexts: greenSystemHibernationState.setDescription('Enable/Disable Green LED function. Default is disabled.')
greenSystemHibernationTimeProfile1 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenSystemHibernationTimeProfile1.setStatus('current')
if mibBuilder.loadTexts: greenSystemHibernationTimeProfile1.setDescription("The time profile name associated with the Schedule entry (e.g., `abc, bbb').")
greenSystemHibernationTimeProfile2 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 4, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenSystemHibernationTimeProfile2.setStatus('current')
if mibBuilder.loadTexts: greenSystemHibernationTimeProfile2.setDescription("The time profile name associated with the Schedule entry (e.g., `abc, bbb').")
greenCableLenDetectionState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 31, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: greenCableLenDetectionState.setStatus('current')
if mibBuilder.loadTexts: greenCableLenDetectionState.setDescription('Enable/Disable Power Saving Cable Length Detection.')
sysDevInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 1))
sysSwitchName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSwitchName.setStatus('current')
if mibBuilder.loadTexts: sysSwitchName.setDescription('System name used for identification of the device. The following characters are allowed to input. 0 ~ 9 / a ~ z / A ~ Z Special character: ( ) V + _ = .')
sysHardwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15)).clone('Version of the hardware')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysHardwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysHardwareVersion.setDescription('Version number of the Hardware.')
sysFirmwareVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysFirmwareVersion.setStatus('current')
if mibBuilder.loadTexts: sysFirmwareVersion.setDescription('Version number of the Firmware.')
sysDeviceType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysDeviceType.setStatus('current')
if mibBuilder.loadTexts: sysDeviceType.setDescription("A textual description of the entity. This value should include the full name and version identification of the system's hardware type, software operating-system, and networking software.")
sysBootVerion = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysBootVerion.setStatus('current')
if mibBuilder.loadTexts: sysBootVerion.setDescription('Version number of the BootLoader.')
sysLoginTimeout = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLoginTimeout.setStatus('current')
if mibBuilder.loadTexts: sysLoginTimeout.setDescription('This time is used to count the time and logout web or telnet interface automatically.')
sysLocationName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLocationName.setStatus('current')
if mibBuilder.loadTexts: sysLocationName.setDescription("The location name of this node (e.g., `telephone closet, 3rd floor'). If the location is unknown, the value is the zero-length string.")
sysContact = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysContact.setStatus('current')
if mibBuilder.loadTexts: sysContact.setDescription('The textual identification of the contact person for this managed node, together with information on how to contact this person. If no contact information is known, the value is the zero-length string.')
sysSafeGuardEnable = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSafeGuardEnable.setStatus('current')
if mibBuilder.loadTexts: sysSafeGuardEnable.setDescription('This object is used to set Safeguard Enable\\Disable.')
sysRestart = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noreboot", 1), ("reboot", 2), ("reset", 3), ("resetwithoutip", 4), ("resetwithoutipvlan", 5))).clone('noreboot')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRestart.setStatus('current')
if mibBuilder.loadTexts: sysRestart.setDescription('This object allows the user to restart the Switch (i.e)the entire switch will operationally go down and start again. This objects also allows user to reset swith(all configuration set to default) and reset switch without ip(except ip configuration saved, configuration set to default) and reset switch without ip and vlan(except ip and vlan configuration saved, configuration set to default) When the switch operationally goes down, configuration save operation is initiated based on the configuration save option chosen. When the switch operationally come up, the saved configurations are restored based on the restore option chosen. Once the switch is restarted, the value of this object reverts to noreboot.')
sysSave = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSave.setStatus('current')
if mibBuilder.loadTexts: sysSave.setDescription('This object is used to save Configuration.')
sysJumboFrameEnable = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysJumboFrameEnable.setStatus('current')
if mibBuilder.loadTexts: sysJumboFrameEnable.setDescription('Gigabit Web Smart Switches support jumbo frames (frames larger than the Ethernet frame size of 1522 bytes) of up to 10,000 bytes (tagged). Default jumbo frame is disabled.')
sysDhcpAutoConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDhcpAutoConfiguration.setStatus('current')
if mibBuilder.loadTexts: sysDhcpAutoConfiguration.setDescription('This object indicates auto config is enabled or disabled.')
sysWebState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysWebState.setStatus('current')
if mibBuilder.loadTexts: sysWebState.setDescription('This object is for Enabled(1) or Disabled(2) Web state in the system.')
sysWebPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(80)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysWebPortNumber.setStatus('current')
if mibBuilder.loadTexts: sysWebPortNumber.setDescription('Web Server Port Number.')
sysARPAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysARPAgingTime.setStatus('current')
if mibBuilder.loadTexts: sysARPAgingTime.setDescription('This object is for ARP aging time.')
sysMACAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMACAgingTime.setStatus('current')
if mibBuilder.loadTexts: sysMACAgingTime.setDescription('This object is for MAC aging time.')
sysTelnetsettingManagementOnOff = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTelnetsettingManagementOnOff.setStatus('current')
if mibBuilder.loadTexts: sysTelnetsettingManagementOnOff.setDescription('Enable/Disable management Telnetsetting mechanism.')
sysTelnetUDPPort = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(23)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTelnetUDPPort.setStatus('current')
if mibBuilder.loadTexts: sysTelnetUDPPort.setDescription("The value is for setting telnet's UDP Port.")
sysAutoRefreshConfiguration = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("refreshimenever", 0), ("refreshtime10secs", 1), ("refreshtime30secs", 2), ("refreshtime1min", 3), ("refreshtime5mins", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysAutoRefreshConfiguration.setStatus('current')
if mibBuilder.loadTexts: sysAutoRefreshConfiguration.setDescription('To set the WEB panel auto refresh timer.')
sysMacAddr = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 26), MacAddress().clone(hexValue="000102030405")).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysMacAddr.setStatus('current')
if mibBuilder.loadTexts: sysMacAddr.setDescription('Ethernet address (base address) of the Switch. This base Mac Address, if modified, will take effect only when the Switch is restarted.')
sysSwitchTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 27), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSwitchTime.setStatus('current')
if mibBuilder.loadTexts: sysSwitchTime.setDescription(' The date is configured in the switch in the format, Hours:Minutes:Seconds Day Month Year e.g 19:10:31 11 08 2005 01-12 Month - beginning from January to December The railway time 00 to 24 hours can be configured and displayed. The Display of the date is in the format , WeekDay Month Day Hours:Minutes:Seconds Year e.g 04 09 21 18:11:30 2005 01-07 WeekDay - beginning from Sunday to Saturday 01-12 Month - beginning from January to December ')
sysDhcpTimeout = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDhcpTimeout.setStatus('current')
if mibBuilder.loadTexts: sysDhcpTimeout.setDescription('This is DHCP auto configuration timeout, the maxium time in seconds to wait before terminate.')
sysSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysSerialNumber.setStatus('current')
if mibBuilder.loadTexts: sysSerialNumber.setDescription('The serial number assigned to this nvram sub-unit')
sysCPU = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 30))
cpuLast5SecUsage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 30, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuLast5SecUsage.setStatus('current')
if mibBuilder.loadTexts: cpuLast5SecUsage.setDescription('Indicates the average CPU usage in last 5 second of the switch in percentage')
cpuLast1MinUsage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 30, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuLast1MinUsage.setStatus('current')
if mibBuilder.loadTexts: cpuLast1MinUsage.setDescription('Indicates the average CPU usage in last 1 minute of the switch in percentage')
cpuLast5MinUsage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 30, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuLast5MinUsage.setStatus('current')
if mibBuilder.loadTexts: cpuLast5MinUsage.setDescription('Indicates the average CPU usage in last 5 minute of the switch in percentage')
sysRAM = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 31))
ramLast5SecUsage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 31, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ramLast5SecUsage.setStatus('current')
if mibBuilder.loadTexts: ramLast5SecUsage.setDescription('Indicates the average RAM usage in last 5 second of the switch in percentage')
ramLast1MinUsage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 31, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ramLast1MinUsage.setStatus('current')
if mibBuilder.loadTexts: ramLast1MinUsage.setDescription('Indicates the average RAM usage in last 1 minute of the switch in percentage')
ramLast5MinUsage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 31, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ramLast5MinUsage.setStatus('current')
if mibBuilder.loadTexts: ramLast5MinUsage.setDescription('Indicates the average RAM usage in last 5 minute of the switch in percentage')
sysCliPromptStr = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCliPromptStr.setStatus('current')
if mibBuilder.loadTexts: sysCliPromptStr.setDescription('Cli Prompt string, some special value definition as below: 1. default - represent using the default value; 2. username - using the current login username;')
sysSshState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSshState.setStatus('current')
if mibBuilder.loadTexts: sysSshState.setDescription('Enable/Disable management SSH .')
sysSshPortNumber = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(22)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSshPortNumber.setStatus('current')
if mibBuilder.loadTexts: sysSshPortNumber.setDescription("The value is for setting SSH's tcp Port.")
portCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1), )
if mibBuilder.loadTexts: portCtrlTable.setStatus('current')
if mibBuilder.loadTexts: portCtrlTable.setDescription('A table to control the port specific parameters of the device like speed, duplex mode, etc.')
portCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "portCtrlIndex"), (0, "DGS-1100-10ME_A1", "portCtrlMediumType"))
if mibBuilder.loadTexts: portCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: portCtrlEntry.setDescription('An entry appears in this table for each interface in the system. Index to the table is the interface index of the port.')
portCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: portCtrlIndex.setDescription('Interface index of the port for the configuration in this entry applies.')
portCtrlMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("copper", 1), ("fiber", 2))).clone('copper')).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCtrlMediumType.setStatus('current')
if mibBuilder.loadTexts: portCtrlMediumType.setDescription('This object indicates the port type: fiber 1G/100M or copper.')
portCtrlSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("full1000m", 1), ("full100m", 2), ("half100m", 3), ("full10m", 4), ("half10m", 5), ("auto", 6), ("disabled", 7))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCtrlSpeed.setStatus('current')
if mibBuilder.loadTexts: portCtrlSpeed.setDescription('Configures port speed which the mediatype is match with portCtrlDetailMediumType.')
portCtrlLinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("down", 1), ("full1000m", 2), ("full100m", 3), ("half100m", 4), ("full10m", 5), ("half10m", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCtrlLinkStatus.setStatus('current')
if mibBuilder.loadTexts: portCtrlLinkStatus.setDescription("The port's operating speed state.")
portCtrlMDI = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("mdi", 2), ("mdix", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCtrlMDI.setStatus('current')
if mibBuilder.loadTexts: portCtrlMDI.setDescription('Configures interface auto/mdi/mdix mode. The default setting is Auto.')
portCtrlFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCtrlFlowControl.setStatus('current')
if mibBuilder.loadTexts: portCtrlFlowControl.setDescription('Enables / disables flow control for the interface.')
portCtrlFlowControlOper = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCtrlFlowControlOper.setStatus('current')
if mibBuilder.loadTexts: portCtrlFlowControlOper.setDescription(' Show Enables / disables status of flow control for the interface.')
portCtrlAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCtrlAdminState.setStatus('current')
if mibBuilder.loadTexts: portCtrlAdminState.setDescription(' Enables / disables Admin for the interface.')
portCtrlDetailMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("fastethernet", 1), ("gigabitethernet", 2), ("fiberwith100BaseSFPModule", 3), ("fiberwith1GBaseSFPModule", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCtrlDetailMediumType.setStatus('current')
if mibBuilder.loadTexts: portCtrlDetailMediumType.setDescription("Get the port's current media type")
portCtrlDynamicMacAutoLearn = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCtrlDynamicMacAutoLearn.setStatus('current')
if mibBuilder.loadTexts: portCtrlDynamicMacAutoLearn.setDescription(' Enables / disables dynamic mac auto learning for the interface.')
portDescriptionTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 2), )
if mibBuilder.loadTexts: portDescriptionTable.setStatus('current')
if mibBuilder.loadTexts: portDescriptionTable.setDescription('The port description table.')
portDescriptionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "portDescIndex"), (0, "DGS-1100-10ME_A1", "portDescMediumType"))
if mibBuilder.loadTexts: portDescriptionEntry.setStatus('current')
if mibBuilder.loadTexts: portDescriptionEntry.setDescription('The port description entry.')
portDescIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDescIndex.setStatus('current')
if mibBuilder.loadTexts: portDescIndex.setDescription('This object indicates the port index.')
portDescMediumType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("copper", 1), ("fiber", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portDescMediumType.setStatus('current')
if mibBuilder.loadTexts: portDescMediumType.setDescription('This object indicates the port type: fiber or copper.')
portDescString = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portDescString.setStatus('current')
if mibBuilder.loadTexts: portDescString.setDescription('This object indicates the port description.')
portErrTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 3), )
if mibBuilder.loadTexts: portErrTable.setStatus('current')
if mibBuilder.loadTexts: portErrTable.setDescription('The port error table.')
portErrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "portErrPortIndex"))
if mibBuilder.loadTexts: portErrEntry.setStatus('current')
if mibBuilder.loadTexts: portErrEntry.setDescription('A list of information for the err port of the device.')
portErrPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portErrPortIndex.setStatus('current')
if mibBuilder.loadTexts: portErrPortIndex.setDescription("This object indicates the module's port number.(1..Max port number in the module)")
portErrPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portErrPortState.setStatus('current')
if mibBuilder.loadTexts: portErrPortState.setDescription('This object decides whether the port state is enabled or disabled.')
portErrPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("err-disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portErrPortStatus.setStatus('current')
if mibBuilder.loadTexts: portErrPortStatus.setDescription('This object decides whether the PortStatus is err-disabled.')
portErrPortReason = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lbd", 1), ("trafficcontrol", 2), ("duld", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portErrPortReason.setStatus('current')
if mibBuilder.loadTexts: portErrPortReason.setDescription('This object decides whether the PortStatus is LBD, Traffic Control, DULD.')
portUtilizTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 4), )
if mibBuilder.loadTexts: portUtilizTable.setStatus('current')
if mibBuilder.loadTexts: portUtilizTable.setDescription('A table to display the TX/RX frames per second and port utilization.')
portUtilizEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "portUtilizIndex"))
if mibBuilder.loadTexts: portUtilizEntry.setStatus('current')
if mibBuilder.loadTexts: portUtilizEntry.setDescription('An entry appears in this table for each interface in the system. Index to the table is the interface index of the port.')
portUtilizIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portUtilizIndex.setStatus('current')
if mibBuilder.loadTexts: portUtilizIndex.setDescription('Interface index of the port for the configuration in this entry applies.')
portUtilizTX = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portUtilizTX.setStatus('current')
if mibBuilder.loadTexts: portUtilizTX.setDescription('The total number of frames forwarded on the interface during last second.')
portUtilizRX = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portUtilizRX.setStatus('current')
if mibBuilder.loadTexts: portUtilizRX.setDescription('The total number of frames received on the interface during last second.')
portUtilizAverage = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 1, 100, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portUtilizAverage.setStatus('current')
if mibBuilder.loadTexts: portUtilizAverage.setDescription('interface frame usage during last second.')
sysStatisticsTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1), )
if mibBuilder.loadTexts: sysStatisticsTable.setStatus('current')
if mibBuilder.loadTexts: sysStatisticsTable.setDescription('A list of interface entries. The number of entries is given by the value of ifNumber.')
statisticsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "statisticsIndex"))
if mibBuilder.loadTexts: statisticsEntry.setStatus('current')
if mibBuilder.loadTexts: statisticsEntry.setDescription('An entry containing management information applicable to a particular interface.')
statisticsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsIndex.setStatus('current')
if mibBuilder.loadTexts: statisticsIndex.setDescription("A unique value, greater than zero, for each interface. It is recommended that values are assigned contiguously starting from 1. The value for each interface sub-layer must remain constant at least from one re-initialization of the entity's network management system to the next re- initialization.")
statisticsInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsInOctets.setStatus('current')
if mibBuilder.loadTexts: statisticsInOctets.setDescription('The total number of octets received on the interface, including framing characters. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsInUcastPkts.setStatus('current')
if mibBuilder.loadTexts: statisticsInUcastPkts.setDescription('The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were not addressed to a multicast or broadcast address at this sub-layer. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsInMcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsInMcastPkts.setStatus('current')
if mibBuilder.loadTexts: statisticsInMcastPkts.setDescription('The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were not addressed to a multicast address at this sub-layer. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsInNUcastPkts.setStatus('deprecated')
if mibBuilder.loadTexts: statisticsInNUcastPkts.setDescription('The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were addressed to a multicast or broadcast address at this sub-layer. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. This object is deprecated in favour of ifInMulticastPkts and ifInBroadcastPkts.')
statisticsInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsInDiscards.setStatus('current')
if mibBuilder.loadTexts: statisticsInDiscards.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher-layer protocol. One possible reason for discarding such a packet could be to free up buffer space. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsInErrors.setStatus('current')
if mibBuilder.loadTexts: statisticsInErrors.setDescription('For packet-oriented interfaces, the number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol. For character- oriented or fixed-length interfaces, the number of inbound transmission units that contained errors preventing them from being deliverable to a higher-layer protocol. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsOutOctets.setStatus('current')
if mibBuilder.loadTexts: statisticsOutOctets.setDescription('The total number of octets transmitted out of the interface, including framing characters. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsOutUcastPkts.setStatus('current')
if mibBuilder.loadTexts: statisticsOutUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted, and which were not addressed to a multicast or broadcast address at this sub-layer, including those that were discarded or not sent. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsOutNUcastPkts.setStatus('deprecated')
if mibBuilder.loadTexts: statisticsOutNUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted, and which were addressed to a multicast or broadcast address at this sub-layer, including those that were discarded or not sent. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime. This object is deprecated in favour of ifOutMulticastPkts and ifOutBroadcastPkts.')
statisticsOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsOutErrors.setStatus('current')
if mibBuilder.loadTexts: statisticsOutErrors.setDescription('For packet-oriented interfaces, the number of outbound packets that could not be transmitted because of errors. For character-oriented or fixed-length interfaces, the number of outbound transmission units that could not be transmitted because of errors. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsOutDiscards.setStatus('current')
if mibBuilder.loadTexts: statisticsOutDiscards.setDescription('The number of outbound packets which were chosen to be discarded even though no errors had been detected to prevent their being transmitted. One possible reason for discarding such a packet could be to free up buffer space.')
statisticsLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsLateCollisions.setReference('[IEEE 802.3 Std.], 30.3.1.1.10, aLateCollisions.')
if mibBuilder.loadTexts: statisticsLateCollisions.setStatus('current')
if mibBuilder.loadTexts: statisticsLateCollisions.setDescription('The number of times that a collision is detected on a particular interface later than one slotTime into the transmission of a packet. A (late) collision included in a count represented by an instance of this object is also considered as a (generic) collision for purposes of other collision-related statistics. This counter does not increment when the interface is operating in full-duplex mode. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsExcessiveCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsExcessiveCollisions.setReference('[IEEE 802.3 Std.], 30.3.1.1.11, aFramesAbortedDueToXSColls.')
if mibBuilder.loadTexts: statisticsExcessiveCollisions.setStatus('current')
if mibBuilder.loadTexts: statisticsExcessiveCollisions.setDescription('A count of frames for which transmission on a particular interface fails due to excessive collisions. This counter does not increment when the interface is operating in full-duplex mode. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsFCSErrors.setReference('[IEEE 802.3 Std.], 30.3.1.1.6, aFrameCheckSequenceErrors.')
if mibBuilder.loadTexts: statisticsFCSErrors.setStatus('current')
if mibBuilder.loadTexts: statisticsFCSErrors.setDescription("A count of frames received on a particular interface that are an integral number of octets in length but do not pass the FCS check. This count does not include frames received with frame-too-long or frame-too-short error. The count represented by an instance of this object is incremented when the frameCheckError status is returned by the MAC service to the LLC (or other MAC user). Received frames for which multiple error conditions pertain are, according to the conventions of IEEE 802.3 Layer Management, counted exclusively according to the error status presented to the LLC. Note: Coding errors detected by the physical layer for speeds above 10 Mb/s will cause the frame to fail the FCS check. For interfaces operating at 10 Gb/s, this counter can roll over in less than 5 minutes if it is incrementing at its maximum rate. Since that amount of time could be less than a management station's poll cycle time, in order to avoid a loss of information, a management station is advised to poll the dot3HCStatsFCSErrors object for 10 Gb/s or faster interfaces. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.")
statisticsFrameTooLongs = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsFrameTooLongs.setReference('[IEEE 802.3 Std.], 30.3.1.1.25, aFrameTooLongErrors.')
if mibBuilder.loadTexts: statisticsFrameTooLongs.setStatus('current')
if mibBuilder.loadTexts: statisticsFrameTooLongs.setDescription("A count of frames received on a particular interface that exceed the maximum permitted frame size. The count represented by an instance of this object is incremented when the frameTooLong status is returned by the MAC service to the LLC (or other MAC user). Received frames for which multiple error conditions pertain are, according to the conventions of IEEE 802.3 Layer Management, counted exclusively according to the error status presented to the LLC. For interfaces operating at 10 Gb/s, this counter can roll over in less than 80 minutes if it is incrementing at its maximum rate. Since that amount of time could be less than a management station's poll cycle time, in order to avoid a loss of information, a management station is advised to poll the dot3HCStatsFrameTooLongs object for 10 Gb/s or faster interfaces. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.")
statisticsEtherUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 17), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsEtherUndersizePkts.setStatus('current')
if mibBuilder.loadTexts: statisticsEtherUndersizePkts.setDescription('The total number of packets received that were less than 64 octets long (excluding framing bits, but including FCS octets) and were otherwise well formed.')
statisticsEtherOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 18), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsEtherOversizePkts.setStatus('current')
if mibBuilder.loadTexts: statisticsEtherOversizePkts.setDescription('The total number of packets received that were longer than 1518 octets (excluding framing bits, but including FCS octets) and were otherwise well formed.')
statisticsEtherFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 19), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsEtherFragments.setStatus('current')
if mibBuilder.loadTexts: statisticsEtherFragments.setDescription('The total number of packets received that were less than 64 octets in length (excluding framing bits but including FCS octets) and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that it is entirely normal for statisEtherFragments to increment. This is because it counts both runts (which are normal occurrences due to collisions) and noise hits.')
statisticsEtherJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 20), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsEtherJabbers.setStatus('current')
if mibBuilder.loadTexts: statisticsEtherJabbers.setDescription('The total number of packets received that were longer than 1518 octets (excluding framing bits, but including FCS octets), and had either a bad Frame Check Sequence (FCS) with an integral number of octets (FCS Error) or a bad FCS with a non-integral number of octets (Alignment Error). Note that this definition of jabber is different than the definition in IEEE-802.3 section 8.2.1.5 (10BASE5) and section 10.3.1.4 (10BASE2). These documents define jabber as the condition where any packet exceeds 20 ms. The allowed range to detect jabber is between 20 ms and 150 ms.')
statisticsEtherDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsEtherDropEvents.setStatus('current')
if mibBuilder.loadTexts: statisticsEtherDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
statisticsDeferredTransmissions = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsDeferredTransmissions.setStatus('current')
if mibBuilder.loadTexts: statisticsDeferredTransmissions.setDescription('A count of frames for which the first transmission attempt on a particular interface is delayed because the medium is busy. The count represented by an instance of this object does not include frames involved in collisions. This counter does not increment when the interface is operating in full-duplex mode. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsSingleCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsSingleCollisionFrames.setStatus('current')
if mibBuilder.loadTexts: statisticsSingleCollisionFrames.setDescription('A count of frames that are involved in a single collision, and are subsequently transmitted successfully. A frame that is counted by an instance of this object is also counted by the corresponding instance of either the ifOutUcastPkts, ifOutMulticastPkts, or ifOutBroadcastPkts, and is not counted by the corresponding instance of the dot3StatsMultipleCollisionFrames object. This counter does not increment when the interface is operating in full-duplex mode. Discontinuities in the value of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of ifCounterDiscontinuityTime.')
statisticsStatsCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsStatsCollisions.setStatus('current')
if mibBuilder.loadTexts: statisticsStatsCollisions.setDescription('The best estimate of the total number of collisions on this Ethernet segment. The value returned will depend on the location of the RMON probe. Section 8.2.1.3 (10BASE-5) and section 10.3.1.3 (10BASE-2) of IEEE standard 802.3 states that a station must detect a collision, in the receive mode, if three or more stations are transmitting simultaneously. A repeater port must detect a collision when two or more stations are transmitting simultaneously. Thus a probe placed on a repeater port could record more collisions than a probe connected to a station on the same segment would. Probe location plays a much smaller role when considering 10BASE-T. 14.2.1.4 (10BASE-T) of IEEE standard 802.3 defines a collision as the simultaneous presence of signals on the DO and RD circuits (transmitting and receiving at the same time). A 10BASE-T station can only detect collisions when it is transmitting. Thus probes placed on a station and a repeater, should report the same number of collisions. Note also that an RMON probe inside a repeater should ideally report collisions between the repeater and one or more other hosts (transmit collisions as defined by IEEE 802.3k) plus receiver collisions observed on any coax segments to which the repeater is connected.')
statisticsPkts64Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsPkts64Octets.setStatus('current')
if mibBuilder.loadTexts: statisticsPkts64Octets.setDescription("The number of pkts that it's length is 64 bytes.")
statisticsPkts65to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsPkts65to127Octets.setStatus('current')
if mibBuilder.loadTexts: statisticsPkts65to127Octets.setDescription("The number of Rx pkts that it's length is 65-127 bytes.")
statisticsPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsPkts128to255Octets.setStatus('current')
if mibBuilder.loadTexts: statisticsPkts128to255Octets.setDescription("The number of Rx pkts that it's length is 128-255 bytes.")
statisticsPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsPkts256to511Octets.setStatus('current')
if mibBuilder.loadTexts: statisticsPkts256to511Octets.setDescription("The number of Rx pkts that it's length is 256-511 bytes.")
statisticsPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsPkts512to1023Octets.setStatus('current')
if mibBuilder.loadTexts: statisticsPkts512to1023Octets.setDescription("The number of Rx pkts that it's length is 512-1023 bytes.")
statisticsPkts1024to1518Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsPkts1024to1518Octets.setStatus('current')
if mibBuilder.loadTexts: statisticsPkts1024to1518Octets.setDescription("The number of Rx pkts that it's length is 1024-1518 bytes.")
sysStatisticsClearTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 2), )
if mibBuilder.loadTexts: sysStatisticsClearTable.setStatus('current')
if mibBuilder.loadTexts: sysStatisticsClearTable.setDescription('A list of interface entries. The number of entries is given by the value of ifNumber.')
statisticsClearEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "statisticsClearIndex"))
if mibBuilder.loadTexts: statisticsClearEntry.setStatus('current')
if mibBuilder.loadTexts: statisticsClearEntry.setDescription('An entry containing management information applicable to a particular interface.')
statisticsClearIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statisticsClearIndex.setStatus('current')
if mibBuilder.loadTexts: statisticsClearIndex.setDescription("A unique value, greater than zero, for each interface. It is recommended that values are assigned contiguously starting from 1. The value for each interface sub-layer must remain constant at least from one re-initialization of the entity's network management system to the next re- initialization.")
statisticsClearStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 99, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statisticsClearStatus.setStatus('current')
if mibBuilder.loadTexts: statisticsClearStatus.setDescription('Enable or disable statistics Counters Clear on read by port.')
sysDot1qVlanManagementOnOff = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDot1qVlanManagementOnOff.setStatus('current')
if mibBuilder.loadTexts: sysDot1qVlanManagementOnOff.setDescription('Enable/Disable management VLAN mechanism.')
sysDot1qVlanManagementid = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 3), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDot1qVlanManagementid.setStatus('current')
if mibBuilder.loadTexts: sysDot1qVlanManagementid.setDescription('The management VLAN ID, which will allow to forward packets of that VLAN to CPU.')
sysDot1qPVIDAutoAssign = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDot1qPVIDAutoAssign.setStatus('current')
if mibBuilder.loadTexts: sysDot1qPVIDAutoAssign.setDescription('Enable/Disable IEEE 802.1Q PVID Auto assign')
sysDot1qVlanAsyOnOff = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDot1qVlanAsyOnOff.setStatus('current')
if mibBuilder.loadTexts: sysDot1qVlanAsyOnOff.setDescription('Enable/Disable IEEE 802.1Q Asymmetric VLAN')
sysDot1qVlanTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 6), )
if mibBuilder.loadTexts: sysDot1qVlanTable.setStatus('current')
if mibBuilder.loadTexts: sysDot1qVlanTable.setDescription('A table containing static configuration information for each VLAN configured into the device by (local or network) management. All entries are permanent and will be restored after the device is reset.')
dot1qVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 6, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "dot1qVlanid"))
if mibBuilder.loadTexts: dot1qVlanEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanEntry.setDescription('Information for a VLAN configured into the device by (local or network) management.')
dot1qVlanid = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanid.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanid.setDescription('Vlan id used to identify the VLAN.')
dot1qVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 6, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanName.setReference('IEEE 802.1Q/D11 Section 12.10.2.1')
if mibBuilder.loadTexts: dot1qVlanName.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanName.setDescription('An administratively assigned string, which may be used to identify the VLAN.')
dot1qVlanEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 6, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanEgressPorts.setReference('IEEE 802.1Q/D11 Section 12.7.7.3, 11.2.3.2.3')
if mibBuilder.loadTexts: dot1qVlanEgressPorts.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanEgressPorts.setDescription('The set of ports which are permanently assigned to the egress list for this VLAN by management. Changes to a bit in this object affect the per-port per-VLAN Registrar control for Registration Fixed for the relevant GVRP state machine on each port. A port may not be added in this set if it is already a member of the set of ports in dot1qVlanForbiddenEgressPorts. The default value of this object is a string of zeros of appropriate length, indicating not fixed.')
dot1qVlanUntaggedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 6, 1, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanUntaggedPorts.setReference('IEEE 802.1Q/D11 Section 12.10.2.1')
if mibBuilder.loadTexts: dot1qVlanUntaggedPorts.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanUntaggedPorts.setDescription('The set of ports which should transmit egress packets for this VLAN as untagged. The default value of this object for the default VLAN (dot1qVlanIndex = 1) is a string of appropriate length including all ports. There is no specified default for other VLANs. If a device agent cannot support the set of ports being set then it will reject the set operation with an error. An example might be if a manager attempts to set more than one VLAN to be untagged on egress where the device does not support this IEEE 802.1Q option.')
dot1qVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 6, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanRowStatus.setDescription('The status of a row in sysDot1qVlanTable. By setting this object, new entries can be created in sysDot1qVlanTable and existing entries can be removed from sysDot1qVlanTable. It can be used as specified in the SNMP v2 standard.')
sysDot1qVlanPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 7), )
if mibBuilder.loadTexts: sysDot1qVlanPortTable.setStatus('current')
if mibBuilder.loadTexts: sysDot1qVlanPortTable.setDescription('A table containing per port control and status information for VLAN configuration in the device.')
dot1qVlanPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 7, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "dot1qVlanPortIndex"))
if mibBuilder.loadTexts: dot1qVlanPortEntry.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanPortEntry.setDescription('Information controlling VLAN configuration for a port on the device.')
dot1qVlanPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 7, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dot1qVlanPortIndex.setReference('IEEE 802.1Q/D11 Section 12.10.1.1')
if mibBuilder.loadTexts: dot1qVlanPortIndex.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanPortIndex.setDescription('Port index.')
dot1qVlanPortVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 7, 7, 1, 2), VlanIndex().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dot1qVlanPortVlanId.setReference('IEEE 802.1Q/D11 Section 12.10.1.1')
if mibBuilder.loadTexts: dot1qVlanPortVlanId.setStatus('current')
if mibBuilder.loadTexts: dot1qVlanPortVlanId.setDescription('The PVID, the VLAN ID assigned to untagged frames or Priority-Tagged frames received on this port.')
aacAuthenAdminState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacAuthenAdminState.setStatus('current')
if mibBuilder.loadTexts: aacAuthenAdminState.setDescription('This object indicates the Access Authentication is enable or disable.')
aacAuthParamResponseTimeout = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacAuthParamResponseTimeout.setStatus('current')
if mibBuilder.loadTexts: aacAuthParamResponseTimeout.setDescription('Timeout in second for login authentication response.')
aacAuthParamAttempt = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacAuthParamAttempt.setStatus('current')
if mibBuilder.loadTexts: aacAuthParamAttempt.setDescription('The amount for login authentication, if login failure exceed, connection or access would be locked.')
aacLocalEnablePassword = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacLocalEnablePassword.setStatus('current')
if mibBuilder.loadTexts: aacLocalEnablePassword.setDescription('This object is used to set Local Enable Password.')
aacAPAuthMethodGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 5))
aacAPLoginMethod = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 5, 1))
aacAPEnableMethod = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 5, 2))
aacAPTelnetLoginMethod = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacAPTelnetLoginMethod.setStatus('current')
if mibBuilder.loadTexts: aacAPTelnetLoginMethod.setDescription('Specify the way which has to execute authentication while login the system and the method for authentication.Access system via telnet.')
aacAPHttpLoginMethod = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacAPHttpLoginMethod.setStatus('current')
if mibBuilder.loadTexts: aacAPHttpLoginMethod.setDescription('Specify the way which has to execute authentication while login the system and the method for authentication.Access system via HTTP.')
aacAPTelnetEnableMethod = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 5, 2, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacAPTelnetEnableMethod.setStatus('current')
if mibBuilder.loadTexts: aacAPTelnetEnableMethod.setDescription('Specify the way which has to execute authentication while login the system and the method for authentication.Access system via telnet.')
aacAPHttpEnableMethod = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 5, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacAPHttpEnableMethod.setStatus('current')
if mibBuilder.loadTexts: aacAPHttpEnableMethod.setDescription('Specify the way which has to execute authentication while login the system and the method for authentication.Access system via HTTP.')
aacLoginMethodListTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6), )
if mibBuilder.loadTexts: aacLoginMethodListTable.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethodListTable.setDescription('A table that contains information about Login authentication method lists.')
aacLoginMethodListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aacLoginMethodListName"))
if mibBuilder.loadTexts: aacLoginMethodListEntry.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethodListEntry.setDescription('A list of the Authentication methods.')
aacLoginMethodListName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aacLoginMethodListName.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethodListName.setDescription('A human-readable text string of the method list.')
aacLoginMethod1 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacLoginMethod1.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethod1.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacLoginMethod2 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacLoginMethod2.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethod2.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacLoginMethod3 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacLoginMethod3.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethod3.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacLoginMethod4 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacLoginMethod4.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethod4.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacLoginMethodListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 6, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacLoginMethodListRowStatus.setStatus('current')
if mibBuilder.loadTexts: aacLoginMethodListRowStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
aacEnableMethodListTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7), )
if mibBuilder.loadTexts: aacEnableMethodListTable.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethodListTable.setDescription('A table that contains information about Enable authentication method lists.')
aacEnableMethodListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aacEnableMethodListName"))
if mibBuilder.loadTexts: aacEnableMethodListEntry.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethodListEntry.setDescription('A list of the Authentication methods.')
aacEnableMethodListName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aacEnableMethodListName.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethodListName.setDescription('A human-readable text string of the method list.')
aacEnableMethod1 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7, 1, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacEnableMethod1.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethod1.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacEnableMethod2 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacEnableMethod2.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethod2.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacEnableMethod3 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacEnableMethod3.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethod3.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacEnableMethod4 = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacEnableMethod4.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethod4.setDescription('The type of Login method list. Besides the pre-defined type, it also allow to be set user-defined group by aacServerGroupIndex.')
aacEnableMethodListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 7, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacEnableMethodListRowStatus.setStatus('current')
if mibBuilder.loadTexts: aacEnableMethodListRowStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
aacServerGroupTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 8), )
if mibBuilder.loadTexts: aacServerGroupTable.setStatus('current')
if mibBuilder.loadTexts: aacServerGroupTable.setDescription('A table that contains informations about server group.')
aacServerGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 8, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aacServerGroupName"))
if mibBuilder.loadTexts: aacServerGroupEntry.setStatus('current')
if mibBuilder.loadTexts: aacServerGroupEntry.setDescription('A list of the group including servers.')
aacServerGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 8, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aacServerGroupName.setStatus('current')
if mibBuilder.loadTexts: aacServerGroupName.setDescription('A human-readable text string of the method group.')
aacServersInGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 8, 1, 2), Bits().clone(namedValues=NamedValues(("id1", 0), ("id2", 1), ("id3", 2), ("id4", 3), ("id5", 4), ("id6", 5), ("id7", 6), ("id8", 7), ("id9", 8), ("id10", 9), ("id11", 10), ("id12", 11), ("id13", 12), ("id14", 13), ("id15", 14), ("id16", 15)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServersInGroup.setStatus('current')
if mibBuilder.loadTexts: aacServersInGroup.setDescription('The list of servers in the group, each bit indicates a specified server ID. The server must be created before including it.')
aacServerGroupRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 8, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServerGroupRowStatus.setStatus('current')
if mibBuilder.loadTexts: aacServerGroupRowStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
aacServerInfoTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9), )
if mibBuilder.loadTexts: aacServerInfoTable.setStatus('current')
if mibBuilder.loadTexts: aacServerInfoTable.setDescription('A table that contains information about radius severs.')
aacServerInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aacServerIPType"), (0, "DGS-1100-10ME_A1", "aacServerIPAddr"))
if mibBuilder.loadTexts: aacServerInfoEntry.setStatus('current')
if mibBuilder.loadTexts: aacServerInfoEntry.setDescription('A list of the information of server .')
aacServerIPType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: aacServerIPType.setStatus('current')
if mibBuilder.loadTexts: aacServerIPType.setDescription('The IP address of the radius AAC server IP type referred to in this table entry. (IPv4=1, IPv6=2)')
aacServerIPAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aacServerIPAddr.setStatus('current')
if mibBuilder.loadTexts: aacServerIPAddr.setDescription('The IP address of radius Server')
aacServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aacServerIndex.setStatus('current')
if mibBuilder.loadTexts: aacServerIndex.setDescription('A value that uniquely identifies this SwAACServerGroupEntry.')
aacServerInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServerInterfaceName.setStatus('current')
if mibBuilder.loadTexts: aacServerInterfaceName.setDescription('Specifies the interface name when the aacServerIPAddr is linklocal address.')
aacServerAuthPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServerAuthPort.setStatus('current')
if mibBuilder.loadTexts: aacServerAuthPort.setDescription('The TCP/IP port .')
aacServerAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 254))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServerAuthKey.setStatus('current')
if mibBuilder.loadTexts: aacServerAuthKey.setDescription('The key used while authentication process.')
aacServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServerTimeout.setStatus('current')
if mibBuilder.loadTexts: aacServerTimeout.setDescription('radius Server response timeout .')
aacServerRetryCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServerRetryCount.setStatus('current')
if mibBuilder.loadTexts: aacServerRetryCount.setDescription('Client retry count . (-1: No retry mechanism)')
aacServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 11, 9, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aacServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: aacServerRowStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is be deleted when this object is SET 'destroy'.")
sysCableDiagTriggerIndex = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysCableDiagTriggerIndex.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagTriggerIndex.setDescription('Trigger an interface index to do cable diagnostic.')
sysCableDiagPair1TestResult = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5))).clone(namedValues=NamedValues(("ok", 0), ("open", 1), ("short", 2), ("notAvailable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair1TestResult.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair1TestResult.setDescription('Cable diagnostics pair 1 test result.')
sysCableDiagPair1FaultDistance = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair1FaultDistance.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair1FaultDistance.setDescription('Cable Diagnostics pair 1 fault distance.')
sysCableDiagPair2TestResult = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5))).clone(namedValues=NamedValues(("ok", 0), ("open", 1), ("short", 2), ("notAvailable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair2TestResult.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair2TestResult.setDescription('Cable diagnostics pair 2 test result.')
sysCableDiagPair2FaultDistance = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair2FaultDistance.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair2FaultDistance.setDescription('Cable diagnostics pair 2 fault distance.')
sysCableDiagPair3TestResult = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5))).clone(namedValues=NamedValues(("ok", 0), ("open", 1), ("short", 2), ("notAvailable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair3TestResult.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair3TestResult.setDescription('Cable diagnostics pair 3 test result.')
sysCableDiagPair3FaultDistance = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair3FaultDistance.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair3FaultDistance.setDescription('Cable diagnostics pair 3 fault distance.')
sysCableDiagPair4TestResult = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5))).clone(namedValues=NamedValues(("ok", 0), ("open", 1), ("short", 2), ("notAvailable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair4TestResult.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair4TestResult.setDescription('Cable diagnostics pair 4 test result.')
sysCableDiagPair4FaultDistance = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagPair4FaultDistance.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagPair4FaultDistance.setDescription('Cable diagnostics pair 4 fault distance.')
sysCableDiagLengthinRange = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 35, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("less50", 1), ("from50to80", 2), ("from80to100", 3), ("from100to140", 4), ("notAvailable", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysCableDiagLengthinRange.setStatus('current')
if mibBuilder.loadTexts: sysCableDiagLengthinRange.setDescription('Cable diagnostics length when link up in speed 1G. (Display in range)')
sysLBDStateEnable = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDStateEnable.setStatus('current')
if mibBuilder.loadTexts: sysLBDStateEnable.setDescription('Enable/Disable Loopback detection function. The Loopback Detection function is used to detect the loop created by a specific port while Spanning Tree Protocol (STP) is not enabled in the network, especially when the down links are hubs or unmanaged switchs.The Switch will automatically shutdown the port and sends a log to the administrator.')
sysLBDMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port", 1), ("vlan", 2))).clone('port')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDMode.setStatus('current')
if mibBuilder.loadTexts: sysLBDMode.setDescription('Loopback detection function mode.')
sysLBDInterval = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32767)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDInterval.setStatus('current')
if mibBuilder.loadTexts: sysLBDInterval.setDescription('Set a Loop detection Interval between 1 and 32767 seconds. The default is 2 seconds. This time interval to be used at counting time seconds to resend the CTP packet automatically.')
sysLBDRecoverTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(60, 1000000), )).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDRecoverTime.setStatus('current')
if mibBuilder.loadTexts: sysLBDRecoverTime.setDescription('This time interval to be used at counting time seconds to recover the disabled port automatically. The Loop Detection Recover Time can be set at 0 seconds, or 60 to 1000000 seconds. Entering 0 will disable the Loop Detection Recover Time. The default is 60 seconds.')
sysLBDCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 5), )
if mibBuilder.loadTexts: sysLBDCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysLBDCtrlTable.setDescription('A table to control Loopback detection features either for the entire switch or for each interface in the switch.')
sysLBDCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 5, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "sysLBDCtrlIndex"))
if mibBuilder.loadTexts: sysLBDCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: sysLBDCtrlEntry.setDescription('An entry appears in this table for each interface in the system.')
sysLBDCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLBDCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: sysLBDCtrlIndex.setDescription('The interface index of the port for which the configuration in this entry applies.')
sysLBDPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDPortStatus.setStatus('current')
if mibBuilder.loadTexts: sysLBDPortStatus.setDescription('Provides control to per port enable or disable the loopback detection function. Default is disabled.')
sysLBDPortLoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("loop", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLBDPortLoopStatus.setStatus('current')
if mibBuilder.loadTexts: sysLBDPortLoopStatus.setDescription('The loop status for this port.')
sysLBDVlanLoopTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 6), )
if mibBuilder.loadTexts: sysLBDVlanLoopTable.setStatus('current')
if mibBuilder.loadTexts: sysLBDVlanLoopTable.setDescription('A table to display Loopback detection features by vlan mode .')
sysLBDVlanLoopEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 6, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "sysLBDVlanLoopIndex"))
if mibBuilder.loadTexts: sysLBDVlanLoopEntry.setStatus('current')
if mibBuilder.loadTexts: sysLBDVlanLoopEntry.setDescription('An entry appears in this table for each interface in the system.')
sysLBDVlanLoopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLBDVlanLoopIndex.setStatus('current')
if mibBuilder.loadTexts: sysLBDVlanLoopIndex.setDescription('Display port lists loop status by vlan.')
sysLBDVlanLoopPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 6, 1, 2), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysLBDVlanLoopPorts.setStatus('current')
if mibBuilder.loadTexts: sysLBDVlanLoopPorts.setDescription('Display port lists loop status by vlan.')
sysLBDEnabledVlanList = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLBDEnabledVlanList.setStatus('current')
if mibBuilder.loadTexts: sysLBDEnabledVlanList.setDescription("This object indicates the VLANs that enabled LBD. Note: For the LBD enabled VLAN specification, the value should be separated by ',' or '-'. Such as: 1,4,7 or 1,4,7-9 .")
sysLBDTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 8))
lbdTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 8, 0))
loopbackOccur = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 8, 0, 1)).setObjects(("DGS-1100-10ME_A1", "sysLBDCtrlIndex"), ("DGS-1100-10ME_A1", "sysLBDPortLoopStatus"))
if mibBuilder.loadTexts: loopbackOccur.setStatus('current')
if mibBuilder.loadTexts: loopbackOccur.setDescription('A loopbackOccur notification is sent when loop found.')
loopbackRecovery = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 17, 8, 0, 2)).setObjects(("DGS-1100-10ME_A1", "sysLBDCtrlIndex"), ("DGS-1100-10ME_A1", "sysLBDRecoverTime"))
if mibBuilder.loadTexts: loopbackRecovery.setStatus('current')
if mibBuilder.loadTexts: loopbackRecovery.setDescription('A loopbackRecovery notification is sent when recovery time comes to end.')
sysLLDPXdot3Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12))
sysLLDPXdot1Objects = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13))
sysLLDPStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14))
sysLLDPLocalSystemData = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15))
sysLLDPRemoteSystemsData = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16))
sysLLDPNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17))
sysLLDPState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLLDPState.setStatus('current')
if mibBuilder.loadTexts: sysLLDPState.setDescription('This object is used for enabling or disabling LLDP in the system.')
sysLLDPMsgHoldMultiplier = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLLDPMsgHoldMultiplier.setStatus('current')
if mibBuilder.loadTexts: sysLLDPMsgHoldMultiplier.setDescription('The time-to-live value expressed as a multiple of the lldpMessageTxInterval object.The actual time-to-live value used in LLDP frames, transmitted on behalf of this LLDP agent, can be expressed by the following formula: TTL = min(65535, (lldpMessageTxInterval * lldpMessageTxHoldMultiplier))')
sysLLDPMsgTxInterval = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 32768))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLLDPMsgTxInterval.setStatus('current')
if mibBuilder.loadTexts: sysLLDPMsgTxInterval.setDescription('This object is used for LLDP packet update frequency. The timer in units of seconds.')
sysLLDPReinitDelay = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLLDPReinitDelay.setStatus('current')
if mibBuilder.loadTexts: sysLLDPReinitDelay.setDescription('This object is used for LLDP Reinitialization Delay. The timer in units of seconds.')
sysLLDPTxDelay = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8192))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysLLDPTxDelay.setStatus('current')
if mibBuilder.loadTexts: sysLLDPTxDelay.setDescription('The lldpTxDelay indicates the delay (in units of seconds) between successive LLDP frame transmissions initiated by value/status changes in the LLDP local systems MIB. The recommended value for the lldpTxDelay is set by the following formula: 1 <= lldpTxDelay <= (0.25 * lldpMessageTxInterval).')
sysLLDPConfigManAddrTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 6), )
if mibBuilder.loadTexts: sysLLDPConfigManAddrTable.setStatus('current')
if mibBuilder.loadTexts: sysLLDPConfigManAddrTable.setDescription('The table that controls selection of LLDP management address TLV instances to be transmitted on individual ports.')
sysLLDPConfigManAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 6, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpConfigManAddrSubtype"), (0, "DGS-1100-10ME_A1", "lldpConfigManAddr"))
if mibBuilder.loadTexts: sysLLDPConfigManAddrEntry.setStatus('current')
if mibBuilder.loadTexts: sysLLDPConfigManAddrEntry.setDescription('LLDP configuration information that specifies the set of ports (represented as a PortList) on which the local system management address instance will be transmitted. Each active sysLLDPConfigManAddrEntry must be restored from non-volatile and re-created (along with the corresponding lldpLocManAddrEntry) after a re-initialization of the management system.')
lldpConfigManAddrSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 6, 1, 1), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpConfigManAddrSubtype.setReference('IEEE 802.1AB-2005 9.5.9.3')
if mibBuilder.loadTexts: lldpConfigManAddrSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpConfigManAddrSubtype.setDescription("The type of management address identifier encoding used in the associated 'lldpLocManagmentAddr' object.")
lldpConfigManAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 6, 1, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpConfigManAddr.setReference('IEEE 802.1AB-2005 9.5.9.4')
if mibBuilder.loadTexts: lldpConfigManAddr.setStatus('current')
if mibBuilder.loadTexts: lldpConfigManAddr.setDescription('The string value used to identify the management address component associated with the local system. The purpose of this address is to contact the management entity.')
lldpConfigManAddrPortsTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 6, 1, 3), LldpPortList().clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpConfigManAddrPortsTxEnable.setReference('IEEE 802.1AB-2005 10.2.1.1')
if mibBuilder.loadTexts: lldpConfigManAddrPortsTxEnable.setStatus('current')
if mibBuilder.loadTexts: lldpConfigManAddrPortsTxEnable.setDescription('A set of ports that are identified by a PortList, in which each port is represented as a bit. The corresponding local system management address instance will be transmitted on the member ports of the lldpManAddrPortsTxEnable. The default value for lldpConfigManAddrPortsTxEnable object is empty binary string, which means no ports are specified for advertising indicated management address instance.')
sysLLDPPortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 11), )
if mibBuilder.loadTexts: sysLLDPPortConfigTable.setStatus('current')
if mibBuilder.loadTexts: sysLLDPPortConfigTable.setDescription('The table that controls LLDP frame transmission on individual ports.')
sysLLDPPortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 11, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpPortConfigPortNum"))
if mibBuilder.loadTexts: sysLLDPPortConfigEntry.setStatus('current')
if mibBuilder.loadTexts: sysLLDPPortConfigEntry.setDescription('LLDP configuration information for a particular port. This configuration parameter controls the transmission and the reception of LLDP frames on those ports whose rows are created in this table.')
lldpPortConfigPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 11, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpPortConfigPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpPortConfigPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The value of this object is used as a port index to the sysLLDPPortConfigTable.')
lldpPortConfigAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("txOnly", 1), ("rxOnly", 2), ("txAndRx", 3), ("disabled", 4))).clone('txAndRx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpPortConfigAdminStatus.setReference('IEEE 802.1AB-2005 10.5.1')
if mibBuilder.loadTexts: lldpPortConfigAdminStatus.setStatus('current')
if mibBuilder.loadTexts: lldpPortConfigAdminStatus.setDescription("The administratively desired status of the local LLDP agent. If the associated lldpPortConfigAdminStatus object has a value of 'txOnly(1)', then LLDP agent will transmit LLDP frames on this port and it will not store any information about the remote systems connected. If the associated lldpPortConfigAdminStatus object has a value of 'rxOnly(2)', then the LLDP agent will receive, but it will not transmit LLDP frames on this port. If the associated lldpPortConfigAdminStatus object has a value of 'txAndRx(3)', then the LLDP agent will transmit and receive LLDP frames on this port. If the associated lldpPortConfigAdminStatus object has a value of 'disabled(4)', then LLDP agent will not transmit or receive LLDP frames on this port. If there is remote systems information which is received on this port and stored in other tables, before the port's lldpPortConfigAdminStatus becomes disabled, then the information will naturally age out.")
lldpPortConfigNotificationEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 11, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpPortConfigNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: lldpPortConfigNotificationEnable.setDescription('The lldpPortConfigNotificationEnable controls, on a per port basis, whether or not notifications from the agent are enabled. The value true(1) means that notifications are enabled; the value false(2) means that they are not.')
lldpPortConfigTLVsTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 11, 1, 4), Bits().clone(namedValues=NamedValues(("portDesc", 0), ("sysName", 1), ("sysDesc", 2), ("sysCap", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpPortConfigTLVsTxEnable.setReference('IEEE 802.1AB-2005 10.2.1.1')
if mibBuilder.loadTexts: lldpPortConfigTLVsTxEnable.setStatus('current')
if mibBuilder.loadTexts: lldpPortConfigTLVsTxEnable.setDescription("The lldpPortConfigTLVsTxEnable, defined as a bitmap, includes the basic set of LLDP TLVs whose transmission is allowed on the local LLDP agent by the network management. Each bit in the bitmap corresponds to a TLV type associated with a specific optional TLV. It should be noted that the organizationally-specific TLVs are excluded from the lldpTLVsTxEnable bitmap. LLDP Organization Specific Information Extension MIBs should have similar configuration object to control transmission of their organizationally defined TLVs. The bit 'portDesc(0)' indicates that LLDP agent should transmit 'Port Description TLV'. The bit 'sysName(1)' indicates that LLDP agent should transmit 'System Name TLV'. The bit 'sysDesc(2)' indicates that LLDP agent should transmit 'System Description TLV'. The bit 'sysCap(3)' indicates that LLDP agent should transmit 'System Capabilities TLV'. There is no bit reserved for the management address TLV type since transmission of management address TLVs are controlled by another object, sysLLDPConfigManAddrTable. The default value for lldpPortConfigTLVsTxEnable object is empty set, which means no enumerated values are set. The value of this object must be restored from non-volatile storage after a re-initialization of the management system.")
lldpXdot3Config = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 1))
lldpXdot3LocalData = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2))
lldpXdot3RemoteData = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3))
lldpXdot3PortConfigTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 1, 1), )
if mibBuilder.loadTexts: lldpXdot3PortConfigTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3PortConfigTable.setDescription('A table that controls selection of LLDP TLVs to be transmitted on individual ports.')
lldpXdot3PortConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot3PortConfigPortNum"))
if mibBuilder.loadTexts: lldpXdot3PortConfigEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3PortConfigEntry.setDescription('LLDP configuration information that controls the transmission of IEEE 802.3 organizationally defined TLVs on LLDP transmission capable ports. Each active lldpXdot3PortConfigEntry must be from non-volatile storage (along with the corresponding sysLLDPPortConfigEntry) after a re-initialization of the management system.')
lldpXdot3PortConfigPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 1, 1, 1, 1), LldpPortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot3PortConfigPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3PortConfigPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The value of this object is used as a port index to the sysLLDPPortConfigTable.')
lldpXdot3PortConfigTLVsTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 1, 1, 1, 2), Bits().clone(namedValues=NamedValues(("macPhyConfigStatus", 0), ("maxFrameSize", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot3PortConfigTLVsTxEnable.setReference('IEEE 802.1AB-2005 10.2.1.1')
if mibBuilder.loadTexts: lldpXdot3PortConfigTLVsTxEnable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3PortConfigTLVsTxEnable.setDescription("The lldpXdot3PortConfigTLVsTxEnable, defined as a bitmap, includes the IEEE 802.3 organizationally defined set of LLDP TLVs whose transmission is allowed on the local LLDP agent by the network management. Each bit in the bitmap corresponds to an IEEE 802.3 subtype associated with a specific IEEE 802.3 optional TLV. The bit 0 is not used since there is no corresponding subtype. The bit 'macPhyConfigStatus(0)' indicates that LLDP agent should transmit 'MAC/PHY configuration/status TLV'. The bit 'maxFrameSize(1)' indicates that LLDP agent should transmit 'Maximum-frame-size TLV'. The default value for lldpXdot3PortConfigTLVsTxEnable object is an empty set, which means no enumerated values are set. The value of this object must be restored from non-volatile storage after a re-initialization of the management system.")
lldpXdot3LocPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 1), )
if mibBuilder.loadTexts: lldpXdot3LocPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocPortTable.setDescription('This table contains one row per port of Ethernet port information (as a part of the LLDP 802.3 organizational extension) on the local system known to this agent.')
lldpXdot3LocPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot3LocPortNum"))
if mibBuilder.loadTexts: lldpXdot3LocPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocPortEntry.setDescription('Information about a particular port component.')
lldpXdot3LocPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 1, 1, 1), LldpPortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot3LocPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocPortNum.setDescription('The value of this object is used as a port index to the lldpXdot3LocPortTable.')
lldpXdot3LocPortAutoNegSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegSupported.setReference('IEEE 802.1AB-2005 G.2.1')
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegSupported.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegSupported.setDescription('The truth value used to indicate whether the given port (associated with the local system) supports Auto-negotiation.')
lldpXdot3LocPortAutoNegEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 1, 1, 3), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegEnabled.setReference('IEEE 802.1AB-2005 G.2.1')
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegEnabled.setDescription('The truth value used to indicate whether port Auto-negotiation is enabled on the given port associated with the local system.')
lldpXdot3LocPortAutoNegAdvertisedCap = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegAdvertisedCap.setReference('IEEE 802.1AB-2005 G.2.2')
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegAdvertisedCap.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocPortAutoNegAdvertisedCap.setDescription('This object contains the value (bitmap) of the ifMauAutoNegCapAdvertisedBits object (defined in IETF RFC 3636) which is associated with the given port on the local system.')
lldpXdot3LocPortOperMauType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3LocPortOperMauType.setReference('IEEE 802.1AB-2005 G.2.3')
if mibBuilder.loadTexts: lldpXdot3LocPortOperMauType.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocPortOperMauType.setDescription('An integer value that indicates the operational MAU type of the given port on the local system. This object contains the integer value derived from the list position of the corresponding dot3MauType as listed in IETF RFC 3636 (or subsequent revisions) and is equal to the last number in the respective dot3MauType OID. For example, if the ifMauType object is dot3MauType1000BaseTHD which corresponds to {dot3MauType 29}, the numerical value of this field will be 29. For MAU types not listed in RFC 3636 (or subsequent revisions), the value of this field shall be set to zero.')
lldpXdot3LocMaxFrameSizeTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 4), )
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSizeTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSizeTable.setDescription('This table contains one row per port of maximum frame size information (as a part of the LLDP 802.3 organizational extension) on the local system known to this agent.')
lldpXdot3LocMaxFrameSizeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot3LocMaxFrameSizePortNum"))
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSizeEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSizeEntry.setDescription('Maximum Frame Size information about a particular port component.')
lldpXdot3LocMaxFrameSizePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 4, 1, 1), LldpPortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSizePortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSizePortNum.setDescription('The value of this object is used as a port index to the lldpXdot3LocMaxFrameSizeTable.')
lldpXdot3LocMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSize.setReference('IEEE 802.1AB-2005 G.5.1')
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3LocMaxFrameSize.setDescription('An integer value indicating the maximum supported frame size in octets on the given port of the local system.')
lldpXdot3RemPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1), )
if mibBuilder.loadTexts: lldpXdot3RemPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPortTable.setDescription('This table contains Ethernet port information (as a part of the LLDP 802.3 organizational extension) of the remote system.')
lldpXdot3RemPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot3RemTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemIndex"))
if mibBuilder.loadTexts: lldpXdot3RemPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPortEntry.setDescription('Information about a particular physical network connection.')
lldpXdot3RemTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot3RemTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot3RemLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The lldpXdot3RemLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpXdot3RemPortTable.')
lldpXdot3RemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the lldpXdot3RemIndex will wrap between reboots.')
lldpXdot3RemPortAutoNegSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1, 4), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegSupported.setReference('IEEE 802.1AB-2005 G.2.1')
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegSupported.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegSupported.setDescription('The truth value used to indicate whether the given port (associated with remote system) supports Auto-negotiation.')
lldpXdot3RemPortAutoNegEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegEnabled.setReference('IEEE 802.1AB-2005 G.2.1')
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegEnabled.setDescription('The truth value used to indicate whether port Auto-negotiation is enabled on the given port associated with the remote system.')
lldpXdot3RemPortAutoNegAdvertisedCap = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegAdvertisedCap.setReference('IEEE 802.1AB-2005 G.2.2')
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegAdvertisedCap.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPortAutoNegAdvertisedCap.setDescription('This object contains the value (bitmap) of the ifMauAutoNegCapAdvertisedBits object (defined in IETF RFC 3636) which is associated with the given port on the remote system.')
lldpXdot3RemPortOperMauType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPortOperMauType.setReference('IEEE 802.1AB-2005 G.2.3')
if mibBuilder.loadTexts: lldpXdot3RemPortOperMauType.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPortOperMauType.setDescription('An integer value that indicates the operational MAU type of the sending device. This object contains the integer value derived from the list position of the corresponding dot3MauType as listed in in IETF RFC 3636 (or subsequent revisions) and is equal to the last number in the respective dot3MauType OID. For example, if the ifMauType object is dot3MauType1000BaseTHD which corresponds to {dot3MauType 29}, the numerical value of this field will be 29. For MAU types not listed in RFC 3636 (or subsequent revisions), the value of this field shall be set to zero.')
lldpXdot3RemPowerTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2), )
if mibBuilder.loadTexts: lldpXdot3RemPowerTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerTable.setDescription('This table contains Ethernet power information (as a part of the LLDP 802.3 organizational extension) of the remote system.')
lldpXdot3RemPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot3RemPowerTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemPowerLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemPowerIndex"))
if mibBuilder.loadTexts: lldpXdot3RemPowerEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerEntry.setDescription('Information about a particular physical network connection.')
lldpXdot3RemPowerTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot3RemPowerTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot3RemPowerLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The lldpXdot3RemLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpXdot3RemPortTable.')
lldpXdot3RemPowerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the lldpXdot3RemIndex will wrap between reboots.')
lldpXdot3RemPowerPortClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 4), LldpPowerPortClass()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerPortClass.setReference('IEEE 802.1AB-2005 G.3.1')
if mibBuilder.loadTexts: lldpXdot3RemPowerPortClass.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerPortClass.setDescription('The value that identifies the port Class of the given port associated with the remote system.')
lldpXdot3RemPowerMDISupported = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerMDISupported.setReference('IEEE 802.1AB-2005 G.3.1')
if mibBuilder.loadTexts: lldpXdot3RemPowerMDISupported.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerMDISupported.setDescription('The truth value used to indicate whether the MDI power is supported on the given port associated with the remote system.')
lldpXdot3RemPowerMDIEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerMDIEnabled.setReference('IEEE 802.1AB-2005 G.3.1')
if mibBuilder.loadTexts: lldpXdot3RemPowerMDIEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerMDIEnabled.setDescription('The truth value used to identify whether MDI power is enabled on the given port associated with the remote system.')
lldpXdot3RemPowerPairControlable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerPairControlable.setReference('IEEE 802.1AB-2005 G.3.1')
if mibBuilder.loadTexts: lldpXdot3RemPowerPairControlable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerPairControlable.setDescription('The truth value is derived from the value of pethPsePortPowerPairsControlAbility object (defined in IETF RFC 3621) and is used to indicate whether the pair selection can be controlled on the given port associated with the remote system.')
lldpXdot3RemPowerPairs = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerPairs.setReference('IEEE 802.1AB-2005 G.3.2')
if mibBuilder.loadTexts: lldpXdot3RemPowerPairs.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerPairs.setDescription('This object contains the value of the pethPsePortPowerPairs object (defined in IETF RFC 3621) which is associated with the given port on the remote system.')
lldpXdot3RemPowerClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(3, 3), ValueRangeConstraint(4, 4), ValueRangeConstraint(5, 5), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemPowerClass.setReference('IEEE 802.1AB-2005 G.3.3')
if mibBuilder.loadTexts: lldpXdot3RemPowerClass.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemPowerClass.setDescription('This object contains the value of the pethPsePortPowerClassifications object (defined in IETF RFC 3621) which is associated with the given port on the remote system.')
lldpXdot3RemLinkAggTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 3), )
if mibBuilder.loadTexts: lldpXdot3RemLinkAggTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggTable.setDescription('This table contains port link aggregation information (as a part of the LLDP 802.3 organizational extension) of the remote system.')
lldpXdot3RemLinkAggEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot3RemLinkAggTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemLinkAggLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemLinkAggIndex"))
if mibBuilder.loadTexts: lldpXdot3RemLinkAggEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggEntry.setDescription("Link Aggregation information about remote system's port component.")
lldpXdot3RemLinkAggTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 3, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemLinkAggTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot3RemLinkAggLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 3, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemLinkAggLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The lldpXdot3RemLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpXdot3RemPortTable.')
lldpXdot3RemLinkAggIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemLinkAggIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the lldpXdot3RemIndex will wrap between reboots.')
lldpXdot3RemLinkAggStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 3, 1, 4), LldpLinkAggStatusMap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemLinkAggStatus.setReference('IEEE 802.1AB-2005 G.4.1')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggStatus.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggStatus.setDescription('The bitmap value contains the link aggregation capabilities and the current aggregation status of the link.')
lldpXdot3RemLinkAggPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemLinkAggPortId.setReference('IEEE 802.1AB-2005 G.4.2')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggPortId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemLinkAggPortId.setDescription('This object contains the IEEE 802.3 aggregated port identifier, aAggPortID (IEEE 802.3-2002, 30.7.2.1.1), derived from the ifNumber of the ifIndex for the port component associated with the remote system. If the remote port is not in link aggregation state and/or it does not support link aggregation, this value should be zero.')
lldpXdot3RemMaxFrameSizeTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 4), )
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeTable.setDescription('This table contains one row per port of maximum frame size information (as a part of the LLDP 802.3 organizational extension) of the remote system.')
lldpXdot3RemMaxFrameSizeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot3RemMaxFrameSizeTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemMaxFrameSizeLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot3RemMaxFrameSizeIndex"))
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeEntry.setDescription('Maximum Frame Size information about a particular port component.')
lldpXdot3RemMaxFrameSizeTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 4, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot3RemMaxFrameSizeLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 4, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The lldpXdot3RemLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpXdot3RemPortTable.')
lldpXdot3RemMaxFrameSizeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSizeIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the lldpXdot3RemIndex will wrap between reboots.')
lldpXdot3RemMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 12, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSize.setReference('IEEE 802.1AB-2005 G.5.1')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: lldpXdot3RemMaxFrameSize.setDescription('An integer value indicating the maximum supported frame size in octets on the port component associated with the remote system.')
lldpXdot1Config = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1))
lldpXdot1LocalData = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2))
lldpXdot1RemoteData = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3))
lldpXdot1ConfigPortVlanTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 1), )
if mibBuilder.loadTexts: lldpXdot1ConfigPortVlanTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigPortVlanTable.setDescription('A table that controls selection of LLDP Port VLAN-ID TLVs to be transmitted on individual ports.')
lldpXdot1ConfigPortVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1ConfigVlanPortNum"))
if mibBuilder.loadTexts: lldpXdot1ConfigPortVlanEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigPortVlanEntry.setDescription('LLDP configuration information that controls the transmission of IEEE 802.1 organizationally defined Port VLAN-ID TLV on LLDP transmission capable ports. Each active lldpConfigEntry must be restored from non-volatile storage (along with the corresponding sysLLDPPortConfigEntry) after a re-initialization of the management system.')
lldpXdot1ConfigVlanPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 1, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1ConfigVlanPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigVlanPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The value of this object is used as a port index to the sysLLDPPortConfigTable.')
lldpXdot1ConfigPortVlanTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot1ConfigPortVlanTxEnable.setReference('IEEE 802.1AB-2005 10.2.1.1')
if mibBuilder.loadTexts: lldpXdot1ConfigPortVlanTxEnable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigPortVlanTxEnable.setDescription('The lldpXdot1ConfigPortVlanTxEnable, which is defined as a truth value and configured by the network management, determines whether the IEEE 802.1 organizationally defined port VLAN TLV transmission is allowed on a given LLDP transmission capable port. The value of this object must be restored from non-volatile storage after a re-initialization of the management system.')
lldpXdot1ConfigVlanNameTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 2), )
if mibBuilder.loadTexts: lldpXdot1ConfigVlanNameTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigVlanNameTable.setDescription('The table that controls selection of LLDP VLAN name TLV instances to be transmitted on individual ports.')
lldpXdot1ConfigVlanNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1LocConfigVlanNamePortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1ConfigVlanId"))
if mibBuilder.loadTexts: lldpXdot1ConfigVlanNameEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigVlanNameEntry.setDescription('LLDP configuration information that specifies the set of ports (represented as a PortList) on which the Local System VLAN name instance will be transmitted. Each active lldpXdot1ConfigVlanNameEntry must be restored from non-volatile storage (along with the corresponding lldpXdot1LocVlanNameEntry) after a re-initialization of the management system.')
lldpXdot1LocConfigVlanNamePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 2, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocConfigVlanNamePortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocConfigVlanNamePortNum.setDescription('The value of this object is used as a port index to the lldpXdot3LocPortTable.')
lldpXdot1ConfigVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 2, 1, 2), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1ConfigVlanId.setReference('IEEE 802.1AB-2005 F.4.2')
if mibBuilder.loadTexts: lldpXdot1ConfigVlanId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigVlanId.setDescription('The integer value used to identify the IEEE 802.1Q VLAN IDs with which the given port is compatible.')
lldpXdot1ConfigVlanNameTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 2, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot1ConfigVlanNameTxEnable.setReference('IEEE 802.1AB-2005 10.2.1.1')
if mibBuilder.loadTexts: lldpXdot1ConfigVlanNameTxEnable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigVlanNameTxEnable.setDescription('The boolean value that indicates whether the corresponding Local System VLAN name instance will be transmitted on the port defined by the given lldpXdot1LocVlanNameEntry. The value of this object must be restored from non-volatile storage after a re-initialization of the management system.')
lldpXdot1ConfigProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 4), )
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolTable.setDescription('The table that controls selection of LLDP Protocol TLV instances to be transmitted on individual ports.')
lldpXdot1ConfigProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1ConfigProtocolPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1ConfigProtocolIndex"))
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolEntry.setDescription('LLDP configuration information that specifies the set of ports (represented as a PortList) on which the Local System Protocol instance will be transmitted. Each active lldpXdot1ConfigProtocolEntry must be restored from non-volatile storage (along with the corresponding lldpXdot1LocProtocolEntry) after a re-initialization of the management system.')
lldpXdot1ConfigProtocolPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 4, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolPortNum.setDescription('The value of this object is used as a port index to the lldpXdot1ConfigProtocolTable.')
lldpXdot1ConfigProtocolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular protocol identity.')
lldpXdot1ConfigProtocolTxEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 1, 4, 1, 3), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolTxEnable.setReference('IEEE 802.1AB-2005 10.2.1.1')
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolTxEnable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1ConfigProtocolTxEnable.setDescription('The boolean value that indicates whether the corresponding Local System Protocol Identity instance will be transmitted on the port defined by the given lldpXdot1LocProtocolEntry. The value of this object must be restored from non-volatile storage after a re-initialization of the management system.')
lldpXdot1LocTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 1), )
if mibBuilder.loadTexts: lldpXdot1LocTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocTable.setDescription('This table contains one row per port for IEEE 802.1 organizationally defined LLDP extension on the local system known to this agent.')
lldpXdot1LocEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1LocPortNum"))
if mibBuilder.loadTexts: lldpXdot1LocEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocEntry.setDescription('Information about IEEE 802.1 organizationally defined LLDP extension.')
lldpXdot1LocPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 1, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocPortNum.setDescription('The value of this object is used as a port index to the lldpXdot1LocTable.')
lldpXdot1LocPortVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4094), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocPortVlanId.setReference('IEEE 802.1AB-2005 F.2.1')
if mibBuilder.loadTexts: lldpXdot1LocPortVlanId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocPortVlanId.setDescription("The integer value used to identify the port's VLAN identifier associated with the local system. A value of zero shall be used if the system either does not know the PVID or does not support port-based VLAN operation.")
lldpXdot1LocVlanNameTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 3), )
if mibBuilder.loadTexts: lldpXdot1LocVlanNameTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocVlanNameTable.setDescription('This table contains one or more rows per IEEE 802.1Q VLAN name information on the local system known to this agent.')
lldpXdot1LocVlanNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1LocVlanNamePortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1LocVlanId"))
if mibBuilder.loadTexts: lldpXdot1LocVlanNameEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocVlanNameEntry.setDescription('VLAN name Information about a particular port component. There may be multiple VLANs, identified by a particular lldpXdot1LocVlanId, configured on the given port.')
lldpXdot1LocVlanNamePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 3, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocVlanNamePortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocVlanNamePortNum.setDescription('The value of this object is used as a port index to the lldpXdot1LocVlanNameTable.')
lldpXdot1LocVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 3, 1, 2), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocVlanId.setReference('IEEE 802.1AB-2005 F.4.2')
if mibBuilder.loadTexts: lldpXdot1LocVlanId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocVlanId.setDescription('The integer value used to identify the IEEE 802.1Q VLAN IDs with which the given port is compatible.')
lldpXdot1LocVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 3, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocVlanName.setReference('IEEE 802.1AB-2005 F.4.4')
if mibBuilder.loadTexts: lldpXdot1LocVlanName.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocVlanName.setDescription('The string value used to identify VLAN name identified by the Vlan Id associated with the given port on the local system. This object should contain the value of the dot1QVLANStaticName object (defined in IETF RFC 2674) identified with the given lldpXdot1LocVlanId.')
lldpXdot1LocProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 4), )
if mibBuilder.loadTexts: lldpXdot1LocProtocolTable.setReference('IEEE 802.1AB-2005 F.5')
if mibBuilder.loadTexts: lldpXdot1LocProtocolTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocProtocolTable.setDescription('This table contains one or more rows per protocol identity information on the local system known to this agent.')
lldpXdot1LocProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1LocProtocolPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1LocProtocolIndex"))
if mibBuilder.loadTexts: lldpXdot1LocProtocolEntry.setReference('IEEE 802.1AB-2005 F.5')
if mibBuilder.loadTexts: lldpXdot1LocProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocProtocolEntry.setDescription('Information about particular protocols that are accessible through the given port component. There may be multiple protocols, identified by particular lldpXdot1ProtocolIndex, and lldpLocPortNum.')
lldpXdot1LocProtocolPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 4, 1, 1), LldpPortNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lldpXdot1LocProtocolPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocProtocolPortNum.setDescription('The value of this object is used as a port index to the lldpXdot1LocProtocolTable.')
lldpXdot1LocProtocolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocProtocolIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocProtocolIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular protocol identity.')
lldpXdot1LocProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 2, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1LocProtocolId.setReference('IEEE 802.1AB-2005 F.5.3')
if mibBuilder.loadTexts: lldpXdot1LocProtocolId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1LocProtocolId.setDescription('The octet string value used to identify the protocols associated with the given port of the local system.')
lldpXdot1RemTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 1), )
if mibBuilder.loadTexts: lldpXdot1RemTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemTable.setDescription('This table contains one or more rows per physical network connection known to this agent. The agent may wish to ensure that only one lldpXdot1RemEntry is present for each local port, or it may choose to maintain multiple lldpXdot1RemEntries for the same local port.')
lldpXdot1RemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1RemTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemIndex"))
if mibBuilder.loadTexts: lldpXdot1RemEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemEntry.setDescription('Information about a particular port component.')
lldpXdot1RemTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 1, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot1RemTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot1RemLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 1, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The ldpXdot1RemLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpRemTable.')
lldpXdot1RemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the ldpXdot1RemIndex will wrap between reboots.')
lldpXdot1RemPortVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4094), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemPortVlanId.setReference('IEEE 802.1AB-2005 F.2.1')
if mibBuilder.loadTexts: lldpXdot1RemPortVlanId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemPortVlanId.setDescription("The integer value used to identify the port's VLAN identifier associated with the remote system. if the remote system either does not know the PVID or does not support port-based VLAN operation, the value of lldpXdot1RemPortVlanId should be zero.")
lldpXdot1RemProtoVlanTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2), )
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanTable.setDescription('This table contains one or more rows per Port and Protocol VLAN information about the remote system, received on the given port.')
lldpXdot1RemProtoVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1RemProtoVlanTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemProtoVlanLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemProtoVlanIndex"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemProtoVlanId"))
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanEntry.setDescription('Port and protocol VLAN name Information about a particular port component. There may be multiple protocol VLANs, identified by a particular lldpXdot1RemProtoVlanId, configured on the remote system.')
lldpXdot1RemProtoVlanTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot1RemProtoVlanLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The ldpXdot1RemLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpRemTable.')
lldpXdot1RemProtoVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the ldpXdot1RemIndex will wrap between reboots.')
lldpXdot1RemProtoVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4094), )))
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanId.setReference('IEEE 802.1AB-2005 F.3.2')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanId.setDescription('The integer value used to identify the port and protocol VLANs associated with the given port associated with the remote system. If port and protocol VLANs are not supported on the given port associated with the remote system, or if the port is not enabled with any port and protocol VLAN, the value of lldpXdot1RemProtoVlanId should be zero.')
lldpXdot1RemProtoVlanSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanSupported.setReference('IEEE 802.1AB-2005 F.3.1')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanSupported.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanSupported.setDescription('The truth value used to indicate whether the given port (associated with the remote system) is capable of supporting port and protocol VLANs.')
lldpXdot1RemProtoVlanEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 2, 1, 6), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanEnabled.setReference('IEEE 802.1AB-2005 F.3.1')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtoVlanEnabled.setDescription('The truth value used to indicate whether the port and protocol VLANs are enabled on the given port associated with the remote system.')
lldpXdot1RemVlanNameTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 3), )
if mibBuilder.loadTexts: lldpXdot1RemVlanNameTable.setReference('IEEE 802.1AB-2005 F.4')
if mibBuilder.loadTexts: lldpXdot1RemVlanNameTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemVlanNameTable.setDescription('This table contains one or more rows per IEEE 802.1Q VLAN name information about the remote system, received on the given port.')
lldpXdot1RemVlanNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1RemVlanNameTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemVlanNameLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemVlanNameIndex"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemVlanId"))
if mibBuilder.loadTexts: lldpXdot1RemVlanNameEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemVlanNameEntry.setDescription('VLAN name Information about a particular port component. There may be multiple VLANs, identified by a particular lldpXdot1RemVlanId, received on the given port.')
lldpXdot1RemVlanNameTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 3, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemVlanNameTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot1RemVlanNameTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemVlanNameTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot1RemVlanNameLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 3, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemVlanNameLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemVlanNameLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The ldpXdot1RemVlanNameLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpRemTable.')
lldpXdot1RemVlanNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemVlanNameIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemVlanNameIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the ldpXdot1RemVlanNameIndex will wrap between reboots.')
lldpXdot1RemVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 3, 1, 4), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemVlanId.setReference('IEEE 802.1AB-2005 F.4.2')
if mibBuilder.loadTexts: lldpXdot1RemVlanId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemVlanId.setDescription('The integer value used to identify the IEEE 802.1Q VLAN IDs with which the given port of the remote system is compatible.')
lldpXdot1RemVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 3, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemVlanName.setReference('IEEE 802.1AB-2005 F.4.4')
if mibBuilder.loadTexts: lldpXdot1RemVlanName.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemVlanName.setDescription('The string value used to identify VLAN name identified by the VLAN Id associated with the remote system.')
lldpXdot1RemProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 4), )
if mibBuilder.loadTexts: lldpXdot1RemProtocolTable.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtocolTable.setDescription('This table contains one or more rows per protocol information about the remote system, received on the given port.')
lldpXdot1RemProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpXdot1RemProtocolTimeMark"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemProtocolLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemProtocolIndex"), (0, "DGS-1100-10ME_A1", "lldpXdot1RemProtocolIdIndex"))
if mibBuilder.loadTexts: lldpXdot1RemProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtocolEntry.setDescription('Protocol information about a particular port component. There may be multiple protocols, identified by a particular lldpXdot1ProtocolIndex, received on the given port.')
lldpXdot1RemProtocolTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 4, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtocolTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpXdot1RemProtocolTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtocolTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpXdot1RemProtocolLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 4, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtocolLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtocolLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The ldpXdot1RemProtocolLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpRemTable.')
lldpXdot1RemProtocolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtocolIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtocolIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the ldpXdot1RemProtocolIndex will wrap between reboots.')
lldpXdot1RemProtocolIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtocolIdIndex.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtocolIdIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular protocol identity.')
lldpXdot1RemProtocolId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 13, 3, 4, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpXdot1RemProtocolId.setReference('IEEE 802.1AB-2005 F.5.3')
if mibBuilder.loadTexts: lldpXdot1RemProtocolId.setStatus('current')
if mibBuilder.loadTexts: lldpXdot1RemProtocolId.setDescription('The octet string value used to identify the protocols associated with the given port of remote system.')
lldpStatsRemTablesLastChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRemTablesLastChangeTime.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRemTablesLastChangeTime.setDescription('The value of sysUpTime object (defined in IETF RFC 3418) at the time an entry is created, modified, or deleted in the in tables associated with the sysLLDPRemoteSystemsData objects and all LLDP extension objects associated with remote systems. An NMS can use this object to reduce polling of the sysLLDPRemoteSystemsData objects.')
lldpStatsRemTablesInserts = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 2), ZeroBasedCounter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRemTablesInserts.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRemTablesInserts.setDescription('The number of times the complete set of information advertised by a particular MSAP has been inserted into tables contained in sysLLDPRemoteSystemsData and lldpExtensions objects. The complete set of information received from a particular MSAP should be inserted into related tables. If partial information cannot be inserted for a reason such as lack of resources, all of the complete set of information should be removed. This counter should be incremented only once after the complete set of information is successfully recorded in all related tables. Any failures during inserting information set which result in deletion of previously inserted information should not trigger any changes in lldpStatsRemTablesInserts since the insert is not completed yet or or in lldpStatsRemTablesDeletes, since the deletion would only be a partial deletion. If the failure was the result of lack of resources, the lldpStatsRemTablesDrops counter should be incremented once.')
lldpStatsRemTablesDeletes = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 3), ZeroBasedCounter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRemTablesDeletes.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRemTablesDeletes.setDescription('The number of times the complete set of information advertised by a particular MSAP has been deleted from tables contained in sysLLDPRemoteSystemsData and lldpExtensions objects. This counter should be incremented only once when the complete set of information is completely deleted from all related tables. Partial deletions, such as deletion of rows associated with a particular MSAP from some tables, but not from all tables are not allowed, thus should not change the value of this counter.')
lldpStatsRemTablesDrops = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 4), ZeroBasedCounter32()).setUnits('table entries').setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRemTablesDrops.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRemTablesDrops.setDescription('The number of times the complete set of information advertised by a particular MSAP could not be entered into tables contained in sysLLDPRemoteSystemsData and lldpExtensions objects because of insufficient resources.')
lldpStatsRemTablesAgeouts = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRemTablesAgeouts.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRemTablesAgeouts.setDescription('The number of times the complete set of information advertised by a particular MSAP has been deleted from tables contained in sysLLDPRemoteSystemsData and lldpExtensions objects because the information timeliness interval has expired. This counter should be incremented only once when the complete set of information is completely invalidated (aged out) from all related tables. Partial aging, similar to deletion case, is not allowed, and thus, should not change the value of this counter.')
lldpStatsTxPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 6), )
if mibBuilder.loadTexts: lldpStatsTxPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTxPortTable.setDescription("A table containing LLDP transmission statistics for individual ports. Entries are not required to exist in this table while the sysLLDPPortConfigEntry object is equal to 'disabled(4)'.")
lldpStatsTxPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 6, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpStatsTxPortNum"))
if mibBuilder.loadTexts: lldpStatsTxPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTxPortEntry.setDescription('LLDP frame transmission statistics for a particular port. The port must be contained in the same chassis as the LLDP agent. All counter values in a particular entry shall be maintained on a continuing basis and shall not be deleted upon expiration of rxInfoTTL timing counters in the LLDP remote systems MIB of the receipt of a shutdown frame from a remote LLDP agent. All statistical counters associated with a particular port on the local LLDP agent become frozen whenever the adminStatus is disabled for the same port.')
lldpStatsTxPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 6, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsTxPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTxPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The value of this object is used as a port index to the lldpStatsTable.')
lldpStatsTxPortFramesTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsTxPortFramesTotal.setReference('IEEE 802.1AB-2005 10.5.2.1')
if mibBuilder.loadTexts: lldpStatsTxPortFramesTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsTxPortFramesTotal.setDescription('The number of LLDP frames transmitted by this LLDP agent on the indicated port.')
lldpRxStatsPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7), )
if mibBuilder.loadTexts: lldpRxStatsPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpRxStatsPortTable.setDescription("A table containing LLDP reception statistics for individual ports. Entries are not required to exist in this table while the sysLLDPPortConfigEntry object is equal to 'disabled(4)'.")
lldpRxStatsPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpStatsRxPortNum"))
if mibBuilder.loadTexts: lldpRxStatsPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpRxStatsPortEntry.setDescription('LLDP frame reception statistics for a particular port. The port must be contained in the same chassis as the LLDP agent. All counter values in a particular entry shall be maintained on a continuing basis and shall not be deleted upon expiration of rxInfoTTL timing counters in the LLDP remote systems MIB of the receipt of a shutdown frame from a remote LLDP agent. All statistical counters associated with a particular port on the local LLDP agent become frozen whenever the adminStatus is disabled for the same port.')
lldpStatsRxPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRxPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRxPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The value of this object is used as a port index to the lldpStatsTable.')
lldpStatsRxPortFramesDiscardedTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRxPortFramesDiscardedTotal.setReference('IEEE 802.1AB-2005 10.5.2.2')
if mibBuilder.loadTexts: lldpStatsRxPortFramesDiscardedTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRxPortFramesDiscardedTotal.setDescription('The number of LLDP frames received by this LLDP agent on the indicated port, and then discarded for any reason. This counter can provide an indication that LLDP header formating problems may exist with the local LLDP agent in the sending system or that LLDPDU validation problems may exist with the local LLDP agent in the receiving system.')
lldpStatsRxPortFramesErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRxPortFramesErrors.setReference('IEEE 802.1AB-2005 10.5.2.2')
if mibBuilder.loadTexts: lldpStatsRxPortFramesErrors.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRxPortFramesErrors.setDescription('The number of invalid LLDP frames received by this LLDP agent on the indicated port, while this LLDP agent is enabled.')
lldpStatsRxPortFramesTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRxPortFramesTotal.setReference('IEEE 802.1AB-2005 10.5.2.2')
if mibBuilder.loadTexts: lldpStatsRxPortFramesTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRxPortFramesTotal.setDescription('The number of valid LLDP frames received by this LLDP agent on the indicated port, while this LLDP agent is enabled.')
lldpStatsRxPortTLVsDiscardedTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRxPortTLVsDiscardedTotal.setReference('IEEE 802.1AB-2005 10.5.2.2')
if mibBuilder.loadTexts: lldpStatsRxPortTLVsDiscardedTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRxPortTLVsDiscardedTotal.setDescription('The number of LLDP TLVs discarded for any reason by this LLDP agent on the indicated port.')
lldpStatsRxPortTLVsUnrecognizedTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRxPortTLVsUnrecognizedTotal.setReference('IEEE 802.1AB-2005 10.5.2.2')
if mibBuilder.loadTexts: lldpStatsRxPortTLVsUnrecognizedTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRxPortTLVsUnrecognizedTotal.setDescription('The number of LLDP TLVs received on the given port that are not recognized by this LLDP agent on the indicated port. An unrecognized TLV is referred to as the TLV whose type value is in the range of reserved TLV types (000 1001 - 111 1110) in Table 9.1 of IEEE Std 802.1AB-2005. An unrecognized TLV may be a basic management TLV from a later LLDP version.')
lldpStatsRxPortAgeoutsTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 14, 7, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpStatsRxPortAgeoutsTotal.setReference('IEEE 802.1AB-2005 10.5.2.2')
if mibBuilder.loadTexts: lldpStatsRxPortAgeoutsTotal.setStatus('current')
if mibBuilder.loadTexts: lldpStatsRxPortAgeoutsTotal.setDescription("The counter that represents the number of age-outs that occurred on a given port. An age-out is the number of times the complete set of information advertised by a particular MSAP has been deleted from tables contained in sysLLDPRemoteSystemsData and lldpExtensions objects because the information timeliness interval has expired. This counter is similar to lldpStatsRemTablesAgeouts, except that the counter is on a per port basis. This enables NMS to poll tables associated with the sysLLDPRemoteSystemsData objects and all LLDP extension objects associated with remote systems on the indicated port only. This counter should be set to zero during agent initialization and its value should not be saved in non-volatile storage. When a port's admin status changes from 'disabled' to 'rxOnly', 'txOnly' or 'txAndRx', the counter associated with the same port should reset to 0. The agent should also flush all remote system information associated with the same port. This counter should be incremented only once when the complete set of information is invalidated (aged out) from all related tables on a particular port. Partial aging is not allowed, and thus, should not change the value of this counter.")
lldpLocChassisIdSubtype = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 1), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocChassisIdSubtype.setReference('IEEE 802.1AB-2005 9.5.2.2')
if mibBuilder.loadTexts: lldpLocChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpLocChassisIdSubtype.setDescription('The type of encoding used to identify the chassis associated with the local system.')
lldpLocChassisId = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 2), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocChassisId.setReference('IEEE 802.1AB-2005 9.5.2.3')
if mibBuilder.loadTexts: lldpLocChassisId.setStatus('current')
if mibBuilder.loadTexts: lldpLocChassisId.setDescription('The string value used to identify the chassis component associated with the local system.')
lldpLocSysName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocSysName.setReference('IEEE 802.1AB-2005 9.5.6.2')
if mibBuilder.loadTexts: lldpLocSysName.setStatus('current')
if mibBuilder.loadTexts: lldpLocSysName.setDescription('The string value used to identify the system name of the local system. If the local agent supports IETF RFC 3418, lldpLocSysName object should have the same value of sysName object.')
lldpLocSysDesc = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocSysDesc.setReference('IEEE 802.1AB-2005 9.5.7.2')
if mibBuilder.loadTexts: lldpLocSysDesc.setStatus('current')
if mibBuilder.loadTexts: lldpLocSysDesc.setDescription('The string value used to identify the system description of the local system. If the local agent supports IETF RFC 3418, lldpLocSysDesc object should have the same value of sysDesc object.')
lldpLocSysCapEnabled = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 5), LldpSystemCapabilitiesMap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocSysCapEnabled.setReference('IEEE 802.1AB-2005 9.5.7.2')
if mibBuilder.loadTexts: lldpLocSysCapEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpLocSysCapEnabled.setDescription('The bitmap value used to identify which system capabilities are enabled on the local system.')
lldpLocPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 7), )
if mibBuilder.loadTexts: lldpLocPortTable.setStatus('current')
if mibBuilder.loadTexts: lldpLocPortTable.setDescription('This table contains one or more rows per port information associated with the local system known to this agent.')
lldpLocPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 7, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpLocPortNum"))
if mibBuilder.loadTexts: lldpLocPortEntry.setStatus('current')
if mibBuilder.loadTexts: lldpLocPortEntry.setDescription('Information about a particular port component. Entries may be created and deleted in this table by the agent.')
lldpLocPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 7, 1, 1), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpLocPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The value of this object is used as a port index to the lldpLocPortTable.')
lldpLocPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 7, 1, 2), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocPortIdSubtype.setReference('IEEE 802.1AB-2005 9.5.3.2')
if mibBuilder.loadTexts: lldpLocPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpLocPortIdSubtype.setDescription("The type of port identifier encoding used in the associated 'lldpLocPortId' object.")
lldpLocPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 7, 1, 3), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocPortId.setReference('IEEE 802.1AB-2005 9.5.3.3')
if mibBuilder.loadTexts: lldpLocPortId.setStatus('current')
if mibBuilder.loadTexts: lldpLocPortId.setDescription('The string value used to identify the port component associated with a given port in the local system.')
lldpLocPortDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 7, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocPortDesc.setReference('IEEE 802.1AB-2005 9.5.5.2')
if mibBuilder.loadTexts: lldpLocPortDesc.setStatus('current')
if mibBuilder.loadTexts: lldpLocPortDesc.setDescription("The string value used to identify the 802 LAN station's port description associated with the local system. If the local agent supports IETF RFC 2863, lldpLocPortDesc object should have the same value of ifDescr object.")
lldpLocManAddrTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8), )
if mibBuilder.loadTexts: lldpLocManAddrTable.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddrTable.setDescription('This table contains management address information on the local system known to this agent.')
lldpLocManAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpLocManAddrSubtype"), (0, "DGS-1100-10ME_A1", "lldpLocManAddr"))
if mibBuilder.loadTexts: lldpLocManAddrEntry.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddrEntry.setDescription("Management address information about a particular chassis component. There may be multiple management addresses configured on the system identified by a particular lldpLocChassisId. Each management address should have distinct 'management address type' (lldpLocManAddrSubtype) and 'management address' (lldpLocManAddr.) Entries may be created and deleted in this table by the agent.")
lldpLocManAddrSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8, 1, 1), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocManAddrSubtype.setReference('IEEE 802.1AB-2005 9.5.9.3')
if mibBuilder.loadTexts: lldpLocManAddrSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddrSubtype.setDescription("The type of management address identifier encoding used in the associated 'lldpLocManagmentAddr' object.")
lldpLocManAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8, 1, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocManAddr.setReference('IEEE 802.1AB-2005 9.5.9.4')
if mibBuilder.loadTexts: lldpLocManAddr.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddr.setDescription('The string value used to identify the management address component associated with the local system. The purpose of this address is to contact the management entity.')
lldpLocManAddrLen = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocManAddrLen.setReference('IEEE 802.1AB-2005 9.5.9.2')
if mibBuilder.loadTexts: lldpLocManAddrLen.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddrLen.setDescription('The total length of the management address subtype and the management address fields in LLDPDUs transmitted by the local LLDP agent. The management address length field is needed so that the receiving systems that do not implement SNMP will not be required to implement an iana family numbers/address length equivalency table in order to decode the management adress.')
lldpLocManAddrIfSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8, 1, 4), LldpManAddrIfSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocManAddrIfSubtype.setReference('IEEE 802.1AB-2005 9.5.9.5')
if mibBuilder.loadTexts: lldpLocManAddrIfSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddrIfSubtype.setDescription('The enumeration value that identifies the interface numbering method used for defining the interface number, associated with the local system.')
lldpLocManAddrIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocManAddrIfId.setReference('IEEE 802.1AB-2005 9.5.9.6')
if mibBuilder.loadTexts: lldpLocManAddrIfId.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddrIfId.setDescription('The integer value used to identify the interface number regarding the management address component associated with the local system.')
lldpLocManAddrOID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 15, 8, 1, 6), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpLocManAddrOID.setReference('IEEE 802.1AB-2005 9.5.9.8')
if mibBuilder.loadTexts: lldpLocManAddrOID.setStatus('current')
if mibBuilder.loadTexts: lldpLocManAddrOID.setDescription('The OID value used to identify the type of hardware component or protocol entity associated with the management address advertised by the local system agent.')
lldpRemTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1), )
if mibBuilder.loadTexts: lldpRemTable.setStatus('current')
if mibBuilder.loadTexts: lldpRemTable.setDescription('This table contains one or more rows per physical network connection known to this agent. The agent may wish to ensure that only one lldpRemEntry is present for each local port, or it may choose to maintain multiple lldpRemEntries for the same local port. The following procedure may be used to retrieve remote systems information updates from an LLDP agent: 1. NMS polls all tables associated with remote systems and keeps a local copy of the information retrieved. NMS polls periodically the values of the following objects: a. lldpStatsRemTablesInserts b. lldpStatsRemTablesDeletes c. lldpStatsRemTablesDrops d. lldpStatsRemTablesAgeouts e. lldpStatsRxPortAgeoutsTotal for all ports. 2. LLDP agent updates remote systems MIB objects, and sends out notifications to a list of notification destinations. 3. NMS receives the notifications and compares the new values of objects listed in step 1. Periodically, NMS should poll the object lldpStatsRemTablesLastChangeTime to find out if anything has changed since the last poll. if something has changed, NMS will poll the objects listed in step 1 to figure out what kind of changes occurred in the tables. if value of lldpStatsRemTablesInserts has changed, then NMS will walk all tables by employing TimeFilter with the last-polled time value. This request will return new objects or objects whose values are updated since the last poll. if value of lldpStatsRemTablesAgeouts has changed, then NMS will walk the lldpStatsRxPortAgeoutsTotal and compare the new values with previously recorded ones. For ports whose lldpStatsRxPortAgeoutsTotal value is greater than the recorded value, NMS will have to retrieve objects associated with those ports from table(s) without employing a TimeFilter (which is performed by specifying 0 for the TimeFilter.) lldpStatsRemTablesDeletes and lldpStatsRemTablesDrops objects are provided for informational purposes.')
lldpRemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpRemTimeMark"), (0, "DGS-1100-10ME_A1", "lldpRemLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpRemIndex"))
if mibBuilder.loadTexts: lldpRemEntry.setStatus('current')
if mibBuilder.loadTexts: lldpRemEntry.setDescription('Information about a particular physical network connection. Entries may be created and deleted in this table by the agent, if a physical topology discovery process is active.')
lldpRemTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpRemTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpRemTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpRemLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpRemLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The lldpRemLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpRemTable.')
lldpRemIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemIndex.setStatus('current')
if mibBuilder.loadTexts: lldpRemIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the lldpRemIndex will wrap between reboots.')
lldpRemChassisIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 4), LldpChassisIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemChassisIdSubtype.setReference('IEEE 802.1AB-2005 9.5.2.2')
if mibBuilder.loadTexts: lldpRemChassisIdSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpRemChassisIdSubtype.setDescription('The type of encoding used to identify the chassis associated with the remote system.')
lldpRemChassisId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 5), LldpChassisId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemChassisId.setReference('IEEE 802.1AB-2005 9.5.2.3')
if mibBuilder.loadTexts: lldpRemChassisId.setStatus('current')
if mibBuilder.loadTexts: lldpRemChassisId.setDescription('The string value used to identify the chassis component associated with the remote system.')
lldpRemPortIdSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 6), LldpPortIdSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemPortIdSubtype.setReference('IEEE 802.1AB-2005 9.5.3.2')
if mibBuilder.loadTexts: lldpRemPortIdSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpRemPortIdSubtype.setDescription("The type of port identifier encoding used in the associated 'lldpRemPortId' object.")
lldpRemPortId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 7), LldpPortId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemPortId.setReference('IEEE 802.1AB-2005 9.5.3.3')
if mibBuilder.loadTexts: lldpRemPortId.setStatus('current')
if mibBuilder.loadTexts: lldpRemPortId.setDescription('The string value used to identify the port component associated with the remote system.')
lldpRemPortDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemPortDesc.setReference('IEEE 802.1AB-2005 9.5.5.2')
if mibBuilder.loadTexts: lldpRemPortDesc.setStatus('current')
if mibBuilder.loadTexts: lldpRemPortDesc.setDescription('The string value used to identify the description of the given port associated with the remote system.')
lldpRemSysName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemSysName.setReference('IEEE 802.1AB-2005 9.5.6.2')
if mibBuilder.loadTexts: lldpRemSysName.setStatus('current')
if mibBuilder.loadTexts: lldpRemSysName.setDescription('The string value used to identify the system name of the remote system.')
lldpRemSysDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemSysDesc.setReference('IEEE 802.1AB-2005 9.5.7.2')
if mibBuilder.loadTexts: lldpRemSysDesc.setStatus('current')
if mibBuilder.loadTexts: lldpRemSysDesc.setDescription('The string value used to identify the system description of the remote system.')
lldpRemSysCapSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 11), LldpSystemCapabilitiesMap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemSysCapSupported.setReference('IEEE 802.1AB-2005 9.5.8.1')
if mibBuilder.loadTexts: lldpRemSysCapSupported.setStatus('current')
if mibBuilder.loadTexts: lldpRemSysCapSupported.setDescription('The bitmap value used to identify which system capabilities are supported on the remote system.')
lldpRemSysCapEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 1, 1, 12), LldpSystemCapabilitiesMap()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemSysCapEnabled.setReference('IEEE 802.1AB-2005 9.5.8.2')
if mibBuilder.loadTexts: lldpRemSysCapEnabled.setStatus('current')
if mibBuilder.loadTexts: lldpRemSysCapEnabled.setDescription('The bitmap value used to identify which system capabilities are enabled on the remote system.')
lldpRemManAddrTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2), )
if mibBuilder.loadTexts: lldpRemManAddrTable.setStatus('current')
if mibBuilder.loadTexts: lldpRemManAddrTable.setDescription('This table contains one or more rows per management address information on the remote system learned on a particular port contained in the local chassis known to this agent.')
lldpRemManAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpRemManTimeMark"), (0, "DGS-1100-10ME_A1", "lldpRemManLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpRemManIndex"), (0, "DGS-1100-10ME_A1", "lldpRemManAddrSubtype"), (0, "DGS-1100-10ME_A1", "lldpRemManAddr"))
if mibBuilder.loadTexts: lldpRemManAddrEntry.setStatus('current')
if mibBuilder.loadTexts: lldpRemManAddrEntry.setDescription("Management address information about a particular chassis component. There may be multiple management addresses configured on the remote system identified by a particular lldpRemIndex whose information is received on lldpRemManLocalPortNum of the local system. Each management address should have distinct 'management address type' (lldpRemManAddrSubtype) and 'management address' (lldpRemManAddr.) Entries may be created and deleted in this table by the agent.")
lldpRemManTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpRemManTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpRemManTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpRemManLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpRemManLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The lldpRemManLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpRemTable.')
lldpRemManIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManIndex.setStatus('current')
if mibBuilder.loadTexts: lldpRemManIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the lldpRemManIndex will wrap between reboots.')
lldpRemManAddrSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 4), AddressFamilyNumbers()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManAddrSubtype.setReference('IEEE 802.1AB-2005 9.5.9.3')
if mibBuilder.loadTexts: lldpRemManAddrSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpRemManAddrSubtype.setDescription("The type of management address identifier encoding used in the associated 'lldpRemManagmentAddr' object.")
lldpRemManAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManAddr.setReference('IEEE 802.1AB-2005 9.5.9.4')
if mibBuilder.loadTexts: lldpRemManAddr.setStatus('current')
if mibBuilder.loadTexts: lldpRemManAddr.setDescription('The string value used to identify the management address component associated with the remote system. The purpose of this address is to contact the management entity.')
lldpRemManAddrIfSubtype = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 6), LldpManAddrIfSubtype()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManAddrIfSubtype.setReference('IEEE 802.1AB-2005 9.5.9.5')
if mibBuilder.loadTexts: lldpRemManAddrIfSubtype.setStatus('current')
if mibBuilder.loadTexts: lldpRemManAddrIfSubtype.setDescription('The enumeration value that identifies the interface numbering method used for defining the interface number, associated with the remote system.')
lldpRemManAddrIfId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManAddrIfId.setReference('IEEE 802.1AB-2005 9.5.9.6')
if mibBuilder.loadTexts: lldpRemManAddrIfId.setStatus('current')
if mibBuilder.loadTexts: lldpRemManAddrIfId.setDescription('The integer value used to identify the interface number regarding the management address component associated with the remote system.')
lldpRemManAddrOID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 2, 1, 8), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemManAddrOID.setReference('IEEE 802.1AB-2005 9.5.9.8')
if mibBuilder.loadTexts: lldpRemManAddrOID.setStatus('current')
if mibBuilder.loadTexts: lldpRemManAddrOID.setDescription('The OID value used to identify the type of hardware component or protocol entity associated with the management address advertised by the remote system agent.')
lldpRemUnknownTLVTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 3), )
if mibBuilder.loadTexts: lldpRemUnknownTLVTable.setReference('IEEE 802.1AB-2005 10.3.2')
if mibBuilder.loadTexts: lldpRemUnknownTLVTable.setStatus('current')
if mibBuilder.loadTexts: lldpRemUnknownTLVTable.setDescription('This table contains information about an incoming TLV which is not recognized by the receiving LLDP agent. The TLV may be from a later version of the basic management set. This table should only contain TLVs that are found in a single LLDP frame. Entries in this table, associated with an MAC service access point (MSAP, the access point for MAC services provided to the LCC sublayer, defined in IEEE 100, which is also identified with a particular lldpRemLocalPortNum, lldpRemIndex pair) are overwritten with most recently received unrecognized TLV from the same MSAP, or they will naturally age out when the rxInfoTTL timer (associated with the MSAP) expires.')
lldpRemUnknownTLVEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "lldpRemUnknownTimeMark"), (0, "DGS-1100-10ME_A1", "lldpRemUnknownLocalPortNum"), (0, "DGS-1100-10ME_A1", "lldpRemUnknownIndex"), (0, "DGS-1100-10ME_A1", "lldpRemUnknownTLVType"))
if mibBuilder.loadTexts: lldpRemUnknownTLVEntry.setStatus('current')
if mibBuilder.loadTexts: lldpRemUnknownTLVEntry.setDescription('Information about an unrecognized TLV received from a physical network connection. Entries may be created and deleted in this table by the agent, if a physical topology discovery process is active.')
lldpRemUnknownTimeMark = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 3, 1, 1), TimeFilter()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemUnknownTimeMark.setReference('IETF RFC 2021 section 6')
if mibBuilder.loadTexts: lldpRemUnknownTimeMark.setStatus('current')
if mibBuilder.loadTexts: lldpRemUnknownTimeMark.setDescription('A TimeFilter for this entry. See the TimeFilter textual convention in IETF RFC 2021 and http://www.ietf.org/IESG/Implementations/RFC2021-Implementation.txt to see how TimeFilter works.')
lldpRemUnknownLocalPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 3, 1, 2), LldpPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemUnknownLocalPortNum.setStatus('current')
if mibBuilder.loadTexts: lldpRemUnknownLocalPortNum.setDescription('The index value used to identify the port component (contained in the local chassis with the LLDP agent) associated with this entry. The lldpRemUnknownLocalPortNum identifies the port on which the remote system information is received. The value of this object is used as a port index to the lldpRemTable.')
lldpRemUnknownIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemUnknownIndex.setStatus('current')
if mibBuilder.loadTexts: lldpRemUnknownIndex.setDescription('This object represents an arbitrary local integer value used by this agent to identify a particular connection instance, unique only for the indicated remote system. An agent is encouraged to assign monotonically increasing index values to new entries, starting with one, after each reboot. It is considered unlikely that the lldpRemUnknownIndex will wrap between reboots.')
lldpRemUnknownTLVType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(9, 126))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemUnknownTLVType.setReference('IEEE 802.1AB-2005 10.3.5')
if mibBuilder.loadTexts: lldpRemUnknownTLVType.setStatus('current')
if mibBuilder.loadTexts: lldpRemUnknownTLVType.setDescription('This object represents the value extracted from the type field of the TLV.')
lldpRemUnknownTLVInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 16, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lldpRemUnknownTLVInfo.setReference('IEEE 802.1AB-2005 10.3.5')
if mibBuilder.loadTexts: lldpRemUnknownTLVInfo.setStatus('current')
if mibBuilder.loadTexts: lldpRemUnknownTLVInfo.setDescription('This object represents the value extracted from the value field of the TLV.')
lldpTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0))
lldpRemTablesChange = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 1)).setObjects(("DGS-1100-10ME_A1", "lldpStatsRemTablesInserts"), ("DGS-1100-10ME_A1", "lldpStatsRemTablesDeletes"), ("DGS-1100-10ME_A1", "lldpStatsRemTablesDrops"), ("DGS-1100-10ME_A1", "lldpStatsRemTablesAgeouts"))
if mibBuilder.loadTexts: lldpRemTablesChange.setStatus('current')
if mibBuilder.loadTexts: lldpRemTablesChange.setDescription("A lldpRemTablesChange notification is sent when the value of lldpStatsRemTableLastChangeTime changes. It can be utilized by an NMS to trigger LLDP remote systems table maintenance polls. Note that transmission of lldpRemTablesChange notifications are throttled by the agent, as specified by the 'lldpNotificationInterval' object. The first four objects are already mentioned in the standard LLDP mib. As the Table Updation notification is also sent in the same notification PDU these objects are moved to proprietary mib.")
lldpExceedsMaxFrameSize = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 2)).setObjects(("DGS-1100-10ME_A1", "lldpLocPortId"))
if mibBuilder.loadTexts: lldpExceedsMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: lldpExceedsMaxFrameSize.setDescription('A lldpExceedsMaxFrameSize notification is sent if the size of LLDP frame to be transmitted exceeds the maximum frame size (1522 bytes). This can occur if many number of TLVs need to be included in a single frame . It notifies the NMS that the information obtained about this system from its neighbor is not complete.')
lldpDupChasisId = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 3)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"))
if mibBuilder.loadTexts: lldpDupChasisId.setStatus('current')
if mibBuilder.loadTexts: lldpDupChasisId.setDescription('A lldpDupChasisId notification sent if the configured chasisId and Received chasisId from the neighbor is same. It notifies the NMS that the information obtained from its neighbor is Duplicate.')
lldpDupSystemName = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 4)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"), ("DGS-1100-10ME_A1", "lldpRemSysName"))
if mibBuilder.loadTexts: lldpDupSystemName.setStatus('current')
if mibBuilder.loadTexts: lldpDupSystemName.setDescription('A lldpDupSystemName notification sent if the configured system name and Received system name from the neighbor is same. It notifies the NMS that the information obtained from its neighbor is Duplicate.')
lldpDupManagmentAddress = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 5)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"), ("DGS-1100-10ME_A1", "lldpRemManAddrIfId"))
if mibBuilder.loadTexts: lldpDupManagmentAddress.setStatus('current')
if mibBuilder.loadTexts: lldpDupManagmentAddress.setDescription('A fsLldpDupManagementAddress notification sent if the configured management address and Received management address from the neighbor is same. The received duplicate management address is sent with the OID as index. Hence lldpRemManAddrIfId is sent in the value field. It notifies the NMS that the information obtained from its neighbor is Duplicate.')
lldpMisConfigPortVlanID = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 6)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"), ("DGS-1100-10ME_A1", "lldpXdot1RemPortVlanId"))
if mibBuilder.loadTexts: lldpMisConfigPortVlanID.setStatus('current')
if mibBuilder.loadTexts: lldpMisConfigPortVlanID.setDescription('A lldpMisConfigPortVlanID notification sent if the Port VlanId of two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
lldpMisConfigVlanName = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 8)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"), ("DGS-1100-10ME_A1", "lldpXdot1RemVlanName"))
if mibBuilder.loadTexts: lldpMisConfigVlanName.setStatus('current')
if mibBuilder.loadTexts: lldpMisConfigVlanName.setDescription('A lldpMisConfigVlanName notification sent if the vlan name of two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
lldpMisConfigProtocolIdentity = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 9)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"), ("DGS-1100-10ME_A1", "lldpXdot1RemProtocolId"))
if mibBuilder.loadTexts: lldpMisConfigProtocolIdentity.setStatus('current')
if mibBuilder.loadTexts: lldpMisConfigProtocolIdentity.setDescription('A lldpMisConfigProtocolIdentity notification sent if the protocol identity information (example spanning Tree protocol, the Link Aggregation protocol and proprietary protocol) of two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
lldpMisConfigMaxFrameSize = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 12)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"), ("DGS-1100-10ME_A1", "lldpXdot3RemMaxFrameSize"))
if mibBuilder.loadTexts: lldpMisConfigMaxFrameSize.setStatus('current')
if mibBuilder.loadTexts: lldpMisConfigMaxFrameSize.setDescription('A lldpMisConfigMaxFrameSize notification sent if the maximum frame size configuration of two systems connected to the same link is different. Difference in maximum frame size can result in loss of frames if the sending station advertised maximum frame size is larger than the receiveing station. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
lldpMisConfigOperMauType = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 32, 17, 0, 13)).setObjects(("DGS-1100-10ME_A1", "lldpRemChassisId"), ("DGS-1100-10ME_A1", "lldpRemPortId"), ("DGS-1100-10ME_A1", "lldpXdot3RemPortOperMauType"))
if mibBuilder.loadTexts: lldpMisConfigOperMauType.setStatus('current')
if mibBuilder.loadTexts: lldpMisConfigOperMauType.setDescription('A lldpMisConfigOperMauType notification sent if the Operational MauType of the two systems connected to the same link is different. It notifies the NMS that the information obtained from its neighbor is mis-configured.')
sysQinQSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1))
qinQGlobalStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQGlobalStatus.setStatus('current')
if mibBuilder.loadTexts: qinQGlobalStatus.setDescription('This object is used to enable/disable the Q-in-Q status.')
qinQInnerTPID = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQInnerTPID.setStatus('current')
if mibBuilder.loadTexts: qinQInnerTPID.setDescription('Sets the QinQ Inner TPID value per system')
qinQConfigTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 2), )
if mibBuilder.loadTexts: qinQConfigTable.setStatus('current')
if mibBuilder.loadTexts: qinQConfigTable.setDescription('A table that contains Q-in-Q VLAN mode information about each port.')
qinQConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "qinQIfIndex"))
if mibBuilder.loadTexts: qinQConfigEntry.setStatus('current')
if mibBuilder.loadTexts: qinQConfigEntry.setDescription('A list of Q-in-Q VLAN mode information for each port.')
qinQIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qinQIfIndex.setStatus('current')
if mibBuilder.loadTexts: qinQIfIndex.setDescription('The index of the port. ')
qinQRoleState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nni", 1), ("uni", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQRoleState.setStatus('current')
if mibBuilder.loadTexts: qinQRoleState.setDescription('Sets the QinQ Role as NNI or UNI.')
qinQOuterTPID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 2, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQOuterTPID.setStatus('current')
if mibBuilder.loadTexts: qinQOuterTPID.setDescription('Sets the QinQ Outer TPID value.')
qinQMissDrop = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQMissDrop.setStatus('current')
if mibBuilder.loadTexts: qinQMissDrop.setDescription('This object indicates if drop pkts that do not match selective QinQ rule')
qinQAddInnerTag = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQAddInnerTag.setStatus('current')
if mibBuilder.loadTexts: qinQAddInnerTag.setDescription('innter tag for C-VLAN untag pkts')
qinQVlanTranslationTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4), )
if mibBuilder.loadTexts: qinQVlanTranslationTable.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTranslationTable.setDescription('A table that contains Q-in-Q VLAN translation config.')
qinQVlanTranslationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "qinQVlanTransPortNum"), (0, "DGS-1100-10ME_A1", "qinQVlanTransCVID"))
if mibBuilder.loadTexts: qinQVlanTranslationEntry.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTranslationEntry.setDescription('A list of Q-in-Q VLAN translation config .')
qinQVlanTransPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qinQVlanTransPortNum.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTransPortNum.setDescription('The Index value of the port in the system for which this entry applies. The maximum index value of the port is defined by the system.')
qinQVlanTransCVID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qinQVlanTransCVID.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTransCVID.setDescription('The customer VLAN ID in the customer VLAN tag of an ingress frame at this specified port or the customer VLAN ID to which the ingress frame is classified to, at this specified port.')
qinQVlanTransSVID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQVlanTransSVID.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTransSVID.setDescription('S-VLAN Id for the service instance to which this port and this C-VLAN are mapped to. ie) CEP,C-VID ===> S-VID.')
qinQVlanTransAction = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("add", 1), ("replace", 2))).clone('add')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQVlanTransAction.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTransAction.setDescription('This object indicates add outer tag or replace inner tag by outer tag .')
qinQVlanTransPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qinQVlanTransPriority.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTransPriority.setDescription('The priority for rule matched outer tag. -1 means use inner priority. ')
qinQVlanTransRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 37, 1, 4, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: qinQVlanTransRowStatus.setStatus('current')
if mibBuilder.loadTexts: qinQVlanTransRowStatus.setDescription("This object indicates the status of this entry. An entry is created in this table when this object is SET to 'createAndWait'. The entry in this table is used when the status of this object is SET 'active'. The entry in this table is not used when this object is SET 'notInService'. An entry created in this table is deleted when this object is SET 'destroy'.")
sysTftpFwTargetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1))
tftpFwTargetServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1, 1), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFwTargetServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: tftpFwTargetServerIpAddress.setDescription("The TFTP server's IP address is used to upload or download firmware.")
tftpFwTargetServerIpType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("iPv4", 1), ("iPv6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFwTargetServerIpType.setStatus('current')
if mibBuilder.loadTexts: tftpFwTargetServerIpType.setDescription('Type of IP interface.')
tftpFwTargetInterfaceName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpFwTargetInterfaceName.setStatus('current')
if mibBuilder.loadTexts: tftpFwTargetInterfaceName.setDescription('Specifies the interface name when the tftpFwTargetServerIpAddress is linklocal address.')
tftpFwTargetImageFileName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFwTargetImageFileName.setStatus('current')
if mibBuilder.loadTexts: tftpFwTargetImageFileName.setDescription('Configure firmware filename to download.')
tftpFwTargetTftpOperation = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("none", 0), ("download", 1), ("upload", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpFwTargetTftpOperation.setStatus('current')
if mibBuilder.loadTexts: tftpFwTargetTftpOperation.setDescription('The tftp operates to perform downloading the firmware image to the unit. This object is used in conjunction with configBootTftpServerIp and configBootImageFileName.')
tftpFwTargetTftpOperationStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 0), ("success", 1), ("fail", 2), ("progressing", 3), ("transmit", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpFwTargetTftpOperationStatus.setStatus('current')
if mibBuilder.loadTexts: tftpFwTargetTftpOperationStatus.setDescription('The tftp operation status represent firmware backup or upgrade status.')
tftpFwTargetTransferPercentage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpFwTargetTransferPercentage.setStatus('current')
if mibBuilder.loadTexts: tftpFwTargetTransferPercentage.setDescription('The file transfer percentage of the file upload or download.')
sysTftpCfgTargetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 2))
tftpCfgTargetServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 2, 1), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpCfgTargetServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: tftpCfgTargetServerIpAddress.setDescription("The TFTP server's IP address is used to upload or download configuration file.")
tftpCfgTargetServerIpType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("iPv4", 1), ("iPv6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpCfgTargetServerIpType.setStatus('current')
if mibBuilder.loadTexts: tftpCfgTargetServerIpType.setDescription('Type of IP interface.')
tftpCfgTargetInterfaceName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 2, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpCfgTargetInterfaceName.setStatus('current')
if mibBuilder.loadTexts: tftpCfgTargetInterfaceName.setDescription('Specifies the interface name when the tftpCfgTargetServerIpAddress is linklocal address.')
tftpCfgTargetImageFileName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 2, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpCfgTargetImageFileName.setStatus('current')
if mibBuilder.loadTexts: tftpCfgTargetImageFileName.setDescription('The configuration filename is used to store or retrieve config from the tftp server.')
tftpCfgTargetTftpOperation = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("download", 1), ("upload", 2), ("progressing", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpCfgTargetTftpOperation.setStatus('current')
if mibBuilder.loadTexts: tftpCfgTargetTftpOperation.setDescription('The tftp operates to perform either downloading the configuration file to the unit or uploading the current configuration file to the tftp server. This object is used in conjunction with configTftpServerIpAddress and configTftpServerFileName.')
tftpCfgTargetTftpOperationStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("success", 1), ("fail", 2), ("progressing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpCfgTargetTftpOperationStatus.setStatus('current')
if mibBuilder.loadTexts: tftpCfgTargetTftpOperationStatus.setDescription('The tftp operation status represent configuration file backup or restore status.')
sysTftpSyslogTargetGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3))
syslogFileSave = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogFileSave.setStatus('current')
if mibBuilder.loadTexts: syslogFileSave.setDescription('enable will save system log to file.')
tftpSyslogTargetServerIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 2), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSyslogTargetServerIpAddress.setStatus('current')
if mibBuilder.loadTexts: tftpSyslogTargetServerIpAddress.setDescription("The TFTP server's IP address is used to upload or download system log file.")
tftpSyslogTargetServerIpType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("iPv4", 1), ("iPv6", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSyslogTargetServerIpType.setStatus('current')
if mibBuilder.loadTexts: tftpSyslogTargetServerIpType.setDescription('Type of IP interface.')
tftpSyslogTargetInterfaceName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSyslogTargetInterfaceName.setStatus('current')
if mibBuilder.loadTexts: tftpSyslogTargetInterfaceName.setDescription('Specifies the interface name when the tftpSyslogTargetServerIpAddress is linklocal address.')
tftpSyslogTargetImageFileName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSyslogTargetImageFileName.setStatus('current')
if mibBuilder.loadTexts: tftpSyslogTargetImageFileName.setDescription('The system log filename is used to store or retrieve system log from the tftp server.')
tftpSyslogTargetTftpOperation = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tftpSyslogTargetTftpOperation.setStatus('current')
if mibBuilder.loadTexts: tftpSyslogTargetTftpOperation.setDescription('The tftp operates to perform either downloading the system log file to the unit or uploading the current system log file to the tftp server. This object is used in conjunction with configTftpServerIpAddress and configTftpServerFileName. Note: enable means backup system log file from dut.')
tftpSyslogTargetTftpOperationStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("success", 1), ("fail", 2), ("progressing", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpSyslogTargetTftpOperationStatus.setStatus('current')
if mibBuilder.loadTexts: tftpSyslogTargetTftpOperationStatus.setDescription('The tftp operation status represent system log file backup or restore status.')
tftpSyslogTargetTftpTransferPercentage = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 3, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: tftpSyslogTargetTftpTransferPercentage.setStatus('current')
if mibBuilder.loadTexts: tftpSyslogTargetTftpTransferPercentage.setDescription('The file transfer percentage of the file upload or download.')
sysTftpTrapGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 4))
sysFimwareTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 4, 0))
sysFimwareupgradesuccess = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 4, 0, 1))
if mibBuilder.loadTexts: sysFimwareupgradesuccess.setStatus('current')
if mibBuilder.loadTexts: sysFimwareupgradesuccess.setDescription('This is a trap that will send to snmp manager,and it will be generated when Firware upgrade success.')
sysFimwareillegalfile = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 4, 0, 2))
if mibBuilder.loadTexts: sysFimwareillegalfile.setStatus('current')
if mibBuilder.loadTexts: sysFimwareillegalfile.setDescription('This is a trap that will send to snmp manager,and it will be generated when Firware upgrade with issegalfile.')
sysFimwarefiletransferfailed = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 4, 0, 3))
if mibBuilder.loadTexts: sysFimwarefiletransferfailed.setStatus('current')
if mibBuilder.loadTexts: sysFimwarefiletransferfailed.setDescription('This is a trap that will send to snmp manager,and it will be generated when transfer file failed.')
sysFimwarewrongchecksum = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 4, 0, 4))
if mibBuilder.loadTexts: sysFimwarewrongchecksum.setStatus('current')
if mibBuilder.loadTexts: sysFimwarewrongchecksum.setDescription('This is a trap that will send to snmp manager,and it will be generated when Firware with wrong checksum .')
sysFimwareuupgradefailed = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 3, 4, 0, 5))
if mibBuilder.loadTexts: sysFimwareuupgradefailed.setStatus('current')
if mibBuilder.loadTexts: sysFimwareuupgradefailed.setDescription('This is a trap that will send to snmp manager,and it will be generated when Firware upgrade failed.')
sysTimeRangeSettingTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1), )
if mibBuilder.loadTexts: sysTimeRangeSettingTable.setStatus('current')
if mibBuilder.loadTexts: sysTimeRangeSettingTable.setDescription('A table to configure time Range in the system.')
timeRangeSettingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "timeRangeIndex"))
if mibBuilder.loadTexts: timeRangeSettingEntry.setStatus('current')
if mibBuilder.loadTexts: timeRangeSettingEntry.setDescription('A schedule entry to configure time Range in the system.')
timeRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 52))).setMaxAccess("readonly")
if mibBuilder.loadTexts: timeRangeIndex.setStatus('current')
if mibBuilder.loadTexts: timeRangeIndex.setDescription('The Time Range identifier. The maximum number of Schedule entry is the number of ports supported PoE function. The value must be between 1 and 52.')
timeRangeName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeName.setStatus('current')
if mibBuilder.loadTexts: timeRangeName.setDescription("The Schedule name associated with the Schedule entry (e.g., `abc, bbb').")
timeRangeDate = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeDate.setStatus('current')
if mibBuilder.loadTexts: timeRangeDate.setDescription('Enable/Disable date range checking while executing time base PoE.')
timeRangeStartYear = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029))).clone(namedValues=NamedValues(("y2014", 2014), ("y2015", 2015), ("y2016", 2016), ("y2017", 2017), ("y2018", 2018), ("y2019", 2019), ("y2020", 2020), ("y2021", 2021), ("y2022", 2022), ("y2023", 2023), ("y2024", 2024), ("y2025", 2025), ("y2026", 2026), ("y2027", 2027), ("y2028", 2028), ("y2029", 2029)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeStartYear.setStatus('current')
if mibBuilder.loadTexts: timeRangeStartYear.setDescription('Start year of the Schedule entry.')
timeRangeStartMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("january", 1), ("february", 2), ("march", 3), ("april", 4), ("may", 5), ("june", 6), ("july", 7), ("august", 8), ("september", 9), ("october", 10), ("november", 11), ("december", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeStartMonth.setStatus('current')
if mibBuilder.loadTexts: timeRangeStartMonth.setDescription('Start month of the Schedule entry.')
timeRangeStartDay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeStartDay.setStatus('current')
if mibBuilder.loadTexts: timeRangeStartDay.setDescription('Start day of the Schedule entry. The value must be from 1 to 31.')
timeRangeStartHour = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeStartHour.setStatus('current')
if mibBuilder.loadTexts: timeRangeStartHour.setDescription('Start hour of the Schedule entry. The value must be from 0 to 23.')
timeRangeStartMinute = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeStartMinute.setStatus('current')
if mibBuilder.loadTexts: timeRangeStartMinute.setDescription('Start minute of the Schedule entry. The value must be from 0 to 59.')
timeRangeEndYear = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029))).clone(namedValues=NamedValues(("y2011", 2011), ("y2012", 2012), ("y2013", 2013), ("y2014", 2014), ("y2015", 2015), ("y2016", 2016), ("y2017", 2017), ("y2018", 2018), ("y2019", 2019), ("y2020", 2020), ("y2021", 2021), ("y2022", 2022), ("y2023", 2023), ("y2024", 2024), ("y2025", 2025), ("y2026", 2026), ("y2027", 2027), ("y2028", 2028), ("y2029", 2029)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeEndYear.setStatus('current')
if mibBuilder.loadTexts: timeRangeEndYear.setDescription('End year of the Schedule entry.')
timeRangeEndMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("january", 1), ("february", 2), ("march", 3), ("april", 4), ("may", 5), ("june", 6), ("july", 7), ("august", 8), ("september", 9), ("october", 10), ("november", 11), ("december", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeEndMonth.setStatus('current')
if mibBuilder.loadTexts: timeRangeEndMonth.setDescription('End month of the Schedule entry.')
timeRangeEndDay = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeEndDay.setStatus('current')
if mibBuilder.loadTexts: timeRangeEndDay.setDescription('End day of the Schedule entry. The value must be from 1 to 31.')
timeRangeEndHour = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 23))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeEndHour.setStatus('current')
if mibBuilder.loadTexts: timeRangeEndHour.setDescription('End hour of the Schedule entry. The value must be from 0 to 23.')
timeRangeEndMinute = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 59))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeEndMinute.setStatus('current')
if mibBuilder.loadTexts: timeRangeEndMinute.setDescription('End minute of the Schedule entry. The value must be from 0 to 59.')
timeRangeMonday = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeMonday.setStatus('current')
if mibBuilder.loadTexts: timeRangeMonday.setDescription('Enable/Disble scheduling Monday.')
timeRangeTuesday = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeTuesday.setStatus('current')
if mibBuilder.loadTexts: timeRangeTuesday.setDescription('Enable/Disble scheduling Tuesday.')
timeRangeWednesday = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeWednesday.setStatus('current')
if mibBuilder.loadTexts: timeRangeWednesday.setDescription('Enable/Disble scheduling Wednesday.')
timeRangeThursday = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeThursday.setStatus('current')
if mibBuilder.loadTexts: timeRangeThursday.setDescription('Enable/Disble scheduling Thursday.')
timeRangeFriday = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeFriday.setStatus('current')
if mibBuilder.loadTexts: timeRangeFriday.setDescription('Enable/Disble scheduling Friday.')
timeRangeSaturday = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeSaturday.setStatus('current')
if mibBuilder.loadTexts: timeRangeSaturday.setDescription('Enable/Disble scheduling Saturday.')
timeRangeSunday = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeSunday.setStatus('current')
if mibBuilder.loadTexts: timeRangeSunday.setDescription('Enable/Disble scheduling Sunday.')
timeRangeRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 38, 1, 1, 21), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: timeRangeRowStatus.setStatus('current')
if mibBuilder.loadTexts: timeRangeRowStatus.setDescription('The status of an entry in the Time Range Information Table. Only a subset of the rowstatus variables (active, notinservice, createAndWait, destroy) are available.')
sysTraceRouteCtlAddressType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTraceRouteCtlAddressType.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteCtlAddressType.setDescription('Specifies the type of host address to be used on the traceroute request at the remote host, 1(ipv4), 2(ipv6).')
sysTraceRouteCtlAddress = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 2), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTraceRouteCtlAddress.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteCtlAddress.setDescription('Specifies the host address used on the traceroute request at the remote host. The host address type can be determined by examining the value of the corresponding sysTraceRouteCtlTargetAddressType.')
sysTraceRouteCtlTimeOut = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(3)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTraceRouteCtlTimeOut.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteCtlTimeOut.setDescription('Specifies the time-out value, in seconds, for a traceroute request.')
sysTraceRouteCtlTTL = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(30)).setUnits('time-to-live value').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTraceRouteCtlTTL.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteCtlTTL.setDescription('Specifies the time-to-live value.')
sysTraceRouteCtlPort = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30000, 64900)).clone(33434)).setUnits('UDP Port').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTraceRouteCtlPort.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteCtlPort.setDescription('Specifies the (initial) UDP port to send the traceroute request to. A port needs to be specified that is not in use at the destination (target) host. The default value for this object is the IANA assigned port, 33434, for the traceroute function.')
sysTraceRouteCtlProbe = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 9)).clone(3)).setUnits('probes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTraceRouteCtlProbe.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteCtlProbe.setDescription('Specifies the number of times to reissue a traceroute request with the same time-to-live (TTL) value.')
sysTraceRouteCtlAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysTraceRouteCtlAdminStatus.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteCtlAdminStatus.setDescription('Control the traceroute action state, value should be in: enabled(1) - Attempt to activate the test as configure. disabled(2) - Deactivate the test.')
sysTraceRouteHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8), )
if mibBuilder.loadTexts: sysTraceRouteHistoryTable.setStatus('current')
if mibBuilder.loadTexts: sysTraceRouteHistoryTable.setDescription('Defines the Remote Operations Traceroute Results Table for storing the results of a traceroute operation. An implementation of this MIB will remove the oldest entry in the traceRouteProbeHistoryTable of the corresponding entry in the traceRouteCtlTable to allow the addition of a new entry once the number of rows in the traceRouteProbeHistoryTable reaches the value specified by traceRouteCtlMaxRows for the corresponding entry in the traceRouteCtlTable.')
traceRouteHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "traceRouteHistoryIndex"), (0, "DGS-1100-10ME_A1", "traceRouteHistoryHopIndex"), (0, "DGS-1100-10ME_A1", "traceRouteHistoryProbeIndex"))
if mibBuilder.loadTexts: traceRouteHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryEntry.setDescription('Defines a table for storing the results of a traceroute operation. Entries in this table are limited by the value of the corresponding traceRouteCtlMaxRows object. The first two index elements identify the traceRouteCtlEntry that a traceRouteProbeHistoryEntry belongs to. The third index element selects a single traceroute operation result. The fourth and fifth indexes select the hop and the probe for a particular traceroute operation.')
traceRouteHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryIndex.setDescription('An entry in this table is created when the result of a traceroute probe is determined. The initial 2 instance identifier index values identify the traceRouteCtlEntry that a probe result (traceRouteProbeHistoryEntry) belongs to. An entry is removed from this table when its corresponding traceRouteCtlEntry is deleted.')
traceRouteHistoryHopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHistoryHopIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryHopIndex.setDescription("Indicates which hop in a traceroute path the probe's results are for. The value of this object is initially determined by the value of traceRouteCtlInitialTtl.")
traceRouteHistoryProbeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHistoryProbeIndex.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryProbeIndex.setDescription('Indicates the index of a probe for a particular hop in a traceroute path. The number of probes per hop is determined by the value of the corresponding traceRouteCtlProbesPerHop object.')
traceRouteHistoryHAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHistoryHAddrType.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryHAddrType.setDescription('This objects indicates the type of address stored in the corresponding traceRouteHistoryHAddr object.')
traceRouteHistoryHAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHistoryHAddr.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryHAddr.setDescription("The address of a hop in a traceroute path. This object is not allowed to be a DNS name. The value of the corresponding object, traceRouteHistoryHAddrType, indicates this object's IP address type.")
traceRouteHistoryResponse = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1, 6), Unsigned32()).setUnits('milliseconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHistoryResponse.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryResponse.setDescription('The amount of time measured in milliseconds from when a probe was sent to when its response was received or when it timed out. The value of this object is reported as 0 when it is not possible to transmit a probe.')
traceRouteHistoryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 90, 8, 1, 7), OperationResponseStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: traceRouteHistoryStatus.setStatus('current')
if mibBuilder.loadTexts: traceRouteHistoryStatus.setDescription('The result of a traceroute operation made by a remote host for a particular probe.')
sysRMONGlobalState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysRMONGlobalState.setStatus('current')
if mibBuilder.loadTexts: sysRMONGlobalState.setDescription('This object is for enabling or disabling RMON function.')
sysRMONStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2))
sysRMONHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3))
sysRMONAlarm = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4))
sysRMONEvent = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5))
rmonStatsTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1), )
if mibBuilder.loadTexts: rmonStatsTable.setStatus('current')
if mibBuilder.loadTexts: rmonStatsTable.setDescription('A list of Ethernet statistics entries.')
rmonStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "rmonStatsIndex"))
if mibBuilder.loadTexts: rmonStatsEntry.setStatus('current')
if mibBuilder.loadTexts: rmonStatsEntry.setDescription('A collection of statistics kept for a particular Ethernet interface. As an example, an instance of the etherStatsPkts object might be named etherStatsPkts.1')
rmonStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonStatsIndex.setStatus('current')
if mibBuilder.loadTexts: rmonStatsIndex.setDescription('The value of this object uniquely identifies this entry.')
rmonStatsDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonStatsDataSource.setStatus('current')
if mibBuilder.loadTexts: rmonStatsDataSource.setDescription('This object identifies the source of the data that this etherStats entry is configured to analyze. This source can be any ethernet interface on this device. In order to identify a particular interface, this object shall identify the instance of the ifIndex object, defined in RFC 2233 [17], for the desired interface. For example, if an entry were to receive data from interface #1, this object would be set to ifIndex.1. The statistics in this group reflect all packets on the local network segment attached to the identified interface. An agent may or may not be able to tell if fundamental changes to the media of the interface have occurred and necessitate an invalidation of this entry. For example, a hot-pluggable ethernet card could be pulled out and replaced by a token-ring card. In such a case, if the agent has such knowledge of the change, it is recommended that it invalidate this entry. This object may not be modified if the associated etherStatsStatus object is equal to valid(1).')
rmonStatsOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 3), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonStatsOwner.setStatus('current')
if mibBuilder.loadTexts: rmonStatsOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
rmonStatsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 4), RmonStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonStatsStatus.setStatus('current')
if mibBuilder.loadTexts: rmonStatsStatus.setDescription('The status of this etherStats entry.')
rmonStatsDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonStatsDropEvents.setStatus('current')
if mibBuilder.loadTexts: rmonStatsDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
rmonStatsOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 6), Counter32()).setUnits('Octets').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonStatsOctets.setStatus('current')
if mibBuilder.loadTexts: rmonStatsOctets.setDescription('The total number of octets of data (including those in bad packets) received on the network (excluding framing bits but including FCS octets). This object can be used as a reasonable estimate of 10-Megabit ethernet utilization. If greater precision is desired, the etherStatsPkts and etherStatsOctets objects should be sampled before and after a common interval. The differences in the sampled values are Pkts and Octets, respectively, and the number of seconds in the interval is Interval. These values are used to calculate the Utilization as follows: Pkts * (9.6 + 6.4) + (Octets * .8) Utilization = ------------------------------------- Interval * 10,000 The result of this equation is the value Utilization which is the percent utilization of the ethernet segment on a scale of 0 to 100 percent.')
rmonStatsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 7), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonStatsPkts.setStatus('current')
if mibBuilder.loadTexts: rmonStatsPkts.setDescription('The total number of packets (including bad packets, broadcast packets, and multicast packets) received.')
rmonStatsBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 8), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonStatsBroadcastPkts.setStatus('current')
if mibBuilder.loadTexts: rmonStatsBroadcastPkts.setDescription('The total number of good packets received that were directed to the broadcast address. Note that this does not include multicast packets.')
rmonStatsMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 2, 1, 1, 9), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonStatsMulticastPkts.setStatus('current')
if mibBuilder.loadTexts: rmonStatsMulticastPkts.setDescription('The total number of good packets received that were directed to a multicast address. Note that this number does not include packets directed to the broadcast address.')
rmonHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1), )
if mibBuilder.loadTexts: rmonHistoryTable.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryTable.setDescription('A list of history control entries.')
rmonHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "rmonHistoryIndex"))
if mibBuilder.loadTexts: rmonHistoryEntry.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryEntry.setDescription('A list of parameters that set up a periodic sampling of statistics. As an example, an instance of the historyControlInterval object might be named historyControlInterval.2')
rmonHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonHistoryIndex.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryIndex.setDescription('An index that uniquely identifies an entry in the historyControl table. Each such entry defines a set of samples at a particular interval for an interface on the device.')
rmonHistoryDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonHistoryDataSource.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryDataSource.setDescription('This object identifies the source of the data for which historical data was collected and placed in a media-specific table on behalf of this historyControlEntry. This source can be any interface on this device. In order to identify a particular interface, this object shall identify the instance of the ifIndex object, defined in RFC 2233 [17], for the desired interface. For example, if an entry were to receive data from interface #1, this object would be set to ifIndex.1. The statistics in this group reflect all packets on the local network segment attached to the identified interface. An agent may or may not be able to tell if fundamental changes to the media of the interface have occurred and necessitate an invalidation of this entry. For example, a hot-pluggable ethernet card could be pulled out and replaced by a token-ring card. In such a case, if the agent has such knowledge of the change, it is recommended that it invalidate this entry. This object may not be modified if the associated historyControlStatus object is equal to valid(1).')
rmonHistoryBucketsRequested = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 50)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonHistoryBucketsRequested.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryBucketsRequested.setDescription('The requested number of discrete time intervals over which data is to be saved in the part of the media-specific table associated with this historyControlEntry. When this object is created or modified, the probe should set historyControlBucketsGranted as closely to this object as is possible for the particular probe implementation and available resources.')
rmonHistoryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1800)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonHistoryInterval.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryInterval.setDescription("The interval in seconds over which the data is sampled for each bucket in the part of the media-specific table associated with this historyControlEntry. This interval can be set to any number of seconds between 1 and 3600 (1 hour). Because the counters in a bucket may overflow at their maximum value with no indication, a prudent manager will take into account the possibility of overflow in any of the associated counters. It is important to consider the minimum time in which any counter could overflow on a particular media type and set the historyControlInterval object to a value less than this interval. This is typically most important for the 'octets' counter in any media-specific table. For example, on an Ethernet network, the etherHistoryOctets counter could overflow in about one hour at the Ethernet's maximum utilization. This object may not be modified if the associated historyControlStatus object is equal to valid(1).")
rmonHistoryOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1, 1, 5), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonHistoryOwner.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
rmonHistoryStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 3, 1, 1, 6), RmonStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonHistoryStatus.setStatus('current')
if mibBuilder.loadTexts: rmonHistoryStatus.setDescription('The status of this historyControl entry. Each instance of the media-specific table associated with this historyControlEntry will be deleted by the agent if this historyControlEntry is not equal to valid(1).')
rmonAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1), )
if mibBuilder.loadTexts: rmonAlarmTable.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmTable.setDescription('A list of alarm entries.')
rmonAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "rmonAlarmIndex"))
if mibBuilder.loadTexts: rmonAlarmEntry.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmEntry.setDescription('A list of parameters that set up a periodic checking for alarm conditions. For example, an instance of the alarmValue object might be named alarmValue.8')
rmonAlarmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonAlarmIndex.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmIndex.setDescription('An index that uniquely identifies an entry in the alarm table. Each such entry defines a diagnostic sample at a particular interval for an object on the device.')
rmonAlarmInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 2), Integer32()).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmInterval.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmInterval.setDescription('The interval in seconds over which the data is sampled and compared with the rising and falling thresholds. When setting this variable, care should be taken in the case of deltaValue sampling - the interval should be set short enough that the sampled variable is very unlikely to increase or decrease by more than 2^31 - 1 during a single sampling interval. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rmonAlarmVariable = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 3), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmVariable.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmVariable.setDescription('The object identifier of the particular variable to be sampled. Only variables that resolve to an ASN.1 primitive type of INTEGER (INTEGER, Integer32, Counter32, Counter64, Gauge, or TimeTicks) may be sampled. Because SNMP access control is articulated entirely in terms of the contents of MIB views, no access control mechanism exists that can restrict the value of this object to identify only those objects that exist in a particular MIB view. Because there is thus no acceptable means of restricting the read access that could be obtained through the alarm mechanism, the probe must only grant write access to this object in those views that have read access to all objects on the probe. During a set operation, if the supplied variable name is not available in the selected MIB view, a badValue error must be returned. If at any time the variable name of an established alarmEntry is no longer available in the selected MIB view, the probe must change the status of this alarmEntry to invalid(4). This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rmonAlarmSampleType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("absoluteValue", 1), ("deltaValue", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmSampleType.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmSampleType.setDescription('The method of sampling the selected variable and calculating the value to be compared against the thresholds. If the value of this object is absoluteValue(1), the value of the selected variable will be compared directly with the thresholds at the end of the sampling interval. If the value of this object is deltaValue(2), the value of the selected variable at the last sample will be subtracted from the current value, and the difference compared with the thresholds. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rmonAlarmRisingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmRisingThreshold.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmRisingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is greater than or equal to this threshold, and the value at the last sampling interval was less than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is greater than or equal to this threshold and the associated alarmStartupAlarm is equal to risingAlarm(1) or risingOrFallingAlarm(3). After a rising event is generated, another such event will not be generated until the sampled value falls below this threshold and reaches the alarmFallingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rmonAlarmFallingThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmFallingThreshold.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmFallingThreshold.setDescription('A threshold for the sampled statistic. When the current sampled value is less than or equal to this threshold, and the value at the last sampling interval was greater than this threshold, a single event will be generated. A single event will also be generated if the first sample after this entry becomes valid is less than or equal to this threshold and the associated alarmStartupAlarm is equal to fallingAlarm(2) or risingOrFallingAlarm(3). After a falling event is generated, another such event will not be generated until the sampled value rises above this threshold and reaches the alarmRisingThreshold. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rmonAlarmRisingEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmRisingEventIndex.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmRisingEventIndex.setDescription('The index of the eventEntry that is used when a rising threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rmonAlarmFallingEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmFallingEventIndex.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmFallingEventIndex.setDescription('The index of the eventEntry that is used when a falling threshold is crossed. The eventEntry identified by a particular value of this index is the same as identified by the same value of the eventIndex object. If there is no corresponding entry in the eventTable, then no association exists. In particular, if this value is zero, no associated event will be generated, as zero is not a valid event index. This object may not be modified if the associated alarmStatus object is equal to valid(1).')
rmonAlarmOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 9), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmOwner.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
rmonAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 4, 1, 1, 10), RmonStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonAlarmStatus.setStatus('current')
if mibBuilder.loadTexts: rmonAlarmStatus.setDescription('The status of this alarm entry.')
rmonEventTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1), )
if mibBuilder.loadTexts: rmonEventTable.setStatus('current')
if mibBuilder.loadTexts: rmonEventTable.setDescription('A list of events to be generated.')
rmonEventEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "rmonEventIndex"))
if mibBuilder.loadTexts: rmonEventEntry.setStatus('current')
if mibBuilder.loadTexts: rmonEventEntry.setDescription('A set of parameters that describe an event to be generated when certain conditions are met. As an example, an instance of the eventLastTimeSent object might be named eventLastTimeSent.6')
rmonEventIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonEventIndex.setStatus('current')
if mibBuilder.loadTexts: rmonEventIndex.setDescription('An index that uniquely identifies an entry in the event table. Each such entry defines one event that is to be generated when the appropriate conditions occur.')
rmonEventDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonEventDescription.setStatus('current')
if mibBuilder.loadTexts: rmonEventDescription.setDescription('A comment describing this event entry.')
rmonEventType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("log", 2), ("snmptrap", 3), ("logandtrap", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonEventType.setStatus('current')
if mibBuilder.loadTexts: rmonEventType.setDescription('The type of notification that the probe will make about this event. In the case of log, an entry is made in the log table for each event. In the case of snmp-trap, an SNMP trap is sent to one or more management stations.')
rmonEventCommunity = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1, 4), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonEventCommunity.setStatus('current')
if mibBuilder.loadTexts: rmonEventCommunity.setDescription('If an SNMP trap is to be sent, it will be sent to the SNMP community specified by this octet string.')
rmonEventOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1, 5), OwnerString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonEventOwner.setStatus('current')
if mibBuilder.loadTexts: rmonEventOwner.setDescription("The entity that configured this entry and is therefore using the resources assigned to it. If this object contains a string starting with 'monitor' and has associated entries in the log table, all connected management stations should retrieve those log entries, as they may have significance to all management stations connected to this device")
rmonEventStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1, 6), RmonStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rmonEventStatus.setStatus('current')
if mibBuilder.loadTexts: rmonEventStatus.setDescription('The status of this event entry. If this object is not equal to valid(1), all associated log entries shall be deleted by the agent.')
rmonEventLastTimeSent = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 22, 5, 1, 1, 7), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rmonEventLastTimeSent.setStatus('current')
if mibBuilder.loadTexts: rmonEventLastTimeSent.setDescription('The value of sysUpTime at the time this event entry last generated an event. If this entry has not generated any events, this value will be zero.')
sysDHCPRelayControl = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 1))
sysDHCPRelayManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2))
dhcpRelayManagermentOption82 = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 2))
dhcpRelayState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayState.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayState.setDescription('This object indicates DHCP relay function is enabled or disabled.')
dhcpRelayHopCount = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayHopCount.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayHopCount.setDescription('This object indicates the maximum number of router hops that the BOOTP packets can cross.')
dhcpRelayTimeThreshold = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayTimeThreshold.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayTimeThreshold.setDescription('This object indicates the minimum time in seconds within which the switch must relay the DHCP request. If this time is exceeded, the switch will drop the DHCP packet.')
dhcpRelayInterfaceSettingsTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 1), )
if mibBuilder.loadTexts: dhcpRelayInterfaceSettingsTable.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayInterfaceSettingsTable.setDescription('This table indicates the IP address as a destination to forward (relay) DHCP packets to.')
dhcpRelayInterfaceSettingsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "dhcpRelayServerIP"))
if mibBuilder.loadTexts: dhcpRelayInterfaceSettingsEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayInterfaceSettingsEntry.setDescription('A list of information indicates the IP address as a destination to forward (relay) DHCP packets to.')
dhcpRelayServerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRelayServerIP.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayServerIP.setDescription('This object indicates the DHCP server IP address.')
dhcpRelayInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRelayInterface.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayInterface.setDescription('This object indicates the input Interface Index value mapped to this Server Address Table.')
dhcpRelayInterfaceSettingsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayInterfaceSettingsRowStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayInterfaceSettingsRowStatus.setDescription('This object indicates the status of this entry.')
dhcpRelayOption82State = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayOption82State.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayOption82State.setDescription('Only when enabled, the Relay Agent shall do any processing related to Relay Agent Information Options - like inserting the necessary options while relaying a packet from a client to a server and examining/stripping of options when relaying a packet from a server to a client.')
dhcpRelayOption82CheckState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayOption82CheckState.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayOption82CheckState.setDescription('This object indicates DHCP relay option 82 Check function is enabled or disabled.')
dhcpRelayOption82Policy = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("replace", 1), ("drop", 2), ("keep", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayOption82Policy.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayOption82Policy.setDescription('This object indicates DHCP relay option 82 policy.')
dhcpRelayOption82RemoteIDType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("default", 1), ("userdefined", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayOption82RemoteIDType.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayOption82RemoteIDType.setDescription('This object indicates the type of remote ID. If the type is default, the remote ID will be the MAC address of the device, otherwise, the remote ID can be defined by writing to the swDHCPRelayOption82RemoteID object.')
dhcpRelayOption82RemoteID = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 28, 2, 2, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpRelayOption82RemoteID.setStatus('current')
if mibBuilder.loadTexts: dhcpRelayOption82RemoteID.setDescription('This object displays the current remote ID of the device. If DHCPRelayOption82RemoteIDType is set to default, the value will be the MAC address of the device, and this object cannot be modified. If DHCPRelayOption82RemoteIDType is set to user-defined, a new value can be written to this object.')
sysDHCPLocalRelayGlobalState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 29, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDHCPLocalRelayGlobalState.setStatus('current')
if mibBuilder.loadTexts: sysDHCPLocalRelayGlobalState.setDescription('This object indicates DHCP local relay function is enabled or disabled globally.')
sysDHCPLocalRelayTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 29, 2), )
if mibBuilder.loadTexts: sysDHCPLocalRelayTable.setStatus('current')
if mibBuilder.loadTexts: sysDHCPLocalRelayTable.setDescription('This table indicates the IP address as a destination to forward (local relay) DHCP packets to.')
dhcpLocalRelayEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 29, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "dhcpLocalRelayVlanId"))
if mibBuilder.loadTexts: dhcpLocalRelayEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpLocalRelayEntry.setDescription('A list of information indicates the IP address as a destination to forward (local relay) DHCP packets to.')
dhcpLocalRelayVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 29, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpLocalRelayVlanId.setStatus('current')
if mibBuilder.loadTexts: dhcpLocalRelayVlanId.setDescription('This object displays the current VLAN ID of the device.')
dhcpLocalRelayState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 29, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpLocalRelayState.setStatus('current')
if mibBuilder.loadTexts: dhcpLocalRelayState.setDescription('This object indicates DHCP local relay function of VLAN is enabled or disabled.')
sysDHCPv6RelayControl = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 1))
sysDHCPv6RelayManagement = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 2))
sysDHCPv6RelayOption37 = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 3))
dhcpv6RelayState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpv6RelayState.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayState.setDescription('This object indicates DHCPv6 relay function is enabled or disabled.')
dhcpv6RelayHopCount = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpv6RelayHopCount.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayHopCount.setDescription('This object indicates the maximum number of router hops that the DHCPv6 packets can cross.')
dhcpv6RelayInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 2, 1), )
if mibBuilder.loadTexts: dhcpv6RelayInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayInterfaceTable.setDescription('This table indicates the IP address as a destination to forward (relay) DHCP packets to.')
dhcpv6RelayInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "dhcpv6RelayServerIP"))
if mibBuilder.loadTexts: dhcpv6RelayInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayInterfaceEntry.setDescription('A list of information indicates the IP address as a destination to forward (relay) DHCP packets to.')
dhcpv6RelayServerIP = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 2, 1, 1, 1), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpv6RelayServerIP.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayServerIP.setDescription('This object indicates the DHCP server IP address.')
dhcpv6RelayInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpv6RelayInterface.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayInterface.setDescription('This object indicates the input Interface Index value mapped to this Server Address Table.')
dhcpv6RelayRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 2, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpv6RelayRowStatus.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayRowStatus.setDescription('This object indicates the status of this entry.')
dhcpv6RelayOption37State = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpv6RelayOption37State.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayOption37State.setDescription('This object indicates DHCPv6 relay option 37 function is enabled or disabled.')
dhcpv6RelayOption37CheckState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpv6RelayOption37CheckState.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayOption37CheckState.setDescription('This object indicates DHCPv6 relay option 37 Check function is enabled or disabled.')
dhcpv6RelayOption37RemoteIDType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("default", 0), ("cid_with_user_define", 1), ("user_define", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpv6RelayOption37RemoteIDType.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayOption37RemoteIDType.setDescription('This object indicates the type of remote ID.')
dhcpv6RelayOption37RemoteID = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 86, 3, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: dhcpv6RelayOption37RemoteID.setStatus('current')
if mibBuilder.loadTexts: dhcpv6RelayOption37RemoteID.setDescription('This object displays the current remote ID of the device. If RemoteIDType is set to default, the value will be the MAC address of the device, and this object cannot be modified. If RemoteIDType is set to user-defined, a new value can be written to this object.')
sysBandwidthCtrlSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1))
bandwidthCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1, 2), )
if mibBuilder.loadTexts: bandwidthCtrlTable.setStatus('current')
if mibBuilder.loadTexts: bandwidthCtrlTable.setDescription('A table to control the rate limiting parameters either for the entire switch or for each interface in the switch.')
bandwidthCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "bandwidthCtrlIndex"))
if mibBuilder.loadTexts: bandwidthCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: bandwidthCtrlEntry.setDescription('An entry appears in this table for each physical interface in the switch.')
bandwidthCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: bandwidthCtrlIndex.setDescription('The interface index for which the configuration in this entry applies.')
bandwidthCtrlTxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(64, 1000000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bandwidthCtrlTxThreshold.setStatus('current')
if mibBuilder.loadTexts: bandwidthCtrlTxThreshold.setDescription("Configures interface Rate Limit (Packet that can be transferred on a port at a particular second). This object's value will take effect on the interface speed. Based on the operating speed of the port, the rate limit will be applied. This value can also be affected by the metering. A value of zero(0) disable rate limiting i.e. sets the port to full speed. The value can be set between 64~100000(Kbits per second) in FE port, 64~1000000 (Kbits per second) in GE port.")
bandwidthCtrlEffectiveTxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(64, 1000000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthCtrlEffectiveTxThreshold.setStatus('current')
if mibBuilder.loadTexts: bandwidthCtrlEffectiveTxThreshold.setDescription("Configures the new interface Rate Limit (Packet that can be transferred on a port at a particular second). This object's value will take effect on the interface speed. Based on the operating speed of the port, the rate limit will be applied. This value can also be affected by the metering. A value of zero(0) disable rate limiting i.e. sets the port to full speed. The value can be set between 64~100000(Kbits per second) in FE port, 64~1000000 (Kbits per second) in GE port.")
bandwidthCtrlRxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(64, 1000000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bandwidthCtrlRxThreshold.setStatus('current')
if mibBuilder.loadTexts: bandwidthCtrlRxThreshold.setDescription('Allows to configure the limiting value for the maximum number of receive packets that can be transmitted per second over this interface. Setting this object to the value zero disables rate limiting for receive packets on this interface. The value that can be set for this object is limited by the underlying hardware. The value can be set between 64~100000(Kbits per second) in FE port, 64~1000000(Kbits per second) in GE port.')
bandwidthCtrlEffectiveRxThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(64, 1000000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bandwidthCtrlEffectiveRxThreshold.setStatus('current')
if mibBuilder.loadTexts: bandwidthCtrlEffectiveRxThreshold.setDescription('Allows to configure the new limiting value for the maximum number of receive packets that can be transmitted per second over this interface. Setting this object to the value zero disables rate limiting for receive packets on this interface. The value that can be set for this object is limited by the underlying hardware. The value can be set between 64~100000(Kbits per second) in FE port, 64~1000000(Kbits per second) in GE port.')
sysTrafficCtrlSettings = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4))
trafficCtrlTrap = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("stormOccurred", 1), ("stormCleared", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficCtrlTrap.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlTrap.setDescription('The trap setting of traffic control.')
trafficCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2), )
if mibBuilder.loadTexts: trafficCtrlTable.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlTable.setDescription('The traffic control table.')
trafficCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "trafficCtrlIndex"))
if mibBuilder.loadTexts: trafficCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlEntry.setDescription('The traffic control entry.')
trafficCtrlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficCtrlIndex.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlIndex.setDescription('The traffic control index.')
trafficCtrlActionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("drop", 0), ("shutdown", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficCtrlActionMode.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlActionMode.setDescription('The action mode of traffic control.')
trafficCtrlType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 0), ("b", 1), ("m", 2), ("mb", 3), ("u", 4), ("ub", 5), ("um", 6), ("umb", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficCtrlType.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlType.setDescription('The control type of traffic control. (b: Broadcast, m: Multicast, u: Unknown Unicast)')
trafficCtrlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 102400))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficCtrlThreshold.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlThreshold.setDescription("The threshold of traffic control. In drop mode,threshold should be times of 64,its range is 64 to 1000000,unit is kbps In Shutdown mode,threshold's range is 1 to 255000,unit is pkts per second")
trafficCtrlCountDown = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficCtrlCountDown.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlCountDown.setDescription('The count down value of traffic control.')
trafficCtrlTimeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficCtrlTimeInterval.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlTimeInterval.setDescription('The time interval of traffic control.')
trafficCtrlPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("blocking", 1), ("shutdown", 2))).clone('normal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficCtrlPortState.setStatus('current')
if mibBuilder.loadTexts: trafficCtrlPortState.setDescription('The Traffic control port status in shutdown mode.')
sysStormCtrlTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 5))
stormCtrlTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 5, 0))
stormOccurred = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 5, 0, 1)).setObjects(("DGS-1100-10ME_A1", "trafficCtrlIndex"), ("DGS-1100-10ME_A1", "trafficCtrlType"))
if mibBuilder.loadTexts: stormOccurred.setStatus('current')
if mibBuilder.loadTexts: stormOccurred.setDescription('when storm event occur on the port ,it will send out storm occured snmp trap to snmp manager.')
stormCleared = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 13, 5, 0, 2)).setObjects(("DGS-1100-10ME_A1", "trafficCtrlIndex"), ("DGS-1100-10ME_A1", "trafficCtrlTimeInterval"))
if mibBuilder.loadTexts: stormCleared.setStatus('current')
if mibBuilder.loadTexts: stormCleared.setDescription('when storm event cleared on the port, it will send out a storm cleared snmp trap to snmp manager.')
sysQos1p = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 4))
qosTrafficClassTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 4, 1), )
if mibBuilder.loadTexts: qosTrafficClassTable.setReference('ISO/IEC 15802-3 Table 7-2')
if mibBuilder.loadTexts: qosTrafficClassTable.setStatus('current')
if mibBuilder.loadTexts: qosTrafficClassTable.setDescription('A table mapping evaluated User Priority to Traffic Class, for forwarding by the bridge.')
qosTrafficClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 4, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "qosTrafficClassPriority"))
if mibBuilder.loadTexts: qosTrafficClassEntry.setStatus('current')
if mibBuilder.loadTexts: qosTrafficClassEntry.setDescription('User Priority to Traffic Class mapping.')
qosTrafficClassPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosTrafficClassPriority.setStatus('current')
if mibBuilder.loadTexts: qosTrafficClassPriority.setDescription('The Priority value determined for the received frame. This value is equivalent to the priority indicated in the tagged frame received, or one of the evaluated priorities, determined according to the media-type.')
qosTrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosTrafficClass.setStatus('current')
if mibBuilder.loadTexts: qosTrafficClass.setDescription('The Traffic Class the received frame is mapped to.')
sysQosPortBase = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 3))
qosPortBaseTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 3, 1), )
if mibBuilder.loadTexts: qosPortBaseTable.setStatus('current')
if mibBuilder.loadTexts: qosPortBaseTable.setDescription('A list of 802.1p port default priority Entries.')
qosPortBaseEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "qosPortBasePortIndex"))
if mibBuilder.loadTexts: qosPortBaseEntry.setStatus('current')
if mibBuilder.loadTexts: qosPortBaseEntry.setDescription('A list of 802.1p port default priority priorities.')
qosPortBasePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosPortBasePortIndex.setStatus('current')
if mibBuilder.loadTexts: qosPortBasePortIndex.setDescription('A port identifier that is in the range of 1 to ifNumber.')
qosPortBasePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosPortBasePriority.setStatus('current')
if mibBuilder.loadTexts: qosPortBasePriority.setDescription("For ingress packets, the per port 'Default Priority' setting will be applied to packets of each port to provide port-based traffic prioritization.")
qosPortBaseEffectivePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosPortBaseEffectivePriority.setStatus('current')
if mibBuilder.loadTexts: qosPortBaseEffectivePriority.setDescription("For ingress packets, the per port 'Effective Default Priority' setting will be applied to packets of each port to provide port-based traffic prioritization.")
sysQosMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dot1p", 1), ("dscp", 2), ("portbase", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysQosMode.setStatus('current')
if mibBuilder.loadTexts: sysQosMode.setDescription('Settings of Qos mode. Qos PortBase, 802.1p or DSCP mode. PortBase: When Qos in Port Base mode, ingress packets from each port SHOULD be forwarded to the specific queue according to Port Base Priority settings for traffic per-port classification 802.1p: When Qos is placed in 802.1P mode, ingress tagged packets SHOULD be classified to 8 different queues according to its carrying 802.1P priority and queue setting DSCP: When Qos in DSCP mode, ingress packets MUST be classified to the specified queue according to its DSCP and queue mapping ')
sysQosQueuingMechanism = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("strictPriority", 1), ("wrr", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysQosQueuingMechanism.setStatus('current')
if mibBuilder.loadTexts: sysQosQueuingMechanism.setDescription('Queuing mechanism. strictPriority(1) : Strict Priority wrr(2) : Weighted Round Robin Strict-priority scheduling is implemented with a special strict-priority scheduler node that is stacked directly above the port. Queues stacked on top of the strict-priority scheduler node always get bandwidth before other queues. Weighted round-robin scheduling is designed to better handle queues with different processing capacities. Each queue has a weight : Low is 1, Medium is 2, High is 4 and Highest is 8. Queues with higher weights get bandwidth before than other queues with less weights. ')
sysQosDiffServ = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6))
qosDiffServTypeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1))
qosDiffServType00 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType00.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType00.setDescription('DiffServ Type 0 : IP ToS value = 0')
qosDiffServType01 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType01.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType01.setDescription('DiffServ Type 01 : IP ToS value = 4')
qosDiffServType02 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType02.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType02.setDescription('DiffServ Type 02 : IP ToS value = 8')
qosDiffServType03 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType03.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType03.setDescription('DiffServ Type 03 : IP ToS value = 12')
qosDiffServType04 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType04.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType04.setDescription('DiffServ Type 04 : IP ToS value = 16')
qosDiffServType05 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType05.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType05.setDescription('DiffServ Type 05 : IP ToS value = 20')
qosDiffServType06 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType06.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType06.setDescription('DiffServ Type 06 : IP ToS value = 24')
qosDiffServType07 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType07.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType07.setDescription('DiffServ Type 07 : IP ToS value = 28')
qosDiffServType08 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType08.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType08.setDescription('DiffServ Type 08 : IP ToS value = 32')
qosDiffServType09 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType09.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType09.setDescription('DiffServ Type 09 : IP ToS value = 36')
qosDiffServType10 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType10.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType10.setDescription('DiffServ Type 10 : IP ToS value = 40')
qosDiffServType11 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType11.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType11.setDescription('DiffServ Type 11 : IP ToS value = 44')
qosDiffServType12 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType12.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType12.setDescription('DiffServ Type 12 : IP ToS value = 48')
qosDiffServType13 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType13.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType13.setDescription('DiffServ Type 13 : IP ToS value = 52')
qosDiffServType14 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType14.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType14.setDescription('DiffServ Type 14 : IP ToS value = 56')
qosDiffServType15 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType15.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType15.setDescription('DiffServ Type 15 : IP ToS value = 60')
qosDiffServType16 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType16.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType16.setDescription('DiffServ Type 16 : IP ToS value = 64')
qosDiffServType17 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType17.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType17.setDescription('DiffServ Type 17 : IP ToS value = 68')
qosDiffServType18 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType18.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType18.setDescription('DiffServ Type 18 : IP ToS value = 72')
qosDiffServType19 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType19.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType19.setDescription('DiffServ Type 19 : IP ToS value = 76')
qosDiffServType20 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType20.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType20.setDescription('DiffServ Type 20 : IP ToS value = 80')
qosDiffServType21 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType21.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType21.setDescription('DiffServ Type 21 : IP ToS value = 84')
qosDiffServType22 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType22.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType22.setDescription('DiffServ Type 22 : IP ToS value = 88')
qosDiffServType23 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType23.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType23.setDescription('DiffServ Type 23 : IP ToS value = 92')
qosDiffServType24 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType24.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType24.setDescription('DiffServ Type 24 : IP ToS value = 96')
qosDiffServType25 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType25.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType25.setDescription('DiffServ Type 25 : IP ToS value = 100')
qosDiffServType26 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType26.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType26.setDescription('DiffServ Type 26 : IP ToS value = 104')
qosDiffServType27 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType27.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType27.setDescription('DiffServ Type 27 : IP ToS value = 108')
qosDiffServType28 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType28.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType28.setDescription('DiffServ Type 28 : IP ToS value = 112')
qosDiffServType29 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType29.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType29.setDescription('DiffServ Type 29 : IP ToS value = 116')
qosDiffServType30 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType30.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType30.setDescription('DiffServ Type 30 : IP ToS value = 120')
qosDiffServType31 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType31.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType31.setDescription('DiffServ Type 31 : IP ToS value = 124')
qosDiffServType32 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType32.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType32.setDescription('DiffServ Type 32 : IP ToS value = 128')
qosDiffServType33 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType33.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType33.setDescription('DiffServ Type 33 : IP ToS value = 132')
qosDiffServType34 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType34.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType34.setDescription('DiffServ Type 34 : IP ToS value = 136')
qosDiffServType35 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType35.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType35.setDescription('DiffServ Type 35 : IP ToS value = 140')
qosDiffServType36 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType36.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType36.setDescription('DiffServ Type 36 : IP ToS value = 144')
qosDiffServType37 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType37.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType37.setDescription('DiffServ Type 37 : IP ToS value = 148')
qosDiffServType38 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType38.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType38.setDescription('DiffServ Type 38 : IP ToS value = 152')
qosDiffServType39 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType39.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType39.setDescription('DiffServ Type 39 : IP ToS value = 156')
qosDiffServType40 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType40.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType40.setDescription('DiffServ Type 40 : IP ToS value = 160')
qosDiffServType41 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType41.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType41.setDescription('DiffServ Type 41 : IP ToS value = 164')
qosDiffServType42 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType42.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType42.setDescription('DiffServ Type 42 : IP ToS value = 168')
qosDiffServType43 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType43.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType43.setDescription('DiffServ Type 43 : IP ToS value = 172')
qosDiffServType44 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType44.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType44.setDescription('DiffServ Type 44 : IP ToS value = 176')
qosDiffServType45 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType45.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType45.setDescription('DiffServ Type 45 : IP ToS value = 180')
qosDiffServType46 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType46.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType46.setDescription('DiffServ Type 46 : IP ToS value = 184')
qosDiffServType47 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType47.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType47.setDescription('DiffServ Type 47 : IP ToS value = 188')
qosDiffServType48 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType48.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType48.setDescription('DiffServ Type 48 : IP ToS value = 192')
qosDiffServType49 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType49.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType49.setDescription('DiffServ Type 49 : IP ToS value = 196')
qosDiffServType50 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType50.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType50.setDescription('DiffServ Type 50 : IP ToS value = 200')
qosDiffServType51 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType51.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType51.setDescription('DiffServ Type 51 : IP ToS value = 204')
qosDiffServType52 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType52.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType52.setDescription('DiffServ Type 52 : IP ToS value = 208')
qosDiffServType53 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType53.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType53.setDescription('DiffServ Type 53 : IP ToS value = 212')
qosDiffServType54 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType54.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType54.setDescription('DiffServ Type 54 : IP ToS value = 216')
qosDiffServType55 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType55.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType55.setDescription('DiffServ Type 55 : IP ToS value = 220')
qosDiffServType56 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType56.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType56.setDescription('DiffServ Type 56 : IP ToS value = 224')
qosDiffServType57 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType57.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType57.setDescription('DiffServ Type 57 : IP ToS value = 228')
qosDiffServType58 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 59), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType58.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType58.setDescription('DiffServ Type 58 : IP ToS value = 232')
qosDiffServType59 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType59.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType59.setDescription('DiffServ Type 59 : IP ToS value = 236')
qosDiffServType60 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType60.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType60.setDescription('DiffServ Type 60 : IP ToS value = 240')
qosDiffServType61 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType61.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType61.setDescription('DiffServ Type 61 : IP ToS value = 244')
qosDiffServType62 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType62.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType62.setDescription('DiffServ Type 62 : IP ToS value = 248')
qosDiffServType63 = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 6, 1, 64), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: qosDiffServType63.setStatus('current')
if mibBuilder.loadTexts: qosDiffServType63.setDescription('DiffServ Type 63 : IP ToS value = 252')
sysQosScheduling = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 5))
qosSchedulingClassTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 5, 1), )
if mibBuilder.loadTexts: qosSchedulingClassTable.setStatus('current')
if mibBuilder.loadTexts: qosSchedulingClassTable.setDescription('A list of sysQosScheduling.')
qosSchedulingClassEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 5, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "qosSchedulingClassIndex"))
if mibBuilder.loadTexts: qosSchedulingClassEntry.setStatus('current')
if mibBuilder.loadTexts: qosSchedulingClassEntry.setDescription('A list of sysQosScheduling Weight.')
qosSchedulingClassIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosSchedulingClassIndex.setStatus('current')
if mibBuilder.loadTexts: qosSchedulingClassIndex.setDescription('A index of class 0 ~ 7.')
qosSchedulingWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 12, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127))).setMaxAccess("readonly")
if mibBuilder.loadTexts: qosSchedulingWeight.setStatus('current')
if mibBuilder.loadTexts: qosSchedulingWeight.setDescription('cos weight ')
sysSNTPSettingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17))
sntpTimeSeconds = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpTimeSeconds.setStatus('current')
if mibBuilder.loadTexts: sntpTimeSeconds.setDescription('This object is for setting the system time in seconds from Epoch (00:00:00 UTC, January 1, 2009). Notice : input value must larger than 284083276 (00:00:00 UTC, January 1, 2009) and smaller than 1136073599 (23:59:59 UTC, December 31, 2035).')
sntpPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpPollInterval.setStatus('current')
if mibBuilder.loadTexts: sntpPollInterval.setDescription('SNTP Poll Interval In Seconds (30-99999) ')
sntpGlobalState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("sntp", 1), ("local", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpGlobalState.setStatus('current')
if mibBuilder.loadTexts: sntpGlobalState.setDescription('Enable/Disable SNTP function in the system.')
sntpDSTOffset = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(30, 60, 90, 120))).clone(namedValues=NamedValues(("offset30min", 30), ("offset60min", 60), ("offset90min", 90), ("offset120min", 120)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpDSTOffset.setStatus('current')
if mibBuilder.loadTexts: sntpDSTOffset.setDescription('This object is for Daylight Saving Time Offset In (30/60/90/120) Minutes.')
sntpGMTMinutes = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpGMTMinutes.setStatus('current')
if mibBuilder.loadTexts: sntpGMTMinutes.setDescription('Specifies the Time Zone Offset from GMT in +/- Minutes. (+780 ~ -720)')
sntpDSTStartTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpDSTStartTime.setStatus('current')
if mibBuilder.loadTexts: sntpDSTStartTime.setDescription(' Daylight saving time (DST) is a system of setting clocks ahead so that both sunrise and sunset occur at a later hour. The effect is additional daylight in the evening. Many countries observe DST, although most have their own rules and regulations for when it begins and ends. The dates of DST may change from year to year. The Valid format [dayofmonth-month,HH:MM]. Example:- 01-Apr,17:30')
sntpDSTEndTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpDSTEndTime.setStatus('current')
if mibBuilder.loadTexts: sntpDSTEndTime.setDescription(' Daylight saving time (DST) is a system of setting clocks ahead so that both sunrise and sunset occur at a later hour. The effect is additional daylight in the evening. Many countries observe DST, although most have their own rules and regulations for when it begins and ends. The dates of DST may change from year to year. The Valid format [dayofmonth-month,HH:MM]. Example:- 01-Apr,17:30')
sntpDSTState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 17, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("annual", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpDSTState.setStatus('current')
if mibBuilder.loadTexts: sntpDSTState.setDescription('This object is for Annual(1) or Disabled(2) DST state in the system.')
sysSNTPServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 18))
sntpServerTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 18, 1), )
if mibBuilder.loadTexts: sntpServerTable.setStatus('current')
if mibBuilder.loadTexts: sntpServerTable.setDescription('The table contains configured SNTP/NTP servers in the system.')
sntpServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 18, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "sntpServerAddrType"), (0, "DGS-1100-10ME_A1", "sntpServerAddr"))
if mibBuilder.loadTexts: sntpServerEntry.setStatus('current')
if mibBuilder.loadTexts: sntpServerEntry.setDescription(' Each entry in the table contains necessary information to send SNTP request to the servers.')
sntpServerAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 18, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sntpServerAddrType.setStatus('current')
if mibBuilder.loadTexts: sntpServerAddrType.setDescription('The IP address type ipv4 or ipv6.')
sntpServerAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 18, 1, 1, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sntpServerAddr.setStatus('current')
if mibBuilder.loadTexts: sntpServerAddr.setDescription(' The unicast IPv4/IPv6 server address in the Unicast Addressing mode ')
sntpServerType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 18, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpServerType.setStatus('current')
if mibBuilder.loadTexts: sntpServerType.setDescription('In Unicast addressing mode, we can have primary and secondary servers. This flag is to distinguish between primary and secondary server. SNTP client sends request to different servers until it receives successful response. This flag tells the order in which to query the servers.')
sntpServerRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 20, 18, 1, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sntpServerRowStatus.setStatus('current')
if mibBuilder.loadTexts: sntpServerRowStatus.setDescription(' The activation of a row adds server entry. The destruction of a row removes server entry')
portSecurityTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 1), )
if mibBuilder.loadTexts: portSecurityTable.setStatus('current')
if mibBuilder.loadTexts: portSecurityTable.setDescription('A table to control port security features of the device.')
portSecurityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "portSecurityIndex"))
if mibBuilder.loadTexts: portSecurityEntry.setStatus('current')
if mibBuilder.loadTexts: portSecurityEntry.setDescription('An entry appears in port security table for each interface in the system.')
portSecurityIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecurityIndex.setStatus('current')
if mibBuilder.loadTexts: portSecurityIndex.setDescription('The interface index for which the configuration in this entry applies.')
portSecurityState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityState.setStatus('current')
if mibBuilder.loadTexts: portSecurityState.setDescription("Enable / disable port security admin state for the interface. A given ports' dynamic MAC address learning will be stopped such that the current source MAC addresses entered into the MAC address forwarding table can not be changed once the port security admin state is enabled.")
portSecurityMLA = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityMLA.setStatus('current')
if mibBuilder.loadTexts: portSecurityMLA.setDescription("Configures interface port security maximum learning address numbers. When given ports' admin state is enabled, allows forwarding table learning address number. The number can be set 0 to 64. Note: Set value 0 means cannot learn MAC address.")
portSecurityLockAddrMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("deleteOnReset", 1), ("deleteOnTimeout", 2), ("permanent", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecurityLockAddrMode.setStatus('current')
if mibBuilder.loadTexts: portSecurityLockAddrMode.setDescription('Configures port security lock address mode for the interface. deleteOnReset : The locked addresses will not age out until the Switch has been reset. deleteOnTimeout : The locked addresses will age out after the aging timer expires. Permanent : The locked addresses will not age out after the aging timer expires.')
portSecFDBPermanentTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 2), )
if mibBuilder.loadTexts: portSecFDBPermanentTable.setStatus('current')
if mibBuilder.loadTexts: portSecFDBPermanentTable.setDescription('A table to control port security FDB Permanent of the device.')
portSecFDBPermanentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "portSecFDBPermVlanID"), (0, "DGS-1100-10ME_A1", "portSecFDBPermMac"))
if mibBuilder.loadTexts: portSecFDBPermanentEntry.setStatus('current')
if mibBuilder.loadTexts: portSecFDBPermanentEntry.setDescription('An entry appears in port security table for each interface in the system.')
portSecFDBPermVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecFDBPermVlanID.setStatus('current')
if mibBuilder.loadTexts: portSecFDBPermVlanID.setDescription('The VLAN ID of the port security MAC entry.')
portSecFDBPermMac = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecFDBPermMac.setStatus('current')
if mibBuilder.loadTexts: portSecFDBPermMac.setDescription('The MAC address associated of the port security MAC entry.')
portSecFDBPermPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecFDBPermPort.setStatus('current')
if mibBuilder.loadTexts: portSecFDBPermPort.setDescription('The forwarding port of the port security MAC entry.')
portSecFDBPermType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 0), ("deleteOnReset", 1), ("deleteOnTimeout", 2), ("permanent", 3), ("invalid", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSecFDBPermType.setStatus('current')
if mibBuilder.loadTexts: portSecFDBPermType.setDescription('This object indicates the status of this entry. The default value is permanent(3). other(1) - this entry is currently in use but the conditions under which it will remain so are different from each of the following values. invalid(2) - writing this value to the object removes the corresponding entry. permanent(3) - this entry is currently in use and will remain so after the next reset of the bridge. deleteOnReset(4) - this entry is currently in use and will remain so until the next reset of the bridge. deleteOnTimeout(5) - this entry is currently in use and will remain so until it is aged out.')
portSecFDBPermEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portSecFDBPermEntryState.setStatus('current')
if mibBuilder.loadTexts: portSecFDBPermEntryState.setDescription('This object indicates the status of Port Security entry when the value of this boject is setted to false ,this specific enntry will be delete form dynamic FDB and Port Security Entry')
sysPortSecurityTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 12))
portSecurityTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 12, 0))
portSecurityViolation = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 12, 0, 1)).setObjects(("DGS-1100-10ME_A1", "portSecurityIndex"), ("DGS-1100-10ME_A1", "portSecurityMLA"))
if mibBuilder.loadTexts: portSecurityViolation.setStatus('current')
if mibBuilder.loadTexts: portSecurityViolation.setDescription('System SHOULD send out a trap message in violation that the learning entries exceeds the max learning address set of port security.')
sysMldsSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 1))
sysMldsVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3))
sysMldsHost = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 4))
mldsStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsStatus.setStatus('current')
if mibBuilder.loadTexts: mldsStatus.setDescription("Enables or disables MLD snooping in the system. When set to 'enabled', the MLDS module starts protocol operations. When set to 'disabled', the MLDS module stops performing protocol operations.")
mldsVlanRouterTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 3), )
if mibBuilder.loadTexts: mldsVlanRouterTable.setStatus('current')
if mibBuilder.loadTexts: mldsVlanRouterTable.setDescription('This table contains the list of ports through which a router, in a particular VLAN is reachable.')
mldsVlanRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "mldsVlanRouterVlanId"))
if mibBuilder.loadTexts: mldsVlanRouterEntry.setStatus('current')
if mibBuilder.loadTexts: mldsVlanRouterEntry.setDescription('Contains the VLAN ID and list of ports on which routers are present in the VLAN.')
mldsVlanRouterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanRouterVlanId.setStatus('current')
if mibBuilder.loadTexts: mldsVlanRouterVlanId.setDescription('VLAN ID of the ports through which router is reachable.')
mldsVlanRouterStaticPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 3, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanRouterStaticPortList.setStatus('current')
if mibBuilder.loadTexts: mldsVlanRouterStaticPortList.setDescription('List of static ports on which routers are present. These router ports are learnt through control messages received from routers, and can also be configured statically.')
mldsVlanRouterDynamicPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 3, 1, 3), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanRouterDynamicPortList.setStatus('current')
if mibBuilder.loadTexts: mldsVlanRouterDynamicPortList.setDescription('List of dynamic ports on which routers are present. These router ports are learnt through control messages received from routers, and can also be configured statically.')
mldsVlanFilterTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4), )
if mibBuilder.loadTexts: mldsVlanFilterTable.setStatus('current')
if mibBuilder.loadTexts: mldsVlanFilterTable.setDescription('This table contains configuration of snooping on specific Vlans. This Table is valid only when VLAN is enabled in the system.')
mldsVlanFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "mldsVlanFilterVlanId"))
if mibBuilder.loadTexts: mldsVlanFilterEntry.setStatus('current')
if mibBuilder.loadTexts: mldsVlanFilterEntry.setDescription('Contains snooping status , version and fast leave configuration for a specific VLAN.')
mldsVlanFilterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanFilterVlanId.setStatus('current')
if mibBuilder.loadTexts: mldsVlanFilterVlanId.setDescription('Index of MldsVlanFilterEntry. This object indicates the VLAN ID for which the snooping configurations in MldsVlanFilterEntry is to be done.')
mldsVlanSnoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanSnoopStatus.setStatus('current')
if mibBuilder.loadTexts: mldsVlanSnoopStatus.setDescription('This object allows you to enable/disable MLDS function on a specific VLAN.')
mldsVlanQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanQuerier.setStatus('current')
if mibBuilder.loadTexts: mldsVlanQuerier.setDescription('Indicates whether the switch is configured as a querier in the VLAN')
mldsVlanCfgQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanCfgQuerier.setStatus('current')
if mibBuilder.loadTexts: mldsVlanCfgQuerier.setDescription("The snooping switch can be configured as a querier via this object to send out MLD general queries when IGMP routers are not present in the VLAN. When set to 'enabled', the switch will generate general queries.")
mldsVlanQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanQueryInterval.setStatus('current')
if mibBuilder.loadTexts: mldsVlanQueryInterval.setDescription('This is the interval (in seconds) for which the switch sends general queries when it is configured as a querier for the VLAN. A switch should be configured as a querier for a VLAN only when there is no queriers in the network.')
mldsVlanFastLeave = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanFastLeave.setStatus('current')
if mibBuilder.loadTexts: mldsVlanFastLeave.setDescription("Enables or disables fast leave for the VLAN. When it is 'disabled',on reception of a leave message, the switch checks if they are any interested receivers for the group by sending a group specific query before removing the port from the forwarding table. If set to 'enabled', the switch does not send a group specific query and immediately removes the port from the forwarding table.")
mldsVlanQuerierVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("v1", 1), ("v2", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanQuerierVersion.setStatus('current')
if mibBuilder.loadTexts: mldsVlanQuerierVersion.setDescription('This object allows you to set igmp version function on a specific VLAN.')
mldsVlanRouterPortPurgeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanRouterPortPurgeInterval.setStatus('current')
if mibBuilder.loadTexts: mldsVlanRouterPortPurgeInterval.setDescription("This is the interval (in seconds) after which a learnt router port entry will be purged for a specific VLAN. For each router port learnt, this timer runs for 'RouterPortPurgeInterval' seconds.When the timer expires, the learnt router port entry is purged. However if control messages are received from the router before the timer expiry, then the timer is restarted.")
mldsVlanHostPortPurgeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(130, 153025)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanHostPortPurgeInterval.setStatus('current')
if mibBuilder.loadTexts: mldsVlanHostPortPurgeInterval.setDescription("This is the interval (in seconds) after which a learnt port entry will be purged for a specific VLAN. For each port on which report has been received this timer runs for 'PortPurgeInterval' seconds. This timer will be restarted whenever a report message is received from a host on the specific port. If the timer expires, then , the learnt port entry will be purged from the multicast group.")
mldsVlanRobustnessValue = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanRobustnessValue.setStatus('current')
if mibBuilder.loadTexts: mldsVlanRobustnessValue.setDescription("When the switch receives leave message on a port, it sends group specific query to check if there are any other interested receivers for the group. This attribute defines the maximum number for a specific VLAN queries sent by the switch before deleting the port from the group membership information in the forwarding database. If the maximum retry count exceeds 'RobustnessValue', then the port will be deleted from the multicast group membership information in the forwarding database and received leave message will be forwarded onto the router ports if there are no interested receivers for the group.")
mldsVlanGrpQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanGrpQueryInterval.setStatus('current')
if mibBuilder.loadTexts: mldsVlanGrpQueryInterval.setDescription("The value of this attribute defines the time period with which the specific VLAN will send group specific queries on a port to check if there is any interested receivers. The switch will send 'RobustnessValue' queries before removing the port from the group membership information in the forwarding database.")
mldsVlanQueryMaxResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 25)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mldsVlanQueryMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: mldsVlanQueryMaxResponseTime.setDescription('The maximum query response time advertised General queries on this interface.')
mldsVlanMulticastGroupTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 5), )
if mibBuilder.loadTexts: mldsVlanMulticastGroupTable.setStatus('current')
if mibBuilder.loadTexts: mldsVlanMulticastGroupTable.setDescription('This table contains MAC based multicast forwarding information.')
mldsVlanMulticastGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 5, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "mldsVlanMulticastGroupVlanId"), (0, "DGS-1100-10ME_A1", "mldsVlanMulticastGroupIpAddress"))
if mibBuilder.loadTexts: mldsVlanMulticastGroupEntry.setStatus('current')
if mibBuilder.loadTexts: mldsVlanMulticastGroupEntry.setDescription('This table contains VLAN ID, multicast group MAC address and the list of ports onto which the multicast data packets for group should be forwarded.')
mldsVlanMulticastGroupVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanMulticastGroupVlanId.setStatus('current')
if mibBuilder.loadTexts: mldsVlanMulticastGroupVlanId.setDescription('VLAN ID pertaining to the Multicast forwarding entry')
mldsVlanMulticastGroupIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 5, 1, 2), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanMulticastGroupIpAddress.setStatus('current')
if mibBuilder.loadTexts: mldsVlanMulticastGroupIpAddress.setDescription('Multicast group IP address. This object indicates that a multicast group address was learned in the switch and be represented as IP address format.')
mldsVlanMulticastGroupMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 5, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanMulticastGroupMacAddress.setStatus('current')
if mibBuilder.loadTexts: mldsVlanMulticastGroupMacAddress.setDescription('Multicast group MAC address. This object indicates that a multicast group address was learned in the switch and be represented as MAC address format.')
mldsVlanMulticastGroupPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 3, 5, 1, 4), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsVlanMulticastGroupPortList.setStatus('current')
if mibBuilder.loadTexts: mldsVlanMulticastGroupPortList.setDescription('List of ports onto which the multicast data packets destined for this group will be forwarded.')
mldsHostTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 4, 1), )
if mibBuilder.loadTexts: mldsHostTable.setStatus('current')
if mibBuilder.loadTexts: mldsHostTable.setDescription('This table is used to manage the mld snooping Host based Fast Leave function of the switch.')
mldsHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 4, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "mldsHostTableVLANID"), (0, "DGS-1100-10ME_A1", "mldsHostTableGroupAddress"), (0, "DGS-1100-10ME_A1", "mldsHostTablePort"), (0, "DGS-1100-10ME_A1", "mldsHostTableHostIPAddress"))
if mibBuilder.loadTexts: mldsHostEntry.setStatus('current')
if mibBuilder.loadTexts: mldsHostEntry.setDescription('Contains management entities for mld snooping Host based function.')
mldsHostTableVLANID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsHostTableVLANID.setStatus('current')
if mibBuilder.loadTexts: mldsHostTableVLANID.setDescription('VLAN ID of mld snooping Host table entry.')
mldsHostTableGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 4, 1, 1, 2), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsHostTableGroupAddress.setStatus('current')
if mibBuilder.loadTexts: mldsHostTableGroupAddress.setDescription('Group address of mld snooping Host table entry.')
mldsHostTablePort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 4, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsHostTablePort.setStatus('current')
if mibBuilder.loadTexts: mldsHostTablePort.setDescription('Port number of mld snooping Host table entry.')
mldsHostTableHostIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 88, 4, 1, 1, 4), Ipv6Address()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mldsHostTableHostIPAddress.setStatus('current')
if mibBuilder.loadTexts: mldsHostTableHostIPAddress.setDescription('Host IP address of Group in mld snooping Host table entry.')
sysStaticMacTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 1), )
if mibBuilder.loadTexts: sysStaticMacTable.setStatus('current')
if mibBuilder.loadTexts: sysStaticMacTable.setDescription('A list of the Static MACs')
staticMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "staticMacVlanID"), (0, "DGS-1100-10ME_A1", "staticMacAddr"))
if mibBuilder.loadTexts: staticMacEntry.setStatus('current')
if mibBuilder.loadTexts: staticMacEntry.setDescription('A Static MAC entry containing the mac and forwarding port.')
staticMacVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staticMacVlanID.setStatus('current')
if mibBuilder.loadTexts: staticMacVlanID.setDescription('The VLAN ID of the static MAC entry.')
staticMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staticMacAddr.setStatus('current')
if mibBuilder.loadTexts: staticMacAddr.setDescription('The MAC address associated of the static MAC entry.')
staticMacPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: staticMacPort.setStatus('current')
if mibBuilder.loadTexts: staticMacPort.setDescription('The forwarding port of the static MAC entry.')
staticMacStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: staticMacStatus.setStatus('current')
if mibBuilder.loadTexts: staticMacStatus.setDescription('The status of an entry in the Static MAC Table. Only a subset of the rowstatus variables (active, createAndGo, destroy) are available. The trunk member port can not set up static MAC.')
sysDynamicFdbTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 2), )
if mibBuilder.loadTexts: sysDynamicFdbTable.setReference('IEEE 802.1Q/D11 Section 12.7.7')
if mibBuilder.loadTexts: sysDynamicFdbTable.setStatus('current')
if mibBuilder.loadTexts: sysDynamicFdbTable.setDescription('A table that contains information about unicast entries for which the device has forwarding and/or filtering information. This information is used by the transparent bridging function in determining how to propagate a received frame. This table maintains context ID as one more index to support Multiple Instances.')
sysDynamicFdbEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "dynamicFdbId"), (0, "DGS-1100-10ME_A1", "dynamicFdbMacAddr"))
if mibBuilder.loadTexts: sysDynamicFdbEntry.setStatus('current')
if mibBuilder.loadTexts: sysDynamicFdbEntry.setDescription('Information about a specific unicast MAC address for which the device has some forwarding and/or filtering information.')
dynamicFdbId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 2, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dynamicFdbId.setStatus('current')
if mibBuilder.loadTexts: dynamicFdbId.setDescription('The identity of this Filtering Database.')
dynamicFdbMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 2, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dynamicFdbMacAddr.setStatus('current')
if mibBuilder.loadTexts: dynamicFdbMacAddr.setDescription('A unicast MAC address for which the device has forwarding and/or filtering information.')
dynamicFdbPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dynamicFdbPort.setStatus('current')
if mibBuilder.loadTexts: dynamicFdbPort.setDescription("The port number of the port on which a frame having a source address equal to the value of the corresponding instance of dynamicFdbMacAddr has been seen.If the port is LA port, will show 'po' before port.")
dynamicFdbStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("other", 1), ("invalid", 2), ("dynamic", 3), ("self", 4), ("static", 5), ("deleteOnReset", 6), ("deleteOnTimeout", 7), ("permanent", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dynamicFdbStatus.setStatus('current')
if mibBuilder.loadTexts: dynamicFdbStatus.setDescription("The status of this entry. The meanings of the values are: other(1) - none of the following. This may include the case where some other MIB object (not the corresponding instance of dynamicFdbPort, nor an entry in the fsDot1qStaticUnicastTable) is being used to determine if and how frames addressed to the value of the corresponding instance of dynamicFdbMacAddr are being forwarded. invalid(2) - this entry is no longer valid (e.g., it was learned but has since aged out), but has not yet been flushed from the table. learned(3) - the value of the corresponding instance of dynamicFdbPort was learned and is being used. self(4) - the value of the corresponding instance of dynamicFdbMacAddr represents one of the device's addresses. The corresponding instance of dynamicFdbPort indicates which of the device's ports has this address. static(5) - the value of the corresponding instance of dynamicFdbMacAddr is also the value of an existing instance of fsDot1qStaticAddress. deleteOnReset(6) - the value of the corresponding instance of fsDot1qTpFdbAddress and the port of this entry enablement Port security and set Lock address mode to Delete on Reset. deleteOnTimeout(7) - the value of the corresponding instance of fsDot1qTpFdbAddress and the port of this entry enablement Port security and set Lock address mode to Delete on TimeOut. permanent(8) - the value of the corresponding instance of fsDot1qTpFdbAddress and the port of this entry enablement Port security and set Lock address mode to Permanent.")
sysFdbClear = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 3))
sysFdbClearId = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 3, 1), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysFdbClearId.setStatus('current')
if mibBuilder.loadTexts: sysFdbClearId.setDescription('Fdb clear object identification: If cmFdbClearAction is clear by port, then this value is a port number; If cmFdbClearAction is clear by vlan, then this value is a port vlan id; otherwise this value is not used.')
sysFdbClearAction = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 9, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clearAll", 1), ("clearByVlanId", 2), ("clearByPort", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysFdbClearAction.setStatus('current')
if mibBuilder.loadTexts: sysFdbClearAction.setDescription('Fdb clear action identification: ClearAll to clear all fdb entries; ClearClearAllByVlanId clear all fdb entries that belong to specified vlan id; ClearAllByPort clear all fdb entries that belong to specified port')
syslimitIPMulticastProfileTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 1), )
if mibBuilder.loadTexts: syslimitIPMulticastProfileTable.setStatus('current')
if mibBuilder.loadTexts: syslimitIPMulticastProfileTable.setDescription('A list of the limit ip multicast Profile Table.')
limitIPMulticastProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "limitIPMulticastProfileID"), (0, "DGS-1100-10ME_A1", "limitIPMulticastIPType"))
if mibBuilder.loadTexts: limitIPMulticastProfileEntry.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastProfileEntry.setDescription('A limit ip multicast entry maintain by the start IP Address, end ip address, profile id.')
limitIPMulticastProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIPMulticastProfileID.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastProfileID.setDescription('The ProfileID of the limit ip multicast profile entry.')
limitIPMulticastIPType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIPMulticastIPType.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastIPType.setDescription('Indicate the IP type of profile.')
limitIPMulticastProfileName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: limitIPMulticastProfileName.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastProfileName.setDescription('The ProfileName of the limit ip multicast profile entry.')
limitIPMulticastProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: limitIPMulticastProfileStatus.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastProfileStatus.setDescription('The status of an entry in the limit ip multicast profile Table. Only a subset of the rowstatus variables (active, createAndGo, destroy) are available.')
syslimitIPMulticastPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 3), )
if mibBuilder.loadTexts: syslimitIPMulticastPortTable.setStatus('current')
if mibBuilder.loadTexts: syslimitIPMulticastPortTable.setDescription('A list of the limit ip multicast Port entry Table.')
limitIPMulticastPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "limitIPMulticastPortID"), (0, "DGS-1100-10ME_A1", "limitIPMulticastPortIPType"))
if mibBuilder.loadTexts: limitIPMulticastPortEntry.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastPortEntry.setDescription('A limit ip multicast entry maintain by the Port Index.')
limitIPMulticastPortID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIPMulticastPortID.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastPortID.setDescription('The Port Index of the limit ip multicast port entry.')
limitIPMulticastPortIPType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIPMulticastPortIPType.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastPortIPType.setDescription('Indicate the IP type of entry.')
limitIPMulticastPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: limitIPMulticastPortState.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastPortState.setDescription('The limit ip multicast port state')
limitIPMulticastPortProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 3, 1, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: limitIPMulticastPortProfileID.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastPortProfileID.setDescription('The limit ip multicast port mapping profileID list.')
limitIPMulticastPortMaxGrp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 3, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: limitIPMulticastPortMaxGrp.setStatus('current')
if mibBuilder.loadTexts: limitIPMulticastPortMaxGrp.setDescription('The limit ip multicast per-port max group.')
limitIpMulticastRangeTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 4), )
if mibBuilder.loadTexts: limitIpMulticastRangeTable.setStatus('current')
if mibBuilder.loadTexts: limitIpMulticastRangeTable.setDescription('A list of the limit ip multicast entry Table.')
limitIpMulticastRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "limitIpMulticastRangeProfileID"), (0, "DGS-1100-10ME_A1", "limitIpMulticastRangeIPType"), (0, "DGS-1100-10ME_A1", "limitIpMulticastRangeStartIpAddr"), (0, "DGS-1100-10ME_A1", "limitIpMulticastRangeEndIpAddr"))
if mibBuilder.loadTexts: limitIpMulticastRangeEntry.setStatus('current')
if mibBuilder.loadTexts: limitIpMulticastRangeEntry.setDescription('A limit ip multicast entry maintain by the start IP Address, end ip address, profile id.')
limitIpMulticastRangeProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIpMulticastRangeProfileID.setStatus('current')
if mibBuilder.loadTexts: limitIpMulticastRangeProfileID.setDescription('The ProfileID of the limit ip multicast entry.')
limitIpMulticastRangeIPType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIpMulticastRangeIPType.setStatus('current')
if mibBuilder.loadTexts: limitIpMulticastRangeIPType.setDescription('Indicate the IP type of entry.')
limitIpMulticastRangeStartIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 4, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIpMulticastRangeStartIpAddr.setStatus('current')
if mibBuilder.loadTexts: limitIpMulticastRangeStartIpAddr.setDescription('The limit ip multicast IP address is used to set start ip')
limitIpMulticastRangeEndIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 4, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: limitIpMulticastRangeEndIpAddr.setStatus('current')
if mibBuilder.loadTexts: limitIpMulticastRangeEndIpAddr.setDescription('The limit ip multicast IP address is used to set end ip')
limitIpMulticastRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 45, 4, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: limitIpMulticastRangeStatus.setStatus('current')
if mibBuilder.loadTexts: limitIpMulticastRangeStatus.setDescription('The status of an entry in the limit ip multicast entry Table. Only a subset of the rowstatus variables (active, createAndGo, destroy) are available.')
sysMirrorStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMirrorStatus.setStatus('current')
if mibBuilder.loadTexts: sysMirrorStatus.setDescription('Enable/Disable Port Mirroring function. Default is disabled. Port Mirroring is a method of monitoring network traffic that forwards a copy of each incoming and/or outgoing packet from one port of the Switch to another port where the packet can be studied.')
sysMirrorPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 2), )
if mibBuilder.loadTexts: sysMirrorPortTable.setStatus('current')
if mibBuilder.loadTexts: sysMirrorPortTable.setDescription('Provides control to enable or disable mirroring of ingress or Egress traffic over this interface to the mirrored-to port.')
mirrorPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "mirrorTargetIfIndex"))
if mibBuilder.loadTexts: mirrorPortEntry.setStatus('current')
if mibBuilder.loadTexts: mirrorPortEntry.setDescription('Provides control to enable or disable mirroring of ingress traffic over this interface to the mirrored-to port.')
mirrorTargetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mirrorTargetIfIndex.setStatus('current')
if mibBuilder.loadTexts: mirrorTargetIfIndex.setDescription('Specifies the port to which the mirrored traffic in the system is to be copied.')
mirrorTargetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 2, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorTargetPort.setStatus('current')
if mibBuilder.loadTexts: mirrorTargetPort.setDescription('Specifies the port to which the mirrored traffic in the system is to be copied.')
mirrorIngressPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 2, 1, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorIngressPortList.setStatus('current')
if mibBuilder.loadTexts: mirrorIngressPortList.setDescription('Provides control to enable or disable mirroring of ingress traffic over this interface to the mirrored-to port.')
mirrorEgressPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 2, 1, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorEgressPortList.setStatus('current')
if mibBuilder.loadTexts: mirrorEgressPortList.setDescription('Provides control to enable or disable mirroring of egress traffic over this interface to the mirrored-to port.')
mirrorCtrlRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 18, 2, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mirrorCtrlRowStatus.setStatus('current')
if mibBuilder.loadTexts: mirrorCtrlRowStatus.setDescription('Specifies the validity of the entry, max entry number is 4.')
sysMulticastFilterPortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 49, 1), )
if mibBuilder.loadTexts: sysMulticastFilterPortTable.setStatus('current')
if mibBuilder.loadTexts: sysMulticastFilterPortTable.setDescription('A table to control multicast filtering modes.')
multicastFilterPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 49, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "multicastFilterPortIndex"))
if mibBuilder.loadTexts: multicastFilterPortEntry.setStatus('current')
if mibBuilder.loadTexts: multicastFilterPortEntry.setDescription('An entry appears in this table for each interface in the mcastFiltertem. Index to the table is the interface index of the port.')
multicastFilterPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 49, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: multicastFilterPortIndex.setStatus('current')
if mibBuilder.loadTexts: multicastFilterPortIndex.setDescription('Interface index of the port for which the configuration in this entry applies.')
multicastFilterPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 49, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("forward", 0), ("filter", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: multicastFilterPortType.setStatus('current')
if mibBuilder.loadTexts: multicastFilterPortType.setDescription('Configures the multicast filtering modes as below : forward -Forwards all unregistered groups. filter -Filters all unregistered groups.')
sysStaticMcastTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 19, 1), )
if mibBuilder.loadTexts: sysStaticMcastTable.setStatus('current')
if mibBuilder.loadTexts: sysStaticMcastTable.setDescription('A list of the Static MACs')
staticMcastEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 19, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "staticMcastVlanID"), (0, "DGS-1100-10ME_A1", "staticMcastMac"), (0, "DGS-1100-10ME_A1", "staticMcastEgressPorts"))
if mibBuilder.loadTexts: staticMcastEntry.setStatus('current')
if mibBuilder.loadTexts: staticMcastEntry.setDescription('A Static MAC entry containing the mac and forwarding port.')
staticMcastVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 19, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staticMcastVlanID.setStatus('current')
if mibBuilder.loadTexts: staticMcastVlanID.setDescription('The VLAN ID of the static MAC entry.')
staticMcastMac = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 19, 1, 1, 2), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staticMcastMac.setStatus('current')
if mibBuilder.loadTexts: staticMcastMac.setDescription('The MAC address associated of the static MAC entry.')
staticMcastEgressPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 19, 1, 1, 3), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: staticMcastEgressPorts.setReference('IEEE 802.1Q/D11 Section 12.7.7.3, 11.2.3.2.3')
if mibBuilder.loadTexts: staticMcastEgressPorts.setStatus('current')
if mibBuilder.loadTexts: staticMcastEgressPorts.setDescription('The set of ports to which frames received from a specific port and destined for a specific Multicast or Broadcast MAC address must be forwarded, regardless of any dynamic information e.g. from GMRP. A port may not be added in this set if it is already a member of the set of ports in dot1qStaticMulticastForbiddenEgressPorts. The default value of this object is a string of ones of appropriate length.')
staticMcastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 19, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: staticMcastStatus.setStatus('current')
if mibBuilder.loadTexts: staticMcastStatus.setDescription('The status of an entry in the Static Mcast Table. Only a subset of the rowstatus variables (active, createAndGo, destroy) are available.')
sysDDPStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 101, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDDPStatus.setStatus('current')
if mibBuilder.loadTexts: sysDDPStatus.setDescription('Enable/Disable DDP function.')
sysDDPReportTime = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 101, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 30, 60, 90, 120))).clone(namedValues=NamedValues(("never", 0), ("offset30sec", 30), ("offset60sec", 60), ("offset90sec", 90), ("offset120sec", 120))).clone('never')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysDDPReportTime.setStatus('current')
if mibBuilder.loadTexts: sysDDPReportTime.setDescription('Set DDP report time seconds.')
sysDDPTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 101, 3), )
if mibBuilder.loadTexts: sysDDPTable.setStatus('current')
if mibBuilder.loadTexts: sysDDPTable.setDescription('Define sysDDPTable for per port settings.')
ddpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 101, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "ddpPort"))
if mibBuilder.loadTexts: ddpEntry.setStatus('current')
if mibBuilder.loadTexts: ddpEntry.setDescription('Define sysDDPTable for per port settings.')
ddpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 101, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ddpPort.setStatus('current')
if mibBuilder.loadTexts: ddpPort.setDescription('This object indicates the port index.')
ddpPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 101, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ddpPortStatus.setStatus('current')
if mibBuilder.loadTexts: ddpPortStatus.setDescription('This object indicates DDP status is enabled or disabled.')
sysEee = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 60, 1))
eeeTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 60, 1, 1), )
if mibBuilder.loadTexts: eeeTable.setStatus('current')
if mibBuilder.loadTexts: eeeTable.setDescription('A table that contains EEE status about each port.')
eeeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 60, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "eeePort"))
if mibBuilder.loadTexts: eeeEntry.setStatus('current')
if mibBuilder.loadTexts: eeeEntry.setDescription('A list of EEE status for each port.')
eeePort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 60, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eeePort.setStatus('current')
if mibBuilder.loadTexts: eeePort.setDescription('This object indicates the port index.')
eeestatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 60, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eeestatus.setStatus('current')
if mibBuilder.loadTexts: eeestatus.setDescription('This object indicates the port eee status.')
sysPppoeGlobalState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPppoeGlobalState.setStatus('current')
if mibBuilder.loadTexts: sysPppoeGlobalState.setDescription('PPPoE global state')
sysPppoePortTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98, 2), )
if mibBuilder.loadTexts: sysPppoePortTable.setStatus('current')
if mibBuilder.loadTexts: sysPppoePortTable.setDescription('A table to control PPPoE features of the device.')
pppoePortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "pppoePortIndex"))
if mibBuilder.loadTexts: pppoePortEntry.setStatus('current')
if mibBuilder.loadTexts: pppoePortEntry.setDescription('An entry appears in PPPoE table for each interface in the system.')
pppoePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pppoePortIndex.setStatus('current')
if mibBuilder.loadTexts: pppoePortIndex.setDescription('Interface index of the port for the configuration in this entry applies.')
pppoePortState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoePortState.setStatus('current')
if mibBuilder.loadTexts: pppoePortState.setDescription('PPPoE per port state')
pppoePortCircuitIDType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("mac", 2), ("udf", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoePortCircuitIDType.setStatus('current')
if mibBuilder.loadTexts: pppoePortCircuitIDType.setDescription('PPPoE per port circuit ID type')
pppoePortUDFString = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 98, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pppoePortUDFString.setStatus('current')
if mibBuilder.loadTexts: pppoePortUDFString.setDescription('PPPoE per port UDF string')
sysIgsSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 1))
sysIgsVlan = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3))
sysIgsAccessAuth = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 5))
sysIgsHost = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 6))
igsStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsStatus.setStatus('current')
if mibBuilder.loadTexts: igsStatus.setDescription("Enables or disables IGMP snooping in the system. When set to 'enabled', the IGS module starts protocol operations. When set to 'disabled', the IGS module stops performing protocol operations.")
igsReportForwardRouterOnly = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsReportForwardRouterOnly.setStatus('current')
if mibBuilder.loadTexts: igsReportForwardRouterOnly.setDescription("Enables or disables IGMP snooping in the system. When set to 'enabled', the IGS module forwards report packets to router port only. When set to 'disabled', the IGS module forwards report packets to all port.")
igsVlanRouterTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 3), )
if mibBuilder.loadTexts: igsVlanRouterTable.setStatus('current')
if mibBuilder.loadTexts: igsVlanRouterTable.setDescription('This table contains the list of ports through which a router, in a particular VLAN is reachable.')
igsVlanRouterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "igsVlanRouterVlanId"))
if mibBuilder.loadTexts: igsVlanRouterEntry.setStatus('current')
if mibBuilder.loadTexts: igsVlanRouterEntry.setDescription('Contains the VLAN ID and list of ports on which routers are present in the VLAN.')
igsVlanRouterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanRouterVlanId.setStatus('current')
if mibBuilder.loadTexts: igsVlanRouterVlanId.setDescription('VLAN ID of the ports through which router is reachable.')
igsVlanRouterStaticPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 3, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanRouterStaticPortList.setStatus('current')
if mibBuilder.loadTexts: igsVlanRouterStaticPortList.setDescription('List of static ports on which routers are present. These router ports are learnt through control messages received from routers, and can also be configured statically.')
igsVlanRouterDynamicPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 3, 1, 3), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanRouterDynamicPortList.setStatus('current')
if mibBuilder.loadTexts: igsVlanRouterDynamicPortList.setDescription('List of dynamic ports on which routers are present. These router ports are learnt through control messages received from routers, and can also be configured statically.')
igsVlanFilterTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4), )
if mibBuilder.loadTexts: igsVlanFilterTable.setStatus('current')
if mibBuilder.loadTexts: igsVlanFilterTable.setDescription('This table contains configuration of snooping on specific Vlans. This Table is valid only when VLAN is enabled in the system.')
igsVlanFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "igsVlanFilterVlanId"))
if mibBuilder.loadTexts: igsVlanFilterEntry.setStatus('current')
if mibBuilder.loadTexts: igsVlanFilterEntry.setDescription('Contains snooping status , version and fast leave configuration for a specific VLAN.')
igsVlanFilterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanFilterVlanId.setStatus('current')
if mibBuilder.loadTexts: igsVlanFilterVlanId.setDescription('Index of IgsVlanFilterEntry. This object indicates the VLAN ID for which the snooping configurations in IgsVlanFilterEntry is to be done.')
igsVlanSnoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanSnoopStatus.setStatus('current')
if mibBuilder.loadTexts: igsVlanSnoopStatus.setDescription('This object allows you to enable/disable IGS function on a specific VLAN.')
igsVlanQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanQuerier.setStatus('current')
if mibBuilder.loadTexts: igsVlanQuerier.setDescription('Indicates whether the switch is configured as a querier in the VLAN')
igsVlanCfgQuerier = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanCfgQuerier.setStatus('current')
if mibBuilder.loadTexts: igsVlanCfgQuerier.setDescription("The snooping switch can be configured as a querier via this object to send out IGMP general queries when IGMP routers are not present in the VLAN. When set to 'enabled', the switch will generate general queries.")
igsVlanQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanQueryInterval.setStatus('current')
if mibBuilder.loadTexts: igsVlanQueryInterval.setDescription('This is the interval (in seconds) for which the switch sends general queries when it is configured as a querier for the VLAN. A switch should be configured as a querier for a VLAN only when there is no queriers in the network.')
igsVlanFastLeave = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanFastLeave.setStatus('current')
if mibBuilder.loadTexts: igsVlanFastLeave.setDescription("Enables or disables fast leave for the VLAN. When it is 'disabled',on reception of a leave message, the switch checks if they are any interested receivers for the group by sending a group specific query before removing the port from the forwarding table. If set to 'enabled', the switch does not send a group specific query and immediately removes the port from the forwarding table.")
igsVlanQuerierVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("igmp_v1", 1), ("igmp_v2", 2), ("igmp_v3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanQuerierVersion.setStatus('current')
if mibBuilder.loadTexts: igsVlanQuerierVersion.setDescription('This object allows you to set igmp version function on a specific VLAN.')
igsVlanRouterPortPurgeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(60, 600)).clone(125)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanRouterPortPurgeInterval.setStatus('current')
if mibBuilder.loadTexts: igsVlanRouterPortPurgeInterval.setDescription("This is the interval (in seconds) after which a learnt router port entry will be purged for a specific VLAN. For each router port learnt, this timer runs for 'RouterPortPurgeInterval' seconds.When the timer expires, the learnt router port entry is purged. However if control messages are received from the router before the timer expiry, then the timer is restarted.")
igsVlanHostPortPurgeInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(130, 153025)).clone(260)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanHostPortPurgeInterval.setStatus('current')
if mibBuilder.loadTexts: igsVlanHostPortPurgeInterval.setDescription("This is the interval (in seconds) after which a learnt port entry will be purged for a specific VLAN. For each port on which report has been received this timer runs for 'PortPurgeInterval' seconds. This timer will be restarted whenever a report message is received from a host on the specific port. If the timer expires, then , the learnt port entry will be purged from the multicast group.")
igsVlanRobustnessValue = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanRobustnessValue.setStatus('current')
if mibBuilder.loadTexts: igsVlanRobustnessValue.setDescription("When the switch receives leave message on a port, it sends group specific query to check if there are any other interested receivers for the group. This attribute defines the maximum number for a specific VLAN queries sent by the switch before deleting the port from the group membership information in the forwarding database. If the maximum retry count exceeds 'RobustnessValue', then the port will be deleted from the multicast group membership information in the forwarding database and received leave message will be forwarded onto the router ports if there are no interested receivers for the group.")
igsVlanGrpQueryInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 25)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanGrpQueryInterval.setStatus('current')
if mibBuilder.loadTexts: igsVlanGrpQueryInterval.setDescription("The value of this attribute defines the time period with which the specific VLAN will send group specific queries on a port to check if there is any interested receivers. The switch will send 'RobustnessValue' queries before removing the port from the group membership information in the forwarding database.")
igsVlanQueryMaxResponseTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 4, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 25)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsVlanQueryMaxResponseTime.setStatus('current')
if mibBuilder.loadTexts: igsVlanQueryMaxResponseTime.setDescription('The maximum query response time advertised General queries on this interface.')
igsVlanMulticastGroupTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 5), )
if mibBuilder.loadTexts: igsVlanMulticastGroupTable.setStatus('current')
if mibBuilder.loadTexts: igsVlanMulticastGroupTable.setDescription('This table contains MAC based multicast forwarding information.')
igsVlanMulticastGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 5, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "igsVlanMulticastGroupVlanId"), (0, "DGS-1100-10ME_A1", "igsVlanMulticastGroupIpAddress"))
if mibBuilder.loadTexts: igsVlanMulticastGroupEntry.setStatus('current')
if mibBuilder.loadTexts: igsVlanMulticastGroupEntry.setDescription('This table contains VLAN ID, multicast group MAC address and the list of ports onto which the multicast data packets for group should be forwarded.')
igsVlanMulticastGroupVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanMulticastGroupVlanId.setStatus('current')
if mibBuilder.loadTexts: igsVlanMulticastGroupVlanId.setDescription('VLAN ID pertaining to the Multicast forwarding entry')
igsVlanMulticastGroupIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 5, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanMulticastGroupIpAddress.setStatus('current')
if mibBuilder.loadTexts: igsVlanMulticastGroupIpAddress.setDescription('Multicast group IP address. This object indicates that a multicast group address was learned in the switch and be represented as IP address format.')
igsVlanMulticastGroupMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 5, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanMulticastGroupMacAddress.setStatus('current')
if mibBuilder.loadTexts: igsVlanMulticastGroupMacAddress.setDescription('Multicast group MAC address. This object indicates that a multicast group address was learned in the switch and be represented as MAC address format.')
igsVlanMulticastGroupPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 3, 5, 1, 4), PortList()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsVlanMulticastGroupPortList.setStatus('current')
if mibBuilder.loadTexts: igsVlanMulticastGroupPortList.setDescription('List of ports onto which the multicast data packets destined for this group will be forwarded.')
igsAccessAuthTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 5, 1), )
if mibBuilder.loadTexts: igsAccessAuthTable.setStatus('current')
if mibBuilder.loadTexts: igsAccessAuthTable.setDescription('This table is used to manage the IGMP Authentication function of the switch.')
igsAccessAuthEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 5, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "igsAccessAuthPortIndex"))
if mibBuilder.loadTexts: igsAccessAuthEntry.setStatus('current')
if mibBuilder.loadTexts: igsAccessAuthEntry.setDescription('Contains management entities for IGMP Authentication function.')
igsAccessAuthPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsAccessAuthPortIndex.setStatus('current')
if mibBuilder.loadTexts: igsAccessAuthPortIndex.setDescription('The port index of igsAccessAuthTable which indicates the port to be configured.')
igsAccessAuthState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igsAccessAuthState.setStatus('current')
if mibBuilder.loadTexts: igsAccessAuthState.setDescription('This object can be configured to set IGMP Authentication state to enabled/disabled on each port.')
igsHostTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 6, 1), )
if mibBuilder.loadTexts: igsHostTable.setStatus('current')
if mibBuilder.loadTexts: igsHostTable.setDescription('This table is used to manage the IGMP Host based Fast Leave function of the switch.')
igsHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 6, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "igsHostTableVlanId"), (0, "DGS-1100-10ME_A1", "igsHostTableGroupAddress"), (0, "DGS-1100-10ME_A1", "igsHostTablePort"), (0, "DGS-1100-10ME_A1", "igsHostTableHostIPAddress"))
if mibBuilder.loadTexts: igsHostEntry.setStatus('current')
if mibBuilder.loadTexts: igsHostEntry.setDescription('Contains management entities for IGMP Host based fast leave function.')
igsHostTableVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsHostTableVlanId.setStatus('current')
if mibBuilder.loadTexts: igsHostTableVlanId.setDescription('VLAN ID of Host table entry.')
igsHostTableGroupAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 6, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsHostTableGroupAddress.setStatus('current')
if mibBuilder.loadTexts: igsHostTableGroupAddress.setDescription('Group address of Host table entry.')
igsHostTablePort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 6, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsHostTablePort.setStatus('current')
if mibBuilder.loadTexts: igsHostTablePort.setDescription('Port number of Host table entry.')
igsHostTableHostIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 10, 6, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igsHostTableHostIPAddress.setStatus('current')
if mibBuilder.loadTexts: igsHostTableHostIPAddress.setDescription('Host IP address of Group in Host table entry.')
sysIGMPMulticastVlanStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysIGMPMulticastVlanStatus.setStatus('current')
if mibBuilder.loadTexts: sysIGMPMulticastVlanStatus.setDescription('Enable/Disable IGMP Multicast Vlan function.')
sysIGMPMulticastVlanTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2), )
if mibBuilder.loadTexts: sysIGMPMulticastVlanTable.setStatus('current')
if mibBuilder.loadTexts: sysIGMPMulticastVlanTable.setDescription('Information about the IGMP snooping multicast VLAN table.')
sysIGMPMulticastVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "igmpMulticastVlanid"), (0, "DGS-1100-10ME_A1", "igmpMulticastVlanAddressType"))
if mibBuilder.loadTexts: sysIGMPMulticastVlanEntry.setStatus('current')
if mibBuilder.loadTexts: sysIGMPMulticastVlanEntry.setDescription('The entry of sysIGMPMulticastVlanTable.')
igmpMulticastVlanid = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMulticastVlanid.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanid.setDescription('This object indicates the VLAN ID of the IGMP snooping multicast VLAN entry.')
igmpMulticastVlanAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMulticastVlanAddressType.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanAddressType.setDescription('This object indicates InetAddressType IGS or MLD')
igmpMulticastVlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanName.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanName.setDescription('This object indicates the VLAN name of the IGMP snooping multicast VLAN entry.')
igmpMulticastVlanSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 4), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanSourcePort.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanSourcePort.setDescription('This object indicates the port list of the source ports of the IGMP snooping multicast VLAN. The source ports will be set as tag ports of the VLAN entry and the IGMP control messages received from the member ports will be forwarded to the source ports.')
igmpMulticastVlanMemberPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 5), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanMemberPort.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanMemberPort.setDescription('This object indicates the port list of the member ports of the IGMP snooping multicast VLAN. The source ports will be set as untagged ports of the VLAN entry and the IGMP control messages received from the member ports will be forwarded to the source ports.')
igmpMulticastVlanTagMemberPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 6), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanTagMemberPort.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanTagMemberPort.setDescription('This object indicates the port list of the tag member ports of the IGMP snooping multicast VLAN.')
igmpMulticastVlanState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanState.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanState.setDescription('This object can be used to enable or disable the IGMP snooping multicast VLAN.')
igmpMulticastVlanReplaceSourceIp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanReplaceSourceIp.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanReplaceSourceIp.setDescription('The replacement source IP of this multicast VLAN.')
igmpMulticastVlanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 2, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanRowStatus.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanRowStatus.setDescription('This object indicates the status of this entry.')
sysIGMPMulticastVlanGroupTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 3), )
if mibBuilder.loadTexts: sysIGMPMulticastVlanGroupTable.setStatus('current')
if mibBuilder.loadTexts: sysIGMPMulticastVlanGroupTable.setDescription('The table containing the IGMP snooping multicast VLAN group information')
sysIGMPMulticastVlanGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 3, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "igmpMulticastVlanGroupVid"), (0, "DGS-1100-10ME_A1", "igmpMulticastVlanGroupAddressType"), (0, "DGS-1100-10ME_A1", "igmpMulticastVlanGroupFromIp"), (0, "DGS-1100-10ME_A1", "igmpMulticastVlanGroupToIp"))
if mibBuilder.loadTexts: sysIGMPMulticastVlanGroupEntry.setStatus('current')
if mibBuilder.loadTexts: sysIGMPMulticastVlanGroupEntry.setDescription('Information about the current IGMP snooping multicast VLAN group.')
igmpMulticastVlanGroupVid = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMulticastVlanGroupVid.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanGroupVid.setDescription('This object indicates the VID of the IGMP snooping multicast VLAN group.')
igmpMulticastVlanGroupAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 3, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMulticastVlanGroupAddressType.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanGroupAddressType.setDescription('This object indicates InetAddressType IGS or MLD')
igmpMulticastVlanGroupFromIp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 3, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMulticastVlanGroupFromIp.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanGroupFromIp.setDescription('Specifies the multicast address list for this VLAN.')
igmpMulticastVlanGroupToIp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 3, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igmpMulticastVlanGroupToIp.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanGroupToIp.setDescription('Specifies the multicast address list for this VLAN.')
igmpMulticastVlanGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 27, 3, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: igmpMulticastVlanGroupStatus.setStatus('current')
if mibBuilder.loadTexts: igmpMulticastVlanGroupStatus.setDescription('This object indicates the status of this entry.')
sysPnacCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 1))
pnacStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacStatus.setStatus('current')
if mibBuilder.loadTexts: pnacStatus.setDescription('Enable/Disable Static 802.1x.')
pnacMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("portBase", 1), ("macBase", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacMode.setStatus('current')
if mibBuilder.loadTexts: pnacMode.setDescription('This object indicates the authentication mode of the device.')
pnacProtocol = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pnacProtocolRadiusEap", 1), ("pnacProtocolLocal", 2))).clone('pnacProtocolLocal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacProtocol.setStatus('current')
if mibBuilder.loadTexts: pnacProtocol.setDescription('The authentication method used to authenticate users.')
pnacRadiusAccountingState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusAccountingState.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusAccountingState.setDescription('Enable/disable Radius Accounting Settings.')
sysPnacPortAccessCtrl = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2))
pnacPortAccessControlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1), )
if mibBuilder.loadTexts: pnacPortAccessControlTable.setStatus('current')
if mibBuilder.loadTexts: pnacPortAccessControlTable.setDescription('A table that contains the configuration objects for the Authenticator PAE associated with each port. An entry appears in this table for each port that may authenticate access to itself.')
pnacPortAccessControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "pnacConfigPortNumber"))
if mibBuilder.loadTexts: pnacPortAccessControlEntry.setStatus('current')
if mibBuilder.loadTexts: pnacPortAccessControlEntry.setDescription('The configuration information for an Authenticator Port.')
pnacConfigPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnacConfigPortNumber.setStatus('current')
if mibBuilder.loadTexts: pnacConfigPortNumber.setDescription('A unique value for each port that correlates to port index. Its value ranges between 1 and the value of port number.')
pnacQuietPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacQuietPeriod.setStatus('current')
if mibBuilder.loadTexts: pnacQuietPeriod.setDescription('The value, in seconds, of the quietPeriod constant currently in use by the Authenticator PAE state machine.')
pnacTxPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacTxPeriod.setStatus('current')
if mibBuilder.loadTexts: pnacTxPeriod.setDescription('The value, in seconds, of the txPeriod constant currently in use by the Authenticator PAE state machine.')
pnacSuppTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacSuppTimeout.setStatus('current')
if mibBuilder.loadTexts: pnacSuppTimeout.setDescription('The value, in seconds, of the suppTimeout constant currently in use by the Backend Authentication state machine.')
pnacServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacServerTimeout.setStatus('current')
if mibBuilder.loadTexts: pnacServerTimeout.setDescription('The value, in seconds, of the serverTimeout constant currently in use by the Backend Authentication state machine.')
pnacMaxReq = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacMaxReq.setStatus('current')
if mibBuilder.loadTexts: pnacMaxReq.setDescription('The value of the maxReq constant currently in use by the Backend Authentication state machine.')
pnacReAuthPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(3600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacReAuthPeriod.setStatus('current')
if mibBuilder.loadTexts: pnacReAuthPeriod.setDescription('The value, in seconds, of the reAuthPeriod constant currently in use by the Reauthentication Timer state machine.')
pnacReAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacReAuthentication.setStatus('current')
if mibBuilder.loadTexts: pnacReAuthentication.setDescription('The enable/disable control used by the Reauthentication Timer state machine (8.5.5.1).')
pnacConfigPortControl = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forceUnauthorized", 1), ("auto", 2), ("forceAuthorized", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacConfigPortControl.setStatus('current')
if mibBuilder.loadTexts: pnacConfigPortControl.setDescription('The current value of the controlled Port control parameter for the Port.')
pnacCapability = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("authenticator", 1), ("none", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacCapability.setStatus('current')
if mibBuilder.loadTexts: pnacCapability.setDescription('The current value of the controlled Port control parameter for the Port.')
pnacDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("both", 0), ("in", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacDirection.setStatus('current')
if mibBuilder.loadTexts: pnacDirection.setDescription('The current value of the controlled Port control parameter for the Port.')
pnacOperControlledDirections = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("both", 0), ("in", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnacOperControlledDirections.setStatus('current')
if mibBuilder.loadTexts: pnacOperControlledDirections.setDescription('The current value of the open control Port control parameter for the Port.')
pnacPortAuthStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("authorized", 1), ("unAuthorized", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnacPortAuthStatus.setStatus('current')
if mibBuilder.loadTexts: pnacPortAuthStatus.setDescription('The authorized status of the open control Port.')
sysPnacUser = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 3))
pnacUserTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 3, 1), )
if mibBuilder.loadTexts: pnacUserTable.setStatus('current')
if mibBuilder.loadTexts: pnacUserTable.setDescription('A table that contains the configuration objects for the Authenticator PAE associated with each port. An entry appears in this table for each port that may authenticate access to itself.')
pnacUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "pnacUserName"))
if mibBuilder.loadTexts: pnacUserEntry.setStatus('current')
if mibBuilder.loadTexts: pnacUserEntry.setDescription('The configuration information for an Pnacenticator Port.')
pnacUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 3, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnacUserName.setStatus('current')
if mibBuilder.loadTexts: pnacUserName.setDescription('The unique index value of a row in this table. This object is used to set 802.1X Local user name, The following characters are allowed to input: semicolon, question mark, space, and double quotation mark.')
pnacUserPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 3, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacUserPassword.setStatus('current')
if mibBuilder.loadTexts: pnacUserPassword.setDescription('This object is used to set 802.1X Local user Password, The following characters are allowed to input: semicolon, question mark, space, and double quotation mark.')
pnacUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 3, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacUserStatus.setStatus('current')
if mibBuilder.loadTexts: pnacUserStatus.setDescription('The status of this conceptual row in the pnacUserTable. An entry in this table is not qualified for activation until instances of all corresponding columns have been initialized, either through default values, or through Set operations. The pnacUserName objects must be explicitly set.')
pnacRadiusServerTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1), )
if mibBuilder.loadTexts: pnacRadiusServerTable.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerTable.setDescription('A table that contains the configuration objects for the Authenticator PAE associated with each port. An entry appears in this table for each port that may authenticate access to itself.')
pnacRadiusServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "pnacRadiusServerIndex"))
if mibBuilder.loadTexts: pnacRadiusServerEntry.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerEntry.setDescription('The configuration information for an Authenticator Port.')
pnacRadiusServerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pnacRadiusServerIndex.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerIndex.setDescription('A unique value for Authentication RADIUS Server index. Its value ranges between 1 and 3.')
pnacRadiusIPType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusIPType.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusIPType.setDescription('The IP address of the RADIUS server IP type referred to in this table entry.')
pnacRadiusServerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 3), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusServerAddress.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerAddress.setDescription('The IP address of the RADIUS server referred to in this table entry.')
pnacRadiusServerAuthenticationPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1812)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusServerAuthenticationPort.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerAuthenticationPort.setDescription('The value is for setting UDP Port.')
pnacRadiusServerAccountingPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1813)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusServerAccountingPort.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerAccountingPort.setDescription('The value is for setting UDP Port.')
pnacRadiusServerTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusServerTimeout.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerTimeout.setDescription('The value is for setting UDP Port.')
pnacRadiusServerRetransmit = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusServerRetransmit.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerRetransmit.setDescription('The value is for setting UDP Port.')
pnacRadiusServerKey = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusServerKey.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerKey.setDescription('This object is used to set 802.1X Radius Server Key, The following characters are allowed to input: semicolon, question mark, space, and double quotation mark.')
pnacRadiusServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 23, 4, 1, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pnacRadiusServerStatus.setStatus('current')
if mibBuilder.loadTexts: pnacRadiusServerStatus.setDescription('The status of this conceptual row in the pnacRadiusServerTable. An entry in this table is not qualified for activation until instances of all corresponding columns have been initialized, either through default values, or through Set operations. The pnacRadiusServerIndex objects must be explicitly set.')
sysGuestVlanName = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 24, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 20))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGuestVlanName.setStatus('current')
if mibBuilder.loadTexts: sysGuestVlanName.setDescription('The VLAN name of guest VLAN.')
sysGuestVlanPort = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 24, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGuestVlanPort.setStatus('current')
if mibBuilder.loadTexts: sysGuestVlanPort.setDescription('This object indicates the guest VLAN port members of this device.')
sysGuestVlanDelState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 24, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("start", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysGuestVlanDelState.setStatus('current')
if mibBuilder.loadTexts: sysGuestVlanDelState.setDescription('Used to delete the guest VLAN.')
sysSNMPGlobalState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSNMPGlobalState.setStatus('current')
if mibBuilder.loadTexts: sysSNMPGlobalState.setDescription('This object is for enabling or disabling SNMP Community function.')
sysSNMPUser = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2))
sysSNMPGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3))
sysSNMPViewTree = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4))
sysSNMPCommunity = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 5))
sysSNMPHost = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6))
sysSNMPEngineID = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 7), SnmpEngineID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysSNMPEngineID.setStatus('current')
if mibBuilder.loadTexts: sysSNMPEngineID.setDescription("An SNMP engine's administratively-unique identifier. In a simple agent, this value is always that agent's own snmpEngineID value. The value can also take the value of the snmpEngineID of a remote SNMP engine with which this user can communicate.")
sysSNMPTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8))
snmpUserTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1), )
if mibBuilder.loadTexts: snmpUserTable.setStatus('current')
if mibBuilder.loadTexts: snmpUserTable.setDescription('The table of snmp user.')
snmpUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "snmpUserName"), (0, "DGS-1100-10ME_A1", "snmpUserVersion"))
if mibBuilder.loadTexts: snmpUserEntry.setStatus('current')
if mibBuilder.loadTexts: snmpUserEntry.setDescription('The list of snmp user entry.')
snmpUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpUserName.setStatus('current')
if mibBuilder.loadTexts: snmpUserName.setDescription('A human readable string representing the name of the user. This is the (User-based Security) Model dependent security ID. ')
snmpUserVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("v1", 1), ("v2c", 2), ("v3", 3))).clone('v1')).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpUserVersion.setStatus('current')
if mibBuilder.loadTexts: snmpUserVersion.setDescription('A human readable string representing the name of the user. This is the (User-based Security) Model dependent security ID.')
snmpUserGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpUserGroupName.setStatus('current')
if mibBuilder.loadTexts: snmpUserGroupName.setDescription('The name of the group to which this entry (e.g., the combination of securityModel and securityName) belongs. This groupName is used as index into the vacmAccessTable to select an access control policy. However, a value in this table does not imply that an instance with the value exists in table vacmAccesTable. ')
snmpUserAuthProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("md5", 2), ("sha", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpUserAuthProtocol.setStatus('current')
if mibBuilder.loadTexts: snmpUserAuthProtocol.setDescription("An indication of whether messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, can be authenticated, and if so, the type of authentication protocol which is used. An instance of this object is created concurrently with the creation of any other object instance for the same user (i.e., as part of the processing of the set operation which creates the first object instance in the same conceptual row). If an initial set operation (i.e. at row creation time) tries to set a value for an unknown or unsupported protocol, then a 'wrongValue' error must be returned. The value will be overwritten/set when a set operation is performed on the corresponding instance of UserCloneFrom. Once instantiated, the value of such an instance of this object can only be changed via a set operation to the value of the NoAuthProtocol. If a set operation tries to change the value of an existing instance of this object to any value other than NoAuthProtocol, then an 'inconsistentValue' error must be returned. If a set operation tries to set the value to the NoAuthProtocol while the UserPrivProtocol value in the same row is not equal to NoPrivProtocol, then an 'inconsistentValue' error must be returned. That means that an SNMP command generator application must first ensure that the UserPrivProtocol is set to the NoPrivProtocol value before it can set the UserAuthProtocol value to NoAuthProtocol. ")
snmpUserAuthProtocolPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpUserAuthProtocolPassword.setStatus('current')
if mibBuilder.loadTexts: snmpUserAuthProtocolPassword.setDescription('Password of snmp user auth protocol.')
snmpUserPrivProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("des", 2))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpUserPrivProtocol.setStatus('current')
if mibBuilder.loadTexts: snmpUserPrivProtocol.setDescription("An indication of whether messages sent on behalf of this user to/from the SNMP engine identified by usmUserEngineID, can be protected from disclosure, and if so, the type of privacy protocol which is used. An instance of this object is created concurrently with the creation of any other object instance for the same user (i.e., as part of the processing of the set operation which creates the first object instance in the same conceptual row). If an initial set operation (i.e. at row creation time) tries to set a value for an unknown or unsupported protocol, then a 'wrongValue' error must be returned. The value will be overwritten/set when a set operation is performed on the corresponding instance of usmUserCloneFrom. Once instantiated, the value of such an instance of this object can only be changed via a set operation to the value of the NoPrivProtocol. If a set operation tries to change the value of an existing instance of this object to any value other than NoPrivProtocol, then an 'inconsistentValue' error must be returned. Note that if any privacy protocol is used, then you must also use an authentication protocol. In other words, if usmUserPrivProtocol is set to anything else than NoPrivProtocol, then the corresponding instance of usmUserAuthProtocol cannot have a value of usmNoAuthProtocol. If it does, then an 'inconsistentValue' error must be returned. ")
snmpUserPrivProtocolPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpUserPrivProtocolPassword.setStatus('current')
if mibBuilder.loadTexts: snmpUserPrivProtocolPassword.setDescription('Password of snmp user priv protocol.')
snmpUserStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 2, 1, 1, 8), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpUserStatus.setStatus('current')
if mibBuilder.loadTexts: snmpUserStatus.setDescription("The status of this conceptual row. Until instances of all corresponding columns are appropriately configured, the value of the corresponding instance of the usmUserStatus column is 'notReady'. In particular, a newly created row for a user who employs authentication, cannot be made active until the corresponding usmUserCloneFrom and usmUserAuthKeyChange have been set. Further, a newly created row for a user who also employs privacy, cannot be made active until the usmUserPrivKeyChange has been set. The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified: The value of this object has no effect on whether other objects in this conceptual row can be modified, except for usmUserOwnAuthKeyChange and usmUserOwnPrivKeyChange. For these 2 objects, the value of usmUserStatus MUST be active. ")
snmpGroupTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1), )
if mibBuilder.loadTexts: snmpGroupTable.setStatus('current')
if mibBuilder.loadTexts: snmpGroupTable.setDescription('The table of snmp group.')
snmpGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "snmpGroupName"), (0, "DGS-1100-10ME_A1", "snmpGroupSecurityModel"), (0, "DGS-1100-10ME_A1", "snmpGroupSecurityLevel"))
if mibBuilder.loadTexts: snmpGroupEntry.setStatus('current')
if mibBuilder.loadTexts: snmpGroupEntry.setDescription(' The list of snmp group entry.')
snmpGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpGroupName.setStatus('current')
if mibBuilder.loadTexts: snmpGroupName.setDescription('The name of the group to which this entry (e.g., the combination of securityModel and securityName) belongs. This groupName is used as index into the vacmAccessTable to select an access control policy. However, a value in this table does not imply that an instance with the value exists in table vacmAccesTable. ')
snmpGroupSecurityModel = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("v1", 1), ("v2c", 2), ("v3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpGroupSecurityModel.setStatus('current')
if mibBuilder.loadTexts: snmpGroupSecurityModel.setDescription('In order to gain the access rights allowed by this conceptual row, this securityModel must be in use. ')
snmpGroupSecurityLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAuthNoPriv", 1), ("authNoPriv", 2), ("authPriv", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpGroupSecurityLevel.setStatus('current')
if mibBuilder.loadTexts: snmpGroupSecurityLevel.setDescription('The minimum level of security required in order to gain the access rights allowed by this conceptual row. A securityLevel of noAuthNoPriv is less than authNoPriv which in turn is less than authPriv. If multiple entries are equally indexed except for this vacmAccessSecurityLevel index, then the entry which has the highest value for vacmAccessSecurityLevel is selected. ')
snmpGroupReadViewName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGroupReadViewName.setStatus('current')
if mibBuilder.loadTexts: snmpGroupReadViewName.setDescription('The value of an instance of this object identifies the MIB view of the SNMP context to which this conceptual row authorizes read access. The identified MIB view is that one for which the vacmViewTreeFamilyViewName has the same value as the instance of this object; if the value is the empty string or if there is no active MIB view having this value of vacmViewTreeFamilyViewName, then no access is granted. ')
snmpGroupWriteViewName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGroupWriteViewName.setStatus('current')
if mibBuilder.loadTexts: snmpGroupWriteViewName.setDescription('The value of an instance of this object identifies the MIB view of the SNMP context to which this conceptual row authorizes write access. The identified MIB view is that one for which the vacmViewTreeFamilyViewName has the same value as the instance of this object; if the value is the empty string or if there is no active MIB view having this value of vacmViewTreeFamilyViewName, then no access is granted. ')
snmpGroupNotifyViewName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGroupNotifyViewName.setStatus('current')
if mibBuilder.loadTexts: snmpGroupNotifyViewName.setDescription('The value of an instance of this object identifies the MIB view of the SNMP context to which this conceptual row authorizes access for notifications. The identified MIB view is that one for which the vacmViewTreeFamilyViewName has the same value as the instance of this object; if the value is the empty string or if there is no active MIB view having this value of vacmViewTreeFamilyViewName, then no access is granted. ')
snmpGroupStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 3, 1, 1, 7), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpGroupStatus.setStatus('current')
if mibBuilder.loadTexts: snmpGroupStatus.setDescription('The status of this conceptual row. The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified: The value of this object has no effect on whether other objects in this conceptual row can be modified. ')
snmpViewTreeTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4, 1), )
if mibBuilder.loadTexts: snmpViewTreeTable.setStatus('current')
if mibBuilder.loadTexts: snmpViewTreeTable.setDescription('The table of snmp view tree.')
snmpViewTreeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "snmpViewTreeName"), (0, "DGS-1100-10ME_A1", "snmpViewTreeSubtree"))
if mibBuilder.loadTexts: snmpViewTreeEntry.setStatus('current')
if mibBuilder.loadTexts: snmpViewTreeEntry.setDescription('The list of snmp view tree entry.')
snmpViewTreeName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpViewTreeName.setStatus('current')
if mibBuilder.loadTexts: snmpViewTreeName.setDescription('The human readable name for a family of view subtrees. ')
snmpViewTreeSubtree = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpViewTreeSubtree.setStatus('current')
if mibBuilder.loadTexts: snmpViewTreeSubtree.setDescription('The MIB subtree which when combined with the corresponding instance of vacmViewTreeFamilyMask defines a family of view subtrees. ')
snmpViewTreeMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpViewTreeMask.setStatus('current')
if mibBuilder.loadTexts: snmpViewTreeMask.setDescription("The bit mask which, in combination with the corresponding instance of vacmViewTreeFamilySubtree, defines a family of view subtrees. Each bit of this bit mask corresponds to a sub-identifier of vacmViewTreeFamilySubtree, with the most significant bit of the i-th octet of this octet string value (extended if necessary, see below) corresponding to the (8*i - 7)-th sub-identifier, and the least significant bit of the i-th octet of this octet string corresponding to the (8*i)-th sub-identifier, where i is in the range 1 through 16. Each bit of this bit mask specifies whether or not the corresponding sub-identifiers must match when determining if an OBJECT IDENTIFIER is in this family of view subtrees; a '1' indicates that an exact match must occur; a '0' indicates 'wild card', i.e., any sub-identifier value matches. Thus, the OBJECT IDENTIFIER X of an object instance is contained in a family of view subtrees if, for each sub-identifier of the value of vacmViewTreeFamilySubtree, either: the i-th bit of vacmViewTreeFamilyMask is 0, or the i-th sub-identifier of X is equal to the i-th sub-identifier of the value of vacmViewTreeFamilySubtree. If the value of this bit mask is M bits long and there are more than M sub-identifiers in the corresponding instance of vacmViewTreeFamilySubtree, then the bit mask is extended with 1's to be the required length. Note that when the value of this object is the zero-length string, this extension rule results in a mask of all-1's being used (i.e., no 'wild card'), and the family of view subtrees is the one view subtree uniquely identified by the corresponding instance of vacmViewTreeFamilySubtree. Note that masks of length greater than zero length do not need to be supported. In this case this object is made read-only. ")
snmpViewTreeType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("included", 1), ("excluded", 2))).clone('included')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpViewTreeType.setStatus('current')
if mibBuilder.loadTexts: snmpViewTreeType.setDescription('Indicates whether the corresponding instances of vacmViewTreeFamilySubtree and vacmViewTreeFamilyMask define a family of view subtrees which is included in or excluded from the MIB view. ')
snmpViewTreeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 4, 1, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpViewTreeStatus.setStatus('current')
if mibBuilder.loadTexts: snmpViewTreeStatus.setDescription('The status of this conceptual row. The RowStatus TC [RFC2579] requires that this DESCRIPTION clause states under which circumstances other objects in this row can be modified: The value of this object has no effect on whether other objects in this conceptual row can be modified. ')
snmpCommunityTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 5, 1), )
if mibBuilder.loadTexts: snmpCommunityTable.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityTable.setDescription('The table of snmp community.')
snmpCommunityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 5, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "snmpCommunityName"))
if mibBuilder.loadTexts: snmpCommunityEntry.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityEntry.setDescription('The list of snmp community entry.')
snmpCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 5, 1, 1, 1), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpCommunityName.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityName.setDescription('The unique index value of a row in this table.')
snmpCommunityPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 5, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: snmpCommunityPolicy.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityPolicy.setDescription('A human readable string representing the corresponding value of snmpCommunityName in a Security Model independent format.')
snmpCommunityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 5, 1, 1, 3), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpCommunityStatus.setStatus('current')
if mibBuilder.loadTexts: snmpCommunityStatus.setDescription('The status of this conceptual row in the snmpCommunityTable. An entry in this table is not qualified for activation until instances of all corresponding columns have been initialized, either through default values, or through Set operations. The snmpCommunityName and snmpCommunitySecurityName objects must be explicitly set. There is no restriction on setting columns in this table when the value of snmpCommunityStatus is active(1).')
snmpHostTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6, 1), )
if mibBuilder.loadTexts: snmpHostTable.setStatus('current')
if mibBuilder.loadTexts: snmpHostTable.setDescription('The table of snmp host.')
snmpHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "snmpHostAddress"), (0, "DGS-1100-10ME_A1", "snmpHostIPType"))
if mibBuilder.loadTexts: snmpHostEntry.setStatus('current')
if mibBuilder.loadTexts: snmpHostEntry.setDescription('The list of snmp host entry.')
snmpHostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6, 1, 1, 1), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpHostAddress.setStatus('current')
if mibBuilder.loadTexts: snmpHostAddress.setDescription('This object contains a transport address. The format of this address depends on the value of the snmpTargetAddrTDomain object. And this object is unique identifier associated with this snmpNotifyEntry.')
snmpHostIPType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("iPv4", 1), ("iPv6", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpHostIPType.setStatus('current')
if mibBuilder.loadTexts: snmpHostIPType.setDescription('Type of IP interface.')
snmpHostCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpHostCommunityName.setStatus('current')
if mibBuilder.loadTexts: snmpHostCommunityName.setDescription('The locally arbitrary.')
snmpHostVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("v1", 1), ("v2c", 2), ("v3-NoAuthNoPriv", 3), ("v3-AuthNoPriv", 4), ("v3-AuthPriv", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpHostVersion.setStatus('current')
if mibBuilder.loadTexts: snmpHostVersion.setDescription('The Level of Security to be used when generating SNMP messages using this entry.')
snmpHostStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 6, 1, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpHostStatus.setStatus('current')
if mibBuilder.loadTexts: snmpHostStatus.setDescription('The status of this conceptual row in the snmpHostTable.')
snmpTrapSNMPAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapSNMPAuthentication.setStatus('current')
if mibBuilder.loadTexts: snmpTrapSNMPAuthentication.setDescription('This object is for enabling or disabling SNMP login fail event trap in the system.')
snmpTrapColdStart = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapColdStart.setStatus('current')
if mibBuilder.loadTexts: snmpTrapColdStart.setDescription('This object is for enabling or disabling devie Bootup event trap in the system.')
snmpTrapWarmStart = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapWarmStart.setStatus('current')
if mibBuilder.loadTexts: snmpTrapWarmStart.setDescription('This object is for enabling or disabling devie bootup event trap in the system.')
snmpTrapFiberLinkUpDown = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapFiberLinkUpDown.setStatus('current')
if mibBuilder.loadTexts: snmpTrapFiberLinkUpDown.setDescription('This object is for enabling or disabling fiber port link up / link down event trap in the system.')
snmpTrapTwistLinkUpDown = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapTwistLinkUpDown.setStatus('current')
if mibBuilder.loadTexts: snmpTrapTwistLinkUpDown.setDescription('This object is for enabling or disabling twisted pair port link up / link down event trap in the system.')
snmpTrapFirmwareUpgrade = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapFirmwareUpgrade.setStatus('current')
if mibBuilder.loadTexts: snmpTrapFirmwareUpgrade.setDescription('This object is for enabling or disabling firmware upgrade success or fail event trap in the system.')
snmpTrapPortSecViolation = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapPortSecViolation.setStatus('current')
if mibBuilder.loadTexts: snmpTrapPortSecViolation.setDescription('This object is for enabling or disabling port security event trap in the system.')
snmpTrapLBDDetection = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapLBDDetection.setStatus('current')
if mibBuilder.loadTexts: snmpTrapLBDDetection.setDescription('This object is for enabling or disabling lbd event trap in the system.')
snmpTrapDuplicateIPDetected = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 5, 8, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpTrapDuplicateIPDetected.setStatus('current')
if mibBuilder.loadTexts: snmpTrapDuplicateIPDetected.setDescription('This object is for enabling or disabling send gratuitous trap when IP address conflicted in the network.')
syslogSettingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 1))
syslogEnable = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogEnable.setStatus('current')
if mibBuilder.loadTexts: syslogEnable.setDescription('This object is for enabling or disabling syslog alert features in the system and the syslog will save to flash or send to remote syslog server. System Logs record and manage events, as well as report errors and informational messages.')
syslogSaveMode = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("onDemand", 0), ("timeInterval", 1), ("logTrigger", 2))).clone('logTrigger')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogSaveMode.setStatus('current')
if mibBuilder.loadTexts: syslogSaveMode.setDescription('This object is for choosing the method to save syslog into flash.')
syslogSaveMinutes = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogSaveMinutes.setStatus('current')
if mibBuilder.loadTexts: syslogSaveMinutes.setDescription("When savemode is time interval, it's used to set the interval minutes of system save syslog to flash.")
syslogClearLog = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 1, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogClearLog.setStatus('current')
if mibBuilder.loadTexts: syslogClearLog.setDescription("Clears the buffered logs. This object is set to 'false' by default. When set to 'True', the buffered logs will be cleared and the value of this object will become 'false' again.")
syslogServerGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3))
syslogServTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1), )
if mibBuilder.loadTexts: syslogServTable.setStatus('current')
if mibBuilder.loadTexts: syslogServTable.setDescription('The table of syslog remote server.')
syslogServEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "syslogServIndex"))
if mibBuilder.loadTexts: syslogServEntry.setStatus('current')
if mibBuilder.loadTexts: syslogServEntry.setDescription('The list of syslog remote server entry.')
syslogServIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogServIndex.setStatus('current')
if mibBuilder.loadTexts: syslogServIndex.setDescription('The index of syslog remote server.')
syslogServAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServAddrType.setStatus('current')
if mibBuilder.loadTexts: syslogServAddrType.setDescription('Specifies the Address type of server.Address type shall be ipv4 or ipv6.')
syslogServAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 3), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServAddr.setStatus('current')
if mibBuilder.loadTexts: syslogServAddr.setDescription('Specifies the ServerIP to which the syslog shall be forwarded.')
syslogServSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 6, 7))).clone(namedValues=NamedValues(("warning", 4), ("information", 6), ("debug", 7))).clone('warning')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServSeverity.setStatus('current')
if mibBuilder.loadTexts: syslogServSeverity.setDescription('Specifies the log level option to be set for a specific server.')
syslogServFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(128, 136, 144, 152, 160, 168, 176, 184))).clone(namedValues=NamedValues(("local0", 128), ("local1", 136), ("local2", 144), ("local3", 152), ("local4", 160), ("local5", 168), ("local6", 176), ("local7", 184))).clone('local0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServFacility.setStatus('current')
if mibBuilder.loadTexts: syslogServFacility.setDescription('The Syslog standard facilities. The facility to be used when sending Syslog messages to this server.')
syslogServUDPport = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(514, 514), ValueRangeConstraint(6000, 65535), )).clone(514)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServUDPport.setStatus('current')
if mibBuilder.loadTexts: syslogServUDPport.setDescription('The value is for setting UDP Port.')
syslogServSrvStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServSrvStatus.setStatus('current')
if mibBuilder.loadTexts: syslogServSrvStatus.setDescription('The status for this server. If enable, system will send message to this server.')
syslogServSrvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 3, 1, 1, 9), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: syslogServSrvRowStatus.setStatus('current')
if mibBuilder.loadTexts: syslogServSrvRowStatus.setDescription('Row status of this server entry.')
syslogMsg = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 4))
syslogMsgTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 4, 1), )
if mibBuilder.loadTexts: syslogMsgTable.setStatus('current')
if mibBuilder.loadTexts: syslogMsgTable.setDescription('Specifies the number of messages .')
syslogMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 4, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "syslogMsgIndex"))
if mibBuilder.loadTexts: syslogMsgEntry.setStatus('current')
if mibBuilder.loadTexts: syslogMsgEntry.setDescription('An entry (conceptual row) in the syslogMsgTable.')
syslogMsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogMsgIndex.setStatus('current')
if mibBuilder.loadTexts: syslogMsgIndex.setDescription('The auxiliary variable used for identifying instances of the columnar objects in the syslogMsgTable.')
syslogMsgDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogMsgDescr.setStatus('current')
if mibBuilder.loadTexts: syslogMsgDescr.setDescription('A textual description of system log message.')
syslogMsgTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 4, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogMsgTime.setStatus('current')
if mibBuilder.loadTexts: syslogMsgTime.setDescription('time of system log message.')
syslogMsgSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 16, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("emergency", 0), ("alert", 1), ("critical", 2), ("error", 3), ("warning", 4), ("notice", 5), ("information", 6), ("debug", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: syslogMsgSeverity.setStatus('current')
if mibBuilder.loadTexts: syslogMsgSeverity.setDescription('Severity of system log message.')
sysEoamSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1))
sysEoamLinkMonitor = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2))
sysEoamStats = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3))
sysEoamEventLog = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4))
sysEoamTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 5))
sysEoamLoopbackTest = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6))
eoamTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2), )
if mibBuilder.loadTexts: eoamTable.setStatus('current')
if mibBuilder.loadTexts: eoamTable.setDescription('A table that contains EOAM mode information about each port.')
eoamEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "eoamIfIndex"))
if mibBuilder.loadTexts: eoamEntry.setStatus('current')
if mibBuilder.loadTexts: eoamEntry.setDescription('A list of EOAM mode information for each port.')
eoamIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamIfIndex.setStatus('current')
if mibBuilder.loadTexts: eoamIfIndex.setDescription('The index of the port. ')
eoamState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamState.setStatus('current')
if mibBuilder.loadTexts: eoamState.setDescription('Sets the EOAM state enabled or disabled.')
eoamMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("passive", 1), ("active", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamMode.setStatus('current')
if mibBuilder.loadTexts: eoamMode.setDescription('Sets the EOAM mode as active or passive.')
eoamReceivedRemoteLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ignore", 1), ("process", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamReceivedRemoteLoopback.setStatus('current')
if mibBuilder.loadTexts: eoamReceivedRemoteLoopback.setDescription('Sets the EOAM received or ignore remote loopback packets.')
eoamRemoteLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noLoopBack", 1), ("startLoopBack", 2), ("remoteLoopBack", 3), ("stopLoopBack", 4), ("localLoopBack", 5), ("unknownLoopBack", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamRemoteLoopback.setStatus('current')
if mibBuilder.loadTexts: eoamRemoteLoopback.setDescription('Sets the EOAM remote loopback start or stop.')
eoamMaxOAMPDU = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamMaxOAMPDU.setStatus('current')
if mibBuilder.loadTexts: eoamMaxOAMPDU.setDescription('Indicate the max EOAM PDU received packets.')
eoamUnidirection = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamUnidirection.setStatus('current')
if mibBuilder.loadTexts: eoamUnidirection.setDescription('Indicate the eoamUnidirection support or not support.')
eoamLinkMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLinkMonitoring.setStatus('current')
if mibBuilder.loadTexts: eoamLinkMonitoring.setDescription('Indicate the eoam Link Monitoring support or not support.')
eoamVarReq = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamVarReq.setStatus('current')
if mibBuilder.loadTexts: eoamVarReq.setDescription('Indicate the eoam variable support or not support.')
eoamRemoteLoopbackSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamRemoteLoopbackSupport.setStatus('current')
if mibBuilder.loadTexts: eoamRemoteLoopbackSupport.setDescription('Indicate the eoam remote loopback support or not support.')
eoamPDURev = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPDURev.setStatus('current')
if mibBuilder.loadTexts: eoamPDURev.setDescription('The configuration revision of the OAM entity as reflected in the latest OAMPDU sent by the OAM entity.')
eoamOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("disabled", 1), ("linkFault", 2), ("passiveWait", 3), ("activeSendLocal", 4), ("sendLocalAndRemote", 5), ("sendLocalAndRemoteOk", 6), ("oamPeeringLocallyRejected", 7), ("oamPeeringRemotelyRejected", 8), ("operational", 9), ("nonOperHalfDuplex", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamOperStatus.setStatus('current')
if mibBuilder.loadTexts: eoamOperStatus.setDescription('At initialization and failure conditions, two OAM entities on the same full-duplex Ethernet link begin a discovery phase to determine what OAM capabilities may be used on that link. The progress of this initialization is controlled by the OA sublayer.')
eoamPeerMode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("passive", 1), ("active", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerMode.setStatus('current')
if mibBuilder.loadTexts: eoamPeerMode.setDescription('Indicate the EOAM peer mode as active or passive.')
eoamPeerMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 14), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerMacAddress.setStatus('current')
if mibBuilder.loadTexts: eoamPeerMacAddress.setDescription('The MAC address of the peer OAM entity.')
eoamPeerVendorOui = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerVendorOui.setStatus('current')
if mibBuilder.loadTexts: eoamPeerVendorOui.setDescription('The OUI of the OAM peer as reflected in the latest Information OAMPDU received with a Local Information TLV.')
eoamPeerMaxOAMPDU = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 16), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerMaxOAMPDU.setStatus('current')
if mibBuilder.loadTexts: eoamPeerMaxOAMPDU.setDescription('Indicate the max EOAM peer PDU received packets.')
eoamPeerUnidirection = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerUnidirection.setStatus('current')
if mibBuilder.loadTexts: eoamPeerUnidirection.setDescription('Indicate the eoam peer Unidirection support or not support.')
eoamPeerLinkMonitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerLinkMonitoring.setStatus('current')
if mibBuilder.loadTexts: eoamPeerLinkMonitoring.setDescription('Indicate the eoam peer Link Monitoring support or not support.')
eoamPeerVarReq = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerVarReq.setStatus('current')
if mibBuilder.loadTexts: eoamPeerVarReq.setDescription('Indicate the eoam peer variable support or not support.')
eoamPeerPDURev = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 1, 2, 1, 20), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamPeerPDURev.setStatus('current')
if mibBuilder.loadTexts: eoamPeerPDURev.setDescription('The configuration revision of the OAM peer as reflected in the latest OAMPDU. This attribute is changed by the peer whenever it has a local configuration change for Ethernet OA on this interface.')
eoamLinkMonitorTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1), )
if mibBuilder.loadTexts: eoamLinkMonitorTable.setStatus('current')
if mibBuilder.loadTexts: eoamLinkMonitorTable.setDescription('A table that contains EOAM link monitor information about each port.')
eoamLinkMonitorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "eoamLinkMonitorIfIndex"))
if mibBuilder.loadTexts: eoamLinkMonitorEntry.setStatus('current')
if mibBuilder.loadTexts: eoamLinkMonitorEntry.setDescription('A list of EOAM link monitor information for each port.')
eoamLinkMonitorIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLinkMonitorIfIndex.setStatus('current')
if mibBuilder.loadTexts: eoamLinkMonitorIfIndex.setDescription('The index of the port. ')
errorSymbolNotifyState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorSymbolNotifyState.setStatus('current')
if mibBuilder.loadTexts: errorSymbolNotifyState.setDescription('Sets the EOAM error symbol notify state enabled or disabled.')
errorSymbolThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 3), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorSymbolThreshold.setStatus('current')
if mibBuilder.loadTexts: errorSymbolThreshold.setDescription('Sets the EOAM error symbol threshold.')
errorSymbolWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorSymbolWindow.setStatus('current')
if mibBuilder.loadTexts: errorSymbolWindow.setDescription('Sets the EOAM error symbol window.')
errorFrameNotifyState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFrameNotifyState.setStatus('current')
if mibBuilder.loadTexts: errorFrameNotifyState.setDescription('Sets the EOAM error frame notify state enabled or disabled.')
errorFrameThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 6), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFrameThreshold.setStatus('current')
if mibBuilder.loadTexts: errorFrameThreshold.setDescription('Sets the EOAM error frame threshold.')
errorFrameWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 60000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFrameWindow.setStatus('current')
if mibBuilder.loadTexts: errorFrameWindow.setDescription('Sets the EOAM error symbol window.')
errorFrameSecondsNotifyState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFrameSecondsNotifyState.setStatus('current')
if mibBuilder.loadTexts: errorFrameSecondsNotifyState.setDescription('Sets the EOAM error symbol notify state enabled or disabled.')
errorFrameSecondsThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFrameSecondsThreshold.setStatus('current')
if mibBuilder.loadTexts: errorFrameSecondsThreshold.setDescription('Sets the EOAM error symbol threshold.')
errorFrameSecondsWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10000, 900000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFrameSecondsWindow.setStatus('current')
if mibBuilder.loadTexts: errorFrameSecondsWindow.setDescription('Sets the EOAM error symbol window.')
errorFramePeriodNotifyState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFramePeriodNotifyState.setStatus('current')
if mibBuilder.loadTexts: errorFramePeriodNotifyState.setDescription('Sets the EOAM error symbol notify state enabled or disabled.')
errorFramePeriodThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 12), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFramePeriodThreshold.setStatus('current')
if mibBuilder.loadTexts: errorFramePeriodThreshold.setDescription('Sets the EOAM error symbol threshold.')
errorFramePeriodWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(148810, 100000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: errorFramePeriodWindow.setStatus('current')
if mibBuilder.loadTexts: errorFramePeriodWindow.setDescription('Sets the EOAM error symbol window.')
eoamCriticalLinkEventState = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 2, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamCriticalLinkEventState.setStatus('current')
if mibBuilder.loadTexts: eoamCriticalLinkEventState.setDescription('Set the EOAM critical link event state.')
sysEoamStatsTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1), )
if mibBuilder.loadTexts: sysEoamStatsTable.setStatus('current')
if mibBuilder.loadTexts: sysEoamStatsTable.setDescription('This table contains statistics for the OAM function on a particular Ethernet-like interface. There is an entry in the table for every entry in the dot3OamTable. The counters in this table are defined as 32-bit entries to match the counter size as defined in [802.3ah]. Given that the OA protocol is a slow protocol, the counters increment at a slow rate. ')
eoamStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "eoamInfomationIndex"))
if mibBuilder.loadTexts: eoamStatsEntry.setStatus('current')
if mibBuilder.loadTexts: eoamStatsEntry.setDescription('An entry in the table containing statistics information on the Ethernet OAM function for a single Ethernet-like interface. Entries are automatically created for every entry in the dot3OamTable. Counters are maintained across transitions in dot3OamOperStatus. ')
eoamInfomationIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamInfomationIndex.setStatus('current')
if mibBuilder.loadTexts: eoamInfomationIndex.setDescription("A unique value, greater than zero, for each interface. It is recommended that values are assigned contiguously starting from 1. The value for each interface sub-layer must remain constant at least from one re-initialization of the entity's network management system to the next re- initialization.")
eoamInformationTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 2), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamInformationTx.setReference('[802.3ah], 30.3.6.1.20.')
if mibBuilder.loadTexts: eoamInformationTx.setStatus('current')
if mibBuilder.loadTexts: eoamInformationTx.setDescription('A count of the number of Information OAMPDUs transmitted on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamInformationRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 3), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamInformationRx.setReference('[802.3ah], 30.3.6.1.21.')
if mibBuilder.loadTexts: eoamInformationRx.setStatus('current')
if mibBuilder.loadTexts: eoamInformationRx.setDescription('A count of the number of Information OAMPDUs received on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamUniqueEventNotificationTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 4), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamUniqueEventNotificationTx.setReference('[802.3ah], 30.3.6.1.22.')
if mibBuilder.loadTexts: eoamUniqueEventNotificationTx.setStatus('current')
if mibBuilder.loadTexts: eoamUniqueEventNotificationTx.setDescription('A count of the number of unique Event OAMPDUs transmitted on this interface. Event Notifications may be sent in duplicate to increase the probability of successfully being received, given the possibility that a frame may be lost in transit. Duplicate Event Notification transmissions are counted by eoamDuplicateEventNotificationTx. A unique Event Notification OAMPDU is indicated as an Event Notification OAMPDU with a Sequence Number field that is distinct from the previously transmitted Event Notification OAMPDU Sequence Number. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamUniqueEventNotificationRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 5), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamUniqueEventNotificationRx.setReference('[802.3ah], 30.3.6.1.24.')
if mibBuilder.loadTexts: eoamUniqueEventNotificationRx.setStatus('current')
if mibBuilder.loadTexts: eoamUniqueEventNotificationRx.setDescription('A count of the number of unique Event OAMPDUs received on this interface. Event Notification OAMPDUs may be sent in duplicate to increase the probability of successfully being received, given the possibility that a frame may be lost in transit. Duplicate Event Notification receptions are counted by eoamDuplicateEventNotificationRx. A unique Event Notification OAMPDU is indicated as an Event Notification OAMPDU with a Sequence Number field that is distinct from the previously received Event Notification OAMPDU Sequence Number. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamDuplicateEventNotificationTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 6), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamDuplicateEventNotificationTx.setReference('[802.3ah], 30.3.6.1.23.')
if mibBuilder.loadTexts: eoamDuplicateEventNotificationTx.setStatus('current')
if mibBuilder.loadTexts: eoamDuplicateEventNotificationTx.setDescription('A count of the number of duplicate Event OAMPDUs transmitted on this interface. Event Notification OAMPDUs may be sent in duplicate to increase the probability of successfully being received, given the possibility that a frame may be lost in transit. A duplicate Event Notification OAMPDU is indicated as an Event Notification OAMPDU with a Sequence Number field that is identical to the previously transmitted Event Notification OAMPDU Sequence Number. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamDuplicateEventNotificationRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 7), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamDuplicateEventNotificationRx.setReference('[802.3ah], 30.3.6.1.25.')
if mibBuilder.loadTexts: eoamDuplicateEventNotificationRx.setStatus('current')
if mibBuilder.loadTexts: eoamDuplicateEventNotificationRx.setDescription('A count of the number of duplicate Event OAMPDUs received on this interface. Event Notification OAMPDUs may be sent in duplicate to increase the probability of successfully being received, given the possibility that a frame may be lost in transit. A duplicate Event Notification OAMPDU is indicated as an Event Notification OAMPDU with a Sequence Number field that is identical to the previously received Event Notification OAMPDU Sequence Number. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamLoopbackControlTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 8), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackControlTx.setReference('[802.3ah], 30.3.6.1.26.')
if mibBuilder.loadTexts: eoamLoopbackControlTx.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackControlTx.setDescription('A count of the number of Loopback Control OAMPDUs transmitted on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamLoopbackControlRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 9), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackControlRx.setReference('[802.3ah], 30.3.6.1.27.')
if mibBuilder.loadTexts: eoamLoopbackControlRx.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackControlRx.setDescription('A count of the number of Loopback Control OAMPDUs received on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamVariableRequestTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 10), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamVariableRequestTx.setReference('[802.3ah], 30.3.6.1.28.')
if mibBuilder.loadTexts: eoamVariableRequestTx.setStatus('current')
if mibBuilder.loadTexts: eoamVariableRequestTx.setDescription('A count of the number of Variable Request OAMPDUs transmitted on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamVariableRequestRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 11), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamVariableRequestRx.setReference('[802.3ah], 30.3.6.1.29.')
if mibBuilder.loadTexts: eoamVariableRequestRx.setStatus('current')
if mibBuilder.loadTexts: eoamVariableRequestRx.setDescription('A count of the number of Variable Request OAMPDUs received on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamVariableResponseTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 12), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamVariableResponseTx.setReference('[802.3ah], 30.3.6.1.30.')
if mibBuilder.loadTexts: eoamVariableResponseTx.setStatus('current')
if mibBuilder.loadTexts: eoamVariableResponseTx.setDescription('A count of the number of Variable Response OAMPDUs transmitted on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamVariableResponseRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 13), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamVariableResponseRx.setReference('[802.3ah], 30.3.6.1.31.')
if mibBuilder.loadTexts: eoamVariableResponseRx.setStatus('current')
if mibBuilder.loadTexts: eoamVariableResponseRx.setDescription('A count of the number of Variable Response OAMPDUs received on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamOrgSpecificTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 14), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamOrgSpecificTx.setReference('[802.3ah], 30.3.6.1.32.')
if mibBuilder.loadTexts: eoamOrgSpecificTx.setStatus('current')
if mibBuilder.loadTexts: eoamOrgSpecificTx.setDescription('A count of the number of Organization Specific OAMPDUs transmitted on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamOrgSpecificRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 15), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamOrgSpecificRx.setReference('[802.3ah], 30.3.6.1.33.')
if mibBuilder.loadTexts: eoamOrgSpecificRx.setStatus('current')
if mibBuilder.loadTexts: eoamOrgSpecificRx.setDescription('A count of the number of Organization Specific OAMPDUs received on this interface. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamUnsupportedCodesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 16), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamUnsupportedCodesTx.setReference('[802.3ah], 30.3.6.1.18.')
if mibBuilder.loadTexts: eoamUnsupportedCodesTx.setStatus('current')
if mibBuilder.loadTexts: eoamUnsupportedCodesTx.setDescription('A count of the number of OAMPDUs transmitted on this interface with an unsupported op-code. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamUnsupportedCodesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 17), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamUnsupportedCodesRx.setReference('[802.3ah], 30.3.6.1.19.')
if mibBuilder.loadTexts: eoamUnsupportedCodesRx.setStatus('current')
if mibBuilder.loadTexts: eoamUnsupportedCodesRx.setDescription('A count of the number of OAMPDUs received on this interface with an unsupported op-code. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ')
eoamFramesLostDueToOam = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 1, 1, 18), Counter32()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamFramesLostDueToOam.setReference('[802.3ah], 30.3.6.1.46.')
if mibBuilder.loadTexts: eoamFramesLostDueToOam.setStatus('current')
if mibBuilder.loadTexts: eoamFramesLostDueToOam.setDescription("A count of the number of frames that were dropped by the OA multiplexer. Since the OAM multiplexer has multiple inputs and a single output, there may be cases where frames are dropped due to transmit resource contention. This counter is incremented whenever a frame is dropped by the OAM layer. Note that any Ethernet frame, not just OAMPDUs, may be dropped by the OAM layer. This can occur when an OAMPDU takes precedence over a 'normal' frame resulting in the 'normal' frame being dropped. When this counter is incremented, no other counters in this MIB are incremented. Discontinuities of this counter can occur at re-initialization of the management system, and at other times as indicated by the value of the ifCounterDiscontinuityTime. ")
sysEoamStatsClearPortlist = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 3, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEoamStatsClearPortlist.setStatus('current')
if mibBuilder.loadTexts: sysEoamStatsClearPortlist.setDescription('Clear Eoam statistics according to portlist setting')
sysOamEventLogTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2), )
if mibBuilder.loadTexts: sysOamEventLogTable.setStatus('current')
if mibBuilder.loadTexts: sysOamEventLogTable.setDescription("This table records a history of the events that have occurred at the Ethernet OAM level. These events can include locally detected events, which may result in locally generated OAMPDUs, and remotely detected events, which are detected by the OAM peer entity and signaled to the local entity via Ethernet OAM. Ethernet OAM events can be signaled by Event Notification OAMPDUs or by the flags field in any OAMPDU. This table contains both threshold crossing events and non-threshold crossing events. The parameters for the threshold window, threshold value, and actual value (eoamEventLogWindowXX, eoamEventLogThresholdXX, eoamEventLogValue) are only applicable to threshold crossing events, and are returned as all F's (2^32 - 1) for non-threshold crossing events. Entries in the table are automatically created when such events are detected. The size of the table is implementation dependent. When the table reaches its maximum size, older entries are automatically deleted to make room for newer entries. ")
eoamEventLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "eoamEventLogPort"), (0, "DGS-1100-10ME_A1", "eoamEventLogIndex"))
if mibBuilder.loadTexts: eoamEventLogEntry.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogEntry.setDescription('An entry in the eoamEventLogTable. Entries are automatically created whenever Ethernet OAM events occur at the local OAM entity, and when Event Notification OAMPDUs are received at the local OAM entity (indicating that events have occurred at the peer OAM entity). The size of the table is implementation dependent, but when the table becomes full, older events are automatically deleted to make room for newer events. The table index eoamEventLogIndex increments for each new entry, and when the maximum value is reached, the value restarts at zero. ')
eoamEventLogPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogPort.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogPort.setDescription("A unique value, greater than zero, for each interface. It is recommended that values are assigned contiguously starting from 1. The value for each interface sub-layer must remain constant at least from one re-initialization of the entity's network management system to the next re- initialization.")
eoamEventLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogIndex.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogIndex.setDescription('An arbitrary integer for identifying individual events within the event log. ')
eoamEventLogTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogTimestamp.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogTimestamp.setDescription(' The object indicates eoam event log time stamp which in the format: day/month/year hour:minute:second. e.g 30/10/2013 17:36:11.')
eoamEventLogType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogType.setReference('[802.3ah], 30.3.6.1.10 and 57.5.3.')
if mibBuilder.loadTexts: eoamEventLogType.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogType.setDescription("The type of event that generated this entry in the event log. When the OUI is the IEEE 802.3 OUI of 0x0180C2, the following event types are defined: erroredSymbolEvent(1), erroredFramePeriodEvent(2), erroredFrameEvent(3), erroredFrameSecondsEvent(4), linkFault(256), dyingGaspEvent(257), criticalLinkEvent(258) The first four are considered threshold crossing events, as they are generated when a metric exceeds a given value within a specified window. The other three are not threshold crossing events. When the OUI is not 71874 (0x0180C2 in hex), then some other organization has defined the event space. If event subtyping is known to the implementation, it may be reflected here. Otherwise, this value should return all F's (2^32 - 1). ")
eoamEventLogLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("local", 1), ("remote", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogLocation.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogLocation.setDescription('Whether this event occurred locally (local(1)), or was received from the OAM peer via Ethernet OAM (remote(2)). ')
eoamEventLogValue = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogValue.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogValue.setDescription('The Ethernet OAM event log event value.')
eoamEventLogWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogWindow.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogWindow.setDescription('The Ethernet OAM event log window value.')
eoamEventLogThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogThreshold.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogThreshold.setDescription('The Ethernet OAM event log Threshold value.')
eoamEventLogAccError = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 2, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamEventLogAccError.setStatus('current')
if mibBuilder.loadTexts: eoamEventLogAccError.setDescription('The Ethernet OAM event log accumulate errors.')
sysEoamEventLogClearPortlist = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 4, 3), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysEoamEventLogClearPortlist.setStatus('current')
if mibBuilder.loadTexts: sysEoamEventLogClearPortlist.setDescription('Clear Eoam Event Log Table according to portlist setting')
eoamTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 5, 0))
eoamNotifyThresholdEvent = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 5, 0, 1)).setObjects(("DGS-1100-10ME_A1", "eoamEventLogPort"), ("DGS-1100-10ME_A1", "eoamEventLogTimestamp"), ("DGS-1100-10ME_A1", "eoamEventLogType"), ("DGS-1100-10ME_A1", "eoamEventLogLocation"), ("DGS-1100-10ME_A1", "eoamEventLogValue"), ("DGS-1100-10ME_A1", "eoamEventLogWindow"), ("DGS-1100-10ME_A1", "eoamEventLogThreshold"), ("DGS-1100-10ME_A1", "eoamEventLogAccError"))
if mibBuilder.loadTexts: eoamNotifyThresholdEvent.setStatus('current')
if mibBuilder.loadTexts: eoamNotifyThresholdEvent.setDescription('eoamNotifyThresholdEvent trap is sent when a local or remote threshold crossing event is detected')
eoamNotifyNonThresholdEvent = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 5, 0, 2)).setObjects(("DGS-1100-10ME_A1", "eoamEventLogPort"), ("DGS-1100-10ME_A1", "eoamEventLogTimestamp"), ("DGS-1100-10ME_A1", "eoamEventLogType"), ("DGS-1100-10ME_A1", "eoamEventLogLocation"), ("DGS-1100-10ME_A1", "eoamEventLogAccError"))
if mibBuilder.loadTexts: eoamNotifyNonThresholdEvent.setStatus('current')
if mibBuilder.loadTexts: eoamNotifyNonThresholdEvent.setDescription('eoamNotifyNonThresholdEvent trap is sent when a local or remote non-threshold crossing event is detected')
eoamLoopbackTestTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1), )
if mibBuilder.loadTexts: eoamLoopbackTestTable.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestTable.setDescription('This table contains objects to configure Remote Loopback mode and loopback tests.')
eoamLoopbackTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "eoamLoopbackTestIndex"))
if mibBuilder.loadTexts: eoamLoopbackTestEntry.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestEntry.setDescription('This table contains remote loopback configuration and loopback test configuration.')
eoamLoopbackTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackTestIndex.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestIndex.setDescription('fault management loopback port index.')
eoamLoopbackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noLoopback", 1), ("remoteLoopback", 2), ("unknown", 3))).clone('unknown')).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackStatus.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatus.setDescription('The loopback status of the local interface. This status is obtained from the local EOAM Client. When operating in normal mode with no loopback in progress, the status reads noLoopback(1). If the local OAM client knows that the remote OAM entity is in loopback mode , the status is remoteLoopback(2). The unknown(3) status indicates the loopback status is not known.')
eoamLoopbackTestPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamLoopbackTestPattern.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestPattern.setDescription("Test Pattern for the remote loopback test. The default pattern of the test data will be 'F0F0F0F0'H ")
eoamLoopbackTestPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(64, 1500)).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamLoopbackTestPktSize.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestPktSize.setDescription('Test packet size for the remote loopback test')
eoamLoopbackTestCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamLoopbackTestCount.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestCount.setDescription('Number of Test packets to be sent for the remote loopback test')
eoamLoopbackTestWaitTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamLoopbackTestWaitTime.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestWaitTime.setDescription('This timer is started after sending the last test packet. The Fault management module will wait until this timer expires or the packet reception counter is equal to the transmission counter. This timer (in seconds) denotes the maximum time a packet can take to get looped back.')
eoamLoopbackTestCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noLoopbackTest", 1), ("startLoopbackTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: eoamLoopbackTestCommand.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestCommand.setDescription("This attribute initiates remote loopback test with an EOAM peer. Writing startLoopbackTest(2) to this attribute cause the fault management send loopback test packets with defined test pattern, size and count. Writing noLoopbackTest to this attribute has no effect. Writes to this attribute are ignored unless the fsFmLoopbackStatus of this interface is 'remoteLoopback'. The attribute always returns noLoopbackTest on a read. ")
eoamLoopbackTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notInitiated", 1), ("loopbackTestInprogress", 2), ("loopbackTestCompleted", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackTestStatus.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestStatus.setDescription("This attribute indicates the status of the remote loopback test. 'notInitiated' indicates that the loopback has not been initiated yet. 'loopbackbTestInprogress' indicates that the loopback test is in progress. 'loopbackbTestCompleted' indicates that the loopback test has been completed.")
eoamLoopbackTestStartTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackTestStartTimestamp.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestStartTimestamp.setDescription('Start timestamp of the current loopback test.')
eoamLoopbackTestEndTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackTestEndTimestamp.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestEndTimestamp.setDescription('End timestamp of the current loopback test.')
eoamLoopbackTestTxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackTestTxCount.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestTxCount.setDescription('Statistics of number of Test packets transmitted during current loopback test.')
eoamLoopbackTestRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 12), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackTestRxCount.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestRxCount.setDescription('Statistics of number of Test packets received during current loopback test.')
eoamLoopbackTestMatchCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackTestMatchCount.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackTestMatchCount.setDescription('Statistics of number of Test packets that matched with the test pattern sent during current loopback test.')
eoamLoopbackStatsTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2), )
if mibBuilder.loadTexts: eoamLoopbackStatsTable.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsTable.setDescription('This table contains statistics of the last remote loopback test.')
eoamLoopbackStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "eoamLoopbackStatsIndex"))
if mibBuilder.loadTexts: eoamLoopbackStatsEntry.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsEntry.setDescription('This table contains remote loopback test results of the last session. This table is updated every time a new loopback test session is started. The current fsFmLBTestTxCount, fsFmLBTestRxCount and fsFmLBTestMatchCount are copied to this table before starting the new test.')
eoamLoopbackStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackStatsIndex.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsIndex.setDescription('fault management loopback port index.')
eoamLoopbackStatsStartTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackStatsStartTimestamp.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsStartTimestamp.setDescription('Start timestamp of the current loopback test.')
eoamLoopbackStatsEndTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(40, 40)).setFixedLength(40)).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackStatsEndTimestamp.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsEndTimestamp.setDescription('End timestamp of the current loopback test.')
eoamLoopbackStatsTxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackStatsTxCount.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsTxCount.setDescription('Statistics of number of Test packets transmitted during last loopback test.')
eoamLoopbackStatsRxCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2, 1, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackStatsRxCount.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsRxCount.setDescription('Statistics of number of Test packets received during last loopback test.')
eoamLoopbackStatsMatchCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 51, 6, 2, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: eoamLoopbackStatsMatchCount.setStatus('current')
if mibBuilder.loadTexts: eoamLoopbackStatsMatchCount.setDescription('Statistics of number of Test packets that matched with the test pattern sent.')
trafficSegmentationTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 9, 1), )
if mibBuilder.loadTexts: trafficSegmentationTable.setStatus('current')
if mibBuilder.loadTexts: trafficSegmentationTable.setDescription('A Port-channel is created through ifMain table. After the creation of the port-channel, corresponding logical interface will be created in the ifMain table. This Port-channel table is indexed through Key values and allows to configure link selection policy and the Mac address for the port-channel. All other objects in this table displays the details of the port-channel')
trafficSegmentationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 9, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "trafficSegmentationIfIndex"))
if mibBuilder.loadTexts: trafficSegmentationEntry.setStatus('current')
if mibBuilder.loadTexts: trafficSegmentationEntry.setDescription('There is one entry in this table for each created port-channel port')
trafficSegmentationIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 9, 1, 1, 1), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trafficSegmentationIfIndex.setStatus('current')
if mibBuilder.loadTexts: trafficSegmentationIfIndex.setDescription("The ifIndex of the port-channel(Aggregator's interface index). ")
trafficSegmentationMemberList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 9, 1, 1, 2), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trafficSegmentationMemberList.setStatus('current')
if mibBuilder.loadTexts: trafficSegmentationMemberList.setDescription('Port list of port channel.')
sysPingDestIpType = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPingDestIpType.setStatus('current')
if mibBuilder.loadTexts: sysPingDestIpType.setDescription('The IP address type of the node to be pinged.')
sysPingDestIpAddr = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100, 2), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPingDestIpAddr.setStatus('current')
if mibBuilder.loadTexts: sysPingDestIpAddr.setDescription('The IP address of the node to be pinged, set ip type before set it.')
sysPingTimeout = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPingTimeout.setStatus('current')
if mibBuilder.loadTexts: sysPingTimeout.setDescription('The time in seconds after which the entity waiting for the ping response times out.')
sysPingTimes = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPingTimes.setStatus('current')
if mibBuilder.loadTexts: sysPingTimes.setDescription('The number of times the given node address is to be pinged. value 0 for infinite times.')
sysPingStart = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysPingStart.setStatus('current')
if mibBuilder.loadTexts: sysPingStart.setDescription('The ping event of ping operate.')
sysPingStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notinitiated", 1), ("progress", 2), ("completed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPingStatus.setStatus('current')
if mibBuilder.loadTexts: sysPingStatus.setDescription('The current status of the Ping operate')
sysPingSuccesses = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 100, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sysPingSuccesses.setStatus('current')
if mibBuilder.loadTexts: sysPingSuccesses.setDescription('The number of ping responses received.')
sysMacNotifyState = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysMacNotifyState.setStatus('current')
if mibBuilder.loadTexts: sysMacNotifyState.setDescription('This object can enabled or disabled MAC Notification.')
sysmacNotifyInterval = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysmacNotifyInterval.setStatus('current')
if mibBuilder.loadTexts: sysmacNotifyInterval.setDescription('This object indicates the time interval in second for trigger the MAC notify message. ')
sysmacNotifyHistorySize = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sysmacNotifyHistorySize.setStatus('current')
if mibBuilder.loadTexts: sysmacNotifyHistorySize.setDescription('This object indicates the history size of variation MAC in address table. The default value is 1 .')
sysmacNotifyCtrlTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 4), )
if mibBuilder.loadTexts: sysmacNotifyCtrlTable.setStatus('current')
if mibBuilder.loadTexts: sysmacNotifyCtrlTable.setDescription('A table to control Loopback detection features either for the entire switch or for each interface in the switch.')
macNotifyCtrlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 4, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "macNotifyPortIndex"))
if mibBuilder.loadTexts: macNotifyCtrlEntry.setStatus('current')
if mibBuilder.loadTexts: macNotifyCtrlEntry.setDescription('An entry appears in this table for each interface in the system.')
macNotifyPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: macNotifyPortIndex.setStatus('current')
if mibBuilder.loadTexts: macNotifyPortIndex.setDescription('The interface index of the port for which the configuration in this entry applies.')
macNotifyPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: macNotifyPortStatus.setStatus('current')
if mibBuilder.loadTexts: macNotifyPortStatus.setDescription('Provides control to per port enable or disable the mac notify status function. Default is disabled.')
sysMacNotifyTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 5))
fdbTableChanged = NotificationType((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 25, 5, 1)).setObjects(("DGS-1100-10ME_A1", "portSecFDBPermVlanID"), ("DGS-1100-10ME_A1", "portSecFDBPermMac"), ("DGS-1100-10ME_A1", "portSecFDBPermPort"))
if mibBuilder.loadTexts: fdbTableChanged.setStatus('current')
if mibBuilder.loadTexts: fdbTableChanged.setDescription('A fdbTableChanged notification is sent when dynamic forwarding table add learning mac; also when one device leave, dynamic forwarding table delete one mac,a fdbTableChanged notification is sent too. Note that transmission of fdbTableChanged notifications are throttled by the agent.')
sysArp = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 1))
arpTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 1, 1), )
if mibBuilder.loadTexts: arpTable.setStatus('current')
if mibBuilder.loadTexts: arpTable.setDescription('A table that contains ARP infomation')
arpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "arpIpAddr"))
if mibBuilder.loadTexts: arpEntry.setStatus('current')
if mibBuilder.loadTexts: arpEntry.setDescription('An entry appears in this table for each interface in the system.')
arpIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 1, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpIpAddr.setStatus('current')
if mibBuilder.loadTexts: arpIpAddr.setDescription('The IpAddress corresponding to the Mac Address.')
arpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 1, 1, 1, 2), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpMacAddress.setStatus('current')
if mibBuilder.loadTexts: arpMacAddress.setDescription('Ethernet Mac Address.')
arpType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("static", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpType.setStatus('current')
if mibBuilder.loadTexts: arpType.setDescription('The type of ARP mapping entry.')
arpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 1, 1, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: arpRowStatus.setStatus('current')
if mibBuilder.loadTexts: arpRowStatus.setDescription('The status of an entry in the ARP Table. A conceptual row can not be made active until the arpMacAddress object has been set.')
cmArpClear = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 15, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("clearAll", 1), ("cleatAllStatic", 2), ("clearAllDynamic", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cmArpClear.setStatus('current')
if mibBuilder.loadTexts: cmArpClear.setDescription('clear action type: none(0), -- no action clearAll(1), -- clear all arp entries cleatAllStatic, -- clear all static arp entries clearAllDynamic, -- clear all dynamic arp entries Initial its value is 0, and after each action, it will reset to 0')
sysUserAccount = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1))
adminUserTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1), )
if mibBuilder.loadTexts: adminUserTable.setStatus('current')
if mibBuilder.loadTexts: adminUserTable.setDescription('A table to management user table in the switch.')
adminUserEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "userName"))
if mibBuilder.loadTexts: adminUserEntry.setStatus('current')
if mibBuilder.loadTexts: adminUserEntry.setDescription('An entry appears in this table for each user in the system.')
userName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: userName.setStatus('current')
if mibBuilder.loadTexts: userName.setDescription('The name of user entry.')
userPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userPassword.setStatus('current')
if mibBuilder.loadTexts: userPassword.setDescription('The password of user entry. 0 means no password.')
userAccessRight = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("admin", 1), ("operator", 2), ("user", 3))).clone('admin')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userAccessRight.setStatus('current')
if mibBuilder.loadTexts: userAccessRight.setDescription('The access right of user entry.')
userEncrypt = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("plainText", 1), ("sha1", 2))).clone('sha1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userEncrypt.setStatus('current')
if mibBuilder.loadTexts: userEncrypt.setDescription('The encrypt type of user password.')
userEncryptControl = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: userEncryptControl.setStatus('current')
if mibBuilder.loadTexts: userEncryptControl.setDescription('Enable or disable Encrypt of user password.')
userRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 1, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: userRowStatus.setStatus('current')
if mibBuilder.loadTexts: userRowStatus.setDescription('The row status of user entry.')
sysPasswordEncrypt = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sysPasswordEncrypt.setStatus('current')
if mibBuilder.loadTexts: sysPasswordEncrypt.setDescription('encrypt control of user password, default password storage type is plaintext, if set enable, all password storage is dlinksha1 format.')
syssessionTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1), )
if mibBuilder.loadTexts: syssessionTable.setStatus('current')
if mibBuilder.loadTexts: syssessionTable.setDescription('A Table contain the user login session information.')
syssessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "sessionID"))
if mibBuilder.loadTexts: syssessionEntry.setStatus('current')
if mibBuilder.loadTexts: syssessionEntry.setDescription('A Session Table contain the user login information.')
sessionID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionID.setStatus('current')
if mibBuilder.loadTexts: sessionID.setDescription('The index of session table.')
sessionUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionUserName.setStatus('current')
if mibBuilder.loadTexts: sessionUserName.setDescription('The name of login user.')
sessionUserPrivilege = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5))).clone(namedValues=NamedValues(("user", 3), ("operator", 4), ("admin", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionUserPrivilege.setStatus('current')
if mibBuilder.loadTexts: sessionUserPrivilege.setDescription('login user privilege.')
sessionLoginTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionLoginTime.setStatus('current')
if mibBuilder.loadTexts: sessionLoginTime.setDescription('The time at which user login.')
sessionLiveTime = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionLiveTime.setStatus('current')
if mibBuilder.loadTexts: sessionLiveTime.setDescription('The time peroid user has kept login.')
sessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("http", 1), ("telnet", 2), ("ssh", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionType.setStatus('current')
if mibBuilder.loadTexts: sessionType.setDescription('login from http or telnet.')
sessionIP = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 102, 1, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sessionIP.setStatus('current')
if mibBuilder.loadTexts: sessionIP.setDescription('login ip through http or telnet.')
trustedHostStatus = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 13, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trustedHostStatus.setStatus('current')
if mibBuilder.loadTexts: trustedHostStatus.setDescription('This object indicates trusted host function is enabled or disabled. When trusted host function is enabled, Smart Switches will only allow hosts which you trust to access and control the switch. Your local host IP Addresses must be one of the IP Addresses to avoid disconnection.')
trustedHostTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 13, 2), )
if mibBuilder.loadTexts: trustedHostTable.setStatus('current')
if mibBuilder.loadTexts: trustedHostTable.setDescription('A table to configure IP authorized managers in the system.')
trustedHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 13, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "trustedHostIpAddr"), (0, "DGS-1100-10ME_A1", "trustedHostIpMask"))
if mibBuilder.loadTexts: trustedHostEntry.setStatus('current')
if mibBuilder.loadTexts: trustedHostEntry.setDescription('Each entry in this table represents rules for particular IP authorized manager.')
trustedHostIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 13, 2, 1, 1), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trustedHostIpAddr.setStatus('current')
if mibBuilder.loadTexts: trustedHostIpAddr.setDescription("Specifies either the Network or Host address from which the switch can be managed. An address 0.0.0.0 indicates 'Any Manager'.")
trustedHostIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 13, 2, 1, 2), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trustedHostIpMask.setStatus('current')
if mibBuilder.loadTexts: trustedHostIpMask.setDescription('Used to mask with IP address, it allow you set a subnet as a trusted host entry.')
trustedHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 14, 13, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: trustedHostRowStatus.setStatus('current')
if mibBuilder.loadTexts: trustedHostRowStatus.setDescription('This object indicates the status of this entry.')
sysAclProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1))
aclL2ProfileTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1), )
if mibBuilder.loadTexts: aclL2ProfileTable.setStatus('current')
if mibBuilder.loadTexts: aclL2ProfileTable.setDescription('A Table contain the L2 acl profile infomation.')
aclL2ProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aclL2ProfileID"))
if mibBuilder.loadTexts: aclL2ProfileEntry.setStatus('current')
if mibBuilder.loadTexts: aclL2ProfileEntry.setDescription('Entries of the aclL2ProfileTable')
aclL2ProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 150))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL2ProfileID.setStatus('current')
if mibBuilder.loadTexts: aclL2ProfileID.setDescription('The ACL Profile ID.')
aclL2RuleCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL2RuleCount.setStatus('current')
if mibBuilder.loadTexts: aclL2RuleCount.setDescription('Rule count in this profile.')
aclL2SrcMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2SrcMacMask.setStatus('current')
if mibBuilder.loadTexts: aclL2SrcMacMask.setDescription('L2 source mac address filter mask.')
aclL2DstMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2DstMacMask.setStatus('current')
if mibBuilder.loadTexts: aclL2DstMacMask.setDescription('L2 destination mac address filter mask.')
aclL28021pCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL28021pCheck.setStatus('current')
if mibBuilder.loadTexts: aclL28021pCheck.setDescription('Configure to decide whether to do 802.1p field check.')
aclL2VlanIdCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2VlanIdCheck.setStatus('current')
if mibBuilder.loadTexts: aclL2VlanIdCheck.setDescription('Configure to decide whether to do vlan id field check.')
aclL2EtherTypeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2EtherTypeCheck.setStatus('current')
if mibBuilder.loadTexts: aclL2EtherTypeCheck.setDescription('Configure to decide whether to do ether type check')
aclL2ProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclL2ProfileStatus.setStatus('current')
if mibBuilder.loadTexts: aclL2ProfileStatus.setDescription("This object indicates the status of this entry, can only be set to 'createAndWait','active' and 'destroy'. When the value of the entry status is 'createAndWait', it could be set to 'active' only if there is no configuration conflict.")
aclL3ProfileTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2), )
if mibBuilder.loadTexts: aclL3ProfileTable.setStatus('current')
if mibBuilder.loadTexts: aclL3ProfileTable.setDescription('A Table contain the L3 IPv4 acl profile infomation.')
aclL3ProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aclL3ProfileID"))
if mibBuilder.loadTexts: aclL3ProfileEntry.setStatus('current')
if mibBuilder.loadTexts: aclL3ProfileEntry.setDescription('Entries of the aclIpv4ProfileTable')
aclL3ProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 150))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL3ProfileID.setStatus('current')
if mibBuilder.loadTexts: aclL3ProfileID.setDescription('The ACL Profile ID.')
aclL3RuleCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL3RuleCount.setStatus('current')
if mibBuilder.loadTexts: aclL3RuleCount.setDescription('Rule count in this profile.')
aclL3ProfileType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 3), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3ProfileType.setStatus('current')
if mibBuilder.loadTexts: aclL3ProfileType.setDescription('Current profile type, valid type is ipv4 and ipv6')
aclL3Ip4SrcAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip4SrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip4SrcAddrMask.setDescription('L3 IPv4 source address filter mask.')
aclL3Ip4DstAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip4DstAddrMask.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip4DstAddrMask.setDescription('L3 IPv4 destination address filter mask.')
aclL3Ip4DscpCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip4DscpCheck.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip4DscpCheck.setDescription('L3 IPv4 DSCP/ToS check or not.')
aclL3Ip4TosCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip4TosCheck.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip4TosCheck.setDescription('L3 IPv4 DSCP/ToS check or not.')
aclL3Ip4Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 6, 17, 58))).clone(namedValues=NamedValues(("none", 0), ("icmp", 1), ("igmp", 2), ("tcp", 6), ("udp", 17), ("icmpv6", 58)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip4Protocol.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip4Protocol.setDescription('Indicate the IP Protocol to be care in this profile.')
aclL3Ip4ProtocolMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip4ProtocolMask.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip4ProtocolMask.setDescription('L3 IPv4 protocol id mask.')
aclL3Ip6SrcAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 10), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip6SrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip6SrcAddrMask.setDescription('L3 IPv6 source address filter mask.')
aclL3Ip6DstAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 11), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip6DstAddrMask.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip6DstAddrMask.setDescription('L3 IPv6 destination address filter mask.')
aclL3Ip6TrafficClassCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip6TrafficClassCheck.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip6TrafficClassCheck.setDescription('Configure to decide whether to do ip6 Traffic Class check')
aclL3IcmpTypeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IcmpTypeCheck.setStatus('current')
if mibBuilder.loadTexts: aclL3IcmpTypeCheck.setDescription('Configure to decide whether to do icmp type check')
aclL3IcmpCodeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IcmpCodeCheck.setStatus('current')
if mibBuilder.loadTexts: aclL3IcmpCodeCheck.setDescription('Configure to decide whether to do icmp code check')
aclL3IgmpTypeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IgmpTypeCheck.setStatus('current')
if mibBuilder.loadTexts: aclL3IgmpTypeCheck.setDescription('Configure to decide whether to do igmp type check')
aclL3SrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 16), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3SrcPortMask.setStatus('current')
if mibBuilder.loadTexts: aclL3SrcPortMask.setDescription('Source port filter mask.')
aclL3DstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 17), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3DstPortMask.setStatus('current')
if mibBuilder.loadTexts: aclL3DstPortMask.setDescription('Destination port filter mask.')
aclL3TcpFlagCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3TcpFlagCheck.setStatus('current')
if mibBuilder.loadTexts: aclL3TcpFlagCheck.setDescription('Configure to decide whether to do tcp flag check')
aclL3ProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 1, 2, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclL3ProfileStatus.setStatus('current')
if mibBuilder.loadTexts: aclL3ProfileStatus.setDescription("This object indicates the status of this entry, can only be set to 'createAndWait','active' and 'destroy'. When the value of the entry status is 'createAndWait', it could be set to 'active' only if there is no configuration conflict.")
sysAclRule = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2))
aclL2RuleTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1), )
if mibBuilder.loadTexts: aclL2RuleTable.setStatus('current')
if mibBuilder.loadTexts: aclL2RuleTable.setDescription('A Table contain the L2 acl rule infomation.')
aclL2RuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aclL2RuleProfileID"), (0, "DGS-1100-10ME_A1", "aclL2RuleAccessID"))
if mibBuilder.loadTexts: aclL2RuleEntry.setStatus('current')
if mibBuilder.loadTexts: aclL2RuleEntry.setDescription('Entries of the aclL2RuleTable')
aclL2RuleProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 150))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL2RuleProfileID.setStatus('current')
if mibBuilder.loadTexts: aclL2RuleProfileID.setDescription('The ACL Profile ID.')
aclL2RuleAccessID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL2RuleAccessID.setStatus('current')
if mibBuilder.loadTexts: aclL2RuleAccessID.setDescription('The ACL rule access ID.')
aclL2VlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2VlanId.setStatus('current')
if mibBuilder.loadTexts: aclL2VlanId.setDescription('Vlan id to be filter, 0 means not care.')
aclL2SrcMac = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2SrcMac.setStatus('current')
if mibBuilder.loadTexts: aclL2SrcMac.setDescription('L2 source mac address filter mask.')
aclL2DstMac = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2DstMac.setStatus('current')
if mibBuilder.loadTexts: aclL2DstMac.setDescription('L2 destination mac address filter mask.')
aclL28021p = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL28021p.setStatus('current')
if mibBuilder.loadTexts: aclL28021p.setDescription('Ethernet header 802.1p value to be filter, -1 means not care.')
aclL2EtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2EtherType.setStatus('current')
if mibBuilder.loadTexts: aclL2EtherType.setDescription('Ethernet type value to be filter, 0 means not care.')
aclL2InPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 8), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2InPortList.setStatus('current')
if mibBuilder.loadTexts: aclL2InPortList.setDescription('Packet from which ports that this rule apply on.')
aclL2Action = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6))).clone(namedValues=NamedValues(("permit", 1), ("drop", 2), ("rateLimit", 4), ("replaceDSCP", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2Action.setStatus('current')
if mibBuilder.loadTexts: aclL2Action.setDescription('Action for a packet that hit this rule.')
aclL2RateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2RateLimit.setStatus('current')
if mibBuilder.loadTexts: aclL2RateLimit.setDescription('Rate limit value for the packet hit.')
aclL2ReplaceDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL2ReplaceDSCP.setStatus('current')
if mibBuilder.loadTexts: aclL2ReplaceDSCP.setDescription('Replace the DSCP value configured. -1 means not care.')
aclL2RuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 1, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclL2RuleStatus.setStatus('current')
if mibBuilder.loadTexts: aclL2RuleStatus.setDescription('operation of rule action')
aclL3RuleTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2), )
if mibBuilder.loadTexts: aclL3RuleTable.setStatus('current')
if mibBuilder.loadTexts: aclL3RuleTable.setDescription('A Table contain the L3 IPv4 acl rule infomation.')
aclL3RuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "aclL3RuleProfileID"), (0, "DGS-1100-10ME_A1", "aclL3RuleAccessID"))
if mibBuilder.loadTexts: aclL3RuleEntry.setStatus('current')
if mibBuilder.loadTexts: aclL3RuleEntry.setDescription('Entries of the acL3RuleTable')
aclL3RuleProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 150))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL3RuleProfileID.setStatus('current')
if mibBuilder.loadTexts: aclL3RuleProfileID.setDescription('The ACL Profile ID.')
aclL3RuleAccessID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclL3RuleAccessID.setStatus('current')
if mibBuilder.loadTexts: aclL3RuleAccessID.setDescription('The ACL rule access ID.')
aclL3IP4SrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IP4SrcAddr.setStatus('current')
if mibBuilder.loadTexts: aclL3IP4SrcAddr.setDescription('ipv4 source address to filter')
aclL3IP4DstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IP4DstAddr.setStatus('current')
if mibBuilder.loadTexts: aclL3IP4DstAddr.setDescription('ipv4 destination address to filter')
aclL3IP4DSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IP4DSCP.setStatus('current')
if mibBuilder.loadTexts: aclL3IP4DSCP.setDescription('ipv4 dscp value to filter, -1 means do not care.')
aclL3IP4ToS = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IP4ToS.setStatus('current')
if mibBuilder.loadTexts: aclL3IP4ToS.setDescription('ipv4 tos value to filter, -1 means do not care.')
aclL3IP4Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IP4Protocol.setStatus('current')
if mibBuilder.loadTexts: aclL3IP4Protocol.setDescription('ipv4 protocol value to filter, 255 means do not care.')
aclL3IP6SrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 8), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IP6SrcAddr.setStatus('current')
if mibBuilder.loadTexts: aclL3IP6SrcAddr.setDescription('ipv6 source address to filter')
aclL3IP6DstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 9), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IP6DstAddr.setStatus('current')
if mibBuilder.loadTexts: aclL3IP6DstAddr.setDescription('ipv6 destination address to filter')
aclL3Ip6TrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Ip6TrafficClass.setStatus('current')
if mibBuilder.loadTexts: aclL3Ip6TrafficClass.setDescription('ipv6 traffic class to filter')
aclL3IcmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 11), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IcmpType.setStatus('current')
if mibBuilder.loadTexts: aclL3IcmpType.setDescription('the icmp type value to filter')
aclL3IcmpCode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 12), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IcmpCode.setStatus('current')
if mibBuilder.loadTexts: aclL3IcmpCode.setDescription('the icmp code value to filter')
aclL3IgmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3IgmpType.setStatus('current')
if mibBuilder.loadTexts: aclL3IgmpType.setDescription('the igmp type value to filter')
aclL3SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3SrcPort.setStatus('current')
if mibBuilder.loadTexts: aclL3SrcPort.setDescription('the source port to filter')
aclL3DstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3DstPort.setStatus('current')
if mibBuilder.loadTexts: aclL3DstPort.setDescription('the destination port to filter')
aclL3TcpFlagURG = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3TcpFlagURG.setStatus('current')
if mibBuilder.loadTexts: aclL3TcpFlagURG.setDescription('check tcp urg flag set or not.')
aclL3TcpFlagACK = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3TcpFlagACK.setStatus('current')
if mibBuilder.loadTexts: aclL3TcpFlagACK.setDescription('check tcp ack flag set or not.')
aclL3TcpFlagPSH = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3TcpFlagPSH.setStatus('current')
if mibBuilder.loadTexts: aclL3TcpFlagPSH.setDescription('check tcp psh flag set or not.')
aclL3TcpFlagRST = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3TcpFlagRST.setStatus('current')
if mibBuilder.loadTexts: aclL3TcpFlagRST.setDescription('check tcp rst flag set or not.')
aclL3TcpFlagSYN = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3TcpFlagSYN.setStatus('current')
if mibBuilder.loadTexts: aclL3TcpFlagSYN.setDescription('check tcp syn flag set or not.')
aclL3TcpFlagFIN = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3TcpFlagFIN.setStatus('current')
if mibBuilder.loadTexts: aclL3TcpFlagFIN.setDescription('check tco fin flag set or not.')
aclL3InPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 22), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3InPortList.setStatus('current')
if mibBuilder.loadTexts: aclL3InPortList.setDescription('Packet from which ports that this rule apply on.')
aclL3Action = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 6))).clone(namedValues=NamedValues(("permit", 1), ("drop", 2), ("rateLimit", 4), ("replaceDSCP", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3Action.setStatus('current')
if mibBuilder.loadTexts: aclL3Action.setDescription('Action for a packet that hit this rule.')
aclL3RateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 1000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3RateLimit.setStatus('current')
if mibBuilder.loadTexts: aclL3RateLimit.setDescription('Rate limit value for the packet hit.')
aclL3ReplaceDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aclL3ReplaceDSCP.setStatus('current')
if mibBuilder.loadTexts: aclL3ReplaceDSCP.setDescription('replace dscp value to configured, -1 means not care.')
aclL3RuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 2, 2, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aclL3RuleStatus.setStatus('current')
if mibBuilder.loadTexts: aclL3RuleStatus.setDescription('operation of rule action.')
sysAclStatistic = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 3))
aclTotalProfile = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclTotalProfile.setStatus('current')
if mibBuilder.loadTexts: aclTotalProfile.setDescription('Total profile entry count')
aclUsedProfile = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclUsedProfile.setStatus('current')
if mibBuilder.loadTexts: aclUsedProfile.setDescription('Profile entry number that in use')
aclTotalRule = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclTotalRule.setStatus('current')
if mibBuilder.loadTexts: aclTotalRule.setDescription('Total rule entry count')
aclUsedRule = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 103, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aclUsedRule.setStatus('current')
if mibBuilder.loadTexts: aclUsedRule.setDescription('Rule entry number that in use')
sysCpuAclProfile = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1))
cpuAclL2ProfileTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1), )
if mibBuilder.loadTexts: cpuAclL2ProfileTable.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2ProfileTable.setDescription('A Table contain the L2 acl profile infomation.')
cpuAclL2ProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "cpuAclL2ProfileID"))
if mibBuilder.loadTexts: cpuAclL2ProfileEntry.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2ProfileEntry.setDescription('Entries of the cpuAclL2ProfileTable')
cpuAclL2ProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL2ProfileID.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2ProfileID.setDescription('The ACL Profile ID.')
cpuAclL2RuleCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL2RuleCount.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2RuleCount.setDescription('Rule count in this profile.')
cpuAclL2SrcMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 3), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2SrcMacMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2SrcMacMask.setDescription('L2 source mac address filter mask.')
cpuAclL2DstMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2DstMacMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2DstMacMask.setDescription('L2 destination mac address filter mask.')
cpuAclL28021pCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL28021pCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL28021pCheck.setDescription('Configure to decide whether to do 802.1p field check.')
cpuAclL2VlanIdCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2VlanIdCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2VlanIdCheck.setDescription('Configure to decide whether to do vlan id field check.')
cpuAclL2EtherTypeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2EtherTypeCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2EtherTypeCheck.setDescription('Configure to decide whether to do ether type check')
cpuAclL2ProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpuAclL2ProfileStatus.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2ProfileStatus.setDescription("This object indicates the status of this entry, can only be set to 'createAndWait','active' and 'destroy'. When the value of the entry status is 'createAndWait', it could be set to 'active' only if there is no configuration conflict.")
cpuAclL3ProfileTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2), )
if mibBuilder.loadTexts: cpuAclL3ProfileTable.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3ProfileTable.setDescription('A Table contain the L3 IPv4 acl profile infomation.')
cpuAclL3ProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "cpuAclL3ProfileID"))
if mibBuilder.loadTexts: cpuAclL3ProfileEntry.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3ProfileEntry.setDescription('Entries of the aclIpv4ProfileTable')
cpuAclL3ProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL3ProfileID.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3ProfileID.setDescription('The ACL Profile ID.')
cpuAclL3RuleCount = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL3RuleCount.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3RuleCount.setDescription('Rule count in this profile.')
cpuAclL3ProfileType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 3), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3ProfileType.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3ProfileType.setDescription('Current profile type, valid type is ipv4 and ipv6')
cpuAclL3Ip4SrcAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4SrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4SrcAddrMask.setDescription('L3 IPv4 source address filter mask.')
cpuAclL3Ip4DstAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4DstAddrMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4DstAddrMask.setDescription('L3 IPv4 destination address filter mask.')
cpuAclL3Ip4DscpCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4DscpCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4DscpCheck.setDescription('L3 IPv4 DSCP/ToS check or not.')
cpuAclL3Ip4Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 6, 17))).clone(namedValues=NamedValues(("none", 0), ("icmp", 1), ("igmp", 2), ("tcp", 6), ("udp", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4Protocol.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4Protocol.setDescription('Indicate the IP Protocol to be care in this profile.')
cpuAclL3Ip4ProtocolMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4ProtocolMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4ProtocolMask.setDescription('L3 IPv4 protocol id mask.')
cpuAclL3Ip4IcmpTypeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4IcmpTypeCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4IcmpTypeCheck.setDescription('Configure to decide whether to do icmp type check')
cpuAclL3Ip4IcmpCodeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4IcmpCodeCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4IcmpCodeCheck.setDescription('Configure to decide whether to do icmp code check')
cpuAclL3Ip4IgmpTypeCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4IgmpTypeCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4IgmpTypeCheck.setDescription('Configure to decide whether to do igmp type check')
cpuAclL3Ip4SrcPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 12), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4SrcPortMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4SrcPortMask.setDescription('Source port filter mask.')
cpuAclL3Ip4DstPortMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 13), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4DstPortMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4DstPortMask.setDescription('Destination port filter mask.')
cpuAclL3Ip4TcpFlagCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip4TcpFlagCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip4TcpFlagCheck.setDescription('Configure to decide whether to do tcp flag check')
cpuAclL3Ip6SrcAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 15), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip6SrcAddrMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip6SrcAddrMask.setDescription('L3 IPv6 source address filter mask.')
cpuAclL3Ip6DstAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 16), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip6DstAddrMask.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip6DstAddrMask.setDescription('L3 IPv6 destination address filter mask.')
cpuAclL3Ip6TrafficClassCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip6TrafficClassCheck.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip6TrafficClassCheck.setDescription('Configure to decide whether to do ip6 Traffic Class check')
cpuAclL3ProfileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 1, 2, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpuAclL3ProfileStatus.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3ProfileStatus.setDescription("This object indicates the status of this entry, can only be set to 'createAndWait','active' and 'destroy'. When the value of the entry status is 'createAndWait', it could be set to 'active' only if there is no configuration conflict.")
sysCpuAclRule = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2))
cpuAclL2RuleTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1), )
if mibBuilder.loadTexts: cpuAclL2RuleTable.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2RuleTable.setDescription('A Table contain the L2 acl rule infomation.')
cpuAclL2RuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "cpuAclL2RuleProfileID"), (0, "DGS-1100-10ME_A1", "cpuAclL2RuleAccessID"))
if mibBuilder.loadTexts: cpuAclL2RuleEntry.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2RuleEntry.setDescription('Entries of the cpuAclL2RuleTable')
cpuAclL2RuleProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL2RuleProfileID.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2RuleProfileID.setDescription('The ACL Profile ID.')
cpuAclL2RuleAccessID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL2RuleAccessID.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2RuleAccessID.setDescription('The ACL rule access ID.')
cpuAclL2VlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2VlanId.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2VlanId.setDescription('Vlan id to be filter, 0 means not care.')
cpuAclL2SrcMac = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 4), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2SrcMac.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2SrcMac.setDescription('L2 source mac address filter mask.')
cpuAclL2DstMac = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 5), MacAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2DstMac.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2DstMac.setDescription('L2 destination mac address filter mask.')
cpuAclL28021p = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL28021p.setStatus('current')
if mibBuilder.loadTexts: cpuAclL28021p.setDescription('Ethernet header 802.1p value to be filter, 0 means not care.')
cpuAclL2EtherType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1501, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2EtherType.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2EtherType.setDescription('Ethernet type value to be filter, 0 means not care.')
cpuAclL2InPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 8), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2InPortList.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2InPortList.setDescription('Packet from which ports that this rule apply on.')
cpuAclL2Action = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL2Action.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2Action.setDescription('Action for a packet that hit this rule.')
cpuAclL2RuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 1, 1, 10), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpuAclL2RuleStatus.setStatus('current')
if mibBuilder.loadTexts: cpuAclL2RuleStatus.setDescription('operation of rule action')
cpuAclL3RuleTable = MibTable((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2), )
if mibBuilder.loadTexts: cpuAclL3RuleTable.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3RuleTable.setDescription('A Table contain the L3 IPv4 acl rule infomation.')
cpuAclL3RuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1), ).setIndexNames((0, "DGS-1100-10ME_A1", "cpuAclL3RuleProfileID"), (0, "DGS-1100-10ME_A1", "cpuAclL3RuleAccessID"))
if mibBuilder.loadTexts: cpuAclL3RuleEntry.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3RuleEntry.setDescription('Entries of the acL3RuleTable')
cpuAclL3RuleProfileID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL3RuleProfileID.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3RuleProfileID.setDescription('The ACL Profile ID.')
cpuAclL3RuleAccessID = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclL3RuleAccessID.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3RuleAccessID.setDescription('The ACL rule access ID.')
cpuAclL3IP4SrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4SrcAddr.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4SrcAddr.setDescription('ipv4 source address to filter')
cpuAclL3IP4DstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4DstAddr.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4DstAddr.setDescription('ipv4 destination address to filter')
cpuAclL3IP4DSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4DSCP.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4DSCP.setDescription('ipv4 dscp value to filter, -1 means do not care.')
cpuAclL3IP4Protocol = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4Protocol.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4Protocol.setDescription('ipv4 protocol value to filter, 255 means do not care.')
cpuAclL3IP4IcmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4IcmpType.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4IcmpType.setDescription('the icmp type value to filter')
cpuAclL3IP4IcmpCode = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4IcmpCode.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4IcmpCode.setDescription('the icmp code value to filter')
cpuAclL3IP4IgmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4IgmpType.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4IgmpType.setDescription('the igmp type value to filter')
cpuAclL3IP4SrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4SrcPort.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4SrcPort.setDescription('the source port to filter')
cpuAclL3IP4DstPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4DstPort.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4DstPort.setDescription('the destination port to filter')
cpuAclL3IP4TcpFlagURG = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagURG.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagURG.setDescription('check tcp urg flag set or not.')
cpuAclL3IP4TcpFlagACK = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagACK.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagACK.setDescription('check tcp ack flag set or not.')
cpuAclL3IP4TcpFlagPSH = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagPSH.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagPSH.setDescription('check tcp psh flag set or not.')
cpuAclL3IP4TcpFlagRST = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagRST.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagRST.setDescription('check tcp rst flag set or not.')
cpuAclL3IP4TcpFlagSYN = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagSYN.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagSYN.setDescription('check tcp syn flag set or not.')
cpuAclL3IP4TcpFlagFIN = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("set", 1), ("notSet", 2), ("any", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagFIN.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP4TcpFlagFIN.setDescription('check tco fin flag set or not.')
cpuAclL3InPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 18), PortList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3InPortList.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3InPortList.setDescription('Packet from which ports that this rule apply on.')
cpuAclL3Action = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("drop", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Action.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Action.setDescription('Action for a packet that hit this rule.')
cpuAclL3IP6SrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 20), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP6SrcAddr.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP6SrcAddr.setDescription('ipv6 source address to filter')
cpuAclL3IP6DstAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 21), Ipv6Address()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3IP6DstAddr.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3IP6DstAddr.setDescription('ipv6 destination address to filter')
cpuAclL3Ip6TrafficClass = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpuAclL3Ip6TrafficClass.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3Ip6TrafficClass.setDescription('ipv6 traffic class to filter')
cpuAclL3RuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 2, 2, 1, 23), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpuAclL3RuleStatus.setStatus('current')
if mibBuilder.loadTexts: cpuAclL3RuleStatus.setDescription('operation of rule action')
sysCpuAclStatistic = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 3))
cpuAclTotalProfile = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclTotalProfile.setStatus('current')
if mibBuilder.loadTexts: cpuAclTotalProfile.setDescription('Total profile entry count')
cpuAclUsedProfile = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclUsedProfile.setStatus('current')
if mibBuilder.loadTexts: cpuAclUsedProfile.setDescription('Profile entry number that in use')
cpuAclTotalRule = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclTotalRule.setStatus('current')
if mibBuilder.loadTexts: cpuAclTotalRule.setDescription('Total rule entry count')
cpuAclUsedRule = MibScalar((1, 3, 6, 1, 4, 1, 171, 10, 134, 2, 1, 104, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuAclUsedRule.setStatus('current')
if mibBuilder.loadTexts: cpuAclUsedRule.setDescription('Rule entry number that in use')
mibBuilder.exportSymbols("DGS-1100-10ME_A1", cpuAclL2DstMacMask=cpuAclL2DstMacMask, mldsHostTableVLANID=mldsHostTableVLANID, sysMACAgingTime=sysMACAgingTime, igsVlanQueryMaxResponseTime=igsVlanQueryMaxResponseTime, tftpCfgTargetServerIpAddress=tftpCfgTargetServerIpAddress, lldpMisConfigMaxFrameSize=lldpMisConfigMaxFrameSize, lldpRemUnknownTLVEntry=lldpRemUnknownTLVEntry, companyMulticastFilter=companyMulticastFilter, aclL3RuleAccessID=aclL3RuleAccessID, qosDiffServType36=qosDiffServType36, aacAPEnableMethod=aacAPEnableMethod, sysQosScheduling=sysQosScheduling, pnacPortAccessControlEntry=pnacPortAccessControlEntry, lldpRemManAddr=lldpRemManAddr, pnacConfigPortNumber=pnacConfigPortNumber, companyDot1qVlanGroup=companyDot1qVlanGroup, lldpXdot3RemoteData=lldpXdot3RemoteData, aacLoginMethod2=aacLoginMethod2, dot1qVlanName=dot1qVlanName, pnacRadiusServerTimeout=pnacRadiusServerTimeout, greenLEDShutoffTimeProfile1=greenLEDShutoffTimeProfile1, greenPortShutoffTimeProfile1=greenPortShutoffTimeProfile1, dhcpLocalRelayVlanId=dhcpLocalRelayVlanId, aclL2RateLimit=aclL2RateLimit, portSecurityState=portSecurityState, trustedHostEntry=trustedHostEntry, limitIPMulticastPortProfileID=limitIPMulticastPortProfileID, aclL28021p=aclL28021p, cpuAclL3IP4TcpFlagPSH=cpuAclL3IP4TcpFlagPSH, snmpUserName=snmpUserName, bandwidthCtrlEffectiveTxThreshold=bandwidthCtrlEffectiveTxThreshold, trafficCtrlCountDown=trafficCtrlCountDown, timeRangeDate=timeRangeDate, dhcpv6RelayInterfaceTable=dhcpv6RelayInterfaceTable, qosDiffServType11=qosDiffServType11, qinQVlanTransRowStatus=qinQVlanTransRowStatus, qosSchedulingClassIndex=qosSchedulingClassIndex, sysDDPStatus=sysDDPStatus, dhcpRelayManagermentOption82=dhcpRelayManagermentOption82, companyStatistics=companyStatistics, eoamLoopbackStatsIndex=eoamLoopbackStatsIndex, aclUsedProfile=aclUsedProfile, lldpXdot3RemPowerTable=lldpXdot3RemPowerTable, aacServerInfoEntry=aacServerInfoEntry, cpuAclL3Ip6TrafficClass=cpuAclL3Ip6TrafficClass, ipv6AddressEntry=ipv6AddressEntry, eoamState=eoamState, aacLoginMethodListName=aacLoginMethodListName, mirrorTargetPort=mirrorTargetPort, LldpPortId=LldpPortId, companyDHCPv6Relay=companyDHCPv6Relay, cpuAclL3IP4DstPort=cpuAclL3IP4DstPort, sysTraceRouteCtlPort=sysTraceRouteCtlPort, sysLBDStateEnable=sysLBDStateEnable, eoamVariableResponseTx=eoamVariableResponseTx, snmpViewTreeStatus=snmpViewTreeStatus, companyLBD=companyLBD, aclL3Ip4ProtocolMask=aclL3Ip4ProtocolMask, staticMcastEgressPorts=staticMcastEgressPorts, sysDot1qVlanManagementid=sysDot1qVlanManagementid, ipv4DefaultGateway=ipv4DefaultGateway, pnacRadiusServerAddress=pnacRadiusServerAddress, timeRangeIndex=timeRangeIndex, qosDiffServType41=qosDiffServType41, sysTftpFwTargetGroup=sysTftpFwTargetGroup, staticMcastStatus=staticMcastStatus, errorFrameSecondsWindow=errorFrameSecondsWindow, pnacSuppTimeout=pnacSuppTimeout, aclL3ProfileStatus=aclL3ProfileStatus, cpuAclL2SrcMacMask=cpuAclL2SrcMacMask, sysCpuAclRule=sysCpuAclRule, qinQVlanTransAction=qinQVlanTransAction, trustedHostIpAddr=trustedHostIpAddr, ddpPortStatus=ddpPortStatus, snmpUserStatus=snmpUserStatus, bandwidthCtrlRxThreshold=bandwidthCtrlRxThreshold, sysMirrorPortTable=sysMirrorPortTable, adminUserEntry=adminUserEntry, lldpXdot3RemPortTable=lldpXdot3RemPortTable, pnacRadiusServerKey=pnacRadiusServerKey, ramLast5MinUsage=ramLast5MinUsage, sysDeviceType=sysDeviceType, sysPasswordEncrypt=sysPasswordEncrypt, mldsHostEntry=mldsHostEntry, eoamLinkMonitorIfIndex=eoamLinkMonitorIfIndex, aclL3TcpFlagURG=aclL3TcpFlagURG, lldpXdot1RemVlanNameLocalPortNum=lldpXdot1RemVlanNameLocalPortNum, igsVlanCfgQuerier=igsVlanCfgQuerier, dhcpv6RelayOption37CheckState=dhcpv6RelayOption37CheckState, pppoePortCircuitIDType=pppoePortCircuitIDType, rmonStatsIndex=rmonStatsIndex, arpType=arpType, pnacUserStatus=pnacUserStatus, aclL3RuleStatus=aclL3RuleStatus, qosDiffServType28=qosDiffServType28, portSecFDBPermanentTable=portSecFDBPermanentTable, sysAclStatistic=sysAclStatistic, sysIPv6neighborTable=sysIPv6neighborTable, portCtrlDynamicMacAutoLearn=portCtrlDynamicMacAutoLearn, lldpLocPortId=lldpLocPortId, sysPingStart=sysPingStart, aclL3SrcPortMask=aclL3SrcPortMask, cpuAclL28021p=cpuAclL28021p, trafficCtrlIndex=trafficCtrlIndex, statisticsEtherDropEvents=statisticsEtherDropEvents, dhcpv6RelayOption37RemoteIDType=dhcpv6RelayOption37RemoteIDType, pnacRadiusServerAccountingPort=pnacRadiusServerAccountingPort, traceRouteHistoryHAddr=traceRouteHistoryHAddr, eoamNotifyThresholdEvent=eoamNotifyThresholdEvent, companyMacNotify=companyMacNotify, snmpCommunityPolicy=snmpCommunityPolicy, portDescriptionTable=portDescriptionTable, snmpViewTreeSubtree=snmpViewTreeSubtree, lldpLocPortNum=lldpLocPortNum, qinQConfigEntry=qinQConfigEntry, tftpSyslogTargetInterfaceName=tftpSyslogTargetInterfaceName, ipv4SubnetMask=ipv4SubnetMask, cpuAclL3IP6DstAddr=cpuAclL3IP6DstAddr, aacAPLoginMethod=aacAPLoginMethod, snmpHostVersion=snmpHostVersion, aclL2VlanId=aclL2VlanId, sysPnacPortAccessCtrl=sysPnacPortAccessCtrl, aclL2RuleTable=aclL2RuleTable, qinQGlobalStatus=qinQGlobalStatus, ipifDuplicateIPDetected=ipifDuplicateIPDetected, lldpXdot3RemLinkAggTable=lldpXdot3RemLinkAggTable, sysEee=sysEee, timeRangeRowStatus=timeRangeRowStatus, companyGuestVLAN=companyGuestVLAN, lldpXdot3LocPortTable=lldpXdot3LocPortTable, lldpXdot1ConfigPortVlanTable=lldpXdot1ConfigPortVlanTable, sysRestart=sysRestart, sysMirrorStatus=sysMirrorStatus, rmonEventCommunity=rmonEventCommunity, qosDiffServType40=qosDiffServType40, aclL3IcmpCodeCheck=aclL3IcmpCodeCheck, lldpXdot3LocPortAutoNegEnabled=lldpXdot3LocPortAutoNegEnabled, tftpFwTargetServerIpType=tftpFwTargetServerIpType, companySNMP=companySNMP, pnacRadiusServerEntry=pnacRadiusServerEntry, lldpRemManTimeMark=lldpRemManTimeMark, lldpXdot1ConfigVlanNameEntry=lldpXdot1ConfigVlanNameEntry, eoamEventLogType=eoamEventLogType, aclL3InPortList=aclL3InPortList, mldsVlanFilterEntry=mldsVlanFilterEntry, mldsVlanFastLeave=mldsVlanFastLeave, limitIpMulticastRangeStatus=limitIpMulticastRangeStatus, lldpXdot1ConfigPortVlanEntry=lldpXdot1ConfigPortVlanEntry, rmonAlarmInterval=rmonAlarmInterval, lldpPortConfigAdminStatus=lldpPortConfigAdminStatus, lldpXdot3LocPortNum=lldpXdot3LocPortNum, portSecFDBPermMac=portSecFDBPermMac, trafficSegmentationTable=trafficSegmentationTable, lldpXdot3RemPortAutoNegAdvertisedCap=lldpXdot3RemPortAutoNegAdvertisedCap, snmpTrapDuplicateIPDetected=snmpTrapDuplicateIPDetected, qosPortBaseEffectivePriority=qosPortBaseEffectivePriority, eoamVariableRequestRx=eoamVariableRequestRx, mldsHostTablePort=mldsHostTablePort, pnacDirection=pnacDirection, qosSchedulingClassTable=qosSchedulingClassTable, igmpMulticastVlanName=igmpMulticastVlanName, ipv6AddressTable=ipv6AddressTable, eoamLoopbackTestStartTimestamp=eoamLoopbackTestStartTimestamp, eoamLoopbackStatsEndTimestamp=eoamLoopbackStatsEndTimestamp, rmonStatsEntry=rmonStatsEntry, snmpHostAddress=snmpHostAddress, aclL3Ip6TrafficClassCheck=aclL3Ip6TrafficClassCheck, cpuAclL3RuleStatus=cpuAclL3RuleStatus, eoamVariableRequestTx=eoamVariableRequestTx, qosDiffServType06=qosDiffServType06, timeRangeEndMinute=timeRangeEndMinute, dynamicFdbStatus=dynamicFdbStatus, adminUserTable=adminUserTable, sysTimeRangeSettingTable=sysTimeRangeSettingTable, statisticsOutDiscards=statisticsOutDiscards, qosDiffServType48=qosDiffServType48, igsVlanRouterEntry=igsVlanRouterEntry, sysEoamLinkMonitor=sysEoamLinkMonitor, qosDiffServType18=qosDiffServType18, pnacRadiusServerAuthenticationPort=pnacRadiusServerAuthenticationPort, lldpXdot1RemProtocolTimeMark=lldpXdot1RemProtocolTimeMark, userRowStatus=userRowStatus, userName=userName, sysmacNotifyCtrlTable=sysmacNotifyCtrlTable, igsVlanRouterTable=igsVlanRouterTable, dot1qVlanid=dot1qVlanid, eoamPeerMaxOAMPDU=eoamPeerMaxOAMPDU, lldpXdot3RemLinkAggLocalPortNum=lldpXdot3RemLinkAggLocalPortNum, lldpRemUnknownTLVTable=lldpRemUnknownTLVTable, pnacRadiusIPType=pnacRadiusIPType, snmpUserAuthProtocol=snmpUserAuthProtocol, cpuAclL3IP4SrcPort=cpuAclL3IP4SrcPort, snmpHostStatus=snmpHostStatus, snmpGroupSecurityModel=snmpGroupSecurityModel, companySNTPSetting=companySNTPSetting, sysFimwareuupgradefailed=sysFimwareuupgradefailed, portSecurityViolation=portSecurityViolation, cpuAclL3Ip4SrcAddrMask=cpuAclL3Ip4SrcAddrMask, igmpMulticastVlanMemberPort=igmpMulticastVlanMemberPort, sntpServerTable=sntpServerTable, cpuAclL3IP4TcpFlagFIN=cpuAclL3IP4TcpFlagFIN, lldpStatsTxPortNum=lldpStatsTxPortNum, rmonHistoryIndex=rmonHistoryIndex, sysGuestVlanPort=sysGuestVlanPort, lldpLocPortIdSubtype=lldpLocPortIdSubtype, snmpHostTable=snmpHostTable, lldpXdot3RemPowerMDIEnabled=lldpXdot3RemPowerMDIEnabled, sysTraceRouteCtlAddress=sysTraceRouteCtlAddress, tftpCfgTargetTftpOperationStatus=tftpCfgTargetTftpOperationStatus, rmonStatsDropEvents=rmonStatsDropEvents, companyDuld=companyDuld, igsVlanQueryInterval=igsVlanQueryInterval, sysLLDPTxDelay=sysLLDPTxDelay, ramLast5SecUsage=ramLast5SecUsage, OperationResponseStatus=OperationResponseStatus, companyGreenSetting=companyGreenSetting, lldpXdot1ConfigProtocolTable=lldpXdot1ConfigProtocolTable, lldpRemUnknownTLVType=lldpRemUnknownTLVType, aacEnableMethodListName=aacEnableMethodListName, portSecurityTable=portSecurityTable, eoamInformationTx=eoamInformationTx, mldsVlanRouterVlanId=mldsVlanRouterVlanId, eoamMaxOAMPDU=eoamMaxOAMPDU, errorFramePeriodNotifyState=errorFramePeriodNotifyState, sessionLoginTime=sessionLoginTime, portErrPortStatus=portErrPortStatus, sysDHCPv6RelayManagement=sysDHCPv6RelayManagement, companyRMON=companyRMON, pnacUserName=pnacUserName, lldpXdot3LocMaxFrameSizeTable=lldpXdot3LocMaxFrameSizeTable, aacEnableMethod3=aacEnableMethod3, sysTrustedHost=sysTrustedHost, lldpXdot3RemPowerPairs=lldpXdot3RemPowerPairs, eoamEventLogThreshold=eoamEventLogThreshold, eoamTable=eoamTable, statisticsInDiscards=statisticsInDiscards, cpuAclL2RuleStatus=cpuAclL2RuleStatus, loopbackRecovery=loopbackRecovery, lldpXdot1RemProtocolLocalPortNum=lldpXdot1RemProtocolLocalPortNum, userEncrypt=userEncrypt, rmonEventDescription=rmonEventDescription, aacServerRowStatus=aacServerRowStatus, qosPortBasePortIndex=qosPortBasePortIndex, igsVlanHostPortPurgeInterval=igsVlanHostPortPurgeInterval, aclL3Ip4SrcAddrMask=aclL3Ip4SrcAddrMask, cpuAclL2RuleProfileID=cpuAclL2RuleProfileID, sysIGMPMulticastVlanGroupTable=sysIGMPMulticastVlanGroupTable, dhcpRelayOption82State=dhcpRelayOption82State, lldpRxStatsPortEntry=lldpRxStatsPortEntry, ramLast1MinUsage=ramLast1MinUsage, sysCableDiagPair1FaultDistance=sysCableDiagPair1FaultDistance, portDescString=portDescString, syslogSaveMinutes=syslogSaveMinutes, aacServersInGroup=aacServersInGroup)
mibBuilder.exportSymbols("DGS-1100-10ME_A1", rmonAlarmRisingEventIndex=rmonAlarmRisingEventIndex, snmpGroupTable=snmpGroupTable, limitIPMulticastPortMaxGrp=limitIPMulticastPortMaxGrp, duldTable=duldTable, rmonAlarmSampleType=rmonAlarmSampleType, syslogFileSave=syslogFileSave, stormOccurred=stormOccurred, LldpLinkAggStatusMap=LldpLinkAggStatusMap, ipv6GlobalStatus=ipv6GlobalStatus, mldsVlanMulticastGroupMacAddress=mldsVlanMulticastGroupMacAddress, lldpRemTablesChange=lldpRemTablesChange, sysDHCPRelayControl=sysDHCPRelayControl, eoamEventLogIndex=eoamEventLogIndex, rmonAlarmStatus=rmonAlarmStatus, sysStormCtrlTrap=sysStormCtrlTrap, portSecurityLockAddrMode=portSecurityLockAddrMode, rmonEventIndex=rmonEventIndex, lldpConfigManAddrPortsTxEnable=lldpConfigManAddrPortsTxEnable, lldpXdot3RemLinkAggEntry=lldpXdot3RemLinkAggEntry, lldpConfigManAddr=lldpConfigManAddr, mldsVlanGrpQueryInterval=mldsVlanGrpQueryInterval, companyPPPoE=companyPPPoE, lldpXdot1ConfigVlanId=lldpXdot1ConfigVlanId, lldpMisConfigProtocolIdentity=lldpMisConfigProtocolIdentity, timeRangeEndYear=timeRangeEndYear, lldpLocManAddrIfSubtype=lldpLocManAddrIfSubtype, aclL3Ip6TrafficClass=aclL3Ip6TrafficClass, sysLBDMode=sysLBDMode, lldpXdot3PortConfigTable=lldpXdot3PortConfigTable, igsVlanFilterVlanId=igsVlanFilterVlanId, sysIpifTraps=sysIpifTraps, macNotifyPortStatus=macNotifyPortStatus, lldpXdot1LocVlanNameTable=lldpXdot1LocVlanNameTable, aclL3Ip4TosCheck=aclL3Ip4TosCheck, lldpXdot3LocPortAutoNegSupported=lldpXdot3LocPortAutoNegSupported, cpuAclL2EtherTypeCheck=cpuAclL2EtherTypeCheck, ipv6DefaultRouteMetric=ipv6DefaultRouteMetric, qosDiffServType39=qosDiffServType39, aclL3TcpFlagFIN=aclL3TcpFlagFIN, cpuAclL2ProfileTable=cpuAclL2ProfileTable, tftpSyslogTargetTftpOperationStatus=tftpSyslogTargetTftpOperationStatus, limitIpMulticastRangeEntry=limitIpMulticastRangeEntry, aclL2RuleEntry=aclL2RuleEntry, portErrPortState=portErrPortState, trustedHostIpMask=trustedHostIpMask, sysmacNotifyInterval=sysmacNotifyInterval, sysDHCPLocalRelayGlobalState=sysDHCPLocalRelayGlobalState, sysFimwareillegalfile=sysFimwareillegalfile, igmpMulticastVlanGroupFromIp=igmpMulticastVlanGroupFromIp, lldpXdot3RemPowerEntry=lldpXdot3RemPowerEntry, rmonHistoryStatus=rmonHistoryStatus, lldpXdot3RemIndex=lldpXdot3RemIndex, lldpXdot1ConfigPortVlanTxEnable=lldpXdot1ConfigPortVlanTxEnable, snmpTrapLBDDetection=snmpTrapLBDDetection, qosDiffServType49=qosDiffServType49, qosDiffServType09=qosDiffServType09, lldpXdot3RemPortEntry=lldpXdot3RemPortEntry, snmpHostIPType=snmpHostIPType, qosDiffServType44=qosDiffServType44, cpuAclL3IP4TcpFlagSYN=cpuAclL3IP4TcpFlagSYN, rmonAlarmFallingEventIndex=rmonAlarmFallingEventIndex, statisticsSingleCollisionFrames=statisticsSingleCollisionFrames, qosDiffServTypeGroup=qosDiffServTypeGroup, lldpRemSysName=lldpRemSysName, lldpXdot1ConfigVlanNameTxEnable=lldpXdot1ConfigVlanNameTxEnable, timeRangeStartYear=timeRangeStartYear, eoamLoopbackTestTable=eoamLoopbackTestTable, eoamVariableResponseRx=eoamVariableResponseRx, lldpDupManagmentAddress=lldpDupManagmentAddress, companyIgsGroup=companyIgsGroup, qinQOuterTPID=qinQOuterTPID, sysLLDPState=sysLLDPState, aclL3IcmpCode=aclL3IcmpCode, igsAccessAuthState=igsAccessAuthState, aclL2RuleCount=aclL2RuleCount, statisticsLateCollisions=statisticsLateCollisions, companyArp=companyArp, sysLLDPConfigManAddrEntry=sysLLDPConfigManAddrEntry, cpuAclL3ProfileStatus=cpuAclL3ProfileStatus, syslogSaveMode=syslogSaveMode, lldpXdot3RemPowerIndex=lldpXdot3RemPowerIndex, sysSNMPViewTree=sysSNMPViewTree, lldpLocSysCapEnabled=lldpLocSysCapEnabled, lldpXdot1LocTable=lldpXdot1LocTable, statisticsInErrors=statisticsInErrors, aclL3RateLimit=aclL3RateLimit, lldpRemManAddrIfId=lldpRemManAddrIfId, cpuAclL2RuleTable=cpuAclL2RuleTable, LldpPortNumber=LldpPortNumber, lldpXdot1ConfigProtocolEntry=lldpXdot1ConfigProtocolEntry, sntpPollInterval=sntpPollInterval, igsAccessAuthTable=igsAccessAuthTable, mldsVlanCfgQuerier=mldsVlanCfgQuerier, cpuAclL3Ip4IcmpTypeCheck=cpuAclL3Ip4IcmpTypeCheck, tftpFwTargetInterfaceName=tftpFwTargetInterfaceName, qosDiffServType03=qosDiffServType03, trafficCtrlThreshold=trafficCtrlThreshold, limitIpMulticastRangeEndIpAddr=limitIpMulticastRangeEndIpAddr, syslogServAddr=syslogServAddr, companySecurity=companySecurity, duldOperState=duldOperState, aclL2ProfileEntry=aclL2ProfileEntry, lldpXdot1LocProtocolIndex=lldpXdot1LocProtocolIndex, lldpXdot3RemMaxFrameSizeEntry=lldpXdot3RemMaxFrameSizeEntry, aclL3IP4DSCP=aclL3IP4DSCP, eoamUniqueEventNotificationRx=eoamUniqueEventNotificationRx, eoamLoopbackTestIndex=eoamLoopbackTestIndex, trafficCtrlTable=trafficCtrlTable, cpuAclL2RuleCount=cpuAclL2RuleCount, qinQAddInnerTag=qinQAddInnerTag, qosTrafficClassEntry=qosTrafficClassEntry, userPassword=userPassword, limitIPMulticastProfileEntry=limitIPMulticastProfileEntry, aacAPHttpLoginMethod=aacAPHttpLoginMethod, lldpRemManAddrIfSubtype=lldpRemManAddrIfSubtype, lldpExceedsMaxFrameSize=lldpExceedsMaxFrameSize, dot1qVlanRowStatus=dot1qVlanRowStatus, dhcpv6RelayState=dhcpv6RelayState, sysDynamicFdbTable=sysDynamicFdbTable, companyPing=companyPing, pppoePortUDFString=pppoePortUDFString, qosDiffServType31=qosDiffServType31, greenPortShutoffTimeProfile2=greenPortShutoffTimeProfile2, sysLLDPPortConfigEntry=sysLLDPPortConfigEntry, VlanIndex=VlanIndex, sysLLDPRemoteSystemsData=sysLLDPRemoteSystemsData, trafficCtrlActionMode=trafficCtrlActionMode, pnacPortAccessControlTable=pnacPortAccessControlTable, lldpXdot3RemPowerPortClass=lldpXdot3RemPowerPortClass, ipv6DefaultRouteTable=ipv6DefaultRouteTable, sysEoamEventLogClearPortlist=sysEoamEventLogClearPortlist, tftpSyslogTargetImageFileName=tftpSyslogTargetImageFileName, portUtilizTable=portUtilizTable, mldsVlanQueryInterval=mldsVlanQueryInterval, sysLLDPConfigManAddrTable=sysLLDPConfigManAddrTable, sysWebPortNumber=sysWebPortNumber, igsHostTableGroupAddress=igsHostTableGroupAddress, cpuLast1MinUsage=cpuLast1MinUsage, eoamPeerPDURev=eoamPeerPDURev, lldpStatsRxPortFramesTotal=lldpStatsRxPortFramesTotal, igsVlanQuerierVersion=igsVlanQuerierVersion, aclL3SrcPort=aclL3SrcPort, aacEnableMethodListRowStatus=aacEnableMethodListRowStatus, portUtilizTX=portUtilizTX, sessionType=sessionType, sysQosMode=sysQosMode, sysTraceRouteHistoryTable=sysTraceRouteHistoryTable, LldpChassisId=LldpChassisId, aclL3RuleEntry=aclL3RuleEntry, companyCPUACL=companyCPUACL, syssessionEntry=syssessionEntry, qosDiffServType58=qosDiffServType58, qinQVlanTransCVID=qinQVlanTransCVID, qosDiffServType26=qosDiffServType26, greenSystemHibernationTimeProfile2=greenSystemHibernationTimeProfile2, aacServerTimeout=aacServerTimeout, eeeEntry=eeeEntry, snmpViewTreeType=snmpViewTreeType, sysQosQueuingMechanism=sysQosQueuingMechanism, sysPort=sysPort, aacServerInfoTable=aacServerInfoTable, tftpSyslogTargetServerIpAddress=tftpSyslogTargetServerIpAddress, sysLBDCtrlTable=sysLBDCtrlTable, igsReportForwardRouterOnly=igsReportForwardRouterOnly, lldpStatsRemTablesInserts=lldpStatsRemTablesInserts, ipv6NeighborMacAddr=ipv6NeighborMacAddr, lldpXdot1LocPortNum=lldpXdot1LocPortNum, lldpXdot1RemProtoVlanTimeMark=lldpXdot1RemProtoVlanTimeMark, lldpStatsRemTablesDeletes=lldpStatsRemTablesDeletes, multicastFilterPortIndex=multicastFilterPortIndex, snmpCommunityEntry=snmpCommunityEntry, lldpXdot1LocEntry=lldpXdot1LocEntry, staticMacStatus=staticMacStatus, sysLBDEnabledVlanList=sysLBDEnabledVlanList, sntpServerEntry=sntpServerEntry, sysMulticastFilterPortTable=sysMulticastFilterPortTable, lldpStatsRemTablesLastChangeTime=lldpStatsRemTablesLastChangeTime, dlink_DGS1100SeriesProd=dlink_DGS1100SeriesProd, aacEnableMethod1=aacEnableMethod1, cpuAclL3RuleAccessID=cpuAclL3RuleAccessID, igmpMulticastVlanSourcePort=igmpMulticastVlanSourcePort, syslogMsgSeverity=syslogMsgSeverity, macNotifyPortIndex=macNotifyPortIndex, sysStaticMcastTable=sysStaticMcastTable, portSecurityEntry=portSecurityEntry, lldpXdot1LocProtocolEntry=lldpXdot1LocProtocolEntry, sysArp=sysArp, pnacRadiusServerIndex=pnacRadiusServerIndex, sysSNMPCommunity=sysSNMPCommunity, lldpLocSysName=lldpLocSysName, aclL3IcmpTypeCheck=aclL3IcmpTypeCheck, qosTrafficClassTable=qosTrafficClassTable, mldsVlanRouterStaticPortList=mldsVlanRouterStaticPortList, portUtilizAverage=portUtilizAverage, portCtrlAdminState=portCtrlAdminState, pnacRadiusServerTable=pnacRadiusServerTable, trafficCtrlEntry=trafficCtrlEntry, cpuAclL3Action=cpuAclL3Action, pnacServerTimeout=pnacServerTimeout, igsVlanFilterTable=igsVlanFilterTable, syslogMsgEntry=syslogMsgEntry, eoamLoopbackControlTx=eoamLoopbackControlTx, portUtilizIndex=portUtilizIndex, lldpXdot3RemPowerPairControlable=lldpXdot3RemPowerPairControlable, igsHostTableHostIPAddress=igsHostTableHostIPAddress, igsHostEntry=igsHostEntry, errorFrameWindow=errorFrameWindow, arpIpAddr=arpIpAddr, sysQosPortBase=sysQosPortBase, qinQInnerTPID=qinQInnerTPID, ipv6AutolinkloStatus=ipv6AutolinkloStatus, snmpGroupNotifyViewName=snmpGroupNotifyViewName, sysEoamLoopbackTest=sysEoamLoopbackTest, sysTelnetUDPPort=sysTelnetUDPPort, statisticsPkts64Octets=statisticsPkts64Octets, dot1qVlanPortVlanId=dot1qVlanPortVlanId, sysLBDPortStatus=sysLBDPortStatus, timeRangeMonday=timeRangeMonday, companyStaticMcast=companyStaticMcast, traceRouteHistoryStatus=traceRouteHistoryStatus, aacServerAuthKey=aacServerAuthKey, dhcpRelayInterfaceSettingsTable=dhcpRelayInterfaceSettingsTable, dhcpv6RelayServerIP=dhcpv6RelayServerIP, sysDHCPRelayManagement=sysDHCPRelayManagement, pnacUserPassword=pnacUserPassword, traceRouteHistoryProbeIndex=traceRouteHistoryProbeIndex, qosDiffServType30=qosDiffServType30, eoamLoopbackControlRx=eoamLoopbackControlRx, staticMcastMac=staticMcastMac, mldsStatus=mldsStatus, portErrTable=portErrTable, lldpXdot1RemProtoVlanLocalPortNum=lldpXdot1RemProtoVlanLocalPortNum, tftpFwTargetTransferPercentage=tftpFwTargetTransferPercentage, OwnerString=OwnerString, eoamLoopbackTestEndTimestamp=eoamLoopbackTestEndTimestamp, lldpRemManAddrTable=lldpRemManAddrTable, statisticsOutUcastPkts=statisticsOutUcastPkts, mldsVlanHostPortPurgeInterval=mldsVlanHostPortPurgeInterval, snmpHostEntry=snmpHostEntry, statisticsStatsCollisions=statisticsStatsCollisions, lldpXdot1RemProtocolId=lldpXdot1RemProtocolId, LldpSystemCapabilitiesMap=LldpSystemCapabilitiesMap, snmpGroupStatus=snmpGroupStatus, sysDDPReportTime=sysDDPReportTime, lldpStatsRemTablesAgeouts=lldpStatsRemTablesAgeouts, cpuAclL3InPortList=cpuAclL3InPortList, qosDiffServType24=qosDiffServType24, sysmacNotifyHistorySize=sysmacNotifyHistorySize, limitIpMulticastRangeTable=limitIpMulticastRangeTable, statisticsOutOctets=statisticsOutOctets, statisticsFrameTooLongs=statisticsFrameTooLongs, eoamLoopbackTestRxCount=eoamLoopbackTestRxCount, syslogClearLog=syslogClearLog, igsVlanQuerier=igsVlanQuerier)
mibBuilder.exportSymbols("DGS-1100-10ME_A1", snmpUserEntry=snmpUserEntry, eoamEventLogAccError=eoamEventLogAccError, loopbackOccur=loopbackOccur, lldpXdot3LocalData=lldpXdot3LocalData, sysPortSecurityTrap=sysPortSecurityTrap, portSecFDBPermType=portSecFDBPermType, qosDiffServType16=qosDiffServType16, sysCableDiagPair4FaultDistance=sysCableDiagPair4FaultDistance, greenPortShutoffPortList=greenPortShutoffPortList, mldsVlanFilterTable=mldsVlanFilterTable, aclL2ProfileTable=aclL2ProfileTable, sysLLDPMsgTxInterval=sysLLDPMsgTxInterval, pnacReAuthentication=pnacReAuthentication, eoamEventLogWindow=eoamEventLogWindow, lldpXdot1LocConfigVlanNamePortNum=lldpXdot1LocConfigVlanNamePortNum, aacLoginMethodListTable=aacLoginMethodListTable, trafficCtrlPortState=trafficCtrlPortState, LldpChassisIdSubtype=LldpChassisIdSubtype, lldpXdot1RemProtocolIdIndex=lldpXdot1RemProtocolIdIndex, lldpXdot1ConfigVlanPortNum=lldpXdot1ConfigVlanPortNum, companyMirror=companyMirror, cpuAclL3Ip4ProtocolMask=cpuAclL3Ip4ProtocolMask, eoamPeerMode=eoamPeerMode, statisticsInOctets=statisticsInOctets, sysTftpSyslogTargetGroup=sysTftpSyslogTargetGroup, trafficSegmentationIfIndex=trafficSegmentationIfIndex, sntpGMTMinutes=sntpGMTMinutes, staticMacPort=staticMacPort, lldpRemManIndex=lldpRemManIndex, lldpXdot3RemPortAutoNegEnabled=lldpXdot3RemPortAutoNegEnabled, sysMacNotifyTraps=sysMacNotifyTraps, dhcpv6RelayInterfaceEntry=dhcpv6RelayInterfaceEntry, cpuAclL3IP6SrcAddr=cpuAclL3IP6SrcAddr, sysLLDPMsgHoldMultiplier=sysLLDPMsgHoldMultiplier, lldpRemLocalPortNum=lldpRemLocalPortNum, lldpXdot1RemLocalPortNum=lldpXdot1RemLocalPortNum, lldpLocSysDesc=lldpLocSysDesc, portErrPortReason=portErrPortReason, lldpLocManAddrOID=lldpLocManAddrOID, portSecurityTraps=portSecurityTraps, portSecFDBPermPort=portSecFDBPermPort, snmpViewTreeEntry=snmpViewTreeEntry, LldpManAddress=LldpManAddress, companyMldsGroup=companyMldsGroup, sysPppoeGlobalState=sysPppoeGlobalState, igmpMulticastVlanRowStatus=igmpMulticastVlanRowStatus, aclUsedRule=aclUsedRule, snmpTrapFiberLinkUpDown=snmpTrapFiberLinkUpDown, sysBootVerion=sysBootVerion, syslogServAddrType=syslogServAddrType, eoamLinkMonitoring=eoamLinkMonitoring, tftpFwTargetTftpOperationStatus=tftpFwTargetTftpOperationStatus, mldsVlanRouterTable=mldsVlanRouterTable, sysQos1p=sysQos1p, TimeFilter=TimeFilter, timeRangeWednesday=timeRangeWednesday, qosDiffServType56=qosDiffServType56, sysPppoePortTable=sysPppoePortTable, qosDiffServType23=qosDiffServType23, eoamPDURev=eoamPDURev, sysEoamStats=sysEoamStats, snmpHostCommunityName=snmpHostCommunityName, lldpMisConfigVlanName=lldpMisConfigVlanName, lldpXdot3RemPowerTimeMark=lldpXdot3RemPowerTimeMark, dhcpv6RelayOption37State=dhcpv6RelayOption37State, tftpSyslogTargetTftpOperation=tftpSyslogTargetTftpOperation, lldpXdot1RemVlanNameIndex=lldpXdot1RemVlanNameIndex, lldpPortConfigPortNum=lldpPortConfigPortNum, timeRangeTuesday=timeRangeTuesday, statisticsClearStatus=statisticsClearStatus, lldpXdot3RemPowerLocalPortNum=lldpXdot3RemPowerLocalPortNum, aclL3Ip4Protocol=aclL3Ip4Protocol, dhcpRelayHopCount=dhcpRelayHopCount, ZeroBasedCounter32=ZeroBasedCounter32, companyIPv6Neighbor=companyIPv6Neighbor, igsVlanMulticastGroupMacAddress=igsVlanMulticastGroupMacAddress, lldpXdot1RemVlanNameEntry=lldpXdot1RemVlanNameEntry, portDescriptionEntry=portDescriptionEntry, rmonHistoryEntry=rmonHistoryEntry, ipv4Address=ipv4Address, aclL3IP4SrcAddr=aclL3IP4SrcAddr, cpuAclL3RuleCount=cpuAclL3RuleCount, qosDiffServType05=qosDiffServType05, eoamInfomationIndex=eoamInfomationIndex, sntpDSTState=sntpDSTState, cpuAclL3RuleEntry=cpuAclL3RuleEntry, lldpStatsRemTablesDrops=lldpStatsRemTablesDrops, sessionLiveTime=sessionLiveTime, bandwidthCtrlTable=bandwidthCtrlTable, lldpXdot1LocPortVlanId=lldpXdot1LocPortVlanId, qosDiffServType45=qosDiffServType45, companyISMVLAN=companyISMVLAN, igsVlanRouterPortPurgeInterval=igsVlanRouterPortPurgeInterval, rmonEventEntry=rmonEventEntry, snmpUserPrivProtocolPassword=snmpUserPrivProtocolPassword, lldpStatsRxPortAgeoutsTotal=lldpStatsRxPortAgeoutsTotal, duldDiscoveryTime=duldDiscoveryTime, sysPingDestIpAddr=sysPingDestIpAddr, syssessionTable=syssessionTable, rmonEventOwner=rmonEventOwner, dhcpRelayState=dhcpRelayState, sntpServerAddrType=sntpServerAddrType, stormCleared=stormCleared, dhcpRetryCount=dhcpRetryCount, sysIGMPMulticastVlanTable=sysIGMPMulticastVlanTable, dhcpRelayServerIP=dhcpRelayServerIP, igsHostTableVlanId=igsHostTableVlanId, statisticsClearEntry=statisticsClearEntry, sysLBDTrap=sysLBDTrap, eoamLoopbackStatus=eoamLoopbackStatus, sysSecurityAAC=sysSecurityAAC, lldpXdot3LocMaxFrameSizePortNum=lldpXdot3LocMaxFrameSizePortNum, rmonHistoryBucketsRequested=rmonHistoryBucketsRequested, sysSafeGuardEnable=sysSafeGuardEnable, cpuAclL3IP4DSCP=cpuAclL3IP4DSCP, igsVlanRouterStaticPortList=igsVlanRouterStaticPortList, statisticsPkts512to1023Octets=statisticsPkts512to1023Octets, syslogMsgTable=syslogMsgTable, eoamLoopbackTestEntry=eoamLoopbackTestEntry, sysWebState=sysWebState, snmpGroupWriteViewName=snmpGroupWriteViewName, lldpLocManAddrEntry=lldpLocManAddrEntry, sysSNMPHost=sysSNMPHost, aacLoginMethod1=aacLoginMethod1, snmpGroupEntry=snmpGroupEntry, arpMacAddress=arpMacAddress, lldpStatsRxPortTLVsUnrecognizedTotal=lldpStatsRxPortTLVsUnrecognizedTotal, cpuAclL3IP4IgmpType=cpuAclL3IP4IgmpType, statisticsEtherJabbers=statisticsEtherJabbers, timeRangeSettingEntry=timeRangeSettingEntry, aclL3TcpFlagACK=aclL3TcpFlagACK, sysLLDPStatistics=sysLLDPStatistics, lldpXdot1LocVlanNamePortNum=lldpXdot1LocVlanNamePortNum, aclL3IP6SrcAddr=aclL3IP6SrcAddr, lldpXdot3RemMaxFrameSize=lldpXdot3RemMaxFrameSize, qosDiffServType53=qosDiffServType53, dhcpRelayTimeThreshold=dhcpRelayTimeThreshold, sysTraceRouteCtlAddressType=sysTraceRouteCtlAddressType, eoamLoopbackStatsMatchCount=eoamLoopbackStatsMatchCount, sysGreenLEDShutoff=sysGreenLEDShutoff, greenLEDShutoffPortList=greenLEDShutoffPortList, aclL2EtherType=aclL2EtherType, qinQVlanTranslationEntry=qinQVlanTranslationEntry, lldpXdot3RemPortAutoNegSupported=lldpXdot3RemPortAutoNegSupported, aclL3IgmpType=aclL3IgmpType, sysRMONAlarm=sysRMONAlarm, statisticsEntry=statisticsEntry, lldpXdot1LocVlanId=lldpXdot1LocVlanId, aclTotalProfile=aclTotalProfile, portErrEntry=portErrEntry, lldpLocPortDesc=lldpLocPortDesc, statisticsPkts256to511Octets=statisticsPkts256to511Octets, companyDDP=companyDDP, eoamEventLogLocation=eoamEventLogLocation, aclL3DstPortMask=aclL3DstPortMask, igsStatus=igsStatus, eoamCriticalLinkEventState=eoamCriticalLinkEventState, errorSymbolThreshold=errorSymbolThreshold, rmonHistoryTable=rmonHistoryTable, cpuAclUsedProfile=cpuAclUsedProfile, cpuAclL3IP4DstAddr=cpuAclL3IP4DstAddr, mirrorEgressPortList=mirrorEgressPortList, tftpFwTargetImageFileName=tftpFwTargetImageFileName, cpuAclL3IP4IcmpType=cpuAclL3IP4IcmpType, aacEnableMethodListTable=aacEnableMethodListTable, bandwidthCtrlEntry=bandwidthCtrlEntry, cpuAclL3IP4Protocol=cpuAclL3IP4Protocol, pnacRadiusServerRetransmit=pnacRadiusServerRetransmit, sntpDSTOffset=sntpDSTOffset, qosDiffServType02=qosDiffServType02, portSecFDBPermVlanID=portSecFDBPermVlanID, Ipv6Address=Ipv6Address, lldpLocManAddr=lldpLocManAddr, eoamLoopbackStatsTable=eoamLoopbackStatsTable, mldsHostTableGroupAddress=mldsHostTableGroupAddress, rmonAlarmTable=rmonAlarmTable, rmonHistoryInterval=rmonHistoryInterval, sysFdbClear=sysFdbClear, igsVlanMulticastGroupEntry=igsVlanMulticastGroupEntry, pnacPortAuthStatus=pnacPortAuthStatus, ipv6NeighborRowStatus=ipv6NeighborRowStatus, cpuAclL3Ip4DscpCheck=cpuAclL3Ip4DscpCheck, arpEntry=arpEntry, userEncryptControl=userEncryptControl, traceRouteHistoryHopIndex=traceRouteHistoryHopIndex, rmonAlarmVariable=rmonAlarmVariable, tftpFwTargetServerIpAddress=tftpFwTargetServerIpAddress, aclL2RuleProfileID=aclL2RuleProfileID, qinQVlanTranslationTable=qinQVlanTranslationTable, portSecurityIndex=portSecurityIndex, qosDiffServType32=qosDiffServType32, dhcpRelayInterface=dhcpRelayInterface, lldpRemUnknownTimeMark=lldpRemUnknownTimeMark, rmonStatsMulticastPkts=rmonStatsMulticastPkts, sysMacAddr=sysMacAddr, sysRAM=sysRAM, limitIPMulticastProfileName=limitIPMulticastProfileName, dhcpv6RelayInterface=dhcpv6RelayInterface, sysStatisticsTable=sysStatisticsTable, igsHostTablePort=igsHostTablePort, aclL2DstMac=aclL2DstMac, pnacStatus=pnacStatus, ipv6AddressIpPrefix=ipv6AddressIpPrefix, lldpConfigManAddrSubtype=lldpConfigManAddrSubtype, timeRangeSaturday=timeRangeSaturday, snmpUserPrivProtocol=snmpUserPrivProtocol, timeRangeEndMonth=timeRangeEndMonth, userAccessRight=userAccessRight, qosDiffServType51=qosDiffServType51, tftpCfgTargetImageFileName=tftpCfgTargetImageFileName, limitIpMulticastRangeIPType=limitIpMulticastRangeIPType, igmpMulticastVlanGroupStatus=igmpMulticastVlanGroupStatus, dhcpOption12HostName=dhcpOption12HostName, multicastFilterPortEntry=multicastFilterPortEntry, dot1qVlanEntry=dot1qVlanEntry, cpuLast5SecUsage=cpuLast5SecUsage, sysPingDestIpType=sysPingDestIpType, portCtrlMediumType=portCtrlMediumType, qosDiffServType63=qosDiffServType63, errorSymbolWindow=errorSymbolWindow, lldpXdot3RemTimeMark=lldpXdot3RemTimeMark, cpuAclL3Ip4DstPortMask=cpuAclL3Ip4DstPortMask, lldpRemUnknownTLVInfo=lldpRemUnknownTLVInfo, lldpRemIndex=lldpRemIndex, cpuAclL2ProfileID=cpuAclL2ProfileID, snmpCommunityTable=snmpCommunityTable, aclL3TcpFlagCheck=aclL3TcpFlagCheck, lldpXdot1ConfigVlanNameTable=lldpXdot1ConfigVlanNameTable, sysCPU=sysCPU, sysSshState=sysSshState, qosTrafficClassPriority=qosTrafficClassPriority, qosDiffServType19=qosDiffServType19, snmpCommunityName=snmpCommunityName, statisticsInMcastPkts=statisticsInMcastPkts, tftpFwTargetTftpOperation=tftpFwTargetTftpOperation, sysFimwarewrongchecksum=sysFimwarewrongchecksum, sysGreenSystemHibernation=sysGreenSystemHibernation, sysStatisticsClearTable=sysStatisticsClearTable, statisticsEtherFragments=statisticsEtherFragments, timeRangeEndDay=timeRangeEndDay, qosDiffServType12=qosDiffServType12, aacServerRetryCount=aacServerRetryCount, igmpMulticastVlanState=igmpMulticastVlanState, aacLoginMethodListRowStatus=aacLoginMethodListRowStatus, aacAPTelnetEnableMethod=aacAPTelnetEnableMethod, snmpViewTreeTable=snmpViewTreeTable, eoamRemoteLoopback=eoamRemoteLoopback, mldsVlanFilterVlanId=mldsVlanFilterVlanId, qosDiffServType54=qosDiffServType54, lldpStatsTxPortFramesTotal=lldpStatsTxPortFramesTotal, sysIpifSupportV4V6Info=sysIpifSupportV4V6Info, sysLBDPortLoopStatus=sysLBDPortLoopStatus, rmonStatsOwner=rmonStatsOwner, qinQIfIndex=qinQIfIndex)
mibBuilder.exportSymbols("DGS-1100-10ME_A1", eoamOperStatus=eoamOperStatus, lldpXdot1ConfigProtocolIndex=lldpXdot1ConfigProtocolIndex, aclL3DstPort=aclL3DstPort, aacEnableMethod2=aacEnableMethod2, sysUserAccount=sysUserAccount, eoamEventLogPort=eoamEventLogPort, lldpRemManLocalPortNum=lldpRemManLocalPortNum, aclL2EtherTypeCheck=aclL2EtherTypeCheck, aclL3IgmpTypeCheck=aclL3IgmpTypeCheck, companyQinQ=companyQinQ, igsVlanSnoopStatus=igsVlanSnoopStatus, rmonHistoryOwner=rmonHistoryOwner, igsVlanMulticastGroupVlanId=igsVlanMulticastGroupVlanId, syslogServSrvStatus=syslogServSrvStatus, aclL3TcpFlagRST=aclL3TcpFlagRST, trustedHostRowStatus=trustedHostRowStatus, eoamInformationRx=eoamInformationRx, lldpRxStatsPortTable=lldpRxStatsPortTable, rmonStatsDataSource=rmonStatsDataSource, timeRangeEndHour=timeRangeEndHour, aacAPTelnetLoginMethod=aacAPTelnetLoginMethod, sysTftpCfgTargetGroup=sysTftpCfgTargetGroup, lldpRemManAddrSubtype=lldpRemManAddrSubtype, trustedHostStatus=trustedHostStatus, eoamLoopbackStatsEntry=eoamLoopbackStatsEntry, limitIPMulticastIPType=limitIPMulticastIPType, aclL2SrcMac=aclL2SrcMac, mldsVlanSnoopStatus=mldsVlanSnoopStatus, sysDot1qVlanTable=sysDot1qVlanTable, lldpLocChassisIdSubtype=lldpLocChassisIdSubtype, companyTraceRoute=companyTraceRoute, cpuAclL2Action=cpuAclL2Action, timeRangeStartMinute=timeRangeStartMinute, sysSNMPGlobalState=sysSNMPGlobalState, snmpTrapColdStart=snmpTrapColdStart, sysPnacRadiusServer=sysPnacRadiusServer, sysDHCPv6RelayControl=sysDHCPv6RelayControl, sysSNMPGroup=sysSNMPGroup, lldpLocManAddrTable=lldpLocManAddrTable, LldpPortList=LldpPortList, eoamLoopbackStatsRxCount=eoamLoopbackStatsRxCount, lldpRemChassisIdSubtype=lldpRemChassisIdSubtype, sysContact=sysContact, qosDiffServType29=qosDiffServType29, greenPortShutoffState=greenPortShutoffState, errorFrameNotifyState=errorFrameNotifyState, snmpGroupReadViewName=snmpGroupReadViewName, aclL2RuleStatus=aclL2RuleStatus, sysRMONGlobalState=sysRMONGlobalState, snmpGroupSecurityLevel=snmpGroupSecurityLevel, companyStaticMac=companyStaticMac, lldpXdot1RemVlanNameTimeMark=lldpXdot1RemVlanNameTimeMark, syslogServSrvRowStatus=syslogServSrvRowStatus, lldpRemManAddrOID=lldpRemManAddrOID, statisticsFCSErrors=statisticsFCSErrors, ddpEntry=ddpEntry, syslogServerGroup=syslogServerGroup, rmonStatsStatus=rmonStatsStatus, eoamPeerVarReq=eoamPeerVarReq, cpuAclL2VlanIdCheck=cpuAclL2VlanIdCheck, cpuAclTotalRule=cpuAclTotalRule, igmpMulticastVlanid=igmpMulticastVlanid, lldpRemTimeMark=lldpRemTimeMark, rmonEventType=rmonEventType, lldpXdot1RemProtoVlanTable=lldpXdot1RemProtoVlanTable, dynamicFdbMacAddr=dynamicFdbMacAddr, companySystem=companySystem, lldpRemTable=lldpRemTable, pnacRadiusServerStatus=pnacRadiusServerStatus, aclL3RuleTable=aclL3RuleTable, dgs_1100_10ME_A1=dgs_1100_10ME_A1, portSecurityMLA=portSecurityMLA, igsVlanRouterDynamicPortList=igsVlanRouterDynamicPortList, aacServerAuthPort=aacServerAuthPort, qosDiffServType47=qosDiffServType47, aclL3TcpFlagSYN=aclL3TcpFlagSYN, pppoePortEntry=pppoePortEntry, sysTraceRouteCtlProbe=sysTraceRouteCtlProbe, cpuAclL3Ip6TrafficClassCheck=cpuAclL3Ip6TrafficClassCheck, sysPnacCtrl=sysPnacCtrl, LldpPowerPortClass=LldpPowerPortClass, lldpXdot3LocMaxFrameSizeEntry=lldpXdot3LocMaxFrameSizeEntry, qosDiffServType52=qosDiffServType52, eeePort=eeePort, aclL3ProfileTable=aclL3ProfileTable, portUtilizEntry=portUtilizEntry, errorFrameThreshold=errorFrameThreshold, cpuAclTotalProfile=cpuAclTotalProfile, eeeTable=eeeTable, lldpXdot1RemProtoVlanEnabled=lldpXdot1RemProtoVlanEnabled, aacServerIndex=aacServerIndex, dhcpLocalRelayState=dhcpLocalRelayState, syslogMsgDescr=syslogMsgDescr, sysARPAgingTime=sysARPAgingTime, igsVlanMulticastGroupTable=igsVlanMulticastGroupTable, lldpXdot1RemVlanId=lldpXdot1RemVlanId, igmpMulticastVlanGroupAddressType=igmpMulticastVlanGroupAddressType, dhcpRelayOption82RemoteID=dhcpRelayOption82RemoteID, lldpPortConfigNotificationEnable=lldpPortConfigNotificationEnable, qosDiffServType59=qosDiffServType59, eoamUnidirection=eoamUnidirection, companyQoSGroup=companyQoSGroup, lldpXdot1RemEntry=lldpXdot1RemEntry, lldpXdot3RemMaxFrameSizeTable=lldpXdot3RemMaxFrameSizeTable, ddpPort=ddpPort, companyCableDiagnostic=companyCableDiagnostic, ipv6NeighborCacheState=ipv6NeighborCacheState, sysCableDiagTriggerIndex=sysCableDiagTriggerIndex, errorSymbolNotifyState=errorSymbolNotifyState, sysPingStatus=sysPingStatus, aacAPAuthMethodGroup=aacAPAuthMethodGroup, cpuAclL3IP4TcpFlagURG=cpuAclL3IP4TcpFlagURG, sysDuld=sysDuld, eoamLoopbackStatsStartTimestamp=eoamLoopbackStatsStartTimestamp, aclL3RuleProfileID=aclL3RuleProfileID, companyTimeRangeMgmt=companyTimeRangeMgmt, ipv6DefaultRouteEntry=ipv6DefaultRouteEntry, aacEnableMethodListEntry=aacEnableMethodListEntry, igsAccessAuthEntry=igsAccessAuthEntry, cpuAclL3ProfileEntry=cpuAclL3ProfileEntry, limitIPMulticastPortID=limitIPMulticastPortID, snmpTrapPortSecViolation=snmpTrapPortSecViolation, sysBandwidthCtrlSettings=sysBandwidthCtrlSettings, qosTrafficClass=qosTrafficClass, portCtrlSpeed=portCtrlSpeed, eoamLoopbackStatsTxCount=eoamLoopbackStatsTxCount, lbdTraps=lbdTraps, qosDiffServType62=qosDiffServType62, sysRMONStatistics=sysRMONStatistics, cpuAclL3RuleTable=cpuAclL3RuleTable, dot1qVlanUntaggedPorts=dot1qVlanUntaggedPorts, dhcpRelayInterfaceSettingsEntry=dhcpRelayInterfaceSettingsEntry, lldpXdot3RemMaxFrameSizeTimeMark=lldpXdot3RemMaxFrameSizeTimeMark, aacLoginMethod3=aacLoginMethod3, qosDiffServType22=qosDiffServType22, companyEee=companyEee, ipv6NSRetransmitTime=ipv6NSRetransmitTime, qosDiffServType14=qosDiffServType14, igmpMulticastVlanReplaceSourceIp=igmpMulticastVlanReplaceSourceIp, lldpXdot1RemProtoVlanId=lldpXdot1RemProtoVlanId, mirrorCtrlRowStatus=mirrorCtrlRowStatus, rmonAlarmFallingThreshold=rmonAlarmFallingThreshold, duldState=duldState, eeestatus=eeestatus, lldpXdot1RemoteData=lldpXdot1RemoteData, sysTraceRouteCtlTimeOut=sysTraceRouteCtlTimeOut, sysCableDiagPair2FaultDistance=sysCableDiagPair2FaultDistance, sysLBDInterval=sysLBDInterval, timeRangeThursday=timeRangeThursday, sysPnacUser=sysPnacUser, lldpLocManAddrIfId=lldpLocManAddrIfId, snmpUserTable=snmpUserTable, rmonEventStatus=rmonEventStatus, mldsVlanMulticastGroupIpAddress=mldsVlanMulticastGroupIpAddress, sysPingTimeout=sysPingTimeout, sysLoginTimeout=sysLoginTimeout, eoamPeerVendorOui=eoamPeerVendorOui, syslogServEntry=syslogServEntry, traceRouteHistoryHAddrType=traceRouteHistoryHAddrType, igsAccessAuthPortIndex=igsAccessAuthPortIndex, portUtilizRX=portUtilizRX, trustedHostTable=trustedHostTable, sysDot1qVlanAsyOnOff=sysDot1qVlanAsyOnOff, sysFdbClearAction=sysFdbClearAction, companyEoam=companyEoam, snmpTrapWarmStart=snmpTrapWarmStart, cpuLast5MinUsage=cpuLast5MinUsage, lldpXdot3LocPortAutoNegAdvertisedCap=lldpXdot3LocPortAutoNegAdvertisedCap, qosDiffServType07=qosDiffServType07, qosDiffServType10=qosDiffServType10, sntpGlobalState=sntpGlobalState, aclL3Ip4DstAddrMask=aclL3Ip4DstAddrMask, companyDHCPLocalRelay=companyDHCPLocalRelay, aclTotalRule=aclTotalRule, lldpStatsRxPortFramesErrors=lldpStatsRxPortFramesErrors, limitIPMulticastPortEntry=limitIPMulticastPortEntry, lldpXdot1ConfigProtocolTxEnable=lldpXdot1ConfigProtocolTxEnable, qosDiffServType21=qosDiffServType21, qosPortBasePriority=qosPortBasePriority, qinQMissDrop=qinQMissDrop, lldpLocPortTable=lldpLocPortTable, sysDot1qPVIDAutoAssign=sysDot1qPVIDAutoAssign, sysPingTimes=sysPingTimes, aacServerGroupName=aacServerGroupName, tftpSyslogTargetTftpTransferPercentage=tftpSyslogTargetTftpTransferPercentage, cpuAclL2ProfileEntry=cpuAclL2ProfileEntry, sysPortSecurity=sysPortSecurity, lldpRemUnknownLocalPortNum=lldpRemUnknownLocalPortNum, qinQVlanTransPriority=qinQVlanTransPriority, sysDevInfo=sysDevInfo, mldsVlanQueryMaxResponseTime=mldsVlanQueryMaxResponseTime, timeRangeName=timeRangeName, lldpXdot3RemMaxFrameSizeLocalPortNum=lldpXdot3RemMaxFrameSizeLocalPortNum, eoamEventLogTimestamp=eoamEventLogTimestamp, sysIGMPMulticastVlanGroupEntry=sysIGMPMulticastVlanGroupEntry, lldpRemPortId=lldpRemPortId, lldpLocPortEntry=lldpLocPortEntry, cpuAclL3Ip6DstAddrMask=cpuAclL3Ip6DstAddrMask, statisticsOutErrors=statisticsOutErrors, sysDhcpAutoConfiguration=sysDhcpAutoConfiguration, cpuAclL3ProfileID=cpuAclL3ProfileID, sysQinQSystem=sysQinQSystem, cpuAclL2VlanId=cpuAclL2VlanId, sysLLDPPortConfigTable=sysLLDPPortConfigTable, sysLBDVlanLoopPorts=sysLBDVlanLoopPorts, sessionUserName=sessionUserName, qosPortBaseTable=qosPortBaseTable, sysCliPromptStr=sysCliPromptStr, cpuAclL3IP4SrcAddr=cpuAclL3IP4SrcAddr, aclL3Ip4DscpCheck=aclL3Ip4DscpCheck, lldpRemManAddrEntry=lldpRemManAddrEntry, sysSshPortNumber=sysSshPortNumber, sysLocationName=sysLocationName, syslimitIPMulticastPortTable=syslimitIPMulticastPortTable, cpuAclL3Ip4IcmpCodeCheck=cpuAclL3Ip4IcmpCodeCheck, eoamDuplicateEventNotificationTx=eoamDuplicateEventNotificationTx, eoamLoopbackTestCommand=eoamLoopbackTestCommand, lldpXdot1RemVlanName=lldpXdot1RemVlanName, mldsVlanQuerierVersion=mldsVlanQuerierVersion, qosDiffServType01=qosDiffServType01, pppoePortState=pppoePortState, pnacMode=pnacMode, cpuAclL3Ip4SrcPortMask=cpuAclL3Ip4SrcPortMask, eoamLinkMonitorEntry=eoamLinkMonitorEntry, rmonEventTable=rmonEventTable, sysFimwareupgradesuccess=sysFimwareupgradesuccess, sysQosDiffServ=sysQosDiffServ, lldpDupSystemName=lldpDupSystemName, statisticsClearIndex=statisticsClearIndex, sysDynamicFdbEntry=sysDynamicFdbEntry, eoamLoopbackTestCount=eoamLoopbackTestCount, dhcpRelayOption82Policy=dhcpRelayOption82Policy, eoamTrap=eoamTrap, mldsVlanMulticastGroupVlanId=mldsVlanMulticastGroupVlanId, rmonEventLastTimeSent=rmonEventLastTimeSent, aclL28021pCheck=aclL28021pCheck, eoamLoopbackTestWaitTime=eoamLoopbackTestWaitTime, aclL3IcmpType=aclL3IcmpType, sysDDPTable=sysDDPTable, aclL2InPortList=aclL2InPortList, trafficSegmentationMemberList=trafficSegmentationMemberList, qosDiffServType37=qosDiffServType37, cpuAclL3IP4TcpFlagRST=cpuAclL3IP4TcpFlagRST, BridgeId=BridgeId, mldsVlanRobustnessValue=mldsVlanRobustnessValue, qosDiffServType08=qosDiffServType08, aacLoginMethodListEntry=aacLoginMethodListEntry, ipv6DefaultRouteProtocol=ipv6DefaultRouteProtocol, sysGreenPortShutoff=sysGreenPortShutoff, portErrPortIndex=portErrPortIndex, PortList=PortList, aclL3IP4ToS=aclL3IP4ToS, sysFirmwareVersion=sysFirmwareVersion, igsVlanRouterVlanId=igsVlanRouterVlanId)
mibBuilder.exportSymbols("DGS-1100-10ME_A1", portDescMediumType=portDescMediumType, lldpXdot1Config=lldpXdot1Config, eoamLoopbackTestTxCount=eoamLoopbackTestTxCount, qosDiffServType46=qosDiffServType46, rmonStatsOctets=rmonStatsOctets, qosDiffServType50=qosDiffServType50, igsVlanFastLeave=igsVlanFastLeave, lldpXdot1RemTable=lldpXdot1RemTable, sysFdbClearId=sysFdbClearId, aacServerInterfaceName=aacServerInterfaceName, snmpUserAuthProtocolPassword=snmpUserAuthProtocolPassword, aclL3IP4DstAddr=aclL3IP4DstAddr, lldpXdot1RemVlanNameTable=lldpXdot1RemVlanNameTable, aacServerIPType=aacServerIPType, dot1qVlanPortEntry=dot1qVlanPortEntry, greenSystemHibernationTimeProfile1=greenSystemHibernationTimeProfile1, dhcpv6RelayHopCount=dhcpv6RelayHopCount, lldpRemUnknownIndex=lldpRemUnknownIndex, sysCableDiagPair3FaultDistance=sysCableDiagPair3FaultDistance, lldpXdot3PortConfigTLVsTxEnable=lldpXdot3PortConfigTLVsTxEnable, snmpTrapFirmwareUpgrade=snmpTrapFirmwareUpgrade, lldpXdot1LocVlanName=lldpXdot1LocVlanName, sysSerialNumber=sysSerialNumber, sntpServerAddr=sntpServerAddr, pnacReAuthPeriod=pnacReAuthPeriod, eoamUnsupportedCodesRx=eoamUnsupportedCodesRx, snmpTrapSNMPAuthentication=snmpTrapSNMPAuthentication, qosDiffServType57=qosDiffServType57, portCtrlDetailMediumType=portCtrlDetailMediumType, igsHostTable=igsHostTable, syslogMsg=syslogMsg, greenCableLenDetectionState=greenCableLenDetectionState, companyPnacGroup=companyPnacGroup, rmonAlarmIndex=rmonAlarmIndex, errorFramePeriodWindow=errorFramePeriodWindow, aclL3IP6DstAddr=aclL3IP6DstAddr, eoamPeerLinkMonitoring=eoamPeerLinkMonitoring, ipv6AddressRowStatus=ipv6AddressRowStatus, dhcpRelayOption82RemoteIDType=dhcpRelayOption82RemoteIDType, timeRangeFriday=timeRangeFriday, igsVlanMulticastGroupPortList=igsVlanMulticastGroupPortList, sntpServerType=sntpServerType, syslogServUDPport=syslogServUDPport, portSecFDBPermEntryState=portSecFDBPermEntryState, multicastFilterPortType=multicastFilterPortType, statisticsEtherOversizePkts=statisticsEtherOversizePkts, arpRowStatus=arpRowStatus, rmonAlarmRisingThreshold=rmonAlarmRisingThreshold, igmpMulticastVlanTagMemberPort=igmpMulticastVlanTagMemberPort, eoamOrgSpecificRx=eoamOrgSpecificRx, duldEntry=duldEntry, mirrorIngressPortList=mirrorIngressPortList, sysCableDiagPair1TestResult=sysCableDiagPair1TestResult, pppoePortIndex=pppoePortIndex, dynamicFdbPort=dynamicFdbPort, sessionID=sessionID, sysHardwareVersion=sysHardwareVersion, limitIpMulticastRangeProfileID=limitIpMulticastRangeProfileID, lldpRemSysCapSupported=lldpRemSysCapSupported, statisticsInUcastPkts=statisticsInUcastPkts, timeRangeStartDay=timeRangeStartDay, duldMode=duldMode, statisticsInNUcastPkts=statisticsInNUcastPkts, staticMacVlanID=staticMacVlanID, lldpRemEntry=lldpRemEntry, lldpXdot1RemProtoVlanSupported=lldpXdot1RemProtoVlanSupported, cpuAclL3IP4IcmpCode=cpuAclL3IP4IcmpCode, tftpCfgTargetTftpOperation=tftpCfgTargetTftpOperation, aclL3Action=aclL3Action, eoamVarReq=eoamVarReq, aclL3ReplaceDSCP=aclL3ReplaceDSCP, aclL2ProfileStatus=aclL2ProfileStatus, lldpXdot3RemPortOperMauType=lldpXdot3RemPortOperMauType, sysSNTPSettingGroup=sysSNTPSettingGroup, staticMcastEntry=staticMcastEntry, trafficSegmentationEntry=trafficSegmentationEntry, companyLLDP=companyLLDP, sysLLDPNotification=sysLLDPNotification, cpuAclL3Ip4TcpFlagCheck=cpuAclL3Ip4TcpFlagCheck, sysTraceRouteCtlTTL=sysTraceRouteCtlTTL, syslogServFacility=syslogServFacility, sysLBDVlanLoopTable=sysLBDVlanLoopTable, traceRouteHistoryEntry=traceRouteHistoryEntry, sysLBDCtrlEntry=sysLBDCtrlEntry, tftpSyslogTargetServerIpType=tftpSyslogTargetServerIpType, sysCpuAclProfile=sysCpuAclProfile, errorFrameSecondsThreshold=errorFrameSecondsThreshold, sysLLDPLocalSystemData=sysLLDPLocalSystemData, sysMldsVlan=sysMldsVlan, igsVlanMulticastGroupIpAddress=igsVlanMulticastGroupIpAddress, eoamOrgSpecificTx=eoamOrgSpecificTx, mldsVlanRouterPortPurgeInterval=mldsVlanRouterPortPurgeInterval, snmpGroupName=snmpGroupName, eoamLoopbackTestStatus=eoamLoopbackTestStatus, lldpRemSysDesc=lldpRemSysDesc, aacLoginMethod4=aacLoginMethod4, portSecFDBPermanentEntry=portSecFDBPermanentEntry, eoamDuplicateEventNotificationRx=eoamDuplicateEventNotificationRx, sysAutoRefreshConfiguration=sysAutoRefreshConfiguration, ipv6NeighborIndex=ipv6NeighborIndex, pnacProtocol=pnacProtocol, aacServerIPAddr=aacServerIPAddr, mldsVlanRouterEntry=mldsVlanRouterEntry, dhcpRelayOption82CheckState=dhcpRelayOption82CheckState, sysRMONEvent=sysRMONEvent, mldsVlanMulticastGroupEntry=mldsVlanMulticastGroupEntry, cpuAclL2EtherType=cpuAclL2EtherType, aclL2DstMacMask=aclL2DstMacMask, rmonAlarmEntry=rmonAlarmEntry, ipv6DefaultRouteIfIndex=ipv6DefaultRouteIfIndex, sessionIP=sessionIP, bandwidthCtrlTxThreshold=bandwidthCtrlTxThreshold, sysSwitchTime=sysSwitchTime, sysLBDVlanLoopIndex=sysLBDVlanLoopIndex, aclL3Ip6DstAddrMask=aclL3Ip6DstAddrMask, sessionUserPrivilege=sessionUserPrivilege, eoamPeerMacAddress=eoamPeerMacAddress, trafficCtrlTrap=trafficCtrlTrap, cpuAclUsedRule=cpuAclUsedRule, lldpXdot3RemLinkAggIndex=lldpXdot3RemLinkAggIndex, lldpXdot3RemLinkAggStatus=lldpXdot3RemLinkAggStatus, aclL3IP4Protocol=aclL3IP4Protocol, limitIPMulticastProfileID=limitIPMulticastProfileID, eoamRemoteLoopbackSupport=eoamRemoteLoopbackSupport, lldpXdot1RemProtoVlanEntry=lldpXdot1RemProtoVlanEntry, rmonStatsTable=rmonStatsTable, lldpXdot3RemPowerClass=lldpXdot3RemPowerClass, sysCableDiagPair4TestResult=sysCableDiagPair4TestResult, companyACL=companyACL, sysMldsSystem=sysMldsSystem, lldpXdot3RemMaxFrameSizeIndex=lldpXdot3RemMaxFrameSizeIndex, duldLinkStatus=duldLinkStatus, ipv6NeighborAddr=ipv6NeighborAddr, sysDot1qVlanPortTable=sysDot1qVlanPortTable, sysLBDRecoverTime=sysLBDRecoverTime, portCtrlFlowControlOper=portCtrlFlowControlOper, qinQVlanTransSVID=qinQVlanTransSVID, limitIpMulticastRangeStartIpAddr=limitIpMulticastRangeStartIpAddr, eoamMode=eoamMode, igmpMulticastVlanAddressType=igmpMulticastVlanAddressType, aacServerGroupEntry=aacServerGroupEntry, sysCableDiagPair2TestResult=sysCableDiagPair2TestResult, duldIfIndex=duldIfIndex, aclL2Action=aclL2Action, ipv6AddressIpAddr=ipv6AddressIpAddr, qosDiffServType55=qosDiffServType55, eoamFramesLostDueToOam=eoamFramesLostDueToOam, lldpXdot1LocProtocolPortNum=lldpXdot1LocProtocolPortNum, sysIgsHost=sysIgsHost, limitIPMulticastProfileStatus=limitIPMulticastProfileStatus, lldpDupChasisId=lldpDupChasisId, snmpCommunityStatus=snmpCommunityStatus, sysTftpTrapGroup=sysTftpTrapGroup, igsVlanRobustnessValue=igsVlanRobustnessValue, sysLBDCtrlIndex=sysLBDCtrlIndex, aclL2SrcMacMask=aclL2SrcMacMask, syslimitIPMulticastProfileTable=syslimitIPMulticastProfileTable, sysFimwareTraps=sysFimwareTraps, ipv6DHCPStatus=ipv6DHCPStatus, qosDiffServType34=qosDiffServType34, cpuAclL2RuleEntry=cpuAclL2RuleEntry, dot1qVlanEgressPorts=dot1qVlanEgressPorts, dhcpLocalRelayEntry=dhcpLocalRelayEntry, sysAclRule=sysAclRule, aacLocalEnablePassword=aacLocalEnablePassword, sysCpuAclStatistic=sysCpuAclStatistic, companyTftpGroup=companyTftpGroup, lldpStatsRxPortFramesDiscardedTotal=lldpStatsRxPortFramesDiscardedTotal, lldpRemPortDesc=lldpRemPortDesc, statisticsOutNUcastPkts=statisticsOutNUcastPkts, sysLLDPXdot1Objects=sysLLDPXdot1Objects, igsVlanFilterEntry=igsVlanFilterEntry, eoamIfIndex=eoamIfIndex, sysStaticMacTable=sysStaticMacTable, sysTrafficCtrlSettings=sysTrafficCtrlSettings, aacEnableMethod4=aacEnableMethod4, lldpXdot3Config=lldpXdot3Config, ipv6AddressMainIndex=ipv6AddressMainIndex, cpuAclL28021pCheck=cpuAclL28021pCheck, statisticsPkts1024to1518Octets=statisticsPkts1024to1518Octets, timeRangeStartMonth=timeRangeStartMonth, snmpUserVersion=snmpUserVersion, mirrorTargetIfIndex=mirrorTargetIfIndex, portCtrlTable=portCtrlTable, statisticsIndex=statisticsIndex, lldpTraps=lldpTraps, bandwidthCtrlEffectiveRxThreshold=bandwidthCtrlEffectiveRxThreshold, eoamEventLogValue=eoamEventLogValue, lldpRemChassisId=lldpRemChassisId, LldpPortIdSubtype=LldpPortIdSubtype, statisticsEtherUndersizePkts=statisticsEtherUndersizePkts, lldpXdot3RemLinkAggPortId=lldpXdot3RemLinkAggPortId, traceRouteHistoryIndex=traceRouteHistoryIndex, igmpMulticastVlanGroupVid=igmpMulticastVlanGroupVid, bandwidthCtrlIndex=bandwidthCtrlIndex, lldpXdot3PortConfigPortNum=lldpXdot3PortConfigPortNum, eoamLinkMonitorTable=eoamLinkMonitorTable, macNotifyCtrlEntry=macNotifyCtrlEntry, eoamStatsEntry=eoamStatsEntry, sysSave=sysSave, companySession=companySession, timeRangeStartHour=timeRangeStartHour, lldpLocManAddrSubtype=lldpLocManAddrSubtype, snmpViewTreeMask=snmpViewTreeMask, mldsVlanQuerier=mldsVlanQuerier, snmpTrapTwistLinkUpDown=snmpTrapTwistLinkUpDown, sysTelnetsettingManagementOnOff=sysTelnetsettingManagementOnOff, lldpStatsTxPortEntry=lldpStatsTxPortEntry, qosDiffServType04=qosDiffServType04, arpTable=arpTable, eoamUniqueEventNotificationTx=eoamUniqueEventNotificationTx, sysSNTPServerGroup=sysSNTPServerGroup, dot1qVlanPortIndex=dot1qVlanPortIndex, aacAuthParamAttempt=aacAuthParamAttempt, lldpPortConfigTLVsTxEnable=lldpPortConfigTLVsTxEnable, lldpXdot1RemProtocolIndex=lldpXdot1RemProtocolIndex, pnacCapability=pnacCapability, rmonStatsBroadcastPkts=rmonStatsBroadcastPkts, eoamLoopbackTestPktSize=eoamLoopbackTestPktSize, syslogServSeverity=syslogServSeverity, sysOamEventLogTable=sysOamEventLogTable, mldsVlanMulticastGroupTable=mldsVlanMulticastGroupTable, companyUserAccount=companyUserAccount, qinQConfigTable=qinQConfigTable, qosDiffServType35=qosDiffServType35, sysEoamStatsClearPortlist=sysEoamStatsClearPortlist, dlink_products=dlink_products, errorFramePeriodThreshold=errorFramePeriodThreshold, qosPortBaseEntry=qosPortBaseEntry, cpuAclL2RuleAccessID=cpuAclL2RuleAccessID, lldpXdot1RemProtocolEntry=lldpXdot1RemProtocolEntry, d_link=d_link, qinQRoleState=qinQRoleState, qosDiffServType61=qosDiffServType61, aclL2ReplaceDSCP=aclL2ReplaceDSCP, qosDiffServType25=qosDiffServType25, pnacQuietPeriod=pnacQuietPeriod, cpuAclL3Ip4Protocol=cpuAclL3Ip4Protocol, qosDiffServType13=qosDiffServType13, pnacConfigPortControl=pnacConfigPortControl, lldpMisConfigPortVlanID=lldpMisConfigPortVlanID, lldpXdot3PortConfigEntry=lldpXdot3PortConfigEntry, rmonAlarmOwner=rmonAlarmOwner, sysRMONHistory=sysRMONHistory, greenLEDShutoffTimeProfile2=greenLEDShutoffTimeProfile2, statisticsDeferredTransmissions=statisticsDeferredTransmissions, ipv6DefaultRouteNextHop=ipv6DefaultRouteNextHop, qosDiffServType42=qosDiffServType42, rmonStatsPkts=rmonStatsPkts, sysEoamStatsTable=sysEoamStatsTable, sysLLDPReinitDelay=sysLLDPReinitDelay, sysSNMPUser=sysSNMPUser, lldpXdot3RemLinkAggTimeMark=lldpXdot3RemLinkAggTimeMark, lldpLocManAddrLen=lldpLocManAddrLen)
mibBuilder.exportSymbols("DGS-1100-10ME_A1", mldsVlanMulticastGroupPortList=mldsVlanMulticastGroupPortList, portCtrlIndex=portCtrlIndex, lldpRemPortIdSubtype=lldpRemPortIdSubtype, portCtrlFlowControl=portCtrlFlowControl, sysGuestVlanName=sysGuestVlanName, sysGuestVlanDelState=sysGuestVlanDelState, sysDHCPLocalRelayTable=sysDHCPLocalRelayTable, lldpXdot1LocProtocolId=lldpXdot1LocProtocolId, qosDiffServType38=qosDiffServType38, lldpXdot1RemIndex=lldpXdot1RemIndex, pnacRadiusAccountingState=pnacRadiusAccountingState, sysSNMPEngineID=sysSNMPEngineID, eoamUnsupportedCodesTx=eoamUnsupportedCodesTx, sysIgsVlan=sysIgsVlan, dhcpOption12Status=dhcpOption12Status, qosDiffServType27=qosDiffServType27, aclL2VlanIdCheck=aclL2VlanIdCheck, cmArpClear=cmArpClear, sysTraceRouteCtlAdminStatus=sysTraceRouteCtlAdminStatus, qosDiffServType33=qosDiffServType33, portCtrlEntry=portCtrlEntry, pnacUserTable=pnacUserTable, qinQVlanTransPortNum=qinQVlanTransPortNum, qosSchedulingClassEntry=qosSchedulingClassEntry, syslogSettingGroup=syslogSettingGroup, lldpXdot1LocProtocolTable=lldpXdot1LocProtocolTable, aclL3TcpFlagPSH=aclL3TcpFlagPSH, lldpXdot1LocVlanNameEntry=lldpXdot1LocVlanNameEntry, qosDiffServType15=qosDiffServType15, sntpTimeSeconds=sntpTimeSeconds, pnacUserEntry=pnacUserEntry, sntpDSTStartTime=sntpDSTStartTime, aclL3ProfileEntry=aclL3ProfileEntry, lldpXdot1RemPortVlanId=lldpXdot1RemPortVlanId, RmonStatus=RmonStatus, eoamNotifyNonThresholdEvent=eoamNotifyNonThresholdEvent, Timeout=Timeout, traceRouteHistoryResponse=traceRouteHistoryResponse, cpuAclL3Ip6SrcAddrMask=cpuAclL3Ip6SrcAddrMask, eoamLoopbackTestMatchCount=eoamLoopbackTestMatchCount, staticMacEntry=staticMacEntry, sysMldsHost=sysMldsHost, statisticsExcessiveCollisions=statisticsExcessiveCollisions, igsVlanGrpQueryInterval=igsVlanGrpQueryInterval, trafficCtrlTimeInterval=trafficCtrlTimeInterval, eoamEventLogEntry=eoamEventLogEntry, lldpXdot3RemPowerMDISupported=lldpXdot3RemPowerMDISupported, pnacOperControlledDirections=pnacOperControlledDirections, aacAuthenAdminState=aacAuthenAdminState, sysJumboFrameEnable=sysJumboFrameEnable, sysDhcpTimeout=sysDhcpTimeout, qosSchedulingWeight=qosSchedulingWeight, limitIPMulticastPortIPType=limitIPMulticastPortIPType, cpuAclL3Ip4IgmpTypeCheck=cpuAclL3Ip4IgmpTypeCheck, portDescIndex=portDescIndex, sysSwitchName=sysSwitchName, dhcpRelayInterfaceSettingsRowStatus=dhcpRelayInterfaceSettingsRowStatus, qosDiffServType20=qosDiffServType20, syslogEnable=syslogEnable, tftpCfgTargetServerIpType=tftpCfgTargetServerIpType, aclL2ProfileID=aclL2ProfileID, lldpMisConfigOperMauType=lldpMisConfigOperMauType, lldpXdot1RemTimeMark=lldpXdot1RemTimeMark, greenLEDShutoffState=greenLEDShutoffState, lldpLocChassisId=lldpLocChassisId, mirrorPortEntry=mirrorPortEntry, lldpXdot3LocPortOperMauType=lldpXdot3LocPortOperMauType, sysLLDPXdot3Objects=sysLLDPXdot3Objects, dgs_1100_10ME=dgs_1100_10ME, dhcpv6RelayOption37RemoteID=dhcpv6RelayOption37RemoteID, cpuAclL3IP4TcpFlagACK=cpuAclL3IP4TcpFlagACK, sntpServerRowStatus=sntpServerRowStatus, lldpXdot3RemLocalPortNum=lldpXdot3RemLocalPortNum, sysAclProfile=sysAclProfile, sysLBDVlanLoopEntry=sysLBDVlanLoopEntry, eoamReceivedRemoteLoopback=eoamReceivedRemoteLoopback, ipv6AddressIpType=ipv6AddressIpType, companyIpifGroup=companyIpifGroup, syslogMsgTime=syslogMsgTime, cpuAclL3Ip4DstAddrMask=cpuAclL3Ip4DstAddrMask, sysTrafficSegmentation=sysTrafficSegmentation, stormCtrlTrap=stormCtrlTrap, lldpXdot1RemProtoVlanIndex=lldpXdot1RemProtoVlanIndex, pnacTxPeriod=pnacTxPeriod, lldpStatsTxPortTable=lldpStatsTxPortTable, sysDHCPv6RelayOption37=sysDHCPv6RelayOption37, lldpXdot3LocMaxFrameSize=lldpXdot3LocMaxFrameSize, syslogMsgIndex=syslogMsgIndex, aclL3RuleCount=aclL3RuleCount, eoamPeerUnidirection=eoamPeerUnidirection, lldpStatsRxPortTLVsDiscardedTotal=lldpStatsRxPortTLVsDiscardedTotal, qosDiffServType00=qosDiffServType00, cpuAclL3ProfileTable=cpuAclL3ProfileTable, qosDiffServType43=qosDiffServType43, aacAuthParamResponseTimeout=aacAuthParamResponseTimeout, timeRangeSunday=timeRangeSunday, cpuAclL2InPortList=cpuAclL2InPortList, mldsVlanRouterDynamicPortList=mldsVlanRouterDynamicPortList, cpuAclL3RuleProfileID=cpuAclL3RuleProfileID, mldsHostTableHostIPAddress=mldsHostTableHostIPAddress, aacServerGroupTable=aacServerGroupTable, rmonHistoryDataSource=rmonHistoryDataSource, portCtrlMDI=portCtrlMDI, sysPingSuccesses=sysPingSuccesses, qosDiffServType17=qosDiffServType17, aacAPHttpEnableMethod=aacAPHttpEnableMethod, sntpDSTEndTime=sntpDSTEndTime, sysEoamEventLog=sysEoamEventLog, aclL3Ip6SrcAddrMask=aclL3Ip6SrcAddrMask, eoamLoopbackTestPattern=eoamLoopbackTestPattern, errorFrameSecondsNotifyState=errorFrameSecondsNotifyState, snmpViewTreeName=snmpViewTreeName, sysIgsSystem=sysIgsSystem, trafficCtrlType=trafficCtrlType, qosDiffServType60=qosDiffServType60, snmpUserGroupName=snmpUserGroupName, sysCableDiagPair3TestResult=sysCableDiagPair3TestResult, dynamicFdbId=dynamicFdbId, cpuAclL2ProfileStatus=cpuAclL2ProfileStatus, LldpManAddrIfSubtype=LldpManAddrIfSubtype, pnacMaxReq=pnacMaxReq, tftpCfgTargetInterfaceName=tftpCfgTargetInterfaceName, igmpMulticastVlanGroupToIp=igmpMulticastVlanGroupToIp, limitIPMulticastPortState=limitIPMulticastPortState, lldpXdot1ConfigProtocolPortNum=lldpXdot1ConfigProtocolPortNum, lldpStatsRxPortNum=lldpStatsRxPortNum, sysIGMPMulticastVlanStatus=sysIGMPMulticastVlanStatus, ipv4AddrCfgMode=ipv4AddrCfgMode, aclL3ProfileType=aclL3ProfileType, statisticsPkts128to255Octets=statisticsPkts128to255Octets, lldpXdot1RemProtocolTable=lldpXdot1RemProtocolTable, aacServerGroupRowStatus=aacServerGroupRowStatus, aclL2RuleAccessID=aclL2RuleAccessID, mldsHostTable=mldsHostTable, lldpXdot3LocPortEntry=lldpXdot3LocPortEntry, lldpXdot1LocalData=lldpXdot1LocalData, sysIgsAccessAuth=sysIgsAccessAuth, sysSNMPTrap=sysSNMPTrap, greenSystemHibernationState=greenSystemHibernationState, sysEoamTrap=sysEoamTrap, companyDHCPRelay=companyDHCPRelay, syslogServIndex=syslogServIndex, sysEoamSystem=sysEoamSystem, syslogServTable=syslogServTable, companySyslog=companySyslog, fdbTableChanged=fdbTableChanged, ipv6DefaultRouteAdminStatus=ipv6DefaultRouteAdminStatus, ipv6NeighborEntry=ipv6NeighborEntry, companyLimitIP=companyLimitIP, sysDot1qVlanManagementOnOff=sysDot1qVlanManagementOnOff, lldpRemSysCapEnabled=lldpRemSysCapEnabled, cpuAclL3ProfileType=cpuAclL3ProfileType, statisticsPkts65to127Octets=statisticsPkts65to127Octets, companyTrafficMgmt=companyTrafficMgmt, sysFimwarefiletransferfailed=sysFimwarefiletransferfailed, staticMcastVlanID=staticMcastVlanID, cpuAclL2DstMac=cpuAclL2DstMac, staticMacAddr=staticMacAddr, aclL3ProfileID=aclL3ProfileID, portCtrlLinkStatus=portCtrlLinkStatus, sysMacNotifyState=sysMacNotifyState, sysCableDiagLengthinRange=sysCableDiagLengthinRange, cpuAclL2SrcMac=cpuAclL2SrcMac, sysIGMPMulticastVlanEntry=sysIGMPMulticastVlanEntry, dhcpv6RelayRowStatus=dhcpv6RelayRowStatus, eoamEntry=eoamEntry)

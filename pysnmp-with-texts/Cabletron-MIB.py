#
# PySNMP MIB module Cabletron-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Cabletron-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:34:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, NotificationType, ObjectIdentity, TimeTicks, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, Gauge32, Bits, iso, MibIdentifier, IpAddress, Unsigned32, enterprises, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "ObjectIdentity", "TimeTicks", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "Gauge32", "Bits", "iso", "MibIdentifier", "IpAddress", "Unsigned32", "enterprises", "Counter64")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
cabletron = MibIdentifier((1, 3, 6, 1, 4, 1, 52))
commsDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1))
layerMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2))
common = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1))
repeater = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2))
bridge = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3))
router = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 4))
product = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 5))
subsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6))
commonRev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 1))
sysOIDs = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2))
repeaterRev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1))
repeaterRev2 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2))
deviceType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceType.setStatus('mandatory')
if mibBuilder.loadTexts: deviceType.setDescription('This object defines the board type for the Management board in the device. (eg. IRBM, IRM). See appendix A for value.')
deviceName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceName.setStatus('mandatory')
if mibBuilder.loadTexts: deviceName.setDescription('An ASCII name of the device that this agent manages.')
deviceIPAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: deviceIPAddress.setDescription('The Internet address of this device.')
currentTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: currentTime.setStatus('mandatory')
if mibBuilder.loadTexts: currentTime.setDescription('The current time of day as measured by the device')
currentDate = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: currentDate.setStatus('mandatory')
if mibBuilder.loadTexts: currentDate.setDescription('Character representation of the current date')
mACAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mACAddress.setDescription('The MAC (Ethernet) address of the MMAC. This can also be obtained from address translation MIB. The Instance Identifier for the MAC address is interface number. For the IRBM, their are 2.')
sysOtherType = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 1))
sysIRMType = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 2))
sysRepType = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 3))
sysBDGType = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 4))
soidIRMSNMP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 2, 1))
soidIRBM = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 2, 2))
soidIRM2 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 2, 3))
soidMINIMMAC = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 3, 1))
soidMRXI = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 1, 2, 3, 2))
device = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1))
board = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 2))
port = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 3))
sourceAddr = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 7))
redundancy = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8))
alarm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9))
deviceMMACType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("mMAC8", 0), ("mMAC3", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceMMACType.setStatus('mandatory')
if mibBuilder.loadTexts: deviceMMACType.setDescription('Indicates the type of MMAC.')
deviceSlots = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 3))).clone(namedValues=NamedValues(("mMAC8", 8), ("mMAC3", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceSlots.setStatus('mandatory')
if mibBuilder.loadTexts: deviceSlots.setDescription('Number of available device slots in this device, including the IRM slot.')
deviceOccupiedSlots = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceOccupiedSlots.setStatus('mandatory')
if mibBuilder.loadTexts: deviceOccupiedSlots.setDescription('The slots that contain MIM boards. This field is bit encoded (eg. If a bit is set then that board is present. For example, a value of 3 indicates that there are boards in the IRM slot and the first MIM slot.')
devicePortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devicePortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: devicePortsOn.setDescription('The number of operating ports on the device.')
deviceTotalPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTotalPorts.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTotalPorts.setDescription('The total number of repeater ports on the MMAC.')
deviceTotalPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTotalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTotalPkts.setDescription('The number of packets detected on all ports of this device.')
deviceTotalErrors = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTotalErrors.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTotalErrors.setDescription('The sum of all of the errors listed including alignment,CRC, runts, giants, and Out of window collisions.')
deviceTransmitColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTransmitColl.setStatus('optional')
if mibBuilder.loadTexts: deviceTransmitColl.setDescription('The number of transmit collisions detected by this MMAC.')
deviceRecColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRecColls.setStatus('optional')
if mibBuilder.loadTexts: deviceRecColls.setDescription('The number of receive collsions detected by this MMAC.')
deviceAlign = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceAlign.setStatus('optional')
if mibBuilder.loadTexts: deviceAlign.setDescription('The number of packets with alignement errors detected. ')
deviceCRC = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceCRC.setStatus('optional')
if mibBuilder.loadTexts: deviceCRC.setDescription('The number of packets with bad CRC detected. ')
deviceRunt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRunt.setStatus('optional')
if mibBuilder.loadTexts: deviceRunt.setDescription('The number of runt frames detected by this device.')
deviceOOWColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceOOWColl.setStatus('optional')
if mibBuilder.loadTexts: deviceOOWColl.setDescription('The number of out-of-window collisions detected by this')
deviceNoResources = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceNoResources.setStatus('mandatory')
if mibBuilder.loadTexts: deviceNoResources.setDescription('The number of No resource condtions detected.')
deviceRecBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRecBytes.setStatus('optional')
if mibBuilder.loadTexts: deviceRecBytes.setDescription('The number of bytes detected on the network.')
deviceGiantFrames = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceGiantFrames.setStatus('mandatory')
if mibBuilder.loadTexts: deviceGiantFrames.setDescription('The number of longer than 1518 bytes.')
deviceRestart = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 18), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceRestart.setStatus('mandatory')
if mibBuilder.loadTexts: deviceRestart.setDescription('If this object is set to 0 the device is restarted.')
deviceResetCounter = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 19), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceResetCounter.setStatus('mandatory')
if mibBuilder.loadTexts: deviceResetCounter.setDescription('If this object is set to 0, all of the devices Counters are reset to 0.')
deviceRedundantCts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceRedundantCts.setStatus('mandatory')
if mibBuilder.loadTexts: deviceRedundantCts.setDescription('The number of redundant circuits available for use.')
deviceTimeBase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceTimeBase.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTimeBase.setDescription('The number of seconds used as the interval for performing all of the rate alarm checks. The minimum is 10 secs.')
deviceResetRedundancy = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceResetRedundancy.setStatus('mandatory')
if mibBuilder.loadTexts: deviceResetRedundancy.setDescription('Setting this object to a 1 will reset redundancy for the entire box.')
deviceSrcAddrAgingTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceSrcAddrAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: deviceSrcAddrAgingTime.setDescription('The number of minutes that a source address is not detected before it is removed from the source address table.')
deviceSrcAddrTraps = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("trapsoff", 1), ("trapson", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceSrcAddrTraps.setStatus('mandatory')
if mibBuilder.loadTexts: deviceSrcAddrTraps.setDescription('Controls sending of source address related traps.')
deviceSrcAddrLocked = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("lockoff", 1), ("lockon", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: deviceSrcAddrLocked.setStatus('mandatory')
if mibBuilder.loadTexts: deviceSrcAddrLocked.setDescription('If this is set to 2, any source addresses that are detected on station ports that are not in the table will cause the port to be turned off.')
deviceEnetBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceEnetBoardMap.setStatus('mandatory')
if mibBuilder.loadTexts: deviceEnetBoardMap.setDescription('The slots that contain Ethernet MIM boards.')
deviceTokenRingBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTokenRingBoardMap.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTokenRingBoardMap.setDescription('The slots that contain Token Ring MIM boards.')
deviceFDDIBoardMap = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceFDDIBoardMap.setStatus('mandatory')
if mibBuilder.loadTexts: deviceFDDIBoardMap.setDescription('The slots that contain FDDI MIM boards.')
sourceAddrBoard = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceAddrBoard.setStatus('mandatory')
if mibBuilder.loadTexts: sourceAddrBoard.setDescription('The board number of the port that the supplied source address has been found on.')
sourceAddrPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sourceAddrPort.setStatus('mandatory')
if mibBuilder.loadTexts: sourceAddrPort.setDescription('The port number of the port that the supplied source address has been found on.')
redundancyPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyPollInterval.setDescription('The number of seconds between polls for redundancy.')
redundancyTestTod = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyTestTod.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyTestTod.setDescription('The time of day at which the redundant circuits should be tested.')
redundancyPerformTest = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("performTest", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyPerformTest.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyPerformTest.setDescription('Test the redundant circuit.')
redundancyCircuitName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitName.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitName.setDescription('The name of the indicated circuit.')
redundancyRetryCount = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyRetryCount.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyRetryCount.setDescription('The number of unanswered polls allowed for the indicated circuit before the current connection is declared bad.')
redundancyNumBPs = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyNumBPs.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyNumBPs.setDescription('The number of board/port combinations associated with the indicated circuit.')
redundancyCircuitBoards = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitBoards.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitBoards.setDescription('The boards associated with the indicated circuit, accessed by index.')
redundancyCircuitPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitPort.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitPort.setDescription('The ports associated with the indicated circuit, accessed by index.')
redundancyCircuitTypes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitTypes.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitTypes.setDescription('The type of each port associated with the indicated circuit, accessed by index.')
redundancyCircuitNumAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitNumAddr.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitNumAddr.setDescription('The number of addresses associated with the indicated circuit.')
redundancyCircuitMACAddrAdd = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 11), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitMACAddrAdd.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitMACAddrAdd.setDescription('Adds the ethernet address to the polling list for the indicated circuit.')
redundancyCircuitMACAddrDel = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 12), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitMACAddrDel.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitMACAddrDel.setDescription('Removes the ethernet address from the polling list for the indicated circuit.')
redundancyCircuitMACAddrDisp = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: redundancyCircuitMACAddrDisp.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitMACAddrDisp.setDescription('The ethernet addresses associated with the indicated circuit, accessed by index.')
redundancyCircuitEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitEnable.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitEnable.setDescription('Enables and disables the indicated circuit.')
redundancyCircuitReset = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 8, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: redundancyCircuitReset.setStatus('mandatory')
if mibBuilder.loadTexts: redundancyCircuitReset.setDescription('Reset the indicated circuit. Return all of the associated board and ports to NOT-USED, remove associated addresses from the polling list, reset the circuit name and retry count to default values .')
devAlrm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1))
bdAlrm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2))
portAlrm = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3))
devTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 1))
devColls = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 2))
devError = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3))
devTrafficEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devTrafficEnable.setStatus('mandatory')
if mibBuilder.loadTexts: devTrafficEnable.setDescription('Enable the sending of device level traffic traps.')
devTrafficThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 1, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devTrafficThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: devTrafficThreshold.setDescription('The threshold of packets within the devicetimebase that will cause a traffic alarm.')
devCollsEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devCollsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: devCollsEnable.setDescription('Enable the sending of device level collsion alarms.')
devCollsThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devCollsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: devCollsThreshold.setDescription('This object represents the number of collisions per good packet measured by the device that will generate an alarm. valid values are 1 to 15')
devErrorEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devErrorEnable.setStatus('mandatory')
if mibBuilder.loadTexts: devErrorEnable.setDescription('Enable the sending of device level error alarms.')
devErrorThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: devErrorThreshold.setDescription('This object represents the percentage of errors per good packet that will generate an alarm.')
devErrorSource = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 1, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: devErrorSource.setStatus('mandatory')
if mibBuilder.loadTexts: devErrorSource.setDescription('The type of error used for the error alarm.')
bdTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 1))
bdColls = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 2))
bdError = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3))
bdTrafficEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdTrafficEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bdTrafficEnable.setDescription('Enable the sending of board level traffic traps for this board.')
bdTrafficThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 1, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdTrafficThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bdTrafficThreshold.setDescription('The threshold of packets within the Devicetimebase that will cause a traffic alarm.')
bdCollsEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdCollsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bdCollsEnable.setDescription('Enable the sending of board level collsion alarms.')
bdCollsThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdCollsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bdCollsThreshold.setDescription('This object represents the number of collisions per good packet measured by the board that will generate an alarm. valid values are 1 to 15')
bdErrorEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdErrorEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bdErrorEnable.setDescription('Enable the sending of board level error alarms.')
bdErrorThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: bdErrorThreshold.setDescription('This object represents the percentage of errors per good packet that will generate an alarm.')
bdErrorSource = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 2, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdErrorSource.setStatus('mandatory')
if mibBuilder.loadTexts: bdErrorSource.setDescription('The type of error used for the error alarm.')
portTraffic = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 1))
portColls = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 2))
portError = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3))
portTrafficEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrafficEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portTrafficEnable.setDescription('Enable the sending of port level traffic traps for this port.')
portTrafficThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 1, 2), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portTrafficThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: portTrafficThreshold.setDescription('The threshold of packets within the Devicetimebase that will cause a traffic alarm.')
portCollsEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCollsEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portCollsEnable.setDescription('Enable the sending of port level collsion alarms.')
portCollsThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portCollsThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: portCollsThreshold.setDescription('This object represents the number of collisions per good packet measured by the port that will generate an alarm.')
portErrorEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrorEnable.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorEnable.setDescription('Enable the sending of port level error alarms.')
portErrorThreshold = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrorThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorThreshold.setDescription('This object represents the percentage of errors per good packet that will generate an alarm.')
portErrorSource = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 1, 9, 3, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portErrorSource.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorSource.setDescription('The type of error used for the error alarm.')
rr2device = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1))
network = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 2))
rr2board = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3))
rr2port = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4))
repeaterTables = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 5))
commonD = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 1))
ethernetD = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 2))
tokenRingD = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3))
deviceTRTokenRingPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTokenRingPortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTRTokenRingPortsOn.setDescription('The number of Token Ring Ports (i.e. station, Ring In and Ring Out ports) enabled on this device.')
deviceTRTotalTokenRingPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingPorts.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTRTotalTokenRingPorts.setDescription('The total number of Token Ring Ports (i.e. station, Ring In and Ring Out ports) on this device.')
deviceTRTotalTokenRingRingPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPortsOn.setDescription('The total number of Ring In and Ring Out ports (active) enabled on this device.')
deviceTRTotalTokenRingRingPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPorts.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTRTotalTokenRingRingPorts.setDescription('The total number of Ring In and Ring Out ports on this device.')
deviceTRTotalTokenRingRings = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: deviceTRTotalTokenRingRings.setStatus('mandatory')
if mibBuilder.loadTexts: deviceTRTotalTokenRingRings.setDescription('The total number of (Token Ring) rings formed on this device.')
commonB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1))
ethernetB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2))
tokenRingB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3))
fddiB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 4))
boardIndex = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: boardIndex.setDescription('The slot number of this board.')
boardName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardName.setStatus('mandatory')
if mibBuilder.loadTexts: boardName.setDescription('The name of the board. This field will only contain printable ASCII characters.')
boardType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardType.setStatus('mandatory')
if mibBuilder.loadTexts: boardType.setDescription('The type of the MIM. (eg. FOT, TPT, etc). See appendix A for encoding.')
boardTotalPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalPorts.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalPorts.setDescription('Total number of ports supported on this board.')
boardSTATUS = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardSTATUS.setStatus('optional')
if mibBuilder.loadTexts: boardSTATUS.setDescription('The administrative status of this MIM.')
boardPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardPortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: boardPortsOn.setDescription('The number of operating ports on the board.')
boardTotalPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalPkts.setDescription('The total number of packets this board has seen since the last reset.')
boardErrorPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardErrorPkts.setStatus('mandatory')
if mibBuilder.loadTexts: boardErrorPkts.setDescription('The number of packets that have experienced an error. VAlid only on the IRBM, IRM2, and MiniMMAC.')
boardTransColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTransColl.setStatus('optional')
if mibBuilder.loadTexts: boardTransColl.setDescription('The number of transmit collisions this board has detected.')
boardRecColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRecColl.setStatus('optional')
if mibBuilder.loadTexts: boardRecColl.setDescription('The number of Receive mode collisions this board has detected.')
boardAlign = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardAlign.setStatus('optional')
if mibBuilder.loadTexts: boardAlign.setDescription('The number of mis-aligned frames this board has detected. Only valid for the IRBM, IRM2, and MiniMMAC.')
boardCRC = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardCRC.setStatus('optional')
if mibBuilder.loadTexts: boardCRC.setDescription('The number of packets with bad CRC detected. Only valid on IRBM, IRM2, and MiniMMAC.')
boardRunt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRunt.setStatus('optional')
if mibBuilder.loadTexts: boardRunt.setDescription('The number of runt frames detected by this board. Valid fr the IRBM, IRM2, and MiniMMAC only.')
boardOOWColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardOOWColl.setStatus('optional')
if mibBuilder.loadTexts: boardOOWColl.setDescription('The number of out-of-window collisions detected by this board. Only valid on the IRBM, IRM2, and MiniMMAC.')
boardNoResources = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardNoResources.setStatus('optional')
if mibBuilder.loadTexts: boardNoResources.setDescription('The number of times The no resources condition was detected for this board.')
boardRecBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRecBytes.setStatus('optional')
if mibBuilder.loadTexts: boardRecBytes.setDescription('The number of bytes detected on the network. Valid only on the IRBM, IRM2, and MiniMMAC.')
boardGiants = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardGiants.setStatus('mandatory')
if mibBuilder.loadTexts: boardGiants.setDescription('The number of packets longer than 1518 bytes detected on this board.')
boardTotalRingPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalRingPorts.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalRingPorts.setDescription('The total number of ring ports on this board. Currently, zero or two.')
boardTotalStationPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalStationPorts.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalStationPorts.setDescription('The total number of station ports on this board.')
boardModeStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardModeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: boardModeStatus.setDescription('The board is configured for 2 == Auto Mode or 1 == Management Mode')
boardTotalRingPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalRingPortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalRingPortsOn.setDescription('The number of enabled ring ports on this board.')
boardTotalStationPortsOn = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardTotalStationPortsOn.setStatus('mandatory')
if mibBuilder.loadTexts: boardTotalStationPortsOn.setDescription('The number of enabled station ports on this board.')
boardSpeed = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: boardSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: boardSpeed.setDescription(' Speed 4 == 4 Mhz Speed 16 == 16 Mhz')
boardRingSpeedFault = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 3, 3, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noFaultDetected", 1), ("faultDetected", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: boardRingSpeedFault.setStatus('mandatory')
if mibBuilder.loadTexts: boardRingSpeedFault.setDescription('Data speed of station mismatches configuration speed of board. board is automatically bypassed.')
commonP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1))
ethernetP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2))
tokenRingP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3))
fddiP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 4))
portIndex = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portIndex.setStatus('mandatory')
if mibBuilder.loadTexts: portIndex.setDescription('The slot number of this port.')
portMediaType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: portMediaType.setDescription('The type of the port. (eg. FOT, TPT, etc). See appendix A for values.')
portAdminState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: portAdminState.setDescription('The administrative status of this port.')
portSourceAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSourceAddr.setStatus('mandatory')
if mibBuilder.loadTexts: portSourceAddr.setDescription('A source address that has been seen on this port.')
portTopologyType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTopologyType.setStatus('mandatory')
if mibBuilder.loadTexts: portTopologyType.setDescription('The topological type of the port. { Station(1) Link(2) }')
portLinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("linkSignalInactive", 1), ("linkSignalActive", 2), ("linkSignalNotSupported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portLinkStatus.setDescription('The state of the link signal for this port')
portStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("segmented", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portStatus.setStatus('mandatory')
portTotalPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portTotalPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portTotalPkts.setDescription('The total number of packets this port has seen since the last reset.')
portErrorPkts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portErrorPkts.setStatus('mandatory')
if mibBuilder.loadTexts: portErrorPkts.setDescription('The number of packets that have experienced an error. Valid only on the IRBM, IRM2, and MiniMMAC')
portXmitColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portXmitColls.setStatus('optional')
if mibBuilder.loadTexts: portXmitColls.setDescription('The number of Transmit mode collisions this port has detected. Only valid on IRBM, IRM2, and MiniMMAC.')
portRecColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRecColls.setStatus('optional')
if mibBuilder.loadTexts: portRecColls.setDescription('The number of Receive mode collisions this port has detected. Only valid on IRBM, IRM2, and MiniMMAC.')
portAlign = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAlign.setStatus('optional')
if mibBuilder.loadTexts: portAlign.setDescription('The number of mis-aligned frames this port has detected. Only valid for the IRBM, IRM2, and MiniMMAC.')
portCRC = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portCRC.setStatus('optional')
if mibBuilder.loadTexts: portCRC.setDescription('The number of packets with bad CRC detected. Only valid on IRBM, IRM2, and MiniMMAC.')
portRunt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRunt.setStatus('optional')
if mibBuilder.loadTexts: portRunt.setDescription('The number of runt frames detected by this port. Valid for the IRBM, IRM2, and MiniMMAC only.')
portOOWColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOOWColl.setStatus('optional')
if mibBuilder.loadTexts: portOOWColl.setDescription('The number of out-of-window collisions detected by this port. Only valid on the IRBM, IRM2, and MiniMMAC.')
portNoResorces = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portNoResorces.setStatus('optional')
if mibBuilder.loadTexts: portNoResorces.setDescription('The number of times the no resource condition is detected on this port.')
portRecBytes = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portRecBytes.setStatus('optional')
if mibBuilder.loadTexts: portRecBytes.setDescription('The number of bytes detected on the network. Valid only on the IRBM, IRM2, and MiniMMAC.')
portGiants = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portGiants.setStatus('optional')
if mibBuilder.loadTexts: portGiants.setDescription('The number of frames longer than 1518 bytes detected on this port.')
portRedundCrt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRedundCrt.setStatus('mandatory')
if mibBuilder.loadTexts: portRedundCrt.setDescription('The redundant circuit with which this port is associated.')
portRedundType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("notUsed", 1), ("primary", 3), ("backup", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRedundType.setStatus('mandatory')
if mibBuilder.loadTexts: portRedundType.setDescription('The type of port this port is in the redundant circuit.')
portRedundStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notUsed", 1), ("active", 2), ("inactive", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portRedundStatus.setStatus('mandatory')
if mibBuilder.loadTexts: portRedundStatus.setDescription('The current state of this port is in the redundant circuit.')
portForceLinkType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notForced", 1), ("forced", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: portForceLinkType.setStatus('mandatory')
if mibBuilder.loadTexts: portForceLinkType.setDescription('This variable forces a port to be a link port.')
stationP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 1))
ringP = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 2))
stationPortLinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linkSignalInactive", 1), ("linkSignalActive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: stationPortLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: stationPortLinkStatus.setDescription('When station is supplying phantom current the Link Signal is active. When there is no phantom current the Link Signal is inactive.')
stationPortLinkStateTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: stationPortLinkStateTime.setStatus('mandatory')
if mibBuilder.loadTexts: stationPortLinkStateTime.setDescription('The amount of time (in seconds) elapsed since the station port last changed state.')
ringPortLinkStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ringPortLinkStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ringPortLinkStatus.setDescription('Off (wrapped). On (active).')
ringPortLinkStateTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 2, 2, 4, 3, 2, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ringPortLinkStateTime.setStatus('mandatory')
if mibBuilder.loadTexts: ringPortLinkStateTime.setDescription('The amount of time (in seconds) elapsed since ring port last changed state.')
productRev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 5, 1))
iRBM = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 5, 1, 1))
iRBMRevision = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("rev0", 0), ("rev1", 1), ("rev2", 2), ("rev3", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iRBMRevision.setStatus('mandatory')
if mibBuilder.loadTexts: iRBMRevision.setDescription('The revision of the IRBM board')
iRBMPortAssociation = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 5, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: iRBMPortAssociation.setStatus('mandatory')
if mibBuilder.loadTexts: iRBMPortAssociation.setDescription('Controls how front panel ports are associated with the bridge or the repeater. The valid values are: Value AUI Port Fiber Port 0 Bridge Redundant 1 Redundant Bridge 2 Bridge Repeater 3 Repeater Bridge 4 Redundant Repeater 5 Repeater Redundant Note: only values 0 and 1 are valid for rev 2 boards and before.')
mMAC = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1))
fnb = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1))
fnbConnectedLeft = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbConnectedLeft.setStatus('mandatory')
if mibBuilder.loadTexts: fnbConnectedLeft.setDescription('The Connected Left board (board n + 1) has the following states: Detached == 1 (Management (only management) detached, read/write). Attached == 2 (Management/AutoMode attached, read/write). Faulted == 3 (Management/AutoMode tried to attach but failed read ONLY).')
fnbConnectedRight = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbConnectedRight.setStatus('mandatory')
if mibBuilder.loadTexts: fnbConnectedRight.setDescription('The Connected Right board (board n - 1) has the following states: Detached == 1 (Management (only management) detached, read/write). Attached == 2 (Management/AutoMode attached, read/write ). Faulted == 3 (Management/AutoMode tried to attach but failed read ONLY).')
fnbBoardBypassState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 6, 1, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fnbBoardBypassState.setStatus('mandatory')
if mibBuilder.loadTexts: fnbBoardBypassState.setDescription('Off == 1 (NOT bypassed). On == 2 (bypassed).')
bridgeRev1 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1))
bdgdevice = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1))
bdgPort = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2))
filterDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3))
trapTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 4))
bdgTables = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 5))
acqDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1))
permDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2))
specialDB = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3))
acqStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1))
acqOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2))
permStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1))
permOptions = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2))
specStats = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1))
specFilters = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2))
bdgdeviceDisableBdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableBridge", 0), ("enableBridge", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceDisableBdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceDisableBdg.setDescription('Indicates if the bridge will be disabled.')
bdgdeviceRestoreSettings = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("restoreSettings", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceRestoreSettings.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRestoreSettings.setDescription('Restore the following settings to their default values: Bridge Name to ETHERNET_BRIDGE, Location to LOCAL, Port 1 Name to PORT_1, Port 2 Name to PORT_2, Port 1 Network Name to LAN_1, Port 2 Network Name to LAN_2, Ageing Time for Acquired Database to 300 seconds, Erase the acquired database, Erase the permanent database, Place sixteen default multicast addresses into the permanent and acquired databases, Type of Spanning Tree to 802.1, Type of Filtering to IEEE 802.1, Bridge Max Age to 20 seconds, Bridge Forward Delay to 15 seconds, Bridge Hello Time to 2 seconds, Bridge Priority to 8000, Port 1 Priority to 80, Port 2 Priority to 80, Port 1 Path Cost to 100, Port 2 Path Cost to 100, Restart the bridge.')
bdgdeviceBdgName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgName.setDescription('The user-defined name (up to 32 characters long) of the bridge. The default bridge name is ETHERNET_BRIDGE.')
bdgdeviceNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceNumPorts.setDescription('The number of ports present on the bridge.')
bdgdeviceType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceType.setDescription('The type of bridge, NB25E, IRBM, or NB20E.')
bdgdeviceVersion = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceVersion.setDescription('The release version of the firmware installed in the bridge.')
bdgdeviceLocation = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 8), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceLocation.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceLocation.setDescription('The user-defined name to indicate the location of the bridge on the network. The default location name is LOCAL.')
bdgdeviceStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceStatus.setDescription('The status of the bridge, ON-LINE, STAND BY or DISABLED.')
bdgdeviceRestartBdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("restartBridge", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceRestartBdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRestartBdg.setDescription('Force the bridge to undergo a software reset.')
bdgdeviceFrFwd = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrFwd.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrFwd.setDescription('The number of frames forwarded by the bridge.')
bdgdeviceFrRx = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrRx.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrRx.setDescription('The number of frames received by the bridge.')
bdgdeviceFrFlt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFrFlt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFrFlt.setDescription('The number of frames filtered by the bridge.')
bdgdeviceErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceErr.setDescription('The total number of network errors that have occurred.')
bdgdeviceSwitchSetting = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 15), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceSwitchSetting.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceSwitchSetting.setDescription('Indicates the current switch settings read from the bridge hardware.')
bdgdeviceNumRestarts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceNumRestarts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceNumRestarts.setDescription('The number of times the bridge has been powered up or restarted.')
bdgdeviceTypeFiltering = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ieee8021", 0), ("specialDB", 1), ("both", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceTypeFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTypeFiltering.setDescription('The type of filtering to be performed by the bridge. The default is IEEE 802.1.')
bdgdeviceSTAProtocol = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ieee8021", 0), ("dec", 1), ("none", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceSTAProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceSTAProtocol.setDescription('The spanning tree algorithm under which the bridge is operating. The selections are as follows: - IEEE 802.1 compliant spanning tree algorithm environment (802.1) - DEC LAN Bridge 100 environment (DEC) - Without the spanning tree algorithm enabled (NONE) The default is 802.1.')
bdgdeviceBridgeID = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 19), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceBridgeID.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBridgeID.setDescription('The unique identifier of the bridge. The first two bytes of the identifier are the bridge priority and the last six bytes are the Ethernet address.')
bdgdeviceTopChgCnt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTopChgCnt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTopChgCnt.setDescription("The number of times the bridge's Topology Change Flag has been changed since the bridge was powered up or initialized.")
bdgdeviceRootCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRootCost.setDescription('The cost of the path to the root from this bridge.')
bdgdeviceRootPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceRootPort.setDescription('The port identifier for the port which offers the lowest cost path to the root, i.e. that port for which the sum of the values of the designated cost and path cost parameters held for the port is lowest.')
bdgdeviceHelloTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceHelloTime.setDescription("The time interval between the transmission of Configuration BPDU's by a bridge which is attempting to become the root or is the root.")
bdgdeviceBdgMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 24), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgMaxAge.setDescription('The value of the Max Age parameter when the bridge is the root or is attempting to become the root. A time of 6 to 40 seconds is allowed. The default is 20 seconds.')
bdgdeviceBdgFwdDly = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgFwdDly.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgFwdDly.setDescription('The value of the forward delay parameter when the bridge is the root or is attempting to become the root. A time of 4 to 30 seconds is allowed.')
bdgdeviceTimeTopChg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTimeTopChg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTimeTopChg.setDescription("The time in seconds that has elapsed since the bridge's Topology Change Flag last recorded the value of a topology change.")
bdgdeviceTopChg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noTopologyChangeInProgress", 0), ("topologyChangeInProgress", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTopChg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTopChg.setDescription('Indicates if a bridge topology change is in progress.')
bdgdeviceDesigRoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 28), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceDesigRoot.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceDesigRoot.setDescription('The unique identifier of the bridge recorded as the root.')
bdgdeviceMaxAge = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceMaxAge.setDescription('The maximum age of received protocol information before it is discarded.')
bdgdeviceHoldTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceHoldTime.setDescription("The minimum time period elapsing between the transmission of configuration BPDU's through a given bridge port.")
bdgdeviceFwdDly = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceFwdDly.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceFwdDly.setDescription('The time spent in the listening state while moving from the blocking state to the learning state, or the time spent in the learning state while moving from the listening state to the forwarding state.')
bdgdeviceBdgHello = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgHello.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgHello.setDescription('The value of the Hello Time parameter when the bridge is the root or is attempting to become the root. A time of 1 to 10 seconds is allowed. The default is 2 seconds.')
bdgdeviceBdgPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceBdgPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceBdgPriority.setDescription('The part of the bridge address that contains the identifier used in the spanning tree for priority comparisons. Allowed range is 0 through FFFF. The default is 8000.')
bdgdeviceResetCounts = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("resetCounts", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgdeviceResetCounts.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceResetCounts.setDescription('Reset all counters to zero.')
bdgdeviceUptime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceUptime.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceUptime.setDescription('The time, in seconds, that has elapsed since the bridge was last reset or initialized.')
bdgdeviceTrapType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 1, 36), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgdeviceTrapType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgdeviceTrapType.setDescription('Contains the object identifier of the first VarBinding in the last trap generated by the bridge.')
bdgPortAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortAddress.setDescription('The Ethernet address of the port.')
bdgPortName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 2), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortName.setDescription('The user-defined name assigned to the port. The default port 1 name is PORT_1 and the default Port 2 name is PORT_2.')
bdgPortType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortType.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortType.setDescription('The IEEE specification the port meets, e.g. 802.3.')
bdgPortStatus = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortStatus.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortStatus.setDescription('The status in which the port is operating. The status messages for Ports 1 and 2 are: OFF - The port is off, due to a failed network interface chip associated with that port. OK/SQE ON - The port is communicating with the network and the transceiver making the connection to the network has SQE enabled. OK/SQE OFF - The port is communicating with the network and the transceiver making the connection to the network has SQE disabled. CARRIER LOST - Communication with the network has not been established or has been lost.')
bdgPortNetName = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortNetName.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortNetName.setDescription('The user-defined name assigned to a network segment connected to the port. The default network name for Port 1 is LAN_1 and the default network name for Port 2 is LAN_2.')
bdgPortFrRx = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrRx.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrRx.setDescription('The number of frames received at the specified port.')
bdgPortDisInb = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisInb.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisInb.setDescription('The total number of valid frames that were received at the port but then discarded by the bridge in the forwarding process.')
bdgPortFwdOutb = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFwdOutb.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFwdOutb.setDescription('The number of frames forwarded successfully to the appropriate port.')
bdgPortDisLOB = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisLOB.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisLOB.setDescription('The number of packets that were discarded by the bridge because of a lack of buffer space to maintain the data.')
bdgPortDisTDE = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisTDE.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisTDE.setDescription('The number of frames that were intended for forwarding but were discarded when the maximum time period set for transmission was exceeded before forwarding was possible.')
bdgPortDisErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDisErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDisErr.setDescription('The number of frames that could not be transmitted because the frame was too large for the attached network (1526 bytes, including preamble, for 802.3 networks).')
bdgPortColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortColl.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortColl.setDescription('The number of collisions that have occurred on the network at the specified port.')
bdgPortTxAbrt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortTxAbrt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortTxAbrt.setDescription('The number of transmissions that have been aborted due to excessive collisions (over 16 attempts to transmit the same packet).')
bdgPortOowColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortOowColl.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortOowColl.setDescription('The number of collisions out of the standard collision window (51.2 uS). This indicates a network problem.')
bdgPortCRCErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortCRCErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortCRCErr.setDescription('The number of packets detected with Cyclical Redundancy Check failures.')
bdgPortFrAlErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrAlErr.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrAlErr.setDescription('The number of errors due to misaligned packets.')
bdgPortPriority = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 17), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortPriority.setDescription('The part of the port identifier which is used with the spanning tree algorithm when determining which port in a LAN segment has priority. The default is 80.')
bdgPortState = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 18), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortState.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortState.setDescription('The current state of the port, DISABLED, LISTENING, LEARNING, FORWARDING or BLOCKING.')
bdgPortPathCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bdgPortPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortPathCost.setDescription('The contributory cost of the applicable port to the overall cost of the path when the specified port is the root port. Allowable range is 1 to 65535. The default is 100.')
bdgPortDesigCost = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigCost.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigCost.setDescription('The cost of the path of this port to the root bridge on the network.')
bdgPortDesigBrdg = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 21), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigBrdg.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigBrdg.setDescription('The network address of the bridge that is assumed to be the root bridge on the network.')
bdgPortDesigPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigPort.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigPort.setDescription('The port identifier of the bridge port believed to be the designated port for the LAN associated with the port.')
bdgPortTopChgAck = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("noTopologyChangeIsOccurring", 0), ("topologyChangeIsOccurring", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortTopChgAck.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortTopChgAck.setDescription('The value of the topology change acknowledgement flag in the next configuration BPDU to be transmitted on the associated port.')
bdgPortDesigRoot = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortDesigRoot.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortDesigRoot.setDescription('The unique bridge identifier of the bridge that is assumed to be the root bridge on the network.')
bdgPortRuntPackets = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortRuntPackets.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortRuntPackets.setDescription('The number of packets received at the indicated bdgPort that were less than the IEEE 802.3 minimum Ethernet frame size of 64 bytes.')
bdgPortOversizePackets = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortOversizePackets.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortOversizePackets.setDescription('The number of packets received at the indicated port that were greater than the IEEE 802.3 maximum Ethernet frame size of 1518 bytes.')
bdgPortFrFilt = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 2, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bdgPortFrFilt.setStatus('mandatory')
if mibBuilder.loadTexts: bdgPortFrFilt.setDescription('The number of frames received at the indicated port that were filtered by the bridge.')
acqTotalEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqTotalEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqTotalEntries.setDescription('The total number of entries in the acquired database.')
acqMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqMaxEntries.setDescription('The maximum number of entries allowed in the acquired database.')
acqStaticEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqStaticEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqStaticEntries.setDescription('The number of addresses added to the Acquired database by the user or network manager.')
acqStaticAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqStaticAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: acqStaticAgeTime.setDescription('The length of time allowed for a static entry in the Acquired database to be inactive before it is dropped from the database. This time is fixed at zero.')
acqDynEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDynEntries.setStatus('mandatory')
if mibBuilder.loadTexts: acqDynEntries.setDescription("The number of entries that have been accumulated in the Acquired database through the bridge's learning process.")
acqDynAgeTime = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqDynAgeTime.setStatus('mandatory')
if mibBuilder.loadTexts: acqDynAgeTime.setDescription('The length of time allowed for a dynamic entry in the acquired database to be inactive before it is dropped from the database. A time from 10 - 1,000,000 seconds is allowed. The default is 300 seconds.')
acqEraseDatabase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("eraseAcquiredDatabase", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqEraseDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: acqEraseDatabase.setDescription('Set to zero to erase all entries in the acquired database.')
acqCreate00 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryFilterPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate00.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate00.setDescription('Add an entry to the acquired database to filter packets entering ports 1 and 2 if those packets are destined for the specified address.')
acqCreate20 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryForwardPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate20.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate20.setDescription('Add an entry to the acquired database to forward packets entering port1 to port2 and filter packets entering port2 if those packets are destined for the specified address.')
acqCreate01 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryFilterPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate01.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate01.setDescription('Add an entry to the acquired database to filter packets entering port 1 and forward packets entering port 2 to port 1 if those packets are destined for the specified address.')
acqCreate21 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createAcquiredEntryForwardPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqCreate21.setStatus('mandatory')
if mibBuilder.loadTexts: acqCreate21.setDescription('Add an entry to the acquired database to forward packets entering port 1 to port 2 and to forward packets entering port 2 to port 1 if those packets are destined for the specified address.')
acqDelete = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deleteAcquiredEntry", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acqDelete.setStatus('mandatory')
if mibBuilder.loadTexts: acqDelete.setDescription('Delete an entry from the acquired database.')
acqDispType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispType.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispType.setDescription('Display the entry type, STATIC or DYNAMIC.')
acqDispOutp1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispOutp1.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispOutp1.setDescription('The outbound port for packets entering port 1.')
acqDispOutp2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqDispOutp2.setStatus('mandatory')
if mibBuilder.loadTexts: acqDispOutp2.setDescription('The outbound port for packets entering port 2.')
acqSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 1, 2, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acqSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: acqSrcAddress.setDescription('The source address of this acquired database entry, i.e. the instance.')
permMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: permMaxEntries.setDescription('The maximum number of entries allowed in the permanent database.')
permCurrEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permCurrEntries.setStatus('mandatory')
if mibBuilder.loadTexts: permCurrEntries.setDescription("The number of entries currently recorded in the bridge's permanent database.")
permEraseDatabase = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("erasePermanentDatabase", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permEraseDatabase.setStatus('mandatory')
if mibBuilder.loadTexts: permEraseDatabase.setDescription('Erase all entries in the permanent database.')
permCreate00 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryFilterPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate00.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate00.setDescription('Add an entry to the permanent database to filter packets entering ports 1 and 2 if those packets are destined for the specified address.')
permCreate20 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryForwardPort1FilterPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate20.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate20.setDescription('Add an entry to the permanent database to forward packets entering port 1 and filter packets entering port 2 if those packets are destined for the specified address.')
permCreate01 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryFilterPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate01.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate01.setDescription('Add an entry to the permanent database to filter packets entering port 1 and forward packets entering port 2 if those packets are destined for the specified address.')
permCreate21 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("createPermanentEntryForwardPort1ForwardPort2", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permCreate21.setStatus('mandatory')
if mibBuilder.loadTexts: permCreate21.setDescription('Add an entry to the permanent database to forward packets entering ports 1 and 2 if those packets are destined for the specified address.')
permDelete = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deletePermanentEntry", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: permDelete.setStatus('mandatory')
if mibBuilder.loadTexts: permDelete.setDescription('Delete an entry from the permanent database.')
permDispType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispType.setStatus('mandatory')
if mibBuilder.loadTexts: permDispType.setDescription('Display the entry type, STATIC or DYNAMIC.')
permDispOutp1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispOutp1.setStatus('mandatory')
if mibBuilder.loadTexts: permDispOutp1.setDescription('The outbound port for packets entering port 1.')
permDispOutp2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: permDispOutp2.setStatus('mandatory')
if mibBuilder.loadTexts: permDispOutp2.setDescription('The outbound port for packets entering port 2.')
permSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 2, 2, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: permSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: permSrcAddress.setDescription('The source address in this permanent database entry, i.e. the instance.')
specNumEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: specNumEntries.setDescription('The number of filters in the special database.')
specMaxEntries = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: specMaxEntries.setDescription('The maximum number of filters the special database can contain.')
specNextFilterNum = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: specNextFilterNum.setStatus('mandatory')
if mibBuilder.loadTexts: specNextFilterNum.setDescription('The number of the next available filter that can be added to the special database.')
specEnable = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disableFilter", 0), ("enableFilter", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specEnable.setStatus('mandatory')
if mibBuilder.loadTexts: specEnable.setDescription('Enable or disable the filter.')
specPort1 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2))).clone(namedValues=NamedValues(("filter", 0), ("relay", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specPort1.setStatus('mandatory')
if mibBuilder.loadTexts: specPort1.setDescription('Set port 1 to filter or forward packets.')
specPort2 = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("filter", 0), ("relay", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specPort2.setStatus('mandatory')
if mibBuilder.loadTexts: specPort2.setDescription('Set port 2 to filter or forward packets.')
specDestAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDestAddress.setStatus('mandatory')
if mibBuilder.loadTexts: specDestAddress.setDescription('Set the special database to filter packets with a specific destination address.')
specSrcAddress = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specSrcAddress.setStatus('mandatory')
if mibBuilder.loadTexts: specSrcAddress.setDescription('Set the special database to filter packets with a specific source address.')
specType = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specType.setStatus('mandatory')
if mibBuilder.loadTexts: specType.setDescription('Set the special database to filter packets with a specific type field.')
specDataField = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 7), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDataField.setStatus('mandatory')
if mibBuilder.loadTexts: specDataField.setDescription('Set the special database to filter packets based on the first sixteen bytes of data in the packet.')
specDeleteFilter = MibScalar((1, 3, 6, 1, 4, 1, 52, 1, 3, 1, 3, 3, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("deleteFilter", 0)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: specDeleteFilter.setStatus('mandatory')
if mibBuilder.loadTexts: specDeleteFilter.setDescription('Delete a filter from the special database.')
lmcommon = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 1))
mAC = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2))
ieee8023 = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1))
pcIF = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1))
pcIfRev = MibIdentifier((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1))
pcDeviceName = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDeviceName.setStatus('mandatory')
if mibBuilder.loadTexts: pcDeviceName.setDescription('Name of the PC device')
pcBoardType = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBoardType.setStatus('mandatory')
if mibBuilder.loadTexts: pcBoardType.setDescription('An object Identifier that indicates the type of the PC board. This will include MAC type and Media type.')
pcOwnerName = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcOwnerName.setStatus('mandatory')
if mibBuilder.loadTexts: pcOwnerName.setDescription('The owner of this PC.')
pcLocation = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLocation.setStatus('mandatory')
if mibBuilder.loadTexts: pcLocation.setDescription('A text description of the location of this PC.')
pcMMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACAddr.setDescription('The MAC address of the MMAC that this PC is connected to.')
pcMMACBoard = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACBoard.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACBoard.setDescription('The slot number of the board in the MMAC that this PC is connected to.')
pcMMACPort = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMMACPort.setStatus('mandatory')
if mibBuilder.loadTexts: pcMMACPort.setDescription('The number of the port on the board of the MMAC that this PC is connected to.')
pcApplication = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcApplication.setStatus('mandatory')
if mibBuilder.loadTexts: pcApplication.setDescription('A text description of the network application running on this PC.')
pcDriverRev = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDriverRev.setStatus('mandatory')
if mibBuilder.loadTexts: pcDriverRev.setDescription('The revision of the LAN card driver.')
pcOnboardMemory = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcOnboardMemory.setStatus('mandatory')
if mibBuilder.loadTexts: pcOnboardMemory.setDescription('The number of Kilobytes of memory (eg. a 16K board would reply 16)')
pcComment = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcComment.setStatus('mandatory')
if mibBuilder.loadTexts: pcComment.setDescription('A user-defined character string.')
pcMACAddr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMACAddr.setStatus('mandatory')
if mibBuilder.loadTexts: pcMACAddr.setDescription('The MAC address of the PC card.')
pcFramesXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcFramesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcFramesXmit.setDescription('The number of MAC frames transmitted by this PC card.')
pcBytesXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBytesXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcBytesXmit.setDescription('The number bytes transmitted by this PC card.')
pcMcastXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMcastXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcMcastXmit.setDescription('The number of multicasted frames sent by this PC card.')
pcBcastXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBcastXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcBcastXmit.setDescription('The number of broadcast frames from this PC card.')
pcDeferXmit = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcDeferXmit.setStatus('mandatory')
if mibBuilder.loadTexts: pcDeferXmit.setDescription('The number of transmit packets that were deferred due to busy media.')
pcSglColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcSglColl.setStatus('mandatory')
if mibBuilder.loadTexts: pcSglColl.setDescription('The number of transmit packet experiencing a single collision.')
pcMultiColl = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMultiColl.setStatus('mandatory')
if mibBuilder.loadTexts: pcMultiColl.setDescription('The number of transmit packets that have experienced multiple collisions.')
pcTotXmitErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTotXmitErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcTotXmitErrs.setDescription('The total number of transmit errors.')
pcLateColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLateColls.setStatus('mandatory')
if mibBuilder.loadTexts: pcLateColls.setDescription('The number of transmit packets that experienced late collisions.')
pcXcessColls = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcXcessColls.setStatus('mandatory')
if mibBuilder.loadTexts: pcXcessColls.setDescription('The number of transmit packets aborted due to excess collisions.')
pcCarrErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcCarrErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcCarrErr.setDescription('The number of transmit packets that experience carrier sense errors (ie. lose carrier during transmission).')
pcFramesRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcFramesRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcFramesRec.setDescription('The number of frames received.')
pcBytesRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBytesRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcBytesRec.setDescription('The number of bytes received by this station.')
pcMcastRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcMcastRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcMcastRec.setDescription('The number of multicasted frames received.')
pcBcastRec = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcBcastRec.setStatus('mandatory')
if mibBuilder.loadTexts: pcBcastRec.setDescription('The number of broadcast packets received.')
pcTotRecErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTotRecErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcTotRecErrs.setDescription('The total number of receive errors.')
pcTooLong = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTooLong.setStatus('mandatory')
if mibBuilder.loadTexts: pcTooLong.setDescription('The number of packets received that are too long (over 1518 bytes).')
pcTooShort = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcTooShort.setStatus('mandatory')
if mibBuilder.loadTexts: pcTooShort.setDescription('The number of packets that are too short. (under 64 bytes long).')
pcAlignErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcAlignErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcAlignErrs.setDescription('The number of alignment errors in receive packets.')
pcCRCErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcCRCErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcCRCErrs.setDescription('The number of receive packets with CRC errors.')
pcLenErrs = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcLenErrs.setStatus('mandatory')
if mibBuilder.loadTexts: pcLenErrs.setDescription('The number of packets whose length is not equal to the number of bytes received.')
pcIntRecErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcIntRecErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcIntRecErr.setDescription('The number of receive packets that experienced internal errors (eg. no receive buffers).')
pcSqeErr = MibScalar((1, 3, 6, 1, 4, 1, 52, 2, 2, 1, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pcSqeErr.setStatus('mandatory')
if mibBuilder.loadTexts: pcSqeErr.setDescription('The number of SQE errors.')
mibBuilder.exportSymbols("Cabletron-MIB", pcBcastXmit=pcBcastXmit, devicePortsOn=devicePortsOn, bdgdeviceTrapType=bdgdeviceTrapType, bridgeRev1=bridgeRev1, layerMgmt=layerMgmt, bdColls=bdColls, portRecColls=portRecColls, boardTotalRingPortsOn=boardTotalRingPortsOn, permMaxEntries=permMaxEntries, permCreate01=permCreate01, fnbConnectedLeft=fnbConnectedLeft, portError=portError, fnbBoardBypassState=fnbBoardBypassState, bdgPortDisLOB=bdgPortDisLOB, ethernetD=ethernetD, deviceRestart=deviceRestart, pcMACAddr=pcMACAddr, bdgdeviceBdgHello=bdgdeviceBdgHello, permCurrEntries=permCurrEntries, acqCreate21=acqCreate21, acqMaxEntries=acqMaxEntries, acqStats=acqStats, devColls=devColls, devError=devError, boardTotalPkts=boardTotalPkts, bdgPortType=bdgPortType, permDB=permDB, specFilters=specFilters, permCreate00=permCreate00, portTrafficThreshold=portTrafficThreshold, deviceTRTotalTokenRingPorts=deviceTRTotalTokenRingPorts, portErrorThreshold=portErrorThreshold, ethernetB=ethernetB, devTrafficEnable=devTrafficEnable, deviceTRTotalTokenRingRings=deviceTRTotalTokenRingRings, bdgdeviceRestoreSettings=bdgdeviceRestoreSettings, acqSrcAddress=acqSrcAddress, bdTraffic=bdTraffic, portRunt=portRunt, devErrorThreshold=devErrorThreshold, permDispType=permDispType, bdgdeviceRestartBdg=bdgdeviceRestartBdg, portStatus=portStatus, portAlign=portAlign, pcDeviceName=pcDeviceName, sourceAddrPort=sourceAddrPort, bdgdeviceUptime=bdgdeviceUptime, bdgdeviceLocation=bdgdeviceLocation, portXmitColls=portXmitColls, tokenRingD=tokenRingD, pcFramesXmit=pcFramesXmit, repeater=repeater, bdgPortTopChgAck=bdgPortTopChgAck, deviceFDDIBoardMap=deviceFDDIBoardMap, portLinkStatus=portLinkStatus, deviceEnetBoardMap=deviceEnetBoardMap, devCollsThreshold=devCollsThreshold, acqStaticEntries=acqStaticEntries, commsDevice=commsDevice, pcApplication=pcApplication, acqDispOutp1=acqDispOutp1, permEraseDatabase=permEraseDatabase, bdgdeviceBdgFwdDly=bdgdeviceBdgFwdDly, bdgdeviceBdgPriority=bdgdeviceBdgPriority, boardRingSpeedFault=boardRingSpeedFault, redundancyCircuitReset=redundancyCircuitReset, sysBDGType=sysBDGType, sysRepType=sysRepType, pcOwnerName=pcOwnerName, portCollsThreshold=portCollsThreshold, bdgdeviceBridgeID=bdgdeviceBridgeID, pcSqeErr=pcSqeErr, redundancyCircuitBoards=redundancyCircuitBoards, bdgPortName=bdgPortName, portRedundStatus=portRedundStatus, alarm=alarm, deviceTRTotalTokenRingRingPorts=deviceTRTotalTokenRingRingPorts, repeaterRev2=repeaterRev2, boardTotalStationPorts=boardTotalStationPorts, pcBoardType=pcBoardType, permStats=permStats, bdgdeviceBdgName=bdgdeviceBdgName, iRBM=iRBM, device=device, deviceRedundantCts=deviceRedundantCts, pcIntRecErr=pcIntRecErr, bdgPortCRCErr=bdgPortCRCErr, redundancyCircuitMACAddrDisp=redundancyCircuitMACAddrDisp, boardNoResources=boardNoResources, boardErrorPkts=boardErrorPkts, permDispOutp1=permDispOutp1, boardRecBytes=boardRecBytes, ringP=ringP, mACAddress=mACAddress, bdgdeviceType=bdgdeviceType, soidIRM2=soidIRM2, tokenRingB=tokenRingB, bdgPortPriority=bdgPortPriority, redundancyCircuitMACAddrDel=redundancyCircuitMACAddrDel, bdgPortDisErr=bdgPortDisErr, router=router, portRedundType=portRedundType, deviceNoResources=deviceNoResources, sourceAddrBoard=sourceAddrBoard, bdAlrm=bdAlrm, boardTransColl=boardTransColl, permDispOutp2=permDispOutp2, deviceResetCounter=deviceResetCounter, bdgdeviceRootPort=bdgdeviceRootPort, boardTotalRingPorts=boardTotalRingPorts, devAlrm=devAlrm, deviceOccupiedSlots=deviceOccupiedSlots, pcBytesXmit=pcBytesXmit, bdgPortFrAlErr=bdgPortFrAlErr, portTotalPkts=portTotalPkts, bdCollsThreshold=bdCollsThreshold, pcIF=pcIF, pcMMACAddr=pcMMACAddr, specialDB=specialDB, acqCreate20=acqCreate20, fddiB=fddiB, permCreate21=permCreate21, pcMMACBoard=pcMMACBoard, pcTooLong=pcTooLong, boardRunt=boardRunt, bdgPortState=bdgPortState, redundancyPerformTest=redundancyPerformTest, bdgPortColl=bdgPortColl, deviceCRC=deviceCRC, pcMultiColl=pcMultiColl, bridge=bridge, bdgdeviceRootCost=bdgdeviceRootCost, boardTotalStationPortsOn=boardTotalStationPortsOn, boardAlign=boardAlign, acqDynAgeTime=acqDynAgeTime, portErrorEnable=portErrorEnable, ieee8023=ieee8023, pcTotRecErrs=pcTotRecErrs, portSourceAddr=portSourceAddr, portIndex=portIndex, acqStaticAgeTime=acqStaticAgeTime, portErrorSource=portErrorSource, port=port, lmcommon=lmcommon, bdgPortDesigBrdg=bdgPortDesigBrdg, pcDriverRev=pcDriverRev, bdgPortPathCost=bdgPortPathCost, mAC=mAC, bdgdeviceDesigRoot=bdgdeviceDesigRoot, bdTrafficEnable=bdTrafficEnable, pcCRCErrs=pcCRCErrs, boardRecColl=boardRecColl, ringPortLinkStateTime=ringPortLinkStateTime, pcMMACPort=pcMMACPort, deviceSrcAddrTraps=deviceSrcAddrTraps, deviceTransmitColl=deviceTransmitColl, redundancyNumBPs=redundancyNumBPs, portColls=portColls, bdgdeviceResetCounts=bdgdeviceResetCounts, devCollsEnable=devCollsEnable, bdgPortDesigCost=bdgPortDesigCost, sysOtherType=sysOtherType, ethernetP=ethernetP, redundancyCircuitName=redundancyCircuitName, filterDB=filterDB, redundancyCircuitTypes=redundancyCircuitTypes, bdgPortStatus=bdgPortStatus, trapTypes=trapTypes, specNextFilterNum=specNextFilterNum, bdgTables=bdgTables, boardTotalPorts=boardTotalPorts, productRev1=productRev1, boardPortsOn=boardPortsOn, portRecBytes=portRecBytes, bdError=bdError, deviceType=deviceType, specPort2=specPort2, tokenRingP=tokenRingP, portMediaType=portMediaType, specDestAddress=specDestAddress, bdgPortOowColl=bdgPortOowColl, soidIRMSNMP=soidIRMSNMP, portTraffic=portTraffic, bdgdeviceSTAProtocol=bdgdeviceSTAProtocol, bdTrafficThreshold=bdTrafficThreshold, specStats=specStats, bdgdeviceSwitchSetting=bdgdeviceSwitchSetting, bdgdeviceNumPorts=bdgdeviceNumPorts, deviceAlign=deviceAlign, pcOnboardMemory=pcOnboardMemory, sourceAddr=sourceAddr, currentTime=currentTime, network=network, deviceSrcAddrLocked=deviceSrcAddrLocked, deviceResetRedundancy=deviceResetRedundancy, bdgPortFwdOutb=bdgPortFwdOutb, pcBytesRec=pcBytesRec, soidMINIMMAC=soidMINIMMAC, bdgPortFrFilt=bdgPortFrFilt, acqDelete=acqDelete, acqDispOutp2=acqDispOutp2, cabletron=cabletron, deviceMMACType=deviceMMACType, boardCRC=boardCRC, iRBMRevision=iRBMRevision, deviceSlots=deviceSlots, devErrorSource=devErrorSource, portGiants=portGiants, pcTooShort=pcTooShort, bdgPortNetName=bdgPortNetName, permCreate20=permCreate20, acqCreate01=acqCreate01, bdgdeviceTimeTopChg=bdgdeviceTimeTopChg, redundancyCircuitNumAddr=redundancyCircuitNumAddr, pcMcastRec=pcMcastRec, specSrcAddress=specSrcAddress, acqDispType=acqDispType, pcBcastRec=pcBcastRec, redundancyRetryCount=redundancyRetryCount, deviceIPAddress=deviceIPAddress, acqEraseDatabase=acqEraseDatabase, bdgdeviceNumRestarts=bdgdeviceNumRestarts, pcXcessColls=pcXcessColls, rr2board=rr2board, pcCarrErr=pcCarrErr, rr2device=rr2device, mMAC=mMAC, deviceTotalErrors=deviceTotalErrors, devErrorEnable=devErrorEnable, redundancyCircuitMACAddrAdd=redundancyCircuitMACAddrAdd, bdgdeviceHelloTime=bdgdeviceHelloTime, deviceTRTokenRingPortsOn=deviceTRTokenRingPortsOn, boardGiants=boardGiants, iRBMPortAssociation=iRBMPortAssociation, deviceTRTotalTokenRingRingPortsOn=deviceTRTotalTokenRingRingPortsOn, bdgPortTxAbrt=bdgPortTxAbrt, soidIRBM=soidIRBM, redundancyPollInterval=redundancyPollInterval, deviceSrcAddrAgingTime=deviceSrcAddrAgingTime, ringPortLinkStatus=ringPortLinkStatus, bdgPortRuntPackets=bdgPortRuntPackets, deviceTotalPorts=deviceTotalPorts, deviceTotalPkts=deviceTotalPkts, redundancyTestTod=redundancyTestTod, currentDate=currentDate, redundancyCircuitEnable=redundancyCircuitEnable, portCollsEnable=portCollsEnable, deviceRunt=deviceRunt, redundancy=redundancy, devTrafficThreshold=devTrafficThreshold, specDataField=specDataField, boardIndex=boardIndex, portCRC=portCRC, bdgdeviceErr=bdgdeviceErr)
mibBuilder.exportSymbols("Cabletron-MIB", bdgdeviceFrFlt=bdgdeviceFrFlt, bdgdeviceFwdDly=bdgdeviceFwdDly, common=common, bdErrorThreshold=bdErrorThreshold, bdgdeviceTopChgCnt=bdgdeviceTopChgCnt, boardName=boardName, bdErrorEnable=bdErrorEnable, pcLocation=pcLocation, fddiP=fddiP, deviceRecBytes=deviceRecBytes, devTraffic=devTraffic, commonB=commonB, commonP=commonP, bdgPortDesigRoot=bdgPortDesigRoot, pcMcastXmit=pcMcastXmit, pcAlignErrs=pcAlignErrs, boardType=boardType, bdgdeviceHoldTime=bdgdeviceHoldTime, specType=specType, sysOIDs=sysOIDs, portErrorPkts=portErrorPkts, redundancyCircuitPort=redundancyCircuitPort, portForceLinkType=portForceLinkType, specDeleteFilter=specDeleteFilter, deviceOOWColl=deviceOOWColl, pcFramesRec=pcFramesRec, board=board, deviceGiantFrames=deviceGiantFrames, bdgPortDesigPort=bdgPortDesigPort, bdgdeviceVersion=bdgdeviceVersion, acqDB=acqDB, repeaterTables=repeaterTables, acqOptions=acqOptions, bdgPort=bdgPort, bdErrorSource=bdErrorSource, bdgdeviceTypeFiltering=bdgdeviceTypeFiltering, specMaxEntries=specMaxEntries, bdgdeviceBdgMaxAge=bdgdeviceBdgMaxAge, boardModeStatus=boardModeStatus, boardSpeed=boardSpeed, rr2port=rr2port, deviceName=deviceName, permOptions=permOptions, permDelete=permDelete, sysIRMType=sysIRMType, boardSTATUS=boardSTATUS, subsystem=subsystem, pcLenErrs=pcLenErrs, bdCollsEnable=bdCollsEnable, fnb=fnb, bdgPortFrRx=bdgPortFrRx, deviceTokenRingBoardMap=deviceTokenRingBoardMap, commonD=commonD, pcTotXmitErrs=pcTotXmitErrs, bdgdeviceTopChg=bdgdeviceTopChg, bdgPortOversizePackets=bdgPortOversizePackets, portTrafficEnable=portTrafficEnable, permSrcAddress=permSrcAddress, bdgPortDisTDE=bdgPortDisTDE, bdgPortAddress=bdgPortAddress, bdgdeviceDisableBdg=bdgdeviceDisableBdg, pcSglColl=pcSglColl, portAdminState=portAdminState, fnbConnectedRight=fnbConnectedRight, stationP=stationP, pcDeferXmit=pcDeferXmit, deviceTimeBase=deviceTimeBase, portRedundCrt=portRedundCrt, bdgdevice=bdgdevice, product=product, pcIfRev=pcIfRev, commonRev1=commonRev1, specEnable=specEnable, portOOWColl=portOOWColl, portNoResorces=portNoResorces, bdgPortDisInb=bdgPortDisInb, portAlrm=portAlrm, bdgdeviceStatus=bdgdeviceStatus, pcComment=pcComment, stationPortLinkStateTime=stationPortLinkStateTime, bdgdeviceFrFwd=bdgdeviceFrFwd, specNumEntries=specNumEntries, repeaterRev1=repeaterRev1, pcLateColls=pcLateColls, specPort1=specPort1, boardOOWColl=boardOOWColl, deviceRecColls=deviceRecColls, acqDynEntries=acqDynEntries, stationPortLinkStatus=stationPortLinkStatus, acqCreate00=acqCreate00, bdgdeviceFrRx=bdgdeviceFrRx, bdgdeviceMaxAge=bdgdeviceMaxAge, portTopologyType=portTopologyType, acqTotalEntries=acqTotalEntries, soidMRXI=soidMRXI)

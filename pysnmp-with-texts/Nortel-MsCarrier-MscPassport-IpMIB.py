#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-IpMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-IpMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:25 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint")
Counter32, Integer32, RowStatus, InterfaceIndex, RouterID, StorageType, Unsigned32, RowPointer, AreaID, PhysAddress, DisplayString, Gauge32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Counter32", "Integer32", "RowStatus", "InterfaceIndex", "RouterID", "StorageType", "Unsigned32", "RowPointer", "AreaID", "PhysAddress", "DisplayString", "Gauge32")
AsciiStringIndex, DashedHexString, AsciiString, NonReplicated, Link, HexString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "AsciiStringIndex", "DashedHexString", "AsciiString", "NonReplicated", "Link", "HexString")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
mscVrPpIndex, mscVr, mscVrIndex, mscVrPp = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex", "mscVr", "mscVrIndex", "mscVrPp")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Counter32, ObjectIdentity, TimeTicks, ModuleIdentity, iso, Unsigned32, Counter64, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, Gauge32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter32", "ObjectIdentity", "TimeTicks", "ModuleIdentity", "iso", "Unsigned32", "Counter64", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "Gauge32", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
ipMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27))
mscVrPpIpPort = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5))
mscVrPpIpPortRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPort components.')
mscVrPpIpPortRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPort component.')
mscVrPpIpPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPort components. These components can be added and deleted.')
mscVrPpIpPortComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPort tables.')
mscVrPpIpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpIpPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortIndex.setDescription('This variable represents the index for the mscVrPpIpPort tables.')
mscVrPpIpPortProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortProvTable.setDescription('This group contains provisionable attributes for IP ports.')
mscVrPpIpPortProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortProvEntry.setDescription('An entry in the mscVrPpIpPortProvTable.')
mscVrPpIpPortMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortMaxTxUnit.setDescription('This attribute specifies the IP MTU (Maximum Transmission Unit) supported by this IpPort. The specified MTU must be within the valid range for the IpPort media type.')
mscVrPpIpPortArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortArpStatus.setDescription('This attribute specifies whether ARP is enabled or disabled on this IpPort. If auto is specified, an appropriate value will be selected based on the IpPort media type.')
mscVrPpIpPortProxyArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortProxyArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortProxyArpStatus.setDescription('This attribute specifies whether Proxy ARP is enabled or disabled for this IpPort.')
mscVrPpIpPortArpNoLearn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortArpNoLearn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortArpNoLearn.setDescription('This attribute specifies whether or not dynamic host entries will be installed in the ARP table when ARP packets are received on this IpPort.')
mscVrPpIpPortSendRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortSendRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortSendRedirect.setDescription('This attribute specifies whether or not ICMP host redirects will be sent out this IpPort.')
mscVrPpIpPortMulticastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortMulticastStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortMulticastStatus.setDescription('This attribute specifies whether or not IP multicast packets can be sent out this IpPort. If auto is specified, an appropriate value will be selected based on the IpPort media type.')
mscVrPpIpPortRelayAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 8), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortRelayAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRelayAddress.setDescription("This attribute specifies a relay broadcast address for this IpPort. Each packet, received on this IpPort, meeting the relay broadcast criteria will be forwarded to the specified relay broadcast address. An relay address of all zero's indicates no relay broadcast address.")
mscVrPpIpPortRelayBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortRelayBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRelayBroadcast.setDescription('This attribute specifies how packets, received on other IpPorts, meeting the relay broadcast criteria, will be forwarded out this IpPort. The three options are described as follows: enabled: packets will be forwarded out this IpPort. disabled: packets will not be forwarded out this IpPort. auto: packets will be forwarded out this IpPort only when the bridge state is forwarding.')
mscVrPpIpPortLinkModel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localAreaNetwork", 1), ("pointToPoint", 2))).clone('localAreaNetwork')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLinkModel.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLinkModel.setDescription('This attribute specifies the link model to use when the media type for this IpPort is PPP (Point to Point Protocol). A value of localAreaNetwork causes IP to treat this IpPort like a LAN. A value of pointToPoint causes IP to treat this IpPort like two directly connected IP hosts.')
mscVrPpIpPortLanModel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localAreaNetwork", 1), ("nonBroadcastMultipleAccess", 2))).clone('localAreaNetwork')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLanModel.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLanModel.setDescription('This attribute specifies the lan model to use for this IpPort.')
mscVrPpIpPortEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortEncap.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortEncap.setDescription('This attribute specifies the encapsulation type to be used when sending packets out this IpPort. If auto is specified, an appropriate value is selected based on the IpPort media type. The values ieee8023 and ethernet can only be specified if the media type is ethernet. Otherwise, auto must be specified. For ethernet media type, the default encapsulation is ethernet.')
mscVrPpIpPortIcmpMaskReply = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortIcmpMaskReply.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortIcmpMaskReply.setDescription('This attribute specifies whether or not replies will be generated in response to ICMP Address Mask Requests received on this IpPort.')
mscVrPpIpPortDirectedBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortDirectedBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortDirectedBroadcast.setDescription('This attribute specifies whether or not directed broadcast to physical broadcast translation is enabled for incoming traffic on this IpPort. The IP router requirement (RFC1812) says this translation should be enabled; however, in some network environments, setting this attribute to disabled may prevent operational problem such as broadcast storms. Note that in some configuration, setting this attribute to disabled may cause Bootp to fail.')
mscVrPpIpPortAssignedQos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortAssignedQos.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortAssignedQos.setDescription('This attribute specifies the initial Class of Service (CoS) given to each packet received on the IpPort. The CoS value n is used to select Vr/ <string> QosP/n. which determines the QualityofService-Profile to be used when the packet is forwarded. The initial CoS given to a packet by the assignedQoS attribute may be overridden under certain circumstances (see the description of the Vr Qosp component, the cosPolicyAssignment attribute on the IpPort and Ip components, and the ipCos attribute on any of the frameRelayDte staticDlci, frameRelayDte dynamicDlciDefaults, and atmMpe atmConnection components).')
mscVrPpIpPortAllowMcastMacDest = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortAllowMcastMacDest.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortAllowMcastMacDest.setDescription('This attribute specifies whether a multicast destination MAC address is valid on this IpPort or not. Enabling it is non-standard. It can be used for applications such as transparent server backup. Multicast destination MAC address is only supported on LAN media.')
mscVrPpIpPortCosPolicyAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 10, 1, 17), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortCosPolicyAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortCosPolicyAssignment.setDescription('This attribute specifies the CosPolicyGroup component this IpPort component is using. Assigning a particular policy group to the IpPort may override the effect of the assignedQos; this depends on the actual policies provisioned under the policy group.')
mscVrPpIpPortSresProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 11), )
if mibBuilder.loadTexts: mscVrPpIpPortSresProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortSresProvTable.setDescription('This group contains the provisioned attributes for SourceRouteEndStation support.')
mscVrPpIpPortSresProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortSresProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortSresProvEntry.setDescription('An entry in the mscVrPpIpPortSresProvTable.')
mscVrPpIpPortSourceRouteEndStationSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortSourceRouteEndStationSupport.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortSourceRouteEndStationSupport.setDescription('This attribute is used to enable or disable support for SourceRouteEndStation (Sres). If set to enable, Sres will be supported on this protocol on this ProtocolPort (Pp). If set to disable, it will not be supported. An Sres component must be provisioned under the VirtualRouter if this attribute is set to enable. If this attribute is set to enable and this Pp has its linkToMedia attribute set, it must be linked to a LanApplication (La) that has its Framer interfaceName linked to a Fddi or TokenRing component.')
mscVrPpIpPortAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 12), )
if mibBuilder.loadTexts: mscVrPpIpPortAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscVrPpIpPortAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortAdminControlEntry.setDescription('An entry in the mscVrPpIpPortAdminControlTable.')
mscVrPpIpPortSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscVrPpIpPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13), )
if mibBuilder.loadTexts: mscVrPpIpPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperTable.setDescription('This group contains operational attributes for an IpPort.')
mscVrPpIpPortOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperEntry.setDescription('An entry in the mscVrPpIpPortOperTable.')
mscVrPpIpPortMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18))).clone(namedValues=NamedValues(("ethernet", 1), ("fddi", 2), ("tokenRing", 3), ("ppp", 4), ("vcpEther", 5), ("vcpToken", 6), ("vns", 7), ("x25", 8), ("frameRelay", 9), ("clusterBridge", 10), ("smds", 11), ("invalid", 12), ("atmMpeVcEncap", 13), ("atmMpeLlcEncap", 14), ("lecEther", 15), ("lecToken", 16), ("tunnel", 17), ("virtual", 18))).clone('invalid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortMediaType.setDescription('This attribute indicates the media type of this IpPort.')
mscVrPpIpPortOperMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortOperMtu.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperMtu.setDescription('This attribute indicates the current operational IP MTU for this IpPort. Note that this value may be different than the provisioned maxTxUnit.')
mscVrPpIpPortOperArpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortOperArpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperArpStatus.setDescription('This attribute indicates the current operational ARP status. If the provisioned arpStatus is set to auto, then the IP application automatically determines the operArpStatus based on the IpPort media type.')
mscVrPpIpPortOperMulticastStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortOperMulticastStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperMulticastStatus.setDescription('This attribute indicates the current operational Multicast status. If the provisioned multicastStatus is set to auto, then the IP application automatically determines the operMulticastStatus based on the IpPort media type.')
mscVrPpIpPortOperEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("notApplicable", 3))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortOperEncap.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperEncap.setDescription('This attribute indicates the current operational encapsulation type. If the provisioned encap is set to auto, then the IP application automatically determines the operEncap based on the IpPort media type.')
mscVrPpIpPortOperCosPolicyAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 13, 1, 433), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortOperCosPolicyAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperCosPolicyAssignment.setDescription('This attribute specifies the CosPolicyGroup component this IpPort component is using.')
mscVrPpIpPortRelayBcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 14), )
if mibBuilder.loadTexts: mscVrPpIpPortRelayBcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRelayBcOperTable.setDescription("This group contains operational attributes for an IpPort's RelayBc counters.")
mscVrPpIpPortRelayBcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortRelayBcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRelayBcOperEntry.setDescription('An entry in the mscVrPpIpPortRelayBcOperTable.')
mscVrPpIpPortRelayAddressCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortRelayAddressCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRelayAddressCount.setDescription("This attribute indicates the number of frames received on this IpPort which were forwarded to the provisioned relayAddress for this port. This counter wraps to zero when it reaches it's maximum.")
mscVrPpIpPortRelayBcCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortRelayBcCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortRelayBcCount.setDescription("This attribute indicates the number of frames received on this port which were forwarded to the broadcastAddress on other IpPorts. This counter is incremented once for every frame received on this port regardless of how many other ports it was sent on. This counter wraps to zero when it reaches it's maximum.")
mscVrPpIpPortStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 15), )
if mibBuilder.loadTexts: mscVrPpIpPortStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpIpPortStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortStateEntry.setDescription('An entry in the mscVrPpIpPortStateTable.')
mscVrPpIpPortAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpIpPortOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpIpPortUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 15, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpIpPortOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 16), )
if mibBuilder.loadTexts: mscVrPpIpPortOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpIpPortOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortOperStatusEntry.setDescription('An entry in the mscVrPpIpPortOperStatusTable.')
mscVrPpIpPortSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpIpPortLogicalIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2))
mscVrPpIpPortLogicalIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortLogicalIf components.')
mscVrPpIpPortLogicalIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortLogicalIf component.')
mscVrPpIpPortLogicalIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortLogicalIf components. These components can be added and deleted.')
mscVrPpIpPortLogicalIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortLogicalIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortLogicalIf tables.')
mscVrPpIpPortLogicalIfAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfAddressIndex.setDescription('This variable represents the index for the mscVrPpIpPortLogicalIf tables.')
mscVrPpIpPortLogicalIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfProvTable.setDescription('This group contains attributes required to define an IpLogicalIf.')
mscVrPpIpPortLogicalIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfProvEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfProvTable.')
mscVrPpIpPortLogicalIfNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 10, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfNetMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfNetMask.setDescription('This attribute specifies the subnet mask for this IpLogicalIf. This attribute must be specified because the IP application will not automatically provide a default value.')
mscVrPpIpPortLogicalIfBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 10, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfBroadcastAddress.setDescription('This attribute specifies the broadcast address for this IpLogicalIf. This attribute is ignored if the IpPort mediaType is ppp (Point to Point Protocol). If the value is 0.0.0.0, the actual broadcast address will be derived from the IP address of this LogicalIf and the netmask attribute.')
mscVrPpIpPortLogicalIfLinkDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 10, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfLinkDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfLinkDestinationAddress.setDescription('This attribute specifies the address for the link destination for this IpLogicalIf. This attribute is only required if the IpPort media type is PPP (Point to Point Protocol).')
mscVrPpIpPortLogicalIfOspfIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2))
mscVrPpIpPortLogicalIfOspfIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortLogicalIfOspfIf components.')
mscVrPpIpPortLogicalIfOspfIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortLogicalIfOspfIf component.')
mscVrPpIpPortLogicalIfOspfIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortLogicalIfOspfIf components. These components can be added and deleted.')
mscVrPpIpPortLogicalIfOspfIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortLogicalIfOspfIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortLogicalIfOspfIf tables.')
mscVrPpIpPortLogicalIfOspfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfIndex.setDescription('This variable represents the index for the mscVrPpIpPortLogicalIfOspfIf tables.')
mscVrPpIpPortLogicalIfOspfIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfProvTable.setDescription('This group of attributes identifies a provisionable set of attributes.')
mscVrPpIpPortLogicalIfOspfIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfProvEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfOspfIfProvTable.')
mscVrPpIpPortLogicalIfOspfIfAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 1), AreaID().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfAreaId.setDescription('The area Id this Ospf interface belongs to.')
mscVrPpIpPortLogicalIfOspfIfIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("broadcast", 1), ("nbma", 2), ("pointToPoint", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfIfType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfIfType.setDescription('This attribute indicates the type of this Ospf interface. This interface type does not necessarily correlate with the type of the interface set on the logicalIf entry under IpPort.')
mscVrPpIpPortLogicalIfOspfIfSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfSnmpAdminStatus.setDescription('The administrative status of this Ospf interface.')
mscVrPpIpPortLogicalIfOspfIfRtrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRtrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRtrPriority.setDescription('The priority of this interface. Used in multi-access networks, this field is used in the designated router election algorithm. The value 0 signifies that the router is not eligible to become the designated router on this particular protocol port. In the event of a tie in this value, routers will use their routerId as a tie breaker.')
mscVrPpIpPortLogicalIfOspfIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a link-state update packet over this interface.')
mscVrPpIpPortLogicalIfOspfIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRetransInterval.setDescription('The number of seconds between link-state advertisements retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets.')
mscVrPpIpPortLogicalIfOspfIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfHelloInterval.setDescription('The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for all routers attached to a common network.')
mscVrPpIpPortLogicalIfOspfIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(40)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfRtrDeadInterval.setDescription("The number of seconds that a router's hello packets have not been seen before it's neighbors declare the router down. This should be some multiple of the helloIntereval. This value must be the same for all routers attached to a common network.")
mscVrPpIpPortLogicalIfOspfIfPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfPollInterval.setDescription('The largest time interval, in seconds, between the hello packets sent to an inactive non-broadcast multi-access neighbor.')
mscVrPpIpPortLogicalIfOspfIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 10), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)).clone(hexValue="0000000000000000")).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfAuthKey.setDescription('The Authentication Key. If the value of the attribute authType of an AreaEntry is simplePassword, and the authKey length is shorter than 8 octets, then the value of authKey will be left adjusted zero-filled to 8 octets.')
mscVrPpIpPortLogicalIfOspfIfMulticastForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("blocked", 1))).clone('blocked')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMulticastForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMulticastForwarding.setDescription('The way multicasts should be forwarded on this interface; non forwarded, forwarded as data-link multicasts, or forwarded as data-link unicasts. Data-link multicasting is not meaningful on point-to-point and NBMA(No Broadcast Multi Access) interfaces, and setting this attribute to blocked effectively disables all multicast forwarding.')
mscVrPpIpPortLogicalIfOspfIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 11), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfOperTable.setDescription('This group of attributes identifies operational state that this interface is performing.')
mscVrPpIpPortLogicalIfOspfIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfOperEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfOspfIfOperTable.')
mscVrPpIpPortLogicalIfOspfIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("down", 1), ("loopback", 2), ("waiting", 3), ("pointToPoint", 4), ("designatedRouter", 5), ("backupDesignatedRouter", 6), ("otherDesignatedRouter", 7))).clone('designatedRouter')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfState.setDescription('The state of the OSPF interface.')
mscVrPpIpPortLogicalIfOspfIfDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 11, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfDesignatedRouter.setDescription('The Ip address of the designated router.')
mscVrPpIpPortLogicalIfOspfIfBackupDesignatedRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 11, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfBackupDesignatedRouter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfBackupDesignatedRouter.setDescription('The Ip address of the backup designated router')
mscVrPpIpPortLogicalIfOspfIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfEvents.setDescription('The number of times this OSPF interface has changed its state or an error has occurred.')
mscVrPpIpPortLogicalIfOspfIfMetricTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 12), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMetricTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMetricTable.setDescription('This group contains the operational metric attribute of this interface.')
mscVrPpIpPortLogicalIfOspfIfMetricEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMetricEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMetricEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfOspfIfMetricTable.')
mscVrPpIpPortLogicalIfOspfIfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfMetric.setDescription('This attribute indicates the metric being used by this OspfIf. The metric is derived in one of two ways: 1. If there is a TypeOfService component provisioned under this OspfIf component, then the value of the metric attribute is copied from the provisionable attribute tosMetric. 2. Otherwise, the metric is computed based on the interface speed. If the interface speed is greater than 100 Mbit/s, then the metric is 1. If the interface speed is less than 100 Mbit/s, then the metric is 100 Mbit/s divided by the interface speed. If the interface speed is unknown, then it is treated as 1.54 Mbit/s during the calculation. The value of interface speed is available by displaying the ifSpeed attribute of the corresponding IfTableEntry component.')
mscVrPpIpPortLogicalIfOspfIfTOS = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2))
mscVrPpIpPortLogicalIfOspfIfTOSRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortLogicalIfOspfIfTOS components.')
mscVrPpIpPortLogicalIfOspfIfTOSRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfTOSMetricTosIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortLogicalIfOspfIfTOS component.')
mscVrPpIpPortLogicalIfOspfIfTOSRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortLogicalIfOspfIfTOS components. These components can be added and deleted.')
mscVrPpIpPortLogicalIfOspfIfTOSComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortLogicalIfOspfIfTOSStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortLogicalIfOspfIfTOS tables.')
mscVrPpIpPortLogicalIfOspfIfTOSMetricTosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSMetricTosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSMetricTosIndex.setDescription('This variable represents the index for the mscVrPpIpPortLogicalIfOspfIfTOS tables.')
mscVrPpIpPortLogicalIfOspfIfTOSProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSProvTable.setDescription('Identifies a provisionable set of attributes.')
mscVrPpIpPortLogicalIfOspfIfTOSProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfTOSMetricTosIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSProvEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfOspfIfTOSProvTable.')
mscVrPpIpPortLogicalIfOspfIfTOSTosMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSTosMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfTOSTosMetric.setDescription('The metric using this typeOfService on this interface.')
mscVrPpIpPortLogicalIfOspfIfNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3))
mscVrPpIpPortLogicalIfOspfIfNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortLogicalIfOspfIfNbr components.')
mscVrPpIpPortLogicalIfOspfIfNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortLogicalIfOspfIfNbr component.')
mscVrPpIpPortLogicalIfOspfIfNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortLogicalIfOspfIfNbr components. These components can be added and deleted.')
mscVrPpIpPortLogicalIfOspfIfNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortLogicalIfOspfIfNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortLogicalIfOspfIfNbr tables.')
mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex.setDescription('This variable represents the index for the mscVrPpIpPortLogicalIfOspfIfNbr tables.')
mscVrPpIpPortLogicalIfOspfIfNbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrProvTable.setDescription('Identifies a group of Provisionable attributes.')
mscVrPpIpPortLogicalIfOspfIfNbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrProvEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfOspfIfNbrProvTable.')
mscVrPpIpPortLogicalIfOspfIfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrPriority.setDescription('The priority of this neighbor in the designated router election algorithm. The value 0 signifies that the neighbor is not eligible to become the designated router on this particular network. The higher the number, the better are the chances of being a designated router.')
mscVrPpIpPortLogicalIfOspfIfNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrOperTable.setDescription('Contains the Operational set of attributes for the Neighbor.')
mscVrPpIpPortLogicalIfOspfIfNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrOperEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfOspfIfNbrOperTable.')
mscVrPpIpPortLogicalIfOspfIfNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1, 1), RouterID()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrRtrId.setDescription('An Ip Address uniquely identifying the neighboring router in the Autonomous System.')
mscVrPpIpPortLogicalIfOspfIfNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrOptions.setDescription("A bit mask corresponding to the neighbor's options field. Bit 0, if set, indicates that the area accepts and operates on external information, if zero, it is a stub area. Bit 1, if set, indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric. Bit 2, if set, indicates that the system is Network Multicast capable; i.e., that it implements OSPF Multicast Routing.")
mscVrPpIpPortLogicalIfOspfIfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrState.setDescription('The state of the relationship with this neighbor.')
mscVrPpIpPortLogicalIfOspfIfNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrEvents.setDescription('The number of times this neighbor relationship has changed state, or an error has occurred.')
mscVrPpIpPortLogicalIfOspfIfNbrLsRetransQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrLsRetransQlen.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrLsRetransQlen.setDescription('The current length of the Retransmission queue.')
mscVrPpIpPortLogicalIfOspfIfNbrExchangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrExchangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrExchangeStatus.setDescription('Indicates the exchange status for a neighbor Entry.')
mscVrPpIpPortLogicalIfOspfIfNbrPermanance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 2, 3, 11, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanent", 1), ("dynamic", 2))).clone('permanent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrPermanance.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfOspfIfNbrPermanance.setDescription('This attribute displays how the neighbor became an entry.')
mscVrPpIpPortLogicalIfRipIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3))
mscVrPpIpPortLogicalIfRipIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortLogicalIfRipIf components.')
mscVrPpIpPortLogicalIfRipIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfRipIfIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortLogicalIfRipIf component.')
mscVrPpIpPortLogicalIfRipIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortLogicalIfRipIf components. These components can be added and deleted.')
mscVrPpIpPortLogicalIfRipIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortLogicalIfRipIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortLogicalIfRipIf tables.')
mscVrPpIpPortLogicalIfRipIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIndex.setDescription('This variable represents the index for the mscVrPpIpPortLogicalIfRipIf tables.')
mscVrPpIpPortLogicalIfRipIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfProvTable.setDescription('This group contains the provisionable attributes of the RipIf component.')
mscVrPpIpPortLogicalIfRipIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfRipIfIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfProvEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfRipIfProvTable.')
mscVrPpIpPortLogicalIfRipIfSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfSnmpAdminStatus.setDescription('Identifies the administrative status of this RipInterface. Setting this value to disabled will have the effect of rendering it inactive.')
mscVrPpIpPortLogicalIfRipIfMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfMetric.setDescription('This attribute is the RIP metric for this logical interface.')
mscVrPpIpPortLogicalIfRipIfSilentFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfSilentFlag.setStatus('obsolete')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfSilentFlag.setDescription('If the value of this attribute is set to true, the protocol will only listen to RIP updates, If set to false, then Rip will listen and send RIP updates.This attribute has been migrated to ifConfSend.')
mscVrPpIpPortLogicalIfRipIfPoisonReverseFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfPoisonReverseFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfPoisonReverseFlag.setDescription('If the value of this attribute is set to true, then poison reverse algorithm is used when sending out the updates otherwise use split horizon only.')
mscVrPpIpPortLogicalIfRipIfFlashUpdateFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfFlashUpdateFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfFlashUpdateFlag.setDescription('This attribute when set to true will send updates when updates are received; otherwise RIP will wait till the next update period.')
mscVrPpIpPortLogicalIfRipIfNetworkRouteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("naturalNetWithOutDefaultRoute", 1), ("naturalNetWithDefaultRoute", 2), ("defaultRouteOnly", 3), ("subnetsOnly", 4))).clone('naturalNetWithOutDefaultRoute')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNetworkRouteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNetworkRouteStatus.setDescription('This attribute determines what type of network routes will be sent and whether a default route will be generated for this RipInterface. Generated default routes will not go into the routing table, but are sent in the updates going out on the interface. The possible values for this attribute are: naturalNetWithOutDefaultRoute - This value will cause normal RIP network routes to be put in the update. This means that the address of logicalIf pertaining to this RipInterface knowledge is taken into account in determining if the subnetted network or the natural network is sent for any route going into this update. naturalNetWithDefaultRoute - Selecting this value will cause a default route to be generated with the value of the metric selected for the attribute defaultRouteMetric. defaultRouteOnly - Selection of this value causes the default route to be generated with the value of the metric selected for the attribute defaultRouteMetric. NOTE: No other routes will go in the update. subnetsOnly - selection of this value will cause only subnet information to be put in the update. No default routes will be generated or passed on. Only subnetted routes that are part of the same subnetted network that this logicalInterface is on will be put in the update. NOTE: this also effects receiving of updates on this interface. Only subnetted routes that are part of the same subnetted network that this logicalInterface is on will be accepted on a received RIP update on this RipInterface.')
mscVrPpIpPortLogicalIfRipIfDefaultRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfDefaultRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfDefaultRouteMetric.setDescription('This attribute identifies the metric value for the default route. This value is only used if the attribute networkRouteStatus is configured with a value of either naturalNetWithDefaultRoute or defaultRouteOnly')
mscVrPpIpPortLogicalIfRipIfAcceptDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfAcceptDefault.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfAcceptDefault.setDescription('If this attribute is set to true, then accept the default route from this interface.')
mscVrPpIpPortLogicalIfRipIfIfConfSend = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("doNotSend", 1), ("ripVersion1", 2), ("rip1Compatible", 3), ("ripVersion2", 4))).clone('rip1Compatible')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfConfSend.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfConfSend.setDescription('This attribute identifies what the router sends on this RipIf. ripVersion1 implies sending RIP updates compliant with RFC 1058. rip1Compatible implies broadcasting RIP-2 updates according to RFC 1058. ripVersion2 implies multicasting RIP-2 updates.')
mscVrPpIpPortLogicalIfRipIfIfConfReceive = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rip1", 1), ("rip2", 2), ("rip1OrRip2", 3), ("doNotReceive", 4))).clone('rip1OrRip2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfConfReceive.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfConfReceive.setDescription('This attribute identifies which version of RIP updates are to be accepted on this RipIf. Note that rip2 and rip1OrRip2 implies reception of multicast packets.')
mscVrPpIpPortLogicalIfRipIfStatTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 11), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfStatTable.setDescription('This group contains operational attributes of the RipIf component. These attributes are statistical data corresponding to the RIP-2 standard MIB (rfc 1724) rip2Status table.')
mscVrPpIpPortLogicalIfRipIfStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfRipIfIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfStatEntry.setDescription('An entry in the mscVrPpIpPortLogicalIfRipIfStatTable.')
mscVrPpIpPortLogicalIfRipIfIfBadPacketRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfBadPacketRcv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfBadPacketRcv.setDescription('This attribute counts the number of RIP response packets recieved by the RIP process which were subsequently discarded for any reason.')
mscVrPpIpPortLogicalIfRipIfIfBadRouteRcv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfBadRouteRcv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfBadRouteRcv.setDescription('This attribute counts how many routes, in valid RIP packets, were ignored for any reason.')
mscVrPpIpPortLogicalIfRipIfIfTriggeredUpdates = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfTriggeredUpdates.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfIfTriggeredUpdates.setDescription('This attribute counts the number of triggered updates actually sent on this interface. This explicitly does NOT include full updates sent containing new information.')
mscVrPpIpPortLogicalIfRipIfNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 2))
mscVrPpIpPortLogicalIfRipIfNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 2, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortLogicalIfRipIfNbr components.')
mscVrPpIpPortLogicalIfRipIfNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfRipIfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortLogicalIfRipIfNbrIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortLogicalIfRipIfNbr component.')
mscVrPpIpPortLogicalIfRipIfNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortLogicalIfRipIfNbr components. These components can be added and deleted.')
mscVrPpIpPortLogicalIfRipIfNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortLogicalIfRipIfNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortLogicalIfRipIfNbr tables.')
mscVrPpIpPortLogicalIfRipIfNbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 2, 3, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortLogicalIfRipIfNbrIndex.setDescription('This variable represents the index for the mscVrPpIpPortLogicalIfRipIfNbr tables.')
mscVrPpIpPortNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3))
mscVrPpIpPortNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortNs components.')
mscVrPpIpPortNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortNsIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortNs component.')
mscVrPpIpPortNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortNs components. These components can be added and deleted.')
mscVrPpIpPortNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortNs tables.')
mscVrPpIpPortNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpIpPortNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsIndex.setDescription('This variable represents the index for the mscVrPpIpPortNs tables.')
mscVrPpIpPortNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsProvTable.setDescription('This group contains the attributes required by NetSentry to be applied to all IP packets going through this IpPort.')
mscVrPpIpPortNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortNsIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsProvEntry.setDescription('An entry in the mscVrPpIpPortNsProvTable.')
mscVrPpIpPortNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsIncomingFilter.setDescription('An ASCII string which provides the name of the NetSentry filter which will be applied to all IP datagrams arriving from this IpPort.')
mscVrPpIpPortNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortNsOutgoingFilter.setDescription('An ASCII string which provides the name of NetSentry filter which will be applied to all IP datagrams sent to this IpPort.')
mscVrPpIpPortBootpP = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4))
mscVrPpIpPortBootpPRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 1), )
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpIpPortBootpP components.')
mscVrPpIpPortBootpPRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpIpPortBootpP component.')
mscVrPpIpPortBootpPRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpIpPortBootpP components. These components can be added and deleted.')
mscVrPpIpPortBootpPComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpIpPortBootpPStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStorageType.setDescription('This variable represents the storage type value for the mscVrPpIpPortBootpP tables.')
mscVrPpIpPortBootpPIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpIpPortBootpPIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPIndex.setDescription('This variable represents the index for the mscVrPpIpPortBootpP tables.')
mscVrPpIpPortBootpPProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 10), )
if mibBuilder.loadTexts: mscVrPpIpPortBootpPProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPProvTable.setDescription('This group contains provisionable attributes for the BootpPort component.')
mscVrPpIpPortBootpPProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortBootpPProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPProvEntry.setDescription('An entry in the mscVrPpIpPortBootpPProvTable.')
mscVrPpIpPortBootpPRelayForwardStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("auto", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRelayForwardStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPRelayForwardStatus.setDescription('This attribute controls how BOOTP request packets, received on another port, will be flooded out this port. If relayForwardStatus is enabled, BOOTP requests received on another port will be broadcast out this port. When relayForwardStatus is disabled, BOOTP requests will not be broadcast out this port. If auto is used, the bridge spanning tree database is used to determine if BOOTP requests should be broadcast out this port. Note that when using enabled, it is possible to create misconfigurations which will result in broadcast storms. When using this feature with multiple routers, make sure there are no broadcast forwarding loops. Using auto with bridge spanning tree is safer to use if the network is running bridge spanning tree. Note that for auto to have effect, bridge spanning tree must be running on the corresponding VirtualRouter ProtocolPort.')
mscVrPpIpPortBootpPBootpLogicalInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 10, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPBootpLogicalInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPBootpLogicalInterface.setDescription('This attribute identifies the logical interface whose address is to be the GIADDR of this BOOTP port. If not set, the address of the first logical port is chosen.')
mscVrPpIpPortBootpPAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 11), )
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscVrPpIpPortBootpPAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAdminControlEntry.setDescription('An entry in the mscVrPpIpPortBootpPAdminControlTable.')
mscVrPpIpPortBootpPSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscVrPpIpPortBootpPOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 12), )
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpIpPortBootpPOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOperStatusEntry.setDescription('An entry in the mscVrPpIpPortBootpPOperStatusTable.')
mscVrPpIpPortBootpPSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpIpPortBootpPStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 13), )
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpIpPortBootpPStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStateEntry.setDescription('An entry in the mscVrPpIpPortBootpPStateTable.')
mscVrPpIpPortBootpPAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpIpPortBootpPOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpIpPortBootpPUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 13, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpIpPortBootpPStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14), )
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStatsTable.setDescription('This group contains BootpPortEntry component statistics.')
mscVrPpIpPortBootpPStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPIndex"))
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPStatsEntry.setDescription('An entry in the mscVrPpIpPortBootpPStatsTable.')
mscVrPpIpPortBootpPInRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInRequests.setDescription('This attribute counts the total number of BOOTP Request messages received on this port.')
mscVrPpIpPortBootpPInReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInReplies.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInReplies.setDescription('This attribute counts the total number of BOOTP Reply messages received on this port.')
mscVrPpIpPortBootpPOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOutRequests.setDescription('This attribute counts total the number of BOOTP Request messages broadcast out on this port.')
mscVrPpIpPortBootpPOutReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOutReplies.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPOutReplies.setDescription('This attribute counts the total number of BOOTP Reply messages sent out on this port.')
mscVrPpIpPortBootpPInRequestErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInRequestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInRequestErrors.setDescription('This attribute counts the number of BOOTP Request messages received on this port but not forwarded due to an error. An error occurs if the BOOTP hop limit has been exceeded.')
mscVrPpIpPortBootpPInReplyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 14, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInReplyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPInReplyErrors.setDescription('This attribute counts the number of BOOTP Reply messages received on this port but not forwarded due to an error. An error occurs if the giaddr field in the BOOTP reply does not match an IP address assigned to this VirtualRouter, or if the output IpPort for the BOOTP reply is not provisioned for BOOTP.')
mscVrPpIpPortBootpPAddrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 290), )
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrTable.setDescription("This attribute identifies a list of relay addresses. When a BOOTP request message is received on this port, the request will be forwarded to the IP addresses provisioned in relayAddress. Note that BOOTP requests are also broadcast out all other BootpPort's according to the relayForwardStatus of the outgoing port.")
mscVrPpIpPortBootpPAddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 290, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrPpIpPortBootpPAddrValue"))
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrEntry.setDescription('An entry in the mscVrPpIpPortBootpPAddrTable.')
mscVrPpIpPortBootpPAddrValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 290, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrValue.setDescription('This variable represents both the value and the index for the mscVrPpIpPortBootpPAddrTable.')
mscVrPpIpPortBootpPAddrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 5, 4, 290, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpIpPortBootpPAddrRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVrPpIpPortBootpPAddrTable.')
mscVrIp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6))
mscVrIpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 1), )
if mibBuilder.loadTexts: mscVrIpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIp components.')
mscVrIpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"))
if mibBuilder.loadTexts: mscVrIpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIp component.')
mscVrIpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIp components. These components can be added and deleted.')
mscVrIpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStorageType.setDescription('This variable represents the storage type value for the mscVrIp tables.')
mscVrIpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIndex.setDescription('This variable represents the index for the mscVrIp tables.')
mscVrIpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 100), )
if mibBuilder.loadTexts: mscVrIpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpProvTable.setDescription('This group contains global attributes for IP.')
mscVrIpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"))
if mibBuilder.loadTexts: mscVrIpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpProvEntry.setDescription('An entry in the mscVrIpProvTable.')
mscVrIpForwarding = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("gateway", 1))).clone('gateway')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpForwarding.setDescription('This attribute indicates whether or not this VR is acting as an IP gateway in respect to the forwarding of datagrams received by, but not addressed to, this VR')
mscVrIpDefaultTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(255, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpDefaultTtl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpDefaultTtl.setDescription('This attribute is the default value inserted into the Time-To-Live field of the IP header of datagrams originated at this entity, whenever a Time- To-Live value is not supplied by the transport layer protocol. The value of this attribute deviates from the MIB requirement that it will always have a value of 255.')
mscVrIpCosPolicyAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 100, 1, 4), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpCosPolicyAssignment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCosPolicyAssignment.setDescription('This attribute specifies the default cosPolicyGroup component that is associated with the IpPort of every protocol port on the virtual router. An individual IpPort can override this default using its own cosPolicyAssignment attribute. If this attribute is empty, CoS policy groups are assigned to only those IP ports where the cosPolicyAssignment attribute under the IpPort component is non-empty.')
mscVrIpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101), )
if mibBuilder.loadTexts: mscVrIpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStatsTable.setDescription('This is the GROUP holding the struct which contains statistical attributes for IP.')
mscVrIpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"))
if mibBuilder.loadTexts: mscVrIpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStatsEntry.setDescription('An entry in the mscVrIpStatsTable.')
mscVrIpInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpInReceives.setDescription('This is the number of input datagrams received from the interfaces, including those received in error . inReceives wraps to zero if reaches its maximum defined value.')
mscVrIpInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpInHdrErrors.setDescription('The number of input datagrams discarded due to errors in their IP headers, including bad checksums, version number mismatch, other format errors, time-to-live exceeded, errors discovered in processing their IP options, etc. inHdrErrors wraps to zero if reaches its maximum defined value.')
mscVrIpInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpInAddrErrors.setDescription('The number of input datagrams discarded due to errors such as invalid address, unsupported address class. inAddrErrors wraps to zero if reaches its maximum defined value.')
mscVrIpForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpForwDatagrams.setDescription("The number of input datagrams for which this router was not their final IP destination, as a result of which an attempt was made to find a route to forward them to that final destination. forwDatagrams wraps to zero if reaches it's maximum defined value.")
mscVrIpInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpInUnknownProtos.setDescription('The number of locally-addressed datagrams received successfully but discarded because of an unknown or unsupported protocol inUnknownProtos wraps to zero if reaches its maximum defined value.')
mscVrIpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpInDiscards.setDescription('The number of input datagrams for which no problems were encountered to prevent their continued processing, but which were discarded due to the lack of buffers. This does not include any datagram discarded while awaiting for re-assembly. inDiscards wraps to zero if reaches its maximum defined value.')
mscVrIpInDelivers = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpInDelivers.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpInDelivers.setDescription('The number of input datagrams successfully delivered to IP user- protocols (including ICMP). inDelivers wraps to zero if reaches its maximum defined value.')
mscVrIpOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOutRequests.setDescription('The number of datagrams which local IP user-protocols (including ICMP) supplied to IP in requests for transmission. This sum does not include datagrams counted in ForwDatagrams. outRequests wraps to zero if reaches its maximum defined value.')
mscVrIpOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOutDiscards.setDescription('The number of outbound datagrams that were discarded due to the lack of buffers. This sum also includes datagrams counted in forwDatagrams if any such packets met the discard criterion. outDiscards wraps to zero if reaches its maximum defined value.')
mscVrIpOutNoRoutes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOutNoRoutes.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOutNoRoutes.setDescription('The number of outbound datagrams discarded because no route could be found to transmit them to their destination. This counter includes any datagrams counted in forwDatagrams. outNoRoutes wraps to zero if reaches its maximum defined value.')
mscVrIpReasmTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5)).clone(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpReasmTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpReasmTimeOut.setDescription('The maximum number of seconds, which received fragments are held while they are awaiting reassembly at this gateway.')
mscVrIpReasmReqds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpReasmReqds.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpReasmReqds.setDescription('The number of the IP fragments received by this gateway which needed to be reassembled. reasmReqds wraps to zero if reaches its maximum defined value.')
mscVrIpReasmOks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpReasmOks.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpReasmOks.setDescription('The number of IP fragments successfully reassembled by this gateway. reasmOks wraps to zero if reaches its maximum defined value.')
mscVrIpReasmFails = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpReasmFails.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpReasmFails.setDescription('The number of times this gateway is unabled to assemble IP-fragments for whatever reasons. reasmFails wraps to zero if reaches its maximum defined value.')
mscVrIpFragOks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFragOks.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFragOks.setDescription('The number of IP datagrams that have been successfully fragmented by this gateway. fragOks wraps to zero if reaches its maximum defined value.')
mscVrIpFragFails = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFragFails.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFragFails.setDescription("The number of IP-fragments that have been discarded because they needed to be fragmented but could not be. For example, their Don't Fragment flag was set. fragFails wraps to zero if reaches its maximum defined value.")
mscVrIpFragCreates = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFragCreates.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFragCreates.setDescription('This number of IP fragments that have been generated as a result of fragmentation by this gateway. fragCreates wraps to zero if reaches its maximum defined value.')
mscVrIpRoutingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 101, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRoutingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRoutingDiscards.setDescription('The number of routing entries which were chosen to be discarded even though they are valid. One possible reason for discarding such an entry could be to free -up buffer space for other routing entries. In this implementation, this number is always zero because IP never deletes a valid routing entry.')
mscVrIpAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 102), )
if mibBuilder.loadTexts: mscVrIpAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscVrIpAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 102, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"))
if mibBuilder.loadTexts: mscVrIpAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpAdminControlEntry.setDescription('An entry in the mscVrIpAdminControlTable.')
mscVrIpSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscVrIpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 104), )
if mibBuilder.loadTexts: mscVrIpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 104, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"))
if mibBuilder.loadTexts: mscVrIpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStateEntry.setDescription('An entry in the mscVrIpStateTable.')
mscVrIpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 104, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 104, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 104, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 107), )
if mibBuilder.loadTexts: mscVrIpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrIpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 107, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"))
if mibBuilder.loadTexts: mscVrIpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOperStatusEntry.setDescription('An entry in the mscVrIpOperStatusTable.')
mscVrIpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 107, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrIpCtsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 394), )
if mibBuilder.loadTexts: mscVrIpCtsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCtsTable.setDescription('This attribute specifies the maximum number of entries that can exist in the IP local cache table on each LP. This attribute provides a way to control the resources allocated to the IP cache tables. The default cache table size is 3000 for an FP and 100 for a CP, is used if this attribute is not specified explicitly. The attribute value must be multiple of 100.')
mscVrIpCtsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 394, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpCtsIndex"))
if mibBuilder.loadTexts: mscVrIpCtsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCtsEntry.setDescription('An entry in the mscVrIpCtsTable.')
mscVrIpCtsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 394, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscVrIpCtsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCtsIndex.setDescription('This variable represents the mscVrIpCtsTable specific index for the mscVrIpCtsTable.')
mscVrIpCtsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 394, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 8000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpCtsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCtsValue.setDescription('This variable represents an individual value for the mscVrIpCtsTable.')
mscVrIpFwd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3))
mscVrIpFwdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1), )
if mibBuilder.loadTexts: mscVrIpFwdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpFwd components.')
mscVrIpFwdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdTypeOfServiceIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdGatewayIndex"))
if mibBuilder.loadTexts: mscVrIpFwdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpFwd component.')
mscVrIpFwdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpFwd components. These components cannot be added nor deleted.')
mscVrIpFwdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpFwdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdStorageType.setDescription('This variable represents the storage type value for the mscVrIpFwd tables.')
mscVrIpFwdDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpFwdDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdDestAddressIndex.setDescription('This variable represents an index for the mscVrIpFwd tables.')
mscVrIpFwdDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: mscVrIpFwdDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdDestMaskIndex.setDescription('This variable represents an index for the mscVrIpFwd tables.')
mscVrIpFwdTypeOfServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31)))
if mibBuilder.loadTexts: mscVrIpFwdTypeOfServiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdTypeOfServiceIndex.setDescription('This variable represents an index for the mscVrIpFwd tables.')
mscVrIpFwdGatewayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: mscVrIpFwdGatewayIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdGatewayIndex.setDescription('This variable represents an index for the mscVrIpFwd tables.')
mscVrIpFwdOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10), )
if mibBuilder.loadTexts: mscVrIpFwdOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Identifies a group of operational attributes associated with each entry in the Forward Table.')
mscVrIpFwdOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdTypeOfServiceIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpFwdGatewayIndex"))
if mibBuilder.loadTexts: mscVrIpFwdOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdOperEntry.setDescription('An entry in the mscVrIpFwdOperTable.')
mscVrIpFwdIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1, 1), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdIfIndex.setDescription('This attribute specifies the SNMP index associated with the protocol port represented by the attribute protocolPortName, which identifies the local interface through which the next hop of this route should be reached.')
mscVrIpFwdType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notDefined", 1), ("invalid", 2), ("localInterface", 3), ("remoteDestination", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdType.setDescription('Specifies the type of the route,')
mscVrIpFwdProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netmgmt", 3), ("icmp", 4), ("egp", 5), ("ggp", 6), ("hello", 7), ("rip", 8), ("isIs", 9), ("esIs", 10), ("ciscoIgrp", 11), ("bbnSpfIgp", 12), ("ospf", 13), ("bgp", 14), ("idpr", 15), ("mpls", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdProtocol.setDescription('This Attribute identifies the routing mechanism by which this route was learned.')
mscVrIpFwdAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdAge.setDescription('This attribute specifies the number of seconds since this route was last updated or otherwise determined to be correct.')
mscVrIpFwdProtocolPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1, 5), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdProtocolPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdProtocolPortName.setDescription('Indicates the name of the protocol port by which the next hop of this route should be reached.')
mscVrIpFwdNextHopAs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 429467295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdNextHopAs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdNextHopAs.setDescription('This attribute specifies the Autonomous System number of the Next Hop. If unknown or not relevant to the protocol indicated by the attribute protocol, the value should be zero.')
mscVrIpFwdMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpFwdMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpFwdMetric.setDescription('This attribute specifies the primary routing metric for this route. The semantics of this metric are determined by the routing protocol specified by the value of the attribute protocol. If this metric is not used, its value should be set to -1.')
mscVrIpRdb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4))
mscVrIpRdbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1), )
if mibBuilder.loadTexts: mscVrIpRdbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpRdb components.')
mscVrIpRdbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbProtocolIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbGatewayIndex"))
if mibBuilder.loadTexts: mscVrIpRdbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRdb component.')
mscVrIpRdbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRdbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRdb components. These components cannot be added nor deleted.')
mscVrIpRdbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRdbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRdbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRdbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbStorageType.setDescription('This variable represents the storage type value for the mscVrIpRdb tables.')
mscVrIpRdbDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpRdbDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbDestAddressIndex.setDescription('This variable represents an index for the mscVrIpRdb tables.')
mscVrIpRdbDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: mscVrIpRdbDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbDestMaskIndex.setDescription('This variable represents an index for the mscVrIpRdb tables.')
mscVrIpRdbProtocolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("bogus", 1), ("local", 2), ("remote", 3), ("special", 4), ("ospf", 5), ("ospfExternal", 6), ("ospfType3Discard", 7), ("ospfType7Discard", 8), ("rip", 9), ("ripDiscard", 10), ("egp", 11), ("bgpExternal", 12), ("bgpInternal", 13), ("bgpAggrDiscard", 14), ("redistrib", 15), ("mpls", 16))))
if mibBuilder.loadTexts: mscVrIpRdbProtocolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbProtocolIndex.setDescription('This variable represents an index for the mscVrIpRdb tables.')
mscVrIpRdbGatewayIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: mscVrIpRdbGatewayIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbGatewayIndex.setDescription('This variable represents an index for the mscVrIpRdb tables.')
mscVrIpRdbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 10), )
if mibBuilder.loadTexts: mscVrIpRdbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Identifies a group of operational attributes associated with each entry in the routing database.')
mscVrIpRdbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbProtocolIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRdbGatewayIndex"))
if mibBuilder.loadTexts: mscVrIpRdbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbOperEntry.setDescription('An entry in the mscVrIpRdbOperTable.')
mscVrIpRdbMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRdbMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbMetric.setDescription('This attribute specifies the primary routing metric for this route. The semantics of this metric are determined by the routing protocol specified by the value of the index to this entry protocol. If this metric is not used, its value should be set to -1.')
mscVrIpRdbPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRdbPreference.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbPreference.setDescription('This attribute specifies the the preference value of this particular entry. The value of this attribute affects the way the routeEntries in this database are selected for installing it in the forwardingTable. The lower the preference value of this entry, the higher are the chances that this entry will be selected to install in the ForwardTable.')
mscVrIpRdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 4, 10, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRdbAge.setDescription('This attribute specifies the number of seconds since this route was last updated or otherwise determined to be correct.')
mscVrIpIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5))
mscVrIpIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 1), )
if mibBuilder.loadTexts: mscVrIpIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpIf components.')
mscVrIpIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIfInterfaceAddressIndex"))
if mibBuilder.loadTexts: mscVrIpIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpIf component.')
mscVrIpIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpIf components. These components cannot be added nor deleted.')
mscVrIpIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfStorageType.setDescription('This variable represents the storage type value for the mscVrIpIf tables.')
mscVrIpIfInterfaceAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpIfInterfaceAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfInterfaceAddressIndex.setDescription('This variable represents the index for the mscVrIpIf tables.')
mscVrIpIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10), )
if mibBuilder.loadTexts: mscVrIpIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** Identifies a group of operational attributes associated with each entry in the Ip interface table.')
mscVrIpIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIfInterfaceAddressIndex"))
if mibBuilder.loadTexts: mscVrIpIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfOperEntry.setDescription('An entry in the mscVrIpIfOperTable.')
mscVrIpIfInterfaceMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfInterfaceMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfInterfaceMask.setDescription('This attribute indicates the mask for this interface entry.')
mscVrIpIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfStatus.setDescription('This attribute specifies the status of the provisioned Ip logicalInterface entry. A value of disabled is used when the parent components Vr, Ip or ipPort is in a disabled state. A value of up is used when the interface is in an operational state. A state of down is used if the media associated with this interface is not ready or disabled.')
mscVrIpIfPPName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 23))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfPPName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfPPName.setDescription('Indicates the name of the protocol port this logicalIfEntry belongs to.')
mscVrIpIfMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19))).clone(namedValues=NamedValues(("none", 1), ("tokenRing", 2), ("ethernet", 3), ("fddi", 4), ("x25", 5), ("frameRelay", 6), ("ppp", 7), ("clusterBridge", 8), ("virtualLink", 9), ("vcpEther", 10), ("vcpToken", 11), ("vns", 12), ("smds", 13), ("atmMpeVcEncap", 14), ("atmMpeLlcEncap", 15), ("lecEther", 16), ("lecToken", 17), ("tunnel", 18), ("virtual", 19)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfMediaType.setDescription('This attribute indicates the media type of interface. When the interface is down, a value of none indicates the media stays down from the beginning. When the interface is down, a value of some valid media type indicates the media is brought down after it was up. Otherwise, when the interface is up or disabled, this attribute should reflect the proper media type of the interface.')
mscVrIpIfHardwareAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 5), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfHardwareAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfHardwareAddress.setDescription('This attribute specifies the hardware address of the media in canonical form if applicable. The non-canonical version of this address is indicated in ncHardwareAddress.')
mscVrIpIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfMtu.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfMtu.setDescription('This attribute specifies the maximum transmission unit applicable for this logicalInterface. A value of 0 is used for the interfaces where all the necessary information is not available to compute the mtu applicable for this interface.')
mscVrIpIfBroadcastAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfBroadcastAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfBroadcastAddress.setDescription("This attribute indicates the destination IP address to be used by any application which needs to broadcast on this interface. The value is determined by the corresponding LogicalIf component's broadcastAddress attribute.")
mscVrIpIfNcHardwareAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 5, 10, 1, 8), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIfNcHardwareAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIfNcHardwareAddress.setDescription('This attribute is the non-canonical version of hardwareAddress. This attribute is not displayed for interfaces on non-LAN media.')
mscVrIpEgp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6))
mscVrIpEgpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 1), )
if mibBuilder.loadTexts: mscVrIpEgpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpEgp components.')
mscVrIpEgpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"))
if mibBuilder.loadTexts: mscVrIpEgpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpEgp component.')
mscVrIpEgpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpEgp components. These components can be added and deleted.')
mscVrIpEgpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpEgpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpStorageType.setDescription('This variable represents the storage type value for the mscVrIpEgp tables.')
mscVrIpEgpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpEgpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpIndex.setDescription('This variable represents the index for the mscVrIpEgp tables.')
mscVrIpEgpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 10), )
if mibBuilder.loadTexts: mscVrIpEgpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpProvTable.setDescription('This group contains the provisionable attributes for the EGP component')
mscVrIpEgpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"))
if mibBuilder.loadTexts: mscVrIpEgpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpProvEntry.setDescription('An entry in the mscVrIpEgpProvTable.')
mscVrIpEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpAsId.setDescription('The autonomous system identifier for this EGP entity. The value of this asId can not be equal to the value of EgpNeighborEntry asId.')
mscVrIpEgpDefaultHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 900)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpDefaultHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpDefaultHelloInterval.setDescription("This attribute is used to configure the default hello interval for each neighbor. This attribute's value is used by the application for each EgpNeighbor whose helloInterval has not been set.")
mscVrIpEgpDefaultPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(120, 3600)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpDefaultPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpDefaultPollInterval.setDescription("This attribute is used to configure the default polling interval for the EGP Neighbor. This attribute's value is used by the application for each EgpNeighbor whose pollInterval has not been set.")
mscVrIpEgpMaxNatNets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpMaxNatNets.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpMaxNatNets.setDescription('This attribute is used to configure the maximum number of external natural networks this virtual router will be advertising via EGP.')
mscVrIpEgpMaxBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 16)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpMaxBufferSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpMaxBufferSize.setDescription('This attribute specifies the maximum buffer size (in 1024 byte memory blocks) to be used for an EGP update to be sent.')
mscVrIpEgpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11), )
if mibBuilder.loadTexts: mscVrIpEgpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpStatsTable.setDescription('These set of attributes identifies the statistics for the EGP component.')
mscVrIpEgpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"))
if mibBuilder.loadTexts: mscVrIpEgpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpStatsEntry.setDescription('An entry in the mscVrIpEgpStatsTable.')
mscVrIpEgpInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpInMsgs.setDescription('Identifies the number of EGP messages received without error. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpInErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpInErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpInErrorMsgs.setDescription('Identifies the sum of EGP error messages from all the neighbors. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpOutErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpOutErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpOutErrorMsgs.setDescription('Indicates the sum of Egp error messages sent to all the neighbors. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpInErrors.setDescription('Identifies the number of EGP messages that proved to be in error. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpOutMsgs.setDescription('The total number of locally generated EGP messages. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpOutErrors.setDescription('The number of EGP messages that were locally generated but were not sent out due to resource limitations within an EGP entity.This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 12), )
if mibBuilder.loadTexts: mscVrIpEgpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpEgpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"))
if mibBuilder.loadTexts: mscVrIpEgpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpStateEntry.setDescription('An entry in the mscVrIpEgpStateTable.')
mscVrIpEgpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpEgpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpEgpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpEgpAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 13), )
if mibBuilder.loadTexts: mscVrIpEgpAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscVrIpEgpAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"))
if mibBuilder.loadTexts: mscVrIpEgpAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpAdminControlEntry.setDescription('An entry in the mscVrIpEgpAdminControlTable.')
mscVrIpEgpSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscVrIpEgpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 16), )
if mibBuilder.loadTexts: mscVrIpEgpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrIpEgpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"))
if mibBuilder.loadTexts: mscVrIpEgpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpOperStatusEntry.setDescription('An entry in the mscVrIpEgpOperStatusTable.')
mscVrIpEgpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 16, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrIpEgpNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2))
mscVrIpEgpNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 1), )
if mibBuilder.loadTexts: mscVrIpEgpNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpEgpNbr components.')
mscVrIpEgpNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpNbrNeighborAddressIndex"))
if mibBuilder.loadTexts: mscVrIpEgpNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpEgpNbr component.')
mscVrIpEgpNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpEgpNbr components. These components can be added and deleted.')
mscVrIpEgpNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpEgpNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrStorageType.setDescription('This variable represents the storage type value for the mscVrIpEgpNbr tables.')
mscVrIpEgpNbrNeighborAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpEgpNbrNeighborAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrNeighborAddressIndex.setDescription('This variable represents the index for the mscVrIpEgpNbr tables.')
mscVrIpEgpNbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10), )
if mibBuilder.loadTexts: mscVrIpEgpNbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrProvTable.setDescription('This group of attributes identify the provisionable attributes for this EGP neighbor.')
mscVrIpEgpNbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpNbrNeighborAddressIndex"))
if mibBuilder.loadTexts: mscVrIpEgpNbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrProvEntry.setDescription('An entry in the mscVrIpEgpNbrProvTable.')
mscVrIpEgpNbrAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrAsId.setDescription("The autonomous system identifier of this EGP peer. The value of this neighbor's asId should not be equal to the asId value of Egp entity")
mscVrIpEgpNbrMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2))).clone('active')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrMode.setDescription('This attribute will indicate whether this neighbor is being configured as an active or passive neighbor.')
mscVrIpEgpNbrGenerateDefaultRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrGenerateDefaultRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrGenerateDefaultRoute.setDescription('This attribute distinguishes whether or not the default route should be generated. This route is put in the EGP update along with the normal EGP update routes when updates are sent to this EGP neighbor')
mscVrIpEgpNbrDefaultRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrDefaultRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrDefaultRouteMetric.setDescription("This attribute identifies the Metric to be used for propagating the 'Default Route'. The value of defaultRouteMetric is used only in the case where the value of the attribute generateDefaultRoute is set to yes.")
mscVrIpEgpNbrDefaultMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrDefaultMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrDefaultMetric.setDescription('This attribute identifies the default metric value for routes that are exported to this EgpNeighbor. This value is used when exporting routes to this neighbor and no Export policy applies a different metric.')
mscVrIpEgpNbrHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 120)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrHelloInterval.setDescription('This attribute identifies the interval in seconds, between EGP hello command retransmissions. This is the P1 timer in the RFC904. This value may change in operation due to negotiations.')
mscVrIpEgpNbrPollInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(120, 480)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpNbrPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrPollInterval.setDescription('This attribute identifies the interval in seconds, between EGP poll command retransmissions. This is the P2 timer in the RFC904. This value may change in operation due to negotiations.')
mscVrIpEgpNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11), )
if mibBuilder.loadTexts: mscVrIpEgpNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrOperTable.setDescription('This group of attributes identifies the operational set of attributes for the NeighborEntry component.')
mscVrIpEgpNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpNbrNeighborAddressIndex"))
if mibBuilder.loadTexts: mscVrIpEgpNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrOperEntry.setDescription('An entry in the mscVrIpEgpNbrOperTable.')
mscVrIpEgpNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("idle", 1), ("acquisition", 2), ("down", 3), ("up", 4), ("cease", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrState.setDescription("This attribute describes the state of the local system with respect to this entry's EGP Neighbor.")
mscVrIpEgpNbrInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrInMsgs.setDescription('The number of EGP messages received without error from the EGP peer. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrInErrors.setDescription('The number of messages received from this EGP peer that proved to be in error. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrOutMsgs.setDescription('The number of locally generated EGP messages for this EGP peer. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrOutErrors.setDescription('The number of locally generated EGP messages not sent to this EGP peer due to resource limitations within an EGP entity.This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrInErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrInErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrInErrorMsgs.setDescription('The number of EGP-defined error messages received from this EGP peer.This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrOutErrorMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrOutErrorMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrOutErrorMsgs.setDescription('The number of EGP-defined error messages sent to this EGP peer.This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrStateUps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrStateUps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrStateUps.setDescription('The number of EGP state transitions to the UP state with this EGP peer. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrStateDowns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrStateDowns.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrStateDowns.setDescription('The number of EGP state transitions from the UP state to any other state with this EGP peer. This counter will wraparound once the value reaches the maximum value.')
mscVrIpEgpNbrEventTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 2, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("stop", 2))).clone('start')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpNbrEventTrigger.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpNbrEventTrigger.setDescription('This attribute is used to control the state of the Neighbor. It is not allowed to change. This attribute from SNMP perspective deviates from MIB that it is made READONLY.')
mscVrIpEgpImport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3))
mscVrIpEgpImportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 1), )
if mibBuilder.loadTexts: mscVrIpEgpImportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpEgpImport components.')
mscVrIpEgpImportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpImportIndex"))
if mibBuilder.loadTexts: mscVrIpEgpImportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpEgpImport component.')
mscVrIpEgpImportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpImportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpEgpImport components. These components can be added and deleted.')
mscVrIpEgpImportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpImportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpEgpImportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpImportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportStorageType.setDescription('This variable represents the storage type value for the mscVrIpEgpImport tables.')
mscVrIpEgpImportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpEgpImportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportIndex.setDescription('This variable represents the index for the mscVrIpEgpImport tables.')
mscVrIpEgpImportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 10), )
if mibBuilder.loadTexts: mscVrIpEgpImportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportProvTable.setDescription('These set of attributes describe the provisionable attributes for the import component.')
mscVrIpEgpImportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpImportIndex"))
if mibBuilder.loadTexts: mscVrIpEgpImportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportProvEntry.setDescription('An entry in the mscVrIpEgpImportProvTable.')
mscVrIpEgpImportUsageFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("use", 1), ("ignore", 2))).clone('use')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpImportUsageFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportUsageFlag.setDescription('This flag will determine whether or not EGP will use or ignore information in updates received. If the attribute nbrAsId is not specified or any of the NetworkList components are not added, then this attribute when set to ignore will ignore all incoming information.')
mscVrIpEgpImportImportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpImportImportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportImportMetric.setDescription("This attribute is used to set the metric value to be included in the routing table for any routes sent because this particular import instance was it's 'best match' policy. However this attribute is not a selection key. It should not use or ignore a particular metric value. If the value for this attribute is not specified, then the metric value received in an Egp update will be used. Note: When setting this value, caution should be taken to set the metric value in all relevant Import components to make sure that all matching policies for a given route have the same metric set. This will insure that there are no situations where a specific metric was desired, but doesn't get used in the update because the 'best match' policy for that situation did not set the metric parameter. If the attribute usageFlag for this import policy is set to ignore, then the importMetric value will be ignored by the application. The importMetric value is not used to select which routes to use or ignore but is used to set the metric value for the routes being imported. A value of zero indicates that the metric received in the update will be used.")
mscVrIpEgpImportNbrAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpImportNbrAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNbrAsId.setDescription("The autonomous system Id this import policy will apply to. Note: The Valid value of an asId is from 1 to 65,535. This attribute's value when set to 0 will be ignored.")
mscVrIpEgpImportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2))
mscVrIpEgpImportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 1), )
if mibBuilder.loadTexts: mscVrIpEgpImportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpEgpImportNet components.')
mscVrIpEgpImportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpImportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpImportNetIndex"))
if mibBuilder.loadTexts: mscVrIpEgpImportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpEgpImportNet component.')
mscVrIpEgpImportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpImportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpEgpImportNet components. These components can be added and deleted.')
mscVrIpEgpImportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpImportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpEgpImportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpImportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetStorageType.setDescription('This variable represents the storage type value for the mscVrIpEgpImportNet tables.')
mscVrIpEgpImportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpEgpImportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetIndex.setDescription('This variable represents the index for the mscVrIpEgpImportNet tables.')
mscVrIpEgpImportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 10), )
if mibBuilder.loadTexts: mscVrIpEgpImportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetProvTable.setDescription('This group identifies attributes for the NetworkList component for which the import policy will be applied to')
mscVrIpEgpImportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpImportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpImportNetIndex"))
if mibBuilder.loadTexts: mscVrIpEgpImportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetProvEntry.setDescription('An entry in the mscVrIpEgpImportNetProvTable.')
mscVrIpEgpImportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 3, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpImportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpImportNetIpAddress.setDescription('This attribute identifies the IP address that needs to be matched against in this network list for the Import policy to be applied to.')
mscVrIpEgpExport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4))
mscVrIpEgpExportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 1), )
if mibBuilder.loadTexts: mscVrIpEgpExportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpEgpExport components.')
mscVrIpEgpExportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpExportIndex"))
if mibBuilder.loadTexts: mscVrIpEgpExportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpEgpExport component.')
mscVrIpEgpExportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpEgpExport components. These components can be added and deleted.')
mscVrIpEgpExportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpExportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpEgpExportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpExportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportStorageType.setDescription('This variable represents the storage type value for the mscVrIpEgpExport tables.')
mscVrIpEgpExportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpEgpExportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportIndex.setDescription('This variable represents the index for the mscVrIpEgpExport tables.')
mscVrIpEgpExportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10), )
if mibBuilder.loadTexts: mscVrIpEgpExportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportProvTable.setDescription('This group contains all the provisioned attributes for the Export component.')
mscVrIpEgpExportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpExportIndex"))
if mibBuilder.loadTexts: mscVrIpEgpExportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportProvEntry.setDescription('An entry in the mscVrIpEgpExportProvTable.')
mscVrIpEgpExportAdvertiseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("block", 2))).clone('send')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportAdvertiseStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportAdvertiseStatus.setDescription('This attribute specifies if the routes that match this export policy are advertised (send) or not advertised (block).')
mscVrIpEgpExportExportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportExportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportExportMetric.setDescription('This attribute specifies the metric to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of exportMetric is ignored. The exportMetric value is not used to select which routes to block or send, but rather the metric value advertised for the routes. A value of 0 indicates that the metric associated with the route in the forwarding table is used.')
mscVrIpEgpExportProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("all", 1), ("egp", 2), ("rip", 3), ("ospfInternal", 4), ("ospfExternal", 5), ("staticLocal", 6), ("staticRemote", 7))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportProtocol.setDescription('This attribute specifies the routes to which this export policy applies based on the routing protocol of how the routes are learned. If it is set to all, this export policy applies to all routes in the forwarding table.')
mscVrIpEgpExportRipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportRipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportRipInterface.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP interface from which the routes are learned. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP interface on the same virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
mscVrIpEgpExportRipNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportRipNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportRipNeighbor.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP neighbor of which the routes are learned from. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP neighbor.')
mscVrIpEgpExportInEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportInEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportInEgpAsId.setDescription('This attribute specifies the EGP learned routes to which this export policy applies, based on the EGP autonomous system identifier of which the routes are learned from. This attribute can only be non zero when protocol is set to egp. The value of 0 implies any EGP autonomous system; otherwise the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
mscVrIpEgpExportOspfTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportOspfTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportOspfTag.setDescription('This attribute specifies the OSPF learned external routes to which this export policy applies, based on the learned OSPF tag of the routes. This attribute can only be set to a non default value when protocol is set to ospfExternal. The value of 4294967295 implies any tag.')
mscVrIpEgpExportOutAutonomousSystem = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportOutAutonomousSystem.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportOutAutonomousSystem.setDescription('This attribute specifies the EGP autonomous system to which routes are exported to as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of outAutonomousSystem is ignored. The outAutonomousSystem value is not used to select which routes to block or send but where to export the routes. A value of 0 indicates that the routes are exported to all EGP autonomous systems of which the virtual router is a neighbor. Otherwise, the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
mscVrIpEgpExportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2))
mscVrIpEgpExportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 1), )
if mibBuilder.loadTexts: mscVrIpEgpExportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpEgpExportNet components.')
mscVrIpEgpExportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpExportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpExportNetIndex"))
if mibBuilder.loadTexts: mscVrIpEgpExportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpEgpExportNet component.')
mscVrIpEgpExportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpEgpExportNet components. These components can be added and deleted.')
mscVrIpEgpExportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpExportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpEgpExportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpEgpExportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetStorageType.setDescription('This variable represents the storage type value for the mscVrIpEgpExportNet tables.')
mscVrIpEgpExportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpEgpExportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetIndex.setDescription('This variable represents the index for the mscVrIpEgpExportNet tables.')
mscVrIpEgpExportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 10), )
if mibBuilder.loadTexts: mscVrIpEgpExportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetProvTable.setDescription('This group identifies the set of provisionable attributes for the ExportNetworkList component.')
mscVrIpEgpExportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpExportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpEgpExportNetIndex"))
if mibBuilder.loadTexts: mscVrIpEgpExportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetProvEntry.setDescription('An entry in the mscVrIpEgpExportNetProvTable.')
mscVrIpEgpExportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 6, 4, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpEgpExportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpEgpExportNetIpAddress.setDescription('This attribute identifies the 32 bit IP address to match against.')
mscVrIpOspf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7))
mscVrIpOspfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 1), )
if mibBuilder.loadTexts: mscVrIpOspfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspf components.')
mscVrIpOspfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"))
if mibBuilder.loadTexts: mscVrIpOspfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspf component.')
mscVrIpOspfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspf components. These components can be added and deleted.')
mscVrIpOspfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspf tables.')
mscVrIpOspfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpOspfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfIndex.setDescription('This variable represents the index for the mscVrIpOspf tables.')
mscVrIpOspfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100), )
if mibBuilder.loadTexts: mscVrIpOspfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfProvTable.setDescription('This group of attributes are used to configure the OSPF component.')
mscVrIpOspfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"))
if mibBuilder.loadTexts: mscVrIpOspfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfProvEntry.setDescription('An entry in the mscVrIpOspfProvTable.')
mscVrIpOspfRouterId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 1), RouterID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfRouterId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfRouterId.setDescription('This attribute is an Ip Address that uniquely identifies the router in the autonomous system.')
mscVrIpOspfSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfSnmpAdminStatus.setDescription('The administrative status of the OSPF Component in this Virtual Router.')
mscVrIpOspfAsBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfAsBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAsBdrRtrStatus.setDescription('This attribute is a flag to note whether this router is an autonomous system border router. If this router is configured to export any routes learned from other than OSPF-internal protocol, this attribute should be configured as autonomous system border router.')
mscVrIpOspfTosSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2))).clone(namedValues=NamedValues(("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfTosSupport.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfTosSupport.setDescription("The router's support for type-of-service routing. Only one value will be allowed. This is a deviation from supporting the MIB.")
mscVrIpOspfExtLsdbLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 2147483647)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbLimit.setDescription("The maximum number of external link-state entries that can be stored in the link-state database. If the value is -1, then there is no limit, that is the maximum number of external OSPF routes that this autonomous system border router will originate. It will begin to flush LSA(Link State Advertisement)s, if an ASBR might receive bursts of external routes (for example, a regional network), then the parameter should be configured to a reasonable level. If there are less than two thousand routes and large bursts are unlikely, then the default should be adequate. This parameter will not affect the number of external OSPF routes a router will store in it's database.")
mscVrIpOspfMulticastForward = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 0))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfMulticastForward.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfMulticastForward.setDescription('A bit mask indicating the limits on Network Layer Multicast(class D) forwarding. It is represented as a sum of the following: if intra-Area forwarding is permitted, 1; else 0 if inter-Area forwarding is permitted 2; else 0 if inter-AS forwarding is permitted, 4; else 0 Only the value of 0 is being supported and this is a MIB deviation.')
mscVrIpOspfMigrateRip = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfMigrateRip.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfMigrateRip.setDescription('This Attribute sets the preference level of OSPF-internal routes to be less preferred than RIP. This Parameter should only be used when starting migration of network from RIP to OSPF. When ready to cutover to OSPF, set this attribute disabled and run under normal preferences. All OSPF routers in the Autonomous System should be running with migraterip enabled or with migraterip disabled to prevent routing loops. It is important that the changeover period from RIP to OSPF be performed quickly on all OSPF routers so that no routing loops are formed. These routing loops could be caused by conflicts in the internal RIP and OSPF databases.')
mscVrIpOspfGenerateDefaultRouteMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfGenerateDefaultRouteMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfGenerateDefaultRouteMetric.setDescription('If this router is configured as an autonomous system border router, then this attribute causes the default route to be generated with a metric value equal to generateDefaultRouteMetric value. This route is put in the OSPF update along with the normal update routes when updates are sent to the neighbors. No default route will be generated if the value is 0.')
mscVrIpOspfRedistributeIbgp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 100, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfRedistributeIbgp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfRedistributeIbgp.setDescription('This attribute specifies whether this Ospf instance allows to exporting of any routes learned from internal Bgp peers (IBGP) to Ospf. If the value of this attribute is true, and if an export policy is specified to distribute, then Ospf allows any IBGP routes to be distributed to Ospf. If the value of this attribute is false, Ospf does not allow IBGP routes to be distributed to Ospf, even if an export policy is specified to distribute.')
mscVrIpOspfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101), )
if mibBuilder.loadTexts: mscVrIpOspfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfOperTable.setDescription('These group of attributes identifies the operational attributes for this OSPF Component.')
mscVrIpOspfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"))
if mibBuilder.loadTexts: mscVrIpOspfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfOperEntry.setDescription('An entry in the mscVrIpOspfOperTable.')
mscVrIpOspfVersionNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 2)).clone(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVersionNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVersionNumber.setDescription('The Current Version number of the OSPF Protocol. (2).')
mscVrIpOspfAreaBdrRtrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaBdrRtrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaBdrRtrStatus.setDescription('This attribute is used to specify whether this router is configured as an area border router.')
mscVrIpOspfExternLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExternLsaCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExternLsaCount.setDescription('The number of external (LS type 5) link-state advertisements in the link- state database.')
mscVrIpOspfExternLsaChecksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExternLsaChecksumSum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExternLsaChecksumSum.setDescription("The 32-bit unsigned sum of the LS checksums of the external link-state database. This sum can be used to determine if there has been a change in a router's link state database, and to compare the link-state database of two routers.")
mscVrIpOspfOriginateNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfOriginateNewLsas.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfOriginateNewLsas.setDescription('The number of new link-state advertisements that have been originated. This number is incremented each time the router originates a new LSA.')
mscVrIpOspfRxNewLsas = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 101, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfRxNewLsas.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfRxNewLsas.setDescription('The number of link-state advertisements received determined to be new instantiations. This number does not include newer instantiations of self- originated link-state advertisements.')
mscVrIpOspfStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 102), )
if mibBuilder.loadTexts: mscVrIpOspfStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpOspfStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 102, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"))
if mibBuilder.loadTexts: mscVrIpOspfStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStateEntry.setDescription('An entry in the mscVrIpOspfStateTable.')
mscVrIpOspfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 102, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpOspfOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 102, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpOspfUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 102, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpOspfOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 105), )
if mibBuilder.loadTexts: mscVrIpOspfOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrIpOspfOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 105, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"))
if mibBuilder.loadTexts: mscVrIpOspfOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfOperStatusEntry.setDescription('An entry in the mscVrIpOspfOperStatusTable.')
mscVrIpOspfSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 105, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrIpOspfArea = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2))
mscVrIpOspfAreaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 1), )
if mibBuilder.loadTexts: mscVrIpOspfAreaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspfArea components.')
mscVrIpOspfAreaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAreaAreaIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfAreaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfArea component.')
mscVrIpOspfAreaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfAreaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfArea components. These components can be added and deleted.')
mscVrIpOspfAreaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfAreaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfArea tables.')
mscVrIpOspfAreaAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaIdIndex.setDescription('This variable represents the index for the mscVrIpOspfArea tables.')
mscVrIpOspfAreaProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 10), )
if mibBuilder.loadTexts: mscVrIpOspfAreaProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaProvTable.setDescription('This group describes the set of provisionable attributes for the AreaEntry Component.')
mscVrIpOspfAreaProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAreaAreaIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfAreaProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaProvEntry.setDescription('An entry in the mscVrIpOspfAreaProvTable.')
mscVrIpOspfAreaAuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("none", 0), ("simplePassword", 1))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfAreaAuthType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaAuthType.setDescription('The authentication type specified for this area.')
mscVrIpOspfAreaImportAsExtern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("importExternal", 1), ("importNoExternal", 2), ("importNssa", 3))).clone('importExternal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfAreaImportAsExtern.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaImportAsExtern.setDescription("The area's support for importing AS external link-state advertisements. For backbone area (that is, areaId 0.0.0.0), this attribute must be set to importExternal.")
mscVrIpOspfAreaAreaSummary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noAreaSummary", 1), ("sendAreaSummary", 2))).clone('noAreaSummary')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaSummary.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaSummary.setDescription('This variable controls the import of summary LSAs into stub areas. If it is noAreaSummary, the router will neither originate nor propagate summary LSAs into the stub areas. It will rely entirely on its default route. If it is sendAreaSummary, the router will both summarize and propagate summary LSAs.')
mscVrIpOspfAreaOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 11), )
if mibBuilder.loadTexts: mscVrIpOspfAreaOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaOperTable.setDescription('This group of attributes describes the Operational set of attributes for the AreaEntry component.')
mscVrIpOspfAreaOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAreaAreaIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfAreaOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaOperEntry.setDescription('An entry in the mscVrIpOspfAreaOperTable.')
mscVrIpOspfAreaSpfRuns = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaSpfRuns.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaSpfRuns.setDescription("The number of times that the intra-area route table has been calculated using this area's link-state database since the protocol became operational.")
mscVrIpOspfAreaAreaBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 11, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaBdrRtrCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaBdrRtrCount.setDescription('The total number of area border routers reachable within this area. This is initially zero, and is calculated in each Shortest Path First Pass.')
mscVrIpOspfAreaAsBdrRtrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 11, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaAsBdrRtrCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaAsBdrRtrCount.setDescription('The total number of Autonomous System border routers reachable within this area. This is initially zero, and is calculated in each Shortest Path First Pass.')
mscVrIpOspfAreaLsaCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 11, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaLsaCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaLsaCount.setDescription("The total number of link-state advertisements in this area's link-state database, excluding AS External LSA's.")
mscVrIpOspfAreaAreaLsaCksumSum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 2, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaLsaCksumSum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAreaAreaLsaCksumSum.setDescription("The 32-bit unsigned sum of the link-state advertisement's LS checksums contained in this area's link-state database. This sum excludes external (LS type 5) link-state advertisements. The sum can be used to determine if there has been a change in a router's link state database, and to compare the link-state database of two routers.")
mscVrIpOspfStub = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3))
mscVrIpOspfStubRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 1), )
if mibBuilder.loadTexts: mscVrIpOspfStubRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspfStub components.')
mscVrIpOspfStubRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfStubAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfStubTosIndex"))
if mibBuilder.loadTexts: mscVrIpOspfStubRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfStub component.')
mscVrIpOspfStubRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfStubRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfStub components. These components can be added and deleted.')
mscVrIpOspfStubComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfStubComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfStubStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfStubStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfStub tables.')
mscVrIpOspfStubAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfStubAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubAreaIdIndex.setDescription('This variable represents an index for the mscVrIpOspfStub tables.')
mscVrIpOspfStubTosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscVrIpOspfStubTosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubTosIndex.setDescription('This variable represents an index for the mscVrIpOspfStub tables.')
mscVrIpOspfStubProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 10), )
if mibBuilder.loadTexts: mscVrIpOspfStubProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubProvTable.setDescription('These set of attributes explain the provisionable group for the StubAreaEntry.')
mscVrIpOspfStubProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfStubAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfStubTosIndex"))
if mibBuilder.loadTexts: mscVrIpOspfStubProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubProvEntry.setDescription('An entry in the mscVrIpOspfStubProvTable.')
mscVrIpOspfStubMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfStubMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubMetric.setDescription('The metric value applied at the indicated type of service.')
mscVrIpOspfStubMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ospfMetric", 1), ("comparableCost", 2), ("nonComparable", 3))).clone('ospfMetric')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfStubMetricType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubMetricType.setDescription('This type of the metric advertised as a default route.')
mscVrIpOspfStubAdvertiseDefault = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfStubAdvertiseDefault.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfStubAdvertiseDefault.setDescription('This attribute determines whether or not the default routing information will be advertised, depending on other criterion. Setting this value to no can prevent advertising default routing information. If the value of the attribute is set to yes, then the value of the attribute importAsExtern for that particular AreaEntry should be set to importNssa.')
mscVrIpOspfAggregate = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5))
mscVrIpOspfAggregateRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1), )
if mibBuilder.loadTexts: mscVrIpOspfAggregateRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspfAggregate components.')
mscVrIpOspfAggregateRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateLsdbTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateAggregateNetIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateAggregateMaskIndex"))
if mibBuilder.loadTexts: mscVrIpOspfAggregateRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfAggregate component.')
mscVrIpOspfAggregateRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfAggregateRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfAggregate components. These components can be added and deleted.')
mscVrIpOspfAggregateComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAggregateComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfAggregateStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfAggregateStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfAggregate tables.')
mscVrIpOspfAggregateAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfAggregateAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateAreaIdIndex.setDescription('This variable represents an index for the mscVrIpOspfAggregate tables.')
mscVrIpOspfAggregateLsdbTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 7))).clone(namedValues=NamedValues(("summaryLink", 3), ("nssaExternalLink", 7))))
if mibBuilder.loadTexts: mscVrIpOspfAggregateLsdbTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateLsdbTypeIndex.setDescription('This variable represents an index for the mscVrIpOspfAggregate tables.')
mscVrIpOspfAggregateAggregateNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfAggregateAggregateNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateAggregateNetIndex.setDescription('This variable represents an index for the mscVrIpOspfAggregate tables.')
mscVrIpOspfAggregateAggregateMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfAggregateAggregateMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateAggregateMaskIndex.setDescription('This variable represents an index for the mscVrIpOspfAggregate tables.')
mscVrIpOspfAggregateProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 10), )
if mibBuilder.loadTexts: mscVrIpOspfAggregateProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateProvTable.setDescription('Identifies a group of provisionable attributes.')
mscVrIpOspfAggregateProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateLsdbTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateAggregateNetIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfAggregateAggregateMaskIndex"))
if mibBuilder.loadTexts: mscVrIpOspfAggregateProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateProvEntry.setDescription('An entry in the mscVrIpOspfAggregateProvTable.')
mscVrIpOspfAggregateEffect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("advertiseMatching", 1), ("doNotAdvertiseMatching", 2), ("invalid", 3))).clone('advertiseMatching')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfAggregateEffect.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfAggregateEffect.setDescription('This attribute determines whether or not the routing information will be advertised, depending on other criterion. Setting this value to doNotAdvertiseMatching can prevent advertising routing information for the address and mask values specified as the indices for this entry.')
mscVrIpOspfHost = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6))
mscVrIpOspfHostRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 1), )
if mibBuilder.loadTexts: mscVrIpOspfHostRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspfHost components.')
mscVrIpOspfHostRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfHostAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfHostTosIndex"))
if mibBuilder.loadTexts: mscVrIpOspfHostRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfHost component.')
mscVrIpOspfHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfHostRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfHost components. These components can be added and deleted.')
mscVrIpOspfHostComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfHostComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfHostStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfHostStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfHost tables.')
mscVrIpOspfHostAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfHostAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostAddressIndex.setDescription('This variable represents an index for the mscVrIpOspfHost tables.')
mscVrIpOspfHostTosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscVrIpOspfHostTosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostTosIndex.setDescription('This variable represents an index for the mscVrIpOspfHost tables.')
mscVrIpOspfHostProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 10), )
if mibBuilder.loadTexts: mscVrIpOspfHostProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostProvTable.setDescription('Provisionable set of attributes for the Host entry.')
mscVrIpOspfHostProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfHostAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfHostTosIndex"))
if mibBuilder.loadTexts: mscVrIpOspfHostProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostProvEntry.setDescription('An entry in the mscVrIpOspfHostProvTable.')
mscVrIpOspfHostAreaId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 10, 1, 1), AreaID()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfHostAreaId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostAreaId.setDescription('This is an Ip address for the Host Entry that indicates the area it belongs to.')
mscVrIpOspfHostMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 6, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfHostMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfHostMetric.setDescription('The metric to be advertised.')
mscVrIpOspfVirtIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7))
mscVrIpOspfVirtIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 1), )
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspfVirtIf components.')
mscVrIpOspfVirtIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtIfAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtIfNbrRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfVirtIf component.')
mscVrIpOspfVirtIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfVirtIf components. These components can be added and deleted.')
mscVrIpOspfVirtIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfVirtIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfVirtIf tables.')
mscVrIpOspfVirtIfAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfVirtIfAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfAreaIdIndex.setDescription('This variable represents an index for the mscVrIpOspfVirtIf tables.')
mscVrIpOspfVirtIfNbrRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfVirtIfNbrRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfNbrRouterIdIndex.setDescription('This variable represents an index for the mscVrIpOspfVirtIf tables.')
mscVrIpOspfVirtIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 10), )
if mibBuilder.loadTexts: mscVrIpOspfVirtIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfProvTable.setDescription('This group of attributes provide provisioning data for the VirtIfEntry.')
mscVrIpOspfVirtIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtIfAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtIfNbrRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfVirtIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfProvEntry.setDescription('An entry in the mscVrIpOspfVirtIfProvTable.')
mscVrIpOspfVirtIfTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfTransitDelay.setDescription('The estimated number of seconds it takes to transmit a link-state update packet over this interface.')
mscVrIpOspfVirtIfRetransInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRetransInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRetransInterval.setDescription('The number of seconds between link-state advertisement retransmissions, for adjacencies belonging to this interface. This value is also used when retransmitting database description and link-state request packets. This value would be well over the expected round-trip time.')
mscVrIpOspfVirtIfHelloInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfHelloInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfHelloInterval.setDescription('The length of time, in seconds, between the Hello packets that the router sends on the interface. This value must be the same for the virtual neighbor.')
mscVrIpOspfVirtIfRtrDeadInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRtrDeadInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfRtrDeadInterval.setDescription("The number of seconds that a router's Hello packets have not been seen before its neighbors declare the router down. This should be some multiple of the Hello interval. This value must be the same for the virtual neighbor.")
mscVrIpOspfVirtIfAuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 10, 1, 5), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 8)).clone(hexValue="0000000000000000")).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfAuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfAuthKey.setDescription('If authentication type is simple password, the password for this virtual circuit. If the value of the attribute is not set, then this attribute is ignored by the application. If the value of this attribute is set, then the value of the attribute authType under this particular Area should be set to simplePassword, otherwise the application will ignore this authentication key.')
mscVrIpOspfVirtIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 11), )
if mibBuilder.loadTexts: mscVrIpOspfVirtIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfOperTable.setDescription('Represents a group of operational attributes for the VirtIfEntry component.')
mscVrIpOspfVirtIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtIfAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtIfNbrRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfVirtIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfOperEntry.setDescription('An entry in the mscVrIpOspfVirtIfOperTable.')
mscVrIpOspfVirtIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("down", 1), ("pointToPoint", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfState.setDescription('The state of the OSPF virtual interface.')
mscVrIpOspfVirtIfEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 7, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtIfEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtIfEvents.setDescription('The number of state changes or error events on the virtual link.')
mscVrIpOspfExport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8))
mscVrIpOspfExportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 1), )
if mibBuilder.loadTexts: mscVrIpOspfExportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspfExport components.')
mscVrIpOspfExportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExportIndex"))
if mibBuilder.loadTexts: mscVrIpOspfExportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfExport component.')
mscVrIpOspfExportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfExport components. These components can be added and deleted.')
mscVrIpOspfExportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfExportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfExport tables.')
mscVrIpOspfExportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpOspfExportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportIndex.setDescription('This variable represents the index for the mscVrIpOspfExport tables.')
mscVrIpOspfExportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10), )
if mibBuilder.loadTexts: mscVrIpOspfExportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportProvTable.setDescription('This Group contains all the Provisioned attributes for the Export Component.')
mscVrIpOspfExportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExportIndex"))
if mibBuilder.loadTexts: mscVrIpOspfExportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportProvEntry.setDescription('An entry in the mscVrIpOspfExportProvTable.')
mscVrIpOspfExportAdvertiseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("block", 2))).clone('send')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportAdvertiseStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportAdvertiseStatus.setDescription('This attribute specifies if the routes that match this export policy are advertised (send) or not advertised (block).')
mscVrIpOspfExportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 16777215)).clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportMetric.setDescription('This attribute specifies the metric to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of metric is ignored. The metric value is not used to select which routes to block or send, but rather the metric value advertised for the routes. A value of -1 indicates that the metric associated with the route in the forwarding table is used.')
mscVrIpOspfExportProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 6, 7, 8, 9))).clone(namedValues=NamedValues(("all", 1), ("egp", 2), ("rip", 3), ("staticLocal", 6), ("staticRemote", 7), ("bgpInternal", 8), ("bgpExternal", 9))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportProtocol.setDescription('This attribute specifies the routes to which this export policy applies based on the routing protocol of how the routes are learned. If it is set to all, this export policy applies to all routes in the forwarding table except internal BGP routes.')
mscVrIpOspfExportRipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportRipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportRipInterface.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP interface from which the routes are learned. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP interface on the same virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
mscVrIpOspfExportRipNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportRipNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportRipNeighbor.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP neighbor of which the routes are learned from. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP neighbor.')
mscVrIpOspfExportEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportEgpAsId.setDescription('This attribute specifies the EGP learned routes to which this export policy applies, based on the EGP autonomous system identifier of which the routes are learned from. This attribute can only be non zero when protocol is set to egp. The value of 0 implies any EGP autonomous system; otherwise the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
mscVrIpOspfExportTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportTag.setDescription('This attribute specifies the OSPF tag to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of tag is ignored. The tag value is not used to select which routes to block or send, but rather the tag value advertised for the routes. A value of 4294967295 indicates that the tag associated with the route in the forwarding table is used.')
mscVrIpOspfExportExtLsaMetricType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("useProtocolDefault", 0), ("type1", 1), ("type2", 2))).clone('useProtocolDefault')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportExtLsaMetricType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportExtLsaMetricType.setDescription('This attribute specifies the metric type in the OSPF external link state advertisement of the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of extLsaMetricType is ignored. The extLsaMetricType value is not used to select which routes to block or send, but rather the metric value advertised for the routes. The value useProtocolDefault indicates the metric type is automatically chosen based on the routing protocol which the route was learned from.')
mscVrIpOspfExportBgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportBgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportBgpAsId.setDescription('This key attribute specifies the bgp AS from which a bgp route is learned from. This key is used only if the protocol is bgpExternal. bgpAsId of value 0 mathces all ASs.')
mscVrIpOspfExportBgpPeerIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 10, 1, 10), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportBgpPeerIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportBgpPeerIp.setDescription('This key attribute specifies the bgp peer where the routes were learned from. bgpPeerIp of 0 matches all bgp peers. This attribute is used as a key when protocol is set to bgpInternal or bgpExternal.')
mscVrIpOspfExportNetList = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2))
mscVrIpOspfExportNetListRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 1), )
if mibBuilder.loadTexts: mscVrIpOspfExportNetListRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpOspfExportNetList components.')
mscVrIpOspfExportNetListRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExportNetListIndex"))
if mibBuilder.loadTexts: mscVrIpOspfExportNetListRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfExportNetList component.')
mscVrIpOspfExportNetListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportNetListRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfExportNetList components. These components can be added and deleted.')
mscVrIpOspfExportNetListComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExportNetListComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfExportNetListStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExportNetListStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfExportNetList tables.')
mscVrIpOspfExportNetListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpOspfExportNetListIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListIndex.setDescription('This variable represents the index for the mscVrIpOspfExportNetList tables.')
mscVrIpOspfExportNetListProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 10), )
if mibBuilder.loadTexts: mscVrIpOspfExportNetListProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListProvTable.setDescription('This group identifies the set of provisionable attributes for the ExportNetworkList component.')
mscVrIpOspfExportNetListProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExportNetListIndex"))
if mibBuilder.loadTexts: mscVrIpOspfExportNetListProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListProvEntry.setDescription('An entry in the mscVrIpOspfExportNetListProvTable.')
mscVrIpOspfExportNetListIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportNetListIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListIpAddress.setDescription('This attribute identifies the 32 bit IP address to match against.')
mscVrIpOspfExportNetListIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 8, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpOspfExportNetListIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExportNetListIpMask.setDescription('This attribute is the IP Mask to be used with the IP Address to match against.')
mscVrIpOspfVirtNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9))
mscVrIpOspfVirtNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 1), )
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpOspfVirtNbr components.')
mscVrIpOspfVirtNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtNbrAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtNbrNbrRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfVirtNbr component.')
mscVrIpOspfVirtNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfVirtNbr components. These components cannot be added nor deleted.')
mscVrIpOspfVirtNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfVirtNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfVirtNbr tables.')
mscVrIpOspfVirtNbrAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrAreaIdIndex.setDescription('This variable represents an index for the mscVrIpOspfVirtNbr tables.')
mscVrIpOspfVirtNbrNbrRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrNbrRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrNbrRouterIdIndex.setDescription('This variable represents an index for the mscVrIpOspfVirtNbr tables.')
mscVrIpOspfVirtNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10), )
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group identifies a set of operational attributes.')
mscVrIpOspfVirtNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtNbrAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfVirtNbrNbrRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrOperEntry.setDescription('An entry in the mscVrIpOspfVirtNbrOperTable.')
mscVrIpOspfVirtNbrNbrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrNbrIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrNbrIpAddress.setDescription('Indicates the Ip address this interface this virtual neighbor is using.')
mscVrIpOspfVirtNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrOptions.setDescription("A bit mask corresponding to the neighbor's options field. Bit 1, if set indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric. Bit 2, if set, indicates that the system is Network Multicast capable; i.e., that it implements OSPF Multicast Routing.")
mscVrIpOspfVirtNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchange", 5), ("exchangeStatrt", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrState.setDescription('The state of the virtual neighbor relationship.')
mscVrIpOspfVirtNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrEvents.setDescription('The number of times this virtual link has changed its state, or an error has occurred.')
mscVrIpOspfVirtNbrLsRetransQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10, 1, 5), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrLsRetransQlen.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrLsRetransQlen.setDescription('The current length of the Retransmission queue.')
mscVrIpOspfVirtNbrExchangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 9, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrExchangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfVirtNbrExchangeStatus.setDescription('Indicates the exchange status of the entry in this table.')
mscVrIpOspfNbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10))
mscVrIpOspfNbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 1), )
if mibBuilder.loadTexts: mscVrIpOspfNbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpOspfNbr components.')
mscVrIpOspfNbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfNbrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfNbrAddressLessIndex"))
if mibBuilder.loadTexts: mscVrIpOspfNbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfNbr component.')
mscVrIpOspfNbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfNbr components. These components cannot be added nor deleted.')
mscVrIpOspfNbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfNbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfNbr tables.')
mscVrIpOspfNbrAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfNbrAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrAddressIndex.setDescription('This variable represents an index for the mscVrIpOspfNbr tables.')
mscVrIpOspfNbrAddressLessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscVrIpOspfNbrAddressLessIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrAddressLessIndex.setDescription('This variable represents an index for the mscVrIpOspfNbr tables.')
mscVrIpOspfNbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10), )
if mibBuilder.loadTexts: mscVrIpOspfNbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group identifies the operational set of attributes for the NeighborEntry.')
mscVrIpOspfNbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfNbrAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfNbrAddressLessIndex"))
if mibBuilder.loadTexts: mscVrIpOspfNbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrOperEntry.setDescription('An entry in the mscVrIpOspfNbrOperTable.')
mscVrIpOspfNbrRtrId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrRtrId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrRtrId.setDescription('An Ip Address that uniquely identifies the neighboring router in the autonomous system.')
mscVrIpOspfNbrOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrOptions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrOptions.setDescription("A bit mask corresponding to the neighbor's options field. Bit 0, if set, indicates that the area accepts and operates on external information, if zero, it is a stub area. Bit 1, if set, indicates that the system will operate on Type of Service metrics other than TOS 0. If zero, the neighbor will ignore all metrics except the TOS 0 metric. Bit 2, if set, indicates that the system is Network Multicast capable; i.e., that it implements OSPF Multicast Routing.")
mscVrIpOspfNbrPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrPriority.setDescription('The priority of this neighbor in the designated router election algorithm. The value 0 signifies that the neighbor is not eligible to become the designated router on this particular network.')
mscVrIpOspfNbrState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("down", 1), ("attempt", 2), ("init", 3), ("twoWay", 4), ("exchangeStart", 5), ("exchange", 6), ("loading", 7), ("full", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrState.setDescription('The state of the relationship with this neighbor.')
mscVrIpOspfNbrEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrEvents.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrEvents.setDescription('The number of times this neighbor relationship has changed state, or an error has occurred.')
mscVrIpOspfNbrLsRetransQlen = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 6), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrLsRetransQlen.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrLsRetransQlen.setDescription('The current length of the Retransmission queue.')
mscVrIpOspfNbrNbmaNbrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrNbmaNbrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrNbmaNbrStatus.setDescription('This attribute describes the status of the entry.')
mscVrIpOspfNbrExchangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrExchangeStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrExchangeStatus.setDescription('Indicates the exchange status for a neighbor entry.')
mscVrIpOspfNbrPermanence = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 10, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dynamic", 1), ("permanent", 2))).clone('dynamic')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfNbrPermanence.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfNbrPermanence.setDescription('This attribute displays how the neighbor became an entry.')
mscVrIpOspfLsdb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11))
mscVrIpOspfLsdbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1), )
if mibBuilder.loadTexts: mscVrIpOspfLsdbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpOspfLsdb components.')
mscVrIpOspfLsdbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbLsdbTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbLsIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfLsdbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfLsdb component.')
mscVrIpOspfLsdbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfLsdbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfLsdb components. These components cannot be added nor deleted.')
mscVrIpOspfLsdbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfLsdbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfLsdbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfLsdbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfLsdb tables.')
mscVrIpOspfLsdbAreaIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfLsdbAreaIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbAreaIdIndex.setDescription('This variable represents an index for the mscVrIpOspfLsdb tables.')
mscVrIpOspfLsdbLsdbTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)))
if mibBuilder.loadTexts: mscVrIpOspfLsdbLsdbTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbLsdbTypeIndex.setDescription('This variable represents an index for the mscVrIpOspfLsdb tables.')
mscVrIpOspfLsdbLsIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfLsdbLsIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbLsIdIndex.setDescription('This variable represents an index for the mscVrIpOspfLsdb tables.')
mscVrIpOspfLsdbRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 1, 1, 13), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfLsdbRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbRouterIdIndex.setDescription('This variable represents an index for the mscVrIpOspfLsdb tables.')
mscVrIpOspfLsdbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 10), )
if mibBuilder.loadTexts: mscVrIpOspfLsdbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group describes the Operational set of attributes for the LsdbEntry.')
mscVrIpOspfLsdbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbAreaIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbLsdbTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbLsIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfLsdbRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfLsdbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbOperEntry.setDescription('An entry in the mscVrIpOspfLsdbOperTable.')
mscVrIpOspfLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfLsdbSequence.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbSequence.setDescription('A signed 32-bit integer, used to detect old and duplicate LSAs. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
mscVrIpOspfLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfLsdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbAge.setDescription('The age of the Link State Advertisement in seconds.')
mscVrIpOspfLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfLsdbChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbChecksum.setDescription('The checksum of the complete contents of the advertisement, excepting the age field. The checksum used is the Fletcher checksum.')
mscVrIpOspfLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 11, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfLsdbAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfLsdbAdvertisement.setDescription('The entire LSA including its header.')
mscVrIpOspfExtLsdb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12))
mscVrIpOspfExtLsdbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1), )
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpOspfExtLsdb components.')
mscVrIpOspfExtLsdbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExtLsdbLsdbTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExtLsdbLsIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExtLsdbRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpOspfExtLsdb component.')
mscVrIpOspfExtLsdbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpOspfExtLsdb components. These components cannot be added nor deleted.')
mscVrIpOspfExtLsdbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpOspfExtLsdbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbStorageType.setDescription('This variable represents the storage type value for the mscVrIpOspfExtLsdb tables.')
mscVrIpOspfExtLsdbLsdbTypeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)))
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbLsdbTypeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbLsdbTypeIndex.setDescription('This variable represents an index for the mscVrIpOspfExtLsdb tables.')
mscVrIpOspfExtLsdbLsIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbLsIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbLsIdIndex.setDescription('This variable represents an index for the mscVrIpOspfExtLsdb tables.')
mscVrIpOspfExtLsdbRouterIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRouterIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbRouterIdIndex.setDescription('This variable represents an index for the mscVrIpOspfExtLsdb tables.')
mscVrIpOspfExtLsdbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 10), )
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group describes the operational set of attributes for the ExtLsdbEntry.')
mscVrIpOspfExtLsdbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExtLsdbLsdbTypeIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExtLsdbLsIdIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpOspfExtLsdbRouterIdIndex"))
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbOperEntry.setDescription('An entry in the mscVrIpOspfExtLsdbOperTable.')
mscVrIpOspfExtLsdbSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbSequence.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbSequence.setDescription('A signed 32-bit integer, used to detect old and duplicate LSAs. The space of sequence numbers is linearly ordered. The larger the sequence number, the more recent the advertisement.')
mscVrIpOspfExtLsdbAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 10, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbAge.setDescription('The age of the Link State Advertisement in seconds.')
mscVrIpOspfExtLsdbChecksum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbChecksum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbChecksum.setDescription('The checksum of the complete contents of the advertisement, excepting the age field. The checksum used is the Fletcher checksum.')
mscVrIpOspfExtLsdbAdvertisement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 7, 12, 10, 1, 4), HexString().subtype(subtypeSpec=ValueSizeConstraint(1, 36))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbAdvertisement.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpOspfExtLsdbAdvertisement.setDescription('The entire LSA including its header.')
mscVrIpRip = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8))
mscVrIpRipRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 1), )
if mibBuilder.loadTexts: mscVrIpRipRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpRip components.')
mscVrIpRipRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"))
if mibBuilder.loadTexts: mscVrIpRipRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRip component.')
mscVrIpRipRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRip components. These components can be added and deleted.')
mscVrIpRipComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRipStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipStorageType.setDescription('This variable represents the storage type value for the mscVrIpRip tables.')
mscVrIpRipIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpRipIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipIndex.setDescription('This variable represents the index for the mscVrIpRip tables.')
mscVrIpRipProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 10), )
if mibBuilder.loadTexts: mscVrIpRipProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipProvTable.setDescription('This group contains the provisionable attributes for the RIP component')
mscVrIpRipProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"))
if mibBuilder.loadTexts: mscVrIpRipProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipProvEntry.setDescription('An entry in the mscVrIpRipProvTable.')
mscVrIpRipMigrateRip = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipMigrateRip.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipMigrateRip.setDescription('This attribute sets the preference level of OSPF-internal routes to be less preferred than RIP. Note: This parameter should only be used when starting migration of network from RIP to OSPF. When ready to cutover to OSPF, set this attribute value to disabled and run under normal preferences. All OSPF routers in the Autonomous System should be running with migrateRip enabled or with migrateRip disabled to prevent routing loops. It is important that the changeover period from RIP to OSPF be performed quickly on all OSPF routers so that no routing loops are formed. These routing loops could be caused by conflicts in the internal RIP and OSPF databases.')
mscVrIpRipRfc1058MetricUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipRfc1058MetricUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipRfc1058MetricUsage.setDescription("This attribute determines the metric usage for this RIP instance. This flag is used to determine the way metrics are incremented. RFC1058 way : Sending Update: This is to use the metric for the route from the routing table as the advertised metric to be sent for that route. Nothing is ever added to this value from the sending side. The only special case handling is that if the route being advertised is the network route of a directly connectednetwork, the metric in the routing table will be zero. Then the RipIf interface metric for the interface being advertised is used as the advertise metric. If the interface being advertised is not a Rip interface, then metric value of 1 is used. Receiving Update: Add receiving interface's RIP metric to the metric for the route in the received advertisement and install the result in the receiver's routing table as the metric for that route. Older way: Sending Updates: Add the out going interfaces rip metric to the metric for a route in the routing table to form the metric to be advertised for that route. Receiving Updates: The metric received in the advertisement for a route is put directly in the routing table as the metric for that route. Note: It is recommended that, all the routers in this autonomous system should be following the rfc1058 metric system. Setting this flag to disabled will have the effect of running the RIP with old metric incrementing system.")
mscVrIpRipGenerateDiscardRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipGenerateDiscardRoute.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipGenerateDiscardRoute.setDescription('This attribute when set to yes will add network disacrd routes to the routing and forwarding table for the subnetted interfaces that are running RIP.')
mscVrIpRipRedistributeIbgp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2))).clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipRedistributeIbgp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipRedistributeIbgp.setDescription('This attribute specifies whether this Rip instance allows to exporting of any routes learned from internal Bgp peers (IBGP) to Rip. If the value of this attribute is true, and if an export policy is specified to distribute, then Rip allows any IBGP routes to be distributed to Rip. If the value of this attribute is false, Rip does not allow IBGP routes to be distributed to Rip, even if an export policy is specified to distribute.')
mscVrIpRipStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 11), )
if mibBuilder.loadTexts: mscVrIpRipStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpRipStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"))
if mibBuilder.loadTexts: mscVrIpRipStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipStateEntry.setDescription('An entry in the mscVrIpRipStateTable.')
mscVrIpRipAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpRipOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpRipUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpRipAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 12), )
if mibBuilder.loadTexts: mscVrIpRipAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscVrIpRipAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"))
if mibBuilder.loadTexts: mscVrIpRipAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipAdminControlEntry.setDescription('An entry in the mscVrIpRipAdminControlTable.')
mscVrIpRipSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscVrIpRipOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 15), )
if mibBuilder.loadTexts: mscVrIpRipOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrIpRipOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"))
if mibBuilder.loadTexts: mscVrIpRipOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipOperStatusEntry.setDescription('An entry in the mscVrIpRipOperStatusTable.')
mscVrIpRipSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrIpRipOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 16), )
if mibBuilder.loadTexts: mscVrIpRipOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipOperTable.setDescription('This group defines a set of operational attributes belonging to the RIP component. It corresponds to the rip2Globals table in the RIP-2 standard MIB.')
mscVrIpRipOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"))
if mibBuilder.loadTexts: mscVrIpRipOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipOperEntry.setDescription('An entry in the mscVrIpRipOperTable.')
mscVrIpRipRouteChangesMade = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 16, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipRouteChangesMade.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipRouteChangesMade.setDescription("This attribute counts the route changes made to the IP Route Database by Rip. This does not include the refresh of the route's age.")
mscVrIpRipQueryResponses = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 16, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipQueryResponses.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipQueryResponses.setDescription('This attribute counts the responses sent to RIP queries from other systems.')
mscVrIpRipImport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2))
mscVrIpRipImportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 1), )
if mibBuilder.loadTexts: mscVrIpRipImportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpRipImport components.')
mscVrIpRipImportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipImportIndex"))
if mibBuilder.loadTexts: mscVrIpRipImportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRipImport component.')
mscVrIpRipImportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRipImport components. These components can be added and deleted.')
mscVrIpRipImportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipImportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRipImportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipImportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportStorageType.setDescription('This variable represents the storage type value for the mscVrIpRipImport tables.')
mscVrIpRipImportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpRipImportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportIndex.setDescription('This variable represents the index for the mscVrIpRipImport tables.')
mscVrIpRipImportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 10), )
if mibBuilder.loadTexts: mscVrIpRipImportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportProvTable.setDescription('This is the group of provisionable attributes for the XXXX Import Subcomponent.')
mscVrIpRipImportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipImportIndex"))
if mibBuilder.loadTexts: mscVrIpRipImportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportProvEntry.setDescription('An entry in the mscVrIpRipImportProvTable.')
mscVrIpRipImportUsageFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("use", 1), ("ignore", 2))).clone('use')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportUsageFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportUsageFlag.setDescription('This flag when set to ignore indicates the routes that are not used and if set to use, indicates the routes which are used.')
mscVrIpRipImportImportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportImportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportImportMetric.setDescription('This attribute is used to override the default import metric for the RIP protocol. This value is not used to select which routes to use or ignore, rather it is the metric to be used in the routing table for the routes imported for this import policy. A value of zero indicates that the metric received in the update will be used.')
mscVrIpRipImportNeighbor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 10, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportNeighbor.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNeighbor.setDescription('This attribute indicates the IP Address of the neighbor this policy will apply to.')
mscVrIpRipImportInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportInterface.setDescription('This attribute specifies the RIP interface to which this import policy applies. The value of 0.0.0.0 implies any RIP interface on the virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
mscVrIpRipImportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2))
mscVrIpRipImportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 1), )
if mibBuilder.loadTexts: mscVrIpRipImportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpRipImportNet components.')
mscVrIpRipImportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipImportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipImportNetIndex"))
if mibBuilder.loadTexts: mscVrIpRipImportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRipImportNet component.')
mscVrIpRipImportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRipImportNet components. These components can be added and deleted.')
mscVrIpRipImportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipImportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRipImportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipImportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetStorageType.setDescription('This variable represents the storage type value for the mscVrIpRipImportNet tables.')
mscVrIpRipImportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpRipImportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetIndex.setDescription('This variable represents the index for the mscVrIpRipImportNet tables.')
mscVrIpRipImportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 10), )
if mibBuilder.loadTexts: mscVrIpRipImportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetProvTable.setDescription('This group contains attributes for the XXXX NetworkList component for the Import Policy to be applied to')
mscVrIpRipImportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipImportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipImportNetIndex"))
if mibBuilder.loadTexts: mscVrIpRipImportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetProvEntry.setDescription('An entry in the mscVrIpRipImportNetProvTable.')
mscVrIpRipImportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetIpAddress.setDescription('This attribute specifies the IP address that needs to be matched against in this network list for the Import Policy to be applied to.')
mscVrIpRipImportNetIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 2, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipImportNetIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipImportNetIpMask.setDescription('This attribute specifies the IP mask for the attribute ipAddress.')
mscVrIpRipExport = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3))
mscVrIpRipExportRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 1), )
if mibBuilder.loadTexts: mscVrIpRipExportRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpRipExport components.')
mscVrIpRipExportRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipExportIndex"))
if mibBuilder.loadTexts: mscVrIpRipExportRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRipExport component.')
mscVrIpRipExportRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRipExport components. These components can be added and deleted.')
mscVrIpRipExportComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipExportComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRipExportStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipExportStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportStorageType.setDescription('This variable represents the storage type value for the mscVrIpRipExport tables.')
mscVrIpRipExportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpRipExportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportIndex.setDescription('This variable represents the index for the mscVrIpRipExport tables.')
mscVrIpRipExportProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10), )
if mibBuilder.loadTexts: mscVrIpRipExportProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportProvTable.setDescription('This group contains all the provisioned attributes for the Export component.')
mscVrIpRipExportProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipExportIndex"))
if mibBuilder.loadTexts: mscVrIpRipExportProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportProvEntry.setDescription('An entry in the mscVrIpRipExportProvTable.')
mscVrIpRipExportAdvertiseStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("send", 1), ("block", 2))).clone('send')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportAdvertiseStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportAdvertiseStatus.setDescription('This attribute specifies if the routes that match this export policy are advertised (send) or not advertised (block).')
mscVrIpRipExportExportMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportExportMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportExportMetric.setDescription('This attribute specifies the metric to be used on the routes being exported as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of exportMetric is ignored. The exportMetric value is not used to select which routes to block or send, but rather the metric value advertised for the routes. A value of 0 indicates that the metric associated with the route in the forwarding table is used.')
mscVrIpRipExportProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("all", 1), ("egp", 2), ("rip", 3), ("ospfInternal", 4), ("ospfExternal", 5), ("staticLocal", 6), ("staticRemote", 7), ("bgpInternal", 8), ("bgpExternal", 9))).clone('all')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportProtocol.setDescription('This attribute specifies the routes to which this export policy applies based on the routing protocol of how the routes are learned. If it is set to all, this export policy applies to all routes except internal BGP routes in the forwarding table.')
mscVrIpRipExportRipInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportRipInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportRipInterface.setDescription('This attribute specifies the RIP learned routes to which this export policy applies, based on the RIP interface from which the routes are learned. This attribute can only be non zero when the protocol is set to rip. The value of 0.0.0.0 implies any RIP interface on the same virtual router; otherwise the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router. DESCRIPTION')
mscVrIpRipExportEgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportEgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportEgpAsId.setDescription('This attribute specifies the EGP learned routes to which this export policy applies, based on the EGP autonomous system identifier of which the routes are learned from. This attribute can only be non zero when protocol is set to egp. The value of 0 implies any EGP autonomous system; otherwise the value of this attribute must match the asId of an EGP neighbor on the same virtual router.')
mscVrIpRipExportOspfTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(4294967295)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportOspfTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportOspfTag.setDescription('This attribute specifies the OSPF learned external routes to which this export policy applies, based on the learned OSPF tag of the routes. This attribute can only be set to a non default value when protocol is set to ospfExternal. The default value of 4294967295 implies any tag.')
mscVrIpRipExportOutInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportOutInterface.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportOutInterface.setDescription('This attribute specifies the RIP interface on the virtual router which routes are exported onto as a result of matching this export policy. If the attribute advertiseStatus is set to block, then the value of outInterface is ignored. The outInterface value is not used to select which routes to block or send, but rather where to export the routes. A value of 0.0.0.0 indicates that the routes are exported to all RIP interfaces on the virtual router. Otherwise, the value of this attribute must match the interface address of a LogicalIf that has a RipIf on the same virtual router.')
mscVrIpRipExportBgpAsId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportBgpAsId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportBgpAsId.setDescription('This key attribute specifies the BGP AS from which the routes are learned. This key will be used only when the protocol is set to bgpExternal. bgpAsId of 0 matches all BGP ASs.')
mscVrIpRipExportNet = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2))
mscVrIpRipExportNetRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 1), )
if mibBuilder.loadTexts: mscVrIpRipExportNetRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpRipExportNet components.')
mscVrIpRipExportNetRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipExportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipExportNetIndex"))
if mibBuilder.loadTexts: mscVrIpRipExportNetRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRipExportNet component.')
mscVrIpRipExportNetRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportNetRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRipExportNet components. These components can be added and deleted.')
mscVrIpRipExportNetComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipExportNetComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRipExportNetStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRipExportNetStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetStorageType.setDescription('This variable represents the storage type value for the mscVrIpRipExportNet tables.')
mscVrIpRipExportNetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpRipExportNetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetIndex.setDescription('This variable represents the index for the mscVrIpRipExportNet tables.')
mscVrIpRipExportNetProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 10), )
if mibBuilder.loadTexts: mscVrIpRipExportNetProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetProvTable.setDescription('This group identifies the set of Provisionable attributes for the ExportNetworkList component.')
mscVrIpRipExportNetProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipExportIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRipExportNetIndex"))
if mibBuilder.loadTexts: mscVrIpRipExportNetProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetProvEntry.setDescription('An entry in the mscVrIpRipExportNetProvTable.')
mscVrIpRipExportNetIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 10, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportNetIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetIpAddress.setDescription('This attribute identifies the 32 bit IP address to match against.')
mscVrIpRipExportNetIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 8, 3, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRipExportNetIpMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRipExportNetIpMask.setDescription('This attribute is the IP Mask to be used with the IP Address to match against.')
mscVrIpStatic = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9))
mscVrIpStaticRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 1), )
if mibBuilder.loadTexts: mscVrIpStaticRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpStatic components.')
mscVrIpStaticRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticIndex"))
if mibBuilder.loadTexts: mscVrIpStaticRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpStatic component.')
mscVrIpStaticRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpStaticRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpStatic components. These components can be added and deleted.')
mscVrIpStaticComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpStaticStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticStorageType.setDescription('This variable represents the storage type value for the mscVrIpStatic tables.')
mscVrIpStaticIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpStaticIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticIndex.setDescription('This variable represents the index for the mscVrIpStatic tables.')
mscVrIpStaticStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 10), )
if mibBuilder.loadTexts: mscVrIpStaticStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpStaticStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticIndex"))
if mibBuilder.loadTexts: mscVrIpStaticStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticStateEntry.setDescription('An entry in the mscVrIpStaticStateTable.')
mscVrIpStaticAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpStaticOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpStaticUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpStaticRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2))
mscVrIpStaticRouteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1), )
if mibBuilder.loadTexts: mscVrIpStaticRouteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpStaticRoute components.')
mscVrIpStaticRouteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteTypeOfServiceIndex"))
if mibBuilder.loadTexts: mscVrIpStaticRouteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpStaticRoute component.')
mscVrIpStaticRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpStaticRouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpStaticRoute components. These components can be added and deleted.')
mscVrIpStaticRouteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticRouteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpStaticRouteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticRouteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteStorageType.setDescription('This variable represents the storage type value for the mscVrIpStaticRoute tables.')
mscVrIpStaticRouteDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpStaticRouteDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteDestAddressIndex.setDescription('This variable represents an index for the mscVrIpStaticRoute tables.')
mscVrIpStaticRouteDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: mscVrIpStaticRouteDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteDestMaskIndex.setDescription('This variable represents an index for the mscVrIpStaticRoute tables.')
mscVrIpStaticRouteTypeOfServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscVrIpStaticRouteTypeOfServiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteTypeOfServiceIndex.setDescription('This variable represents an index for the mscVrIpStaticRoute tables.')
mscVrIpStaticRouteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 10), )
if mibBuilder.loadTexts: mscVrIpStaticRouteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteProvTable.setDescription('This group contains a provisionable set of attributes for the static route entry component.')
mscVrIpStaticRouteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteTypeOfServiceIndex"))
if mibBuilder.loadTexts: mscVrIpStaticRouteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteProvEntry.setDescription('An entry in the mscVrIpStaticRouteProvTable.')
mscVrIpStaticRoutePreferredOver = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 72))).clone(namedValues=NamedValues(("intOspf", 5), ("extOspf", 72))).clone('extOspf')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpStaticRoutePreferredOver.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRoutePreferredOver.setDescription('This attribute indicates the preference of the static route in comparison with the OSPF route. intOspf means that the static route is chosen over the OSPF internal route, while extOspf means that the OSPF internal route is chosen over the static route. The default static route preference is set to extOspf .')
mscVrIpStaticRouteNh = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2))
mscVrIpStaticRouteNhRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 1), )
if mibBuilder.loadTexts: mscVrIpStaticRouteNhRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpStaticRouteNh components.')
mscVrIpStaticRouteNhRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteTypeOfServiceIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteNhIndex"))
if mibBuilder.loadTexts: mscVrIpStaticRouteNhRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpStaticRouteNh component.')
mscVrIpStaticRouteNhRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpStaticRouteNhRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpStaticRouteNh components. These components can be added and deleted.')
mscVrIpStaticRouteNhComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticRouteNhComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpStaticRouteNhStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticRouteNhStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhStorageType.setDescription('This variable represents the storage type value for the mscVrIpStaticRouteNh tables.')
mscVrIpStaticRouteNhIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpStaticRouteNhIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhIndex.setDescription('This variable represents the index for the mscVrIpStaticRouteNh tables.')
mscVrIpStaticRouteNhProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 10), )
if mibBuilder.loadTexts: mscVrIpStaticRouteNhProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhProvTable.setDescription('This group contains a provisionable set of attributes for the Static RouteEntry NextHop component.')
mscVrIpStaticRouteNhProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteDestMaskIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteTypeOfServiceIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticRouteNhIndex"))
if mibBuilder.loadTexts: mscVrIpStaticRouteNhProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhProvEntry.setDescription('An entry in the mscVrIpStaticRouteNhProvTable.')
mscVrIpStaticRouteNhMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpStaticRouteNhMetric.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticRouteNhMetric.setDescription('This attribute specifies the primary routing metric for this NextHop.')
mscVrIpStaticDiscard = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3))
mscVrIpStaticDiscardRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3, 1), )
if mibBuilder.loadTexts: mscVrIpStaticDiscardRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticDiscardRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpStaticDiscard components.')
mscVrIpStaticDiscardRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticDiscardDestAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpStaticDiscardDestMaskIndex"))
if mibBuilder.loadTexts: mscVrIpStaticDiscardRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticDiscardRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpStaticDiscard component.')
mscVrIpStaticDiscardRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpStaticDiscardRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticDiscardRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpStaticDiscard components. These components can be added and deleted.')
mscVrIpStaticDiscardComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticDiscardComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticDiscardComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpStaticDiscardStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpStaticDiscardStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticDiscardStorageType.setDescription('This variable represents the storage type value for the mscVrIpStaticDiscard tables.')
mscVrIpStaticDiscardDestAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpStaticDiscardDestAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticDiscardDestAddressIndex.setDescription('This variable represents an index for the mscVrIpStaticDiscard tables.')
mscVrIpStaticDiscardDestMaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 9, 3, 1, 1, 11), IpAddress())
if mibBuilder.loadTexts: mscVrIpStaticDiscardDestMaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpStaticDiscardDestMaskIndex.setDescription('This variable represents an index for the mscVrIpStaticDiscard tables.')
mscVrIpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10))
mscVrIpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 1), )
if mibBuilder.loadTexts: mscVrIpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpNs components.')
mscVrIpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpNsIndex"))
if mibBuilder.loadTexts: mscVrIpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpNs component.')
mscVrIpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpNs components. These components can be added and deleted.')
mscVrIpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsStorageType.setDescription('This variable represents the storage type value for the mscVrIpNs tables.')
mscVrIpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsIndex.setDescription('This variable represents the index for the mscVrIpNs tables.')
mscVrIpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 10), )
if mibBuilder.loadTexts: mscVrIpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsProvTable.setDescription('This group contains provisionable attributes for the NetSentry component.')
mscVrIpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpNsIndex"))
if mibBuilder.loadTexts: mscVrIpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsProvEntry.setDescription('An entry in the mscVrIpNsProvTable.')
mscVrIpNsFirstFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsFirstFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsFirstFilter.setDescription('The firstFilter is the first filter point which affects all IP packets before they have been examined in any way for their origin and destination. The most common use of a firstFilter point is to collect statistis for all packets arriving at the route on any interface, before any subsequent filter processing changes their direction or disposition.')
mscVrIpNsLocalInFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsLocalInFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsLocalInFilter.setDescription("The localInFilter is the second filter point which uses by network administrator to perform a common action on all IP packets that physically arrive over a specific logical interface, regardless of the packet's stated source or destination. Typical uses for a localInFilter include verifying that known Ethernet media source addresses match known IP addresses, or confirming that the IP packet source addresses of received IP packet fall within a narrow range.")
mscVrIpNsLocalOutFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsLocalOutFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsLocalOutFilter.setDescription('The localOutFilter is the third filter point which applies to any IP packet that will be transmitted from the router to the medium associated with the interface, regardless of its source, destination, or what type of decision was made to cause the datagram to be transmitted on this interface. localOutFilter generally used to ensure that certain paterns of traffic do not enter the network or reach a second IP router on that network. For example, localOutFilter can be used as the exclusion of all IP packets above a certain security classification, or collecting statistics on the amount of IP fragments performed on an outgoing interface.')
mscVrIpNsLastFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 10, 1, 4), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsLastFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsLastFilter.setDescription('lastFilter is the fourth and last filter point to be excecuted after all other routing and filtering decisions have been made on the IP packet, and transmission of the information is imminent. lastFilter is generally used to collect statistics on traffic after all previous control and routing decisions have been made.')
mscVrIpNsApply = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2))
mscVrIpNsApplyRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 1), )
if mibBuilder.loadTexts: mscVrIpNsApplyRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpNsApply components.')
mscVrIpNsApplyRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpNsIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpNsApplyIndex"))
if mibBuilder.loadTexts: mscVrIpNsApplyRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpNsApply component.')
mscVrIpNsApplyRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsApplyRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpNsApply components. These components can be added and deleted.')
mscVrIpNsApplyComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpNsApplyComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpNsApplyStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpNsApplyStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyStorageType.setDescription('This variable represents the storage type value for the mscVrIpNsApply tables.')
mscVrIpNsApplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscVrIpNsApplyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyIndex.setDescription('This variable represents the index for the mscVrIpNsApply tables.')
mscVrIpNsApplyProvisionedTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10), )
if mibBuilder.loadTexts: mscVrIpNsApplyProvisionedTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyProvisionedTable.setDescription('The instance of provisioned information relating to a filter application to IP packet.')
mscVrIpNsApplyProvisionedEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpNsIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpNsApplyIndex"))
if mibBuilder.loadTexts: mscVrIpNsApplyProvisionedEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyProvisionedEntry.setDescription('An entry in the mscVrIpNsApplyProvisionedTable.')
mscVrIpNsApplyFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsApplyFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyFilter.setDescription('The name of the filter to be applied to packet matching the conditions in this entry.')
mscVrIpNsApplyIpAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsApplyIpAddress1.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyIpAddress1.setDescription('The first IP address used to compare.')
mscVrIpNsApplyIpMask1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsApplyIpMask1.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyIpMask1.setDescription('The first netmask associated with ipAddress1 used to compare.')
mscVrIpNsApplyIpAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsApplyIpAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyIpAddress2.setDescription('This second IP address used to compare.')
mscVrIpNsApplyIpMask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10, 1, 5), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsApplyIpMask2.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyIpMask2.setDescription('This second netmask associated with ipAddress2 used to compare.')
mscVrIpNsApplyDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 10, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("to", 1), ("from", 2), ("tofrom", 3))).clone('tofrom')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpNsApplyDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpNsApplyDirection.setDescription("Indicates the direction a packet must be moving between the first and second apply list entries in order for the entries to match. First 'to' second, first 'from' second, or first 'tofrom' second (either direction).")
mscVrIpArp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11))
mscVrIpArpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 1), )
if mibBuilder.loadTexts: mscVrIpArpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpArp components.')
mscVrIpArpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpIndex"))
if mibBuilder.loadTexts: mscVrIpArpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpArp component.')
mscVrIpArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpArp components. These components cannot be added nor deleted.')
mscVrIpArpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpArpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpStorageType.setDescription('This variable represents the storage type value for the mscVrIpArp tables.')
mscVrIpArpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpArpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpIndex.setDescription('This variable represents the index for the mscVrIpArp tables.')
mscVrIpArpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 10), )
if mibBuilder.loadTexts: mscVrIpArpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpProvTable.setDescription('The ARP refresh feature allows the router to periodically verify ARP table entries. Whenever the router updates an ARP entry, or creates a new entry, a timeout value is assigned to the entry. When the timeout for an entry expires, the router will send a unicast ARP request to the currently-known physical address. If an ARP response comes back, the entry will be assigned a new timeout. If, however, the host has gone away or been assigned a new physical address, the host will not respond to the unicast ARP, and the entry will be removed from the ARP table. The new physical address will be discovered through the normal ARP mechanism when the next communication is attempted to the host.')
mscVrIpArpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpIndex"))
if mibBuilder.loadTexts: mscVrIpArpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpProvEntry.setDescription('An entry in the mscVrIpArpProvTable.')
mscVrIpArpAutoRefresh = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpAutoRefresh.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpAutoRefresh.setDescription('This attribute is used to enable or disable the ARP refresh feature.')
mscVrIpArpAutoRefreshTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1440)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpAutoRefreshTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpAutoRefreshTimeout.setDescription('This attribute defines the timeout value, in minutes, which is assigned to updated ARP entries, or newly created ARP entries. The range for the timeout is 1 minute to 1440 minutes (24 hours).')
mscVrIpArpHost = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2))
mscVrIpArpHostRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 1), )
if mibBuilder.loadTexts: mscVrIpArpHostRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpArpHost components.')
mscVrIpArpHostRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpHostHostAddressIndex"))
if mibBuilder.loadTexts: mscVrIpArpHostRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpArpHost component.')
mscVrIpArpHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpHostRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpArpHost components. These components can be added and deleted.')
mscVrIpArpHostComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpHostComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpArpHostStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpHostStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostStorageType.setDescription('This variable represents the storage type value for the mscVrIpArpHost tables.')
mscVrIpArpHostHostAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpArpHostHostAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostHostAddressIndex.setDescription('This variable represents the index for the mscVrIpArpHost tables.')
mscVrIpArpHostProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 10), )
if mibBuilder.loadTexts: mscVrIpArpHostProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostProvTable.setDescription('This group contains the provisionable attributes of the HostEntry component.')
mscVrIpArpHostProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpHostHostAddressIndex"))
if mibBuilder.loadTexts: mscVrIpArpHostProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostProvEntry.setDescription('An entry in the mscVrIpArpHostProvTable.')
mscVrIpArpHostPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 10, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 8)).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpHostPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostPhysAddress.setDescription('This attribute identifies the physical address of the host being defined. The value for this attribute should only be specified for media types supporting physical addresses (e.g. ethernet, fddi, tokenRing etc.)')
mscVrIpArpHostMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpHostMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostMaxTxUnit.setDescription("Specify the maximum transmit unit (MTU) size that can be accepted by the host. If this value is not specified, the value for the media interface is used. The specified MTU must be less than or equal to the interface's MTU size.")
mscVrIpArpHostPermanentVirtualCircuitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpHostPermanentVirtualCircuitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostPermanentVirtualCircuitNumber.setDescription('Specify a permanent virtual circuit number to the remote host on X.25 or frame relay media. The value for this attribute can only be specified for X.25 or frame relay media.')
mscVrIpArpHostTunnelDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 10, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpHostTunnelDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostTunnelDestinationAddress.setDescription('This attribute specifies the IP address of a remote IP tunnel endpoint in the shared domain. A value of 0.0.0.0 is used when the entry is not referring to an IP tunnel.')
mscVrIpArpHostEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("auto", 3))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpArpHostEncap.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostEncap.setDescription('This attribute specifies the encapsulation type for the host. The value for this attribute should only be specified for the hosts on the ethernet media. If a value of auto is specified, the application based on the media will determine the proper applicable encapsulation type.')
mscVrIpArpHostOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 11), )
if mibBuilder.loadTexts: mscVrIpArpHostOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostOperTable.setDescription('This group contains the operational attributes of the HostEntry component.')
mscVrIpArpHostOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpHostHostAddressIndex"))
if mibBuilder.loadTexts: mscVrIpArpHostOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostOperEntry.setDescription('An entry in the mscVrIpArpHostOperTable.')
mscVrIpArpHostOperMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpHostOperMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostOperMaxTxUnit.setDescription('This attribute indicates the operational value of the maximum transmission unit.')
mscVrIpArpHostOperEncap = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 2, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpHostOperEncap.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpHostOperEncap.setDescription('This attribute indicates the operational encapsulation type. if the value of the attribute encap is set to auto, then the application will determine the encapsulation type based on the media being used and assigns the appropriate value.')
mscVrIpArpDynHost = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3))
mscVrIpArpDynHostRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 1), )
if mibBuilder.loadTexts: mscVrIpArpDynHostRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpArpDynHost components.')
mscVrIpArpDynHostRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpDynHostHostAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpDynHostCosIndex"))
if mibBuilder.loadTexts: mscVrIpArpDynHostRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpArpDynHost component.')
mscVrIpArpDynHostRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpArpDynHost components. These components cannot be added nor deleted.')
mscVrIpArpDynHostComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpArpDynHostStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostStorageType.setDescription('This variable represents the storage type value for the mscVrIpArpDynHost tables.')
mscVrIpArpDynHostHostAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpArpDynHostHostAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostHostAddressIndex.setDescription('This variable represents an index for the mscVrIpArpDynHost tables.')
mscVrIpArpDynHostCosIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("notApplicable", 4))))
if mibBuilder.loadTexts: mscVrIpArpDynHostCosIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostCosIndex.setDescription('This variable represents an index for the mscVrIpArpDynHost tables.')
mscVrIpArpDynHostOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10), )
if mibBuilder.loadTexts: mscVrIpArpDynHostOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the operational attributes of the DynHostEntry component.')
mscVrIpArpDynHostOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpDynHostHostAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpArpDynHostCosIndex"))
if mibBuilder.loadTexts: mscVrIpArpDynHostOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostOperEntry.setDescription('An entry in the mscVrIpArpDynHostOperTable.')
mscVrIpArpDynHostPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 1), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostPhysAddress.setDescription('This attribute indicates the physical address of the host in canonical form.')
mscVrIpArpDynHostMaxTxUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostMaxTxUnit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostMaxTxUnit.setDescription('This attribute indicates the maximum MTU size that can be accepted by the host.')
mscVrIpArpDynHostEncapsulationType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ieee8023", 1), ("ethernet", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostEncapsulationType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostEncapsulationType.setDescription('This attribute indicates the encapsulation type of the host.')
mscVrIpArpDynHostPermanentVirtualCircuitNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostPermanentVirtualCircuitNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostPermanentVirtualCircuitNumber.setDescription('This attribute indicates the permanent virtual circuit number to the remote host.')
mscVrIpArpDynHostIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 6), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostIfIndex.setDescription('This attribute indicates the ifIndex of the protocol port that is associated with this entry.')
mscVrIpArpDynHostType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("pending", 1), ("invalid", 2), ("dynamic", 3), ("static", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostType.setDescription('This attribute indicates how this entry was learned.')
mscVrIpArpDynHostNcPhysAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 8), PhysAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostNcPhysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostNcPhysAddress.setDescription('This attribute indicates the physical address of the host in non-canonical form. This attribute is not displayed for hosts on non-LAN media.')
mscVrIpArpDynHostTunnelDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 11, 3, 10, 1, 9), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpArpDynHostTunnelDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpArpDynHostTunnelDestinationAddress.setDescription('This attribute indicates the IP address of a remote IP tunnel endpoint in the shared domain. A value of 0.0.0.0 is used when the entry is not referring to an IP tunnel.')
mscVrIpIcmp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12))
mscVrIpIcmpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 1), )
if mibBuilder.loadTexts: mscVrIpIcmpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpIcmp components.')
mscVrIpIcmpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIcmpIndex"))
if mibBuilder.loadTexts: mscVrIpIcmpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpIcmp component.')
mscVrIpIcmpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpIcmp components. These components cannot be added nor deleted.')
mscVrIpIcmpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpIcmpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpStorageType.setDescription('This variable represents the storage type value for the mscVrIpIcmp tables.')
mscVrIpIcmpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpIcmpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpIndex.setDescription('This variable represents the index for the mscVrIpIcmp tables.')
mscVrIpIcmpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 10), )
if mibBuilder.loadTexts: mscVrIpIcmpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpProvTable.setDescription('This group holds provisioned attributes for ICMP.')
mscVrIpIcmpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIcmpIndex"))
if mibBuilder.loadTexts: mscVrIpIcmpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpProvEntry.setDescription('An entry in the mscVrIpIcmpProvTable.')
mscVrIpIcmpSendRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpIcmpSendRedirect.setStatus('obsolete')
if mibBuilder.loadTexts: mscVrIpIcmpSendRedirect.setDescription('This attribute specifies whether an ICMP redirect will be sent. If enabled, the router may send an ICMP redirect if a an Ip packet is being routed out the same logicalInterface as it was received on. The router will only send host ICMP redirects. If disabled, the router will never send a ICMP redirect.')
mscVrIpIcmpSendHostUnreachable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpIcmpSendHostUnreachable.setStatus('obsolete')
if mibBuilder.loadTexts: mscVrIpIcmpSendHostUnreachable.setDescription('This attribute specifies whether host unreachable will be sent or not.')
mscVrIpIcmpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11), )
if mibBuilder.loadTexts: mscVrIpIcmpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpStatsTable.setDescription('This group holds statistics for ICMP.')
mscVrIpIcmpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIcmpIndex"))
if mibBuilder.loadTexts: mscVrIpIcmpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpStatsEntry.setDescription('An entry in the mscVrIpIcmpStatsTable.')
mscVrIpIcmpInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInMsgs.setDescription('This attribute indicates the number of ICMP messages received by this gateway. This number includes inErrors. inMsgs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInErrors.setDescription('This attribute indicates the number of ICMP messages received by this gateway but determined as having ICMP specific errors such as bad ICMP checksums or bad length. inErrors wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInDestUnreachs.setDescription('This attribute indicates the number of ICMP destination unreachable messages received by this gateway. inDestUnreachs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInTimeExcds.setDescription('This attribute indicates the number of ICMP time exceeded messages received by this gateway. inTimeExcds wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInParmProbs.setDescription('This attribute indicates the number of ICMP parameter problem messages received by this gateway. inParmProbs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInSrcQuenchs.setDescription('This attribute indicates the number of ICMP source quench messages received by this gateway. inSrcQuenchs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInRedirects.setDescription('This attribute indicates the number of ICMP redirect messages received by this gateway. inRedirects wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInEchos.setDescription('This attribute indicates the number of ICMP echo request messages received by this gateway. inEchos wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInEchoReps.setDescription('This attribute indicates the number of ICMP echo reply messages received by this gateway. inEchoReps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInTimestamps.setDescription('This attribute indicates the number of ICMP timestamp request messages received by this gateway. inTimeStamps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInTimestampReps.setDescription('This attribute indicates the number of ICMP timestamp reply messages received by this gateway. inTimeStampReps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInAddrMasks.setDescription('This attribute indicates the number of ICMP address mask request messages received by this gateway. inAddrMasks wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInAddrMaskReps.setDescription('This attribute indicates the number of ICMP address mask reply messages received by this gateway. inAddrMaskReps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutMsgs.setDescription('This attribute indicates the number of ICMP messages which this gateway attempted to send. This number includes outErrors. outMsgs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutErrors.setDescription('This attribute indicates the number of ICMP messages which this gateway did not send due to problems discovered within ICMP such as a lack of buffers. outErrors does not included errors discovered outside the ICMP layer such as the inability of IP to route the resultant datagram. outErrors wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutDestUnreachs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutDestUnreachs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutDestUnreachs.setDescription('This attribute indicates the number of ICMP destination unreachable messages sent by this gateway. outDestUnreachs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutTimeExcds = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutTimeExcds.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutTimeExcds.setDescription('This attribute indicates the number of ICMP time exceeded messages sent by this gateway. outTimeExcds wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutParmProbs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutParmProbs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutParmProbs.setDescription('This attribute indicates the number of ICMP parameter problem messages sent by this gateway. outParmProbs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutSrcQuenchs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutSrcQuenchs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutSrcQuenchs.setDescription('This attribute indicates the number of ICMP source quench messages sent by this gateway. ourSrcQuench wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutRedirects.setDescription('This attribute indicates the number of ICMP redirect messages sent by this gateway. outRedirects wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutEchos.setDescription('This attribute indicates the number of ICMP echo request messages sent by this gateway. outEchos wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutEchoReps.setDescription('This attribute indicates the number of ICMP echo reply messages sent by this gateway. outEchoReps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutTimestamps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutTimestamps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutTimestamps.setDescription('This attribute indicates the number of ICMP timestamp request messages sent by this gateway. outTimeStamps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutTimestampReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutTimestampReps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutTimestampReps.setDescription('This attribute indicates the number of ICMP timestamp reply messages sent by this gateway. outTimeStampReps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutAddrMasks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutAddrMasks.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutAddrMasks.setDescription('This attribute indicates the number of ICMP address mask request messages sent by this gateway. outAddrMasks wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutAddrMaskReps = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutAddrMaskReps.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutAddrMaskReps.setDescription('This attribute indicates the number of ICMP address mask reply message sent by this gateway. outAddrMaskReps wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInRtrAdvs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInRtrAdvs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInRtrAdvs.setDescription('This attribute indicates the number of ICMP router advertisement messages received by this gateway. inRtrAdvs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpInRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpInRtrSolicits.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpInRtrSolicits.setDescription('This attribute indicates the number of ICMP router solicitation messages received by this gateway. inRtrSolicits wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutRtrAdvs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutRtrAdvs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutRtrAdvs.setDescription('This attribute indicates the number of ICMP router advertisement messages sent by this gateway. outRtrAdvs wraps to zero if it reaches its maximum defined value.')
mscVrIpIcmpOutRtrSolicits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 12, 11, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpIcmpOutRtrSolicits.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpIcmpOutRtrSolicits.setDescription('This attribute indicates the number of ICMP router solicitation messages sent by this gateway. outRtrSolicits wraps to zero if it reaches its maximum defined value.')
mscVrIpRelayBC = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13))
mscVrIpRelayBCRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 1), )
if mibBuilder.loadTexts: mscVrIpRelayBCRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpRelayBC components.')
mscVrIpRelayBCRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRelayBCIndex"))
if mibBuilder.loadTexts: mscVrIpRelayBCRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRelayBC component.')
mscVrIpRelayBCRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRelayBCRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRelayBC components. These components cannot be added nor deleted.')
mscVrIpRelayBCComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRelayBCComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRelayBCStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRelayBCStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCStorageType.setDescription('This variable represents the storage type value for the mscVrIpRelayBC tables.')
mscVrIpRelayBCIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpRelayBCIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCIndex.setDescription('This variable represents the index for the mscVrIpRelayBC tables.')
mscVrIpRelayBCProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 10), )
if mibBuilder.loadTexts: mscVrIpRelayBCProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCProvTable.setDescription('This group contains global configuration attributes for the Relay Broadcast component.')
mscVrIpRelayBCProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRelayBCIndex"))
if mibBuilder.loadTexts: mscVrIpRelayBCProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCProvEntry.setDescription('An entry in the mscVrIpRelayBCProvTable.')
mscVrIpRelayBCRelayStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRelayBCRelayStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCRelayStatus.setDescription('Specifies whether or not IP will forward IP broadcast packets that were received as Link-Layer broadcasts.')
mscVrIpRelayBCRelayNdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRelayBCRelayNdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCRelayNdStatus.setDescription('Specifies whether or not IP will forward broadcast packets whose protocol is Sun ND.')
mscVrIpRelayBCOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 11), )
if mibBuilder.loadTexts: mscVrIpRelayBCOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCOperTable.setDescription('This group contains RelayBroadcast component statistics.')
mscVrIpRelayBCOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRelayBCIndex"))
if mibBuilder.loadTexts: mscVrIpRelayBCOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCOperEntry.setDescription('An entry in the mscVrIpRelayBCOperTable.')
mscVrIpRelayBCRelayNdCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRelayBCRelayNdCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCRelayNdCount.setDescription('Indicates the number of Sun ND packets received by this router which were forwarded. relayNdCount wraps to zero if reached its maximum.')
mscVrIpRelayBCPort = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2))
mscVrIpRelayBCPortRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 1), )
if mibBuilder.loadTexts: mscVrIpRelayBCPortRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpRelayBCPort components.')
mscVrIpRelayBCPortRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRelayBCIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRelayBCPortPortNumIndex"))
if mibBuilder.loadTexts: mscVrIpRelayBCPortRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpRelayBCPort component.')
mscVrIpRelayBCPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpRelayBCPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpRelayBCPort components. These components can be added and deleted.')
mscVrIpRelayBCPortComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRelayBCPortComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpRelayBCPortStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRelayBCPortStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortStorageType.setDescription('This variable represents the storage type value for the mscVrIpRelayBCPort tables.')
mscVrIpRelayBCPortPortNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 268435455)))
if mibBuilder.loadTexts: mscVrIpRelayBCPortPortNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortPortNumIndex.setDescription('This variable represents the index for the mscVrIpRelayBCPort tables.')
mscVrIpRelayBCPortOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 10), )
if mibBuilder.loadTexts: mscVrIpRelayBCPortOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortOperTable.setDescription('This group contains statistics related to InwPortEntry.')
mscVrIpRelayBCPortOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRelayBCIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpRelayBCPortPortNumIndex"))
if mibBuilder.loadTexts: mscVrIpRelayBCPortOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortOperEntry.setDescription('An entry in the mscVrIpRelayBCPortOperTable.')
mscVrIpRelayBCPortRelayBcUdpCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 13, 2, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpRelayBCPortRelayBcUdpCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpRelayBCPortRelayBcUdpCount.setDescription('Indicates the number of forwarded packets with this destination UDP port number. relayBcUdpCount wraps to zero if reached its maximum.')
mscVrIpUdp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14))
mscVrIpUdpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 1), )
if mibBuilder.loadTexts: mscVrIpUdpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpUdp components.')
mscVrIpUdpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpUdpIndex"))
if mibBuilder.loadTexts: mscVrIpUdpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpUdp component.')
mscVrIpUdpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpUdp components. These components cannot be added nor deleted.')
mscVrIpUdpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpUdpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpStorageType.setDescription('This variable represents the storage type value for the mscVrIpUdp tables.')
mscVrIpUdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpUdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpIndex.setDescription('This variable represents the index for the mscVrIpUdp tables.')
mscVrIpUdpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 10), )
if mibBuilder.loadTexts: mscVrIpUdpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpStatsTable.setDescription('This group holds statictics for UDP.')
mscVrIpUdpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpUdpIndex"))
if mibBuilder.loadTexts: mscVrIpUdpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpStatsEntry.setDescription('An entry in the mscVrIpUdpStatsTable.')
mscVrIpUdpInDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpInDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpInDatagrams.setDescription('The number of UDP datagrams delivered to UDP users. inDatagrams wraps to zero if reaches its maximum defined value.')
mscVrIpUdpNoPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpNoPorts.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpNoPorts.setDescription('The number of UDP datagrams received for which there was no application at the destination port. noPorts wraps to zero if reaches its maximum defined value.')
mscVrIpUdpInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 10, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpInErrors.setDescription('The number of received UDP datagrams that could not be delivered for reasons other than the lack of an application at the destination port. inErrors wraps to zero if reaches its maximum defined value.')
mscVrIpUdpOutDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 10, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpOutDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpOutDatagrams.setDescription('The number of UDP datagrams sent from this gateway. outDatagrams wraps to zero if reaches its maximum defined value.')
mscVrIpUdpListenEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2))
mscVrIpUdpListenEntryRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2, 1), )
if mibBuilder.loadTexts: mscVrIpUdpListenEntryRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpListenEntryRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpUdpListenEntry components.')
mscVrIpUdpListenEntryRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpUdpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpUdpListenEntryLocalAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpUdpListenEntryLocalPortIndex"))
if mibBuilder.loadTexts: mscVrIpUdpListenEntryRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpListenEntryRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpUdpListenEntry component.')
mscVrIpUdpListenEntryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpListenEntryRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpListenEntryRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpUdpListenEntry components. These components cannot be added nor deleted.')
mscVrIpUdpListenEntryComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpListenEntryComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpListenEntryComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpUdpListenEntryStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpUdpListenEntryStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpListenEntryStorageType.setDescription('This variable represents the storage type value for the mscVrIpUdpListenEntry tables.')
mscVrIpUdpListenEntryLocalAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpUdpListenEntryLocalAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpListenEntryLocalAddressIndex.setDescription('This variable represents an index for the mscVrIpUdpListenEntry tables.')
mscVrIpUdpListenEntryLocalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 14, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpUdpListenEntryLocalPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpUdpListenEntryLocalPortIndex.setDescription('This variable represents an index for the mscVrIpUdpListenEntry tables.')
mscVrIpTcp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15))
mscVrIpTcpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 1), )
if mibBuilder.loadTexts: mscVrIpTcpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpTcp components.')
mscVrIpTcpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpIndex"))
if mibBuilder.loadTexts: mscVrIpTcpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpTcp component.')
mscVrIpTcpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpTcp components. These components cannot be added nor deleted.')
mscVrIpTcpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpTcpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpStorageType.setDescription('This variable represents the storage type value for the mscVrIpTcp tables.')
mscVrIpTcpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpTcpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpIndex.setDescription('This variable represents the index for the mscVrIpTcp tables.')
mscVrIpTcpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10), )
if mibBuilder.loadTexts: mscVrIpTcpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpStatsTable.setDescription('This group contains statistics for TCP.')
mscVrIpTcpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpIndex"))
if mibBuilder.loadTexts: mscVrIpTcpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpStatsEntry.setDescription('An entry in the mscVrIpTcpStatsTable.')
mscVrIpTcpRToAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("constant", 2), ("rsre", 3), ("vanJacobson", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpRToAlgorithm.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpRToAlgorithm.setDescription('Indicate which algorithm was used to calculate the timeout value used for retransmitting unackowledged octet.')
mscVrIpTcpRToMin = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpRToMin.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpRToMin.setDescription('Indicate the minimum value, measured in milliseconds, allowed for retransmission timeout.')
mscVrIpTcpRToMax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpRToMax.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpRToMax.setDescription('Indicates the maximun value, measured in milliseconds, allowed for retransmission timeout.')
mscVrIpTcpMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, -1)).clone(-1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpMaxConn.setDescription('Limit on number of connections the TCP can support. The value is always -1 which indicates that the number of connections supported is dynamic (limited by memory in the system).')
mscVrIpTcpActiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpActiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpActiveOpens.setDescription('The number of times TCP connections have made a direct transition to the synSent state from the closed state.')
mscVrIpTcpPassiveOpens = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpPassiveOpens.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpPassiveOpens.setDescription('The number of times TCP connections have made a direct transition to the synRcvd state from the listen state.')
mscVrIpTcpAttemptFails = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpAttemptFails.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpAttemptFails.setDescription('The number of times TCP connections have made a direct transition to the closed state from either the synSent state or the synRcvd state, plus the number of times TCP connections have made a direct transition to the listen state from the synRcvd state.')
mscVrIpTcpEstabResets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpEstabResets.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpEstabResets.setDescription('The number of times TCP connections have made a direct transition to the closed state from either the established state or the closedWait state.')
mscVrIpTcpCurrEstab = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 9), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpCurrEstab.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpCurrEstab.setDescription('The number of TCP connections for which the current state is either established or closedWait.')
mscVrIpTcpInSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpInSegs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpInSegs.setDescription('The number of segments received, including those received in error. This count includes segments received on currently established connections.')
mscVrIpTcpOutSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpOutSegs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpOutSegs.setDescription('The number of segments sent, including those on current connections but excluding those containing only retransmitted octets.')
mscVrIpTcpRetransSegs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpRetransSegs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpRetransSegs.setDescription('The number of segments retransmitted that is, the number of TCP segments transmitted containing one or more previously transmitted octets.')
mscVrIpTcpInErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpInErrs.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpInErrs.setDescription('Total number of segments received in error, for example bad TCP checksum.')
mscVrIpTcpOutRsts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 10, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpOutRsts.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpOutRsts.setDescription('Number of TCP segments sent containing the RST flag.')
mscVrIpTcpTcpEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2))
mscVrIpTcpTcpEntryRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1), )
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpTcpTcpEntry components.')
mscVrIpTcpTcpEntryRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryLocalAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryLocalPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryRemoteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryRemotePortIndex"))
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpTcpTcpEntry component.')
mscVrIpTcpTcpEntryRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpTcpTcpEntry components. These components cannot be added nor deleted.')
mscVrIpTcpTcpEntryComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpTcpTcpEntryStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryStorageType.setDescription('This variable represents the storage type value for the mscVrIpTcpTcpEntry tables.')
mscVrIpTcpTcpEntryLocalAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryLocalAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryLocalAddressIndex.setDescription('This variable represents an index for the mscVrIpTcpTcpEntry tables.')
mscVrIpTcpTcpEntryLocalPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryLocalPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryLocalPortIndex.setDescription('This variable represents an index for the mscVrIpTcpTcpEntry tables.')
mscVrIpTcpTcpEntryRemoteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1, 12), IpAddress())
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRemoteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRemoteAddressIndex.setDescription('This variable represents an index for the mscVrIpTcpTcpEntry tables.')
mscVrIpTcpTcpEntryRemotePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRemotePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryRemotePortIndex.setDescription('This variable represents an index for the mscVrIpTcpTcpEntry tables.')
mscVrIpTcpTcpEntryOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 10), )
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains columnar entries for each end-point on the TCP.')
mscVrIpTcpTcpEntryOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryLocalAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryLocalPortIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryRemoteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTcpTcpEntryRemotePortIndex"))
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryOperEntry.setDescription('An entry in the mscVrIpTcpTcpEntryOperTable.')
mscVrIpTcpTcpEntryState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 15, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("closed", 1), ("listen", 2), ("synSent", 3), ("synReceived", 4), ("established", 5), ("closeWait", 6), ("finWait1", 7), ("closing", 8), ("lastAck", 9), ("finWait2", 10), ("timeWait", 11), ("delete", 12)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTcpTcpEntryState.setDescription('This attribute reflects the current state of this Tcp connection.')
mscVrIpBootp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16))
mscVrIpBootpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 1), )
if mibBuilder.loadTexts: mscVrIpBootpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpBootp components.')
mscVrIpBootpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"))
if mibBuilder.loadTexts: mscVrIpBootpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpBootp component.')
mscVrIpBootpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpBootpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpBootp components. These components can be added and deleted.')
mscVrIpBootpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpBootpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpStorageType.setDescription('This variable represents the storage type value for the mscVrIpBootp tables.')
mscVrIpBootpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpBootpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpIndex.setDescription('This variable represents the index for the mscVrIpBootp tables.')
mscVrIpBootpAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 10), )
if mibBuilder.loadTexts: mscVrIpBootpAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscVrIpBootpAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"))
if mibBuilder.loadTexts: mscVrIpBootpAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpAdminControlEntry.setDescription('An entry in the mscVrIpBootpAdminControlTable.')
mscVrIpBootpSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpBootpSnmpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscVrIpBootpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 11), )
if mibBuilder.loadTexts: mscVrIpBootpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpProvTable.setDescription('This group contains provisionable attributes for the BootpRelayAgent component.')
mscVrIpBootpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"))
if mibBuilder.loadTexts: mscVrIpBootpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpProvEntry.setDescription('An entry in the mscVrIpBootpProvTable.')
mscVrIpBootpHopDiscardThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(2, 16)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpBootpHopDiscardThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpHopDiscardThreshold.setDescription("BOOTP packets contain a 'hops' field which is used to limit the number of relay agents that can process the packet (each relay agent increments the 'hops' field by one). This attribute is used by the relay agent to determine when to discard a BOOTP packet. If the 'hops' field exceeds the hopDiscardThreshold the BOOTP packet will be discarded.")
mscVrIpBootpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 12), )
if mibBuilder.loadTexts: mscVrIpBootpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpBootpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"))
if mibBuilder.loadTexts: mscVrIpBootpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpStateEntry.setDescription('An entry in the mscVrIpBootpStateTable.')
mscVrIpBootpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpBootpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpBootpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpBootpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 13), )
if mibBuilder.loadTexts: mscVrIpBootpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrIpBootpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"))
if mibBuilder.loadTexts: mscVrIpBootpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpOperStatusEntry.setDescription('An entry in the mscVrIpBootpOperStatusTable.')
mscVrIpBootpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrIpBootpPpE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2))
mscVrIpBootpPpERowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 1), )
if mibBuilder.loadTexts: mscVrIpBootpPpERowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpERowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpBootpPpE components.')
mscVrIpBootpPpERowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpPpEIndex"))
if mibBuilder.loadTexts: mscVrIpBootpPpERowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpERowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpBootpPpE component.')
mscVrIpBootpPpERowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpERowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpERowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpBootpPpE components. These components cannot be added nor deleted.')
mscVrIpBootpPpEComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpBootpPpEStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEStorageType.setDescription('This variable represents the storage type value for the mscVrIpBootpPpE tables.')
mscVrIpBootpPpEIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 20)))
if mibBuilder.loadTexts: mscVrIpBootpPpEIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEIndex.setDescription('This variable represents the index for the mscVrIpBootpPpE tables.')
mscVrIpBootpPpEOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 10), )
if mibBuilder.loadTexts: mscVrIpBootpPpEOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains BootpPortEntry component operational data.')
mscVrIpBootpPpEOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpPpEIndex"))
if mibBuilder.loadTexts: mscVrIpBootpPpEOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEOperEntry.setDescription('An entry in the mscVrIpBootpPpEOperTable.')
mscVrIpBootpPpEStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("disabled", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEStatus.setDescription('This attribute indicates the status of the provisioned BootpPortEntry component. A value of disabled is used when the parent components, Vr, Ip, IpPort, or BootpRelayAgent is in a disabled state. A value of up is used when the BootpPortEntry is in an operational state. A state of down is used if the media associated with the BootpPortEntry is not ready or disabled.')
mscVrIpBootpPpEStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11), )
if mibBuilder.loadTexts: mscVrIpBootpPpEStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEStatsTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains BootpPortEntry component statistics.')
mscVrIpBootpPpEStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpBootpPpEIndex"))
if mibBuilder.loadTexts: mscVrIpBootpPpEStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEStatsEntry.setDescription('An entry in the mscVrIpBootpPpEStatsTable.')
mscVrIpBootpPpEInRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEInRequests.setDescription('This attribute counts the total number of BOOTP Request messages received on this port.')
mscVrIpBootpPpEInReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEInReplies.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEInReplies.setDescription('This attribute counts the total number of BOOTP Reply messages received on this port.')
mscVrIpBootpPpEOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEOutRequests.setDescription('This attribute counts total the number of BOOTP Request messages broadcast out on this port.')
mscVrIpBootpPpEOutReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEOutReplies.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEOutReplies.setDescription('This attribute counts the total number of BOOTP Reply messages sent out on this port.')
mscVrIpBootpPpEInRequestErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEInRequestErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEInRequestErrors.setDescription('This attribute counts the number of BOOTP Request messages received on this port but not forwarded due to an error. An error occurs if the BOOTP hop limit has been exceeded.')
mscVrIpBootpPpEInReplyErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 16, 2, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpBootpPpEInReplyErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpBootpPpEInReplyErrors.setDescription('This attribute counts the number of BOOTP Reply messages received on this port but not forwarded due to an error. An error occurs if the giaddr field in the BOOTP reply does not match an IP address assigned to this VirtualRouter, or if the output IpPort for the BOOTP reply is not provisioned for BOOTP.')
mscVrIpCache = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17))
mscVrIpCacheRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 1), )
if mibBuilder.loadTexts: mscVrIpCacheRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrIpCache components.')
mscVrIpCacheRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpCacheIndex"))
if mibBuilder.loadTexts: mscVrIpCacheRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpCache component.')
mscVrIpCacheRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpCache components. These components cannot be added nor deleted.')
mscVrIpCacheComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpCacheStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheStorageType.setDescription('This variable represents the storage type value for the mscVrIpCache tables.')
mscVrIpCacheIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: mscVrIpCacheIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheIndex.setDescription('This variable represents the index for the mscVrIpCache tables.')
mscVrIpCacheStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 10), )
if mibBuilder.loadTexts: mscVrIpCacheStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheStateTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpCacheStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpCacheIndex"))
if mibBuilder.loadTexts: mscVrIpCacheStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheStateEntry.setDescription('An entry in the mscVrIpCacheStateTable.')
mscVrIpCacheAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpCacheOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpCacheUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpCacheOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 11), )
if mibBuilder.loadTexts: mscVrIpCacheOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the operational attributes of an Ip cache table.')
mscVrIpCacheOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpCacheIndex"))
if mibBuilder.loadTexts: mscVrIpCacheOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheOperEntry.setDescription('An entry in the mscVrIpCacheOperTable.')
mscVrIpCacheEntriesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheEntriesFree.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheEntriesFree.setDescription('This attribute is indicative of the number of free Ip cache table entries. A consistently high value for this attribute indicates that there is a resource surplus of the memory requirements for cache table. This surplus could be utilized elsewhere if needed by adjusting the cacheTableMaxEntries under the Ip component.')
mscVrIpCacheTotalLookups = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheTotalLookups.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheTotalLookups.setDescription('This attribute indicates the total number of local cache lookups. It wraps around to 0 when it reaches the maximum value of 4294967295.')
mscVrIpCacheLookupMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheLookupMisses.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheLookupMisses.setDescription('This attribute indicates the total number of local cache lookup misses. It wraps around to 0 when it reaches the maximum value of 4294967295.')
mscVrIpCacheCacheTableMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 17, 11, 1, 395), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpCacheCacheTableMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpCacheCacheTableMaxEntries.setDescription('This attribute indicates the current maximum number of entries that can exist in the IP local cache table on each LP.')
mscVrIpTunnel = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18))
mscVrIpTunnelRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 1), )
if mibBuilder.loadTexts: mscVrIpTunnelRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpTunnel components.')
mscVrIpTunnelRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpTunnel component.')
mscVrIpTunnelRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpTunnel components. These components can be added and deleted.')
mscVrIpTunnelComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpTunnelStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelStorageType.setDescription('This variable represents the storage type value for the mscVrIpTunnel tables.')
mscVrIpTunnelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrIpTunnelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelIndex.setDescription('This variable represents the index for the mscVrIpTunnel tables.')
mscVrIpTunnelStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 12), )
if mibBuilder.loadTexts: mscVrIpTunnelStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrIpTunnelStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelStateEntry.setDescription('An entry in the mscVrIpTunnelStateTable.')
mscVrIpTunnelAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrIpTunnelOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrIpTunnelUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrIpTunnelSep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10))
mscVrIpTunnelSepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 1), )
if mibBuilder.loadTexts: mscVrIpTunnelSepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpTunnelSep components.')
mscVrIpTunnelSepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelSepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelSepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpTunnelSep component.')
mscVrIpTunnelSepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelSepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpTunnelSep components. These components can be added and deleted.')
mscVrIpTunnelSepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelSepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpTunnelSepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelSepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepStorageType.setDescription('This variable represents the storage type value for the mscVrIpTunnelSep tables.')
mscVrIpTunnelSepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63)))
if mibBuilder.loadTexts: mscVrIpTunnelSepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepIndex.setDescription('This variable represents the index for the mscVrIpTunnelSep tables.')
mscVrIpTunnelSepIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 10), )
if mibBuilder.loadTexts: mscVrIpTunnelSepIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscVrIpTunnelSepIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelSepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelSepIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepIfEntryEntry.setDescription('An entry in the mscVrIpTunnelSepIfEntryTable.')
mscVrIpTunnelSepIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelSepIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscVrIpTunnelSepIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 10, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelSepIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscVrIpTunnelSepMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 11), )
if mibBuilder.loadTexts: mscVrIpTunnelSepMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepMpTable.setDescription('This group contains the base provisioning data for the media base component.')
mscVrIpTunnelSepMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelSepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelSepMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepMpEntry.setDescription('An entry in the mscVrIpTunnelSepMpTable.')
mscVrIpTunnelSepLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelSepLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepLinkToProtocolPort.setDescription('This attribute specifies the ProtocolPort to which this interface is linked to. The protocol port is the logical interface to the network. The protocol port component describes the logical characteristics of this interface.')
mscVrIpTunnelSepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 12), )
if mibBuilder.loadTexts: mscVrIpTunnelSepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepProvTable.setDescription('This group contains the provisionable attributes for the StaticEndPoint component.')
mscVrIpTunnelSepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelSepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelSepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepProvEntry.setDescription('An entry in the mscVrIpTunnelSepProvTable.')
mscVrIpTunnelSepEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ipInIp", 0), ("greIp", 1))).clone('ipInIp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelSepEncapType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepEncapType.setDescription('There are two types of encapsulation techniques for IP tunnel, IP in IP (RFC 2003) and GRE over IP (RFC 1701). This attributes specifies the encapsulation type of the IP tunnel. ipInIp: As defined in RFC 2003, it can be used to encapsulated IP and IP payload only. If IP is the only type of payload to be encapsulated by the tunnel, this type of encapsulation is recommended as it requires less processing and uses less bandwidth. greIp: As defined in RFC 1701, it can be used to encapsulate IP or IPX payload. To encapsulate IPX payload, this encapsulation type must be used.')
mscVrIpTunnelSepSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 12, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelSepSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepSourceAddress.setDescription("This attribute specifies the IP address of the local end of the tunnel. The source address must be an address in the shared domain, and it must equal to an interface address on its own Virtual Router (under Vr/<string> Pp/<string> IpPort LogicalIf/<IpAddress>). However, it must not be the interface address of the linked protocol port's IpPort component.")
mscVrIpTunnelSepDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 12, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelSepDestinationAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepDestinationAddress.setDescription('This attribute specifies the IP address of the far end of the tunnel. It must not match any of the IP interface addresses on this Virtual Router.')
mscVrIpTunnelSepOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 14), )
if mibBuilder.loadTexts: mscVrIpTunnelSepOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepOperTable.setDescription('This group contains the operational status attributes of the StaticEndPoint component.')
mscVrIpTunnelSepOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelSepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelSepOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepOperEntry.setDescription('An entry in the mscVrIpTunnelSepOperTable.')
mscVrIpTunnelSepDiscoveredPathMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 10, 14, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(576, 18944), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelSepDiscoveredPathMtu.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelSepDiscoveredPathMtu.setDescription('This attribute indicates the latest learned Path MTU of the tunnel. An MTU is the maximum transmission unit of an arbitrary internet path. When a large amount of IP datagrams are to be transmitted, it is usually preferable that the datagrams be of the largest size that does not require fragmentation anywhere along the path from the source to the destination. This datagram size is referred to as the Path MTU (PMTU). It is equal to the minimum of the MTUs of each hop in the path.')
mscVrIpTunnelMsep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11))
mscVrIpTunnelMsepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 1), )
if mibBuilder.loadTexts: mscVrIpTunnelMsepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrIpTunnelMsep components.')
mscVrIpTunnelMsepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelMsepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelMsepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepRowStatusEntry.setDescription('A single entry in the table represents a single mscVrIpTunnelMsep component.')
mscVrIpTunnelMsepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrIpTunnelMsep components. These components can be added and deleted.')
mscVrIpTunnelMsepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelMsepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrIpTunnelMsepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelMsepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepStorageType.setDescription('This variable represents the storage type value for the mscVrIpTunnelMsep tables.')
mscVrIpTunnelMsepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscVrIpTunnelMsepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepIndex.setDescription('This variable represents the index for the mscVrIpTunnelMsep tables.')
mscVrIpTunnelMsepIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 10), )
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscVrIpTunnelMsepIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelMsepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfEntryEntry.setDescription('An entry in the mscVrIpTunnelMsepIfEntryTable.')
mscVrIpTunnelMsepIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscVrIpTunnelMsepIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 10, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscVrIpTunnelMsepMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 11), )
if mibBuilder.loadTexts: mscVrIpTunnelMsepMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepMpTable.setDescription('This group contains the base provisioning data for the media base component.')
mscVrIpTunnelMsepMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelMsepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelMsepMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepMpEntry.setDescription('An entry in the mscVrIpTunnelMsepMpTable.')
mscVrIpTunnelMsepLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 11, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepLinkToProtocolPort.setDescription('This attribute specifies the ProtocolPort to which this interface is linked to. The protocol port is the logical interface to the network. The protocol port component describes the logical characteristics of this interface.')
mscVrIpTunnelMsepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 12), )
if mibBuilder.loadTexts: mscVrIpTunnelMsepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepProvTable.setDescription('This group contains the provisionable attributes for the MultipointStaticEndPoint component.')
mscVrIpTunnelMsepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelMsepIndex"))
if mibBuilder.loadTexts: mscVrIpTunnelMsepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepProvEntry.setDescription('An entry in the mscVrIpTunnelMsepProvTable.')
mscVrIpTunnelMsepPathMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 12, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(576, 18944)).clone(1604)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepPathMtu.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepPathMtu.setDescription('This attribute specifies the Path Maximum Transmission Unit (MTU) of the IP Tunnel. If this value is set to a larger Path MTU than the forwarding path of the IP datagram can support, IP fragmentation may occur.')
mscVrIpTunnelMsepEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("ipInIp", 0))).clone('ipInIp')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepEncapType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepEncapType.setDescription('This component only supports one type of encapsulation technique for IP tunnel: IP in IP (RFC 2003). ipInIp: As defined in RFC 2003, it can be used to encapsulated IP and IP payload only.')
mscVrIpTunnelMsepSharedDomainVirtualRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 12, 1, 3), RowPointer()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepSharedDomainVirtualRouter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepSharedDomainVirtualRouter.setDescription('This attribute specifies the virtual router at the source endpoint of the IP tunnel. There must be a virtual router component provisioned with this instance value.')
mscVrIpTunnelMsepSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 12, 1, 4), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepSourceAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepSourceAddress.setDescription('This attribute specifies the IP address of the local end of the IP tunnel in the shared domain. There must be a logical interface with this IP address under the virtual router instance specified in the sharedDomainVirtualRouter attribute. This interface IP address cannot be an IP address defined under this IP tunnel protocol port.')
mscVrIpTunnelMsepDstTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 834), )
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstTable.setDescription('This attribute specifies the list of IP addresses mapping to each of the far end IP tunnel endpoints in the private domain. It must not match any of the IP interface addresses on the Virtual Router pointed to by the sharedDomainVirtualRouter attribute.')
mscVrIpTunnelMsepDstEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 834, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelMsepIndex"), (0, "Nortel-MsCarrier-MscPassport-IpMIB", "mscVrIpTunnelMsepDstValue"))
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstEntry.setDescription('An entry in the mscVrIpTunnelMsepDstTable.')
mscVrIpTunnelMsepDstValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 834, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstValue.setDescription('This variable represents both the value and the index for the mscVrIpTunnelMsepDstTable.')
mscVrIpTunnelMsepDstRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 6, 18, 11, 834, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrIpTunnelMsepDstRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVrIpTunnelMsepDstTable.')
ipGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 1))
ipGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 1, 1))
ipGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 1, 1, 3))
ipGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 1, 1, 3, 2))
ipCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 3))
ipCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 3, 1))
ipCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 3, 1, 3))
ipCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 27, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-IpMIB", mscVrPpIpPortSourceRouteEndStationSupport=mscVrPpIpPortSourceRouteEndStationSupport, mscVrPpIpPortBootpPAdminState=mscVrPpIpPortBootpPAdminState, mscVrPpIpPortBootpPInReplies=mscVrPpIpPortBootpPInReplies, mscVrIpTunnelMsepMpEntry=mscVrIpTunnelMsepMpEntry, mscVrIpOspfVirtIfRetransInterval=mscVrIpOspfVirtIfRetransInterval, mscVrIpIcmpProvEntry=mscVrIpIcmpProvEntry, mscVrIpOspfStorageType=mscVrIpOspfStorageType, mscVrIpEgpProvTable=mscVrIpEgpProvTable, mscVrIpTunnelSepEncapType=mscVrIpTunnelSepEncapType, mscVrIpIcmpOutErrors=mscVrIpIcmpOutErrors, mscVrPpIpPortLogicalIfOspfIfAuthKey=mscVrPpIpPortLogicalIfOspfIfAuthKey, mscVrIpOspfNbrOperEntry=mscVrIpOspfNbrOperEntry, mscVrIpOspfExportIndex=mscVrIpOspfExportIndex, mscVrPpIpPortBootpPOutRequests=mscVrPpIpPortBootpPOutRequests, mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex=mscVrPpIpPortLogicalIfOspfIfNbrAddressIndex, mscVrIpCosPolicyAssignment=mscVrIpCosPolicyAssignment, mscVrIpOspfNbrRtrId=mscVrIpOspfNbrRtrId, mscVrIpUdpListenEntryRowStatus=mscVrIpUdpListenEntryRowStatus, mscVrPpIpPortLogicalIfRipIfNbrComponentName=mscVrPpIpPortLogicalIfRipIfNbrComponentName, mscVrIpRelayBCRowStatusTable=mscVrIpRelayBCRowStatusTable, mscVrIpTcpTcpEntryOperTable=mscVrIpTcpTcpEntryOperTable, mscVrIpCacheOperationalState=mscVrIpCacheOperationalState, mscVrPpIpPortBootpPOutReplies=mscVrPpIpPortBootpPOutReplies, mscVrIpBootpPpEInReplyErrors=mscVrIpBootpPpEInReplyErrors, mscVrIpRipExportNetIpAddress=mscVrIpRipExportNetIpAddress, mscVrIpRipUsageState=mscVrIpRipUsageState, mscVrIpUdpListenEntryComponentName=mscVrIpUdpListenEntryComponentName, mscVrIpRipExportNetStorageType=mscVrIpRipExportNetStorageType, mscVrIpFwdStorageType=mscVrIpFwdStorageType, mscVrIpEgpImportNetComponentName=mscVrIpEgpImportNetComponentName, mscVrIpTunnelSepLinkToProtocolPort=mscVrIpTunnelSepLinkToProtocolPort, mscVrIpTunnelUsageState=mscVrIpTunnelUsageState, mscVrIpRelayBCProvTable=mscVrIpRelayBCProvTable, mscVrIpSnmpAdminStatus=mscVrIpSnmpAdminStatus, mscVrIpEgpImportProvEntry=mscVrIpEgpImportProvEntry, mscVrIpUdpInErrors=mscVrIpUdpInErrors, mscVrIpIfMtu=mscVrIpIfMtu, mscVrIpOspfStubAdvertiseDefault=mscVrIpOspfStubAdvertiseDefault, mscVrIpNsIndex=mscVrIpNsIndex, mscVrIpRowStatusEntry=mscVrIpRowStatusEntry, mscVrIpTcpOutSegs=mscVrIpTcpOutSegs, mscVrPpIpPortBootpPSnmpOperStatus=mscVrPpIpPortBootpPSnmpOperStatus, mscVrIpRowStatus=mscVrIpRowStatus, mscVrPpIpPortLogicalIfRipIfNbrRowStatus=mscVrPpIpPortLogicalIfRipIfNbrRowStatus, mscVrPpIpPortRowStatusEntry=mscVrPpIpPortRowStatusEntry, mscVrPpIpPortLogicalIfOspfIfNbrComponentName=mscVrPpIpPortLogicalIfOspfIfNbrComponentName, mscVrIpNsApplyRowStatus=mscVrIpNsApplyRowStatus, mscVrIpEgpExportNetIpAddress=mscVrIpEgpExportNetIpAddress, mscVrPpIpPortLogicalIfOspfIfPollInterval=mscVrPpIpPortLogicalIfOspfIfPollInterval, mscVrIpEgpOutErrorMsgs=mscVrIpEgpOutErrorMsgs, mscVrIpEgpNbrPollInterval=mscVrIpEgpNbrPollInterval, mscVrPpIpPortLogicalIfOspfIfTransitDelay=mscVrPpIpPortLogicalIfOspfIfTransitDelay, mscVrIpTunnelMsepEncapType=mscVrIpTunnelMsepEncapType, mscVrIpEgpStateEntry=mscVrIpEgpStateEntry, mscVrPpIpPortLogicalIfRipIfStatEntry=mscVrPpIpPortLogicalIfRipIfStatEntry, mscVrPpIpPortLogicalIfRipIfNbrIndex=mscVrPpIpPortLogicalIfRipIfNbrIndex, mscVrIpUdpListenEntryLocalAddressIndex=mscVrIpUdpListenEntryLocalAddressIndex, mscVrIpRipExportRowStatus=mscVrIpRipExportRowStatus, mscVrIpRelayBCRowStatus=mscVrIpRelayBCRowStatus, mscVrIpFwdRowStatusEntry=mscVrIpFwdRowStatusEntry, mscVrIpRelayBCPortComponentName=mscVrIpRelayBCPortComponentName, mscVrIpEgpExportComponentName=mscVrIpEgpExportComponentName, mscVrPpIpPortLogicalIfOspfIfRetransInterval=mscVrPpIpPortLogicalIfOspfIfRetransInterval, mscVrPpIpPortLogicalIfAddressIndex=mscVrPpIpPortLogicalIfAddressIndex, mscVrIpStaticRouteNhRowStatusEntry=mscVrIpStaticRouteNhRowStatusEntry, mscVrIpArpDynHostMaxTxUnit=mscVrIpArpDynHostMaxTxUnit, mscVrIpOspfLsdbAdvertisement=mscVrIpOspfLsdbAdvertisement, mscVrIpBootpAdminState=mscVrIpBootpAdminState, mscVrIpTcpRToAlgorithm=mscVrIpTcpRToAlgorithm, mscVrPpIpPortLogicalIfRowStatusEntry=mscVrPpIpPortLogicalIfRowStatusEntry, mscVrPpIpPortLogicalIfOspfIfHelloInterval=mscVrPpIpPortLogicalIfOspfIfHelloInterval, mscVrIpEgpNbrDefaultMetric=mscVrIpEgpNbrDefaultMetric, mscVrIpStaticRouteProvTable=mscVrIpStaticRouteProvTable, mscVrIpEgp=mscVrIpEgp, mscVrIpOspfHostAddressIndex=mscVrIpOspfHostAddressIndex, mscVrPpIpPortBootpPStorageType=mscVrPpIpPortBootpPStorageType, mscVrPpIpPortBootpPProvEntry=mscVrPpIpPortBootpPProvEntry, mscVrIpNsProvTable=mscVrIpNsProvTable, mscVrPpIpPortNsIndex=mscVrPpIpPortNsIndex, mscVrIpOspfRedistributeIbgp=mscVrIpOspfRedistributeIbgp, mscVrIpStorageType=mscVrIpStorageType, mscVrIpOspfVirtNbrRowStatus=mscVrIpOspfVirtNbrRowStatus, mscVrIpArpDynHostNcPhysAddress=mscVrIpArpDynHostNcPhysAddress, mscVrIpRelayBCOperEntry=mscVrIpRelayBCOperEntry, mscVrIpOspfAggregateAreaIdIndex=mscVrIpOspfAggregateAreaIdIndex, mscVrIpEgpNbrNeighborAddressIndex=mscVrIpEgpNbrNeighborAddressIndex, mscVrIpOspfVirtNbrStorageType=mscVrIpOspfVirtNbrStorageType, mscVrIpOspfLsdbLsdbTypeIndex=mscVrIpOspfLsdbLsdbTypeIndex, mscVrIpBootpOperationalState=mscVrIpBootpOperationalState, mscVrIpOspfStubTosIndex=mscVrIpOspfStubTosIndex, mscVrIpTcpCurrEstab=mscVrIpTcpCurrEstab, mscVrIpRdb=mscVrIpRdb, mscVrIpRdbGatewayIndex=mscVrIpRdbGatewayIndex, mscVrPpIpPortLogicalIfRipIfPoisonReverseFlag=mscVrPpIpPortLogicalIfRipIfPoisonReverseFlag, mscVrIpEgpUsageState=mscVrIpEgpUsageState, mscVrIpOspfExportMetric=mscVrIpOspfExportMetric, mscVrIpRipImportStorageType=mscVrIpRipImportStorageType, mscVrIpCacheAdminState=mscVrIpCacheAdminState, mscVrIpArpComponentName=mscVrIpArpComponentName, mscVrIpBootpRowStatusTable=mscVrIpBootpRowStatusTable, mscVrIpOspfLsdbRowStatusEntry=mscVrIpOspfLsdbRowStatusEntry, mscVrIpBootpAdminControlEntry=mscVrIpBootpAdminControlEntry, mscVrIpProvEntry=mscVrIpProvEntry, mscVrIpOspfVirtIfProvEntry=mscVrIpOspfVirtIfProvEntry, mscVrIpOspfExternLsaChecksumSum=mscVrIpOspfExternLsaChecksumSum, mscVrIpArpHost=mscVrIpArpHost, mscVrIpRipOperEntry=mscVrIpRipOperEntry, mscVrIpEgpRowStatusEntry=mscVrIpEgpRowStatusEntry, mscVrIpProvTable=mscVrIpProvTable, mscVrIpOspfAreaComponentName=mscVrIpOspfAreaComponentName, mscVrIpRelayBCComponentName=mscVrIpRelayBCComponentName, mscVrIpOspfAreaAsBdrRtrCount=mscVrIpOspfAreaAsBdrRtrCount, mscVrIpOspfVirtIfRowStatusEntry=mscVrIpOspfVirtIfRowStatusEntry, mscVrIpBootpRowStatusEntry=mscVrIpBootpRowStatusEntry, mscVrIpRipImportNetStorageType=mscVrIpRipImportNetStorageType, mscVrIpOspfNbrComponentName=mscVrIpOspfNbrComponentName, mscVrIpTcpInSegs=mscVrIpTcpInSegs, mscVrPpIpPortBootpPAdminControlTable=mscVrPpIpPortBootpPAdminControlTable, mscVrPpIpPortLogicalIfOspfIfNbrStorageType=mscVrPpIpPortLogicalIfOspfIfNbrStorageType, mscVrIpOspfSnmpOperStatus=mscVrIpOspfSnmpOperStatus, mscVrIpBootpStateTable=mscVrIpBootpStateTable, mscVrIpIcmpInDestUnreachs=mscVrIpIcmpInDestUnreachs, mscVrIpEgpExport=mscVrIpEgpExport, mscVrIpRelayBCRelayStatus=mscVrIpRelayBCRelayStatus, mscVrIpUdp=mscVrIpUdp, mscVrIpRipExport=mscVrIpRipExport, mscVrIpEgpRowStatus=mscVrIpEgpRowStatus, mscVrPpIpPortLogicalIfOspfIfNbrLsRetransQlen=mscVrPpIpPortLogicalIfOspfIfNbrLsRetransQlen, mscVrIpIcmpProvTable=mscVrIpIcmpProvTable, mscVrIpEgpExportNetProvTable=mscVrIpEgpExportNetProvTable, mscVrIpNsApplyRowStatusTable=mscVrIpNsApplyRowStatusTable, mscVrIpTunnelMsepSharedDomainVirtualRouter=mscVrIpTunnelMsepSharedDomainVirtualRouter, mscVrIpIcmpInTimeExcds=mscVrIpIcmpInTimeExcds, mscVrIpTcpTcpEntryOperEntry=mscVrIpTcpTcpEntryOperEntry, mscVrIpNsLocalInFilter=mscVrIpNsLocalInFilter, mscVrIpRipImportImportMetric=mscVrIpRipImportImportMetric, mscVrIpOspfUsageState=mscVrIpOspfUsageState, mscVrIpRipSnmpAdminStatus=mscVrIpRipSnmpAdminStatus, mscVrIpRipOperTable=mscVrIpRipOperTable, mscVrIpOspfHostStorageType=mscVrIpOspfHostStorageType, mscVrIpRipExportProvEntry=mscVrIpRipExportProvEntry, mscVrIpRipImportComponentName=mscVrIpRipImportComponentName, mscVrPpIpPortLogicalIfOspfIfBackupDesignatedRouter=mscVrPpIpPortLogicalIfOspfIfBackupDesignatedRouter, mscVrPpIpPortNsProvEntry=mscVrPpIpPortNsProvEntry, mscVrIpRipExportProtocol=mscVrIpRipExportProtocol, mscVrIpRdbProtocolIndex=mscVrIpRdbProtocolIndex, mscVrPpIpPortSresProvTable=mscVrPpIpPortSresProvTable, mscVrPpIpPortLogicalIfRipIfAcceptDefault=mscVrPpIpPortLogicalIfRipIfAcceptDefault, mscVrIpUsageState=mscVrIpUsageState, mscVrIpEgpExportProtocol=mscVrIpEgpExportProtocol, mscVrIpOspfNbrLsRetransQlen=mscVrIpOspfNbrLsRetransQlen, mscVrIpOspfLsdbSequence=mscVrIpOspfLsdbSequence, mscVrPpIpPortLogicalIfOspfIfMulticastForwarding=mscVrPpIpPortLogicalIfOspfIfMulticastForwarding, mscVrIpRipExportNetComponentName=mscVrIpRipExportNetComponentName, mscVrIpEgpNbrOutMsgs=mscVrIpEgpNbrOutMsgs, mscVrPpIpPortLogicalIfRipIfIfTriggeredUpdates=mscVrPpIpPortLogicalIfRipIfIfTriggeredUpdates, mscVrIpNsApplyProvisionedEntry=mscVrIpNsApplyProvisionedEntry, mscVrIpNsApplyRowStatusEntry=mscVrIpNsApplyRowStatusEntry, mscVrIpStaticRouteNhProvTable=mscVrIpStaticRouteNhProvTable, mscVrIpFwdMetric=mscVrIpFwdMetric, mscVrIpOspfNbrExchangeStatus=mscVrIpOspfNbrExchangeStatus, mscVrIpRipImportProvTable=mscVrIpRipImportProvTable, mscVrIpOspfOperationalState=mscVrIpOspfOperationalState, mscVrIpTcpTcpEntryLocalPortIndex=mscVrIpTcpTcpEntryLocalPortIndex, mscVrPpIpPortBootpPAddrValue=mscVrPpIpPortBootpPAddrValue, mscVrIpTunnelRowStatus=mscVrIpTunnelRowStatus, mscVrIpUdpInDatagrams=mscVrIpUdpInDatagrams, mscVrPpIpPortRowStatus=mscVrPpIpPortRowStatus, mscVrIpEgpImportNetProvTable=mscVrIpEgpImportNetProvTable, mscVrIpOspfVirtNbr=mscVrIpOspfVirtNbr, mscVrIpTunnelMsepIfAdminStatus=mscVrIpTunnelMsepIfAdminStatus, mscVrIpRelayBCIndex=mscVrIpRelayBCIndex, mscVrIpRipRfc1058MetricUsage=mscVrIpRipRfc1058MetricUsage, mscVrIpEgpNbrEventTrigger=mscVrIpEgpNbrEventTrigger, mscVrIpOspfAreaRowStatus=mscVrIpOspfAreaRowStatus, ipGroupCA02A=ipGroupCA02A, mscVrIpOspfExtLsdbStorageType=mscVrIpOspfExtLsdbStorageType, mscVrIpStaticRoutePreferredOver=mscVrIpStaticRoutePreferredOver, mscVrIpOspfAggregateRowStatusEntry=mscVrIpOspfAggregateRowStatusEntry, mscVrIpBootpOperStatusEntry=mscVrIpBootpOperStatusEntry, mscVrIpNsApplyIpAddress1=mscVrIpNsApplyIpAddress1, mscVrIpTcpOutRsts=mscVrIpTcpOutRsts, mscVrIpCacheStateEntry=mscVrIpCacheStateEntry, mscVrIpOspfExportBgpPeerIp=mscVrIpOspfExportBgpPeerIp, mscVrIpUdpComponentName=mscVrIpUdpComponentName, mscVrPpIpPortRelayBcOperEntry=mscVrPpIpPortRelayBcOperEntry, mscVrIpCtsTable=mscVrIpCtsTable, mscVrIpNsApplyIpMask1=mscVrIpNsApplyIpMask1, mscVrIpOspfLsdbRouterIdIndex=mscVrIpOspfLsdbRouterIdIndex, mscVrIpTunnelStateEntry=mscVrIpTunnelStateEntry, mscVrIpIcmp=mscVrIpIcmp, mscVrIpTunnelMsepProvTable=mscVrIpTunnelMsepProvTable, mscVrIpOspfAggregateStorageType=mscVrIpOspfAggregateStorageType, mscVrIpOspfAreaProvEntry=mscVrIpOspfAreaProvEntry, mscVrPpIpPort=mscVrPpIpPort, mscVrIpRipImportNetIpMask=mscVrIpRipImportNetIpMask, mscVrIpOspfSnmpAdminStatus=mscVrIpOspfSnmpAdminStatus, mscVrPpIpPortLogicalIfRipIfComponentName=mscVrPpIpPortLogicalIfRipIfComponentName, mscVrPpIpPortLogicalIfRipIfRowStatusTable=mscVrPpIpPortLogicalIfRipIfRowStatusTable, mscVrIpTcpPassiveOpens=mscVrIpTcpPassiveOpens, mscVrIpRipExportStorageType=mscVrIpRipExportStorageType, mscVrIpBootpPpEStatus=mscVrIpBootpPpEStatus, ipGroup=ipGroup, mscVrIpRipStateTable=mscVrIpRipStateTable, mscVrIpTunnelMsepDstValue=mscVrIpTunnelMsepDstValue, mscVrIpUdpListenEntryLocalPortIndex=mscVrIpUdpListenEntryLocalPortIndex, mscVrPpIpPortMaxTxUnit=mscVrPpIpPortMaxTxUnit, mscVrIpRipExportRipInterface=mscVrIpRipExportRipInterface, mscVrIpEgpNbrOutErrors=mscVrIpEgpNbrOutErrors, mscVrIpOspfExportProvEntry=mscVrIpOspfExportProvEntry, mscVrIpOspfAreaAreaBdrRtrCount=mscVrIpOspfAreaAreaBdrRtrCount, mscVrIpCacheCacheTableMaxEntries=mscVrIpCacheCacheTableMaxEntries, mscVrIpOspfExportRowStatus=mscVrIpOspfExportRowStatus, mscVrIpArpDynHostEncapsulationType=mscVrIpArpDynHostEncapsulationType, mscVrIpRipProvEntry=mscVrIpRipProvEntry, mscVrIpFwdComponentName=mscVrIpFwdComponentName, mscVrIpOspfVirtIfStorageType=mscVrIpOspfVirtIfStorageType, mscVrIpIcmpOutRtrSolicits=mscVrIpIcmpOutRtrSolicits, mscVrIpRipIndex=mscVrIpRipIndex, mscVrIpBootpPpEInRequestErrors=mscVrIpBootpPpEInRequestErrors, mscVrIpFwdDestMaskIndex=mscVrIpFwdDestMaskIndex, mscVrIpRipImportNetRowStatusEntry=mscVrIpRipImportNetRowStatusEntry, mscVrIpEgpNbrProvTable=mscVrIpEgpNbrProvTable, mscVrIpIcmpRowStatusTable=mscVrIpIcmpRowStatusTable, mscVrIpRipExportAdvertiseStatus=mscVrIpRipExportAdvertiseStatus, mscVrIpFwdProtocol=mscVrIpFwdProtocol, mscVrPpIpPortLogicalIfOspfIfEvents=mscVrPpIpPortLogicalIfOspfIfEvents, mscVrIpBootpPpERowStatusTable=mscVrIpBootpPpERowStatusTable, mscVrIpArpDynHostRowStatusTable=mscVrIpArpDynHostRowStatusTable, mscVrPpIpPortLogicalIfOspfIfTOSRowStatusEntry=mscVrPpIpPortLogicalIfOspfIfTOSRowStatusEntry, mscVrIpRipExportExportMetric=mscVrIpRipExportExportMetric, mscVrIpTunnelMsepIfEntryEntry=mscVrIpTunnelMsepIfEntryEntry, mscVrIpUdpListenEntryRowStatusTable=mscVrIpUdpListenEntryRowStatusTable, mscVrIpOspfVirtIfAreaIdIndex=mscVrIpOspfVirtIfAreaIdIndex, mscVrIpAdminControlTable=mscVrIpAdminControlTable, mscVrIpEgpInMsgs=mscVrIpEgpInMsgs, mscVrIpIcmpIndex=mscVrIpIcmpIndex, mscVrIpCacheComponentName=mscVrIpCacheComponentName, mscVrIpStaticRouteProvEntry=mscVrIpStaticRouteProvEntry, mscVrIpRelayBCPortStorageType=mscVrIpRelayBCPortStorageType, mscVrPpIpPortBootpPInRequestErrors=mscVrPpIpPortBootpPInRequestErrors, mscVrPpIpPortRelayAddress=mscVrPpIpPortRelayAddress, mscVrIpRelayBCPortOperTable=mscVrIpRelayBCPortOperTable, mscVrIpBootpPpEOutReplies=mscVrIpBootpPpEOutReplies, mscVrPpIpPortSnmpOperStatus=mscVrPpIpPortSnmpOperStatus, mscVrIpStaticRouteNhMetric=mscVrIpStaticRouteNhMetric, mscVrIpNsRowStatus=mscVrIpNsRowStatus, mscVrIpOspfTosSupport=mscVrIpOspfTosSupport, mscVrIpCacheTotalLookups=mscVrIpCacheTotalLookups, mscVrIpReasmReqds=mscVrIpReasmReqds, mscVrIpArpAutoRefreshTimeout=mscVrIpArpAutoRefreshTimeout, mscVrIpArpHostProvTable=mscVrIpArpHostProvTable, mscVrIpRelayBCPortPortNumIndex=mscVrIpRelayBCPortPortNumIndex, mscVrIpBootpPpERowStatus=mscVrIpBootpPpERowStatus)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-IpMIB", ipCapabilitiesCA02=ipCapabilitiesCA02, mscVrIpOspfVirtIfTransitDelay=mscVrIpOspfVirtIfTransitDelay, mscVrIpOspfStubRowStatus=mscVrIpOspfStubRowStatus, mscVrIpArpDynHostOperEntry=mscVrIpArpDynHostOperEntry, mscVrIpTcpRowStatusEntry=mscVrIpTcpRowStatusEntry, mscVrIpTunnelMsepLinkToProtocolPort=mscVrIpTunnelMsepLinkToProtocolPort, mscVrIpEgpNbrOperEntry=mscVrIpEgpNbrOperEntry, mscVrIpOspfNbr=mscVrIpOspfNbr, mscVrPpIpPortOperStatusEntry=mscVrPpIpPortOperStatusEntry, mscVrIpTunnelStateTable=mscVrIpTunnelStateTable, mscVrIpOspfLsdbRowStatus=mscVrIpOspfLsdbRowStatus, mscVrIpOspfOperStatusTable=mscVrIpOspfOperStatusTable, mscVrIpEgpImportRowStatus=mscVrIpEgpImportRowStatus, mscVrPpIpPortLogicalIfOspfIfProvTable=mscVrPpIpPortLogicalIfOspfIfProvTable, mscVrIpAdminState=mscVrIpAdminState, mscVrIpIfRowStatus=mscVrIpIfRowStatus, mscVrIpOspfStubStorageType=mscVrIpOspfStubStorageType, mscVrIpArpHostPermanentVirtualCircuitNumber=mscVrIpArpHostPermanentVirtualCircuitNumber, mscVrPpIpPortBootpPRowStatusEntry=mscVrPpIpPortBootpPRowStatusEntry, mscVrIpCacheStateTable=mscVrIpCacheStateTable, mscVrIpRdbRowStatusEntry=mscVrIpRdbRowStatusEntry, mscVrIpArpDynHostRowStatus=mscVrIpArpDynHostRowStatus, mscVrIpCtsIndex=mscVrIpCtsIndex, mscVrIpRdbStorageType=mscVrIpRdbStorageType, mscVrIpOspfRowStatusTable=mscVrIpOspfRowStatusTable, mscVrIpRipRouteChangesMade=mscVrIpRipRouteChangesMade, mscVrIpRipExportProvTable=mscVrIpRipExportProvTable, mscVrIpArpDynHostComponentName=mscVrIpArpDynHostComponentName, mscVrIpOspfNbrOperTable=mscVrIpOspfNbrOperTable, mscVrIpArpDynHostPhysAddress=mscVrIpArpDynHostPhysAddress, mscVrIpFragOks=mscVrIpFragOks, mscVrIpStateEntry=mscVrIpStateEntry, mscVrIpOspfExport=mscVrIpOspfExport, mscVrIpOspfVirtNbrNbrRouterIdIndex=mscVrIpOspfVirtNbrNbrRouterIdIndex, mscVrIpOspfVirtIfRowStatus=mscVrIpOspfVirtIfRowStatus, mscVrIpCacheRowStatusTable=mscVrIpCacheRowStatusTable, mscVrIpOspfGenerateDefaultRouteMetric=mscVrIpOspfGenerateDefaultRouteMetric, mscVrIpOspfLsdb=mscVrIpOspfLsdb, mscVrIpFwdRowStatusTable=mscVrIpFwdRowStatusTable, mscVrIpFwdGatewayIndex=mscVrIpFwdGatewayIndex, mscVrIpOspfNbrEvents=mscVrIpOspfNbrEvents, mscVrIpTcpIndex=mscVrIpTcpIndex, mscVrIpIcmpComponentName=mscVrIpIcmpComponentName, mscVrIpOspfVirtNbrRowStatusEntry=mscVrIpOspfVirtNbrRowStatusEntry, mscVrIpOspfHostProvEntry=mscVrIpOspfHostProvEntry, mscVrIpTunnelMsepIndex=mscVrIpTunnelMsepIndex, mscVrIpIcmpOutDestUnreachs=mscVrIpIcmpOutDestUnreachs, mscVrIpOspfNbrStorageType=mscVrIpOspfNbrStorageType, mscVrIpBootpPpEStorageType=mscVrIpBootpPpEStorageType, mscVrIpEgpProvEntry=mscVrIpEgpProvEntry, mscVrIpRelayBCPortRowStatus=mscVrIpRelayBCPortRowStatus, mscVrIpOspfComponentName=mscVrIpOspfComponentName, mscVrPpIpPortLogicalIfRipIfIfBadRouteRcv=mscVrPpIpPortLogicalIfRipIfIfBadRouteRcv, mscVrIpOspfAreaImportAsExtern=mscVrIpOspfAreaImportAsExtern, mscVrIpStaticDiscard=mscVrIpStaticDiscard, mscVrIpEgpImportNetRowStatus=mscVrIpEgpImportNetRowStatus, mscVrIpEgpAdminControlEntry=mscVrIpEgpAdminControlEntry, mscVrIpRipImportNetComponentName=mscVrIpRipImportNetComponentName, mscVrPpIpPortLogicalIfRipIfNetworkRouteStatus=mscVrPpIpPortLogicalIfRipIfNetworkRouteStatus, mscVrIpRipExportNetProvTable=mscVrIpRipExportNetProvTable, mscVrIpIcmpInAddrMasks=mscVrIpIcmpInAddrMasks, mscVrIpIcmpInRedirects=mscVrIpIcmpInRedirects, mscVrIpOspfAreaProvTable=mscVrIpOspfAreaProvTable, mscVrIpTcpTcpEntryComponentName=mscVrIpTcpTcpEntryComponentName, mscVrIpBootpPpEOutRequests=mscVrIpBootpPpEOutRequests, mscVrIpTunnelMsepDstTable=mscVrIpTunnelMsepDstTable, mscVrIpOspfStubComponentName=mscVrIpOspfStubComponentName, mscVrIpOspfHostTosIndex=mscVrIpOspfHostTosIndex, mscVrIpEgpMaxBufferSize=mscVrIpEgpMaxBufferSize, mscVrPpIpPortNsComponentName=mscVrPpIpPortNsComponentName, mscVrIpIfInterfaceMask=mscVrIpIfInterfaceMask, mscVrIpOspfNbrAddressIndex=mscVrIpOspfNbrAddressIndex, mscVrIpEgpExportNetProvEntry=mscVrIpEgpExportNetProvEntry, mscVrIpStaticRouteNh=mscVrIpStaticRouteNh, mscVrIpEgpStatsEntry=mscVrIpEgpStatsEntry, mscVrPpIpPortLogicalIfStorageType=mscVrPpIpPortLogicalIfStorageType, mscVrIpEgpDefaultHelloInterval=mscVrIpEgpDefaultHelloInterval, mscVrIpEgpImportNetStorageType=mscVrIpEgpImportNetStorageType, mscVrIpEgpExportInEgpAsId=mscVrIpEgpExportInEgpAsId, mscVrIpNsApplyFilter=mscVrIpNsApplyFilter, mscVrIpTunnelMsepPathMtu=mscVrIpTunnelMsepPathMtu, mscVrPpIpPortLogicalIfOspfIfRowStatusEntry=mscVrPpIpPortLogicalIfOspfIfRowStatusEntry, mscVrIpRdbOperEntry=mscVrIpRdbOperEntry, mscVrIpOspfAggregateAggregateNetIndex=mscVrIpOspfAggregateAggregateNetIndex, mscVrIpStatsEntry=mscVrIpStatsEntry, mscVrIpOspfLsdbAreaIdIndex=mscVrIpOspfLsdbAreaIdIndex, mscVrIpEgpNbrGenerateDefaultRoute=mscVrIpEgpNbrGenerateDefaultRoute, mscVrIpEgpStateTable=mscVrIpEgpStateTable, mscVrIpOspfProvEntry=mscVrIpOspfProvEntry, mscVrPpIpPortBootpPProvTable=mscVrPpIpPortBootpPProvTable, mscVrPpIpPortLogicalIfRipIfRowStatus=mscVrPpIpPortLogicalIfRipIfRowStatus, mscVrIpEgpMaxNatNets=mscVrIpEgpMaxNatNets, mscVrIpEgpOutErrors=mscVrIpEgpOutErrors, mscVrIpRelayBCRowStatusEntry=mscVrIpRelayBCRowStatusEntry, mscVrIpOspfExtLsdbOperTable=mscVrIpOspfExtLsdbOperTable, mscVrIpTcpInErrs=mscVrIpTcpInErrs, mscVrIpEgpImportNetIndex=mscVrIpEgpImportNetIndex, mscVrIpArpDynHostStorageType=mscVrIpArpDynHostStorageType, mscVrPpIpPortOperationalState=mscVrPpIpPortOperationalState, mscVrIpIcmpInTimestampReps=mscVrIpIcmpInTimestampReps, mscVrIpEgpNbrInMsgs=mscVrIpEgpNbrInMsgs, mscVrPpIpPortLogicalIfOspfIfRtrDeadInterval=mscVrPpIpPortLogicalIfOspfIfRtrDeadInterval, mscVrIpEgpImportComponentName=mscVrIpEgpImportComponentName, mscVrPpIpPortComponentName=mscVrPpIpPortComponentName, mscVrPpIpPortLogicalIfOspfIfMetricEntry=mscVrPpIpPortLogicalIfOspfIfMetricEntry, mscVrPpIpPortNsProvTable=mscVrPpIpPortNsProvTable, mscVrPpIpPortBootpPBootpLogicalInterface=mscVrPpIpPortBootpPBootpLogicalInterface, mscVrIpTunnelAdminState=mscVrIpTunnelAdminState, mscVrIpOspfNbrState=mscVrIpOspfNbrState, mscVrPpIpPortOperMulticastStatus=mscVrPpIpPortOperMulticastStatus, mscVrIpTcpTcpEntryStorageType=mscVrIpTcpTcpEntryStorageType, mscVrIpBootpAdminControlTable=mscVrIpBootpAdminControlTable, mscVrIpReasmFails=mscVrIpReasmFails, mscVrIpOspfVirtIfState=mscVrIpOspfVirtIfState, mscVrPpIpPortLogicalIfOspfIfNbrRowStatus=mscVrPpIpPortLogicalIfOspfIfNbrRowStatus, mscVrIpTunnelSepDestinationAddress=mscVrIpTunnelSepDestinationAddress, mscVrPpIpPortStateTable=mscVrPpIpPortStateTable, mscVrIpFwdNextHopAs=mscVrIpFwdNextHopAs, mscVrIpEgpExportIndex=mscVrIpEgpExportIndex, mscVrIpStaticAdminState=mscVrIpStaticAdminState, mscVrIpOspfVirtIf=mscVrIpOspfVirtIf, mscVrIpRipImportNet=mscVrIpRipImportNet, mscVrIpEgpExportRipNeighbor=mscVrIpEgpExportRipNeighbor, mscVrIpIndex=mscVrIpIndex, mscVrPpIpPortBootpPOperStatusEntry=mscVrPpIpPortBootpPOperStatusEntry, mscVrIpRipImportUsageFlag=mscVrIpRipImportUsageFlag, mscVrIpInHdrErrors=mscVrIpInHdrErrors, mscVrIpStaticRouteComponentName=mscVrIpStaticRouteComponentName, mscVrIpOspfExportProtocol=mscVrIpOspfExportProtocol, mscVrIpStaticRouteNhIndex=mscVrIpStaticRouteNhIndex, mscVrPpIpPortLogicalIfOspfIfNbrProvTable=mscVrPpIpPortLogicalIfOspfIfNbrProvTable, mscVrIpRipImportNetIndex=mscVrIpRipImportNetIndex, mscVrIpEgpInErrors=mscVrIpEgpInErrors, mscVrIpStaticOperationalState=mscVrIpStaticOperationalState, mscVrPpIpPortCosPolicyAssignment=mscVrPpIpPortCosPolicyAssignment, mscVrIpEgpComponentName=mscVrIpEgpComponentName, mscVrIpOspfStubProvEntry=mscVrIpOspfStubProvEntry, mscVrIpOutNoRoutes=mscVrIpOutNoRoutes, mscVrIpIcmpOutRedirects=mscVrIpIcmpOutRedirects, mscVrPpIpPortNsRowStatus=mscVrPpIpPortNsRowStatus, mscVrIpNsProvEntry=mscVrIpNsProvEntry, mscVrPpIpPortLogicalIfOspfIfMetric=mscVrPpIpPortLogicalIfOspfIfMetric, mscVrIpOspfAggregateProvEntry=mscVrIpOspfAggregateProvEntry, mscVrIpOspfAggregateRowStatus=mscVrIpOspfAggregateRowStatus, mscVrIpStaticStateEntry=mscVrIpStaticStateEntry, mscVrIpArpDynHostTunnelDestinationAddress=mscVrIpArpDynHostTunnelDestinationAddress, mscVrPpIpPortOperCosPolicyAssignment=mscVrPpIpPortOperCosPolicyAssignment, mscVrIpEgpExportProvTable=mscVrIpEgpExportProvTable, mscVrIpOspfAreaLsaCount=mscVrIpOspfAreaLsaCount, mscVrIpNsRowStatusTable=mscVrIpNsRowStatusTable, mscVrIpBootpPpEStatsTable=mscVrIpBootpPpEStatsTable, mscVrIpOspfRxNewLsas=mscVrIpOspfRxNewLsas, mscVrIpTunnelSepIfAdminStatus=mscVrIpTunnelSepIfAdminStatus, mscVrIpTunnelMsepProvEntry=mscVrIpTunnelMsepProvEntry, mscVrPpIpPortLogicalIfOspfIfAreaId=mscVrPpIpPortLogicalIfOspfIfAreaId, mscVrIpInAddrErrors=mscVrIpInAddrErrors, mscVrIpIcmpInMsgs=mscVrIpIcmpInMsgs, mscVrPpIpPortSresProvEntry=mscVrPpIpPortSresProvEntry, mscVrIpBootpPpEIndex=mscVrIpBootpPpEIndex, mscVrIpCtsValue=mscVrIpCtsValue, mscVrIpEgpInErrorMsgs=mscVrIpEgpInErrorMsgs, mscVrIpOspfAreaSpfRuns=mscVrIpOspfAreaSpfRuns, mscVrIpOspfLsdbAge=mscVrIpOspfLsdbAge, mscVrIpIcmpRowStatus=mscVrIpIcmpRowStatus, mscVrIpOspfExtLsdbRouterIdIndex=mscVrIpOspfExtLsdbRouterIdIndex, mscVrIpIfMediaType=mscVrIpIfMediaType, mscVrIpRelayBCPort=mscVrIpRelayBCPort, mscVrPpIpPortBootpPRowStatus=mscVrPpIpPortBootpPRowStatus, mscVrIpOspfExportNetListRowStatusTable=mscVrIpOspfExportNetListRowStatusTable, mscVrIpFragFails=mscVrIpFragFails, mscVrIpRipRedistributeIbgp=mscVrIpRipRedistributeIbgp, mscVrIpEgpNbrState=mscVrIpEgpNbrState, mscVrIpOspfExportNetListIndex=mscVrIpOspfExportNetListIndex, mscVrIpOspfNbrAddressLessIndex=mscVrIpOspfNbrAddressLessIndex, mscVrPpIpPortProvEntry=mscVrPpIpPortProvEntry, mscVrIpOspfHostRowStatusEntry=mscVrIpOspfHostRowStatusEntry, mscVrIpOspfExtLsdbAdvertisement=mscVrIpOspfExtLsdbAdvertisement, mscVrIpRipAdminControlEntry=mscVrIpRipAdminControlEntry, mscVrIpOspfStubAreaIdIndex=mscVrIpOspfStubAreaIdIndex, mscVrIpNsLocalOutFilter=mscVrIpNsLocalOutFilter, mscVrIpArpDynHostOperTable=mscVrIpArpDynHostOperTable, mscVrIpNsApplyComponentName=mscVrIpNsApplyComponentName, mscVrIpTcpTcpEntryRowStatusEntry=mscVrIpTcpTcpEntryRowStatusEntry, mscVrIpOspfVirtIfOperTable=mscVrIpOspfVirtIfOperTable, mscVrIpRipGenerateDiscardRoute=mscVrIpRipGenerateDiscardRoute, mscVrIpRipExportEgpAsId=mscVrIpRipExportEgpAsId, mscVrIpStaticDiscardRowStatusEntry=mscVrIpStaticDiscardRowStatusEntry, mscVrIpRelayBCOperTable=mscVrIpRelayBCOperTable, mscVrIpOspfLsdbRowStatusTable=mscVrIpOspfLsdbRowStatusTable, mscVrPpIpPortLogicalIfOspfIfOperEntry=mscVrPpIpPortLogicalIfOspfIfOperEntry, mscVrIpUdpIndex=mscVrIpUdpIndex, mscVrIpOspfRouterId=mscVrIpOspfRouterId, mscVrIpOspfAreaAuthType=mscVrIpOspfAreaAuthType, mscVrIpOspfLsdbOperTable=mscVrIpOspfLsdbOperTable, mscVrIpTunnelSep=mscVrIpTunnelSep, mscVrIpOspfMigrateRip=mscVrIpOspfMigrateRip, mscVrIpEgpSnmpAdminStatus=mscVrIpEgpSnmpAdminStatus, mscVrIpRipImport=mscVrIpRipImport, mscVrPpIpPortLinkModel=mscVrPpIpPortLinkModel, mscVrIpIcmpRowStatusEntry=mscVrIpIcmpRowStatusEntry, mscVrIpRipAdminControlTable=mscVrIpRipAdminControlTable, mscVrIpOspfExtLsdbLsdbTypeIndex=mscVrIpOspfExtLsdbLsdbTypeIndex, mscVrPpIpPortMediaType=mscVrPpIpPortMediaType, mscVrIpArpHostRowStatus=mscVrIpArpHostRowStatus, mscVrIpArpHostOperTable=mscVrIpArpHostOperTable, mscVrIpTunnelComponentName=mscVrIpTunnelComponentName, mscVrIpOspfNbrRowStatusEntry=mscVrIpOspfNbrRowStatusEntry, mscVrPpIpPortLogicalIfRipIfIfBadPacketRcv=mscVrPpIpPortLogicalIfRipIfIfBadPacketRcv, mscVrIpOspfExtLsdbSequence=mscVrIpOspfExtLsdbSequence, mscVrIpOspfHost=mscVrIpOspfHost, mscVrIpIcmpInRtrAdvs=mscVrIpIcmpInRtrAdvs, mscVrIpIfOperEntry=mscVrIpIfOperEntry, mscVrIpNsStorageType=mscVrIpNsStorageType, mscVrIpFwdIfIndex=mscVrIpFwdIfIndex, mscVrIpCacheRowStatusEntry=mscVrIpCacheRowStatusEntry, mscVrIpEgpExportProvEntry=mscVrIpEgpExportProvEntry, mscVrIpOspfExportTag=mscVrIpOspfExportTag, mscVrIpArpDynHost=mscVrIpArpDynHost, mscVrPpIpPortLogicalIfOspfIfTOS=mscVrPpIpPortLogicalIfOspfIfTOS, mscVrIpTunnelSepIfEntryTable=mscVrIpTunnelSepIfEntryTable, mscVrIpOspfExportNetListStorageType=mscVrIpOspfExportNetListStorageType, mscVrPpIpPortLogicalIfOspfIfComponentName=mscVrPpIpPortLogicalIfOspfIfComponentName, mscVrIpEgpExportRowStatus=mscVrIpEgpExportRowStatus, mscVrPpIpPortLogicalIfRipIfNbrRowStatusTable=mscVrPpIpPortLogicalIfRipIfNbrRowStatusTable, mscVrIpOspfNbrOptions=mscVrIpOspfNbrOptions, mscVrIpOspfAggregateLsdbTypeIndex=mscVrIpOspfAggregateLsdbTypeIndex, mscVrIpBootpPpEComponentName=mscVrIpBootpPpEComponentName, mscVrIpEgpOperStatusEntry=mscVrIpEgpOperStatusEntry, mscVrIpRelayBC=mscVrIpRelayBC, mscVrPpIpPortLogicalIfOspfIfTOSRowStatus=mscVrPpIpPortLogicalIfOspfIfTOSRowStatus, mscVrIpEgpImportImportMetric=mscVrIpEgpImportImportMetric, mscVrPpIpPortAllowMcastMacDest=mscVrPpIpPortAllowMcastMacDest, mscVrIpIcmpSendRedirect=mscVrIpIcmpSendRedirect, mscVrIpIcmpInEchos=mscVrIpIcmpInEchos, mscVrIpEgpExportNet=mscVrIpEgpExportNet, mscVrIpOspfVirtIfEvents=mscVrIpOspfVirtIfEvents, mscVrIpBootpOperStatusTable=mscVrIpBootpOperStatusTable, ipCapabilitiesCA=ipCapabilitiesCA, mscVrIpRipExportRowStatusTable=mscVrIpRipExportRowStatusTable, mscVrIpRdbRowStatus=mscVrIpRdbRowStatus, mscVrPpIpPortLogicalIfOspfIfNbrProvEntry=mscVrPpIpPortLogicalIfOspfIfNbrProvEntry, mscVrIpNsApplyStorageType=mscVrIpNsApplyStorageType, mscVrIpIcmpInParmProbs=mscVrIpIcmpInParmProbs, mscVrIpIcmpOutAddrMasks=mscVrIpIcmpOutAddrMasks, mscVrIpTunnelSepIndex=mscVrIpTunnelSepIndex, mscVrIpArpHostHostAddressIndex=mscVrIpArpHostHostAddressIndex, mscVrIpTunnelMsepRowStatusEntry=mscVrIpTunnelMsepRowStatusEntry, mscVrPpIpPortLogicalIfRipIfStatTable=mscVrPpIpPortLogicalIfRipIfStatTable, mscVrPpIpPortAdminState=mscVrPpIpPortAdminState, mscVrIpEgpNbrRowStatusEntry=mscVrIpEgpNbrRowStatusEntry, mscVrIpStaticDiscardRowStatusTable=mscVrIpStaticDiscardRowStatusTable, mscVrIpOspfAreaStorageType=mscVrIpOspfAreaStorageType, mscVrPpIpPortLogicalIfRowStatus=mscVrPpIpPortLogicalIfRowStatus, mscVrIpEgpExportNetRowStatusTable=mscVrIpEgpExportNetRowStatusTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-IpMIB", mscVrPpIpPortBootpPStatsTable=mscVrPpIpPortBootpPStatsTable, mscVrIpOspfOriginateNewLsas=mscVrIpOspfOriginateNewLsas, mscVrIpOspfHostAreaId=mscVrIpOspfHostAreaId, mscVrPpIpPortIndex=mscVrPpIpPortIndex, mscVrIpNsApplyIpMask2=mscVrIpNsApplyIpMask2, mscVrPpIpPortOperTable=mscVrPpIpPortOperTable, mscVrIpRelayBCPortRowStatusEntry=mscVrIpRelayBCPortRowStatusEntry, mscVrIpOspfStubRowStatusEntry=mscVrIpOspfStubRowStatusEntry, mscVrIpEgpStatsTable=mscVrIpEgpStatsTable, mscVrIpOspfExportRowStatusEntry=mscVrIpOspfExportRowStatusEntry, mscVrIpTcpTcpEntryLocalAddressIndex=mscVrIpTcpTcpEntryLocalAddressIndex, mscVrPpIpPortLogicalIfNetMask=mscVrPpIpPortLogicalIfNetMask, mscVrIpOspfAreaAreaLsaCksumSum=mscVrIpOspfAreaAreaLsaCksumSum, mscVrPpIpPortLogicalIfRipIfRowStatusEntry=mscVrPpIpPortLogicalIfRipIfRowStatusEntry, mscVrIpTunnelSepComponentName=mscVrIpTunnelSepComponentName, mscVrIpOspfRowStatusEntry=mscVrIpOspfRowStatusEntry, mscVrIpTunnel=mscVrIpTunnel, mscVrPpIpPortLogicalIfOspfIfNbrExchangeStatus=mscVrPpIpPortLogicalIfOspfIfNbrExchangeStatus, mscVrPpIpPortLogicalIfBroadcastAddress=mscVrPpIpPortLogicalIfBroadcastAddress, mscVrIpFwdType=mscVrIpFwdType, mscVrIpCacheRowStatus=mscVrIpCacheRowStatus, mscVrIpTunnelMsepRowStatus=mscVrIpTunnelMsepRowStatus, ipGroupCA=ipGroupCA, mscVrPpIpPortLogicalIfRipIfStorageType=mscVrPpIpPortLogicalIfRipIfStorageType, mscVrIpEgpNbrRowStatus=mscVrIpEgpNbrRowStatus, mscVrIpOspfHostComponentName=mscVrIpOspfHostComponentName, mscVrIpOspfExtLsdbRowStatusTable=mscVrIpOspfExtLsdbRowStatusTable, mscVrPpIpPortBootpPAddrTable=mscVrPpIpPortBootpPAddrTable, mscVrIpEgpExportNetRowStatus=mscVrIpEgpExportNetRowStatus, mscVrIpRipImportNetProvTable=mscVrIpRipImportNetProvTable, mscVrIpEgpNbrOutErrorMsgs=mscVrIpEgpNbrOutErrorMsgs, mscVrIpArpHostOperMaxTxUnit=mscVrIpArpHostOperMaxTxUnit, mscVrIpRelayBCRelayNdCount=mscVrIpRelayBCRelayNdCount, mscVrPpIpPortLogicalIfComponentName=mscVrPpIpPortLogicalIfComponentName, mscVrIpCacheStorageType=mscVrIpCacheStorageType, mscVrIpBootpIndex=mscVrIpBootpIndex, mscVrIpOspfAreaRowStatusEntry=mscVrIpOspfAreaRowStatusEntry, mscVrIpOspfStub=mscVrIpOspfStub, mscVrIpBootpStateEntry=mscVrIpBootpStateEntry, mscVrIpOspfVirtIfAuthKey=mscVrIpOspfVirtIfAuthKey, mscVrIpRipMigrateRip=mscVrIpRipMigrateRip, mscVrIpOspfLsdbChecksum=mscVrIpOspfLsdbChecksum, mscVrPpIpPortLogicalIfOspfIfTOSProvEntry=mscVrPpIpPortLogicalIfOspfIfTOSProvEntry, mscVrIpEgpNbrAsId=mscVrIpEgpNbrAsId, mscVrIpEgpImportUsageFlag=mscVrIpEgpImportUsageFlag, mscVrIpOspfExportRipNeighbor=mscVrIpOspfExportRipNeighbor, mscVrIpOspfExportExtLsaMetricType=mscVrIpOspfExportExtLsaMetricType, mscVrIpOspfExportNetListComponentName=mscVrIpOspfExportNetListComponentName, mscVrIpOspfVirtNbrComponentName=mscVrIpOspfVirtNbrComponentName, mscVrIpTcpStatsTable=mscVrIpTcpStatsTable, mscVrIpFragCreates=mscVrIpFragCreates, mscVrIpNsApply=mscVrIpNsApply, mscVrIpArpHostTunnelDestinationAddress=mscVrIpArpHostTunnelDestinationAddress, mscVrIpOspfHostRowStatus=mscVrIpOspfHostRowStatus, mscVrIpTcpTcpEntryState=mscVrIpTcpTcpEntryState, mscVrIpSnmpOperStatus=mscVrIpSnmpOperStatus, mscVrIpEgpExportNetRowStatusEntry=mscVrIpEgpExportNetRowStatusEntry, mscVrIpEgpNbrStorageType=mscVrIpEgpNbrStorageType, mscVrIpOspfExtLsdbLimit=mscVrIpOspfExtLsdbLimit, mscVrPpIpPortAdminControlEntry=mscVrPpIpPortAdminControlEntry, mscVrIpOspfExportBgpAsId=mscVrIpOspfExportBgpAsId, mscVrIpOspfStubMetricType=mscVrIpOspfStubMetricType, mscVrIpStatsTable=mscVrIpStatsTable, mscVrPpIpPortLogicalIfRipIfDefaultRouteMetric=mscVrPpIpPortLogicalIfRipIfDefaultRouteMetric, mscVrIpRipSnmpOperStatus=mscVrIpRipSnmpOperStatus, mscVrIpOspfIndex=mscVrIpOspfIndex, mscVrIpOperationalState=mscVrIpOperationalState, mscVrIpStaticRouteNhComponentName=mscVrIpStaticRouteNhComponentName, mscVrPpIpPortBootpP=mscVrPpIpPortBootpP, mscVrIpRipImportNeighbor=mscVrIpRipImportNeighbor, mscVrIpArpDynHostHostAddressIndex=mscVrIpArpDynHostHostAddressIndex, mscVrIpIfStorageType=mscVrIpIfStorageType, mscVrIpRipOperStatusEntry=mscVrIpRipOperStatusEntry, mscVrIpIcmpOutEchos=mscVrIpIcmpOutEchos, mscVrPpIpPortArpNoLearn=mscVrPpIpPortArpNoLearn, mscVrIpOspfAreaAreaSummary=mscVrIpOspfAreaAreaSummary, mscVrPpIpPortRelayBroadcast=mscVrPpIpPortRelayBroadcast, mscVrPpIpPortLogicalIfOspfIfNbr=mscVrPpIpPortLogicalIfOspfIfNbr, mscVrIpRipExportNetRowStatusTable=mscVrIpRipExportNetRowStatusTable, mscVrIpRelayBCPortRelayBcUdpCount=mscVrIpRelayBCPortRelayBcUdpCount, mscVrIpBootpUsageState=mscVrIpBootpUsageState, mscVrIpRipStateEntry=mscVrIpRipStateEntry, mscVrIpOspfExtLsdbComponentName=mscVrIpOspfExtLsdbComponentName, mscVrIpArpDynHostType=mscVrIpArpDynHostType, mscVrIpEgpImport=mscVrIpEgpImport, mscVrIpTcpStorageType=mscVrIpTcpStorageType, mscVrIpRipImportNetIpAddress=mscVrIpRipImportNetIpAddress, mscVrIpTunnelSepOperEntry=mscVrIpTunnelSepOperEntry, mscVrIpIcmpInErrors=mscVrIpIcmpInErrors, mscVrIpTcpTcpEntryRemoteAddressIndex=mscVrIpTcpTcpEntryRemoteAddressIndex, mscVrPpIpPortLogicalIfOspfIfNbrPriority=mscVrPpIpPortLogicalIfOspfIfNbrPriority, mscVrIpRipImportRowStatus=mscVrIpRipImportRowStatus, mscVrIpStaticStateTable=mscVrIpStaticStateTable, mscVrIpRipStorageType=mscVrIpRipStorageType, mscVrIpFwdAge=mscVrIpFwdAge, mscVrIpEgpExportNetIndex=mscVrIpEgpExportNetIndex, mscVrPpIpPortLogicalIfOspfIfNbrOptions=mscVrPpIpPortLogicalIfOspfIfNbrOptions, mscVrPpIpPortLogicalIfRipIfNbrStorageType=mscVrPpIpPortLogicalIfRipIfNbrStorageType, mscVrPpIpPortProxyArpStatus=mscVrPpIpPortProxyArpStatus, mscVrIpOspfExtLsdbAge=mscVrIpOspfExtLsdbAge, mscVrIpOspfAggregateProvTable=mscVrIpOspfAggregateProvTable, mscVrIpUdpStatsEntry=mscVrIpUdpStatsEntry, mscVrIpUdpOutDatagrams=mscVrIpUdpOutDatagrams, mscVrIpOspfAreaOperEntry=mscVrIpOspfAreaOperEntry, mscVrPpIpPortStorageType=mscVrPpIpPortStorageType, mscVrIpOspfExportNetListIpMask=mscVrIpOspfExportNetListIpMask, mscVrIpBootp=mscVrIpBootp, mscVrIpRipExportNet=mscVrIpRipExportNet, mscVrIpRipImportProvEntry=mscVrIpRipImportProvEntry, mscVrIpArp=mscVrIpArp, mscVrIpTcpMaxConn=mscVrIpTcpMaxConn, mscVrIpEgpImportIndex=mscVrIpEgpImportIndex, mscVrIpOspfVirtIfComponentName=mscVrIpOspfVirtIfComponentName, mscVrIpRipExportBgpAsId=mscVrIpRipExportBgpAsId, mscVrIpEgpNbrProvEntry=mscVrIpEgpNbrProvEntry, mscVrIpNs=mscVrIpNs, mscVrIpOspfStubMetric=mscVrIpOspfStubMetric, mscVrIpCacheIndex=mscVrIpCacheIndex, mscVrIpTunnelSepProvTable=mscVrIpTunnelSepProvTable, mscVrPpIpPortRelayBcCount=mscVrPpIpPortRelayBcCount, mscVrIpTunnelSepIfEntryEntry=mscVrIpTunnelSepIfEntryEntry, mscVrIpBootpSnmpOperStatus=mscVrIpBootpSnmpOperStatus, mscVrPpIpPortMulticastStatus=mscVrPpIpPortMulticastStatus, mscVrPpIpPortLogicalIfOspfIfStorageType=mscVrPpIpPortLogicalIfOspfIfStorageType, mscVrPpIpPortLogicalIfOspfIfIfType=mscVrPpIpPortLogicalIfOspfIfIfType, mscVrIpArpHostProvEntry=mscVrIpArpHostProvEntry, mscVrIpOspfVirtNbrLsRetransQlen=mscVrIpOspfVirtNbrLsRetransQlen, mscVrIpEgpExportExportMetric=mscVrIpEgpExportExportMetric, mscVrIpEgpImportNetProvEntry=mscVrIpEgpImportNetProvEntry, mscVrIpOspfOperTable=mscVrIpOspfOperTable, mscVrIpBootpPpEStatsEntry=mscVrIpBootpPpEStatsEntry, mscVrIpTcpRToMin=mscVrIpTcpRToMin, mscVrIpInUnknownProtos=mscVrIpInUnknownProtos, mscVrIpFwd=mscVrIpFwd, mscVrIpOspfVirtIfHelloInterval=mscVrIpOspfVirtIfHelloInterval, mscVrIpNsRowStatusEntry=mscVrIpNsRowStatusEntry, mscVrIpBootpComponentName=mscVrIpBootpComponentName, mscVrPpIpPortLogicalIfRipIfNbrRowStatusEntry=mscVrPpIpPortLogicalIfRipIfNbrRowStatusEntry, mscVrIpStaticComponentName=mscVrIpStaticComponentName, mscVrIpOspfLsdbLsIdIndex=mscVrIpOspfLsdbLsIdIndex, mscVrPpIpPortStateEntry=mscVrPpIpPortStateEntry, mscVrIpTunnelStorageType=mscVrIpTunnelStorageType, mscVrIpIfHardwareAddress=mscVrIpIfHardwareAddress, mscVrIpIcmpStorageType=mscVrIpIcmpStorageType, mscVrIpIcmpStatsEntry=mscVrIpIcmpStatsEntry, mscVrIpIcmpOutSrcQuenchs=mscVrIpIcmpOutSrcQuenchs, mscVrIpEgpOutMsgs=mscVrIpEgpOutMsgs, mscVrIpOspfStateTable=mscVrIpOspfStateTable, mscVrIpCacheUsageState=mscVrIpCacheUsageState, mscVrIpOspfVirtIfRowStatusTable=mscVrIpOspfVirtIfRowStatusTable, mscVrIpOspfHostProvTable=mscVrIpOspfHostProvTable, mscVrPpIpPortNs=mscVrPpIpPortNs, mscVrIpOspfVirtNbrRowStatusTable=mscVrIpOspfVirtNbrRowStatusTable, mscVrIpNsApplyIndex=mscVrIpNsApplyIndex, mscVrIpOspfVirtNbrOperTable=mscVrIpOspfVirtNbrOperTable, mscVrPpIpPortLogicalIfRipIfProvEntry=mscVrPpIpPortLogicalIfRipIfProvEntry, mscVrIpCtsEntry=mscVrIpCtsEntry, mscVrIpTunnelMsepMpTable=mscVrIpTunnelMsepMpTable, mscVrPpIpPortLogicalIfOspfIfIndex=mscVrPpIpPortLogicalIfOspfIfIndex, mscVrIpRdbDestMaskIndex=mscVrIpRdbDestMaskIndex, mscVrIpStaticRouteNhRowStatusTable=mscVrIpStaticRouteNhRowStatusTable, mscVrIpArpRowStatusEntry=mscVrIpArpRowStatusEntry, mscVrIpTcpActiveOpens=mscVrIpTcpActiveOpens, mscVrIpOspfExportNetList=mscVrIpOspfExportNetList, mscVrIpIcmpOutAddrMaskReps=mscVrIpIcmpOutAddrMaskReps, mscVrIpUdpStatsTable=mscVrIpUdpStatsTable, mscVrIpRipImportNetRowStatus=mscVrIpRipImportNetRowStatus, mscVrIpTunnelRowStatusEntry=mscVrIpTunnelRowStatusEntry, mscVrIpEgpExportNetComponentName=mscVrIpEgpExportNetComponentName, mscVrPpIpPortLogicalIfOspfIf=mscVrPpIpPortLogicalIfOspfIf, mscVrIpEgpNbrStateUps=mscVrIpEgpNbrStateUps, mscVrIpEgpImportStorageType=mscVrIpEgpImportStorageType, mscVrPpIpPortBootpPStateEntry=mscVrPpIpPortBootpPStateEntry, mscVrIpOspfLsdbStorageType=mscVrIpOspfLsdbStorageType, mscVrIpOspfExtLsdbRowStatusEntry=mscVrIpOspfExtLsdbRowStatusEntry, mscVrIpOspfExportEgpAsId=mscVrIpOspfExportEgpAsId, mscVrIpBootpPpEOperEntry=mscVrIpBootpPpEOperEntry, mscVrPpIpPortLogicalIfOspfIfNbrRowStatusTable=mscVrPpIpPortLogicalIfOspfIfNbrRowStatusTable, mscVrIpEgpStorageType=mscVrIpEgpStorageType, mscVrPpIpPortArpStatus=mscVrPpIpPortArpStatus, mscVrIpOspfStubProvTable=mscVrIpOspfStubProvTable, mscVrIpOspfAggregate=mscVrIpOspfAggregate, mscVrIpOspfVirtNbrNbrIpAddress=mscVrIpOspfVirtNbrNbrIpAddress, mscVrIpArpHostEncap=mscVrIpArpHostEncap, mscVrIpOspfExtLsdb=mscVrIpOspfExtLsdb, mscVrPpIpPortAssignedQos=mscVrPpIpPortAssignedQos, mscVrIpEgpNbrDefaultRouteMetric=mscVrIpEgpNbrDefaultRouteMetric, mscVrPpIpPortLogicalIfOspfIfTOSProvTable=mscVrPpIpPortLogicalIfOspfIfTOSProvTable, mscVrIpEgpAsId=mscVrIpEgpAsId, mscVrIpRdbPreference=mscVrIpRdbPreference, mscVrIpForwDatagrams=mscVrIpForwDatagrams, mscVrIpRipExportNetRowStatus=mscVrIpRipExportNetRowStatus, mscVrIpTcpTcpEntry=mscVrIpTcpTcpEntry, mscVrIpRipOperStatusTable=mscVrIpRipOperStatusTable, mscVrIpTunnelSepSourceAddress=mscVrIpTunnelSepSourceAddress, mscVrIpBootpPpEOperTable=mscVrIpBootpPpEOperTable, ipMIB=ipMIB, mscVrPpIpPortLogicalIfOspfIfRowStatusTable=mscVrPpIpPortLogicalIfOspfIfRowStatusTable, mscVrIpTunnelSepIfIndex=mscVrIpTunnelSepIfIndex, mscVrIpIcmpOutMsgs=mscVrIpIcmpOutMsgs, mscVrPpIpPortLogicalIfOspfIfSnmpAdminStatus=mscVrPpIpPortLogicalIfOspfIfSnmpAdminStatus, mscVrPpIpPortBootpPInReplyErrors=mscVrPpIpPortBootpPInReplyErrors, mscVrIpStaticRowStatusTable=mscVrIpStaticRowStatusTable, mscVrIpRoutingDiscards=mscVrIpRoutingDiscards, mscVrPpIpPortRelayAddressCount=mscVrPpIpPortRelayAddressCount, mscVrIpRipExportOutInterface=mscVrIpRipExportOutInterface, mscVrIpRipRowStatus=mscVrIpRipRowStatus, mscVrIpTunnelSepRowStatus=mscVrIpTunnelSepRowStatus, mscVrIpArpRowStatus=mscVrIpArpRowStatus, mscVrPpIpPortLogicalIfOspfIfNbrPermanance=mscVrPpIpPortLogicalIfOspfIfNbrPermanance, mscVrIpIfInterfaceAddressIndex=mscVrIpIfInterfaceAddressIndex, mscVrPpIpPortLogicalIfOspfIfOperTable=mscVrPpIpPortLogicalIfOspfIfOperTable, mscVrIpRipExportNetIpMask=mscVrIpRipExportNetIpMask, mscVrIpIfRowStatusEntry=mscVrIpIfRowStatusEntry, mscVrIpEgpExportAdvertiseStatus=mscVrIpEgpExportAdvertiseStatus, mscVrIpOspfExportRipInterface=mscVrIpOspfExportRipInterface, mscVrIpStaticRouteNhRowStatus=mscVrIpStaticRouteNhRowStatus, mscVrIpRelayBCRelayNdStatus=mscVrIpRelayBCRelayNdStatus, mscVrIpStaticRouteNhStorageType=mscVrIpStaticRouteNhStorageType, mscVrIpUdpRowStatusEntry=mscVrIpUdpRowStatusEntry, mscVrIpUdpListenEntry=mscVrIpUdpListenEntry, mscVrIpOutDiscards=mscVrIpOutDiscards, mscVrIpRipRowStatusEntry=mscVrIpRipRowStatusEntry, mscVrPpIpPortLogicalIfLinkDestinationAddress=mscVrPpIpPortLogicalIfLinkDestinationAddress, mscVrPpIpPortBootpPAdminControlEntry=mscVrPpIpPortBootpPAdminControlEntry, mscVrIpComponentName=mscVrIpComponentName, mscVrIpEgpSnmpOperStatus=mscVrIpEgpSnmpOperStatus, mscVrIpArpDynHostRowStatusEntry=mscVrIpArpDynHostRowStatusEntry, mscVrIpNsApplyProvisionedTable=mscVrIpNsApplyProvisionedTable, mscVrIpTcpTcpEntryRemotePortIndex=mscVrIpTcpTcpEntryRemotePortIndex, mscVrPpIpPortLogicalIfOspfIfProvEntry=mscVrPpIpPortLogicalIfOspfIfProvEntry, mscVrIpNsComponentName=mscVrIpNsComponentName, mscVrIpTcpStatsEntry=mscVrIpTcpStatsEntry, mscVrIpEgpImportNet=mscVrIpEgpImportNet, mscVrIpFwdOperTable=mscVrIpFwdOperTable, mscVrPpIpPortLogicalIfOspfIfNbrRtrId=mscVrPpIpPortLogicalIfOspfIfNbrRtrId, mscVrIpOspfExportComponentName=mscVrIpOspfExportComponentName, mscVrIpIf=mscVrIpIf, mscVrIpEgpNbrInErrorMsgs=mscVrIpEgpNbrInErrorMsgs, mscVrPpIpPortRowStatusTable=mscVrPpIpPortRowStatusTable, mscVrIpRdbDestAddressIndex=mscVrIpRdbDestAddressIndex, mscVrIpOspfAggregateEffect=mscVrIpOspfAggregateEffect, mscVrIpStaticRouteDestAddressIndex=mscVrIpStaticRouteDestAddressIndex, mscVrIpStaticDiscardComponentName=mscVrIpStaticDiscardComponentName, mscVrPpIpPortBootpPStateTable=mscVrPpIpPortBootpPStateTable, mscVrIpStaticDiscardRowStatus=mscVrIpStaticDiscardRowStatus, mscVrIpTcpRetransSegs=mscVrIpTcpRetransSegs, mscVrIpStaticDiscardStorageType=mscVrIpStaticDiscardStorageType, mscVrIpArpHostComponentName=mscVrIpArpHostComponentName, mscVrIpDefaultTtl=mscVrIpDefaultTtl, mscVrPpIpPortLogicalIfOspfIfNbrState=mscVrPpIpPortLogicalIfOspfIfNbrState, mscVrIpEgpNbrInErrors=mscVrIpEgpNbrInErrors, mscVrPpIpPortLanModel=mscVrPpIpPortLanModel, mscVrIpOspfAsBdrRtrStatus=mscVrIpOspfAsBdrRtrStatus)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-IpMIB", mscVrIpNsApplyIpAddress2=mscVrIpNsApplyIpAddress2, mscVrIpOspfVirtIfNbrRouterIdIndex=mscVrIpOspfVirtIfNbrRouterIdIndex, mscVrIpArpAutoRefresh=mscVrIpArpAutoRefresh, mscVrIpArpDynHostPermanentVirtualCircuitNumber=mscVrIpArpDynHostPermanentVirtualCircuitNumber, mscVrIpIfComponentName=mscVrIpIfComponentName, mscVrIpUdpRowStatusTable=mscVrIpUdpRowStatusTable, mscVrIpEgpImportRowStatusTable=mscVrIpEgpImportRowStatusTable, mscVrIpTcpTcpEntryRowStatusTable=mscVrIpTcpTcpEntryRowStatusTable, mscVrIpRip=mscVrIpRip, mscVrIpArpHostPhysAddress=mscVrIpArpHostPhysAddress, mscVrIpIcmpOutParmProbs=mscVrIpIcmpOutParmProbs, mscVrIpFwdDestAddressIndex=mscVrIpFwdDestAddressIndex, mscVrIpRipImportRowStatusTable=mscVrIpRipImportRowStatusTable, mscVrIpTunnelSepRowStatusTable=mscVrIpTunnelSepRowStatusTable, mscVrIpIfNcHardwareAddress=mscVrIpIfNcHardwareAddress, mscVrPpIpPortLogicalIfRowStatusTable=mscVrPpIpPortLogicalIfRowStatusTable, mscVrIpArpHostRowStatusTable=mscVrIpArpHostRowStatusTable, mscVrIpEgpNbrComponentName=mscVrIpEgpNbrComponentName, mscVrPpIpPortLogicalIfRipIfIfConfReceive=mscVrPpIpPortLogicalIfRipIfIfConfReceive, mscVrPpIpPortOperStatusTable=mscVrPpIpPortOperStatusTable, mscVrIpArpProvTable=mscVrIpArpProvTable, mscVrPpIpPortLogicalIfOspfIfTOSStorageType=mscVrPpIpPortLogicalIfOspfIfTOSStorageType, mscVrIpIfOperTable=mscVrIpIfOperTable, mscVrIpEgpOperationalState=mscVrIpEgpOperationalState, mscVrPpIpPortNsRowStatusTable=mscVrPpIpPortNsRowStatusTable, mscVrIpRipExportNetIndex=mscVrIpRipExportNetIndex, mscVrIpIcmpInAddrMaskReps=mscVrIpIcmpInAddrMaskReps, mscVrIpEgpExportRowStatusEntry=mscVrIpEgpExportRowStatusEntry, mscVrIpUdpListenEntryRowStatusEntry=mscVrIpUdpListenEntryRowStatusEntry, mscVrIpEgpExportOutAutonomousSystem=mscVrIpEgpExportOutAutonomousSystem, mscVrIpStaticDiscardDestMaskIndex=mscVrIpStaticDiscardDestMaskIndex, mscVrIpIcmpInTimestamps=mscVrIpIcmpInTimestamps, mscVrIpTunnelMsep=mscVrIpTunnelMsep, mscVrPpIpPortLogicalIfOspfIfMetricTable=mscVrPpIpPortLogicalIfOspfIfMetricTable, mscVrIpRipExportIndex=mscVrIpRipExportIndex, mscVrPpIpPortNsRowStatusEntry=mscVrPpIpPortNsRowStatusEntry, mscVrIpOspfVirtNbrOptions=mscVrIpOspfVirtNbrOptions, mscVrIpEgpNbrRowStatusTable=mscVrIpEgpNbrRowStatusTable, mscVrPpIpPortLogicalIfOspfIfTOSComponentName=mscVrPpIpPortLogicalIfOspfIfTOSComponentName, mscVrIpOspfNbrRowStatusTable=mscVrIpOspfNbrRowStatusTable, mscVrIpRdbAge=mscVrIpRdbAge, mscVrIpOspfExtLsdbChecksum=mscVrIpOspfExtLsdbChecksum, mscVrIpOspfStubRowStatusTable=mscVrIpOspfStubRowStatusTable, mscVrPpIpPortEncap=mscVrPpIpPortEncap, mscVrIpRipProvTable=mscVrIpRipProvTable, mscVrPpIpPortLogicalIfProvTable=mscVrPpIpPortLogicalIfProvTable, mscVrIpArpRowStatusTable=mscVrIpArpRowStatusTable, mscVrPpIpPortBootpPSnmpAdminStatus=mscVrPpIpPortBootpPSnmpAdminStatus, mscVrPpIpPortLogicalIfRipIfIfConfSend=mscVrPpIpPortLogicalIfRipIfIfConfSend, mscVrIpBootpProvTable=mscVrIpBootpProvTable, mscVrIpForwarding=mscVrIpForwarding, mscVrIpEgpNbrStateDowns=mscVrIpEgpNbrStateDowns, mscVrIpBootpRowStatus=mscVrIpBootpRowStatus, mscVrIpFwdRowStatus=mscVrIpFwdRowStatus, mscVrIpOspf=mscVrIpOspf, mscVrIpIfStatus=mscVrIpIfStatus, mscVrIpEgpImportProvTable=mscVrIpEgpImportProvTable, mscVrIpIcmpStatsTable=mscVrIpIcmpStatsTable, mscVrIpEgpAdminState=mscVrIpEgpAdminState, mscVrIpRipRowStatusTable=mscVrIpRipRowStatusTable, mscVrIpEgpExportRowStatusTable=mscVrIpEgpExportRowStatusTable, mscVrIpRipExportOspfTag=mscVrIpRipExportOspfTag, mscVrIpRipExportComponentName=mscVrIpRipExportComponentName, mscVrIpOspfAdminState=mscVrIpOspfAdminState, mscVrIpFwdOperEntry=mscVrIpFwdOperEntry, mscVrIpTcpAttemptFails=mscVrIpTcpAttemptFails, mscVrPpIpPortSnmpAdminStatus=mscVrPpIpPortSnmpAdminStatus, mscVrIpRdbMetric=mscVrIpRdbMetric, mscVrIpTunnelSepProvEntry=mscVrIpTunnelSepProvEntry, mscVrIpStaticRowStatus=mscVrIpStaticRowStatus, mscVrIpTunnelMsepRowStatusTable=mscVrIpTunnelMsepRowStatusTable, mscVrPpIpPortLogicalIfOspfIfState=mscVrPpIpPortLogicalIfOspfIfState, mscVrIpEgpImportNetRowStatusEntry=mscVrIpEgpImportNetRowStatusEntry, mscVrPpIpPortUsageState=mscVrPpIpPortUsageState, mscVrIpStaticUsageState=mscVrIpStaticUsageState, mscVrIpTunnelMsepIfEntryTable=mscVrIpTunnelMsepIfEntryTable, mscVrIpRipQueryResponses=mscVrIpRipQueryResponses, mscVrPpIpPortLogicalIfRipIfIndex=mscVrPpIpPortLogicalIfRipIfIndex, mscVrIpOspfVirtIfProvTable=mscVrIpOspfVirtIfProvTable, mscVrIpStaticStorageType=mscVrIpStaticStorageType, mscVrIpRipImportInterface=mscVrIpRipImportInterface, mscVrIpOspfAggregateRowStatusTable=mscVrIpOspfAggregateRowStatusTable, mscVrPpIpPortIcmpMaskReply=mscVrPpIpPortIcmpMaskReply, mscVrIpOspfVirtNbrOperEntry=mscVrIpOspfVirtNbrOperEntry, mscVrIpEgpImportNetRowStatusTable=mscVrIpEgpImportNetRowStatusTable, mscVrIpNsFirstFilter=mscVrIpNsFirstFilter, mscVrIpEgpExportOspfTag=mscVrIpEgpExportOspfTag, mscVrIpOspfExportNetListRowStatusEntry=mscVrIpOspfExportNetListRowStatusEntry, mscVrIpIcmpSendHostUnreachable=mscVrIpIcmpSendHostUnreachable, mscVrIpArpDynHostIfIndex=mscVrIpArpDynHostIfIndex, mscVrPpIpPortBootpPAddrEntry=mscVrPpIpPortBootpPAddrEntry, mscVrIpRelayBCStorageType=mscVrIpRelayBCStorageType, mscVrIpOspfExportNetListProvEntry=mscVrIpOspfExportNetListProvEntry, mscVrIpStaticRouteNhProvEntry=mscVrIpStaticRouteNhProvEntry, mscVrIpEgpDefaultPollInterval=mscVrIpEgpDefaultPollInterval, mscVrIpRipImportNetRowStatusTable=mscVrIpRipImportNetRowStatusTable, mscVrIpTcpRowStatusTable=mscVrIpTcpRowStatusTable, mscVrIpAdminControlEntry=mscVrIpAdminControlEntry, mscVrIpRipOperationalState=mscVrIpRipOperationalState, mscVrIpOspfExtLsdbOperEntry=mscVrIpOspfExtLsdbOperEntry, mscVrIpOspfVirtNbrState=mscVrIpOspfVirtNbrState, mscVrIpIcmpInEchoReps=mscVrIpIcmpInEchoReps, mscVrIpEgpImportNbrAsId=mscVrIpEgpImportNbrAsId, mscVrIpArpHostStorageType=mscVrIpArpHostStorageType, mscVrIpReasmTimeOut=mscVrIpReasmTimeOut, mscVrPpIpPortLogicalIfRipIfNbr=mscVrPpIpPortLogicalIfRipIfNbr, mscVrIpOspfNbrNbmaNbrStatus=mscVrIpOspfNbrNbmaNbrStatus, mscVrIpTunnelSepMpEntry=mscVrIpTunnelSepMpEntry, mscVrIpOspfHostMetric=mscVrIpOspfHostMetric, mscVrIpEgpRowStatusTable=mscVrIpEgpRowStatusTable, mscVrIpOspfOperEntry=mscVrIpOspfOperEntry, mscVrIpRelayBCProvEntry=mscVrIpRelayBCProvEntry, mscVrIpOspfLsdbOperEntry=mscVrIpOspfLsdbOperEntry, mscVrIpInDelivers=mscVrIpInDelivers, mscVrIpIcmpOutTimeExcds=mscVrIpIcmpOutTimeExcds, mscVrIpBootpProvEntry=mscVrIpBootpProvEntry, mscVrIpTcpRowStatus=mscVrIpTcpRowStatus, mscVrIpTcpRToMax=mscVrIpTcpRToMax, mscVrIpOspfNbrPermanence=mscVrIpOspfNbrPermanence, mscVrIpBootpStorageType=mscVrIpBootpStorageType, mscVrIpTcpTcpEntryRowStatus=mscVrIpTcpTcpEntryRowStatus, mscVrIpRipExportNetRowStatusEntry=mscVrIpRipExportNetRowStatusEntry, mscVrIpStaticRouteRowStatusTable=mscVrIpStaticRouteRowStatusTable, mscVrIpArpDynHostCosIndex=mscVrIpArpDynHostCosIndex, mscVrIpTunnelSepRowStatusEntry=mscVrIpTunnelSepRowStatusEntry, mscVrPpIpPortOperEncap=mscVrPpIpPortOperEncap, mscVrIpArpHostMaxTxUnit=mscVrIpArpHostMaxTxUnit, mscVrPpIpPortLogicalIfRipIfSnmpAdminStatus=mscVrPpIpPortLogicalIfRipIfSnmpAdminStatus, mscVrPpIpPortAdminControlTable=mscVrPpIpPortAdminControlTable, mscVrIpStatic=mscVrIpStatic, mscVrIpOspfExportAdvertiseStatus=mscVrIpOspfExportAdvertiseStatus, mscVrIpRelayBCPortOperEntry=mscVrIpRelayBCPortOperEntry, mscVrIpBootpPpEInReplies=mscVrIpBootpPpEInReplies, mscVrIpTunnelMsepIfIndex=mscVrIpTunnelMsepIfIndex, mscVrIpBootpPpE=mscVrIpBootpPpE, mscVrPpIpPortLogicalIfOspfIfNbrEvents=mscVrPpIpPortLogicalIfOspfIfNbrEvents, mscVrPpIpPortLogicalIfOspfIfDesignatedRouter=mscVrPpIpPortLogicalIfOspfIfDesignatedRouter, ipCapabilitiesCA02A=ipCapabilitiesCA02A, mscVrIpOspfArea=mscVrIpOspfArea, mscVrIpEgpImportRowStatusEntry=mscVrIpEgpImportRowStatusEntry, mscVrPpIpPortLogicalIfOspfIfNbrOperEntry=mscVrPpIpPortLogicalIfOspfIfNbrOperEntry, mscVrPpIpPortProvTable=mscVrPpIpPortProvTable, mscVrIpRipExportNetProvEntry=mscVrIpRipExportNetProvEntry, mscVrIpRipImportIndex=mscVrIpRipImportIndex, mscVrIpTunnelMsepSourceAddress=mscVrIpTunnelMsepSourceAddress, mscVrIpOspfVirtNbrAreaIdIndex=mscVrIpOspfVirtNbrAreaIdIndex, mscVrPpIpPortLogicalIfOspfIfNbrOperTable=mscVrPpIpPortLogicalIfOspfIfNbrOperTable, mscVrPpIpPortBootpPAddrRowStatus=mscVrPpIpPortBootpPAddrRowStatus, mscVrIpOspfAreaBdrRtrStatus=mscVrIpOspfAreaBdrRtrStatus, mscVrIpUdpStorageType=mscVrIpUdpStorageType, mscVrIpRipImportRowStatusEntry=mscVrIpRipImportRowStatusEntry, mscVrIpStaticDiscardDestAddressIndex=mscVrIpStaticDiscardDestAddressIndex, mscVrIpStateTable=mscVrIpStateTable, mscVrIpRipAdminState=mscVrIpRipAdminState, mscVrPpIpPortLogicalIfOspfIfRtrPriority=mscVrPpIpPortLogicalIfOspfIfRtrPriority, mscVrPpIpPortBootpPRowStatusTable=mscVrPpIpPortBootpPRowStatusTable, mscVrIpRdbComponentName=mscVrIpRdbComponentName, mscVrIpOspfMulticastForward=mscVrIpOspfMulticastForward, mscVrIpEgpExportStorageType=mscVrIpEgpExportStorageType, mscVrPpIpPortLogicalIfRipIfMetric=mscVrPpIpPortLogicalIfRipIfMetric, mscVrIpRdbRowStatusTable=mscVrIpRdbRowStatusTable, mscVrIpEgpExportNetStorageType=mscVrIpEgpExportNetStorageType, mscVrIpStaticRouteDestMaskIndex=mscVrIpStaticRouteDestMaskIndex, mscVrIpTunnelMsepStorageType=mscVrIpTunnelMsepStorageType, mscVrPpIpPortBootpPOperationalState=mscVrPpIpPortBootpPOperationalState, mscVrIpCacheLookupMisses=mscVrIpCacheLookupMisses, mscVrIpArpIndex=mscVrIpArpIndex, mscVrIpOspfAreaOperTable=mscVrIpOspfAreaOperTable, mscVrIpNsApplyDirection=mscVrIpNsApplyDirection, mscVrIpOspfExtLsdbRowStatus=mscVrIpOspfExtLsdbRowStatus, ipCapabilities=ipCapabilities, mscVrIpBootpPpEInRequests=mscVrIpBootpPpEInRequests, mscVrPpIpPortLogicalIfRipIf=mscVrPpIpPortLogicalIfRipIf, mscVrPpIpPortRelayBcOperTable=mscVrPpIpPortRelayBcOperTable, mscVrIpOspfHostRowStatusTable=mscVrIpOspfHostRowStatusTable, mscVrIpRipExportRowStatusEntry=mscVrIpRipExportRowStatusEntry, mscVrIpIfPPName=mscVrIpIfPPName, mscVrIpTunnelSepOperTable=mscVrIpTunnelSepOperTable, mscVrPpIpPortBootpPRelayForwardStatus=mscVrPpIpPortBootpPRelayForwardStatus, mscVrIpIcmpOutTimestamps=mscVrIpIcmpOutTimestamps, mscVrIpBootpHopDiscardThreshold=mscVrIpBootpHopDiscardThreshold, mscVrIpOspfStateEntry=mscVrIpOspfStateEntry, mscVrIpOperStatusTable=mscVrIpOperStatusTable, mscVrIpOspfOperStatusEntry=mscVrIpOspfOperStatusEntry, mscVrIpTunnelOperationalState=mscVrIpTunnelOperationalState, mscVrIpOspfVirtNbrExchangeStatus=mscVrIpOspfVirtNbrExchangeStatus, mscVrPpIpPortOperEntry=mscVrPpIpPortOperEntry, mscVrIpArpProvEntry=mscVrIpArpProvEntry, mscVrPpIpPortLogicalIfOspfIfTOSRowStatusTable=mscVrPpIpPortLogicalIfOspfIfTOSRowStatusTable, mscVrIpInReceives=mscVrIpInReceives, mscVrIpOspfRowStatus=mscVrIpOspfRowStatus, mscVrPpIpPortLogicalIfOspfIfTOSMetricTosIndex=mscVrPpIpPortLogicalIfOspfIfTOSMetricTosIndex, mscVrPpIpPortLogicalIfRipIfFlashUpdateFlag=mscVrPpIpPortLogicalIfRipIfFlashUpdateFlag, mscVrPpIpPortBootpPInRequests=mscVrPpIpPortBootpPInRequests, mscVrIpArpHostOperEncap=mscVrIpArpHostOperEncap, mscVrIpTunnelIndex=mscVrIpTunnelIndex, mscVrIpCacheEntriesFree=mscVrIpCacheEntriesFree, mscVrPpIpPortLogicalIfRipIfSilentFlag=mscVrPpIpPortLogicalIfRipIfSilentFlag, mscVrIpOspfAggregateAggregateMaskIndex=mscVrIpOspfAggregateAggregateMaskIndex, mscVrIpOspfExportNetListRowStatus=mscVrIpOspfExportNetListRowStatus, mscVrIpEgpNbrHelloInterval=mscVrIpEgpNbrHelloInterval, mscVrPpIpPortOperMtu=mscVrPpIpPortOperMtu, mscVrIpIfRowStatusTable=mscVrIpIfRowStatusTable, mscVrIpTunnelSepDiscoveredPathMtu=mscVrIpTunnelSepDiscoveredPathMtu, mscVrIpOspfExternLsaCount=mscVrIpOspfExternLsaCount, mscVrIpIcmpOutRtrAdvs=mscVrIpIcmpOutRtrAdvs, mscVrIpNsLastFilter=mscVrIpNsLastFilter, mscVrIpUdpListenEntryStorageType=mscVrIpUdpListenEntryStorageType, mscVrIpOspfAreaRowStatusTable=mscVrIpOspfAreaRowStatusTable, mscVrIpCacheOperTable=mscVrIpCacheOperTable, mscVrIpRowStatusTable=mscVrIpRowStatusTable, mscVrIpFwdTypeOfServiceIndex=mscVrIpFwdTypeOfServiceIndex, mscVrIpFwdProtocolPortName=mscVrIpFwdProtocolPortName, mscVrPpIpPortLogicalIfProvEntry=mscVrPpIpPortLogicalIfProvEntry, mscVrIpTcp=mscVrIpTcp, mscVrPpIpPortBootpPIndex=mscVrPpIpPortBootpPIndex, mscVrPpIpPortLogicalIfOspfIfRowStatus=mscVrPpIpPortLogicalIfOspfIfRowStatus, mscVrIpOspfVersionNumber=mscVrIpOspfVersionNumber, mscVrIpIfBroadcastAddress=mscVrIpIfBroadcastAddress, mscVrIpOspfExportNetListProvTable=mscVrIpOspfExportNetListProvTable, mscVrIp=mscVrIp, mscVrIpOspfAggregateComponentName=mscVrIpOspfAggregateComponentName, mscVrPpIpPortLogicalIfOspfIfNbrRowStatusEntry=mscVrPpIpPortLogicalIfOspfIfNbrRowStatusEntry, mscVrIpRipComponentName=mscVrIpRipComponentName, mscVrIpTunnelMsepComponentName=mscVrIpTunnelMsepComponentName, mscVrIpInDiscards=mscVrIpInDiscards, mscVrIpEgpNbrMode=mscVrIpEgpNbrMode, mscVrIpOspfLsdbComponentName=mscVrIpOspfLsdbComponentName, mscVrIpRelayBCPortRowStatusTable=mscVrIpRelayBCPortRowStatusTable, mscVrIpEgpAdminControlTable=mscVrIpEgpAdminControlTable, mscVrPpIpPortBootpPUsageState=mscVrPpIpPortBootpPUsageState, mscVrIpStaticIndex=mscVrIpStaticIndex, mscVrIpStaticRoute=mscVrIpStaticRoute, mscVrIpBootpSnmpAdminStatus=mscVrIpBootpSnmpAdminStatus, mscVrPpIpPortBootpPComponentName=mscVrPpIpPortBootpPComponentName, mscVrIpIcmpInRtrSolicits=mscVrIpIcmpInRtrSolicits, mscVrIpOspfNbrPriority=mscVrIpOspfNbrPriority, mscVrIpRdbOperTable=mscVrIpRdbOperTable, mscVrIpUdpNoPorts=mscVrIpUdpNoPorts, mscVrPpIpPortBootpPStatsEntry=mscVrPpIpPortBootpPStatsEntry, mscVrIpStaticRouteRowStatusEntry=mscVrIpStaticRouteRowStatusEntry, mscVrIpBootpPpERowStatusEntry=mscVrIpBootpPpERowStatusEntry, mscVrIpStaticRowStatusEntry=mscVrIpStaticRowStatusEntry, mscVrPpIpPortNsOutgoingFilter=mscVrPpIpPortNsOutgoingFilter, mscVrIpCacheOperEntry=mscVrIpCacheOperEntry, mscVrIpEgpIndex=mscVrIpEgpIndex, mscVrIpReasmOks=mscVrIpReasmOks, mscVrIpArpHostRowStatusEntry=mscVrIpArpHostRowStatusEntry, mscVrIpOspfExtLsdbLsIdIndex=mscVrIpOspfExtLsdbLsIdIndex, mscVrIpTunnelMsepDstEntry=mscVrIpTunnelMsepDstEntry, mscVrIpEgpImportNetIpAddress=mscVrIpEgpImportNetIpAddress, mscVrIpArpHostOperEntry=mscVrIpArpHostOperEntry, mscVrIpTunnelMsepDstRowStatus=mscVrIpTunnelMsepDstRowStatus, mscVrIpOspfVirtIfOperEntry=mscVrIpOspfVirtIfOperEntry)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-IpMIB", ipGroupCA02=ipGroupCA02, mscVrPpIpPortOperArpStatus=mscVrPpIpPortOperArpStatus, mscVrIpOspfExportStorageType=mscVrIpOspfExportStorageType, mscVrIpTunnelSepStorageType=mscVrIpTunnelSepStorageType, mscVrIpArpStorageType=mscVrIpArpStorageType, mscVrIpOspfExportProvTable=mscVrIpOspfExportProvTable, mscVrIpEgpNbr=mscVrIpEgpNbr, mscVrIpOperStatusEntry=mscVrIpOperStatusEntry, mscVrIpEgpOperStatusTable=mscVrIpEgpOperStatusTable, mscVrPpIpPortLogicalIf=mscVrPpIpPortLogicalIf, mscVrPpIpPortNsStorageType=mscVrPpIpPortNsStorageType, mscVrPpIpPortLogicalIfOspfIfTOSTosMetric=mscVrPpIpPortLogicalIfOspfIfTOSTosMetric, mscVrPpIpPortBootpPOperStatusTable=mscVrPpIpPortBootpPOperStatusTable, mscVrIpStaticRouteStorageType=mscVrIpStaticRouteStorageType, mscVrIpOspfExportRowStatusTable=mscVrIpOspfExportRowStatusTable, mscVrIpOspfExportNetListIpAddress=mscVrIpOspfExportNetListIpAddress, mscVrIpStaticRouteTypeOfServiceIndex=mscVrIpStaticRouteTypeOfServiceIndex, mscVrIpOspfVirtNbrEvents=mscVrIpOspfVirtNbrEvents, mscVrIpUdpRowStatus=mscVrIpUdpRowStatus, mscVrIpCache=mscVrIpCache, mscVrPpIpPortDirectedBroadcast=mscVrPpIpPortDirectedBroadcast, mscVrIpOspfVirtIfRtrDeadInterval=mscVrIpOspfVirtIfRtrDeadInterval, mscVrIpRipImportNetProvEntry=mscVrIpRipImportNetProvEntry, mscVrIpTunnelRowStatusTable=mscVrIpTunnelRowStatusTable, mscVrIpEgpNbrOperTable=mscVrIpEgpNbrOperTable, mscVrIpOspfProvTable=mscVrIpOspfProvTable, mscVrIpIcmpOutEchoReps=mscVrIpIcmpOutEchoReps, mscVrPpIpPortLogicalIfRipIfProvTable=mscVrPpIpPortLogicalIfRipIfProvTable, mscVrIpTcpComponentName=mscVrIpTcpComponentName, mscVrIpOutRequests=mscVrIpOutRequests, mscVrIpIcmpInSrcQuenchs=mscVrIpIcmpInSrcQuenchs, mscVrIpEgpExportRipInterface=mscVrIpEgpExportRipInterface, mscVrIpOspfAreaAreaIdIndex=mscVrIpOspfAreaAreaIdIndex, mscVrIpTunnelSepMpTable=mscVrIpTunnelSepMpTable, mscVrPpIpPortNsIncomingFilter=mscVrPpIpPortNsIncomingFilter, mscVrIpTcpEstabResets=mscVrIpTcpEstabResets, mscVrIpIcmpOutTimestampReps=mscVrIpIcmpOutTimestampReps, mscVrPpIpPortSendRedirect=mscVrPpIpPortSendRedirect, mscVrIpOspfNbrRowStatus=mscVrIpOspfNbrRowStatus, mscVrIpStaticRouteRowStatus=mscVrIpStaticRouteRowStatus)

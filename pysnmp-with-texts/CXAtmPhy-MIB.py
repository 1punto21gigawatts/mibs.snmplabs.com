#
# PySNMP MIB module CXAtmPhy-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CXAtmPhy-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:32:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint")
cxAtmPhy, = mibBuilder.importSymbols("CXProduct-SMI", "cxAtmPhy")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, Counter64, iso, TimeTicks, ModuleIdentity, IpAddress, Counter32, Unsigned32, Bits, Gauge32, MibIdentifier, Integer32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "Counter64", "iso", "TimeTicks", "ModuleIdentity", "IpAddress", "Counter32", "Unsigned32", "Bits", "Gauge32", "MibIdentifier", "Integer32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class Switch(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("disabled", 1), ("enabled", 2))

class ErrorState(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("errorNotDetected", 1), ("errorDetected", 2))

atmPhyMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyMibLevel.setDescription('Used to determine current MIB module release supported by agent. Object is in decimal.')
atmPhyInterfaceConfTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10), )
if mibBuilder.loadTexts: atmPhyInterfaceConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyInterfaceConfTable.setDescription('A table containing information pertaining to one ATM PHY interface.')
atmPhyInterfaceConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmPhyInterfaceConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyInterfaceConfEntry.setDescription('Defines an entry in the ATM PHY interface table.')
atmPhyConfTxClocking = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("synchronized", 1), ("unsynchronized", 2))).clone('synchronized')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfTxClocking.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfTxClocking.setDescription("Defines how the physical line's transmit clock will be derived. For DS1 and E1 ATM implementations, this object defines the interface clocking, and the corresponding clocking object at the DS1 and E1 layer becomes ineffective. This is contrary to non-ATM implementations where it is the clocking object at the DS1 and E1 layer that defines the interface clocking. Options: synchronized (1): The transmit clock will be derived from the receive clock. This is more commonly referred to as 'loop' timing. unsynchronized (2): The transmit clock will be derived internally from an oscillator, and will not be synchronized to the receive clock.")
atmPhyConfRxLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("line", 2), ("cell", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfRxLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfRxLoopback.setDescription('Defines the type of loopback mode. Options: none (1): Normal operating mode. All received cells are sent to the ATM layer. line (2): All received cells are re-transmitted immediately. Received cells are not processed and are not sent to the ATM layer. This setting has no effect for E1 cards. cell (3): All received cells are first processed and then passed to the transmitter to be sent back out. Received cells are not sent to the ATM layer.')
atmPhyConfFrameFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("g-804", 1), ("plcp", 2))).clone('g-804')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfFrameFormat.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfFrameFormat.setDescription('Defines the type of framing used at this interface. Options: g-804 (1): ATM direct cell mapping as per ITU Recommendation G.804. plcp (2): ATM Physical Layer Convergence Protocol (PLCP) cell mapping as per Bellcore TR-TSV-000773.')
atmPhyConfPlcpBypass = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 4), Switch().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfPlcpBypass.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfPlcpBypass.setDescription("Defines whether all internal FIFOs are bypassed when this interface is configured for the PLCP framing format (object atmPhyConfFrameFormat value 'atmPlcp'). FIFO bypass can be used to reduce latency at this interface (through the PHY device). This object will take on value 'disabled' in the initial phase since the ATM layer does not support cell rate decoupling, and idle/unassigned cell processing.")
atmPhyConfTxCoset = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 5), Switch().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfTxCoset.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfTxCoset.setDescription("Defines whether the coset polynomial is applied to the HCS octet of transmitted cells. If 'enabled', the polynomial X^6+X^4+X^2+1 is added to the HCS octet of each cell prior to transmission as required by the ATM Forum UNI specification. The coset function prevents the HCS octet within a cell from taking on a zero value. ")
atmPhyConfRxCoset = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 6), Switch().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfRxCoset.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfRxCoset.setDescription("Defines whether the coset polynomial is applied to the HCS octet of received cells before comparisons. If 'enabled', the polynomial X^6+X^4+X^2+1 is removed from the HCS octet of each received cells before comparison with the calculated result as required by the ATM Forum UNI specification. The coset function prevents the HCS octet within a cell from taking on a zero value. ")
atmPhyConfCellScrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 7), Switch().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfCellScrambling.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfCellScrambling.setDescription("Defines whether the cell payload scrambling is applied to transmitted cells at this interface. If 'enabled', cell payloads are scrambled using the self synchronizing polynomial X^43+1. If 'disabled', cell payloads are transmitted unscrambled.")
atmPhyConfCellDescrambling = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 8), Switch().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfCellDescrambling.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfCellDescrambling.setDescription("Defines whether received cell payloads are descrambled. If 'enabled', received cell payloads are descrambled using the self synchronizing polynomial X^43+1. If 'disabled', cell payload are not descrambled.")
atmPhyConfTxFifoDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfTxFifoDepth.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfTxFifoDepth.setDescription('Defines the size of the transmit FIFO in cells. Reducing the FIFO depth permits cell latencies to be minimized at this interface (through the PHY device). It is not recommended that the FIFO depth be set to 1 cell, since half the bandwidth will be lost to idle/unassigned cells. For minimum latency and maximum throughput, a FIFO depth of 2 cells is suggested..')
atmPhyConfRxUserProgH1Mask = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfRxUserProgH1Mask.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfRxUserProgH1Mask.setDescription('Defines the bit mask pattern for the first octet (H1) of a received cell. For each mask bit that is set, the PHY will process received cells with the corresponding bit(s) set in the H1 octet. For each mask bit that is reset, the PHY will discard received cells with the corresponding bit(s) set in the H1 octet. A logical OR is performed across all mask bits within the same mask byte, and across all four mask bytes.')
atmPhyConfRxUserProgH2Mask = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfRxUserProgH2Mask.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfRxUserProgH2Mask.setDescription('Defines the bit mask pattern for the second octet (H2) of a received cell. For each mask bit that is set, the PHY will process received cells with the corresponding bit(s) set in the H2 octet. For each mask bit that is reset, the PHY will discard received cells with the corresponding bit(s) set in the H2 octet. A logical OR is performed across all mask bits within the same mask byte, and across all four mask bytes.')
atmPhyConfRxUserProgH3Mask = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfRxUserProgH3Mask.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfRxUserProgH3Mask.setDescription('Defines the bit mask pattern for the third octet (H3) of a received cell. For each mask bit that is set, the PHY will process received cells with the corresponding bit(s) set in the H3 octet. For each mask bit that is reset, the PHY will discard received cells with the corresponding bit(s) set in the H3 octet. A logical OR is performed across all mask bits within the same mask byte, and across all four mask bytes.')
atmPhyConfRxUserProgH4Mask = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfRxUserProgH4Mask.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfRxUserProgH4Mask.setDescription('Defines the bit mask pattern for the third octet (H4) of a received cell. For each mask bit that is set, the PHY will process received cells with the corresponding bit(s) set in the H4 octet. For each mask bit that is reset, the PHY will discard received cells with the corresponding bit(s) set in the H4 octet. A logical OR is performed across all mask bits within the same mask byte, and across all four mask bytes.')
atmPhyConfTxIdleUnassignedCellPayload = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(106)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfTxIdleUnassignedCellPayload.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfTxIdleUnassignedCellPayload.setDescription('Defines the pattern inserted in the idle/unassigned cell payload. Idle/unassigned cells are inserted at this interface when the PHY device detects that the transmit FIFO contains no outstanding cells. The default pattern is 6AH, as defined by the ATM Forum UNI Specification.')
atmPhyConfPlcpControlTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfPlcpControlTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfPlcpControlTimer.setDescription("Defines the duration, in milliseconds, permitted for PCLP error generation controls specified by object 'atmPhyConfPlcpControl'.")
atmPhyConfControl = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("clearStats", 2), ("enableHCSErrorGeneration", 3), ("disableHCSErrorGeneration", 4))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfControl.setDescription("Defines the generic controls permitted at this interface. Interface. Options: none (1): The value returned following a 'clearStats' command. clearStats (2): Clear all statistics stored by statistics objects maintained within the Interface Operation and Interface Operational PLCP group tables. enableHCSErrorGeneration (3): Enables the insertion of an incorrect Header Error Checksum (HCS) within consecutive transmitted cells (assigned or unassigned). disableHCSErrorGeneration (4): Disables the insertion of an incorrect Header Error Checksum (HCS) within consecutive transmitted cells (assigned or unassigned).")
atmPhyConfPlcpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 10, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmPhyConfPlcpControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyConfPlcpControl.setDescription("Defines the PLCP error generation controls permitted at this interface. This object is bit-mapped and can permit a maximum of 8 simultaneous error controls. Once the controls are initiated, the selected errors are generated for a period of time specified by object 'atmPhyConfPlcpControlTimer'. Error generation can be restarted at any time. To enable a specific control, its bit must be set. To disable a specific control, its bit must be reset. The controls are assigned the following bits: (bit-0): Controls the generation of a PLCP yellow alarm signal by setting the yellow signal bit position in the path status octet (G1) within consecutive PLCP frames. (bit-1): Controls the generation of a PLCP Far End Block Errors (FEBE) by inserting a single far end block error within consecutive PLCP frames. (bit-2): Controls the generation of PLCP Bit Interleave Parity (BIP) errors by inserting a single bit interleave parity error within consecutive PLCP frames. (bit-3): Controls the generation of frame alignment pattern errors by inserting a single bit error in each A1 & A2 octets within consecutive PLCP frames. (bit-4): Controls the generation of parity errors by inserting a parity error into each path overhead identification (POHID) octet within consecutive PLCP frames.")
atmPhyOperTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20), )
if mibBuilder.loadTexts: atmPhyOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperTable.setDescription('A table containing operational information and controls pertaining to one ATM PHY interface.')
atmPhyOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmPhyOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperEntry.setDescription('Defines an entry in the ATM PHY operational table.')
atmPhyOperDeviceVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperDeviceVersion.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperDeviceVersion.setDescription('Identifies the version level of the S/UNI-PDH. The second version of the device should return value 1.')
atmPhyOperFramerDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("ds1", 2), ("e1", 3), ("ds3", 4), ("e3", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperFramerDetected.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperFramerDetected.setDescription('Identifies the actual hardware framer detected. Only framers on ATM cards are detectable.')
atmPhyOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("offLine", 1), ("downNoHwDetected", 2), ("downConfigError", 3), ("down", 4), ("up", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperState.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperState.setDescription("Identifies the current state of the interface. Options: offline(1): Configuration for this interface has not yet been passed to the layer. downNoHwDetected (2): No ATM card was detected in order to support this configured. Interface. downConfigError (3): An ATM card was detected, however it is not the same as what was requested via configuration. down (4): An ATM card was detected, it matches the configuration requested, but the Physical Layers' PMD sublayer is currently down. up (5): This is the desired state. An ATM card was detected, it matches the configuration requested, and the Physical Layers' PMD sublayer is currently up.")
atmPhyOperLCDState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("detectedLCD", 1), ("noLCD", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperLCDState.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperLCDState.setDescription("Identifies the current cell delineation state of the interface, and only applies to an interface configured to used the direct mapping frame format (object atmPhyConfFrameFormat value 'g-804'). A Loss of Cell Delineation state is declared once an Out of Cell Delineation (OCD) defect has persisted for a default period of 99.4ms for a DS1 interface, or 76.9ms for an E1 interface. An OCD defect is declared once 8 consecutive ATM cells have HEC violations, as per ITU-I.432.")
atmPhyOperRxIdleUnassignedCellsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperRxIdleUnassignedCellsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperRxIdleUnassignedCellsDropped.setDescription("Indicates the number of idle/unassigned cells that have been dropped at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ). ")
atmPhyOperHCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperHCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperHCSErrors.setDescription("Indicates the number of header check sequence (HCS) errors that have been detected at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ). ")
atmPhyOperOCDEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperOCDEvents.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperOCDEvents.setDescription("Indicates the number of Out of Cell Delineation (OCD) events that have been detected at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ). An OCD event is declared and counted once seven consecutive ATM cells are received with Header Error Check (HEC) violations.")
atmPhyOperRxFifoOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperRxFifoOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperRxFifoOverruns.setDescription("Indicates the number of receive FIFO overruns that have been detected at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ). ")
atmPhyOperTxFifoOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 20, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperTxFifoOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperTxFifoOverruns.setDescription("Indicates the number of transmit FIFO overruns that have been detected at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ). ")
atmPhyOperPlcpTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30), )
if mibBuilder.loadTexts: atmPhyOperPlcpTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpTable.setDescription('A table containing additional operational information and controls pertaining to one ATM PHY interface configured for PLCP mapping.')
atmPhyOperPlcpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmPhyOperPlcpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpEntry.setDescription('Defines an entry in the ATM PHY operational table for PLCP configured interfaces.')
atmPhyOperPlcpOOFDefectState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 10), ErrorState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpOOFDefectState.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpOOFDefectState.setDescription('Indicates the current PLCP Out Of Frame (OOF) defect state at this interface. An OOF is declared when an error is detected in both the A1 and A2 octets or when 2 consecutive POHID octets are found in error. AN OOF is removed and framing is declared upon finding 2 valid, consecutive set of frmaing (A1 and A2) octets and 2 valid and sequential path overhead identifier (POHID) octets.')
atmPhyOperPlcpLOFDefectState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 11), ErrorState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpLOFDefectState.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpLOFDefectState.setDescription('Indicates the current PLCP Loss Of Frame (LOF) defect state at this interface. An LOF is declared when an OOF state persists for more than 25ms for DS1, or 20ms for E1 OLCP formats. When LOF is declared, PLCP reframe is initiated. An LOF is removed when an in-frame state persists for more than 250ms for DS1, or 200ms for E1..')
atmPhyOperPlcpYADefectState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 12), ErrorState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpYADefectState.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpYADefectState.setDescription('Indicates the current PLCP Yellow Alarm (YA) defect state at this interface. A Yellow Alarm is declared when 10 consecutive yellow signal bits are set to logical 1. A Yellow Alarm is remove when 10 consecutive received yellow signal bits are set to logical 0. ')
atmPhyOperPlcpOOFs = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpOOFs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpOOFs.setDescription("Indicates the number of PLCP Out of Frame (OOF) defects detected or removed at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ).")
atmPhyOperPlcpLOFs = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpLOFs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpLOFs.setDescription("Indicates the number of PLCP Loss of Frame (LOF) defects detected or removed at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ).")
atmPhyOperPlcpYAs = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpYAs.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpYAs.setDescription("Indicates the number of PLCP Yellow Alarm (YA) defects detected or removed at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ).")
atmPhyOperPlcpBIPErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpBIPErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpBIPErrors.setDescription("Indicates the number of PLCP Bit Interleaved Parity (BIP) errors that have been detected at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ).")
atmPhyOperPlcpFramingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpFramingErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpFramingErrors.setDescription("Indicates the number of PLCP framing pattern octet errors and path overhead identification octet errors that have been detected at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ).")
atmPhyOperPlcpFEBEErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 61, 30, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmPhyOperPlcpFEBEErrors.setStatus('mandatory')
if mibBuilder.loadTexts: atmPhyOperPlcpFEBEErrors.setDescription("Indicates the number of PLCP Far End Block Errors (FEBE) that have been detected at this interface since the last power-up reset, or, since the statistics were last cleared (via object atmPhyConfControl value 'clearStats' ).")
mibBuilder.exportSymbols("CXAtmPhy-MIB", atmPhyOperPlcpYAs=atmPhyOperPlcpYAs, atmPhyConfRxLoopback=atmPhyConfRxLoopback, atmPhyConfControl=atmPhyConfControl, atmPhyConfPlcpControlTimer=atmPhyConfPlcpControlTimer, atmPhyOperHCSErrors=atmPhyOperHCSErrors, Switch=Switch, atmPhyConfRxUserProgH4Mask=atmPhyConfRxUserProgH4Mask, atmPhyOperEntry=atmPhyOperEntry, atmPhyOperRxIdleUnassignedCellsDropped=atmPhyOperRxIdleUnassignedCellsDropped, atmPhyOperTxFifoOverruns=atmPhyOperTxFifoOverruns, atmPhyConfTxFifoDepth=atmPhyConfTxFifoDepth, atmPhyOperPlcpLOFDefectState=atmPhyOperPlcpLOFDefectState, atmPhyConfPlcpControl=atmPhyConfPlcpControl, atmPhyConfRxUserProgH2Mask=atmPhyConfRxUserProgH2Mask, atmPhyConfFrameFormat=atmPhyConfFrameFormat, atmPhyConfRxUserProgH3Mask=atmPhyConfRxUserProgH3Mask, atmPhyOperFramerDetected=atmPhyOperFramerDetected, atmPhyOperLCDState=atmPhyOperLCDState, atmPhyOperOCDEvents=atmPhyOperOCDEvents, atmPhyOperPlcpYADefectState=atmPhyOperPlcpYADefectState, atmPhyMibLevel=atmPhyMibLevel, atmPhyOperPlcpOOFs=atmPhyOperPlcpOOFs, atmPhyInterfaceConfEntry=atmPhyInterfaceConfEntry, atmPhyConfPlcpBypass=atmPhyConfPlcpBypass, atmPhyOperPlcpTable=atmPhyOperPlcpTable, atmPhyOperRxFifoOverruns=atmPhyOperRxFifoOverruns, atmPhyOperPlcpOOFDefectState=atmPhyOperPlcpOOFDefectState, atmPhyConfRxCoset=atmPhyConfRxCoset, atmPhyOperState=atmPhyOperState, ErrorState=ErrorState, atmPhyInterfaceConfTable=atmPhyInterfaceConfTable, atmPhyOperPlcpBIPErrors=atmPhyOperPlcpBIPErrors, atmPhyConfCellDescrambling=atmPhyConfCellDescrambling, atmPhyOperPlcpEntry=atmPhyOperPlcpEntry, atmPhyConfCellScrambling=atmPhyConfCellScrambling, atmPhyConfTxIdleUnassignedCellPayload=atmPhyConfTxIdleUnassignedCellPayload, atmPhyConfTxClocking=atmPhyConfTxClocking, atmPhyConfTxCoset=atmPhyConfTxCoset, atmPhyOperDeviceVersion=atmPhyOperDeviceVersion, atmPhyConfRxUserProgH1Mask=atmPhyConfRxUserProgH1Mask, atmPhyOperPlcpLOFs=atmPhyOperPlcpLOFs, atmPhyOperPlcpFEBEErrors=atmPhyOperPlcpFEBEErrors, atmPhyOperTable=atmPhyOperTable, atmPhyOperPlcpFramingErrors=atmPhyOperPlcpFramingErrors)

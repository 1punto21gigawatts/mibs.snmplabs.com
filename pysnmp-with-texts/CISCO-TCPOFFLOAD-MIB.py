#
# PySNMP MIB module CISCO-TCPOFFLOAD-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-TCPOFFLOAD-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:14:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
cipCardDtrBrdIndex, cipCardSubChannelIndex, cipCardEntryIndex = mibBuilder.importSymbols("CISCO-CHANNEL-MIB", "cipCardDtrBrdIndex", "cipCardSubChannelIndex", "cipCardEntryIndex")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
TimeTicks, Counter32, Counter64, IpAddress, iso, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, NotificationType, Unsigned32, Bits, Integer32, MibIdentifier, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter32", "Counter64", "IpAddress", "iso", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "NotificationType", "Unsigned32", "Bits", "Integer32", "MibIdentifier", "Gauge32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
TruthValue, DisplayString, RowStatus = mibBuilder.importSymbols("SNMPv2-TC-v1", "TruthValue", "DisplayString", "RowStatus")
ciscoTcpOffloadMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31))
tcpOffloadObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31, 1))
cipCardOffloadConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1))
ciscoTcpOffloadMibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31, 2))
ciscoTcpOffloadMibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31, 2, 1))
ciscoTcpOffloadMibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31, 2, 2))
cipCardOffloadConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1), )
if mibBuilder.loadTexts: cipCardOffloadConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigTable.setDescription('This table contains configuration information for the TCP offload feature on the CMCC card. Changing these parameters will take effect immediately. The management station can create an entry in this table by setting the appropriate value in cipCardOffloadConfigRowStatus. All the objects in this table must be supplied for a successful create/set.')
cipCardOffloadConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-CHANNEL-MIB", "cipCardEntryIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardDtrBrdIndex"), (0, "CISCO-CHANNEL-MIB", "cipCardSubChannelIndex"))
if mibBuilder.loadTexts: cipCardOffloadConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigEntry.setDescription('A list of OFFLOAD configuration values.')
cipCardOffloadConfigPath = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigPath.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigPath.setDescription('Hex path identifier for the escon director switch port containing the fiber from the channel on the host to which this CMCC CLAW task connects. This is a concatenation of the switch port number, the channel logical address (used by the host to associate an logical partition (LPAR) with the control unit), and the control unit logical address (address of a logical control unit used by the host to associate a group of physical devices). For a directly connected channel, the switch port number is usually 01.')
cipCardOffloadConfigDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigDevice.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigDevice.setDescription('Two digit hex device address for the device the SNA host will use to communicate with the offload task on the CMCC. The address must be even.')
cipCardOffloadConfigIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigIpAddr.setDescription('IP address of the host application for the offload task as specified in the HOME statement of the PROFILE TCPIP.')
cipCardOffloadConfigHostName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigHostName.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigHostName.setDescription('Host name parameter as specified in the DEVICE statement of the PROFILE TCPIP.')
cipCardOffloadConfigRouterName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigRouterName.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigRouterName.setDescription('Workstation name parameter as specified in the DEVICE statement of the mainframe PROFILE TCPIP.')
cipCardOffloadConfigLinkHostAppl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigLinkHostAppl.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigLinkHostAppl.setDescription('Name of the application providing the IP link services, as specified in the mainframe configuration.')
cipCardOffloadConfigLinkRouterAppl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigLinkRouterAppl.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigLinkRouterAppl.setDescription('Name of the router application providing the IP link services, as specified in the mainframe configuration.')
cipCardOffloadConfigAPIHostAppl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigAPIHostAppl.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigAPIHostAppl.setDescription('Name of the mainframe application providing the API services, as specified in the mainframe configuration.')
cipCardOffloadConfigAPIRouterAppl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigAPIRouterAppl.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigAPIRouterAppl.setDescription('Name of the router application providing the API services, as specified in the mainframe configuration.')
cipCardOffloadConfigBroadcastEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigBroadcastEnable.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigBroadcastEnable.setDescription('Control processing of broadcast frames for the path/device this instance of OFFLOAD is configured on. Enable turns broadcast processing on.')
cipCardOffloadConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 31, 1, 1, 1, 1, 11), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cipCardOffloadConfigRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cipCardOffloadConfigRowStatus.setDescription('This object is used by a management station to create or delete the row entry in cipCardOffloadConfigTable following the RowStatus textual convention.')
ciscoTcpOffloadGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31, 2, 2, 1))
ciscoTcpOffloadMibCompliance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 31, 2, 1, 1))
mibBuilder.exportSymbols("CISCO-TCPOFFLOAD-MIB", cipCardOffloadConfigLinkRouterAppl=cipCardOffloadConfigLinkRouterAppl, cipCardOffloadConfigBroadcastEnable=cipCardOffloadConfigBroadcastEnable, cipCardOffloadConfigRowStatus=cipCardOffloadConfigRowStatus, cipCardOffloadConfigTable=cipCardOffloadConfigTable, ciscoTcpOffloadMIB=ciscoTcpOffloadMIB, cipCardOffloadConfigPath=cipCardOffloadConfigPath, ciscoTcpOffloadGroup=ciscoTcpOffloadGroup, ciscoTcpOffloadMibCompliance=ciscoTcpOffloadMibCompliance, tcpOffloadObjects=tcpOffloadObjects, cipCardOffloadConfigAPIHostAppl=cipCardOffloadConfigAPIHostAppl, cipCardOffloadConfigIpAddr=cipCardOffloadConfigIpAddr, cipCardOffloadConfigDevice=cipCardOffloadConfigDevice, cipCardOffloadConfigLinkHostAppl=cipCardOffloadConfigLinkHostAppl, ciscoTcpOffloadMibGroups=ciscoTcpOffloadMibGroups, cipCardOffloadConfigRouterName=cipCardOffloadConfigRouterName, ciscoTcpOffloadMibCompliances=ciscoTcpOffloadMibCompliances, cipCardOffloadConfigHostName=cipCardOffloadConfigHostName, cipCardOffloadConfig=cipCardOffloadConfig, cipCardOffloadConfigAPIRouterAppl=cipCardOffloadConfigAPIRouterAppl, ciscoTcpOffloadMibConformance=ciscoTcpOffloadMibConformance, cipCardOffloadConfigEntry=cipCardOffloadConfigEntry)

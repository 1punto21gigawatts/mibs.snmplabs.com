#
# PySNMP MIB module GDCUAS7626-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/GDCUAS7626-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:19:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
enterprises, Unsigned32, MibIdentifier, ObjectIdentity, IpAddress, ModuleIdentity, TimeTicks, Bits, NotificationType, Counter32, Counter64, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "Unsigned32", "MibIdentifier", "ObjectIdentity", "IpAddress", "ModuleIdentity", "TimeTicks", "Bits", "NotificationType", "Counter32", "Counter64", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Integer32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
gdc = MibIdentifier((1, 3, 6, 1, 4, 1, 498))
bql2 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12))
uas7626 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12))
uas7626Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 1))
uas7626Maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 2))
uas7626Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 3))
uas7626Diagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 4))
uas7626Performance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 5))
uas7626AlarmConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 6))
uas7626Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7))
uas7626MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Acceptable values for the individual revision components are as follows: x: 1 - 9 y: 0 - 9 z: 0 - 9 T: A - Z Upon formal release, no designation for the test revision will be present.")
uas7626VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2), )
if mibBuilder.loadTexts: uas7626VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626VersionTable.setDescription('The 7626 version table ')
uas7626VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626VersionIndex"))
if mibBuilder.loadTexts: uas7626VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626VersionEntry.setDescription('An entry in the GDC uas7626System Version Table.')
uas7626VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626VersionIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626ActiveFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626ActiveFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ActiveFirmwareRev.setDescription('The version number of the firmware currently executing. The format is MM.NN.BB where: MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) Valid [i]nterface = 0')
uas7626StoredFirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626StoredFirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626StoredFirmwareRev.setDescription('The version number of the firmware stored (in a compressed format) but not currently executing. MM: Major Revision (0-99) NN: Minor Revision (0-99) BB: Bug Fix Revision (0-99) Valid [i]nterface = 0')
uas7626StoredFirmwareStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("statBlank", 1), ("statDownLoading", 2), ("statOK", 3), ("statCheckSumBad", 4), ("statUnZipping", 5), ("statBadUnZip", 6), ("statDownloadAborted", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626StoredFirmwareStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626StoredFirmwareStatus.setDescription('This object represents the state of the Non-Active or Stored firmware: statBlank(1) Factory Default statDownLoading(2) In process of downloading firmware statOK(3) Zipped version checksum succesful (OK to switch) (can set uas7626SwitchActiveFirmware to switchActive(2)) statCheckSumBad(4) Failed checksum after download statUnZipping(5) In process of uncompressing into active area statBadUnZip(6) Failed last uncompress statDownloadAborted(7) Download aborted by user Valid [i]nterface = 0')
uas7626SwitchActiveFirmware = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("switchNorm", 1), ("switchActive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626SwitchActiveFirmware.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626SwitchActiveFirmware.setDescription('This object is used to switch the active executing firmware from the version in uas7626ActiveFirmwareRev to the version in uas7626StoredFirmwareRev. When a switchActive(2) is set (write only) the element will: 1) reboot 2) uncompress stored code into active area 3) perform checksum on active area 4) Set uas7626StoredStatus object to indicate results 5) If succesfull: update uas7626ActiveFirmwareRev and uas7626StoredFirmwareRev and begin executing If failed: replace active area with previous revision The switchNorm(1) enumeration will always be read. Setting switchActive(2) when the uas7626StoredFirmwareStatus is not statOK(3) will result in an error. Valid [i]nterface = 0')
uas7626DownloadingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disableAll", 1), ("enableAndWait", 2), ("enableAndSwitch", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626DownloadingMode.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626DownloadingMode.setDescription('This object is used to configure the download mode: disableAll(1) Prevents any firmware downloading to UAS7626 enableAndWait(2) Allows downloading zipped code to be stored only! enableAndSwitch(3) Allows downloading and then unzips and begins executing the new code Valid [i]nterface = 0')
uas7626MaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1), )
if mibBuilder.loadTexts: uas7626MaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626MaintenanceTable.setDescription('The table describes the maintenance objects for uas7626.')
uas7626MaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626MaintenanceLineIndex"))
if mibBuilder.loadTexts: uas7626MaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626MaintenanceEntry.setDescription('An entry in the GDC 7626 Maintenance Table.')
uas7626MaintenanceLineIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626MaintenanceLineIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626MaintenanceLineIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626SoftReset.setDescription('Supports the action of soft resetting the unit. When this object is set to reset(2), then the unit performs a soft reset, whose meaning is specific to the type of unit being managed. The value of norm(1) will be returned when the reset is complete. The value of norm(1) can not be set by management. Valid [i]nterface = 0')
uas7626DefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("factoryDefault", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626DefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626DefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault(2) the unit will perform a reset to make the default configuration take affect. The value of normal(1) will be returned when the initialization is complete. The value of normal(1) can not be set by management. Valid [i]nterface = 0')
uas7626ResetMajorAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626ResetMajorAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ResetMajorAlarm.setDescription('This variable is used to reset the Major BER alarm. A value of norm(1) cannot be set by management and will always be returned on a read. Valid [i]nterface = 01-06')
uas7626ResetMinorAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626ResetMinorAlarm.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ResetMinorAlarm.setDescription('This variable is used to reset the Minor BER alarm. A value of norm(1) cannot be set by management and will always be returned on a read. Valid [i]nterface = 01-06')
uas7626ResetStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626ResetStatistics.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ResetStatistics.setDescription('This variable is used to reset the performance intervals. When it is set to reset, the performance tables and uas7626Valid intervals are reset to zero. The value of norm(1) can not be set by management. Valid [i]nterface = 01-06')
uas7626ValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626ValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 16 unless the interface was brought on-line within the last 4 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online. Valid [i]nterface = 01-06')
uas7626SysUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626SysUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626SysUpTime.setDescription('This variable is used to report the elapsed system tick time for conversion to real time at the controller and is not related to the sysUpTime referenced in MIB-II. Upon power-up of the unit, the elapsed time is cleared. The elapsed time counter rolls over upon reaching the maximum count. Valid [i]nterface = 0')
uas7626LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626LedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state: key --- 001 = SOLID GREEN 010 = SOLID RED 011 = FLASHING RED 100 = FLASHING GREEN 1.7 - n/a 1.6 - \\ 1.5 - -- Loop 1 (001, 010, 011, 100) 1.4 - / 1.3 - \\ 1.2 - -- Loop 2 (001, 010, 011, 100)Y 1.1 - / 1.0 - f/u 2.7 - f/u 2.6 - \\ 2.5 - -- Loop 3 (001, 010, 011, 100) 2.4 - / 2.3 - \\ 2.2 - -- Loop 4 (001, 010, 011, 100) 2.1 - / 2.0 - f/u 3.7 - f/u 3.6 - \\ 3.5 - -- Loop 5 (001, 010, 011, 100) 3.4 - / 3.3 - \\ 3.2 - -- Loop 6 (001, 010, 011, 100) 3.1 - / 3.0 - f/u 4.7 - f/u 4.6 - f/u 4.5 - f/u 4.4 - Alarm (0 = Off; 1 = Alarm Active ) 4.3 - Test Mode (0 = Off; 1 = Alarm Active ) 4.2 - In Service (0 = Off; 1 = Alarm Active ) 4.1 - Transmitter Timing Failure (0 = Off; 1 = Alarm Active ) 4.0 - Management Response (0 = Off; 1 = Alarm Active ) Valid [i]nterface = 0')
uas7626AlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(7, 7)).setFixedLength(7)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626AlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626AlarmStatus.setDescription('Returns actual bit-wise Status of alarms regardless of whether the alarm is masked or not. key --- 0 = Inactive 1 = Active 1.7 - f/u 1.6 - Power-up 1.5 - f/u 1.4 - f/u 1.3 - f/u 1.2 - f/u 1.1 - f/u 1.0 - f/u Note: n=2-6 for octets 2-7 n.7 - f/u n.6 - Loop n Major n.5 - Loop n Minor n.4 - Loop n Loss of Transmit Clock n.3 - Loop n 2B1Q Out of Sync n.2 - Loop n Sealing Current Non-Continuity Alarm n.1 - Loop n Errored Seconds n.0 - Loop n Unavailable Seconds Valid [i]nterface = 0')
uas7626StatLastInitialized = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 11), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626StatLastInitialized.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626StatLastInitialized.setDescription("The elapsed time since the statistics were last initialized. This will be zero'd when uas7626ResetStatistics is reset(2). Valid [i]nterface = 01-06")
uas7626CircuitID = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 2, 1, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626CircuitID.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626CircuitID.setDescription('Name to identify the circuit. Valid [i]nterface = 01-06')
uas7626ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 3, 1), )
if mibBuilder.loadTexts: uas7626ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ConfigTable.setDescription('The GDC Configuration table.')
uas7626ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 3, 1, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626ConfigIndex"))
if mibBuilder.loadTexts: uas7626ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ConfigEntry.setDescription('The GDC Configuration table entry.')
uas7626ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 3, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ConfigIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626DataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("kbps64", 1), ("kbps128", 2), ("inhibit", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626DataRate.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626DataRate.setDescription('Object to select the Data Rate on Loop n. Valid [i]nterface = 01-06')
uas7626Highway = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("notAssigned", 1), ("highway1", 2), ("highway2", 3), ("highway3", 4), ("highway4", 5), ("highway5", 6), ("highway6", 7), ("highway7", 8), ("highway8", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626Highway.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626Highway.setDescription('Object to select the data highway for Loop n. Valid [i]nterface = 01-06')
uas7626TimeSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626TimeSlot.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626TimeSlot.setDescription('Object to select the timeslots for the data highway given by uas7624Highway for loop n. Valid selections are 1-31 and 64. A value of 64 indicates the loop is not assigned to a highway. Valid [i]nterface = 01-06')
uas7626DiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 4, 1), )
if mibBuilder.loadTexts: uas7626DiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626DiagTable.setDescription('The GDC 7626 Diagnostics table. Information in the entries of this table support diagnostics testing, both active testing via patterns, and passive testing via loopbacks.')
uas7626DiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 4, 1, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626DiagIndex"))
if mibBuilder.loadTexts: uas7626DiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626DiagEntry.setDescription('The GDC 7626 Diagnostics table entry.')
uas7626DiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626DiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626DiagIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626TestSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("stopTest", 1), ("digitalLoopback", 2), ("selfTest", 3), ("remoteDigitalLoopback", 4), ("rdlSelfTest", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626TestSelection.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626TestSelection.setDescription('Selects the test to run. A selection of stopTest(1) stops the current test. Valid [i]nterface = 01-06')
uas7626TestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048576))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626TestResults.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626TestResults.setDescription('Returns the self test bit error count. Valid [i]nterface = 01-06')
uas7626ResetTestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626ResetTestResults.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ResetTestResults.setDescription('Resets the self test bit error count. A value of norm(1) cannot be set by management and is always returned on a read. Valid [i]nterface = 01-06')
uas7626NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 1))
uas7626DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 2))
uas7626PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 3))
uas7626LossofTransmitClockAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 4))
uas7626OutofSyncAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 5))
uas7626SealingCurrentNoContAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 6))
uas7626UASAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 7))
uas7626ESAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 8))
uas7626MajorBERAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 9))
uas7626MinorBERAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 12, 12, 7, 10))
uas7626AlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 1), )
if mibBuilder.loadTexts: uas7626AlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626AlarmConfigTable.setDescription('This table contains entries that configure Alarm reporting.')
uas7626AlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 1, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626AlarmConfigIndex"), (0, "GDCUAS7626-MIB", "uas7626AlarmConfigIdentifier"))
if mibBuilder.loadTexts: uas7626AlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626AlarmConfigEntry.setDescription('An entry in the uas7626 Alarm Configuration table.')
uas7626AlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626AlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626AlarmConfigIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626AlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626AlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626AlarmConfigIdentifier.setDescription('format: iso.org.dod.internet.private.enterprises.gdc. bql2.uas7626.uas7626Alarms.ALM example: 1.3.6.1.4.1.498.12.12.7.ALM where ALM = 1 for uas7626NoResponse alarm, 2 for uas7626DiagRxErr alarm, etc., as specified in the Alarm Definitions above.')
uas7626AlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("thres10E03", 1), ("thres10E04", 2), ("thres10E05", 3), ("thres10E06", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626AlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626AlarmCountThreshold.setDescription('This function sets/reads the alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active. Valid [i]nterface = 01-06')
uas7626LocalAlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2), )
if mibBuilder.loadTexts: uas7626LocalAlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626LocalAlarmConfigTable.setDescription('The uas7626LocalAlarmConfigTable contains entries that configure alarm reporting to the alarm card.')
uas7626LocalAlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626LocalAlarmConfigIndex"))
if mibBuilder.loadTexts: uas7626LocalAlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626LocalAlarmConfigEntry.setDescription('An entry in the GDC Local Alarm Configuration table.')
uas7626LocalAlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626LocalAlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626LocalAlarmConfigIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626LossOfClockLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMinor", 2), ("enabledMajor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626LossOfClockLocal.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626LossOfClockLocal.setDescription('Disables or enables the alarm on the Major buss or Minor Buss. Valid [i]nterface = 01-06')
uas7626ESLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMinor", 2), ("enabledMajor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626ESLocal.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626ESLocal.setDescription('Disables or enables the alarm on the Major buss or Minor Buss. Valid [i]nterface = 01-06')
uas7626UASLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMinor", 2), ("enabledMajor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626UASLocal.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626UASLocal.setDescription('Disables or enables the alarm on the Major buss or Minor Buss. Valid [i]nterface = 01-06')
uas7626OutofSyncLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMinor", 2), ("enabledMajor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626OutofSyncLocal.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626OutofSyncLocal.setDescription('Disables or enables the alarm on the Major buss or Minor Buss. Valid [i]nterface = 01-06')
uas7626NoSealingCurrentLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 6, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("enabledMinor", 2), ("enabledMajor", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: uas7626NoSealingCurrentLocal.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626NoSealingCurrentLocal.setDescription('Disables or enables the alarm on the Major buss or Minor Buss. Valid [i]nterface = 01-06')
uas7626CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 3), )
if mibBuilder.loadTexts: uas7626CurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626CurrentTable.setDescription('The uas7626 Current table contains various statistics being collected for the current 15 minute interval.')
uas7626CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 3, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626CurrentIndex"))
if mibBuilder.loadTexts: uas7626CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626CurrentEntry.setDescription('An entry in the uas7626 Current table.')
uas7626CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626CurrentIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626CurrentStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 3, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(10, 10)).setFixedLength(10)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626CurrentStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626CurrentStat.setDescription('Returns a bitwise snapshot of the current 15 minute statistics: Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 3 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 4 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 5 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 6 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) Valid [i]nterface = 01-06')
uas7626IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 4), )
if mibBuilder.loadTexts: uas7626IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626IntervalTable.setDescription('The uas7626 Interval table contains various statistics collected by each Interface over the last 16 15-minute intervals.')
uas7626IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 4, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626IntervalIndex"), (0, "GDCUAS7626-MIB", "uas7626IntervalNumber"))
if mibBuilder.loadTexts: uas7626IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626IntervalEntry.setDescription('An entry in the Interval table.')
uas7626IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 4, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626IntervalIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626IntervalNumber.setDescription('The interval number 1- 16. Valid [i]nterface = 01-06')
uas7626IntervalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(11, 11)).setFixedLength(11)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626IntervalStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626IntervalStat.setDescription('Returns a bitwise snapshot of the interval statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Interval Octet 3 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 6 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 7 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 8 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 9 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 10 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 11 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) Valid [i]nterface = 01-06')
uas7626TotalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 5), )
if mibBuilder.loadTexts: uas7626TotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626TotalTable.setDescription('The uas7626 Total Table contains the totals of the various statistics collected for the current 24 hour period for each interface.')
uas7626TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 5, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626TotalIndex"))
if mibBuilder.loadTexts: uas7626TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626TotalEntry.setDescription('An entry in the uas7626 Total table.')
uas7626TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 5, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626TotalIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626TotalStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 5, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626TotalStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626TotalStat.setDescription('Returns a bitwise snapshot of the current 24 hour statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 3 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 6 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 11 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^23 bit 1 - 2^22 bit 0 - 2^21 Octet 12 bit 7 - not used bit 6 - 2^20 bit 5 - 2^19 bit 4 - 2^18 bit 3 - 2^17 bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 13 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) Valid [i]nterface = 01-06')
uas7626Recent24HrTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 6), )
if mibBuilder.loadTexts: uas7626Recent24HrTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626Recent24HrTable.setDescription('The Recent 24 Hour table contains the totals of the various statistics collected for the previous 24 hour period for each interface.')
uas7626Recent24HrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 6, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626Recent24HrIndex"))
if mibBuilder.loadTexts: uas7626Recent24HrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626Recent24HrEntry.setDescription('An entry in the Recent24Hr table.')
uas7626Recent24HrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 6, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626Recent24HrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626Recent24HrIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626Recent24HrStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 6, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(14, 14)).setFixedLength(14)).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626Recent24HrStat.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626Recent24HrStat.setDescription('Returns a bitwise snapshot of the recent 24 hour statistics. Octet 1 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Loop ID Octet 2 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 3 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 4 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Errored Seconds Octet 5 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 6 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 7 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Severely Errored Seconds Octet 8 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - >65535 bit 1 - 2^15 bit 0 - 2^14 Octet 9 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 10 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 Unavailable Seconds Octet 11 bit 7 - not used bit 6 - future use bit 5 - future use bit 4 - future use bit 3 - future use bit 2 - 2^23 bit 1 - 2^22 bit 0 - 2^21 Octet 12 bit 7 - not used bit 6 - 2^20 bit 5 - 2^19 bit 4 - 2^18 bit 3 - 2^17 bit 2 - 2^16 bit 1 - 2^15 bit 0 - 2^14 Octet 13 bit 7 - not used bit 6 - 2^13 bit 5 - 2^12 bit 4 - 2^11 bit 3 - 2^10 bit 2 - 2^9 bit 1 - 2^8 bit 0 - 2^7 Octet 14 bit 7 - not used bit 6 - 2^6 bit 5 - 2^5 bit 4 - 2^4 bit 3 - 2^3 bit 2 - 2^2 bit 1 - 2^1 bit 0 - 2^0 FEBE (Far End Block Error Count) Valid [i]nterface = 01-06')
uas7626UnavailableTimeRegTable = MibTable((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 7), )
if mibBuilder.loadTexts: uas7626UnavailableTimeRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626UnavailableTimeRegTable.setDescription('The 7626 Unavailable Time Register table.')
uas7626UnavailableTimeRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 7, 1), ).setIndexNames((0, "GDCUAS7626-MIB", "uas7626UnavailableTimeRegIndex"), (0, "GDCUAS7626-MIB", "uas7626UnavailableTimeRegNumber"))
if mibBuilder.loadTexts: uas7626UnavailableTimeRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626UnavailableTimeRegEntry.setDescription('An entry in the Unavailable Time Register table.')
uas7626UnavailableTimeRegIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 7, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626UnavailableTimeRegIndex.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626UnavailableTimeRegIndex.setDescription('Integer value which uniquely identifies the UAS7626 to which this entry is applicable. SCinstance is defined to be SLDi where: S (byte value) - physical shelf slot location (01-32) L (byte value) - line number (01) D (byte value) - drop number (00) i (byte value) - loop or interface number (00-06)')
uas7626UnavailableTimeRegNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626UnavailableTimeRegNumber.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626UnavailableTimeRegNumber.setDescription('A number between 1 and 6, where the number is the number of the Unavailable Time Register.')
uas7626UnavailableTimeRegStart = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 7, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626UnavailableTimeRegStart.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626UnavailableTimeRegStart.setDescription('Start time of one of the Unavailable Time Registers.')
uas7626UnavailableTimeRegStop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 12, 12, 5, 7, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: uas7626UnavailableTimeRegStop.setStatus('mandatory')
if mibBuilder.loadTexts: uas7626UnavailableTimeRegStop.setDescription('Stop time of one of the Unavailable Time Registers.')
mibBuilder.exportSymbols("GDCUAS7626-MIB", uas7626SoftReset=uas7626SoftReset, uas7626MaintenanceTable=uas7626MaintenanceTable, uas7626ResetMajorAlarm=uas7626ResetMajorAlarm, uas7626IntervalNumber=uas7626IntervalNumber, uas7626UnavailableTimeRegStart=uas7626UnavailableTimeRegStart, uas7626UnavailableTimeRegEntry=uas7626UnavailableTimeRegEntry, uas7626OutofSyncAlm=uas7626OutofSyncAlm, uas7626MaintenanceEntry=uas7626MaintenanceEntry, uas7626VersionTable=uas7626VersionTable, uas7626Alarms=uas7626Alarms, uas7626ConfigEntry=uas7626ConfigEntry, uas7626DiagIndex=uas7626DiagIndex, uas7626TestResults=uas7626TestResults, uas7626IntervalStat=uas7626IntervalStat, uas7626Highway=uas7626Highway, uas7626TotalStat=uas7626TotalStat, gdc=gdc, uas7626DefaultInit=uas7626DefaultInit, uas7626IntervalEntry=uas7626IntervalEntry, uas7626SealingCurrentNoContAlm=uas7626SealingCurrentNoContAlm, uas7626OutofSyncLocal=uas7626OutofSyncLocal, uas7626CurrentIndex=uas7626CurrentIndex, uas7626DiagTable=uas7626DiagTable, uas7626SwitchActiveFirmware=uas7626SwitchActiveFirmware, uas7626ESLocal=uas7626ESLocal, uas7626Recent24HrIndex=uas7626Recent24HrIndex, uas7626UnavailableTimeRegTable=uas7626UnavailableTimeRegTable, uas7626DiagRxErrAlm=uas7626DiagRxErrAlm, uas7626LossofTransmitClockAlm=uas7626LossofTransmitClockAlm, bql2=bql2, uas7626MinorBERAlm=uas7626MinorBERAlm, uas7626PowerUpAlm=uas7626PowerUpAlm, uas7626MIBversion=uas7626MIBversion, uas7626AlarmConfigEntry=uas7626AlarmConfigEntry, uas7626DataRate=uas7626DataRate, uas7626TotalTable=uas7626TotalTable, uas7626ESAlm=uas7626ESAlm, uas7626LocalAlarmConfigEntry=uas7626LocalAlarmConfigEntry, uas7626UnavailableTimeRegIndex=uas7626UnavailableTimeRegIndex, uas7626=uas7626, uas7626AlarmConfigIndex=uas7626AlarmConfigIndex, uas7626ConfigTable=uas7626ConfigTable, uas7626CurrentEntry=uas7626CurrentEntry, uas7626VersionIndex=uas7626VersionIndex, uas7626NoResponseAlm=uas7626NoResponseAlm, uas7626StatLastInitialized=uas7626StatLastInitialized, uas7626Version=uas7626Version, uas7626IntervalIndex=uas7626IntervalIndex, uas7626Configuration=uas7626Configuration, uas7626LocalAlarmConfigTable=uas7626LocalAlarmConfigTable, uas7626ValidIntervals=uas7626ValidIntervals, uas7626ResetStatistics=uas7626ResetStatistics, uas7626TestSelection=uas7626TestSelection, uas7626CircuitID=uas7626CircuitID, uas7626TotalIndex=uas7626TotalIndex, uas7626IntervalTable=uas7626IntervalTable, uas7626AlarmStatus=uas7626AlarmStatus, uas7626LedStatus=uas7626LedStatus, uas7626Maintenance=uas7626Maintenance, uas7626UnavailableTimeRegNumber=uas7626UnavailableTimeRegNumber, uas7626DownloadingMode=uas7626DownloadingMode, uas7626StoredFirmwareStatus=uas7626StoredFirmwareStatus, uas7626AlarmConfig=uas7626AlarmConfig, uas7626ResetTestResults=uas7626ResetTestResults, uas7626AlarmConfigIdentifier=uas7626AlarmConfigIdentifier, uas7626LossOfClockLocal=uas7626LossOfClockLocal, uas7626AlarmConfigTable=uas7626AlarmConfigTable, uas7626StoredFirmwareRev=uas7626StoredFirmwareRev, uas7626MajorBERAlm=uas7626MajorBERAlm, uas7626UASLocal=uas7626UASLocal, uas7626SysUpTime=uas7626SysUpTime, uas7626ConfigIndex=uas7626ConfigIndex, uas7626Recent24HrStat=uas7626Recent24HrStat, uas7626LocalAlarmConfigIndex=uas7626LocalAlarmConfigIndex, uas7626ResetMinorAlarm=uas7626ResetMinorAlarm, uas7626AlarmCountThreshold=uas7626AlarmCountThreshold, uas7626Recent24HrTable=uas7626Recent24HrTable, uas7626Performance=uas7626Performance, uas7626Recent24HrEntry=uas7626Recent24HrEntry, uas7626UnavailableTimeRegStop=uas7626UnavailableTimeRegStop, uas7626NoSealingCurrentLocal=uas7626NoSealingCurrentLocal, uas7626VersionEntry=uas7626VersionEntry, uas7626DiagEntry=uas7626DiagEntry, uas7626UASAlm=uas7626UASAlm, uas7626Diagnostics=uas7626Diagnostics, uas7626TotalEntry=uas7626TotalEntry, uas7626CurrentStat=uas7626CurrentStat, uas7626MaintenanceLineIndex=uas7626MaintenanceLineIndex, uas7626ActiveFirmwareRev=uas7626ActiveFirmwareRev, uas7626TimeSlot=uas7626TimeSlot, uas7626CurrentTable=uas7626CurrentTable)

#
# PySNMP MIB module AVAYA-RTP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AVAYA-RTP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:32:14 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
InetPortNumber, InetAddress, InetAddressIPv6, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddress", "InetAddressIPv6", "InetAddressType")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
enterprises, MibIdentifier, ModuleIdentity, TimeTicks, ObjectIdentity, NotificationType, Integer32, Unsigned32, Counter32, Gauge32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, iso, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "enterprises", "MibIdentifier", "ModuleIdentity", "TimeTicks", "ObjectIdentity", "NotificationType", "Integer32", "Unsigned32", "Counter32", "Gauge32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "iso", "Bits")
DisplayString, TextualConvention, TimeInterval, TruthValue, DateAndTime, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TimeInterval", "TruthValue", "DateAndTime", "RowStatus")
avRtpMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 6889, 2, 7))
if mibBuilder.loadTexts: avRtpMib.setLastUpdated('201006081712Z')
if mibBuilder.loadTexts: avRtpMib.setOrganization('Avaya')
if mibBuilder.loadTexts: avRtpMib.setContactInfo(' Avaya Customer Services Postal: Avaya, Inc. 211 Mt Airy Rd. Basking Ridge, NJ 07920 USA Tel: +1 908 953 6000 WWW: http://www.avaya.com ')
if mibBuilder.loadTexts: avRtpMib.setDescription(" This module defines an interface to RTP sessions QoS statistic gathering capabilities in Avaya's VoIP enabled devices. The MIB, designed for Avaya Services, allows operators to perform the following tasks: 1. View the statistics of recently terminated RTP session. 2. Define QoS related thresholds that define bad-QoS conditions. 3. View the statistics of last session, which experienced bad QoS. 4. Enable a special QoS trap that is sent upon termination of RTP session with bad QoS. 5. Enable a special QoS fault trap that is sent when more than N streams suffer from bad QoS. And a QoS clear trap that is sent when this fault conditions ends. 6. Configure the above traps rate limiting mechanism. Copyright notice: This AVAYA SNMP Management Information Base Specification (Specification) embodies AVAYA confidential and Proprietary intellectual property. AVAYA retains all Title and ownership in the Specification, including any revisionsIt is AVAYA's intent to encourage the widespread use of this Specification in connection with the management of AVAYA products. AVAYA grants vendors, end-users, and other interested parties a non-exclusive license to use this Specification in connection with the management of AVAYA products.This Specification is supplied 'as is', and AVAYA makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification. ")
class AvRtpItuPerceivedSeverity(TextualConvention, Integer32):
    reference = "ITU Recommendation M.3100, 'Generic Network Information Model', 1995 ITU Recommendation X.733, 'Information Technology - Open Systems Interconnection - System Management: Alarm Reporting Function', 1992"
    description = 'ITU perceived severity values'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("cleared", 1), ("indeterminate", 2), ("critical", 3), ("major", 4), ("minor", 5), ("warning", 6))

class AvRtpLoss(TextualConvention, Integer32):
    description = 'Loss in 1/10 precent accuracy'
    status = 'current'
    displayHint = 'd-1%'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(-1, 1000)

class AvRtpSilenceSupp(TextualConvention, Integer32):
    description = 'Silence Suppression modes where: noRtp(2) No RTP packets during silence periods SilenceFrames(3) The codec sends special silence frames during silence periods Complex(4) A combination of the above'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))
    namedValues = NamedValues(("notSupported", 0), ("disabled", 1), ("noRtp", 2), ("silenceFrames", 3), ("complex", 4))

avaya = MibIdentifier((1, 3, 6, 1, 4, 1, 6889))
mibs = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2))
avRtpNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 7, 0))
avRtpQoSTrap = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 7, 0, 1)).setObjects(("AVAYA-RTP-MIB", "avRtpSessionLocAddrV4"), ("AVAYA-RTP-MIB", "avRtpSessionRemAddrV4"), ("AVAYA-RTP-MIB", "avRtpSessionDuration"), ("AVAYA-RTP-MIB", "avRtpSessionCname"), ("AVAYA-RTP-MIB", "avRtpSessionPhone"), ("AVAYA-RTP-MIB", "avRtpSessionSeverity"), ("AVAYA-RTP-MIB", "avRtpSessionDebugStr"))
if mibBuilder.loadTexts: avRtpQoSTrap.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSTrap.setDescription('The trap contains QoS statistics for a single RTP session. The device can send this trap when an RTP session that experienced bad QoS terminates')
avRtpQoSFault = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 7, 0, 2)).setObjects(("AVAYA-RTP-MIB", "avRtpQoSFaultTh"), ("AVAYA-RTP-MIB", "avRtpQoSClearTh"), ("AVAYA-RTP-MIB", "avRtpSessionSeverity"))
if mibBuilder.loadTexts: avRtpQoSFault.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSFault.setDescription('The trap indicates that more than XXX RTP sessions currently suffers from bad QoS.')
avRtpQoSClear = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 7, 0, 3)).setObjects(("AVAYA-RTP-MIB", "avRtpQoSFaultTh"), ("AVAYA-RTP-MIB", "avRtpQoSClearTh"), ("AVAYA-RTP-MIB", "avRtpSessionSeverity"))
if mibBuilder.loadTexts: avRtpQoSClear.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSClear.setDescription('This trap indicates that a QoS fault, previously indicated by an avRtpQoSFault has cleared. ')
avRtpQoSInetTrap = NotificationType((1, 3, 6, 1, 4, 1, 6889, 2, 7, 0, 4)).setObjects(("AVAYA-RTP-MIB", "avRtpSessionLocInetAddrType"), ("AVAYA-RTP-MIB", "avRtpSessionLocInetAddr"), ("AVAYA-RTP-MIB", "avRtpSessionRemInetAddrType"), ("AVAYA-RTP-MIB", "avRtpSessionRemInetAddr"), ("AVAYA-RTP-MIB", "avRtpSessionDuration"), ("AVAYA-RTP-MIB", "avRtpSessionCname"), ("AVAYA-RTP-MIB", "avRtpSessionPhone"), ("AVAYA-RTP-MIB", "avRtpSessionSeverity"), ("AVAYA-RTP-MIB", "avRtpSessionDebugStr"))
if mibBuilder.loadTexts: avRtpQoSInetTrap.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSInetTrap.setDescription('The trap contains QoS statistics for a single RTP session over IPv4/IPv6. The device can send this trap when an RTP session that experienced bad QoS terminates')
avRtpConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1))
avRtpThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1), )
if mibBuilder.loadTexts: avRtpThresholdTable.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdTable.setDescription('Thresholds configuration table')
avRtpThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1), ).setIndexNames((0, "AVAYA-RTP-MIB", "avRtpThresholdSet"))
if mibBuilder.loadTexts: avRtpThresholdEntry.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdEntry.setDescription('Each entry contains one set of thresholds. In this version only one entry is supported (1). ')
avRtpThresholdSet = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpThresholdSet.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdSet.setDescription('The threshold set')
avRtpThresholdMinStatWin = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdMinStatWin.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdMinStatWin.setDescription('The minimum number of observed RTP sequence numbers advance needed for the evaluation of packet loss. ')
avRtpThresholdRxCodecLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 3), AvRtpLoss()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxCodecLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxCodecLoss.setDescription('Codec packet loss i.e. the loss at the codec decoder. This threshold is evaluated once for each statistical interval (6-12 seconds)')
avRtpThresholdRxAvgCodecLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 4), AvRtpLoss()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxAvgCodecLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxAvgCodecLoss.setDescription('Threshold on the avarage codec loss')
avRtpThresholdRxCodecLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxCodecLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxCodecLossEv.setDescription('The device generates a QoS traps if avRtpThresholdRxCodecLoss was crossed avRtpThresholdRxCodecLossEv times during the session (0 means that no traps are sent for this threshold).')
avRtpThresholdCodecRtt = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdCodecRtt.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdCodecRtt.setDescription('Codec round trip time threshold (an estimate for the overall RTT, including the internal delays). This threshold is evaluated each time an RTCP message is received (usually every 6-12 seconds)')
avRtpThresholdCodecRttEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdCodecRttEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdCodecRttEv.setDescription('The device generates a QoS traps if avRtpThresholdCodecRtt was crossed avRtpThresholdCodecRttEv times during the session (0 means that no traps are sent for this threshold).')
avRtpThresholdEcReturnLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdEcReturnLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdEcReturnLoss.setDescription('Echo Cancellation return loss in -dBm. High value (low absolute) means that a lot of energy is returned which can result in auditable echos. This threshold is evaluated once for each statistical interval (6-12 seconds) ')
avRtpThresholdEcReturnLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdEcReturnLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdEcReturnLossEv.setDescription('')
avRtpThresholdRxLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 10), AvRtpLoss()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxLoss.setDescription('The received packet loss. This threshold is evaluated once for each statistical interval (6-12 seconds) ')
avRtpThresholdRxLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxLossEv.setDescription('The device generates a QoS traps if avRtpThresholdRxCodecLoss was crossed avRtpThresholdRxCodecLossEv times during the session (0 means that no traps are sent for this threshold).')
avRtpThresholdRemLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 12), AvRtpLoss()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRemLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRemLoss.setDescription('Remote peer packet loss threshold learnt from received RTCP reports. This threshold is evaluated once for each statistical interval (6-12 seconds) ')
avRtpThresholdRemLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRemLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRemLossEv.setDescription('')
avRtpThresholdAvgRxLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 14), AvRtpLoss()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdAvgRxLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdAvgRxLoss.setDescription('The received average packet loss. This threshold is evaluated at the end of the session.')
avRtpThresholdAvgRemLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 15), AvRtpLoss()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdAvgRemLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdAvgRemLoss.setDescription('Threshold on the average remote packet loss, learnt from RTCP reports. This threshold is evaluated at the end of the session.')
avRtpThresholdRxJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxJitter.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxJitter.setDescription('A threshold on the received inter-arrival jitter, measured in milliseconds. This threshold is evaluated once for each statistical interval (6-12 seconds)')
avRtpThresholdRxJitterEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxJitterEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxJitterEv.setDescription('')
avRtpThresholdRemJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRemJitter.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRemJitter.setDescription('A threshold on the remote inter-arrival jitter, learnt from RTCP reports. This item is measured in milliseconds and is evaluated upon reception of an RTCP message.')
avRtpThresholdRemJitterEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRemJitterEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRemJitterEv.setDescription('')
avRtpThresholdRtt = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRtt.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRtt.setDescription('A threshold on the network round-trip-time, measured in milliseconds. This item is evaluated upon reception of RTCP messages.')
avRtpThresholdRttEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRttEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRttEv.setDescription('')
avRtpThresholdRxSsrcChangeEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpThresholdRxSsrcChangeEv.setStatus('current')
if mibBuilder.loadTexts: avRtpThresholdRxSsrcChangeEv.setDescription('The device would generate an end-of-session QoS trap if the number of observed SSRC changes was over this treshold.')
avRtpEnable = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpEnable.setStatus('current')
if mibBuilder.loadTexts: avRtpEnable.setDescription('Enable RTP statistic collection by the device. Note that statistic collection may cause minor performance hit.')
avRtpQoSTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 3), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpQoSTrapEnable.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSTrapEnable.setDescription('EEnable the QoS-Trap generation.')
avRtpQoSFaultTrapEnable = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 4), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpQoSFaultTrapEnable.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSFaultTrapEnable.setDescription('Enable the QoS-Trap generation.')
avRtpQoSFaultTh = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpQoSFaultTh.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSFaultTh.setDescription("The number of concurrent active RTP sessions that suffers from bad QoS (according to avRtpThresholds) that cause the device to enter a 'QoS fault' state. Note, upon entering this fault state, the device sends a avRtpQoSFault trap.")
avRtpQoSClearTh = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpQoSClearTh.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSClearTh.setDescription("The number of concurrent active RTP sessions that suffers from bad QoS (according to avRtpThresholds) that clears the 'QoS fault' state. Note, when the QoS fault clears, the device send a avRtpQoSClear trap.")
avRtpTxQoSTraps = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpTxQoSTraps.setStatus('current')
if mibBuilder.loadTexts: avRtpTxQoSTraps.setDescription('The number of avRtpQoSTrap sent so far.')
avRtpQoSTrapsDrop = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpQoSTrapsDrop.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSTrapsDrop.setDescription('The number of avRtpQoSTraps that were dropped by the rate limiter')
avRtpQoSTrapTokenInterval = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 9), TimeInterval().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpQoSTrapTokenInterval.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSTrapTokenInterval.setDescription('Configure the QoS trap token-bucket rate limiter. This item sets the token interval in hundredth of seconds.')
avRtpQoSTrapBucketSize = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1000)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpQoSTrapBucketSize.setStatus('current')
if mibBuilder.loadTexts: avRtpQoSTrapBucketSize.setDescription('Configure the QoS trap token-bucket rate limiter. This item configures the bucket-size.')
avRtpDateAndTime = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 11), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpDateAndTime.setStatus('current')
if mibBuilder.loadTexts: avRtpDateAndTime.setDescription('The current RTC date and Time')
avRtpMaxSessionTableSize = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpMaxSessionTableSize.setStatus('current')
if mibBuilder.loadTexts: avRtpMaxSessionTableSize.setDescription('The maximum number of rows of the session table')
avRtpReservedSessionTableRows = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpReservedSessionTableRows.setStatus('current')
if mibBuilder.loadTexts: avRtpReservedSessionTableRows.setDescription('The number of rows in session table reserved for terminated sessions that had QoS events ')
avRtpClear = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 14), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpClear.setStatus('current')
if mibBuilder.loadTexts: avRtpClear.setDescription('Clear the Session table')
avRtpFaultMask = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 1))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpFaultMask.setStatus('current')
if mibBuilder.loadTexts: avRtpFaultMask.setDescription('Fault mask enables Avaya Fault-Mon to poll the device status Bit 0 - Set if there is a fault condition according to avRtpQoSFaultTh/avRtpQoSClearTh')
avRtpSessionTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2), )
if mibBuilder.loadTexts: avRtpSessionTable.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTable.setDescription('This table contains statistics for recently terminated RTP flows.')
avRtpSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1), ).setIndexNames((0, "AVAYA-RTP-MIB", "avRtpSessionState"), (0, "AVAYA-RTP-MIB", "avRtpSessionID"))
if mibBuilder.loadTexts: avRtpSessionEntry.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionEntry.setDescription('Each row contains information from a single RTP session. Rows are removed when the space limits are reached (avRtpSessionTableSize). There are avRtpSessionTableReservedRows reserved rows for terminated sessions that had QoS events. Sessions that had QoS events might appear twice in the table, e.g. once with AvRtpSessionState = terminated and once with terminatedWithEvent. ')
avRtpSessionState = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("active", 1), ("activeWithEvent", 2), ("terminated", 3), ("terminatedWithEvent", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionState.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionState.setDescription('An arbitrary RTP-flow sequence number, serves as the MIB tables index')
avRtpSessionID = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionID.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionID.setDescription('An arbitrary RTP-flow sequence number, serves as the MIB tables index')
avRtpSessionEngineID = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionEngineID.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionEngineID.setDescription('The number of the VoIP engine responsible for the RTP stream. More information about the specific VoIP engine can be found in avRtpSumTable')
avRtpSessionLocAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionLocAddrType.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionLocAddrType.setDescription('This item specifies whether the IP addresses in this row are in IPv6 or in IPv4 format (See RFC3291)')
avRtpSessionLocAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionLocAddr.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionLocAddr.setDescription('The RTP stream local RTP address.')
avRtpSessionLocAddrV4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionLocAddrV4.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionLocAddrV4.setDescription('The RTP stream local RTP address (IPv4).')
avRtpSessionLocAddrV6 = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 7), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionLocAddrV6.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionLocAddrV6.setDescription('The RTP stream local RTP address (IPv6).')
avRtpSessionRemAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemAddrType.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemAddrType.setDescription('This item specifies whether the remote IP addresses in this row is in IPv6 or in IPv4 format (See RFC3291)')
avRtpSessionRemAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemAddr.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemAddr.setDescription('The RTP stream remote peer address')
avRtpSessionRemAddrV4 = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemAddrV4.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemAddrV4.setDescription('The RTP stream Remote RTP address (IPv4).')
avRtpSessionRemAddrV6 = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 11), InetAddressIPv6()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemAddrV6.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemAddrV6.setDescription('The RTP stream Remote RTP address (IPv6).')
avRtpSessionLocPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 12), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionLocPort.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionLocPort.setDescription('The RTP stream local UDP port')
avRtpSessionRemPort = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 13), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemPort.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemPort.setDescription('The RTP stream remote UDP port')
avRtpSessionStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 14), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionStartTime.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionStartTime.setDescription('The stream start time')
avRtpSessionEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 15), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionEndTime.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionEndTime.setDescription('The stream end time')
avRtpSessionDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 16), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionDuration.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionDuration.setDescription('The duration of the stream in hundredth of seconds')
avRtpSessionCname = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionCname.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionCname.setDescription('The RTP canonical name of the gateway')
avRtpSessionPhone = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionPhone.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionPhone.setDescription('A string containing the phone extensions (received for CM), in the format of <conferenceID>:<extension #1>...<extension #N>')
avRtpSessionSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("cleared", 1), ("indeterminate", 2), ("critical", 3), ("major", 4), ("minor", 5), ("warning", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionSeverity.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionSeverity.setDescription("The QoS problem severity for the stream. This item equals to 'warning' if a trap was suppose to be sent. and 'cleared' otherwise. ")
avRtpSessionTxLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxLen.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxLen.setDescription('The transmitted RTP packet size')
avRtpSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 4, 8, 9, 15, 18, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 255))).clone(namedValues=NamedValues(("g711u", 0), ("g723", 4), ("g711a", 8), ("g722", 9), ("g728", 15), ("g729", 18), ("avayaFaxRelay", 128), ("t38fax", 129), ("faxPassThru", 130), ("ttyRelay", 131), ("ttyPassThru", 132), ("modemRelay", 133), ("modemPassThru", 134), ("clearChannel", 135), ("g729a", 136), ("g729ab", 137), ("g729b", 138), ("g726a32", 139), ("unspecified", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionType.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionType.setDescription('This value describes the session type. It holds the RTP type for RTP streams and unique items (above 127) for non-RTP or dynamically allocated types')
avRtpSessionTxInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxInterval.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxInterval.setDescription('The interval (in milliseconds) between RTP packets.')
avRtpSessionTxEncryp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(-1, 0, 1, 2, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("unknown", -1), ("encryptionOff", 0), ("encryptionAEAv2", 1), ("encryptionAES", 2), ("srtpAesCm128", 4), ("srtpAesCm128HmacSha180", 5), ("srtpAesCm128HmacSha132", 6), ("srtpF8128HmacSha180", 7), ("srtpHmacSha180", 8), ("srtpHmacSha132", 9), ("srtp", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxEncryp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxEncryp.setDescription('The Media Encryption metric indicates what kind media encryption is ,if any, is used for the RTP session. This information is valuable because: 1) media-encryption consumes more VoIP resources 2) Encryption key infrastructure may cause problems encryptionOff(0) - Encryption is off encryptionAEAv2(1) - Avaya Proprietary AEAv2 encryption encryptionAES(2) - Avaya Proprietary AES encryption Standard Encryption (Secure RTP): srtpAesCm128(4) - Counter Mode 128 AES encryption, no authentication srtpAesCm128HmacSha180(5) - AES encryption, 80bit SHA1 authentication srtpAesCm128HmacSha132(6) - AES encryption, 32bit SHA1 authentication srtpF8128HmacSha180(7) - F8 encryption, 80bit SHA1 authentication srtpHmacSha180(8) - No encryption, 80bit SHA1 authentication srtpHmacSha132(9) - No encryption, 32bit SHA1 authentication ')
avRtpSessionTxDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxDscp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxDscp.setDescription('The last transmitted IP DSCP. This value may change during the call according to the RSVP status.This information is valuable because routers may give different priority to packets according to their DSCP value')
avRtpSessionTxVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxVlan.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxVlan.setDescription("The VLAN on which the RTP packets are transmitted. Minus one means 'unknown'")
avRtpSessionTxL2Pri = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxL2Pri.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxL2Pri.setDescription('The Layer 2 (e.g. IEEE 802.1p) priority of the sent Ethernet frames. Minus 1 means unknown. This information is valuable because Ethernet switches can give frames different priority according to their 802.1p value')
avRtpSessionTxSilenceSupp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 27), AvRtpSilenceSupp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxSilenceSupp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxSilenceSupp.setDescription("Silence suppression state.noRtp means that a simple silence suppression scheme was used i.e. without RTP packets on silence. Complex means that a combination of silence packets and 'no RTP on Silence' is usedThis information is valuable because: 1) silence suppression can save upto %60 bandwidth 2) Silence suppression influences user experience (especially if the terminals does not generate confort-noise)")
avRtpSessionTxSsrc = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 28), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxSsrc.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxSsrc.setDescription('The transmitted RTP stream SSRC.This value can be used to locate a stream in a packet capture.')
avRtpSessionTxRsvp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unused", 0), ("disabled", 1), ("pending", 2), ("failed", 3), ("reserved", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxRsvp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxRsvp.setDescription('The RSVP status for the stream. This information is valuable because: 1) Routers may reserve bandwidth to for the stream. 2) Avaya VoIP endpoints changes the transmitted DSCP according to the RSVP status. ')
avRtpSessionTxResvFail = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 30), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxResvFail.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxResvFail.setDescription('The number of times the RSVP reservation has failed. This item is init to one if RSVP is in-use.')
avRtpSessionStatInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 31), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionStatInterval.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionStatInterval.setDescription('The thresholds are evaluated periodically, usually each time an RTCP message is being sent.')
avRtpSessionRxCodecPlayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxCodecPlayTime.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxCodecPlayTime.setDescription('The time the codec has played frames (not including silence suppression or fill frames)')
avRtpSessionRxCodecLossCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxCodecLossCount.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxCodecLossCount.setDescription('The total codec loss time in milliseconds ')
avRtpSessionRxCodecLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 34), AvRtpLoss()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxCodecLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxCodecLoss.setDescription('The codec loss during the last Statistical interval, in 1/1000 units. The codec loss is the number of fill period divided by the statistical interval. The fill period is the duration of time that the codec had to send data to the digital to analog converter, but no codec frames were available in the jitter buffer. This is a measure for the overall packet loss after the jitter and resequencing re sequencing buffers.')
avRtpSessionRxAvgCodecLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 35), AvRtpLoss()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxAvgCodecLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxAvgCodecLoss.setDescription('The total codec loss during the session.')
avRtpSessionRxCodecLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxCodecLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxCodecLossEv.setDescription('The number of times codec loss was sampled over the threshold')
avRtpSessionRxLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 37), AvRtpLoss()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxLoss.setDescription('The received network loss in the last statistical interval (in 1/1000 units).')
avRtpSessionRxAvgLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 38), AvRtpLoss()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxAvgLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxAvgLoss.setDescription('The total network loss during the session (in 1/1000 units).')
avRtpSessionRxLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxLossEv.setDescription('The number of times network loss was sampled over the threshold')
avRtpSessionRx = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRx.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRx.setDescription('The total number of received RTP packets')
avRtpSessionRxLossCount = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxLossCount.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxLossCount.setDescription('The total number of lost packets')
avRtpSessionRxSeqFall = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxSeqFall.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxSeqFall.setDescription('The total number of sequence fall events')
avRtpSessionRxDup = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxDup.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxDup.setDescription('The total number of received duplicate packets. This item may indicate transient routing loop')
avRtpSessionRxJBufUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 44), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxJBufUnderruns.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxJBufUnderruns.setDescription('The duration of jitter buffer under runs during the call in milliseconds (i.e. buffer empty when a frame is needed by the codec).')
avRtpSessionRxJBufOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 45), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxJBufOverruns.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxJBufOverruns.setDescription('The duration of time in codec frames that were dropped due to jitter buffer overruns in milliseconds (i.e. jitter buffer is full)')
avRtpSessionRxJBufDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxJBufDelay.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxJBufDelay.setDescription('The last jitter buffer delay in milliseconds.')
avRtpSessionRxMaxJBufDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxMaxJBufDelay.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxMaxJBufDelay.setDescription('The maximum jitter buffer delay during the call (in milliseconds)')
avRtpSessionRxJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxJitter.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxJitter.setDescription('The last/current received RTP jitter')
avRtpSessionRxAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxAvgJitter.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxAvgJitter.setDescription('The average received RTP jitter')
avRtpSessionRxJitterEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxJitterEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxJitterEv.setDescription('The number of times, jitter was sampled over the threshold.')
avRtpSessionRxTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxTtl.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxTtl.setDescription('The current/last received TTL value (IP Time To Live)')
avRtpSessionRxMinTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxMinTtl.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxMinTtl.setDescription('The minimum received TTL value. The technician can use this value as a hint to what was the IP route during the session. ')
avRtpSessionRxMaxTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxMaxTtl.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxMaxTtl.setDescription('The maximum received TTL value. Difference between this value and avRtpSessionRxMinTtl may indicate route changes during the call.')
avRtpSessionRxDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxDscp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxDscp.setDescription('The last received DSCP value.')
avRtpSessionRxL2Pri = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxL2Pri.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxL2Pri.setDescription('The last received L2 priority (IEEE 802.1p, Ethernet priority)')
avRtpSessionRxSilenceSupp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 56), AvRtpSilenceSupp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxSilenceSupp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxSilenceSupp.setDescription('The observed (received) silence suppression technique.')
avRtpSessionRxSsrc = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 57), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxSsrc.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxSsrc.setDescription('The last received RTP SSRC value')
avRtpSessionRxSsrcChange = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxSsrcChange.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxSsrcChange.setDescription('Counts the number of observed SSRC changes during the call. This may indicate a remote VoIP engine fail-over event.')
avRtpSessionTxRtcp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxRtcp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxRtcp.setDescription('The total number of transmitted RTCP reports')
avRtpSessionRxRtcp = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxRtcp.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxRtcp.setDescription('The total number of received RTCP reports')
avRtpSessionCodecRtt = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionCodecRtt.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionCodecRtt.setDescription('The Estimated analog overall round-trip time calculated from the last received RTCP packet. The estimate value include the network delay plus the internal delays plus an estimate for the remote internal delay. This value is measured in milliseconds.')
avRtpSessionAvgCodecRtt = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 62), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionAvgCodecRtt.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionAvgCodecRtt.setDescription('The Avarage Estimated analog overall RTT (including internal delays) during the session.')
avRtpSessionCodecRttEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionCodecRttEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionCodecRttEv.setDescription('The number of times the Estimated analog codec RTT was over the threshold')
avRtpSessionRtt = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 64), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRtt.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRtt.setDescription('The last RTT value in milliseconds. RTT is learnt from RTCP reports')
avRtpSessionAvgRtt = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 65), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionAvgRtt.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionAvgRtt.setDescription('The average RTT during the RTP sessions')
avRtpSessionRttEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRttEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRttEv.setDescription('The number of received RTCP packets which has indicated that RTT was over the threshold.')
avRtpSessionRemLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 67), AvRtpLoss()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemLoss.setDescription('The last known remote loss (learnt from received RTCP message)')
avRtpSessionRemAvgLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 68), AvRtpLoss()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemAvgLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemAvgLoss.setDescription('The last known remote loss (learnt from received RTCP message)')
avRtpSessionRemLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 69), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemLossEv.setDescription('The number of received RTCP packets which has indicated that loss, at the remote peer, was over the threshold..')
avRtpSessionRemJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 70), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemJitter.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemJitter.setDescription('The last known remote jitter, learnt from RTCP.')
avRtpSessionRemAvgJitter = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 71), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemAvgJitter.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemAvgJitter.setDescription('The average remote jitter, learnt from RTCP.')
avRtpSessionRemJitterEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 72), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRemJitterEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemJitterEv.setDescription('The number of received RTCP messages, which have indicated that loss was over the threshold.')
avRtpSessionEcTailLen = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 73), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionEcTailLen.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionEcTailLen.setDescription('The current/last echo cancellation tail length.')
avRtpSessionEcReturnLoss = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 74), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionEcReturnLoss.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionEcReturnLoss.setDescription('The last sampled Echo Cancellation return loss. ')
avRtpSessionEcReturnLossEv = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 75), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionEcReturnLossEv.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionEcReturnLossEv.setDescription('The number of time the echo cancellation return loss was sampled over the threshold. This value is sampled every avRtpSessionStatInerval')
avRtpSessionAEC = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("notSupported", 0), ("none", 1), ("halfDuplex", 2), ("fullDuplex", 3), ("aec", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionAEC.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionAEC.setDescription('Acoustic echo cancellation state, relevant for speaker phones')
avRtpSessionDebugStr = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 77), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionDebugStr.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionDebugStr.setDescription('This string contains the major metrics in human readable form. It is used by the QoS trap.')
avRtpSessionTxFlowLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 78), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionTxFlowLabel.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionTxFlowLabel.setDescription('The last transmitted IPv6 Flow Label. This metric represents the most recently transmitted IPv6 Flow Label field in the IPv6 RTP stream. The value fits in a 20-bit integer and is reset to zero et the start of each new RTP session.')
avRtpSessionRxFlowLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 2, 1, 79), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048575))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSessionRxFlowLabel.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRxFlowLabel.setDescription('The last Received IPv6 Flow Label. This metric represents the value of the IPv6 Flow Label field of the incoming RTP packets. The Received IPv6 Flow Label metric is a 20-bit integer. The metric is set with the first IPv6 RTP packet received, and updated when the value has changed from the previously reported value.')
avRtpSumTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3), )
if mibBuilder.loadTexts: avRtpSumTable.setStatus('current')
if mibBuilder.loadTexts: avRtpSumTable.setDescription('This table contains summary of sessions and QoS events for each VoIP engine.')
avRtpSumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1), ).setIndexNames((0, "AVAYA-RTP-MIB", "avRtpSumEngineID"))
if mibBuilder.loadTexts: avRtpSumEntry.setStatus('current')
if mibBuilder.loadTexts: avRtpSumEntry.setDescription(' ')
avRtpSumEngineID = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumEngineID.setStatus('current')
if mibBuilder.loadTexts: avRtpSumEngineID.setDescription('VoIP engine identifier. Usually, the VoIP engine slot number.')
avRtpSumEngineDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumEngineDescr.setStatus('current')
if mibBuilder.loadTexts: avRtpSumEngineDescr.setDescription('A string describing the VoIP engine. Equals to entPhysicalDescr or cmgModuleDescription ')
avRtpSumPeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 3), TimeInterval()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumPeriod.setStatus('current')
if mibBuilder.loadTexts: avRtpSumPeriod.setDescription('The time since the summary counters were cleared.')
avRtpSumActiveFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumActiveFlows.setStatus('current')
if mibBuilder.loadTexts: avRtpSumActiveFlows.setDescription('The number of active flows')
avRtpSumActiveQosEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumActiveQosEvents.setStatus('current')
if mibBuilder.loadTexts: avRtpSumActiveQosEvents.setDescription('The number of flows that currently suffers from QoS problems.')
avRtpSumTotalFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumTotalFlows.setStatus('current')
if mibBuilder.loadTexts: avRtpSumTotalFlows.setDescription('The total number of flows')
avRtpSumTotalFlowsQoSEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumTotalFlowsQoSEvents.setStatus('current')
if mibBuilder.loadTexts: avRtpSumTotalFlowsQoSEvents.setDescription('The total number of flows that had QoS events')
avRtpSumTxTTL = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumTxTTL.setStatus('current')
if mibBuilder.loadTexts: avRtpSumTxTTL.setDescription('TTL of transmitted RTP packets.')
avRtpSumSessionDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpSumSessionDuration.setStatus('current')
if mibBuilder.loadTexts: avRtpSumSessionDuration.setDescription('Total duration of the sessions in seconds')
avRtpSumClear = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 3, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: avRtpSumClear.setStatus('current')
if mibBuilder.loadTexts: avRtpSumClear.setDescription('Clear the summary counters')
avRtpLookupTable = MibTable((1, 3, 6, 1, 4, 1, 6889, 2, 7, 4), )
if mibBuilder.loadTexts: avRtpLookupTable.setStatus('current')
if mibBuilder.loadTexts: avRtpLookupTable.setDescription('This virtual table is used for finding a specific SessionIDs based on the remote address and call state.')
avRtpLookupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 6889, 2, 7, 4, 1), ).setIndexNames((0, "AVAYA-RTP-MIB", "avRtpSessionRemAddrType"), (0, "AVAYA-RTP-MIB", "avRtpSessionRemAddr"), (0, "AVAYA-RTP-MIB", "avRtpSessionState"), (0, "AVAYA-RTP-MIB", "avRtpSessionID"))
if mibBuilder.loadTexts: avRtpLookupEntry.setStatus('current')
if mibBuilder.loadTexts: avRtpLookupEntry.setDescription('')
avRtpLookupStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 6889, 2, 7, 4, 1, 1), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: avRtpLookupStartTime.setStatus('current')
if mibBuilder.loadTexts: avRtpLookupStartTime.setDescription('The stream start time')
avRtpNotificationVarbinds = ObjectIdentity((1, 3, 6, 1, 4, 1, 6889, 2, 7, 5))
if mibBuilder.loadTexts: avRtpNotificationVarbinds.setStatus('current')
if mibBuilder.loadTexts: avRtpNotificationVarbinds.setDescription('Notify only varbinds used for notifications in avRtpNotification group')
avRtpSessionLocInetAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 5, 1), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: avRtpSessionLocInetAddrType.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionLocInetAddrType.setDescription('The RTP stream local RTP address Type (IPv4/IPv6).')
avRtpSessionLocInetAddr = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 5, 2), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: avRtpSessionLocInetAddr.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionLocInetAddr.setDescription('The RTP stream local RTP address (IPv4/IPv6).')
avRtpSessionRemInetAddrType = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 5, 3), InetAddressType()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: avRtpSessionRemInetAddrType.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemInetAddrType.setDescription('The RTP stream remote RTP address Type (IPv4/IPv6).')
avRtpSessionRemInetAddr = MibScalar((1, 3, 6, 1, 4, 1, 6889, 2, 7, 5, 4), InetAddress()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: avRtpSessionRemInetAddr.setStatus('current')
if mibBuilder.loadTexts: avRtpSessionRemInetAddr.setDescription('The RTP stream remote RTP address (IPv4/IPv6).')
mibBuilder.exportSymbols("AVAYA-RTP-MIB", avRtpLookupStartTime=avRtpLookupStartTime, avRtpSessionRxMinTtl=avRtpSessionRxMinTtl, avRtpSessionLocAddr=avRtpSessionLocAddr, avRtpNotificationVarbinds=avRtpNotificationVarbinds, avRtpSessionEndTime=avRtpSessionEndTime, avRtpSessionRxJitterEv=avRtpSessionRxJitterEv, avRtpThresholdRemLoss=avRtpThresholdRemLoss, avRtpSessionEcReturnLoss=avRtpSessionEcReturnLoss, avRtpSessionRemAvgJitter=avRtpSessionRemAvgJitter, avRtpSessionLocInetAddr=avRtpSessionLocInetAddr, avRtpSessionRxCodecLossCount=avRtpSessionRxCodecLossCount, avRtpSessionStatInterval=avRtpSessionStatInterval, avRtpThresholdEcReturnLoss=avRtpThresholdEcReturnLoss, avRtpQoSTrapsDrop=avRtpQoSTrapsDrop, avRtpThresholdRxLoss=avRtpThresholdRxLoss, avRtpSessionRxDup=avRtpSessionRxDup, AvRtpSilenceSupp=AvRtpSilenceSupp, avRtpSessionRemJitter=avRtpSessionRemJitter, avRtpSessionPhone=avRtpSessionPhone, avRtpSessionRemAddr=avRtpSessionRemAddr, avRtpThresholdRxCodecLossEv=avRtpThresholdRxCodecLossEv, avRtpSessionRxCodecLossEv=avRtpSessionRxCodecLossEv, avRtpSessionEntry=avRtpSessionEntry, avRtpSessionCodecRttEv=avRtpSessionCodecRttEv, avRtpSessionState=avRtpSessionState, avRtpSessionTxFlowLabel=avRtpSessionTxFlowLabel, avRtpSessionID=avRtpSessionID, avRtpSessionRemAddrType=avRtpSessionRemAddrType, avRtpSessionRxAvgJitter=avRtpSessionRxAvgJitter, avRtpQoSTrap=avRtpQoSTrap, avRtpSumEngineID=avRtpSumEngineID, avRtpSessionRemLossEv=avRtpSessionRemLossEv, avRtpSessionRxSsrc=avRtpSessionRxSsrc, avRtpSessionTxLen=avRtpSessionTxLen, avRtpNotification=avRtpNotification, avRtpQoSFault=avRtpQoSFault, avRtpQoSTrapTokenInterval=avRtpQoSTrapTokenInterval, avRtpSessionAEC=avRtpSessionAEC, avRtpTxQoSTraps=avRtpTxQoSTraps, avRtpLookupEntry=avRtpLookupEntry, avRtpSessionRxDscp=avRtpSessionRxDscp, avRtpSessionRxCodecPlayTime=avRtpSessionRxCodecPlayTime, avRtpQoSClear=avRtpQoSClear, avRtpSessionRxJBufOverruns=avRtpSessionRxJBufOverruns, avRtpLookupTable=avRtpLookupTable, avRtpThresholdCodecRttEv=avRtpThresholdCodecRttEv, avRtpSessionTxRsvp=avRtpSessionTxRsvp, avRtpEnable=avRtpEnable, PYSNMP_MODULE_ID=avRtpMib, avRtpSessionTxDscp=avRtpSessionTxDscp, avRtpThresholdRxAvgCodecLoss=avRtpThresholdRxAvgCodecLoss, avRtpSessionEcReturnLossEv=avRtpSessionEcReturnLossEv, avRtpSessionRemAvgLoss=avRtpSessionRemAvgLoss, avRtpSumActiveQosEvents=avRtpSumActiveQosEvents, avRtpSessionRxL2Pri=avRtpSessionRxL2Pri, avRtpSessionLocAddrV6=avRtpSessionLocAddrV6, avRtpMib=avRtpMib, avRtpSessionTxSsrc=avRtpSessionTxSsrc, avRtpSessionCodecRtt=avRtpSessionCodecRtt, avRtpThresholdEntry=avRtpThresholdEntry, avRtpMaxSessionTableSize=avRtpMaxSessionTableSize, avRtpQoSInetTrap=avRtpQoSInetTrap, avRtpSumTotalFlows=avRtpSumTotalFlows, avRtpSessionRxSilenceSupp=avRtpSessionRxSilenceSupp, avRtpSessionTxL2Pri=avRtpSessionTxL2Pri, avRtpThresholdRemJitter=avRtpThresholdRemJitter, avRtpSessionDebugStr=avRtpSessionDebugStr, avRtpThresholdRxSsrcChangeEv=avRtpThresholdRxSsrcChangeEv, avRtpSessionRxSsrcChange=avRtpSessionRxSsrcChange, avRtpQoSClearTh=avRtpQoSClearTh, avRtpSessionTxRtcp=avRtpSessionTxRtcp, avRtpThresholdRemLossEv=avRtpThresholdRemLossEv, avRtpSumSessionDuration=avRtpSumSessionDuration, avRtpSessionRxLoss=avRtpSessionRxLoss, avRtpThresholdEcReturnLossEv=avRtpThresholdEcReturnLossEv, avRtpSessionEngineID=avRtpSessionEngineID, avRtpFaultMask=avRtpFaultMask, avRtpSessionRxJBufDelay=avRtpSessionRxJBufDelay, avRtpSessionRemLoss=avRtpSessionRemLoss, avRtpSumEntry=avRtpSumEntry, avRtpThresholdAvgRxLoss=avRtpThresholdAvgRxLoss, avRtpSessionRxMaxJBufDelay=avRtpSessionRxMaxJBufDelay, avRtpSessionLocPort=avRtpSessionLocPort, mibs=mibs, avRtpSumTxTTL=avRtpSumTxTTL, avRtpThresholdSet=avRtpThresholdSet, avRtpConfig=avRtpConfig, avRtpSessionRxMaxTtl=avRtpSessionRxMaxTtl, avRtpSessionRxRtcp=avRtpSessionRxRtcp, avRtpThresholdCodecRtt=avRtpThresholdCodecRtt, avRtpSessionType=avRtpSessionType, avRtpSumEngineDescr=avRtpSumEngineDescr, avRtpQoSFaultTrapEnable=avRtpQoSFaultTrapEnable, avaya=avaya, avRtpSessionDuration=avRtpSessionDuration, avRtpSessionRxFlowLabel=avRtpSessionRxFlowLabel, avRtpSessionSeverity=avRtpSessionSeverity, avRtpThresholdRttEv=avRtpThresholdRttEv, avRtpSessionRxSeqFall=avRtpSessionRxSeqFall, avRtpSumClear=avRtpSumClear, avRtpQoSTrapEnable=avRtpQoSTrapEnable, avRtpThresholdAvgRemLoss=avRtpThresholdAvgRemLoss, avRtpSessionRemInetAddrType=avRtpSessionRemInetAddrType, avRtpThresholdRxLossEv=avRtpThresholdRxLossEv, avRtpSessionTxSilenceSupp=avRtpSessionTxSilenceSupp, avRtpSessionTxResvFail=avRtpSessionTxResvFail, avRtpSessionAvgCodecRtt=avRtpSessionAvgCodecRtt, avRtpSessionTxVlan=avRtpSessionTxVlan, avRtpSessionRx=avRtpSessionRx, avRtpSessionCname=avRtpSessionCname, avRtpReservedSessionTableRows=avRtpReservedSessionTableRows, avRtpSessionStartTime=avRtpSessionStartTime, avRtpQoSTrapBucketSize=avRtpQoSTrapBucketSize, avRtpSessionRxLossEv=avRtpSessionRxLossEv, avRtpSessionRemJitterEv=avRtpSessionRemJitterEv, avRtpDateAndTime=avRtpDateAndTime, avRtpSessionAvgRtt=avRtpSessionAvgRtt, AvRtpItuPerceivedSeverity=AvRtpItuPerceivedSeverity, avRtpSessionTable=avRtpSessionTable, avRtpThresholdTable=avRtpThresholdTable, avRtpSessionRttEv=avRtpSessionRttEv, avRtpSessionTxInterval=avRtpSessionTxInterval, avRtpSessionRxJBufUnderruns=avRtpSessionRxJBufUnderruns, avRtpSessionRxLossCount=avRtpSessionRxLossCount, avRtpThresholdRemJitterEv=avRtpThresholdRemJitterEv, avRtpSessionRtt=avRtpSessionRtt, avRtpSessionLocInetAddrType=avRtpSessionLocInetAddrType, avRtpSessionRemAddrV6=avRtpSessionRemAddrV6, avRtpThresholdRxJitter=avRtpThresholdRxJitter, avRtpSessionRxJitter=avRtpSessionRxJitter, avRtpSumPeriod=avRtpSumPeriod, avRtpSessionRemPort=avRtpSessionRemPort, avRtpSumTotalFlowsQoSEvents=avRtpSumTotalFlowsQoSEvents, avRtpSessionRemAddrV4=avRtpSessionRemAddrV4, avRtpSessionRxCodecLoss=avRtpSessionRxCodecLoss, avRtpSessionTxEncryp=avRtpSessionTxEncryp, avRtpSumTable=avRtpSumTable, avRtpClear=avRtpClear, avRtpThresholdRxJitterEv=avRtpThresholdRxJitterEv, avRtpSumActiveFlows=avRtpSumActiveFlows, avRtpSessionEcTailLen=avRtpSessionEcTailLen, avRtpThresholdRxCodecLoss=avRtpThresholdRxCodecLoss, avRtpThresholdRtt=avRtpThresholdRtt, avRtpSessionRemInetAddr=avRtpSessionRemInetAddr, avRtpSessionRxAvgLoss=avRtpSessionRxAvgLoss, avRtpSessionRxAvgCodecLoss=avRtpSessionRxAvgCodecLoss, avRtpSessionRxTtl=avRtpSessionRxTtl, avRtpThresholdMinStatWin=avRtpThresholdMinStatWin, AvRtpLoss=AvRtpLoss, avRtpSessionLocAddrType=avRtpSessionLocAddrType, avRtpQoSFaultTh=avRtpQoSFaultTh, avRtpSessionLocAddrV4=avRtpSessionLocAddrV4)

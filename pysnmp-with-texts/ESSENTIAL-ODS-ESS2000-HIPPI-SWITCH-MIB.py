#
# PySNMP MIB module ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:06:39 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
NotificationType, Unsigned32, Counter64, Bits, TimeTicks, NotificationType, iso, enterprises, ModuleIdentity, IpAddress, Integer32, MibIdentifier, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "NotificationType", "Unsigned32", "Counter64", "Bits", "TimeTicks", "NotificationType", "iso", "enterprises", "ModuleIdentity", "IpAddress", "Integer32", "MibIdentifier", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
essentialCommunications = MibIdentifier((1, 3, 6, 1, 4, 1, 2159))
ecRoot = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1))
ecProducts = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3))
ecExperimental = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 6))
ess2000MIB = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2))
switch = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 1))
switchEvents = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 7))
switchDescription = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchDescription.setStatus('mandatory')
if mibBuilder.loadTexts: switchDescription.setDescription('Returns the description, vendor, and version numbers of the switch.')
switchNumOfPorts = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchNumOfPorts.setStatus('mandatory')
if mibBuilder.loadTexts: switchNumOfPorts.setDescription('The number of slots in this switch. (Max number of media access cards).')
switchSensors = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: switchSensors.setStatus('mandatory')
if mibBuilder.loadTexts: switchSensors.setDescription('This value returns the status of the temperature and power supply sensors. From least to most significant byte the values are power supply 1-3 with the most signficant byte being the over temperature sensor. 0 indicates the sensor is autodectable and not installed. 1 indicates the sensor is OK. 2 indicates the sensor is not OK.')
switchControlCard = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 2))
sccDescription = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sccDescription.setStatus('mandatory')
if mibBuilder.loadTexts: sccDescription.setDescription('The model, vendor, and version number of the switch control card.')
sccDateTime = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sccDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: sccDateTime.setDescription('The date/time in the real time clock. Format: yyyymmddhhmmss')
sccAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 2, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sccAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sccAdminStatus.setDescription('The desired state of the switch. 1 indicates switch is up. 2 will make the switch reset.')
sccOperStatus = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sccOperStatus.setDescription('The current state of the switch. 1 indicates the switch is up. 2 indicates the switch is resetting. SNMP operations can not occur when the switch is resetting. 3 indicates a busy switch. SNMP operations can not occur when the switch is busy. ')
mediaInterfaceCards = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3))
backPlaneTable = MibTable((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1), )
if mibBuilder.loadTexts: backPlaneTable.setStatus('mandatory')
if mibBuilder.loadTexts: backPlaneTable.setDescription('This table represent all of the slots in a HIPPI switch. None of the rows can be added to or deleted by the user.')
backPlaneEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1), ).setIndexNames((0, "ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB", "backPlaneIndex"))
if mibBuilder.loadTexts: backPlaneEntry.setStatus('mandatory')
if mibBuilder.loadTexts: backPlaneEntry.setDescription('A row in the table describing one slot in the switch backplane. ')
backPlaneIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 1), Gauge32())
if mibBuilder.loadTexts: backPlaneIndex.setStatus('mandatory')
if mibBuilder.loadTexts: backPlaneIndex.setDescription('The table index for this slot on the backplane.')
backPlaneNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: backPlaneNumber.setStatus('mandatory')
if mibBuilder.loadTexts: backPlaneNumber.setDescription('The slot number as seen printed on the switch (backPlaneIndex + 1)')
backPlaneCard = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: backPlaneCard.setStatus('mandatory')
if mibBuilder.loadTexts: backPlaneCard.setDescription('The type of MIC present in this slot of the backplane on the switch 0 No MIC 1 Unknown MIC 2 Parallel MIC 3 Serial MIC')
mICPowerUpInitError = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICPowerUpInitError.setStatus('mandatory')
if mibBuilder.loadTexts: mICPowerUpInitError.setDescription('1 if error detected by MIC on start-up, else 0.')
mICHippiParityBurstError = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICHippiParityBurstError.setStatus('mandatory')
if mibBuilder.loadTexts: mICHippiParityBurstError.setDescription('Type of parity error. 0 None 1 XDeMux (Transmitting) 2 XMux (Receiving)')
mICLinkReady = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICLinkReady.setStatus('mandatory')
if mibBuilder.loadTexts: mICLinkReady.setDescription('Valid the SMIC only. 1 if link ready asserted, else 0.')
mICSourceInterconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICSourceInterconnect.setStatus('mandatory')
if mibBuilder.loadTexts: mICSourceInterconnect.setDescription('Source interconnect is valid for the PMIC only. 1 if interconnect is true else 0')
mICSourceRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICSourceRequest.setStatus('mandatory')
if mibBuilder.loadTexts: mICSourceRequest.setDescription('1 if source request is asserted else 0.')
mICSourceConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICSourceConnect.setStatus('mandatory')
if mibBuilder.loadTexts: mICSourceConnect.setDescription('1 if source connect is asserted else 0.')
mICSourceLastConnectAttempt = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICSourceLastConnectAttempt.setStatus('mandatory')
if mibBuilder.loadTexts: mICSourceLastConnectAttempt.setDescription('0 if no last connect attempt. 1 if last source request was successful or no last connect. 2 Connection underway. 3 if last connect was rejected downstream.')
mICDestinationInterconnect = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICDestinationInterconnect.setStatus('mandatory')
if mibBuilder.loadTexts: mICDestinationInterconnect.setDescription('1 if destination interconnect is asserted else 0.')
mICDestinationRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICDestinationRequest.setStatus('mandatory')
if mibBuilder.loadTexts: mICDestinationRequest.setDescription('1 if destination request is asserted else 0.')
mICDestinationConnect = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICDestinationConnect.setStatus('mandatory')
if mibBuilder.loadTexts: mICDestinationConnect.setDescription('1 if destination connect is asserted else 0.')
mICByteCounterOverflow = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICByteCounterOverflow.setStatus('mandatory')
if mibBuilder.loadTexts: mICByteCounterOverflow.setDescription('The number of times the byte counter has over-flowed.')
mICNumberOfBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICNumberOfBytes.setStatus('mandatory')
if mibBuilder.loadTexts: mICNumberOfBytes.setDescription('The number of bytes that have passed through the MIC.')
mICNumberOfPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICNumberOfPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mICNumberOfPackets.setDescription('The number of times packets has been asserted.')
mICConnectsSuccessful = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 3, 1, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mICConnectsSuccessful.setStatus('mandatory')
if mibBuilder.loadTexts: mICConnectsSuccessful.setDescription('The number of times this MIC has connected since reset.')
sourceRoutes = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4))
srcRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4, 1), )
if mibBuilder.loadTexts: srcRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: srcRouteTable.setDescription('This table holds all of the source routes for this switch. FORMAT: OutputPort InputPortList Status. Output port is 0 to 31 Input port is 0 to 31 List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2. Status is 0 (disabled) or 1 (enabled)')
srcRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4, 1, 1), ).setIndexNames((0, "ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB", "srcIndex"))
if mibBuilder.loadTexts: srcRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: srcRouteEntry.setDescription('One row in the source route table.')
srcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: srcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: srcIndex.setDescription('The row number for this row of the table.')
srcRouteInPortAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srcRouteInPortAccess.setStatus('mandatory')
if mibBuilder.loadTexts: srcRouteInPortAccess.setDescription(' FORMAT: Shows the input port access for 1 output port. Each instance is the output port number. Each 32 bit hex value displays the input port access for 32 ports. with port 32 on the left and port 0 on the right. Each bit is set for and enabled port, clear for a disabled one. For example 80000000 indicates input port 31 is enabled for this output port')
srcRouteOutPortAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: srcRouteOutPortAccess.setStatus('mandatory')
if mibBuilder.loadTexts: srcRouteOutPortAccess.setDescription(' FORMAT: Shows the output port access for 1 input port. Each instance is the input port number. Each 32 bit hex value displays the output port access for 32 ports. with port 32 on the left and port 0 on the right. Each bit is set for and enabled port, clear for a disabled one. For example 80000000 indicates output port 31 is enabled for this input port')
srcRouteWrite = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srcRouteWrite.setStatus('mandatory')
if mibBuilder.loadTexts: srcRouteWrite.setDescription('Setting this variable alters source routes. FORMAT: OutputPortList InputPortList Status. Output port is 0 to 31 Input port is 0 to 31 Status is 0 (disabled) or 1 (enabled) List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
srcSaveRestore = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 4, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: srcSaveRestore.setStatus('mandatory')
if mibBuilder.loadTexts: srcSaveRestore.setDescription('This will save or restore all of the source routes. Writting a 0 is a no operation. Writting a 1 saves all source routes on the switch. Writting a 2 restores all source routes on the switch.')
logicalAddressRoutes = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5))
destRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 1), )
if mibBuilder.loadTexts: destRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: destRouteTable.setDescription('This table holds all of destination routes (logical address routes) for this switch. FORMAT: LogicalAddress InputPortList Huntgroup. LogicalAddress is 0 to 4095. Input port is 0 to 31 Huntgroup is 0 to 31. List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
destRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 1, 1), ).setIndexNames((0, "ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB", "destIndex"))
if mibBuilder.loadTexts: destRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: destRouteEntry.setDescription('A row in the destination route table.')
destIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: destIndex.setStatus('mandatory')
if mibBuilder.loadTexts: destIndex.setDescription('The index for this row of the table.')
destRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: destRoute.setStatus('mandatory')
if mibBuilder.loadTexts: destRoute.setDescription('One Destination Route. FORMAT: LogicalAddress InputPortList Huntgroup. LogicalAddress is 0 to 4095. Input port is 0 to 31. Huntgroup is 0 to 31. List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
destRouteWrite = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: destRouteWrite.setStatus('mandatory')
if mibBuilder.loadTexts: destRouteWrite.setDescription('Setting this variable will alter the desitination routes. FORMAT: LogicalAddressList Huntgroup InputPortList. LogicalAddress is 0 to 4095. Huntgroup is 0 to 31. 31 will disable this route. Input port is 0 to 31. List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
pathRouteTable = MibTable((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 3), )
if mibBuilder.loadTexts: pathRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: pathRouteTable.setDescription('This table holds all of pathway routes for this switch. FORMAT: PathwayAddressList InputPortList outputPort PathwaAddress is 0 to 4095. Input port is 0 to 31 outputPort is 0 to 31. List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
pathRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 3, 1), ).setIndexNames((0, "ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB", "pathIndex"))
if mibBuilder.loadTexts: pathRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pathRouteEntry.setDescription('A row in the pathway route table.')
pathIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 3, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pathIndex.setDescription('The index for this row of the table.')
pathRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 3, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pathRoute.setStatus('mandatory')
if mibBuilder.loadTexts: pathRoute.setDescription('One pathway logical address route. FORMAT: LogicalAddress InputPortList outputPort. LogicalAddress is 0 to 4095. Input port is 0 to 31. outputPort is 0 to 31. List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
pathRouteWrite = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pathRouteWrite.setStatus('mandatory')
if mibBuilder.loadTexts: pathRouteWrite.setDescription('Setting this variable will alter the pathway logical routes. FORMAT: LogicalAddressList Huntgroup InputPortList. LogicalAddress is 0 to 4095. Huntgroup is 0 to 31. 31 will disable this route. Input port is 0 to 31. List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
routesSaveRestore = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: routesSaveRestore.setStatus('mandatory')
if mibBuilder.loadTexts: routesSaveRestore.setDescription('This saves and restores the route information. 0 is a no operation. 1 saves all destination routes on the switch. 2 restores all destination routes on the switch.')
routeDisable = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 5, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: routeDisable.setStatus('mandatory')
if mibBuilder.loadTexts: routeDisable.setDescription('Setting this variable will disable logical address routes. FORMAT: LogicalAddressList InputPortList. LogicalAddress is 0 to 4095 (0x0 to 0xfff). Input port is 0 to 31 (0x0 to 0x1f). List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
huntGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 6))
hGTable = MibTable((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 6, 1), )
if mibBuilder.loadTexts: hGTable.setStatus('mandatory')
if mibBuilder.loadTexts: hGTable.setDescription('This table holds all of the huntgroups for this switch. FORMAT: Huntgroup ( OutportList ) Huntgroup is 0 to 31. OutportList is an orderd list of output ports in Huntgroup.')
hGEntry = MibTableRow((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 6, 1, 1), ).setIndexNames((0, "ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB", "hg"))
if mibBuilder.loadTexts: hGEntry.setStatus('mandatory')
if mibBuilder.loadTexts: hGEntry.setDescription('A row in the huntgroup table.')
hg = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 6, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hg.setStatus('mandatory')
if mibBuilder.loadTexts: hg.setDescription('The huntgroup number.')
hgList = MibTableColumn((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 6, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hgList.setStatus('mandatory')
if mibBuilder.loadTexts: hgList.setDescription('The definition of one Huntgroup. FORMAT: Huntgroup ( OutportList ) Huntgroup is 0 to 31. OutportList is an orderd list of output ports in Huntgroup.')
hgWrite = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 6, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hgWrite.setStatus('mandatory')
if mibBuilder.loadTexts: hgWrite.setDescription('Setting this variable will alter the huntgroup table by setting every huntgroup in list to include outPortList. FORMAT: HuntgroupList OutportList Huntgroup is 0 to 31. Outport is 0 to 31. List is NUMBER or NUMBER1-NUMBER2 where NUMBER1 < NUMBER2.')
hgSaveRestore = MibScalar((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 6, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hgSaveRestore.setStatus('mandatory')
if mibBuilder.loadTexts: hgSaveRestore.setDescription('This saves and restores the hunt groups. 0 is a no operation. 1 saves all hunt group information on the switch. 2 restores all hunt group information on the switch.')
switchSensorWarning = NotificationType((1, 3, 6, 1, 4, 1, 2159, 1, 3, 2, 7) + (0,1)).setObjects(("ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB", "switchSensors"))
if mibBuilder.loadTexts: switchSensorWarning.setDescription('This warns that switch sensor(s) are changing status. One 32 bit hex values is returned and is ASCII encoded as follows: abcd where each character is a byte (8 bit value). a is the over temperature sensor. b, c, and d are power sensors 3 to 1 respectively. Each byte contains the following information: 0 (30 hex) Sensor is autodetectable, but it is not installed. 1 (32 hex) Sensor (if installed) has no problem 2 (33 hex) Sensor (if installed) has a sensor warning. 3-15 not defined. For example, the hex values 0021 means over temperature sensor is not installed, power supply sensor 3 is not installed, power supply sensor 2 has indicated power supply failure, and power supply 1 is ok.')
mibBuilder.exportSymbols("ESSENTIAL-ODS-ESS2000-HIPPI-SWITCH-MIB", backPlaneEntry=backPlaneEntry, switchDescription=switchDescription, mICNumberOfPackets=mICNumberOfPackets, srcRouteInPortAccess=srcRouteInPortAccess, pathRouteTable=pathRouteTable, mICSourceInterconnect=mICSourceInterconnect, hg=hg, hgSaveRestore=hgSaveRestore, switchSensors=switchSensors, sccDateTime=sccDateTime, ecExperimental=ecExperimental, essentialCommunications=essentialCommunications, hGEntry=hGEntry, routeDisable=routeDisable, destRouteWrite=destRouteWrite, switch=switch, backPlaneNumber=backPlaneNumber, mICSourceConnect=mICSourceConnect, destRouteEntry=destRouteEntry, sccAdminStatus=sccAdminStatus, hgList=hgList, switchSensorWarning=switchSensorWarning, destRoute=destRoute, sccOperStatus=sccOperStatus, mICConnectsSuccessful=mICConnectsSuccessful, mICNumberOfBytes=mICNumberOfBytes, routesSaveRestore=routesSaveRestore, srcSaveRestore=srcSaveRestore, pathRoute=pathRoute, ecProducts=ecProducts, mICLinkReady=mICLinkReady, ecRoot=ecRoot, srcRouteWrite=srcRouteWrite, mICByteCounterOverflow=mICByteCounterOverflow, destIndex=destIndex, pathRouteEntry=pathRouteEntry, ess2000MIB=ess2000MIB, mICHippiParityBurstError=mICHippiParityBurstError, backPlaneIndex=backPlaneIndex, mICSourceLastConnectAttempt=mICSourceLastConnectAttempt, destRouteTable=destRouteTable, hGTable=hGTable, switchEvents=switchEvents, pathRouteWrite=pathRouteWrite, mICDestinationInterconnect=mICDestinationInterconnect, mediaInterfaceCards=mediaInterfaceCards, sourceRoutes=sourceRoutes, srcRouteTable=srcRouteTable, huntGroups=huntGroups, hgWrite=hgWrite, backPlaneCard=backPlaneCard, backPlaneTable=backPlaneTable, sccDescription=sccDescription, srcRouteOutPortAccess=srcRouteOutPortAccess, mICSourceRequest=mICSourceRequest, srcRouteEntry=srcRouteEntry, mICDestinationRequest=mICDestinationRequest, logicalAddressRoutes=logicalAddressRoutes, switchNumOfPorts=switchNumOfPorts, pathIndex=pathIndex, mICPowerUpInitError=mICPowerUpInitError, srcIndex=srcIndex, mICDestinationConnect=mICDestinationConnect, switchControlCard=switchControlCard)

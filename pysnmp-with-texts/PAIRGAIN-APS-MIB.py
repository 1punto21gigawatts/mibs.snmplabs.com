#
# PySNMP MIB module PAIRGAIN-APS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PAIRGAIN-APS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:36:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
pgApsMIB, = mibBuilder.importSymbols("PAIRGAIN-COMMON-HD-MIB", "pgApsMIB")
TimeSeconds, = mibBuilder.importSymbols("PAIRGAIN-DSLAM-CHASSIS-MIB", "TimeSeconds")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, ModuleIdentity, NotificationType, ObjectIdentity, Bits, Counter64, MibIdentifier, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, IpAddress, Integer32, TimeTicks, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "ModuleIdentity", "NotificationType", "ObjectIdentity", "Bits", "Counter64", "MibIdentifier", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "IpAddress", "Integer32", "TimeTicks", "iso")
TextualConvention, TruthValue, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "RowStatus", "DisplayString")
pgAps = ModuleIdentity((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1))
if mibBuilder.loadTexts: pgAps.setLastUpdated('9910110000Z')
if mibBuilder.loadTexts: pgAps.setOrganization('PairGain Technologies, Inc.')
if mibBuilder.loadTexts: pgAps.setContactInfo(' 14402 Franklin Avenue Tustin, CA 92780 ')
if mibBuilder.loadTexts: pgAps.setDescription('The module defines the PairGain Proprietary linear APS1+1 MIB used in the Avidia System ')
pgApsMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 0))
pgApsMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1))
class Byte(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class PgApsK1K2(TextualConvention, Integer32):
    description = 'This Textual Convention describes the K1K2 overhead bytes in the SONET frame that controls APS. K1 is located in the low order byte, K2 is located in the higher order second byte. Bits 1-4 of the K1 byte indicate a request. 1111 Lockout of Protection 1110 Forced Switch 1101 SF - High Priority 1100 SF - Low Priority 1011 SD - High Priority 1010 SD - Low Priority 1001 not used 1000 Manual Switch 0111 not used 0110 Wait-to-Restore 0101 not used 0100 Exercise 0011 not used 0010 Reverse Request 0001 Do Not Revert 0000 No Request Bits 5-8 of the K1 byte indicate the channel associated with the request defined in bits 1-4. 0000 is the Null channel 1-14 are working channels. 15 is the extra traffic channel Bits 1-4 of the K2 byte indicate a channel. The channel is defined with the same syntax as K1 Bits 5-8. Bit 5 of the K2 byte indicates the type of architecture. 0 means the architecture is 1+1 1 means the architecture is 1:n Bits 6-8 of the K2 byte indicates the mode. 000 - 011 are reserved for future use 100 indicates the mode is unidirectional 101 indicates the mode is bidirectional 110 RDI-L 111 AIS-L '
    status = 'current'

pgApsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1), )
if mibBuilder.loadTexts: pgApsConfigTable.setStatus('current')
if mibBuilder.loadTexts: pgApsConfigTable.setDescription('This table provides the Automatic Protection Switch Mode Configuration for Linear 1+1 mode APS')
pgApsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1), ).setIndexNames((0, "PAIRGAIN-APS-MIB", "pgApsIndex"))
if mibBuilder.loadTexts: pgApsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: pgApsConfigEntry.setDescription('Entries in the pgApsConfigTable table. ')
pgApsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsIndex.setStatus('current')
if mibBuilder.loadTexts: pgApsIndex.setDescription(' APS entries are slot based. The index uses the slot number of the card. pgApsIndex (slot number) identifies the APS 1+1 entry that represents the two APS 1+1 channels. ')
pgApsEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgApsEnable.setStatus('current')
if mibBuilder.loadTexts: pgApsEnable.setDescription(' Enable (1) or disables (2) the APS feature. The default is disabled (2). ')
pgApsTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgApsTrapEnable.setStatus('current')
if mibBuilder.loadTexts: pgApsTrapEnable.setDescription(' Enables (1) or disables (2) the sending of the trap whenever an APS switch occurs. The default is disabled (2). ')
pgApsWorkChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsWorkChanIfIndex.setStatus('current')
if mibBuilder.loadTexts: pgApsWorkChanIfIndex.setDescription('The ifIndex of the 1+1 APS configuration working channel. ')
pgApsProtChanIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsProtChanIfIndex.setStatus('current')
if mibBuilder.loadTexts: pgApsProtChanIfIndex.setDescription('The ifIndex of the 1+1 APS configuration protection channel. ')
pgApsConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nonRevertive", 1), ("nonRevertiveAuto", 2), ("revertive", 3))).clone('nonRevertive')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgApsConfigMode.setStatus('current')
if mibBuilder.loadTexts: pgApsConfigMode.setDescription(" nonRevertive(1) : Default. non-Revertive mode as defined in GR-253 nonRevertiveAuto(2) : PairGain proprietary mode that switches from the working channel to the protection channel upon a signal failure (SF) or signal degradation (SD) condition. After the proprietary PairGain wait to switch time has elapsed, the channel can switch from the protection channel to the working channel upon an SF or SD condition. Thus the name 'non-revertive, auto switching' revertive(3) : Revertive switching mode as defined in GR-253 ")
pgApsConfigSigDegradeThresh = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsConfigSigDegradeThresh.setStatus('current')
if mibBuilder.loadTexts: pgApsConfigSigDegradeThresh.setDescription('The Bit Error Rate threshold at which the APS declares that the currently selected signal has degraded. The value is the minus power of 10. For example, a value of 7 represents 10e-7.')
pgApsConfigWaitToRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 720)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgApsConfigWaitToRevert.setStatus('current')
if mibBuilder.loadTexts: pgApsConfigWaitToRevert.setDescription(" This object is only used during 'revertive' switching mode: If the switch has occurred and the error condition has disappeared, then number of seconds specified in this MIB object must elapse before the APS will switch back to the normal mode. The valid range is 300 to 720 seconds (5-12 minutes). The default is 300 seconds (5 minutes). ")
pgApsSwitchCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pgApsSwitchCommand.setStatus('current')
if mibBuilder.loadTexts: pgApsSwitchCommand.setDescription('Sends a local switch command. For example, a command could be Manual switch from normal to protection, or Forced switch from normal to protection. The command format is defined as follows: The pgApsSwitchCommand consists of two 16-bit portions. The high order word contains the command. The low order word contains the destination channel (either working or protection.) The commands contained in the high order word are as follows: Value Command ===== ======= 0 Clear all switch commands for the specified channel. 1 Lockout the working channel from switching to the protection channel. 2 Force switch from the working channel to the protection channel. 3 Force switch from the protection channel to the working channel. 4 Manual switch from the working to the protection. This will not work if SD or SF is in effect on the protection channel. 5 Manual switch from the protection to the working channel. This will not work if SD or SF is active on the working channel. ')
pgApsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2), )
if mibBuilder.loadTexts: pgApsStatusTable.setStatus('current')
if mibBuilder.loadTexts: pgApsStatusTable.setDescription('This table provides the status for each 1+1 APS entry. ')
pgApsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1), ).setIndexNames((0, "PAIRGAIN-APS-MIB", "pgApsIndex"))
if mibBuilder.loadTexts: pgApsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: pgApsStatusEntry.setDescription('Status entry for each 1+1 APS.')
pgApsStatusK1K2Rx = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 1), PgApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsStatusK1K2Rx.setStatus('current')
if mibBuilder.loadTexts: pgApsStatusK1K2Rx.setDescription('The value of the K1 K2 SONET overhead bytes received. ')
pgApsStatusK1K2Tx = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 2), PgApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsStatusK1K2Tx.setStatus('current')
if mibBuilder.loadTexts: pgApsStatusK1K2Tx.setDescription('The value of the K1 K2 SONET overhead bytes transmitted. ')
pgApsStatusCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 3), Byte()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsStatusCurrent.setStatus('current')
if mibBuilder.loadTexts: pgApsStatusCurrent.setDescription('The current switch status. 0 means the working channel selected 1 means protection channel selected The default is the working channel (0). ')
pgApsWorkChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 4), Bits().clone(namedValues=NamedValues(("lockedOut", 0), ("sd", 1), ("sf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsWorkChanStatus.setStatus('current')
if mibBuilder.loadTexts: pgApsWorkChanStatus.setDescription(' Bit 0 set means that this channel is locked out and will not be switched. Bit 1 set means that the SD state is in effect on this channel Bit 2 set means that the SF state is in effect on this channel ')
pgApsWorkChanLastSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 5), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsWorkChanLastSwitch.setStatus('current')
if mibBuilder.loadTexts: pgApsWorkChanLastSwitch.setDescription(' Time stamp of the last time the working channel switched to the protection channel. ')
pgApsWorkChanSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsWorkChanSDs.setStatus('current')
if mibBuilder.loadTexts: pgApsWorkChanSDs.setDescription(' Running count of the number of SD conditions for the working channel that the driver detected. ')
pgApsWorkChanSFs = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsWorkChanSFs.setStatus('current')
if mibBuilder.loadTexts: pgApsWorkChanSFs.setDescription(' Running count of the number of SF conditions for the working channel that the driver detected. ')
pgApsWorkNumSwitchOvers = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsWorkNumSwitchOvers.setStatus('current')
if mibBuilder.loadTexts: pgApsWorkNumSwitchOvers.setDescription(' The number of times the working channel has switched to the protection channel. ')
pgApsProtChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 9), Bits().clone(namedValues=NamedValues(("lockedOut", 0), ("sd", 1), ("sf", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsProtChanStatus.setStatus('current')
if mibBuilder.loadTexts: pgApsProtChanStatus.setDescription(' The protection channel status: Bit 0 set means that the protection channel is locked out and will not be switched. Bit 1 set means that the SD state is in effect on the protection channel. Bit 2 set means that the SF state is in effect on the protection channel. ')
pgApsProtChanLastSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 10), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsProtChanLastSwitch.setStatus('current')
if mibBuilder.loadTexts: pgApsProtChanLastSwitch.setDescription(' Time stamp of the last time the Protection channel switched to the working channel. ')
pgApsProtChanSDs = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsProtChanSDs.setStatus('current')
if mibBuilder.loadTexts: pgApsProtChanSDs.setDescription(' Running count of the number of SD conditions for the protection channel that the driver detected. ')
pgApsProtChanSFs = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsProtChanSFs.setStatus('current')
if mibBuilder.loadTexts: pgApsProtChanSFs.setDescription(' Running count of the number of SF conditions for the protection channel that the driver detected. ')
pgApsProtNumSwitchOvers = MibTableColumn((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 1, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pgApsProtNumSwitchOvers.setStatus('current')
if mibBuilder.loadTexts: pgApsProtNumSwitchOvers.setDescription(' The number of times the protection channel switched to the working channel. ')
pgApsTrapSwitchOver = NotificationType((1, 3, 6, 1, 4, 1, 927, 1, 9, 12, 1, 0, 1)).setObjects(("PAIRGAIN-APS-MIB", "pgApsStatusEntry"))
if mibBuilder.loadTexts: pgApsTrapSwitchOver.setStatus('current')
if mibBuilder.loadTexts: pgApsTrapSwitchOver.setDescription('If pgApsTrapEnable is enabled, then pgApsTrapSwitchOver is sent when the APS switches from the working channel to the protection channel or from the protection channel to the working channel. This occurs when the value of pgApsWorkingNumSwitchOvers or pgApsProtNumSwitchOvers increments. ')
mibBuilder.exportSymbols("PAIRGAIN-APS-MIB", pgApsStatusK1K2Tx=pgApsStatusK1K2Tx, pgApsProtChanLastSwitch=pgApsProtChanLastSwitch, pgApsMIBNotifications=pgApsMIBNotifications, pgApsProtChanStatus=pgApsProtChanStatus, pgApsStatusK1K2Rx=pgApsStatusK1K2Rx, pgApsConfigSigDegradeThresh=pgApsConfigSigDegradeThresh, pgApsIndex=pgApsIndex, PYSNMP_MODULE_ID=pgAps, Byte=Byte, pgApsWorkChanStatus=pgApsWorkChanStatus, pgApsProtChanSFs=pgApsProtChanSFs, pgAps=pgAps, pgApsProtChanIfIndex=pgApsProtChanIfIndex, pgApsEnable=pgApsEnable, pgApsSwitchCommand=pgApsSwitchCommand, pgApsTrapEnable=pgApsTrapEnable, pgApsWorkNumSwitchOvers=pgApsWorkNumSwitchOvers, pgApsProtChanSDs=pgApsProtChanSDs, pgApsTrapSwitchOver=pgApsTrapSwitchOver, pgApsConfigMode=pgApsConfigMode, pgApsConfigEntry=pgApsConfigEntry, pgApsWorkChanLastSwitch=pgApsWorkChanLastSwitch, pgApsConfigWaitToRevert=pgApsConfigWaitToRevert, pgApsStatusEntry=pgApsStatusEntry, pgApsProtNumSwitchOvers=pgApsProtNumSwitchOvers, PgApsK1K2=PgApsK1K2, pgApsStatusCurrent=pgApsStatusCurrent, pgApsWorkChanIfIndex=pgApsWorkChanIfIndex, pgApsMibObjects=pgApsMibObjects, pgApsWorkChanSDs=pgApsWorkChanSDs, pgApsConfigTable=pgApsConfigTable, pgApsStatusTable=pgApsStatusTable, pgApsWorkChanSFs=pgApsWorkChanSFs)

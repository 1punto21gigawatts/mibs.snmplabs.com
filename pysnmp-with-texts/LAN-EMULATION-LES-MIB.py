#
# PySNMP MIB module LAN-EMULATION-LES-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LAN-EMULATION-LES-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:47:49 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint")
LeArpTableEntryType, VciInteger, VpiInteger, atmfLanEmulation = mibBuilder.importSymbols("LAN-EMULATION-CLIENT-MIB", "LeArpTableEntryType", "VciInteger", "VpiInteger", "atmfLanEmulation")
TIMESTAMP, Integer, IfIndexOrZero, AtmLaneMask = mibBuilder.importSymbols("LAN-EMULATION-ELAN-MIB", "TIMESTAMP", "Integer", "IfIndexOrZero", "AtmLaneMask")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, MibIdentifier, Gauge32, Counter64, iso, ObjectIdentity, Counter32, TimeTicks, NotificationType, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, ModuleIdentity, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "MibIdentifier", "Gauge32", "Counter64", "iso", "ObjectIdentity", "Counter32", "TimeTicks", "NotificationType", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "ModuleIdentity", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
lesMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3))
class TruthValue(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("true", 1), ("false", 2))

class RowStatus(Integer32):
    pass

class AtmLaneAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(20, 20), )
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class LesLecDataFrameFormat(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3))
    namedValues = NamedValues(("aflane8023", 2), ("aflane8025", 3))

class LesLecDataFrameSize(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))
    namedValues = NamedValues(("max1516", 2), ("max4544", 3), ("max9234", 4), ("max18190", 5))

lesConfGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1))
lesStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2))
lesLecStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3))
lesFaultGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4))
lesConfNextId = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesConfNextId.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfNextId.setDescription('The next available LES index. The value of this object can be used as the index by the network manager to create an entry in the lesConfTable.')
lesConfTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2), )
if mibBuilder.loadTexts: lesConfTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfTable.setDescription('This table contains all LAN Emulation Servers this agent manages. The LES is one of the components in the Emulated LAN which implements the control coordination function. It is the address resolution server for a given ELAN. The LES provides a facility for registering and resolving MAC addresses and/or route descriptors to ATM addresses. There can be multiple LES per ELAN but a LES can serve only one ELAN.')
lesConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: lesConfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfEntry.setDescription('Each entry in this table represents a LES. The parameters in each entry apply to one emulated LAN served by one LES. Objects lesLanType and lesMaxFrameSize are also required besides lesRowStatus during row creation.')
lesConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 1), Integer32())
if mibBuilder.loadTexts: lesConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesConfIndex.setDescription('A value which uniquely identifies a conceptual row in the lesConfTable. If the conceptual row identified by this value of lesConfIndex is recreated following an agent restart, the same value of lesConfIndex must be used to identify the recreated row.')
lesAtmAddrSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAtmAddrSpec.setReference('LAN Emulation Over ATM Specification - version 1.0. S1.')
if mibBuilder.loadTexts: lesAtmAddrSpec.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrSpec.setDescription('An ATM address specified by the network or local management that, with the ATM address mask, determines a portion of the ATM address that the LES on the designated ATM interface will use to derive the actual ATM address from the network or ILMI. The derived ATM address is specified in the object lesAtmAddrActual, which is used to receive ATM ARP requests.')
lesAtmAddrMask = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 3), AtmLaneMask().clone(hexValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAtmAddrMask.setReference('LAN Emulation Over ATM Specification - version 1.0. S1.')
if mibBuilder.loadTexts: lesAtmAddrMask.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrMask.setDescription("The ATM address mask associated with the object lesAtmAddrSpec. The value of the mask is an ATM address with the don't care portion set to zero and the valid ATM address portion set to one.")
lesAtmAddrActual = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 4), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesAtmAddrActual.setReference('LAN Emulation Over ATM Specification - version 1.0. S1.')
if mibBuilder.loadTexts: lesAtmAddrActual.setStatus('mandatory')
if mibBuilder.loadTexts: lesAtmAddrActual.setDescription(' The resultant ATM address in use by the LES. This object is a product of the specified ATM address, mask and interaction with the network. This object is created by the agent.')
lesElanName = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesElanName.setReference('LAN Emulation Over ATM Specification - version 1.0. C5.')
if mibBuilder.loadTexts: lesElanName.setStatus('mandatory')
if mibBuilder.loadTexts: lesElanName.setDescription('The name of the Emulated LAN this LES is providing service for. This object may be used to identify the ELAN the LES is in.')
lesLanType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 6), LesLecDataFrameFormat()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLanType.setReference('LAN Emulation Over ATM Specification - version 1.0. S2.')
if mibBuilder.loadTexts: lesLanType.setStatus('mandatory')
if mibBuilder.loadTexts: lesLanType.setDescription('The type of the ATM Emulated LAN this LES is providing service to.')
lesLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 7), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: lesLastChange.setDescription('The value of sysUpTime when this LES has entered the state indicated by the object lesOperStatus.')
lesMaxFrameSize = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 8), LesLecDataFrameSize()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesMaxFrameSize.setReference('LAN Emulation Over ATM Specification - version 1.0. S3.')
if mibBuilder.loadTexts: lesMaxFrameSize.setStatus('mandatory')
if mibBuilder.loadTexts: lesMaxFrameSize.setDescription('The maximum AAL-5 SDU size of a data frame that the LE service can guarantee not to drop because it is too large. ')
lesControlTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 300)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesControlTimeOut.setReference('LAN Emulation Over ATM Specification - version 1.0. S4.')
if mibBuilder.loadTexts: lesControlTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: lesControlTimeOut.setDescription('Time out period used for timing out most request/response control frame interactions. This is the time a Client has to issue a join request to a LES after a control direct VCC is established with a LES.')
lesOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesOperStatus.setDescription("The operational state of this LES entry. When in 'up' state the LES will respond to LEC requests. Any other state the LES is notavailable for service and may release all the existing VCCs and refuse service to all clients.")
lesAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("up", 2), ("down", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesAdminStatus.setDescription(' The desired state of the designated LES as prescribed by the operator. The actions of the agent will, if at all possible, eventually result in the desired state being reflected in the lesOperStatus.')
lesRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 2, 1, 13), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesRowStatus.setDescription('This object is used to create or delete entries in the elanConfTable.')
lesVccTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3), )
if mibBuilder.loadTexts: lesVccTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccTable.setDescription('This table contains all the Control Distribute VCCs used by the LES to distribute control traffic to the participating LECs. The Control Distribute VCC can either be point-to-point or point-to- multipoint calls. This table is read only if SVCs are used and writable if PVCs are used.')
lesVccEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesVccAtmIfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesVccCtlDistVpi"), (0, "LAN-EMULATION-LES-MIB", "lesVccCtlDistVci"))
if mibBuilder.loadTexts: lesVccEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccEntry.setDescription("Each entry in this table represents a LES entry and it's associated Control Distribute VCC. ")
lesVccAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 1), IfIndexOrZero())
if mibBuilder.loadTexts: lesVccAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccAtmIfIndex.setDescription('The ATM interface which the Control Distribute VCC is running on. This value must match an existing value in the ifTable. The value of this object is set to zero when the ATM interface is an internal connection.')
lesVccCtlDistVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 2), VpiInteger())
if mibBuilder.loadTexts: lesVccCtlDistVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccCtlDistVpi.setDescription('The VPI value of the Control Distribute VCC. The object lesVccAtmIfIndex, lesVccCtlDistVci and the value of this object uniquely identfies a VCC within a ATM host.')
lesVccCtlDistVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 3), VciInteger())
if mibBuilder.loadTexts: lesVccCtlDistVci.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccCtlDistVci.setDescription('The VCI value of the Control Distribute VCC. The object lesVccAtmIfIndex, lesVccCtlDistVci and the value of this object uniquely identfies a VCC within a ATM host.')
lesVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 3, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesVccRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesVccRowStatus.setDescription('This object is used to create or delete entries in the elanConfTable.')
lesBusTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4), )
if mibBuilder.loadTexts: lesBusTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusTable.setDescription('This table contains the BUSs paired with the LESs found in the lesConfTable. The BUS (Broadcast and Unknown Server) handles data sent by a LE client to the broadcast MAC address, all multicast traffic, and initial unicast frames which are sent by a LAN Emulation Client before the data direct target ATM address has been resolved.')
lesBusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesBusConfIndex"))
if mibBuilder.loadTexts: lesBusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusEntry.setDescription('Each entry in this table represents aLES/BUS pair. Object lesBusAddress is required duringrow creation. This table is indexed by lesConfIndex and lesBusConfIndexto show the pairing relationship betweenthe LES and BUS.')
lesBusConfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4, 1, 1), Integer32())
if mibBuilder.loadTexts: lesBusConfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusConfIndex.setDescription('A value which uniquely identifies a BUS ATM address. If the BUS ATM address identified by this value of lesBusConfIndex is recreated following an agent restart, the same value of lesBusConfIndex must be used to identify the recreated BUS ATM address.')
lesBusAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 4, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesBusAddress.setReference('LAN Emulation Over ATM Specification - version 1.0. S6.')
if mibBuilder.loadTexts: lesBusAddress.setStatus('mandatory')
if mibBuilder.loadTexts: lesBusAddress.setDescription('The ATM address of the BUS. This BUS is associated with LES specified by the lesConfIndex. A BUS may have several ATM addresses, this object provides the ATM address the LES returns in response to the LE-ARP request by the LEC.')
lesLeArpMacTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5), )
if mibBuilder.loadTexts: lesLeArpMacTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpMacTable.setDescription("This table provides access to an ATM LAN Emulation Server's MAC-to-ATM ARP table. It contains entries for unicast addressed, the broadcast address. When the entry is for broadcast MAC address the corresponding ATM address is of a BUS. When the entry is for unicast MAC address the corresponding ATM address represents a LEC.")
lesLeArpMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLeArpMacAddr"))
if mibBuilder.loadTexts: lesLeArpMacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpMacEntry.setDescription('An ATM LAN Emulation ARP table entry containing information about the binding of one MAC address to one ATM address.')
lesLeArpMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 1), MacAddress())
if mibBuilder.loadTexts: lesLeArpMacAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpMacAddr.setDescription("The MAC address for which this table entry provides a translation. Since ATM LAN Emulation uses an LE ARP protocol to locate the Broadcast and Unknown Server, the value of this object could be the broadcast MAC address. MAC addresses should be unique within any given ATM Emulated LAN. However, there's no requirement that they be unique across disjoint emulated LANs.")
lesLeArpLecId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLeArpLecId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpLecId.setDescription('The LE Client Identifier (LECID) of this entry. Each LE Client requires a LECID assigned by the LE Server during the Join phase. If this entry is for a BUS then this object value will be zero.')
lesLeArpAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 3), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpAtmAddr.setDescription("The ATM address of the Broadcast & Unknown Server or LAN Emulation Client whose MAC address is stored in 'lesLeArpMacAddr'. This volume may be registered by a LAN Emulation Client or specified by network management.")
lesLeArpEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 4), LeArpTableEntryType().clone('staticVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpEntryType.setReference('LAN Emulation Client MIB definition.')
if mibBuilder.loadTexts: lesLeArpEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpEntryType.setDescription('This object is used to indicate how this LE-ARP entry was created. The possible values for this object are: viaRegister(1), - agent staticVolatile(2), - network manager staticNonVolatile(3) - network manager This object is filled in by agent or network manager depending on the type.')
lesLeArpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 5, 1, 5), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesLeArpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRowStatus.setDescription('This object is used to create or delete entries in the elanConfTable.')
lesLeArpRdTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6), )
if mibBuilder.loadTexts: lesLeArpRdTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdTable.setDescription("This table provides access to an ATM LAN Emulation Server's RouteDescriptor-to-ATM ARP cache. The entries in this table are set-up by the agent or network manager depending on the entry type. The Route Descriptors are presented as Segment Id (ring number) and Bridge number.")
lesLeArpRdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLeArpRdSegId"), (0, "LAN-EMULATION-LES-MIB", "lesLeArpRdBridgeNum"))
if mibBuilder.loadTexts: lesLeArpRdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdEntry.setDescription('An ATM LAN Emulation ARP cache entry containing information about the binding of one Route Descriptor to one ATM address.')
lesLeArpRdSegId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: lesLeArpRdSegId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdSegId.setDescription('The LAN ID (ring number) portion of the IEEE 802.5 route descriptor associated with this LES.')
lesLeArpRdBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: lesLeArpRdBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdBridgeNum.setDescription('The Bridge Number portion of the IEEE 802.5 route descriptor associated with this LES.')
lesLeArpRdLecId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLeArpRdLecId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdLecId.setDescription('The LE Client Identifier (LECID) of this entry. Each LE Client requires a LECID assigned by the LE Server during the Join phase. ')
lesLeArpRdAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 4), AtmLaneAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRdAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdAtmAddr.setDescription('The ATM address associated with the Route Descriptor.')
lesLeArpRdEntryType = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 5), LeArpTableEntryType().clone('staticVolatile')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRdEntryType.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdEntryType.setDescription('This object is used to indicate how this LE-ARP entry was learned: viaRegister(1), - agent staticVolatile(2), - network manager staticNonVolatile(3) - network manager This object is filled in by agent or network manager depending on the type.')
lesLeArpRdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 6, 1, 6), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLeArpRdRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesLeArpRdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesLeArpRdRowStatus.setDescription('This object is used to create or delete entries in the elanConfTable.')
lesLecTableLastChange = MibScalar((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 7), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecTableLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecTableLastChange.setDescription('The value of sysUptime when an entry was created/deleted.')
lesLecTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8), )
if mibBuilder.loadTexts: lesLecTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecTable.setDescription('This table contains all LAN Emulation clients serviced by LESs specified in the lesConfTable. This table can be used to retrieve the topology of an ELAN, in particular, the LES to LECs mapping information. An entry in this table is filled in by the agent when a LEC registers successfully with the LES. Objects lesLecCtlDirectVpi and lesLecCtlDirectVci can be modified by the network manager after creation if PVC is used.')
lesLecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLecIndex"))
if mibBuilder.loadTexts: lesLecEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecEntry.setDescription('Each entry represents a LANE client to LES binding.')
lesLecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: lesLecIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecIndex.setDescription('An arbitrary integer which uniquely identifies a LEC in this table.')
lesLecAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecAtmAddr.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.4.3')
if mibBuilder.loadTexts: lesLecAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecAtmAddr.setDescription('The ATM address of the LANE client. This is the primary ATM address of the LEC used in joining phase.')
lesLecProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecProxy.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Section 5.1.1')
if mibBuilder.loadTexts: lesLecProxy.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecProxy.setDescription('Whether this client is acting as a proxy. Proxy clients are allowed to represent unregistered MAC addresses, and receive copies of LE_ARP_REQUEST packets for such addresses.')
lesLecId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65279))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecId.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecId.setDescription('The LE Client Identifier (LECID) of this entry. Each LE Client requires a LECID assigned by the LE Server during the Join phase. The LECID is placed in control requests by the LE Client and MAY be used for echo suppression on multicast data frames sent by that LE Client.')
lesLecAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 5), IfIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecAtmIfIndex.setDescription('The ifIndex of ATM port where this LEC entry has established the control direct VCC to the LES. The value of this object maps to an existing ifIndex value in the ifTable of MIB-II. When an internal connection is used, this object is set to zero.')
lesLecCtlDirectVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 6), VpiInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecCtlDirectVpi.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecCtlDirectVpi.setDescription(' The VPI of the bi-directional control direct connection between the LEC and LES.')
lesLecCtlDirectVci = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 7), VciInteger()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecCtlDirectVci.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecCtlDirectVci.setDescription(' The VCI of the bi-directional control direct connection between the LEC and LES.')
lesLecLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 8), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecLastChange.setDescription('The value of sysUpTime of this entry when the LEC enters the state indicated by the object lesLecState.')
lesLecState = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("noLesConnect", 2), ("lesConnect", 3), ("joining", 4), ("addLec", 5), ("joinedLes", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecState.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecState.setDescription("This object is used to indicate the status this LEC entry is in from the LES's perspective. The state of this object is updated by the agent as it discovers various phases of this LEC.")
lesLecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 1, 8, 1, 10), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesLecRowStatus.setReference('RFC 1443, [10] Textual Conventions for version 2 of the Simple Network Management Protocol (SNMPv2).')
if mibBuilder.loadTexts: lesLecRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecRowStatus.setDescription(' This object provides a way for the network manager to selectively remove a LE Client from the designated LES. Or in a system where PVCs are used, this table is used to configure Control Direct VCCs between LES and LEC.')
lesStatTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1), )
if mibBuilder.loadTexts: lesStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatTable.setDescription('This table contains all counters the LES maintain. This table is an extention to the lesConfTable. It provides performance and fault counters on a per LES basis.')
lesStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: lesStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatEntry.setDescription('Each entry in this table contains a LES and its counters.')
lesStatJoinOk = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatJoinOk.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatJoinOk.setDescription('Number of successful Join responses send out by the LAN Emulation Server.')
lesStatVerNotSup = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatVerNotSup.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatVerNotSup.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatVerNotSup.setDescription('Number of version not supported errors. ')
lesStatInvalidReqParam = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidReqParam.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatInvalidReqParam.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidReqParam.setDescription('Number of invalid request parameters errors. ')
lesStatDupLanDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatDupLanDest.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatDupLanDest.setDescription('Number of duplicate LAN destination errors. ')
lesStatDupAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatDupAtmAddr.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatDupAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatDupAtmAddr.setDescription('Number of duplicate ATM address errors. ')
lesStatInsRes = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInsRes.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatInsRes.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInsRes.setDescription('Number of insufficient resources to grant errors. ')
lesStatAccDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatAccDenied.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatAccDenied.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatAccDenied.setDescription('Number of access denied for security reasons errors.')
lesStatInvalidReqId = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidReqId.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatInvalidReqId.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidReqId.setDescription('Number of invalid LEC ID errors.')
lesStatInvalidLanDest = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidLanDest.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatInvalidLanDest.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidLanDest.setDescription('Number of invalid LAN destination errors.')
lesStatInvalidAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInvalidAtmAddr.setReference('ATM Forum LAN Emulation Over ATM Specification, V1.0, Table 13.')
if mibBuilder.loadTexts: lesStatInvalidAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInvalidAtmAddr.setDescription('Number of invalid ATM address errors.')
lesStatInBadPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatInBadPkts.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatInBadPkts.setDescription('Number of mal formed ATM ARP requests received by the LES.')
lesStatOutRegFails = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatOutRegFails.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatOutRegFails.setDescription('Number of registration failures sent out by this LES.')
lesStatLeArpIn = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatLeArpIn.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatLeArpIn.setDescription('The total number of LE_ARP_REQUEST frames the LES has accepted since its last initialization.')
lesStatLeArpFwd = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 2, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesStatLeArpFwd.setStatus('mandatory')
if mibBuilder.loadTexts: lesStatLeArpFwd.setDescription("The number of LE_ARP_REQUESTs that the LES forwarded onto the clients (either via the control distribute or individually over each control direct) rather than answering directly. This may be due to implementation decision (forward all requests) or because the resolution to the request did not reside in the LES's LE ARP cache.")
lesLecStatTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1), )
if mibBuilder.loadTexts: lesLecStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecStatTable.setDescription('This table contains all LE-ARP request related counters and error counts on a per LEC-LES pair basis.')
lesLecStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesLecIndex"))
if mibBuilder.loadTexts: lesLecStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecStatEntry.setDescription('Each entry in this table represents a LEC and its ARP counters. This table is an extention to the lesLecTable.')
lesLecRecvs = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecRecvs.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecRecvs.setDescription('Number of requests received from this LEC. This includes all control frames as well as LE-ARP requests.')
lesLecSends = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecSends.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecSends.setDescription('Number of requests or responses sent to the LEC entry from this LES.')
lesLecInRegReq = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInRegReq.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInRegReq.setDescription('Number of Register requests received from this LEC. ')
lesLecInUnReg = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInUnReg.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInUnReg.setDescription('Number of UnRegister requests received from this LEC. ')
lesLecInLeArpUcast = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInLeArpUcast.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInLeArpUcast.setDescription('Number of LE-ARP requests for UNICAST address received from this LEC. ')
lesLecInLeArpBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInLeArpBcast.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInLeArpBcast.setDescription('Number of LE-ARP requests for MULTICAST and Broadcast address received from this LEC. ')
lesLecInLeArpResp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInLeArpResp.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInLeArpResp.setDescription('Number of LE-ARP responses received from this LEC. ')
lesLecInNArp = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 3, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesLecInNArp.setStatus('mandatory')
if mibBuilder.loadTexts: lesLecInNArp.setDescription('Number of NARP requests received from this LEC. ')
lesErrCtlTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1), )
if mibBuilder.loadTexts: lesErrCtlTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlTable.setDescription('This table contains error log control information of all LES instances. This table is an extention to the lesConfTable. It is used to enable or disable error logs for a particular LES entry.')
lesErrCtlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"))
if mibBuilder.loadTexts: lesErrCtlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlEntry.setDescription('Each entry represents a LES entry in the lesConfTable.')
lesErrCtlAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesErrCtlAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlAdminStatus.setDescription('This object is used to enable/disable error logging for the LES.')
lesErrCtlOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("active", 2), ("outOfRes", 3), ("failed", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrCtlOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlOperStatus.setDescription('This object is used to indicate the result of a set operation to the object lesErrCtlAdminStatus. If the error log was successfully started, it is in active(2) mode. Otherwise, it is set to either outOfRes(3) or failed(4) for the respective reasons.')
lesErrCtlClearLog = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noOp", 1), ("clear", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesErrCtlClearLog.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlClearLog.setDescription('This object is used to clear the error log entries associated with this LES.')
lesErrCtlMaxEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrCtlMaxEntries.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlMaxEntries.setDescription('The maximum entries of the error log a LES can support.')
lesErrCtlLastEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lesErrCtlLastEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrCtlLastEntry.setDescription('The index to the last entry in the error log table for this LES.')
lesErrLogTable = MibTable((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2), )
if mibBuilder.loadTexts: lesErrLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogTable.setDescription('This table contains error logs of the LES instances enabled in the lesErrCtlTable. This table is indexed by the LES instance index and an arbitrary integer uniquely identifies an error log.')
lesErrLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1), ).setIndexNames((0, "LAN-EMULATION-LES-MIB", "lesConfIndex"), (0, "LAN-EMULATION-LES-MIB", "lesErrLogIndex"))
if mibBuilder.loadTexts: lesErrLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogEntry.setDescription('Each entry represents a JOIN or REGISTER that was rejected due to an error.')
lesErrLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: lesErrLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogIndex.setDescription('An arbitrary integer which uniquely identifies an error log entry. The first entry after reset or clearing the error log is an assigned value (2^32-1). Succeding entries are assigned with descending values consecutively. Entries after 1 are discarded. The enabling/disabling of the error log capability is done in the lesErrCtlTable.')
lesErrLogAtmAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 2), AtmLaneAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrLogAtmAddr.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogAtmAddr.setDescription('The ATM address of the requester which sends the JOIN or REGISTER request and causes the error to occur. The corresponding error code is specified in the object lesErrLogErrCode.')
lesErrLogErrCode = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 22))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrLogErrCode.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogErrCode.setDescription('The Error code which indicates the cause of the error triggered by the JOIN or REGISTER request sent by the requester indicated by the value of the object lesErrLogAtmAddr.')
lesErrLogTime = MibTableColumn((1, 3, 6, 1, 4, 1, 353, 5, 3, 3, 4, 2, 1, 4), TIMESTAMP()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lesErrLogTime.setStatus('mandatory')
if mibBuilder.loadTexts: lesErrLogTime.setDescription('The sysUpTime when this entry was logged by the LES.')
mibBuilder.exportSymbols("LAN-EMULATION-LES-MIB", lesAtmAddrMask=lesAtmAddrMask, lesStatOutRegFails=lesStatOutRegFails, lesLecProxy=lesLecProxy, lesLecCtlDirectVpi=lesLecCtlDirectVpi, lesElanName=lesElanName, lesLeArpLecId=lesLeArpLecId, lesStatInsRes=lesStatInsRes, lesLeArpMacTable=lesLeArpMacTable, lesLecInLeArpBcast=lesLecInLeArpBcast, lesLecInUnReg=lesLecInUnReg, lesErrLogAtmAddr=lesErrLogAtmAddr, lesErrLogTable=lesErrLogTable, lesLecIndex=lesLecIndex, lesConfNextId=lesConfNextId, lesLeArpRdLecId=lesLeArpRdLecId, lesLeArpRdEntryType=lesLeArpRdEntryType, lesErrCtlTable=lesErrCtlTable, lesLecInLeArpResp=lesLecInLeArpResp, lesBusTable=lesBusTable, lesErrLogTime=lesErrLogTime, lesLecInLeArpUcast=lesLecInLeArpUcast, lesErrLogIndex=lesErrLogIndex, lesErrLogErrCode=lesErrLogErrCode, lesFaultGroup=lesFaultGroup, lesLeArpAtmAddr=lesLeArpAtmAddr, lesStatLeArpFwd=lesStatLeArpFwd, lesLeArpRdSegId=lesLeArpRdSegId, lesLecInNArp=lesLecInNArp, lesStatDupLanDest=lesStatDupLanDest, lesLecStatTable=lesLecStatTable, lesLecStatEntry=lesLecStatEntry, lesStatInvalidLanDest=lesStatInvalidLanDest, lesLecCtlDirectVci=lesLecCtlDirectVci, lesAtmAddrSpec=lesAtmAddrSpec, lesConfIndex=lesConfIndex, lesBusAddress=lesBusAddress, lesErrCtlOperStatus=lesErrCtlOperStatus, lesLeArpRdTable=lesLeArpRdTable, lesErrCtlClearLog=lesErrCtlClearLog, lesLecState=lesLecState, lesStatTable=lesStatTable, lesStatEntry=lesStatEntry, lesLecId=lesLecId, MacAddress=MacAddress, lesStatJoinOk=lesStatJoinOk, lesAtmAddrActual=lesAtmAddrActual, lesStatInvalidAtmAddr=lesStatInvalidAtmAddr, lesLecTable=lesLecTable, lesLecRecvs=lesLecRecvs, lesAdminStatus=lesAdminStatus, lesStatLeArpIn=lesStatLeArpIn, AtmLaneAddress=AtmLaneAddress, lesErrCtlLastEntry=lesErrCtlLastEntry, lesLecRowStatus=lesLecRowStatus, lesLecTableLastChange=lesLecTableLastChange, lesLecEntry=lesLecEntry, RowStatus=RowStatus, lesLastChange=lesLastChange, lesConfEntry=lesConfEntry, lesLeArpEntryType=lesLeArpEntryType, lesLecAtmAddr=lesLecAtmAddr, lesLecInRegReq=lesLecInRegReq, lesErrLogEntry=lesErrLogEntry, lesConfTable=lesConfTable, lesLeArpRdRowStatus=lesLeArpRdRowStatus, lesBusConfIndex=lesBusConfIndex, lesErrCtlMaxEntries=lesErrCtlMaxEntries, lesErrCtlEntry=lesErrCtlEntry, lesVccRowStatus=lesVccRowStatus, lesLecStatGroup=lesLecStatGroup, LesLecDataFrameFormat=LesLecDataFrameFormat, lesVccAtmIfIndex=lesVccAtmIfIndex, lesConfGroup=lesConfGroup, lesStatVerNotSup=lesStatVerNotSup, lesLecLastChange=lesLecLastChange, lesLeArpRdBridgeNum=lesLeArpRdBridgeNum, lesStatInvalidReqParam=lesStatInvalidReqParam, lesLeArpRowStatus=lesLeArpRowStatus, lesLeArpMacAddr=lesLeArpMacAddr, lesLanType=lesLanType, lesVccCtlDistVci=lesVccCtlDistVci, lesMaxFrameSize=lesMaxFrameSize, lesStatInBadPkts=lesStatInBadPkts, lesOperStatus=lesOperStatus, lesVccEntry=lesVccEntry, lesStatAccDenied=lesStatAccDenied, lesStatInvalidReqId=lesStatInvalidReqId, lesBusEntry=lesBusEntry, lesMIB=lesMIB, lesVccTable=lesVccTable, lesErrCtlAdminStatus=lesErrCtlAdminStatus, lesLecAtmIfIndex=lesLecAtmIfIndex, lesControlTimeOut=lesControlTimeOut, lesStatDupAtmAddr=lesStatDupAtmAddr, lesVccCtlDistVpi=lesVccCtlDistVpi, lesLeArpRdEntry=lesLeArpRdEntry, lesLecSends=lesLecSends, lesLeArpRdAtmAddr=lesLeArpRdAtmAddr, LesLecDataFrameSize=LesLecDataFrameSize, lesStatGroup=lesStatGroup, lesRowStatus=lesRowStatus, lesLeArpMacEntry=lesLeArpMacEntry, TruthValue=TruthValue)

#
# PySNMP MIB module ATM-RMON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ATM-RMON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:31:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
OwnerString, ifIndex = mibBuilder.importSymbols("IF-MIB", "OwnerString", "ifIndex")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Unsigned32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Counter32, ObjectIdentity, Bits, ModuleIdentity, Integer32, Gauge32, iso, NotificationType, MibIdentifier, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Counter32", "ObjectIdentity", "Bits", "ModuleIdentity", "Integer32", "Gauge32", "iso", "NotificationType", "MibIdentifier", "TimeTicks")
TextualConvention, DisplayString, RowStatus, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "RowStatus", "TimeStamp")
atmRmon = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 16))
if mibBuilder.loadTexts: atmRmon.setLastUpdated('9701240000Z')
if mibBuilder.loadTexts: atmRmon.setOrganization('IETF')
if mibBuilder.loadTexts: atmRmon.setContactInfo('Andy Bierman Cisco Systems, Inc. Phone: +1 408 527-3711 Email: abierman@cisco.com Keith McCloghrie Cisco Systems, Inc. Phone: +1 408 526-5260 Email: kzm@cisco.com')
if mibBuilder.loadTexts: atmRmon.setDescription('The MIB module for managing remote monitoring device implementations for ATM networks.')
atmRmonMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 1))
atmRmonNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 2))
atmRmonConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 3))
portSelect = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1))
atmStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2))
atmHost = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3))
atmMatrix = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4))
atmConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 5))
class ZeroBasedCounter32(TextualConvention, Gauge32):
    description = 'This TC describes an object which counts events with the following semantics: objects of this type will be set to zero(0) on creation and will thereafter count appropriate events, wrapping back to zero(0) when the value 2^32 is reached. Provided that an application discovers the new object within the minimum time to wrap it can use the initial value as a delta since it last polled the table of which this object is part. It is important for a management station to be aware of this minimum time and the actual time between polls, and to discard data if the actual time is too long or there is no defined minimum time. Typically this TC is used in tables where the INDEX space is constantly changing and/or the TimeFilter mechanism is in use.'
    status = 'current'

class LastCreateTime(TextualConvention, TimeTicks):
    description = 'This TC describes an object that stores the last time its entry was created. This can be used for polling applications to determine that an entry has been deleted and re-created between polls, causing an otherwise undetectable discontinuity in the data.'
    status = 'current'

class AtmAddr(TextualConvention, OctetString):
    description = 'The ATM address used by the network entity. The address types are: no address (0 octets), E.164 (8 octets), network prefix (13 octets), and NSAP (20 octets). Note: The E.164 address is encoded in BCD format.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(8, 8), ValueSizeConstraint(13, 13), ValueSizeConstraint(20, 20), )
class ServiceClass(TextualConvention, Integer32):
    description = "This TC describes an object that identifies the cell delivery class-of-service classification, associated with a particular statistics collection. In order to conserve agent resources, the classifications are limited to two enumerations which distinguish delay-guarantee. Statistics gathered on behalf on collections identified by the 'cbrAndVbr(1)' enumeration represent constant-bit-rate (CBR), real-time and non-real-time variable bit rate (VBR) traffic. Statistics gathered on behalf on collections identified by the 'abrAndUbr(2)' enumeration represent available-bit-rate (ABR) and unspecified-bit-rate (UBR) traffic."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("cbrAndVbr", 1), ("abrAndUbr", 2))

class ResourcePriority(TextualConvention, Integer32):
    description = "This TC describes an object which indicates the desired resource priority of the entire entry. Lower priorities indicate a lesser requirement to retain resources than higher priority values. A management station can use the resource priority to provide a probe with additional information for managing memory allocation. A probe is strongly encouraged, but not required, to honor all priority requests, all of the time. Objects declared with this TC should be contained within a conceptual control table entry. The indicated resource priority applies to the control entry, all internal data structures maintained on behalf of the control entry, and all external MIB data represented by the control entry. A probe should honor the priority requests in an implementation-dependent way. The data allocation granularity (i.e., shared data structures) may vary greatly for different implementations, so a particular implementation strategy is not mandated. However, the following guidelines are suggested for those agents which implement garbage-collection based on 'least-recently used' (LRU) or other criteria: In the event that the probe runs short of resources, and data entries are to be removed from particular tables to reclaim resources, then entries associated with lower ResourcePriority values should be deleted before entries associated with higher ResourcePriority values, regardless of the resource reclamation algorithm in use. In addition, entries associated with a higher AddressCollectScope value should be deleted before entries with a lower AddressCollectScope value. Note that the priority ordering of entries with the same ResourcePriority and addressCollectScope values is unspecified."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("lowPriority", 1), ("normalPriority", 2), ("highPriority", 3))

class AddressCollectScope(TextualConvention, Integer32):
    description = "This TC describes an object which indicates the granularity of the addresses represented in associated ATM-RMON collections. Addresses gathered on behalf of collections identified by the 'prefix(1)' enumeration will be cleared to zero in bytes 13 through 20, for indexing and counting purposes. Addresses gathered on behalf of collections identified by the 'prefixAndEsi(2)' enumeration will be cleared to zero in byte 20, for indexing and counting purposes. Addresses gathered on behalf of collections identified by the 'entireAddr(3)' enumeration will be unmodified, for indexing and counting purposes."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("prefix", 1), ("prefixAndEsi", 2), ("entireAddr", 3))

class ConnectTime(TextualConvention, Gauge32):
    description = 'This TC describes an object which indicates the sum of the elapsed times of all connections associated with a particular collection. This is a cumulative total and includes all connections which currently exist and all connections which have been released. Elapsed connection time begins when the call attempt is detected, and ends when the call is released. It is an implementation-specific matter whether call attempts which do not result in successful connections are represented in this total. Call duration is maintained in units of seconds, and are rounded to the nearest second when counted.'
    status = 'current'

portSelGrpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 1), )
if mibBuilder.loadTexts: portSelGrpTable.setStatus('current')
if mibBuilder.loadTexts: portSelGrpTable.setDescription('Controls the setup of port and ATM connection selection criteria used on behalf of any collection associated with entries in this table (e.g., atmHostTable). This table allows portSelTable entries with the same value of the portSelCollectGroup object to be grouped together to form port select groups. Note that an agent implementation may restrict the actual number of portSelGrp entries, due to resource limitations.')
portSelGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 1, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"))
if mibBuilder.loadTexts: portSelGrpEntry.setStatus('current')
if mibBuilder.loadTexts: portSelGrpEntry.setDescription('A conceptual row in the portSelGrpTable. An example of the indexing of this entry is portSelGrpCreateTime.7 .')
portSelGrpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: portSelGrpIndex.setStatus('current')
if mibBuilder.loadTexts: portSelGrpIndex.setDescription('An arbitrary and unique index for this portSelGrpEntry. If portSelGrpTable entries are recreated by the agent after a restart, then the portSelGrpIndex value must be retained across a restart as well.')
portSelGrpDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portSelGrpDescr.setStatus('current')
if mibBuilder.loadTexts: portSelGrpDescr.setDescription('An administratively-assigned descriptive label for this portSelGrp entry.')
portSelGrpCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 1, 1, 3), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSelGrpCreateTime.setStatus('current')
if mibBuilder.loadTexts: portSelGrpCreateTime.setDescription('The value of sysUpTime when this portSelGrp entry was activated. This can be used by the management station to ensure that the table has not been deleted and recreated between polls.')
portSelGrpOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 1, 1, 4), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portSelGrpOwner.setStatus('current')
if mibBuilder.loadTexts: portSelGrpOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
portSelGrpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 1, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portSelGrpStatus.setStatus('current')
if mibBuilder.loadTexts: portSelGrpStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. No objects are required to be written prior to the row being set to active(1). However, all portSelTable entries which are to be included in collections on behalf of this portSelectGroup, must be completely configured and activated before this object is set to active(1), since the associated instances of portSelStatus cannot be modified once this object has been set to active(1). If this object is not equal to active(1), all associated data collections shall be deleted (e.g., any associated collections in the atmStats, atmHostTable or atmMatrixSDTable). Note that associated portSelTable and any configured collection control entries (e.g., atmHostControlTable) are not deleted when this entry leaves the active state.')
portSelTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 2), )
if mibBuilder.loadTexts: portSelTable.setStatus('current')
if mibBuilder.loadTexts: portSelTable.setDescription('Controls the setup of selection criteria for a single ATM port, used on behalf of any collections identified with the associated portSelectGroup (identified by its portSelGrpIndex value). This table identifies the collection characteristics for the ATM port indicated by the ifIndex value in the index. Note that an agent implementation may restrict the actual number of portSelTable entries, due to resource limitations.')
portSelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: portSelEntry.setStatus('current')
if mibBuilder.loadTexts: portSelEntry.setDescription('A conceptual row in the portSelTable. Entries may only be created on behalf of ATM interfaces. That is, the ifType value associated with each ifIndex value must be equal to atm(37) or atmLogicalPort(80). An example of the indexing of this entry is portSelCreateTime.7 .')
portSelCollectGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portSelCollectGroup.setStatus('current')
if mibBuilder.loadTexts: portSelCollectGroup.setDescription('This object identifies the associated instance of portSelGrpIndex, which indicates the portSelectGroup to which this port is assigned. This object may not be modified if the associated instance of portSelStatus is equal to active(1).')
portSelCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 2, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSelCreateTime.setStatus('current')
if mibBuilder.loadTexts: portSelCreateTime.setDescription('The value of sysUpTime when this entry was activated. This can be used by the management station to ensure that the table has not been deleted and recreated between polls.')
portSelOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 2, 1, 3), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portSelOwner.setStatus('current')
if mibBuilder.loadTexts: portSelOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
portSelStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portSelStatus.setStatus('current')
if mibBuilder.loadTexts: portSelStatus.setDescription('The status of this row. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Specifically, an appropriate value for the portSelCollectGroup object must be set before this object may be set to active(1). An agent may wish to allow portSelTable entries to exist which reference non-existent portSelGrpTable entries, in order to reduce row creation order dependencies. All portSelTable entries which are to be included in a particular collection (as indicated by the portSelCollectGroup object), should be completely configured and activated before the associated portSelGrpStatus object is set to active(1). Configuration of a portSelectGroup cannot be modified once collections on its behalf have been started. This object may not be modified if the associated portSelGroupStatus in in the active(1) state, indicated by a portSelGrpIndex value identical to the value of the portSelCollectGroup object in this entry.')
atmStatsControlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 1), )
if mibBuilder.loadTexts: atmStatsControlTable.setStatus('current')
if mibBuilder.loadTexts: atmStatsControlTable.setDescription('A list of ATM basic statistic collection table control entries. These entries will enable the collection of statistical totals for an entire portSelectGroup.')
atmStatsControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 1, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"))
if mibBuilder.loadTexts: atmStatsControlEntry.setStatus('current')
if mibBuilder.loadTexts: atmStatsControlEntry.setDescription('A conceptual row in the atmStatsControlTable. Entries in this table are identified and indexed by the portSelGrpIndex object. At most one atmStats collection is done per portSelectGroup. An example of the indexing of this entry is atmStatsDropEvents.1 .')
atmStatsControlDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsControlDropEvents.setStatus('current')
if mibBuilder.loadTexts: atmStatsControlDropEvents.setDescription('The total number of events in which cells which should have been counted in the associated atmStatsEntry, but were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of cells or calls dropped; it is just the number of times this condition has been detected.')
atmStatsControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 1, 1, 2), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmStatsControlOwner.setStatus('current')
if mibBuilder.loadTexts: atmStatsControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
atmStatsControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 1, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmStatsControlStatus.setStatus('current')
if mibBuilder.loadTexts: atmStatsControlStatus.setDescription('The status of this atmStatsControlEntry. This control entry may be created and destroyed independently of the associated portSelGrpEntry, however its associated atmStatsTable can exist only when the portSelGrpEntry controlling this collection is active. If this object is not equal to active(1), all associated entries in the atmStatsTable shall be deleted.')
atmStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2), )
if mibBuilder.loadTexts: atmStatsTable.setStatus('current')
if mibBuilder.loadTexts: atmStatsTable.setDescription('A collection of statistical totals for all ATM addresses that have been discovered on behalf of the portSelectGroup associated with this entry.')
atmStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"), (0, "ATM-RMON-MIB", "atmStatsSClass"))
if mibBuilder.loadTexts: atmStatsEntry.setStatus('current')
if mibBuilder.loadTexts: atmStatsEntry.setDescription('A conceptual row in the atmStatsTable. The portSelGrpIndex value in the index identifies the portSelectGroup on whose behalf this entry was created. An example of the indexing of this entry is atmStatsCells.8.1')
atmStatsSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 1), ServiceClass())
if mibBuilder.loadTexts: atmStatsSClass.setStatus('current')
if mibBuilder.loadTexts: atmStatsSClass.setDescription('The quality of service classification for this entry. See the ServiceClass textual convention for details and specific class-of-service values.')
atmStatsCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 2), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsCreateTime.setStatus('current')
if mibBuilder.loadTexts: atmStatsCreateTime.setDescription('The value of sysUpTime when this entry was created. This can be used by the management station to ensure that the entry has not been deleted and recreated between polls.')
atmStatsCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsCells.setStatus('current')
if mibBuilder.loadTexts: atmStatsCells.setDescription('The total number of error-free cells detected on all ATM connections on behalf of this portSelectGroup collection. Note that a particular cell may only cause this counter to increment once, even if multiple criteria is met for inclusion in this portSelectGroup.')
atmStatsCellsRollovers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsCellsRollovers.setStatus('current')
if mibBuilder.loadTexts: atmStatsCellsRollovers.setDescription('The number of times that the associated instance of the atmStatsCells object has transitioned from the value 2^^32-1 to zero.')
atmStatsHCCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsHCCells.setStatus('current')
if mibBuilder.loadTexts: atmStatsHCCells.setDescription('The high capacity version of the atmStatsCells object.')
atmStatsNumCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsNumCallAttempts.setStatus('current')
if mibBuilder.loadTexts: atmStatsNumCallAttempts.setDescription('The number of call attempts detected on all signalled ATM connections on behalf of this portSelectGroup collection. A probe should increment this counter each time a connection setup attempt (identified with this portSelectGroup) is detected. For point-to-multipoint connections, this counter is incremented once per counted connection, regardless of the number of leafs identified in the connection.')
atmStatsNumCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsNumCalls.setStatus('current')
if mibBuilder.loadTexts: atmStatsNumCalls.setDescription('The number of successfully established calls detected on all signalled ATM connections on behalf of this portSelectGroup collection. Note that this value includes successfully established calls that are currently in progress. A probe should increment this counter each time a valid connection (identified with this portSelectGroup) is successfully established. For point-to-multipoint ATM connections, this counter is incremented once per counted connection, regardless of the number of leafs identified in the connection. Note that when a point-to-point connection setup enters on one port and leaves on another port in the same port select group, it is counted only once.')
atmStatsConnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 2, 2, 1, 8), ConnectTime()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmStatsConnTime.setStatus('current')
if mibBuilder.loadTexts: atmStatsConnTime.setDescription('The elapsed time of all calls identified by the associated instance of the atmStatsNumCallAttempts object. Note that point-to-multipoint calls are counted only once, regardless of the number of leafs participating in the call.')
atmHostControlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1), )
if mibBuilder.loadTexts: atmHostControlTable.setStatus('current')
if mibBuilder.loadTexts: atmHostControlTable.setDescription('A list of ATM host table control entries. These entries will enable the collection of ATM host information in the atmHostTable. Entries in the atmHostTable will be created on behalf of each entry in this table. A probe is required to support at most one atmHost collection per instance of an associated portSelectGroup, therefore the table is indexed by the portSelGrpIndex.')
atmHostControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"))
if mibBuilder.loadTexts: atmHostControlEntry.setStatus('current')
if mibBuilder.loadTexts: atmHostControlEntry.setDescription('A conceptual row in the atmHostControlTable. Entries in this table are identified and indexed by the portSelGrpIndex object. At most one atmHost collection is done per portSelectGroup. An example of the indexing of this entry is atmHostControlInserts.1')
atmHostControlInserts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostControlInserts.setStatus('current')
if mibBuilder.loadTexts: atmHostControlInserts.setDescription('The number of times an atmHost entry has been inserted into the atmHost table. If an entry is inserted, then deleted, and then inserted, this counter will be incremented by 2. To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the table size can be determined by subtracting atmHostControlDeletes from atmHostControlInserts.')
atmHostControlDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostControlDeletes.setStatus('current')
if mibBuilder.loadTexts: atmHostControlDeletes.setDescription('The number of times an atmHost entry has been deleted from the atmHost table (for any reason). If an entry is deleted, then inserted, and then deleted, this counter will be incremented by 2. To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the table size can be determined by subtracting atmHostControlDeletes from atmHostControlInserts.')
atmHostControlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 3), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmHostControlMaxDesiredEntries.setStatus('current')
if mibBuilder.loadTexts: atmHostControlMaxDesiredEntries.setDescription('The maximum number of entries that are desired in the atmHostTable on behalf of this control entry. The probe will not create more than this number of associated entries in the table, but may choose to create fewer entries in this table for any reason including the lack of resources. If this value is set to -1, the probe may create any number of entries in this table. If the associated instance of atmHostControlStatus object is equal to active(1), this object may not be modified.')
atmHostControlPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 4), ResourcePriority().clone('normalPriority')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmHostControlPriority.setStatus('current')
if mibBuilder.loadTexts: atmHostControlPriority.setDescription('The priority this collection should be given to retain resources, in the event the probe must reclaim some resources in order to add new entries to an existing atmHost collection or add new collections of other types. If the associated instance of atmHostControlStatus object is equal to active(1), this object may not be modified.')
atmHostControlAddrCollectScope = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 5), AddressCollectScope().clone('prefixAndEsi')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmHostControlAddrCollectScope.setStatus('current')
if mibBuilder.loadTexts: atmHostControlAddrCollectScope.setDescription('This object controls the granularity of address collection in atmHostTable entries created on behalf of this control entry, according to the rules specified by the AddressCollectScope textual convention. If the associated instance of atmHostControlStatus object is equal to active(1), this object may not be modified.')
atmHostControlDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostControlDropEvents.setStatus('current')
if mibBuilder.loadTexts: atmHostControlDropEvents.setDescription('The total number of events in which cells which should have been counted in the associated atmHostEntry, but were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of cells or calls dropped; it is just the number of times this condition has been detected.')
atmHostControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 7), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmHostControlOwner.setStatus('current')
if mibBuilder.loadTexts: atmHostControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
atmHostControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmHostControlStatus.setStatus('current')
if mibBuilder.loadTexts: atmHostControlStatus.setDescription('The status of this atmHostControlEntry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Specifically, appropriate values for the associated instances of atmHostControlMaxDesiredEntries, atmHostControlPriority, and atmHostControlAddrCollectScope must be set before this object may be set to active(1). This control entry may be created and destroyed independently of the associated portSelGrpEntry, however its associated atmHostTable can exist only when the portSelGrpEntry controlling this collection is active. If this object is not equal to active(1), all associated entries in the atmHostTable shall be deleted.')
atmHostTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2), )
if mibBuilder.loadTexts: atmHostTable.setStatus('current')
if mibBuilder.loadTexts: atmHostTable.setDescription('A collection of statistics for a particular ATM host address that has been discovered on behalf of the portSelectGroup associated with this entry. The probe will add to this table all addresses seen as the source or destination address in all calls, on all ports configured in the portSelGrpEntry controlling this collection.')
atmHostEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"), (0, "ATM-RMON-MIB", "atmHostAddress"), (0, "ATM-RMON-MIB", "atmHostSClass"))
if mibBuilder.loadTexts: atmHostEntry.setStatus('current')
if mibBuilder.loadTexts: atmHostEntry.setDescription('A conceptual row in the atmHostTable. The portSelGrpIndex value in the index identifies the portSelectGroup on whose behalf this entry was created. An example of the indexing of this entry is atmHostInCells.4.20.<NSAP>.2')
atmHostAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmHostAddress.setStatus('current')
if mibBuilder.loadTexts: atmHostAddress.setDescription("The ATM address for this atmHostEntry. This is represented as an octet string with specific semantics and length as identified by the AtmAddr textual convention. Note that only 20 octet 'AtmAddr' addresses are collected in this table.")
atmHostSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 2), ServiceClass())
if mibBuilder.loadTexts: atmHostSClass.setStatus('current')
if mibBuilder.loadTexts: atmHostSClass.setDescription('The quality of service classification for this entry. See the ServiceClass textual convention for details and specific class-of-service values.')
atmHostCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 3), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostCreateTime.setStatus('current')
if mibBuilder.loadTexts: atmHostCreateTime.setDescription('The value of sysUpTime when this entry was activated. This can be used by the management station to ensure that the entry has not been deleted and recreated between polls.')
atmHostInCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostInCells.setStatus('current')
if mibBuilder.loadTexts: atmHostInCells.setDescription('The number of error-free cells detected on ATM connections associated with this portSelectGroup, in which this ATM address was identified as the receiver address, or one of the leaf addresses on a point-to-multipoint ATM connection.')
atmHostInCellsRollovers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostInCellsRollovers.setStatus('current')
if mibBuilder.loadTexts: atmHostInCellsRollovers.setDescription('The number of times that the associated instance of the atmHostInCells object has transitioned from the value 2^^32-1 to zero.')
atmHostInHCCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostInHCCells.setStatus('current')
if mibBuilder.loadTexts: atmHostInHCCells.setDescription('The high capacity version of the atmHostInCells object.')
atmHostOutCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostOutCells.setStatus('current')
if mibBuilder.loadTexts: atmHostOutCells.setDescription('The number of error-free cells detected on ATM connections associated with this portSelectGroup, in which this ATM address was identified as the sender address.')
atmHostOutCellsRollovers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 8), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostOutCellsRollovers.setStatus('current')
if mibBuilder.loadTexts: atmHostOutCellsRollovers.setDescription('The number of times that the associated instance of the atmHostOutCells object has transitioned from the value 2^^32-1 to zero.')
atmHostOutHCCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostOutHCCells.setStatus('current')
if mibBuilder.loadTexts: atmHostOutHCCells.setDescription('The high capacity version of the atmHostOutCells object.')
atmHostInNumCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 10), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostInNumCallAttempts.setStatus('current')
if mibBuilder.loadTexts: atmHostInNumCallAttempts.setDescription('The number of calls detected on ATM connections associated with this entry, in which the associated endpoint address was identified as the Called Party in an signalled ATM connection establishment attempt. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a connection attempt is detected in which this ATM host is identified as the Called Party, or one of the leaf addresses for point-to-multipoint ATM connections.')
atmHostInNumCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 11), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostInNumCalls.setStatus('current')
if mibBuilder.loadTexts: atmHostInNumCalls.setDescription('The number of successfully established calls detected on ATM connections associated with this entry, in which the associated endpoint address was identified as the Called Party address. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a connection is successfully established in which this ATM host is identified as the Called Party address, or one of the leaf addresses for point-to-multipoint ATM connections.')
atmHostOutNumCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 12), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostOutNumCallAttempts.setStatus('current')
if mibBuilder.loadTexts: atmHostOutNumCallAttempts.setDescription('The number of calls detected on ATM connections associated with this entry, in which the associated endpoint address was identified as the Calling Party in an signalled ATM connection establishment attempt. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a connection attempt is detected in which this ATM host is identified as the Calling Party. Note that for point-to-multipoint ATM connections, this counter is incremented only once per call, regardless of the number of leafs established at setup time or the number of leaf-initiated-join attempts since the call was established.')
atmHostOutNumCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 13), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostOutNumCalls.setStatus('current')
if mibBuilder.loadTexts: atmHostOutNumCalls.setDescription('The number of successfully established calls detected on ATM connections associated with this entry, in which the associated endpoint address was identified as the Calling Party address. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a connection is successfully established in which this ATM host is identified as the Calling Party address.')
atmHostInConnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 14), ConnectTime()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostInConnTime.setStatus('current')
if mibBuilder.loadTexts: atmHostInConnTime.setDescription('The elapsed time of all calls identified by the associated instance of atmHostInNumCallAttempts.')
atmHostOutConnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 3, 2, 1, 15), ConnectTime()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmHostOutConnTime.setStatus('current')
if mibBuilder.loadTexts: atmHostOutConnTime.setDescription('The elapsed time of all calls identified by the associated instance of atmHostOutNumCallAttempts.')
atmMatrixControlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1), )
if mibBuilder.loadTexts: atmMatrixControlTable.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlTable.setDescription('A list of ATM matrix table control entries. These entries will enable the collection of ATM matrix information in the atmMatrixSDTable and atmMatrixDSTable. A probe is required to support at most one atmMatrix collection per instance of an associated portSelectGroup, therefore the table is indexed by the portSelGrpIndex.')
atmMatrixControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"))
if mibBuilder.loadTexts: atmMatrixControlEntry.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlEntry.setDescription('A conceptual row in the atmMatrixControlTable. An example of the indexing of this entry is atmMatrixControlInserts.1')
atmMatrixControlInserts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixControlInserts.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlInserts.setDescription('The number of times an atmMatrix entry has been inserted into the atmMatrix table. If an entry is inserted, then deleted, and then inserted, this counter will be incremented by 2. The addition of a conversation into both the atmMatrixSDTable and atmMatrixDSTable shall be counted as two insertions (even though every addition into one table must be accompanied by an insertion into the other). To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the table size can be determined by subtracting atmMatrixControlDeletes from atmMatrixControlInserts, and dividing the result by two.')
atmMatrixControlDeletes = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixControlDeletes.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlDeletes.setDescription('The number of times an atmMatrix entry has been deleted from the atmMatrix table (for any reason). If an entry is deleted, then inserted, and then deleted, this counter will be incremented by 2. The deletion of a conversation from both the atmMatrixSDTable and atmMatrixDSTable shall be counted as two deletions (even though every deletion from one table must be accompanied by a deletion from the other). To allow for efficient implementation strategies, agents may delay updating this object for short periods of time. For example, an implementation strategy may allow internal data structures to differ from those visible via SNMP for short periods of time. This counter may reflect the internal data structures for those short periods of time. Note that the table size can be determined by subtracting atmMatrixControlDeletes from atmMatrixControlInserts, and dividing the result by two.')
atmMatrixControlMaxDesiredEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 3), Integer32().clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixControlMaxDesiredEntries.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlMaxDesiredEntries.setDescription('The maximum number of entries that are desired in the atmMatrixTable on behalf of this control entry. The probe will not create more than this number of associated entries in the table, but may choose to create fewer entries in this table for any reason including the lack of resources. If this value is set to -1, the probe may create any number of entries in this table. If the associated instance of atmMatrixControlStatus object is equal to active(1), this object may not be modified.')
atmMatrixControlPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 4), ResourcePriority().clone('normalPriority')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixControlPriority.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlPriority.setDescription('The priority this collection should be given to retain resources, in the event the probe must reclaim some resources in order to add new entries to an existing atmMatrix collection or add new collections of other types. If the associated instance of atmMatrixControlStatus object is equal to active(1), this object may not be modified.')
atmMatrixControlAddrCollectScope = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 5), AddressCollectScope().clone('prefixAndEsi')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixControlAddrCollectScope.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlAddrCollectScope.setDescription('This object controls the granularity of address collection in atmMatrixSDTable and atmMatrixDSTable entries created on behalf of this control entry, according to the rules specified by the AddressCollectScope textual convention. If the associated instance of atmMatrixControlStatus object is equal to active(1), this object may not be modified.')
atmMatrixControlDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixControlDropEvents.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlDropEvents.setDescription('The total number of events in which cells which should have been counted in the associated atmMatrixSDEntry and atmMatrixDSEntry, but were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of cells or calls dropped; it is just the number of times this condition has been detected.')
atmMatrixControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 7), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixControlOwner.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
atmMatrixControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixControlStatus.setStatus('current')
if mibBuilder.loadTexts: atmMatrixControlStatus.setDescription('The status of this atmMatrixControlEntry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Specifically, the associated instances of atmMatrixControlMaxDesiredEntries, atmMatrixControlPriority, and atmMatrixControlAddrCollectScope objects must be set to appropriate values before this object may be set to active(1). This control entry may be created and destroyed independently of the associated portSelGrpEntry, however its associated atmMatrixSDTable and atmMatrixDSTable can exist only when the portSelGrpEntry controlling this collection is active. If this object is not equal to active(1), all associated entries in the atmMatrixSDTable and atmMatrixDSTable shall be deleted.')
atmMatrixSDTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2), )
if mibBuilder.loadTexts: atmMatrixSDTable.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDTable.setDescription('A collection of statistics for conversations between particular ATM endpoint addresses that have been discovered on behalf of the portSelectGroup associated with this entry. The probe will add a new entry to this table for all conversations (connections) between distinct source and destination address pairs, detected in all calls, on all ports configured in the portSelGrpEntry controlling this collection. Further, this table will only contain entries that have a corresponding entry in the atmMatrixDSTable with the same source address and destination address.')
atmMatrixSDEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"), (0, "ATM-RMON-MIB", "atmMatrixSDSrcAddress"), (0, "ATM-RMON-MIB", "atmMatrixSDDstAddress"), (0, "ATM-RMON-MIB", "atmMatrixSDSClass"))
if mibBuilder.loadTexts: atmMatrixSDEntry.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDEntry.setDescription('A conceptual row in the atmMatrixSDTable. The portSelGrpIndex value in the index identifies the portSelectGroup on whose behalf this entry was created. An example of the indexing of this entry is atmMatrixSDCells.1.20.<NSAP>.20.<NSAP>.2')
atmMatrixSDSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmMatrixSDSrcAddress.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDSrcAddress.setDescription("The transmitting endpoint ATM address for this atmMatrixSDEntry. This is represented as an octet string with specific semantics and length as identified by the AtmAddr textual convention. Note that only 20 octet 'AtmAddr' addresses are collected in this table.")
atmMatrixSDDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 2), AtmAddr())
if mibBuilder.loadTexts: atmMatrixSDDstAddress.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDDstAddress.setDescription("The destination endpoint ATM address for this atmMatrixSDEntry. This is represented as an octet string with specific semantics and length as identified by the AtmAddr textual convention. Note that only 20 octet 'AtmAddr' addresses are collected in this table.")
atmMatrixSDSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 3), ServiceClass())
if mibBuilder.loadTexts: atmMatrixSDSClass.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDSClass.setDescription('The quality of service classification for this entry. See the ServiceClass textual convention for details and specific class-of-service values.')
atmMatrixSDCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 4), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixSDCreateTime.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDCreateTime.setDescription('The value of sysUpTime when this entry was activated. This can be used by the management station to ensure that the entry has not been deleted and recreated between polls.')
atmMatrixSDCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixSDCells.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDCells.setDescription('The number of error-free cells detected on connections in which these ATM addresses were identified as the transmitting and receiving endpoint addresses. Note that for point-to-multipoint connections, an entry is created for each root-to-leaf address-pair that exists, and each cell sent from the root on a point-to-multipoint ATM connection is counted once in each distinct matrix entry.')
atmMatrixSDCellsRollovers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixSDCellsRollovers.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDCellsRollovers.setDescription('The number of times that the associated instance of the atmMatrixSDCells object has transitioned from the value 2^^32-1 to zero.')
atmMatrixSDHCCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixSDHCCells.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDHCCells.setDescription('The high capacity version of the atmMatrixSDCells object.')
atmMatrixSDNumCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 8), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixSDNumCallAttempts.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDNumCallAttempts.setDescription('The number of SVC call setup attempts detected on ATM connections within the specified portSelectGroup, in which the indicated atmMatrixSDSrcAddress endpoint address was identified as the Calling Party and the indicated atmMatrixSDDstAddress was identified as the Called Party. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a connection attempt is detected in which these ATM addresses are identified as the calling and called parties.')
atmMatrixSDNumCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 9), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixSDNumCalls.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDNumCalls.setDescription('The number of successful SVC call setups detected on ATM connections within the specified portSelectGroup, in which the indicated atmMatrixSDSrcAddress endpoint address was identified as the Calling Party and the indicated atmMatrixSDDstAddress was identified as the Called Party. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a valid connection is established in which these ATM addresses are identified as the calling and called parties.')
atmMatrixSDConnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 2, 1, 10), ConnectTime()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixSDConnTime.setStatus('current')
if mibBuilder.loadTexts: atmMatrixSDConnTime.setDescription('The elapsed time of all calls identified by the associated instance of atmMatrixSDNumCallAttempts.')
atmMatrixDSTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3), )
if mibBuilder.loadTexts: atmMatrixDSTable.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSTable.setDescription('A collection of statistics for conversations between particular ATM endpoint addresses that have been discovered on behalf of the portSelectGroup associated with this entry. The probe will add a new entry to this table for all conversations (connections) between distinct source and destination address pairs, detected in all cells identified by the associated portSelGrpEntry criteria. Further, this table will only contain entries that have a corresponding entry in the atmMatrixSDTable with the same source address and destination address.')
atmMatrixDSEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"), (0, "ATM-RMON-MIB", "atmMatrixDSDstAddress"), (0, "ATM-RMON-MIB", "atmMatrixDSSrcAddress"), (0, "ATM-RMON-MIB", "atmMatrixDSSClass"))
if mibBuilder.loadTexts: atmMatrixDSEntry.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSEntry.setDescription('A conceptual row in the atmMatrixDSTable. The portSelGrpIndex value in the index identifies the portSelectGroup on whose behalf this entry was created. An example of the indexing of this entry is atmMatrixDSCells.1.20.<NSAP>.20.<NSAP>.2')
atmMatrixDSSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 1), AtmAddr())
if mibBuilder.loadTexts: atmMatrixDSSrcAddress.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSSrcAddress.setDescription("The transmitting endpoint ATM address for this atmMatrixDSEntry. This is represented as an octet string with specific semantics and length as identified by the AtmAddr textual convention. Note that only 20 octet 'AtmAddr' addresses are collected in this table.")
atmMatrixDSDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 2), AtmAddr())
if mibBuilder.loadTexts: atmMatrixDSDstAddress.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSDstAddress.setDescription("The destination endpoint ATM address for this atmMatrixDSEntry. This is represented as an octet string with specific semantics and length as identified by the AtmAddr textual convention. Note that only 20 octet 'AtmAddr' addresses are collected in this table.")
atmMatrixDSSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 3), ServiceClass())
if mibBuilder.loadTexts: atmMatrixDSSClass.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSSClass.setDescription('The quality of service classification for this entry. See the ServiceClass textual convention for details and specific class-of-service values.')
atmMatrixDSCreateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 4), LastCreateTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixDSCreateTime.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSCreateTime.setDescription('The value of sysUpTime when this entry was activated. This can be used by the management station to ensure that the entry has not been deleted and recreated between polls.')
atmMatrixDSCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixDSCells.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSCells.setDescription('The number of error-free cells detected on ATM connections in which these ATM addresses were identified as the transmitting and receiving endpoint addresses. Note that for point-to-multipoint connections, an entry is created for each root-to-leaf address-pair that exists, and each cell sent from the root on a point-to-multipoint ATM connection is counted once in each distinct matrix entry.')
atmMatrixDSCellsRollovers = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixDSCellsRollovers.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSCellsRollovers.setDescription('The number of times that the associated instance of the atmMatrixDSCells object has transitioned from the value 2^^32-1 to zero.')
atmMatrixDSHCCells = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 7), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixDSHCCells.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSHCCells.setDescription('The high capacity version of the atmMatrixDSCells object.')
atmMatrixDSNumCallAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 8), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixDSNumCallAttempts.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSNumCallAttempts.setDescription('The number of SVC call setup attempts detected on ATM connections within the specified portSelectGroup, in which the indicated atmMatrixDSSrcAddress endpoint address was identified as the Calling Party and the indicated atmMatrixDSDstAddress was identified as the Called Party. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a connection attempt is detected in which these ATM addresses are identified as the calling and called parties.')
atmMatrixDSNumCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 9), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixDSNumCalls.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSNumCalls.setDescription('The number of successful SVC call setups detected on ATM connections within the specified portSelectGroup, in which the indicated atmMatrixDSSrcAddress endpoint address was identified as the Calling Party and the indicated atmMatrixDSDstAddress was identified as the Called Party. Note that this value includes calls that are currently in progress. A probe should increment this counter each time a valid connection is established in which these ATM addresses are identified as the calling and called parties.')
atmMatrixDSConnTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 3, 1, 10), ConnectTime()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixDSConnTime.setStatus('current')
if mibBuilder.loadTexts: atmMatrixDSConnTime.setDescription('The elapsed time of all calls identified by the associated instance of atmMatrixDSNumCallAttempts.')
atmMatrixTopNControlTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4), )
if mibBuilder.loadTexts: atmMatrixTopNControlTable.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlTable.setDescription('A set of parameters that control the creation of a report of the top N matrix entries according to a selected metric.')
atmMatrixTopNControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"), (0, "ATM-RMON-MIB", "atmMatrixTopNControlIndex"))
if mibBuilder.loadTexts: atmMatrixTopNControlEntry.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlEntry.setDescription('A conceptual row in the atmMatrixTopNControlTable. An example of the indexing of this table is atmMatrixTopNControlDuration.3.1')
atmMatrixTopNControlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: atmMatrixTopNControlIndex.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlIndex.setDescription('An index that is used to uniquely identify an entry in the atmMatrixTopNControlTable. Each such entry defines one top N report prepared on behalf of one atmMatrix entry, which must exist before this entry may be created.')
atmMatrixTopNControlRateBase = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("atmMatrixTopNCells", 1), ("atmMatrixTopNNumCallAttempts", 2), ("atmMatrixTopNNumCalls", 3), ("atmMatrixTopNConnTime", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixTopNControlRateBase.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlRateBase.setDescription('The variable for each atmMatrix entry that the atmMatrixTopNEntries are sorted by. This object may not be modified if the associated atmMatrixTopNControlStatus object is equal to active(1).')
atmMatrixTopNControlSClass = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 3), ServiceClass()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixTopNControlSClass.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlSClass.setDescription('The service class for which this topN control entry is collecting information in associated atmMatrixTopN reports. This object may not be modified if the associated atmMatrixTopNControlStatus object is equal to active(1).')
atmMatrixTopNControlTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 4), Integer32().clone(1800)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixTopNControlTimeRemaining.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlTimeRemaining.setDescription('The number of seconds left in the report currently being collected. When this object is modified by the management station, a new collection is started, possibly aborting a currently running report. The new value is used as the requested duration of this report, and is immediately loaded into the associated atmMatrixTopNControlDuration object. When the report finishes, the probe will automatically start another collection with the same initial value of atmMatrixTopNControlTimeRemaining. Thus the management station may simply read the resulting reports repeatedly, checking the startTime and duration each time to ensure that a report was not missed or that the report parameters were not changed. While the value of this object is non-zero, it decrements by one per second until it reaches zero. At the time that this object decrements to zero, the report is made accessible in the atmMatrixTopNTable, overwriting any report that may be there. When this object is modified by the management station, any associated entries in the atmMatrixTopNTable shall be deleted.')
atmMatrixTopNControlGeneratedReports = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNControlGeneratedReports.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlGeneratedReports.setDescription('The number of reports that have been generated by this entry.')
atmMatrixTopNControlDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNControlDuration.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlDuration.setDescription('The number of seconds that this report has collected during the last sampling interval. When the associated atmMatrixTopNControlTimeRemaining object is set, this object shall be set by the probe to the same value and shall not be modified until the next time the atmMatrixTopNControlTimeRemaining is set. This value shall be zero if no reports have been requested for this atmMatrixTopNControlEntry.')
atmMatrixTopNControlRequestedSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 7), Integer32().clone(150)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixTopNControlRequestedSize.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlRequestedSize.setDescription('The maximum number of host entries requested for this report. When this object is created or modified, the probe should set atmMatrixTopNControlGrantedSize as closely to this object as is possible for the particular probe implementation and available resources.')
atmMatrixTopNControlGrantedSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNControlGrantedSize.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlGrantedSize.setDescription('The maximum number of host entries in this report. When the associated atmMatrixTopNControlRequestedSize object is created or modified, the probe should set this object as closely to the requested value as is possible for the particular implementation and available resources. The probe must not lower this value except as a result of a set to the associated atmMatrixTopNControlRequestedSize object. For example, if the value of atmMatrixTopNControlRateBase is equal to atmMatrixTopNCells(1), when the next topN report is generated, host entries with the highest value of atmMatrixSDCells shall be placed in this table in decreasing order of this rate until there is no more room or until there are no more matrix entries. Each atmMatrixSDCells value is copied to the associated atmMatrixTopNRate object. It is an implementation-specific matter how entries with the same value are sorted. It is also an implementation- specific matter as to whether or not zero-valued entries are available.')
atmMatrixTopNControlStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 9), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNControlStartTime.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlStartTime.setDescription('The value of sysUpTime when this top N report was last started. In other words, this is the time that the associated atmMatrixTopNControlTimeRemaining object was modified to start the requested report or the time the report was last automatically (re)started. This object may be used by the management station to determine if a report was missed or not.')
atmMatrixTopNControlOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 10), OwnerString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixTopNControlOwner.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
atmMatrixTopNControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 4, 1, 11), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: atmMatrixTopNControlStatus.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNControlStatus.setDescription('The status of this atmMatrixTopNControlEntry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. If this object is not equal to active(1), all associated entries in the atmMatrixTopNTable shall be deleted by the agent.')
atmMatrixTopNTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 5), )
if mibBuilder.loadTexts: atmMatrixTopNTable.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNTable.setDescription('A set of statistics for those matrix entries that have counted the highest number of cells, calls, or connection time.')
atmMatrixTopNEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 5, 1), ).setIndexNames((0, "ATM-RMON-MIB", "portSelGrpIndex"), (0, "ATM-RMON-MIB", "atmMatrixTopNControlIndex"), (0, "ATM-RMON-MIB", "atmMatrixTopNIndex"))
if mibBuilder.loadTexts: atmMatrixTopNEntry.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNEntry.setDescription('A conceptual row in the atmMatrixTopNTable. The atmMatrixTopNControlIndex value in the index identifies the atmMatrixTopNControlEntry on whose behalf this entry was created. An example of the indexing of this table is atmMatrixTopNSrcAddress.1.3.10')
atmMatrixTopNIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: atmMatrixTopNIndex.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNIndex.setDescription('An index that uniquely identifies an entry in the atmMatrixTopNTable among those in the same report. This index is between 1 and N, where N is the number of entries in this report. Each conversation in the selected atmMatrixSDTable, for the report interval, is ranked in descending order of the metric identified by the atmMatrixTopNRate object. For example, if the value of atmMatrixTopNControlRateBase is equal to atmMatrixTopNCells(1), increasing values of atmMatrixTopNIndex shall be assigned to entries with decreasing delta values of atmMatrixSDCells (for the report interval), until index N is assigned or there are no more atmMatrixSDEntries.')
atmMatrixTopNSrcAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 5, 1, 2), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNSrcAddress.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNSrcAddress.setDescription("The ATM endpoint address identified as the source of the traffic measured in this report. Note that only 20 octet 'AtmAddr' addresses are collected in this table.")
atmMatrixTopNDstAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 5, 1, 3), AtmAddr()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNDstAddress.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNDstAddress.setDescription("The ATM endpoint address identified as the destination of the traffic measured in this report. Note that only 20 octet 'AtmAddr' addresses are collected in this table.")
atmMatrixTopNRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNRate.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNRate.setDescription('The value of the ranked metric for this conversation, for this report. If the associated value of atmMatrixTopNRateBase is equal to atmMatrixTopNCells(1), then this object is assigned the delta value of the atmMatrixSDCells object during this report interval. If the associated value of atmMatrixTopNRateBase is equal to atmMatrixTopNNumCallAttempts(2), then this object is assigned the delta value of the atmMatrixSDNumCallAttempts object during this report interval. If the associated value of atmMatrixTopNRateBase is equal to atmMatrixTopNNumCalls(3), then this object is assigned the delta value of the atmMatrixSDNumCalls object during this report interval. If the associated value of atmMatrixTopNRateBase is equal to atmMatrixTopNConnTime(4), then this object is assigned the delta value of the atmMatrixSDConnTime object during this report interval.')
atmMatrixTopNReverseRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 4, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmMatrixTopNReverseRate.setStatus('current')
if mibBuilder.loadTexts: atmMatrixTopNReverseRate.setDescription('The value of the associated metric for this conversation, and for this report, but for the reverse direction. For example, if the associated value of atmMatrixTopNRateBase is equal to atmMatrixTopNCells(1), then this object contains the atmMatrixSDCells delta cell rate for the reverse direction traffic (i.e., destination to source traffic).')
atmRmonDataCollectMode = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 16, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmRmonDataCollectMode.setStatus('current')
if mibBuilder.loadTexts: atmRmonDataCollectMode.setDescription("Controls the internal data collection for the entire ATM-RMON agent. If this object has a value of 'active(1)', then data tables will be created and maintained (normal behavior). If this object has a value of 'inactive(2)' then ATM-RMON monitoring will not occur, even if valid control tables exist for particular collections. Data tables for active collections are deleted when this object is changed to 'inactive(2)', but control tables are not deleted. When this object is changed to 'active(1)', data collection is started for all valid control tables. ")
atmRmonMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 1))
atmRmonMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2))
atmRmonMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 1, 1)).setObjects(("ATM-RMON-MIB", "portSelectGroup"), ("ATM-RMON-MIB", "atmStatsGroup"), ("ATM-RMON-MIB", "atmHostGroup"), ("ATM-RMON-MIB", "atmMatrixGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmRmonMIBCompliance = atmRmonMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: atmRmonMIBCompliance.setDescription('Describes the requirements for conformance to the ATM-RMON MIB.')
portSelectGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 1)).setObjects(("ATM-RMON-MIB", "portSelGrpDescr"), ("ATM-RMON-MIB", "portSelGrpCreateTime"), ("ATM-RMON-MIB", "portSelGrpOwner"), ("ATM-RMON-MIB", "portSelGrpStatus"), ("ATM-RMON-MIB", "portSelCollectGroup"), ("ATM-RMON-MIB", "portSelCreateTime"), ("ATM-RMON-MIB", "portSelOwner"), ("ATM-RMON-MIB", "portSelStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    portSelectGroup = portSelectGroup.setStatus('current')
if mibBuilder.loadTexts: portSelectGroup.setDescription('Selects the ATM connections that should be monitored as part of a specific collection-group.')
atmStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 2)).setObjects(("ATM-RMON-MIB", "atmStatsControlDropEvents"), ("ATM-RMON-MIB", "atmStatsControlOwner"), ("ATM-RMON-MIB", "atmStatsControlStatus"), ("ATM-RMON-MIB", "atmStatsCreateTime"), ("ATM-RMON-MIB", "atmStatsCells"), ("ATM-RMON-MIB", "atmStatsCellsRollovers"), ("ATM-RMON-MIB", "atmStatsNumCallAttempts"), ("ATM-RMON-MIB", "atmStatsNumCalls"), ("ATM-RMON-MIB", "atmStatsConnTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmStatsGroup = atmStatsGroup.setStatus('current')
if mibBuilder.loadTexts: atmStatsGroup.setDescription('Counts the basic statistics for collections on behalf of particular portSelectGroup collections.')
atmStatsHCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 3)).setObjects(("ATM-RMON-MIB", "atmStatsHCCells"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmStatsHCGroup = atmStatsHCGroup.setStatus('current')
if mibBuilder.loadTexts: atmStatsHCGroup.setDescription('Counts the high capacity basic statistics for collections on behalf of particular portSelectGroup collections. The atmStatsGroup must be implemented if the atmStatsHCGroup is implemented. This group is mandatory for implementations which support high capacity counters.')
atmHostGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 4)).setObjects(("ATM-RMON-MIB", "atmHostControlInserts"), ("ATM-RMON-MIB", "atmHostControlDeletes"), ("ATM-RMON-MIB", "atmHostControlMaxDesiredEntries"), ("ATM-RMON-MIB", "atmHostControlPriority"), ("ATM-RMON-MIB", "atmHostControlAddrCollectScope"), ("ATM-RMON-MIB", "atmHostControlDropEvents"), ("ATM-RMON-MIB", "atmHostControlOwner"), ("ATM-RMON-MIB", "atmHostControlStatus"), ("ATM-RMON-MIB", "atmHostCreateTime"), ("ATM-RMON-MIB", "atmHostInCells"), ("ATM-RMON-MIB", "atmHostInCellsRollovers"), ("ATM-RMON-MIB", "atmHostOutCells"), ("ATM-RMON-MIB", "atmHostOutCellsRollovers"), ("ATM-RMON-MIB", "atmHostInNumCallAttempts"), ("ATM-RMON-MIB", "atmHostInNumCalls"), ("ATM-RMON-MIB", "atmHostOutNumCallAttempts"), ("ATM-RMON-MIB", "atmHostOutNumCalls"), ("ATM-RMON-MIB", "atmHostInConnTime"), ("ATM-RMON-MIB", "atmHostOutConnTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmHostGroup = atmHostGroup.setStatus('current')
if mibBuilder.loadTexts: atmHostGroup.setDescription('Counts the amount of traffic sent from and to each ATM address discovered by the probe, on behalf of particular portSelectGroup collections.')
atmHostHCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 5)).setObjects(("ATM-RMON-MIB", "atmHostInHCCells"), ("ATM-RMON-MIB", "atmHostOutHCCells"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmHostHCGroup = atmHostHCGroup.setStatus('current')
if mibBuilder.loadTexts: atmHostHCGroup.setDescription('Counts the amount of traffic sent from and to each ATM address discovered by the probe, on behalf of particular portSelectGroup collections, using high-capacity counters. The atmHostGroup must be implemented if the atmHostHCGroup is implemented. This group is mandatory for implementations which support high capacity counters.')
atmMatrixGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 6)).setObjects(("ATM-RMON-MIB", "atmMatrixControlInserts"), ("ATM-RMON-MIB", "atmMatrixControlDeletes"), ("ATM-RMON-MIB", "atmMatrixControlMaxDesiredEntries"), ("ATM-RMON-MIB", "atmMatrixControlPriority"), ("ATM-RMON-MIB", "atmMatrixControlAddrCollectScope"), ("ATM-RMON-MIB", "atmMatrixControlDropEvents"), ("ATM-RMON-MIB", "atmMatrixControlOwner"), ("ATM-RMON-MIB", "atmMatrixControlStatus"), ("ATM-RMON-MIB", "atmMatrixSDCreateTime"), ("ATM-RMON-MIB", "atmMatrixSDCells"), ("ATM-RMON-MIB", "atmMatrixSDCellsRollovers"), ("ATM-RMON-MIB", "atmMatrixSDNumCallAttempts"), ("ATM-RMON-MIB", "atmMatrixSDNumCalls"), ("ATM-RMON-MIB", "atmMatrixSDConnTime"), ("ATM-RMON-MIB", "atmMatrixDSCreateTime"), ("ATM-RMON-MIB", "atmMatrixDSCells"), ("ATM-RMON-MIB", "atmMatrixDSCellsRollovers"), ("ATM-RMON-MIB", "atmMatrixDSNumCallAttempts"), ("ATM-RMON-MIB", "atmMatrixDSNumCalls"), ("ATM-RMON-MIB", "atmMatrixDSConnTime"), ("ATM-RMON-MIB", "atmMatrixTopNControlRateBase"), ("ATM-RMON-MIB", "atmMatrixTopNControlSClass"), ("ATM-RMON-MIB", "atmMatrixTopNControlTimeRemaining"), ("ATM-RMON-MIB", "atmMatrixTopNControlGeneratedReports"), ("ATM-RMON-MIB", "atmMatrixTopNControlDuration"), ("ATM-RMON-MIB", "atmMatrixTopNControlRequestedSize"), ("ATM-RMON-MIB", "atmMatrixTopNControlGrantedSize"), ("ATM-RMON-MIB", "atmMatrixTopNControlStartTime"), ("ATM-RMON-MIB", "atmMatrixTopNControlOwner"), ("ATM-RMON-MIB", "atmMatrixTopNControlStatus"), ("ATM-RMON-MIB", "atmMatrixTopNSrcAddress"), ("ATM-RMON-MIB", "atmMatrixTopNDstAddress"), ("ATM-RMON-MIB", "atmMatrixTopNRate"), ("ATM-RMON-MIB", "atmMatrixTopNReverseRate"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmMatrixGroup = atmMatrixGroup.setStatus('current')
if mibBuilder.loadTexts: atmMatrixGroup.setDescription('Counts the amount of traffic sent between each pair of ATM addresses discovered by the probe, on behalf of particular portSelectGroup collections.')
atmMatrixHCGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 7)).setObjects(("ATM-RMON-MIB", "atmMatrixSDHCCells"), ("ATM-RMON-MIB", "atmMatrixDSHCCells"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmMatrixHCGroup = atmMatrixHCGroup.setStatus('current')
if mibBuilder.loadTexts: atmMatrixHCGroup.setDescription('Counts the amount of traffic sent between each pair of ATM addresses discovered by the probe, on behalf of particular portSelectGroup collections, using high capacity counters. The atmMatrixGroup must be implemented if the atmMatrixHCGroup is implemented. This group is mandatory for implementations which support high capacity counters.')
atmConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 16, 3, 2, 8)).setObjects(("ATM-RMON-MIB", "atmRmonDataCollectMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    atmConfigGroup = atmConfigGroup.setStatus('current')
if mibBuilder.loadTexts: atmConfigGroup.setDescription('Configuration extentions used to control internal agent behavior.')
mibBuilder.exportSymbols("ATM-RMON-MIB", atmHostAddress=atmHostAddress, ConnectTime=ConnectTime, atmStatsCellsRollovers=atmStatsCellsRollovers, atmHostOutConnTime=atmHostOutConnTime, ServiceClass=ServiceClass, atmMatrixTopNControlSClass=atmMatrixTopNControlSClass, atmMatrixTopNControlIndex=atmMatrixTopNControlIndex, atmMatrixTopNSrcAddress=atmMatrixTopNSrcAddress, atmMatrixDSConnTime=atmMatrixDSConnTime, atmMatrixTopNControlDuration=atmMatrixTopNControlDuration, atmMatrixControlStatus=atmMatrixControlStatus, portSelEntry=portSelEntry, atmMatrix=atmMatrix, portSelGrpOwner=portSelGrpOwner, portSelCreateTime=portSelCreateTime, atmMatrixSDNumCallAttempts=atmMatrixSDNumCallAttempts, atmMatrixTopNEntry=atmMatrixTopNEntry, ZeroBasedCounter32=ZeroBasedCounter32, AtmAddr=AtmAddr, atmHostHCGroup=atmHostHCGroup, ResourcePriority=ResourcePriority, atmMatrixSDDstAddress=atmMatrixSDDstAddress, atmRmonMIBCompliances=atmRmonMIBCompliances, atmMatrixDSCellsRollovers=atmMatrixDSCellsRollovers, atmHostOutCells=atmHostOutCells, portSelGrpEntry=portSelGrpEntry, atmMatrixSDNumCalls=atmMatrixSDNumCalls, atmRmon=atmRmon, atmMatrixTopNRate=atmMatrixTopNRate, atmStatsNumCallAttempts=atmStatsNumCallAttempts, atmRmonDataCollectMode=atmRmonDataCollectMode, atmStatsCreateTime=atmStatsCreateTime, atmMatrixTopNControlRequestedSize=atmMatrixTopNControlRequestedSize, atmHostControlStatus=atmHostControlStatus, atmMatrixSDCreateTime=atmMatrixSDCreateTime, atmRmonMIBGroups=atmRmonMIBGroups, atmHostInCells=atmHostInCells, PYSNMP_MODULE_ID=atmRmon, atmStatsHCCells=atmStatsHCCells, atmHostInNumCalls=atmHostInNumCalls, atmMatrixSDTable=atmMatrixSDTable, atmMatrixControlInserts=atmMatrixControlInserts, atmHostControlInserts=atmHostControlInserts, atmMatrixTopNControlRateBase=atmMatrixTopNControlRateBase, atmMatrixControlDropEvents=atmMatrixControlDropEvents, atmStatsControlOwner=atmStatsControlOwner, portSelStatus=portSelStatus, atmHostInNumCallAttempts=atmHostInNumCallAttempts, atmStatsTable=atmStatsTable, atmMatrixDSSrcAddress=atmMatrixDSSrcAddress, atmMatrixDSCreateTime=atmMatrixDSCreateTime, atmStatsNumCalls=atmStatsNumCalls, atmHostEntry=atmHostEntry, portSelCollectGroup=portSelCollectGroup, atmHostControlAddrCollectScope=atmHostControlAddrCollectScope, atmMatrixTopNControlStartTime=atmMatrixTopNControlStartTime, atmMatrixSDEntry=atmMatrixSDEntry, atmMatrixGroup=atmMatrixGroup, atmStatsControlDropEvents=atmStatsControlDropEvents, atmStatsConnTime=atmStatsConnTime, atmMatrixDSCells=atmMatrixDSCells, atmHostCreateTime=atmHostCreateTime, atmHostInHCCells=atmHostInHCCells, atmMatrixTopNReverseRate=atmMatrixTopNReverseRate, atmMatrixControlAddrCollectScope=atmMatrixControlAddrCollectScope, atmHostControlMaxDesiredEntries=atmHostControlMaxDesiredEntries, atmHostOutCellsRollovers=atmHostOutCellsRollovers, atmHostGroup=atmHostGroup, atmMatrixSDCellsRollovers=atmMatrixSDCellsRollovers, atmMatrixTopNControlOwner=atmMatrixTopNControlOwner, atmMatrixSDSClass=atmMatrixSDSClass, atmStatsHCGroup=atmStatsHCGroup, atmStatsControlTable=atmStatsControlTable, AddressCollectScope=AddressCollectScope, atmRmonConformance=atmRmonConformance, atmHostControlDropEvents=atmHostControlDropEvents, atmMatrixDSSClass=atmMatrixDSSClass, atmRmonMIBObjects=atmRmonMIBObjects, atmConfig=atmConfig, atmMatrixDSNumCallAttempts=atmMatrixDSNumCallAttempts, atmHostTable=atmHostTable, portSelOwner=portSelOwner, atmMatrixControlPriority=atmMatrixControlPriority, atmHostSClass=atmHostSClass, atmMatrixControlMaxDesiredEntries=atmMatrixControlMaxDesiredEntries, atmMatrixTopNControlTable=atmMatrixTopNControlTable, portSelTable=portSelTable, LastCreateTime=LastCreateTime, atmHostControlTable=atmHostControlTable, atmMatrixControlTable=atmMatrixControlTable, atmMatrixControlEntry=atmMatrixControlEntry, atmMatrixDSEntry=atmMatrixDSEntry, atmMatrixTopNIndex=atmMatrixTopNIndex, atmRmonMIBCompliance=atmRmonMIBCompliance, atmStatsEntry=atmStatsEntry, atmMatrixTopNTable=atmMatrixTopNTable, atmStatsControlStatus=atmStatsControlStatus, atmMatrixTopNDstAddress=atmMatrixTopNDstAddress, atmHostOutNumCalls=atmHostOutNumCalls, atmHostInConnTime=atmHostInConnTime, atmHostOutNumCallAttempts=atmHostOutNumCallAttempts, atmMatrixSDSrcAddress=atmMatrixSDSrcAddress, atmMatrixTopNControlStatus=atmMatrixTopNControlStatus, atmHostControlEntry=atmHostControlEntry, atmMatrixDSNumCalls=atmMatrixDSNumCalls, atmMatrixTopNControlGeneratedReports=atmMatrixTopNControlGeneratedReports, portSelGrpStatus=portSelGrpStatus, atmHostControlPriority=atmHostControlPriority, atmStatsSClass=atmStatsSClass, atmStatsControlEntry=atmStatsControlEntry, atmMatrixHCGroup=atmMatrixHCGroup, portSelGrpDescr=portSelGrpDescr, atmMatrixTopNControlGrantedSize=atmMatrixTopNControlGrantedSize, atmStatsGroup=atmStatsGroup, atmMatrixDSHCCells=atmMatrixDSHCCells, portSelGrpCreateTime=portSelGrpCreateTime, atmHostOutHCCells=atmHostOutHCCells, atmHostInCellsRollovers=atmHostInCellsRollovers, atmMatrixDSTable=atmMatrixDSTable, atmMatrixDSDstAddress=atmMatrixDSDstAddress, atmHost=atmHost, atmStatsCells=atmStatsCells, portSelectGroup=portSelectGroup, atmMatrixControlDeletes=atmMatrixControlDeletes, atmMatrixSDCells=atmMatrixSDCells, portSelGrpTable=portSelGrpTable, portSelGrpIndex=portSelGrpIndex, atmMatrixControlOwner=atmMatrixControlOwner, atmHostControlDeletes=atmHostControlDeletes, portSelect=portSelect, atmStats=atmStats, atmMatrixSDConnTime=atmMatrixSDConnTime, atmRmonNotifications=atmRmonNotifications, atmMatrixTopNControlTimeRemaining=atmMatrixTopNControlTimeRemaining, atmConfigGroup=atmConfigGroup, atmHostControlOwner=atmHostControlOwner, atmMatrixSDHCCells=atmMatrixSDHCCells, atmMatrixTopNControlEntry=atmMatrixTopNControlEntry)

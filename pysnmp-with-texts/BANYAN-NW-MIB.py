#
# PySNMP MIB module BANYAN-NW-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BANYAN-NW-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:33:30 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, Counter64, Counter32, NotificationType, enterprises, Unsigned32, TimeTicks, ObjectIdentity, iso, Integer32, MibIdentifier, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, ModuleIdentity, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Counter64", "Counter32", "NotificationType", "enterprises", "Unsigned32", "TimeTicks", "ObjectIdentity", "iso", "Integer32", "MibIdentifier", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "ModuleIdentity", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
banyan = MibIdentifier((1, 3, 6, 1, 4, 1, 130))
others = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 2))
netware = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 2, 1))
nwmib1 = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 2, 1, 1))
nwfsinfo = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1))
nwperipherals = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2))
nwinterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3))
nwprotocols = MibIdentifier((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4))
nwName = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwName.setStatus('mandatory')
if mibBuilder.loadTexts: nwName.setDescription('The name of the NetWare file server.')
nwCompany = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwCompany.setStatus('mandatory')
if mibBuilder.loadTexts: nwCompany.setDescription('The company name.')
nwRev = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwRev.setStatus('mandatory')
if mibBuilder.loadTexts: nwRev.setDescription('The NetWare software revision for this server.')
nwRevDate = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwRevDate.setStatus('mandatory')
if mibBuilder.loadTexts: nwRevDate.setDescription('The release date of the NetWare software revision.')
nwCopyRight = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwCopyRight.setStatus('mandatory')
if mibBuilder.loadTexts: nwCopyRight.setDescription('The copyright for NetWare software.')
nwConnsSupp = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwConnsSupp.setStatus('mandatory')
if mibBuilder.loadTexts: nwConnsSupp.setDescription('The number of connections supported.')
nwConnsInUse = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwConnsInUse.setStatus('mandatory')
if mibBuilder.loadTexts: nwConnsInUse.setDescription('The current number of connections in use.')
nwPeakConnectionsUsed = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwPeakConnectionsUsed.setStatus('mandatory')
if mibBuilder.loadTexts: nwPeakConnectionsUsed.setDescription('The highest number of connections used since server came up.')
nwMaxVolsSupp = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwMaxVolsSupp.setStatus('mandatory')
if mibBuilder.loadTexts: nwMaxVolsSupp.setDescription('Maximum number of volumes supported.')
nwRevArray = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 1, 10), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwRevArray.setStatus('mandatory')
if mibBuilder.loadTexts: nwRevArray.setDescription('The Revision of the NetWare software displayed in hex.')
nwVolNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolNumber.setDescription('The number of volumes.')
nwVolTable = MibTable((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2), )
if mibBuilder.loadTexts: nwVolTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolTable.setDescription('The Table containing entries for each volume.')
nwVolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1), ).setIndexNames((0, "BANYAN-NW-MIB", "nwVolIndex"))
if mibBuilder.loadTexts: nwVolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolEntry.setDescription('Entry into the volume table.')
nwVolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolIndex.setDescription('A unique value for each volume on the server, used to order the list.')
nwVolName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolName.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolName.setDescription('A string containing the name of the volume.')
nwVolDrive = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolDrive.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolDrive.setDescription('The logical drive number.')
nwVolSectorsPerBlk = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolSectorsPerBlk.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolSectorsPerBlk.setDescription('The number of sectors per block. This is the number of 512-byte sectors contained in each block of the volume.')
nwVolStartBlk = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolStartBlk.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolStartBlk.setDescription('The first block available for you to use for data.')
nwVolTotalBlks = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolTotalBlks.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolTotalBlks.setDescription('The total number of blocks for this volume.')
nwVolAvailBlks = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolAvailBlks.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolAvailBlks.setDescription('The number of available blocks for this volume.')
nwVolTotalDirSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolTotalDirSlots.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolTotalDirSlots.setDescription('The total number of directory slots for this volume.')
nwVolAvailDirSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolAvailDirSlots.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolAvailDirSlots.setDescription('The number of currently available directory slots for this volume.')
nwVolMaxDirSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolMaxDirSlots.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolMaxDirSlots.setDescription('The peak number of directory slots for this volume.')
nwVolHashing = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolHashing.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolHashing.setDescription('The flag to indicate whether hashing is in use.')
nwVolRemovable = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolRemovable.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolRemovable.setDescription('The flag to indicate if the media is removable.')
nwVolMounted = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolMounted.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolMounted.setDescription('The flag to indicate if the volume is mounted.')
nwVolPurgeBlks = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolPurgeBlks.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolPurgeBlks.setDescription('The number of blocks waiting to be purged.')
nwVolNotPurgeBlks = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwVolNotPurgeBlks.setStatus('mandatory')
if mibBuilder.loadTexts: nwVolNotPurgeBlks.setDescription('The number of blocks which cannot be purged.')
nwIfNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfNumber.setDescription('The number of interfaces for this NetWare file server.')
nwIfCfgTable = MibTable((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2), )
if mibBuilder.loadTexts: nwIfCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgTable.setDescription('The Table containing entries for interface configuration information.')
nwIfCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1), ).setIndexNames((0, "BANYAN-NW-MIB", "nwIfCfgBoardNo"))
if mibBuilder.loadTexts: nwIfCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgEntry.setDescription('Entry into the interface configuration table.')
nwIfCfgSignature = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 1), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgSignature.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgSignature.setDescription("The string 'HardwareDriverMLID' followed by 8 spaces is the first entry in the configuration table.")
nwIfCfgMajVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMajVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMajVer.setDescription('The current major version number of the configuration table structure.')
nwIfCfgMinVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMinVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMinVer.setDescription('The current minor version number of the configuration table structure.(0..99 decimal).')
nwIfCfgNodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgNodeAddress.setDescription("The node address of the LAN board. An MLID can call ParseDriverParameters to prompt a console operator to configure this address at the command line. Otherwise the MLID can read the hardware to determine a board's node address.")
nwIfCfgModeFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgModeFlags.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgModeFlags.setDescription('The mode flags with bit map as follows: bit 0 - set to 1. It indicates if a real driver. bit 1 - set driver uses DMA, bit 2 - reserved for NetWare; must be 0. bit 3 - set if driver supports multicasting, bit 4 - set to 0. bit 5 - set to 0. bit 6 - set if driver supports raw sends. bit 7 - set to 0. Unused bits are reserved and should always be set to 0.')
nwIfCfgBoardNo = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgBoardNo.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgBoardNo.setDescription('A unique value for each board in the configuration table used by SNMP to order the list. This corresponds to the logical board number (1- 63) assigned to this LAN board by the Link Support Layer (LSL).')
nwIfCfgBoardInst = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgBoardInst.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgBoardInst.setDescription('The (physical) board instance. The number of the physical card that the logical board is using. If your driver is driving one physical card, all the logical boards using this card would put a value 1 in this field. If you load a second physical card, the value 2 would be the board instance.')
nwIfCfgMaxDataSz = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMaxDataSz.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMaxDataSz.setDescription('The largest possible packet size (in bytes) that can be transmitted and/or received by the LAN board.')
nwIfCfgMaxRcvSz = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMaxRcvSz.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMaxRcvSz.setDescription('The maximum size (or best receive size) a packet could be.')
nwIfCfgRcvSz = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgRcvSz.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgRcvSz.setDescription('The maximum size a protocol stack can send or receive using this board.')
nwIfCfgCardName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 11), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgCardName.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgCardName.setDescription('A string containing a name which uniquely identifies the interface card hardware.')
nwIfCfgShortName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 12), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgShortName.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgShortName.setDescription('A string describing the LAN board in 8 characters or less.')
nwIfCfgMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 13), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMediaType.setDescription("A string describing the MLID's frame type. Examples include `ETHERNET_802.3` and `ETHERNET_II`.")
nwIfCfgCardId = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgCardId.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgCardId.setDescription('A reserved field. The Independent Manufacture Support Program (IMSP) assigns a number to each make of LAN board and/or drver if the table version is 1.0. This field is reserved if the table version is 1.1.')
nwIfCfgMediaId = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMediaId.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMediaId.setDescription('This number identifies the link-level envelope used by the MLID. The ID is associated with a FrameType (nwIfCfgMediaType) string and is assigned with the string. A few examples: MediaId FrameTypeString 01 - LocalTalk 02 - Ethernet_II 03 - Ethernet_802.2 04 - TokenRing 05 - 802.3 For more information contact Novell.')
nwIfCfgTransportTM = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgTransportTM.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgTransportTM.setDescription('The time (in ticks) it takes the LAN board to transmit a 576 byte packet. This field cannot be 0. Most MLIDs will set this to a value of 1.')
nwIfCfgMlidMajVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMlidMajVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMlidMajVer.setDescription('The current revision level of the MLID. It should match the revision level displayed by the MLID.')
nwIfCfgMlidMinVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMlidMinVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMlidMinVer.setDescription('The current minor version number of the MLID.')
nwIfCfgFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgFlags.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgFlags.setDescription('The bus types of physical cards that the MLID supports. Unused bits must be set to 0. EISA 0001h; set if supports EISA type physical card ISA 0002h; set if supports PC/AT type physical card MCA 0004h; set if supports Micro Channel type physical card. Bits 3 - 7 are set to 0.')
nwIfCfgSendRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgSendRetries.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgSendRetries.setDescription('Number of times the MLID should retry send events before aborting the send.')
nwIfCfgShareFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgShareFlags.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgShareFlags.setDescription("Bits which inform the system which hardware resources a driver/physical card can share with other driver/physical cards. bit 0 set if LAN board is currently shutdown; bit 1 set if LAN board can share I/O port #1; bit 2 set if LAN board can share I/O port #2; bit 3 set if LAN board can share memory range #1; bit 4 set if LAN board can share memory range #2; bit 5 set if LAN board can share interrupt #1; bit 6 set if LAN board can share interrupt #2; bit 7 set if LAN board can share DMA channel #1; bit 8 set if LAN board can share DMA channel #2; bit 9 set if driver has its own command line info to put in the AUTOEXEC.NCF file. bit 10 set if driver doesn't want any of default info put in the AUTOEXEC.NCF file. bits 11-15 - set to 0.")
nwIfCfgSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgSlot.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgSlot.setDescription('If a LAN board is running in Micro Channel or EISA machine, this field holds the slot number where the board is installed. If not used, it should be set to 0.')
nwIfCfgIoAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgIoAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgIoAddr1.setDescription('The primary I/O address for the interface card. If not used, it should be set to 0.')
nwIfCfgIoRange1 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgIoRange1.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgIoRange1.setDescription('The number of I/O ports used at IOAddr1. If not used, it should be set to 0.')
nwIfCfgIoAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgIoAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgIoAddr2.setDescription('The secondary I/O address for the interface card. If not used, it should be set to 0.')
nwIfCfgIoRange2 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgIoRange2.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgIoRange2.setDescription('The number of I/O ports used at IOAddr2. If not used, it should be set to 0.')
nwIfCfgMemAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMemAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMemAddr1.setDescription('The absolute primary memory address used by the LAN board. If not used, this is set to 0.')
nwIfCfgMemSize1 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMemSize1.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMemSize1.setDescription('The number of paragraphs (16 bytes) the LAN board uses, starting at nwIfCfgMemAddr1. If not used, it is set to 0.')
nwIfCfgMemAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMemAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMemAddr2.setDescription('The absolute secondary memory address used by the LAN board. If not used, this is set to 0.')
nwIfCfgMemSize2 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgMemSize2.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgMemSize2.setDescription('The number of paragraphs (16 bytes) the LAN board uses, starting at nwIfCfgMemAddr2. If not used, it is set to 0.')
nwIfCfgInt1 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgInt1.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgInt1.setDescription('The primary interrupt vector number. FFh = not used.')
nwIfCfgInt2 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgInt2.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgInt2.setDescription('The secondary interrupt vector number. FFh = not used.')
nwIfCfgDma1 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgDma1.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgDma1.setDescription('The primary DMA channel used by the LAN board. FFh = not used.')
nwIfCfgDma2 = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 2, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCfgDma2.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCfgDma2.setDescription('The secondary DMA channel used by the LAN board. FFh = not used.')
nwIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3), )
if mibBuilder.loadTexts: nwIfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsTable.setDescription('The Table containing MLID module statistics.')
nwIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1), ).setIndexNames((0, "BANYAN-NW-MIB", "nwIfStatsBoardNo"))
if mibBuilder.loadTexts: nwIfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsEntry.setDescription('The entry in the table containing MLID module statistics.')
nwIfStatsMajVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsMajVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsMajVer.setDescription('The current major version number of the generic portion of the statistics table. The current major version number is 2 for a Netware v3.1x Server. The number is defined by Novell.')
nwIfStatsMinVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsMinVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsMinVer.setDescription('The current minor version number of the generic portion of the statistics table. The current minor version number is 0 for a Netware v3.1x Server. The number is defined by Novell.')
nwIfStatsValidMask = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsValidMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsValidMask.setDescription('The bit mask indicating which counters are valid. The first 13 bits (starting with most significant bit) represent fields in this statistics table. The value 0 indicates it is supported, the value 1 indicates it is not supported. The bit/counter correlations are determined by shifting left, as you move down the counters in the table.')
nwIfStatsTotalTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsTotalTxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsTotalTxPkts.setDescription('The total number of packets transmitted by this LAN board.')
nwIfStatsTotalRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsTotalRxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsTotalRxPkts.setDescription('Total number of incoming packets received by this LAN board.')
nwIfStatsNoAvailEcbs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsNoAvailEcbs.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsNoAvailEcbs.setDescription('Number of incoming packets that were lost because of unavailable ECBs.')
nwIfStatsTxTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsTxTooBigs.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsTxTooBigs.setDescription('Number of times the send packet was too big for this LAN board to send.')
nwIfStatsTxTooSmalls = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsTxTooSmalls.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsTxTooSmalls.setDescription('Number of times the send packet was too small for this LAN board to send.')
nwIfStatsRxOverFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsRxOverFlows.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsRxOverFlows.setDescription("Number of times the LAN board's receive buffers overflowed.")
nwIfStatsRxTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsRxTooBigs.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsRxTooBigs.setDescription('Number of times the LAN board could not receive a packet because the packet was too big.')
nwIfStatsRxTooSmalls = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsRxTooSmalls.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsRxTooSmalls.setDescription('Number of times the LAN board could not receive a packet because the packet was too small.')
nwIfStatsTxMiscErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsTxMiscErrs.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsTxMiscErrs.setDescription('The number of transmit errors for the LAN board. This is MLID dependent.')
nwIfStatsRxMiscErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsRxMiscErrs.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsRxMiscErrs.setDescription('The number of receive errors for the LAN board. This is MLID dependent.')
nwIfStatsTxRetrys = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsTxRetrys.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsTxRetrys.setDescription('Number of times the LAN board retried a transmit because of a failure.')
nwIfStatsRxChkSumErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsRxChkSumErrs.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsRxChkSumErrs.setDescription('Number of times a checksum error occured for this LAN board.')
nwIfStatsRxMismatchs = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsRxMismatchs.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsRxMismatchs.setDescription('This is LAN medium-specific.')
nwIfStatsBoardNo = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsBoardNo.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsBoardNo.setDescription('A unique value for each board configured, used by SNMP to order the list of interface statistics. This corresponds to the the logical board number (1 - 63) assigned to this LAN board by the Link Support Layer (LSL).')
nwIfStatsCustom = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 3, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfStatsCustom.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfStatsCustom.setDescription('The total number of custom variables which follow this word.')
nwIfCustomStatsTable = MibTable((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 4), )
if mibBuilder.loadTexts: nwIfCustomStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCustomStatsTable.setDescription('The Table containing custom variables. These are custom counters.')
nwIfCustomStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 4, 1), ).setIndexNames((0, "BANYAN-NW-MIB", "nwIfCustomStatsBoardNo"), (0, "BANYAN-NW-MIB", "nwIfCustomStatsIndex"))
if mibBuilder.loadTexts: nwIfCustomStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCustomStatsEntry.setDescription('The entry in the table containing custom variables indexed by the board number and index of the custom variables.')
nwIfCustomStatsBoardNo = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCustomStatsBoardNo.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCustomStatsBoardNo.setDescription('A unique value for each board configured, used by SNMP to order the list of custom statistics. This corresponds to the the logical board number (1 - 63) assigned to this LAN board by the Link Support Layer (LSL).')
nwIfCustomStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCustomStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCustomStatsIndex.setDescription('A unique value for each custom variable in the table. (There are a total of nwIfCustom variables).')
nwIfCustomStatsDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCustomStatsDescr.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCustomStatsDescr.setDescription('A descriptive text string for the custom variable/counter.')
nwIfCustomStatsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 3, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwIfCustomStatsValue.setStatus('mandatory')
if mibBuilder.loadTexts: nwIfCustomStatsValue.setDescription('The value associated with the custom variable/counter.')
nwProtNumber = MibScalar((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtNumber.setDescription('The number of protocols supported by this server.')
nwProtCfgTable = MibTable((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2), )
if mibBuilder.loadTexts: nwProtCfgTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgTable.setDescription('The Table containing protocol configuration information.')
nwProtCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1), ).setIndexNames((0, "BANYAN-NW-MIB", "nwProtCfgProtNo"))
if mibBuilder.loadTexts: nwProtCfgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgEntry.setDescription('The entry in the protocol configuration table.')
nwProtCfgProtNo = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCfgProtNo.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgProtNo.setDescription('A unique value for each protocol configured, used by SNMP to order the list. ')
nwProtCfgMajVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCfgMajVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgMajVer.setDescription('The major version number of the configuration table.')
nwProtCfgMinVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCfgMinVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgMinVer.setDescription('The minor version number of the configuration table.')
nwProtCfgName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCfgName.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgName.setDescription('A string used to register the protocol stack with the Link Support Lanyer (LSL). This string cannot have more than 15 characters (not including the length byte or zero terminator) and cannot be 0.')
nwProtCfgRegName = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCfgRegName.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgRegName.setDescription('A string containing the name of the protocol stack. It is a length-preceded, zero-terminated string.')
nwProtCfgStkMajVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCfgStkMajVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgStkMajVer.setDescription('The major version number of the protocol stack. The number in this field is a decimal number.')
nwProtCfgStkMinVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCfgStkMinVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCfgStkMinVer.setDescription('The minor version number of the protocol stack. The number in this field is a decimal number.')
nwProtStatsTable = MibTable((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3), )
if mibBuilder.loadTexts: nwProtStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsTable.setDescription('The table containing protocol statistics information.')
nwProtStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1), ).setIndexNames((0, "BANYAN-NW-MIB", "nwProtStatsProtNo"))
if mibBuilder.loadTexts: nwProtStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsEntry.setDescription('The entry in the protocol statistics table indexed by the protocol statistics number.')
nwProtStatsProtNo = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsProtNo.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsProtNo.setDescription('A unique value for each protocol supported on the server, used by SNMP to order the list.')
nwProtStatsMajVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsMajVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsMajVer.setDescription('The major version number of the protocol stack statistics table.')
nwProtStatsMinVer = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsMinVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsMinVer.setDescription('The minor version number of the protocol stack statistics table.')
nwProtStatsValidMask = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsValidMask.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsValidMask.setDescription('A bit mask indicating which counters are used. The value 0 indicates Yes; the value 1 indicates No. The bit/counter correlations are determine by shifting left, as you move down the counters in the table.')
nwProtStatsTotalTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsTotalTxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsTotalTxPkts.setDescription('The total number of packets that were requested to be transmitted (whether they were actually transmitted or not).')
nwProtStatsTotalRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsTotalRxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsTotalRxPkts.setDescription('The total number of incoming packets that were received.')
nwProtStatsIgnoredRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsIgnoredRxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsIgnoredRxPkts.setDescription('The total number of incoming packets that were ignored by the stack.')
nwProtStatsCustom = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtStatsCustom.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtStatsCustom.setDescription('The total number of custom counters following this field.')
nwProtCustomStatsTable = MibTable((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 4), )
if mibBuilder.loadTexts: nwProtCustomStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCustomStatsTable.setDescription('The table of custom statistics for the protocol.')
nwProtCustomStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 4, 1), ).setIndexNames((0, "BANYAN-NW-MIB", "nwProtCustomStatsProtNo"), (0, "BANYAN-NW-MIB", "nwProtCustomStatsIndex"))
if mibBuilder.loadTexts: nwProtCustomStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCustomStatsEntry.setDescription('The entry in table of custom statistics indexed by the protocol number and the index. ')
nwProtCustomStatsProtNo = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCustomStatsProtNo.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCustomStatsProtNo.setDescription('A unique value for each protocol supported, used by SNMP to order the list.')
nwProtCustomStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCustomStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCustomStatsIndex.setDescription('A unique value for each statistic in the custom statistics table.')
nwProtCustomStatsDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 4, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCustomStatsDescr.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCustomStatsDescr.setDescription('A string describing for the custom statistic.')
nwProtCustomStatsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 130, 2, 1, 1, 4, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwProtCustomStatsValue.setStatus('mandatory')
if mibBuilder.loadTexts: nwProtCustomStatsValue.setDescription('The value of the custom statistic.')
mibBuilder.exportSymbols("BANYAN-NW-MIB", nwinterfaces=nwinterfaces, nwProtStatsTotalRxPkts=nwProtStatsTotalRxPkts, nwIfCfgShareFlags=nwIfCfgShareFlags, nwConnsSupp=nwConnsSupp, nwProtStatsCustom=nwProtStatsCustom, nwIfStatsTotalRxPkts=nwIfStatsTotalRxPkts, nwIfStatsTable=nwIfStatsTable, nwIfCfgDma1=nwIfCfgDma1, nwIfCustomStatsTable=nwIfCustomStatsTable, nwIfCfgMemAddr1=nwIfCfgMemAddr1, banyan=banyan, nwIfCustomStatsBoardNo=nwIfCustomStatsBoardNo, nwProtCustomStatsEntry=nwProtCustomStatsEntry, nwIfStatsRxTooSmalls=nwIfStatsRxTooSmalls, nwIfStatsMinVer=nwIfStatsMinVer, nwIfCfgModeFlags=nwIfCfgModeFlags, nwVolEntry=nwVolEntry, nwCompany=nwCompany, nwVolName=nwVolName, nwProtStatsTable=nwProtStatsTable, nwVolIndex=nwVolIndex, nwVolNumber=nwVolNumber, nwIfCfgIoRange1=nwIfCfgIoRange1, nwMaxVolsSupp=nwMaxVolsSupp, nwIfStatsRxChkSumErrs=nwIfStatsRxChkSumErrs, nwIfStatsTotalTxPkts=nwIfStatsTotalTxPkts, nwIfStatsCustom=nwIfStatsCustom, nwfsinfo=nwfsinfo, nwProtStatsTotalTxPkts=nwProtStatsTotalTxPkts, nwIfCfgNodeAddress=nwIfCfgNodeAddress, nwProtStatsMajVer=nwProtStatsMajVer, nwRevDate=nwRevDate, nwIfStatsTxMiscErrs=nwIfStatsTxMiscErrs, nwProtCfgStkMajVer=nwProtCfgStkMajVer, nwIfCustomStatsValue=nwIfCustomStatsValue, nwProtCfgStkMinVer=nwProtCfgStkMinVer, nwIfStatsValidMask=nwIfStatsValidMask, nwIfCfgMediaType=nwIfCfgMediaType, nwIfCfgTable=nwIfCfgTable, nwVolAvailBlks=nwVolAvailBlks, nwIfCfgIoRange2=nwIfCfgIoRange2, nwProtStatsProtNo=nwProtStatsProtNo, nwperipherals=nwperipherals, nwIfNumber=nwIfNumber, nwIfCfgCardId=nwIfCfgCardId, nwIfStatsNoAvailEcbs=nwIfStatsNoAvailEcbs, nwIfCfgMaxRcvSz=nwIfCfgMaxRcvSz, nwprotocols=nwprotocols, nwIfCfgMinVer=nwIfCfgMinVer, nwIfStatsRxTooBigs=nwIfStatsRxTooBigs, nwProtStatsIgnoredRxPkts=nwProtStatsIgnoredRxPkts, nwIfCustomStatsDescr=nwIfCustomStatsDescr, nwIfCustomStatsIndex=nwIfCustomStatsIndex, nwProtCfgMajVer=nwProtCfgMajVer, nwVolMaxDirSlots=nwVolMaxDirSlots, nwmib1=nwmib1, nwIfCfgFlags=nwIfCfgFlags, nwIfStatsBoardNo=nwIfStatsBoardNo, nwIfCfgMlidMajVer=nwIfCfgMlidMajVer, nwIfCfgInt2=nwIfCfgInt2, nwVolDrive=nwVolDrive, nwIfCfgMemSize1=nwIfCfgMemSize1, nwIfStatsMajVer=nwIfStatsMajVer, nwIfStatsRxOverFlows=nwIfStatsRxOverFlows, nwIfCfgRcvSz=nwIfCfgRcvSz, nwIfCfgShortName=nwIfCfgShortName, nwIfCfgDma2=nwIfCfgDma2, nwIfCfgMemAddr2=nwIfCfgMemAddr2, nwVolTotalDirSlots=nwVolTotalDirSlots, nwIfCfgSlot=nwIfCfgSlot, nwIfCfgIoAddr1=nwIfCfgIoAddr1, nwProtNumber=nwProtNumber, nwIfCfgIoAddr2=nwIfCfgIoAddr2, nwPeakConnectionsUsed=nwPeakConnectionsUsed, nwConnsInUse=nwConnsInUse, nwIfStatsTxTooSmalls=nwIfStatsTxTooSmalls, nwVolTable=nwVolTable, nwProtStatsValidMask=nwProtStatsValidMask, nwIfStatsEntry=nwIfStatsEntry, nwRev=nwRev, nwVolMounted=nwVolMounted, nwIfCustomStatsEntry=nwIfCustomStatsEntry, nwProtCfgRegName=nwProtCfgRegName, nwVolAvailDirSlots=nwVolAvailDirSlots, nwIfCfgSendRetries=nwIfCfgSendRetries, nwIfCfgMemSize2=nwIfCfgMemSize2, nwProtCustomStatsDescr=nwProtCustomStatsDescr, nwVolStartBlk=nwVolStartBlk, nwRevArray=nwRevArray, nwVolRemovable=nwVolRemovable, nwProtCfgName=nwProtCfgName, nwIfCfgCardName=nwIfCfgCardName, nwIfCfgEntry=nwIfCfgEntry, nwProtCfgTable=nwProtCfgTable, nwProtCustomStatsTable=nwProtCustomStatsTable, nwIfStatsRxMismatchs=nwIfStatsRxMismatchs, nwIfCfgMlidMinVer=nwIfCfgMlidMinVer, nwName=nwName, nwIfCfgMediaId=nwIfCfgMediaId, nwProtStatsEntry=nwProtStatsEntry, others=others, nwIfCfgBoardNo=nwIfCfgBoardNo, netware=netware, nwVolTotalBlks=nwVolTotalBlks, nwVolHashing=nwVolHashing, nwIfStatsTxRetrys=nwIfStatsTxRetrys, nwProtCustomStatsValue=nwProtCustomStatsValue, nwIfCfgInt1=nwIfCfgInt1, nwProtCustomStatsIndex=nwProtCustomStatsIndex, nwVolSectorsPerBlk=nwVolSectorsPerBlk, nwCopyRight=nwCopyRight, nwVolPurgeBlks=nwVolPurgeBlks, nwProtCfgProtNo=nwProtCfgProtNo, nwProtCfgMinVer=nwProtCfgMinVer, nwIfStatsRxMiscErrs=nwIfStatsRxMiscErrs, nwProtCfgEntry=nwProtCfgEntry, nwVolNotPurgeBlks=nwVolNotPurgeBlks, nwIfCfgSignature=nwIfCfgSignature, nwIfCfgBoardInst=nwIfCfgBoardInst, nwIfCfgMaxDataSz=nwIfCfgMaxDataSz, nwIfCfgTransportTM=nwIfCfgTransportTM, nwIfStatsTxTooBigs=nwIfStatsTxTooBigs, nwProtCustomStatsProtNo=nwProtCustomStatsProtNo, nwIfCfgMajVer=nwIfCfgMajVer, nwProtStatsMinVer=nwProtStatsMinVer)

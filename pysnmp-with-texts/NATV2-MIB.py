#
# PySNMP MIB module NATV2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NATV2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:17:05 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
InetPortNumber, InetAddressType, InetAddressPrefixLength, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddressType", "InetAddressPrefixLength", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
iso, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, MibIdentifier, IpAddress, Counter32, mib_2, NotificationType, Gauge32, Unsigned32, Integer32, ModuleIdentity, Bits, ObjectIdentity, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "MibIdentifier", "IpAddress", "Counter32", "mib-2", "NotificationType", "Gauge32", "Unsigned32", "Integer32", "ModuleIdentity", "Bits", "ObjectIdentity", "Counter64")
TextualConvention, TimeStamp, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TimeStamp", "DisplayString")
natv2MIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 234))
natv2MIB.setRevisions(('2015-10-02 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: natv2MIB.setRevisionsDescriptions(('Complete rewrite, published as RFC 7659. Replaces former version published as RFC 4008.',))
if mibBuilder.loadTexts: natv2MIB.setLastUpdated('201510020000Z')
if mibBuilder.loadTexts: natv2MIB.setOrganization('IETF Behavior Engineering for Hindrance Avoidance (BEHAVE) Working Group')
if mibBuilder.loadTexts: natv2MIB.setContactInfo('Working Group Email: behave@ietf.org Simon Perreault Jive Communications Quebec, QC Canada Email: sperreault@jive.com Tina Tsou Huawei Technologies Bantian, Longgang Shenzhen 518129 China Email: tina.tsou.zouting@huawei.com Senthil Sivakumar Cisco Systems 7100-8 Kit Creek Road Research Triangle Park, North Carolina 27709 United States Phone: +1 919 392 5158 Email: ssenthil@cisco.com Tom Taylor PT Taylor Consulting Ottawa Canada Email: tom.taylor.stds@gmail.com')
if mibBuilder.loadTexts: natv2MIB.setDescription("This MIB module defines the generic managed objects for NAT. Copyright (c) 2015 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). This version of this MIB module is part of RFC 7659; see the RFC itself for full legal notices.")
class ProtocolNumber(TextualConvention, Unsigned32):
    reference = 'IANA Protocol Numbers, <http://www.iana.org/assignments/protocol-numbers>'
    description = 'A protocol number, from the IANA Protocol Numbers registry.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class Natv2SubscriberIndex(TextualConvention, Unsigned32):
    description = "A unique value, greater than zero, for each subscriber in the managed system. The value for each subscriber MUST remain constant at least from one update of the entity's natv2SubscriberDiscontinuityTime object until the next update of that object. If a subscriber is deleted, its assigned index value MUST NOT be assigned to another subscriber at least until reinitialization of the entity's management system."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class Natv2SubscriberIndexOrZero(TextualConvention, Unsigned32):
    description = 'This textual convention is an extension of the Natv2SubscriberIndex convention. The latter defines a greater than zero value used to identify a subscriber in the managed system. This extension permits the additional value of zero, which serves as a placeholder when no subscriber is associated with the object.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), )
class Natv2InstanceIndex(TextualConvention, Unsigned32):
    description = "A unique value, greater than zero, for each NAT instance in the managed system. It is RECOMMENDED that values are assigned contiguously starting from 1. The value for each NAT instance MUST remain constant at least from one update of the entity's natv2InstanceDiscontinuityTime object until the next update of that object. If a NAT instance is deleted, its assigned index value MUST NOT be assigned to another NAT instance at least until reinitialization of the entity's management system."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class Natv2PoolIndex(TextualConvention, Unsigned32):
    description = "A unique value over the containing NAT instance, greater than zero, for each address pool supported by that NAT instance. It is RECOMMENDED that values are assigned contiguously starting from 1. The value for each address pool MUST remain constant at least from one update of the entity's natv2PoolDiscontinuityTime object until the next update of that object. If an address pool is deleted, its assigned index value MUST NOT be assigned to another address pool for the same NAT instance at least until reinitialization of the entity's management system."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

class Natv2PoolIndexOrZero(TextualConvention, Unsigned32):
    description = 'This textual convention is an extension of the Natv2PoolIndex convention. The latter defines a greater than zero value used to identify address pools in the managed system. This extension permits the additional value of zero, which serves as a placeholder when the implementation does not support address pools or no address pool is configured in a given external realm.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4294967295), )
natv2MIBNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 234, 0))
natv2NotificationPoolUsageLow = NotificationType((1, 3, 6, 1, 2, 1, 234, 0, 1)).setObjects(("NATV2-MIB", "natv2PoolNotifiedPortMapEntries"), ("NATV2-MIB", "natv2PoolNotifiedPortMapProtocol"))
if mibBuilder.loadTexts: natv2NotificationPoolUsageLow.setStatus('current')
if mibBuilder.loadTexts: natv2NotificationPoolUsageLow.setDescription("This notification is triggered when an address pool's usage becomes less than or equal to the value of the natv2PoolThresholdUsageLow object for that pool, unless the notification has been disabled by setting the value of the threshold to -1. It is reported subject to the rate limitation specified by natv2PortMapNotificationInterval. Address pool usage is calculated as the percentage of the total number of ports allocated to the address pool that are already in use, for the most-mapped protocol at the time the notification is triggered. The two returned objects are members of natv2PoolTable indexed by the NAT instance and pool indices for which the event is being reported. They give the number of port map entries using external addresses configured on the pool for the most-mapped protocol and identify that protocol at the time the notification was triggered.")
if mibBuilder.loadTexts: natv2NotificationPoolUsageLow.setReference('RFC 7659, Sections 3.1.2 and 3.3.6.')
natv2NotificationPoolUsageHigh = NotificationType((1, 3, 6, 1, 2, 1, 234, 0, 2)).setObjects(("NATV2-MIB", "natv2PoolNotifiedPortMapEntries"), ("NATV2-MIB", "natv2PoolNotifiedPortMapProtocol"))
if mibBuilder.loadTexts: natv2NotificationPoolUsageHigh.setStatus('current')
if mibBuilder.loadTexts: natv2NotificationPoolUsageHigh.setDescription("This notification is triggered when an address pool's usage becomes greater than or equal to the value of the natv2PoolThresholdUsageHigh object for that pool, unless the notification has been disabled by setting the value of the threshold to -1. It is reported subject to the rate limitation specified by natv2PortMapNotificationInterval. Address pool usage is calculated as the percentage of the total number of ports allocated to the address pool that are already in use, for the most-mapped protocol at the time the notification is triggered. The two returned objects are members of natv2PoolTable indexed by the NAT instance and pool indices for which the event is being reported. They give the number of port map entries using external addresses configured on the pool for the most-mapped protocol and identify that protocol at the time the notification was triggered.")
if mibBuilder.loadTexts: natv2NotificationPoolUsageHigh.setReference('RFC 7659, Sections 3.1.2 and 3.3.6.')
natv2NotificationInstanceAddressMapEntriesHigh = NotificationType((1, 3, 6, 1, 2, 1, 234, 0, 3)).setObjects(("NATV2-MIB", "natv2InstanceAddressMapEntries"), ("NATV2-MIB", "natv2InstanceAddressMapCreations"))
if mibBuilder.loadTexts: natv2NotificationInstanceAddressMapEntriesHigh.setStatus('current')
if mibBuilder.loadTexts: natv2NotificationInstanceAddressMapEntriesHigh.setDescription('This notification is triggered when the value of natv2InstanceAddressMapEntries equals or exceeds the value of the natv2InstanceThresholdAddressMapEntriesHigh object for the NAT instance, unless disabled by setting that threshold to -1. Reporting is subject to the rate limitation given by natv2InstanceNotificationInterval. natv2InstanceAddressMapEntries and natv2InstanceAddressMapCreations are members of table natv2InstanceTable indexed by the identifier of the NAT instance for which the event is being reported. The values reported are those observed at the moment the notification was triggered.')
if mibBuilder.loadTexts: natv2NotificationInstanceAddressMapEntriesHigh.setReference('RFC 7659, Section 3.1.2.')
natv2NotificationInstancePortMapEntriesHigh = NotificationType((1, 3, 6, 1, 2, 1, 234, 0, 4)).setObjects(("NATV2-MIB", "natv2InstancePortMapEntries"), ("NATV2-MIB", "natv2InstancePortMapCreations"))
if mibBuilder.loadTexts: natv2NotificationInstancePortMapEntriesHigh.setStatus('current')
if mibBuilder.loadTexts: natv2NotificationInstancePortMapEntriesHigh.setDescription('This notification is triggered when the value of natv2InstancePortMapEntries becomes greater than or equal to the value of natv2InstanceThresholdPortMapEntriesHigh, unless disabled by setting that threshold to -1. Reporting is subject to the rate limitation given by natv2InstanceNotificationInterval. natv2InstancePortMapEntries and natv2InstancePortMapCreations are members of table natv2InstanceTable indexed by the identifier of the NAT instance for which the event is being reported. The values reported are those observed at the moment the notification was triggered.')
natv2NotificationSubscriberPortMappingEntriesHigh = NotificationType((1, 3, 6, 1, 2, 1, 234, 0, 5)).setObjects(("NATV2-MIB", "natv2SubscriberPortMapEntries"), ("NATV2-MIB", "natv2SubscriberPortMapCreations"))
if mibBuilder.loadTexts: natv2NotificationSubscriberPortMappingEntriesHigh.setStatus('current')
if mibBuilder.loadTexts: natv2NotificationSubscriberPortMappingEntriesHigh.setDescription('This notification is triggered when the value of natv2SubscriberPortMapEntries for an individual subscriber becomes greater than or equal to the value of the natv2SubscriberThresholdPortMapEntriesHigh object for that subscriber, unless disabled by setting that threshold to -1. Reporting is subject to the rate limitation given by natv2SubscriberNotificationInterval. natv2SubscriberPortMapEntries and natv2SubscriberPortMapCreations are members of table natv2SubscriberTable indexed by the subscriber for which the event is being reported. The values reported are those observed at the moment the notification was triggered.')
natv2MIBDeviceObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 234, 1))
natv2SubscriberTable = MibTable((1, 3, 6, 1, 2, 1, 234, 1, 1), )
if mibBuilder.loadTexts: natv2SubscriberTable.setReference('RFC 7659, Section 3.3.3.')
if mibBuilder.loadTexts: natv2SubscriberTable.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberTable.setDescription('Table of subscribers. As well as the subscriber index, it provides per-subscriber state and counter objects, a last discontinuity time object for the counters, and a writable threshold value and limit on port consumption.')
natv2SubscriberEntry = MibTableRow((1, 3, 6, 1, 2, 1, 234, 1, 1, 1), ).setIndexNames((0, "NATV2-MIB", "natv2SubscriberIndex"))
if mibBuilder.loadTexts: natv2SubscriberEntry.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberEntry.setDescription('Each entry describes a single subscriber.')
natv2SubscriberIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 1), Natv2SubscriberIndex())
if mibBuilder.loadTexts: natv2SubscriberIndex.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberIndex.setDescription("A unique value, greater than zero, for each subscriber in the managed system. The value for each subscriber MUST remain constant at least from one update of the entity's natv2SubscriberDiscontinuityTime object until the next update of that object. If a subscriber is deleted, its assigned index value MUST NOT be assigned to another subscriber at least until reinitialization of the entity's management system.")
natv2SubscriberInternalRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone('internal')).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberInternalRealm.setReference('Address realm: RFC 2663. DS-Lite: RFC 6333.')
if mibBuilder.loadTexts: natv2SubscriberInternalRealm.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberInternalRealm.setDescription("The address realm to which this subscriber belongs. A realm defines an address space. All NATs support at least two realms. The default realm for subscribers is 'internal'. Administrators can set other values for individual subscribers when they are configured. The administrator MAY configure a new value of natv2SubscriberRealm at any time subsequent to initial configuration of the subscriber. If this happens, it MUST be treated as a point of discontinuity requiring an update of natv2SubscriberDiscontinuityTime. When the subscriber sends a packet to the NAT through a DS-Lite (RFC 6333) tunnel, this is the realm of the outer packet header source address. Other tunneled access is out of scope.")
natv2SubscriberInternalPrefixType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberInternalPrefixType.setReference('DS-Lite: RFC 6333.')
if mibBuilder.loadTexts: natv2SubscriberInternalPrefixType.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberInternalPrefixType.setDescription("Subscriber's internal prefix type. Any value other than ipv4(1) or ipv6(2) would be unexpected. In the case of DS-Lite access, this is the prefix type (IPv6(2)) used in the outer packet header.")
natv2SubscriberInternalPrefix = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberInternalPrefix.setReference('DS-Lite: RFC 6333.')
if mibBuilder.loadTexts: natv2SubscriberInternalPrefix.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberInternalPrefix.setDescription("Prefix assigned to a subscriber's Customer Premises Equipment (CPE). The type of this prefix is given by natv2SubscriberInternalPrefixType. Source addresses of packets outgoing from the subscriber will be contained within this prefix. In the case of DS-Lite access, the source address taken from the prefix will be that of the outer header.")
natv2SubscriberInternalPrefixLength = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 5), InetAddressPrefixLength()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberInternalPrefixLength.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberInternalPrefixLength.setDescription("Length of the prefix assigned to a subscriber's CPE, in bits. If a single address is assigned, this will be 32 for IPv4 and 128 for IPv6.")
natv2SubscriberAddressMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberAddressMapEntries.setReference('RFC 7659, Section 3.3.8.')
if mibBuilder.loadTexts: natv2SubscriberAddressMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberAddressMapEntries.setDescription("The current number of address map entries for the subscriber, including static mappings. An address map entry maps from a given internal address and realm to an external address in a particular external realm. This definition includes 'hairpin' mappings, where the external realm is the same as the internal one. Address map entries are also tracked per instance and per address pool within the instance.")
natv2SubscriberPortMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberPortMapEntries.setReference('RFC 7659, Section 3.3.9.')
if mibBuilder.loadTexts: natv2SubscriberPortMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberPortMapEntries.setDescription("The current number of port map entries in the port map table for the subscriber, including static mappings. A port map entry maps from a given external realm, address, and port for a given protocol to an internal realm, address, and port. This definition includes 'hairpin' mappings, where the external realm is the same as the internal one. Port map entries are also tracked per instance and per protocol and address pool within the instance.")
natv2SubscriberTranslations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 8), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberTranslations.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberTranslations.setDescription("The cumulative number of translated packets received from or sent to this subscriber. This value MUST be monotone increasing in the periods between updates of the entity's natv2SubscriberDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2SubscriberDiscontinuityTime.")
natv2SubscriberAddressMapCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberAddressMapCreations.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberAddressMapCreations.setDescription("The cumulative number of address map entries created for this subscriber, including static mappings. Address map entries are also tracked per instance and per protocol and address pool within the instance. This value MUST be monotone increasing in the periods between updates of the entity's natv2SubscriberDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2SubscriberDiscontinuityTime.")
natv2SubscriberPortMapCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberPortMapCreations.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberPortMapCreations.setDescription("The cumulative number of port map entries created for this subscriber, including static mappings. Port map entries are also tracked per instance and per protocol and address pool within the instance. This value MUST be monotone increasing in the periods between updates of the entity's natv2SubscriberDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2SubscriberDiscontinuityTime.")
natv2SubscriberAddressMapFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberAddressMapFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberAddressMapFailureDrops.setDescription("The cumulative number of packets originated by this subscriber that were dropped because the packet would have triggered the creation of a new address map entry, but no address could be allocated in the selected external realm because all addresses from the selected address pool (or the whole realm, if no address pool has been configured for that realm) have already been fully allocated. This value MUST be monotone increasing in the periods between updates of the entity's natv2SubscriberDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2SubscriberDiscontinuityTime.")
natv2SubscriberPortMapFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberPortMapFailureDrops.setReference('Pooling behavior: RFC 4787, end of Section 4.1.')
if mibBuilder.loadTexts: natv2SubscriberPortMapFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberPortMapFailureDrops.setDescription("The cumulative number of packets dropped because the packet would have triggered the creation of a new port mapping, but no port could be allocated for the protocol concerned. The usual case for this will be for a NAT instance that supports address pooling and the 'Paired' pooling behavior recommended by RFC 4787, where the internal endpoint has used up all of the ports allocated to it for the address it was mapped to in the selected address pool in the external realm concerned and cannot be given more ports because - policy or implementation prevents it from having a second address in the same pool, and - policy or unavailability prevents it from acquiring more ports at its originally assigned address. If the NAT instance supports address pooling but its pooling behavior is 'Arbitrary' (meaning that the NAT instance can allocate a new port mapping for the given internal endpoint on any address in the selected address pool and is not bound to what it has already mapped for that endpoint), then this counter is incremented when all ports for the protocol concerned over the whole of the selected address pool are already in use. As a third case, if no address pools have been configured for the external realm concerned, then this counter is incremented because all ports for the protocol involved over the whole set of addresses available for that external realm are already in use. Finally, this counter is incremented if the packet would have triggered the creation of a new port mapping, but the current value of natv2SubscriberPortMapEntries equals or exceeds the value of natv2SubscriberLimitPortMapEntries for this subscriber (unless that limit is disabled). This value MUST be monotone increasing in the periods between updates of the entity's natv2SubscriberDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2SubscriberDiscontinuityTime.")
natv2SubscriberDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 14), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2SubscriberDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberDiscontinuityTime.setDescription('Snapshot of the value of the sysUpTime object at the beginning of the latest period of continuity of the statistical counters associated with this subscriber.')
natv2SubscriberLimitPortMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 15), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2SubscriberLimitPortMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberLimitPortMapEntries.setDescription('Limit on total number of port mappings active for this subscriber (natv2SubscriberPortMapEntries). Once this limit is reached, packets that might have triggered new port mappings are dropped. The number of such packets dropped is counted in natv2InstancePortMapFailureDrops. Limit is disabled if set to zero.')
natv2SubscriberThresholdPortMapEntriesHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 16), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2SubscriberThresholdPortMapEntriesHigh.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberThresholdPortMapEntriesHigh.setDescription('Notification threshold for total number of port mappings active for this subscriber. Whenever natv2SubscriberPortMapEntries is updated, if it equals or exceeds natv2SubscriberThresholdPortMapEntriesHigh, the notification natv2NotificationSubscriberPortMappingEntriesHigh is triggered, unless the notification is disabled by setting the threshold to -1. Reporting is subject to the minimum inter-notification interval given by natv2SubscriberNotificationInterval. If multiple notifications are triggered during one interval, the agent MUST report only the one containing the highest value of natv2SubscriberPortMapEntries and discard the others.')
natv2SubscriberNotificationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 1, 1, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(60)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2SubscriberNotificationInterval.setStatus('current')
if mibBuilder.loadTexts: natv2SubscriberNotificationInterval.setDescription('Minimum number of seconds between successive reporting of notifications for this subscriber. Controls the reporting of natv2NotificationSubscriberPortMappingEntriesHigh.')
natv2MIBInstanceObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 234, 2))
natv2InstanceTable = MibTable((1, 3, 6, 1, 2, 1, 234, 2, 1), )
if mibBuilder.loadTexts: natv2InstanceTable.setReference('RFC 7659, Section 3.3.4. NAT behaviors: RFC 4787 (primary, UDP); RFC 5382 (TCP); RFC 5508 (ICMP); and RFC 5597 (Datagram Congestion Control Protocol (DCCP)).')
if mibBuilder.loadTexts: natv2InstanceTable.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceTable.setDescription("Table of NAT instances. As well as state and counter objects, it provides the instance index, instance name, and the last discontinuity time object that is applicable to the counters. It also contains writable thresholds for reporting of notifications and limits on usage of resources at the level of the NAT instance. It is assumed that NAT instances can be created and deleted dynamically, but this MIB module does not provide the means to do so. For restrictions on assignment and maintenance of the NAT index instance, see the description of natv2InstanceIndex in the table below. For the requirements on maintenance of the values of the counters in this table, see the description of natv2InstanceDiscontinuityTime in this table. Each NAT instance has its own resources and behavior. The resources include memory as reflected in space for map entries, processing power as reflected in the rate of map creation and deletion, and mappable addresses in each realm that can play the role of an external realm for at least some mappings for that instance. The NAT instance table includes limits and notification thresholds that relate to memory usage for mapping at the level of the whole instance. The limit on number of subscribers with active mappings is a limit to some extent on processor usage. The mappable 'external' addresses may or may not be organized into address pools. For a definition of address pools, see the description of natv2PoolTable. If the instance does support address pools, it also has a pooling behavior. Mapping, filtering, and pooling behavior are defined in the descriptions of the natv2InstancePortMappingBehavior, natv2InstanceFilteringBehavior, and natv2InstancePoolingBehavior objects in this table. The instance also has a fragmentation behavior, defined in the description of the natv2InstanceFragmentBehavior object.")
natv2InstanceEntry = MibTableRow((1, 3, 6, 1, 2, 1, 234, 2, 1, 1), ).setIndexNames((0, "NATV2-MIB", "natv2InstanceIndex"))
if mibBuilder.loadTexts: natv2InstanceEntry.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceEntry.setDescription('Objects related to a single NAT instance.')
natv2InstanceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 1), Natv2InstanceIndex())
if mibBuilder.loadTexts: natv2InstanceIndex.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceIndex.setDescription('NAT instance index. It is up to the implementation to determine which values correspond to in-service NAT instances. This object is used as an index for all tables defined below.')
natv2InstanceAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceAlias.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceAlias.setDescription("This object is an 'alias' name for the NAT instance as specified by a network manager and provides a non-volatile 'handle' for the instance. An example of the value that a network manager might store in this object for a NAT instance is the name/identifier of the interface that brings in internal traffic for this NAT instance or the name of the Virtual Routing and Forwarding (VRF) for internal traffic.")
natv2InstancePortMappingBehavior = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("endpointIndependent", 0), ("addressDependent", 1), ("addressAndPortDependent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstancePortMappingBehavior.setReference('RFC 4787, Section 4.1.')
if mibBuilder.loadTexts: natv2InstancePortMappingBehavior.setStatus('current')
if mibBuilder.loadTexts: natv2InstancePortMappingBehavior.setDescription('Port mapping behavior is the policy governing the selection of external address and port in a given realm for a given five-tuple of source address and port, destination address and port, and protocol. endpointIndependent(0), the behavior REQUIRED by RFC 4787, REQ-1, maps the source address and port to the same external address and port for all destination address and port combinations reached through the same external realm and using the given protocol. addressDependent(1) maps to the same external address and port for all destination ports at the same destination address reached through the same external realm and using the given protocol. addressAndPortDependent(2) maps to a separate external address and port combination for each different destination address and port combination reached through the same external realm.')
natv2InstanceFilteringBehavior = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("endpointIndependent", 0), ("addressDependent", 1), ("addressAndPortDependent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceFilteringBehavior.setReference('RFC 4787, Section 5.')
if mibBuilder.loadTexts: natv2InstanceFilteringBehavior.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceFilteringBehavior.setDescription('Filtering behavior is the policy governing acceptance or the dropping of packets incoming from remote sources via a given external realm and destined to a specific three-tuple of external address, port, and protocol at the NAT instance that has been assigned in a port mapping. endpointIndependent(0) accepts for translation packets from all combinations of remote address and port destined to the mapped external address and port via the given external realm and using the given protocol. addressDependent(1) accepts for translation packets from all remote ports from the same remote source address destined to the mapped external address and port via the given external realm and using the given protocol. addressAndPortDependent(2) accepts for translation only those packets with the same remote source address, port, and protocol incoming from the same external realm as identified when the applicable port map entry was created. RFC 4787, REQ-8 recommends either endpointIndependent(0) or addressDependent(1) filtering behavior depending on whether application friendliness or security takes priority.')
natv2InstancePoolingBehavior = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("arbitrary", 0), ("paired", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstancePoolingBehavior.setReference('RFC 4787, near the end of Section 4.1')
if mibBuilder.loadTexts: natv2InstancePoolingBehavior.setStatus('current')
if mibBuilder.loadTexts: natv2InstancePoolingBehavior.setDescription('Pooling behavior is the policy used to select the address for a new port mapping within a given address pool to which the internal address has already been mapped. arbitrary(0) pooling behavior means that the NAT instance may create the new port mapping using any address in the pool that has a free port for the protocol concerned. paired(1) pooling behavior, the behavior RECOMMENDED by RFC 4787, REQ-2, means that once a given internal address has been mapped to a particular address in a particular pool, further mappings of the same internal address to that pool will reuse the previously assigned pool member address.')
natv2InstanceFragmentBehavior = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fragmentNone", 0), ("fragmentInOrder", 1), ("fragmentOutOfOrder", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceFragmentBehavior.setReference('RFC 4787, Section 11.')
if mibBuilder.loadTexts: natv2InstanceFragmentBehavior.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceFragmentBehavior.setDescription("Fragment behavior is the NAT instance's capability to receive and translate fragments incoming from remote sources. fragmentNone(0) implies no capability to translate incoming fragments, so all received fragments are dropped. Each dropped fragment is counted in natv2InstanceFragmentDrops. fragmentInOrder(1) implies the ability to translate fragments only if they are received in order, so that in particular the header is in the first packet. If a fragment is received out of order, it is dropped and counted in natv2InstanceFragmentDrops. fragmentOutOfOrder(2), the capability REQUIRED by RFC 4787, REQ-14, implies the capability to translate fragments even when they arrive out of order, subject to a protective limit natv2InstanceLimitPendingFragments on total number of fragments awaiting the first fragment of the chain. If the implementation supports this capability, natv2InstanceFragmentDrops is incremented only when a new fragment arrives but is dropped because the limit on pending fragments has already been reached.")
natv2InstanceAddressMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceAddressMapEntries.setReference('RFC 7659, Section 3.3.8. Hairpinning: RFC 4787, Section 6.')
if mibBuilder.loadTexts: natv2InstanceAddressMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceAddressMapEntries.setDescription("The current number of address map entries in total over the whole NAT instance, including static mappings. An address map entry maps from a given internal address and realm to an external address in a particular external realm. This definition includes 'hairpin' mappings, where the external realm is the same as the internal one. Address map entries are also tracked per subscriber and per address pool within the instance.")
natv2InstancePortMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstancePortMapEntries.setReference('RFC 7659, Section 3.3.9. Hairpinning: RFC 4787, Section 6.')
if mibBuilder.loadTexts: natv2InstancePortMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2InstancePortMapEntries.setDescription("The current number of entries in the port map table in total over the whole NAT instance, including static mappings. A port map entry maps from a given external realm, address, and port for a given protocol to an internal realm, address, and port. This definition includes 'hairpin' mappings, where the external realm is the same as the internal one. Port map entries are also tracked per subscriber and per protocol and address pool within the instance.")
natv2InstanceTranslations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceTranslations.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceTranslations.setDescription('The cumulative number of translated packets passing through this NAT instance. This value MUST be monotone increasing in the periods between updates of natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.')
natv2InstanceAddressMapCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceAddressMapCreations.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceAddressMapCreations.setDescription('The cumulative number of address map entries created by the NAT instance, including static mappings. Address map creations are also tracked per address pool within the instance and per subscriber. This value MUST be monotone increasing in the periods between updates of natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.')
natv2InstancePortMapCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstancePortMapCreations.setStatus('current')
if mibBuilder.loadTexts: natv2InstancePortMapCreations.setDescription('The cumulative number of port map entries created by the NAT instance, including static mappings. Port map creations are also tracked per protocol and address pool within the instance and per subscriber. This value MUST be monotone increasing in the periods between updates of natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.')
natv2InstanceAddressMapEntryLimitDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceAddressMapEntryLimitDrops.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceAddressMapEntryLimitDrops.setDescription("The cumulative number of packets dropped rather than translated because the packet would have triggered the creation of a new address map entry, but the limit on number of address map entries for the NAT instance given by natv2InstanceLimitAddressMapEntries has already been reached. This value MUST be monotone increasing in the periods between updates of the entity's natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2InstancePortMapEntryLimitDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 13), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstancePortMapEntryLimitDrops.setStatus('current')
if mibBuilder.loadTexts: natv2InstancePortMapEntryLimitDrops.setDescription("The cumulative number of packets dropped rather than translated because the packet would have triggered the creation of a new port map entry, but the limit on number of port map entries for the NAT instance given by natv2InstanceLimitPortMapEntries has already been reached. This value MUST be monotone increasing in the periods between updates of the entity's natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2InstanceSubscriberActiveLimitDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 14), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceSubscriberActiveLimitDrops.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceSubscriberActiveLimitDrops.setDescription("The cumulative number of packets dropped rather than translated because the packet would have triggered the creation of a new mapping for a subscriber with no other active mappings, but the limit on number of active subscribers for the NAT instance given by natv2InstanceLimitSubscriberActives has already been reached. This value MUST be monotone increasing in the periods between updates of the entity's natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2InstanceAddressMapFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 15), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceAddressMapFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceAddressMapFailureDrops.setDescription("The cumulative number of packets dropped because the packet would have triggered the creation of a new address map entry, but no address could be allocated in the selected external realm because all addresses from the selected address pool (or the whole realm, if no address pool has been configured for that realm) have already been fully allocated. This value MUST be monotone increasing in the periods between updates of the entity's natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2InstancePortMapFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 16), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstancePortMapFailureDrops.setReference('Pooling behavior: RFC 4787, end of Section 4.1.')
if mibBuilder.loadTexts: natv2InstancePortMapFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2InstancePortMapFailureDrops.setDescription("The cumulative number of packets dropped because the packet would have triggered the creation of a new port map entry, but no port could be allocated for the protocol concerned. The usual case for this will be for a NAT instance that supports address pooling and the 'Paired' pooling behavior recommended by RFC 4787, where the internal endpoint has used up all of the ports allocated to it for the address it was mapped to in the selected address pool in the external realm concerned and cannot be given more ports because - policy or implementation prevents it from having a second address in the same pool, and - policy or unavailability prevents it from acquiring more ports at its originally assigned address. If the NAT instance supports address pooling but its pooling behavior is 'Arbitrary' (meaning that the NAT instance can allocate a new port mapping for the given internal endpoint on any address in the selected address pool and is not bound to what it has already mapped for that endpoint), then this counter is incremented when all ports for the protocol concerned over the whole of the selected address pool are already in use. Finally, if no address pools have been configured for the external realm concerned, then this counter is incremented because all ports for the protocol involved over the whole set of addresses available for that external realm are already in use. This value MUST be monotone increasing in the periods between updates of the entity's natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2InstanceFragmentDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 17), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceFragmentDrops.setReference('RFC 4787, Section 11.')
if mibBuilder.loadTexts: natv2InstanceFragmentDrops.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceFragmentDrops.setDescription("The cumulative number of fragments received by the NAT instance but dropped rather than translated. When the NAT instance supports the 'Receive Fragment Out of Order' capability as required by RFC 4787, this occurs because the fragment was received out of order and would be added to the queue of fragments awaiting the initial fragment of the chain, but the queue has already reached the limit set by natv2InstanceLimitsPendingFragments. Counting in other cases is specified in the description of natv2InstanceFragmentBehavior. This value MUST be monotone increasing in the periods between updates of the entity's natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2InstanceOtherResourceFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 18), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceOtherResourceFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceOtherResourceFailureDrops.setDescription("The cumulative number of packets dropped because of unavailability of a resource other than an address or port that would have been required to process it. The most likely case is where the upper-layer protocol in the packet is not supported by the NAT instance. This value MUST be monotone increasing in the periods between updates of the entity's natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2InstanceDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 19), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2InstanceDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceDiscontinuityTime.setDescription('Snapshot of the value of the sysUpTime object at the beginning of the latest period of continuity of the statistical counters associated with this NAT instance.')
natv2InstanceThresholdAddressMapEntriesHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 20), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2InstanceThresholdAddressMapEntriesHigh.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceThresholdAddressMapEntriesHigh.setDescription('Notification threshold for total number of address map entries held by this NAT instance. Whenever natv2InstanceAddressMapEntries is updated, if it equals or exceeds natv2InstanceThresholdAddressMapEntriesHigh, then natv2NotificationInstanceAddressMapEntriesHigh may be triggered, unless the notification is disabled by setting the threshold to -1. Reporting is subject to the minimum inter-notification interval given by natv2InstanceNotificationInterval. If multiple notifications are triggered during one interval, the agent MUST report only the one containing the highest value of natv2InstanceAddressMapEntries and discard the others.')
natv2InstanceThresholdPortMapEntriesHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 21), Integer32().clone(-1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2InstanceThresholdPortMapEntriesHigh.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceThresholdPortMapEntriesHigh.setDescription('Notification threshold for total number of port map entries held by this NAT instance. Whenever natv2InstancePortMapEntries is updated, if it equals or exceeds natv2InstanceThresholdPortMapEntriesHigh, then natv2NotificationInstancePortMapEntriesHigh may be triggered, unless the notification is disabled by setting the threshold to -1. Reporting is subject to the minimum inter-notification interval given by natv2InstanceNotificationInterval. If multiple notifications are triggered during one interval, the agent MUST report only the one containing the highest value of natv2InstancePortMapEntries and discard the others.')
natv2InstanceNotificationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(10)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2InstanceNotificationInterval.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceNotificationInterval.setDescription('Minimum number of seconds between successive notifications for this NAT instance. Controls the reporting of natv2NotificationInstanceAddressMapEntriesHigh and natv2NotificationInstancePortMapEntriesHigh.')
natv2InstanceLimitAddressMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 23), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2InstanceLimitAddressMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceLimitAddressMapEntries.setDescription('Limit on total number of address map entries supported by the NAT instance. When natv2InstanceAddressMapEntries has reached this limit, subsequent packets that would normally trigger creation of a new address map entry will be dropped and counted in natv2InstanceAddressMapEntryLimitDrops. Warning of an approach to this limit can be achieved by setting natv2InstanceThresholdAddressMapEntriesHigh to a non-zero value, for example, 80% of the limit. The limit is disabled by setting its value to zero. For further information, please see the descriptions of natv2NotificationInstanceAddressMapEntriesHigh and natv2InstanceAddressMapEntries.')
natv2InstanceLimitPortMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 24), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2InstanceLimitPortMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceLimitPortMapEntries.setDescription('Limit on total number of port map entries supported by the NAT instance. When natv2InstancePortMapEntries has reached this limit, subsequent packets that would normally trigger creation of a new port map entry will be dropped and counted in natv2InstancePortMapEntryLimitDrops. Warning of an approach to this limit can be achieved by setting natv2InstanceThresholdPortMapEntriesHigh to a non-zero value, for example, 80% of the limit. The limit is disabled by setting its value to zero. For further information, please see the descriptions of natv2NotificationInstancePortMapEntriesHigh and natv2InstancePortMapEntries.')
natv2InstanceLimitPendingFragments = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 25), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2InstanceLimitPendingFragments.setReference('RFC 4787, Section 11.')
if mibBuilder.loadTexts: natv2InstanceLimitPendingFragments.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceLimitPendingFragments.setDescription("Limit on number of out-of-order fragments received by the NAT instance from remote sources and held until head of chain appears. While the number of held fragments is at this limit, subsequent packets that contain fragments not relating to those already held will be dropped and counted in natv2InstancePendingFragmentLimitDrops. The limit is disabled by setting the value to zero. Applicable only when the NAT instance supports 'Receive Fragments Out of Order' behavior; leave at default otherwise. See the description of natv2InstanceFragmentBehavior.")
natv2InstanceLimitSubscriberActives = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 1, 1, 26), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2InstanceLimitSubscriberActives.setStatus('current')
if mibBuilder.loadTexts: natv2InstanceLimitSubscriberActives.setDescription('Limit on number of total number of active subscribers supported by the NAT instance. An active subscriber is defined as any subscriber with at least one map entry, including static mappings. While the number of active subscribers is at this limit, subsequent packets that would otherwise trigger first mappings for newly active subscribers will be dropped and counted in natv2InstanceSubscriberActiveLimitDrops. The limit is disabled by setting the value to zero.')
natv2ProtocolTable = MibTable((1, 3, 6, 1, 2, 1, 234, 2, 2), )
if mibBuilder.loadTexts: natv2ProtocolTable.setReference('RFC 7659, Section 3.3.5.')
if mibBuilder.loadTexts: natv2ProtocolTable.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolTable.setDescription('Table of protocols with per-protocol counters. Conceptual rows of the table are indexed by the combination of the NAT instance number and the IANA-assigned upper-layer protocol number as given by the ProtocolNumber Textual Convention (TC) and contained in the packet IP header. It is up to the agent implementation to determine and operate upon only those upper-layer protocol numbers supported by the NAT instance.')
natv2ProtocolEntry = MibTableRow((1, 3, 6, 1, 2, 1, 234, 2, 2, 1), ).setIndexNames((0, "NATV2-MIB", "natv2ProtocolInstanceIndex"), (0, "NATV2-MIB", "natv2ProtocolNumber"))
if mibBuilder.loadTexts: natv2ProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolEntry.setDescription('Per-protocol counters.')
natv2ProtocolInstanceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 2, 1, 1), Natv2InstanceIndex())
if mibBuilder.loadTexts: natv2ProtocolInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolInstanceIndex.setDescription('NAT instance index. It is up to the implementation to determine and operate upon only those values that correspond to in-service NAT instances.')
natv2ProtocolNumber = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 2, 1, 2), ProtocolNumber())
if mibBuilder.loadTexts: natv2ProtocolNumber.setReference('RFC 7659, Section 3.3.5. IANA Protocol Numbers, <http://www.iana.org/assignments/protocol-numbers>')
if mibBuilder.loadTexts: natv2ProtocolNumber.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolNumber.setDescription('Counters in this conceptual row apply to packets indicating the upper-layer protocol identified by the value of this object. It is up to the implementation to determine and operate upon only those values that correspond to protocols supported by the NAT instance.')
natv2ProtocolPortMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 2, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2ProtocolPortMapEntries.setReference('RFC 7659, Sections 3.3.5 and 3.3.9. Hairpinning: RFC 4787, Section 6.')
if mibBuilder.loadTexts: natv2ProtocolPortMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolPortMapEntries.setDescription("The current number of entries in the port map table in total over the whole NAT instance for a given protocol, including static mappings. A port map entry maps from a given external realm, address, and port for a given protocol to an internal realm, address, and port. This definition includes 'hairpin' mappings, where the external realm is the same as the internal one. Port map entries are also tracked per subscriber, per instance, and per address pool within the instance.")
natv2ProtocolTranslations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 2, 1, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2ProtocolTranslations.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolTranslations.setDescription('The cumulative number of packets translated by the NAT instance in either direction for the given protocol. This value MUST be monotone increasing in the periods between updates of the NAT instance natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.')
natv2ProtocolPortMapCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 2, 1, 5), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2ProtocolPortMapCreations.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolPortMapCreations.setDescription('The cumulative number of port map entries created by the NAT instance for the given protocol. This value MUST be monotone increasing in the periods between updates of the NAT instance natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.')
natv2ProtocolPortMapFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 2, 1, 6), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2ProtocolPortMapFailureDrops.setReference('RFC 4787, end of Section 4.1.')
if mibBuilder.loadTexts: natv2ProtocolPortMapFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2ProtocolPortMapFailureDrops.setDescription("The cumulative number of packets dropped because the packet would have triggered the creation of a new port map entry, but no port could be allocated for the protocol concerned. The usual case for this will be for a NAT instance that supports address pooling and the 'Paired' pooling behavior recommended by RFC 4787, where the internal endpoint has used up all of the ports allocated to it for the address it was mapped to in the selected address pool in the external realm concerned and cannot be given more ports because - policy or implementation prevents it from having a second address in the same pool, and - policy or unavailability prevents it from acquiring more ports at its originally assigned address. If the NAT instance supports address pooling but its pooling behavior is 'Arbitrary' (meaning that the NAT instance can allocate a new port mapping for the given internal endpoint on any address in the selected address pool and is not bound to what it has already mapped for that endpoint), then this counter is incremented when all ports for the protocol concerned over the whole of the selected address pool are already in use. Finally, if the NAT instance has no configured address pooling, then this counter is incremented because all ports for the protocol concerned over the whole of the NAT instance for the external realm concerned are already in use. This value MUST be monotone increasing in the periods between updates of the NAT instance natv2InstanceDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2InstanceDiscontinuityTime.")
natv2PoolTable = MibTable((1, 3, 6, 1, 2, 1, 234, 2, 3), )
if mibBuilder.loadTexts: natv2PoolTable.setReference('RFC 7659, Section 3.3.6.')
if mibBuilder.loadTexts: natv2PoolTable.setStatus('current')
if mibBuilder.loadTexts: natv2PoolTable.setDescription("Table of address pools, applicable only if these are supported by the NAT instance. An address pool is a set of addresses and ports in a particular realm, available for assignment to the 'external' portion of a mapping. Where more than one pool has been configured for the realm, policy determines which subscribers and/or services are mapped to which pool. natv2PoolTable provides basic information, state, statistics, and two notification thresholds for each pool. natv2PoolRangeTable is an expansion table for natv2PoolTable that identifies particular address ranges allocated to the pool.")
natv2PoolEntry = MibTableRow((1, 3, 6, 1, 2, 1, 234, 2, 3, 1), ).setIndexNames((0, "NATV2-MIB", "natv2PoolInstanceIndex"), (0, "NATV2-MIB", "natv2PoolIndex"))
if mibBuilder.loadTexts: natv2PoolEntry.setStatus('current')
if mibBuilder.loadTexts: natv2PoolEntry.setDescription('Entry in the table of address pools.')
natv2PoolInstanceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 1), Natv2InstanceIndex())
if mibBuilder.loadTexts: natv2PoolInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PoolInstanceIndex.setDescription('NAT instance index. It is up to the agent implementation to determine and operate upon only those values that correspond to in-service NAT instances.')
natv2PoolIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 2), Natv2PoolIndex())
if mibBuilder.loadTexts: natv2PoolIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PoolIndex.setDescription('Index of an address pool that is unique for a given NAT instance. It is up to the agent implementation to determine and operate upon only those values that correspond to provisioned pools.')
natv2PoolRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolRealm.setReference('Address realms are discussed in Section 3.3.3 of RFC 7659. The primary reference is RFC 2663, Section 2.1.')
if mibBuilder.loadTexts: natv2PoolRealm.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRealm.setDescription("Address realm to which this pool's addresses belong.")
natv2PoolAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolAddressType.setReference('InetAddressType in RFC 4001.')
if mibBuilder.loadTexts: natv2PoolAddressType.setStatus('current')
if mibBuilder.loadTexts: natv2PoolAddressType.setDescription('Address type supplied by this address pool. This will be the same for all pools in a given realm (by definition of an address realm). Values other than ipv4(1) or ipv6(2) would be unexpected.')
natv2PoolMinimumPort = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 5), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolMinimumPort.setReference('InetPortNumber in RFC 4001.')
if mibBuilder.loadTexts: natv2PoolMinimumPort.setStatus('current')
if mibBuilder.loadTexts: natv2PoolMinimumPort.setDescription('Minimum port number of the range that can be allocated in this pool. Applies to all protocols supported by the NAT instance.')
natv2PoolMaximumPort = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 6), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolMaximumPort.setReference('InetPortNumber in RFC 4001.')
if mibBuilder.loadTexts: natv2PoolMaximumPort.setStatus('current')
if mibBuilder.loadTexts: natv2PoolMaximumPort.setDescription('Maximum port number of the range that can be allocated in this pool. Applies to all protocols supported by the NAT instance.')
natv2PoolAddressMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolAddressMapEntries.setReference('RFC 7659, Section 3.3.8. Hairpinning: RFC 4787, Section 6.')
if mibBuilder.loadTexts: natv2PoolAddressMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2PoolAddressMapEntries.setDescription("The current number of address map entries using external addresses drawn from this pool, including static mappings. This definition includes 'hairpin' mappings, where the external realm is the same as the internal one. Address map entries are also tracked per subscriber and per instance.")
natv2PoolPortMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 8), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolPortMapEntries.setReference('RFC 7659, Section 3.3.9. Hairpinning: RFC 4787, Section 6.')
if mibBuilder.loadTexts: natv2PoolPortMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2PoolPortMapEntries.setDescription("The current number of entries in the port map table using external addresses and ports drawn from this pool, including static mappings. This definition includes 'hairpin' mappings, where the external realm is the same as the internal one. Port map entries are also tracked per subscriber, per instance, and per protocol within the instance.")
natv2PoolAddressMapCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 9), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolAddressMapCreations.setStatus('current')
if mibBuilder.loadTexts: natv2PoolAddressMapCreations.setDescription("The cumulative number of address map entries created in this pool, including static mappings. Address map entries are also tracked per instance and per subscriber. This value MUST be monotone increasing in the periods between updates of the entity's natv2PoolDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2PoolDiscontinuityTime.")
natv2PoolPortMapCreations = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 10), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolPortMapCreations.setStatus('current')
if mibBuilder.loadTexts: natv2PoolPortMapCreations.setDescription("The cumulative number of port map entries created in this pool, including static mappings. Port map entries are also tracked per instance, per protocol, and per subscriber. This value MUST be monotone increasing in the periods between updates of the entity's natv2PoolDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2PoolDiscontinuityTime.")
natv2PoolAddressMapFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 11), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolAddressMapFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2PoolAddressMapFailureDrops.setDescription("The cumulative number of packets originated by the subscriber that were dropped because the packet would have triggered the creation of a new address map entry, but no address could be allocated from this address pool because all addresses in the pool have already been fully allocated. Counters of this event are also provided per instance, per protocol, and per subscriber. This value MUST be monotone increasing in the periods between updates of the entity's natv2PoolDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2PoolDiscontinuityTime.")
natv2PoolPortMapFailureDrops = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 12), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolPortMapFailureDrops.setReference('Pooling behavior: RFC 4787, end of Section 4.1.')
if mibBuilder.loadTexts: natv2PoolPortMapFailureDrops.setStatus('current')
if mibBuilder.loadTexts: natv2PoolPortMapFailureDrops.setDescription("The cumulative number of packets dropped because the packet would have triggered the creation of a new port map entry, but no port could be allocated for the protocol concerned. The usual case for this will be for a NAT instance that supports the 'Paired' pooling behavior recommended by RFC 4787, where the internal endpoint has used up all of the ports allocated to it for the address it was mapped to in this pool and cannot be given more ports because - policy or implementation prevents it from having a second address in the same pool, and - policy or unavailability prevents it from acquiring more ports at its originally assigned address. If the NAT instance pooling behavior is 'Arbitrary' (meaning that the NAT instance can allocate a new port mapping for the given internal endpoint on any address in the selected address pool and is not bound to what it has already mapped for that endpoint), then this counter is incremented when all ports for the protocol concerned over the whole of this address pool are already in use. This value MUST be monotone increasing in the periods between updates of the entity's natv2PoolDiscontinuityTime. If a manager detects a change in the latter since the last time it sampled this counter, it SHOULD NOT make use of the difference between the latest value of the counter and any value retrieved before the new value of natv2PoolDiscontinuityTime.")
natv2PoolDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 13), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: natv2PoolDiscontinuityTime.setDescription('Snapshot of the value of the sysUpTime object at the beginning of the latest period of continuity of the statistical counters associated with this address pool. This MUST be initialized when the address pool is configured and MUST be updated whenever the port or address ranges allocated to the pool change.')
natv2PoolThresholdUsageLow = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2PoolThresholdUsageLow.setReference('RFC 7659, Sections 3.1.2 and 3.3.6.')
if mibBuilder.loadTexts: natv2PoolThresholdUsageLow.setStatus('current')
if mibBuilder.loadTexts: natv2PoolThresholdUsageLow.setDescription('Threshold for reporting low utilization of the address pool. Utilization at a given instant is calculated as the percentage of ports allocated in port map entries for the most-used protocol at that instant. If utilization is less than or equal to natv2PoolThresholdUsageLow, an instance of natv2NotificationPoolUsageLow may be triggered, unless disabled by setting it to -1. Reporting is subject to the per-pool notification interval given by natv2PoolNotificationInterval. If multiple notifications are triggered during one interval, the agent MUST report only the one with the lowest value of natv2PoolNotifiedPortMapEntries and discard the others. Implementation note: the percentage specified by this object can be converted to a number of port map entries at configuration time (after port and address ranges have been configured or reconfigured) and compared to the current value of natv2PoolNotifiedPortMapEntries.')
natv2PoolThresholdUsageHigh = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 100), )).clone(-1)).setUnits('Percent').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2PoolThresholdUsageHigh.setStatus('current')
if mibBuilder.loadTexts: natv2PoolThresholdUsageHigh.setDescription('Threshold for reporting high utilization of the address pool. Utilization at a given instant is calculated as the percentage of ports allocated in port map entries for the most-used protocol at that instant. If utilization is greater than or equal to natv2PoolThresholdUsageHigh, an instance of natv2NotificationPoolUsageHigh may be triggered, unless disabled by setting it to -1. Reporting is subject to the per-pool notification interval given by natv2PoolNotificationInterval. If multiple notifications are triggered during one interval, the agent MUST report only the one with the highest value of natv2PoolNotifiedPortMapEntries and discard the others. In the rare case where both upper and lower thresholds are crossed in the same interval, the agent MUST report only the upper-threshold notification. Implementation note: the percentage specified by this object can be converted to a number of port map entries at configuration time (after port and address ranges have been configured or reconfigured) and compared to the current value of natv2PoolNotifiedPortMapEntries.')
natv2PoolNotifiedPortMapEntries = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 16), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: natv2PoolNotifiedPortMapEntries.setStatus('current')
if mibBuilder.loadTexts: natv2PoolNotifiedPortMapEntries.setDescription('Number of port map entries using addresses and ports from this address pool for the most-used protocol at a given instant. One of the objects returned by natv2NotificationPoolUsageLow and natv2NotificationPoolUsageHigh.')
natv2PoolNotifiedPortMapProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 17), ProtocolNumber()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: natv2PoolNotifiedPortMapProtocol.setStatus('current')
if mibBuilder.loadTexts: natv2PoolNotifiedPortMapProtocol.setDescription('The most-used protocol (i.e., with the largest number of port map entries) mapped into this address pool at a given instant. One of the objects returned by natv2NotificationPoolUsageLow and natv2NotificationPoolUsageHigh.')
natv2PoolNotificationInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 3, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(20)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: natv2PoolNotificationInterval.setStatus('current')
if mibBuilder.loadTexts: natv2PoolNotificationInterval.setDescription('Minimum number of seconds between successive notifications for this address pool. Controls the generation of natv2NotificationPoolUsageLow and natv2NotificationPoolUsageHigh.')
natv2PoolRangeTable = MibTable((1, 3, 6, 1, 2, 1, 234, 2, 4), )
if mibBuilder.loadTexts: natv2PoolRangeTable.setReference('RFC 7659, Section 3.3.7.')
if mibBuilder.loadTexts: natv2PoolRangeTable.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRangeTable.setDescription('This table contains address ranges used by pool entries. It is an expansion of natv2PoolTable.')
natv2PoolRangeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 234, 2, 4, 1), ).setIndexNames((0, "NATV2-MIB", "natv2PoolRangeInstanceIndex"), (0, "NATV2-MIB", "natv2PoolRangePoolIndex"), (0, "NATV2-MIB", "natv2PoolRangeRowIndex"))
if mibBuilder.loadTexts: natv2PoolRangeEntry.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRangeEntry.setDescription('NAT pool address range.')
natv2PoolRangeInstanceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 4, 1, 1), Natv2InstanceIndex())
if mibBuilder.loadTexts: natv2PoolRangeInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRangeInstanceIndex.setDescription('Index of the NAT instance on which the address pool and this address range are configured. See Natv2InstanceIndex.')
natv2PoolRangePoolIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 4, 1, 2), Natv2PoolIndex())
if mibBuilder.loadTexts: natv2PoolRangePoolIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRangePoolIndex.setDescription('Index of the address pool to which this address range belongs. See Natv2PoolIndex.')
natv2PoolRangeRowIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 4, 1, 3), Unsigned32())
if mibBuilder.loadTexts: natv2PoolRangeRowIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRangeRowIndex.setDescription('Row index for successive range entries for the same address pool.')
natv2PoolRangeBegin = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 4, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolRangeBegin.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRangeBegin.setDescription('Lowest address included in this range. The type of address (IPv4 or IPv6) is given by natv2PoolAddressType in natv2PoolTable.')
natv2PoolRangeEnd = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 4, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PoolRangeEnd.setStatus('current')
if mibBuilder.loadTexts: natv2PoolRangeEnd.setDescription('Highest address included in this range. The type of address (IPv4 or IPv6) is given by natv2PoolAddressType in natv2PoolTable.')
natv2AddressMapTable = MibTable((1, 3, 6, 1, 2, 1, 234, 2, 5), )
if mibBuilder.loadTexts: natv2AddressMapTable.setReference('RFC 7659, Section 3.3.8. DS-Lite: RFC 6333')
if mibBuilder.loadTexts: natv2AddressMapTable.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapTable.setDescription('Table of mappings from the internal to external address. By definition, this is a snapshot of NAT instance state at a given moment. Indexed by NAT instance, internal realm, and internal address in that realm. Provides the mapped external address and, depending on implementation support, identifies the address pool from which the external address and port were taken and the index of the subscriber to which the mapping has been allocated. In the case of DS-Lite (RFC 6333), the indexing realm and address are those of the IPv6 encapsulation rather than the IPv4 inner packet.')
natv2AddressMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 234, 2, 5, 1), ).setIndexNames((0, "NATV2-MIB", "natv2AddressMapInstanceIndex"), (0, "NATV2-MIB", "natv2AddressMapInternalRealm"), (0, "NATV2-MIB", "natv2AddressMapInternalAddressType"), (0, "NATV2-MIB", "natv2AddressMapInternalAddress"), (0, "NATV2-MIB", "natv2AddressMapRowIndex"))
if mibBuilder.loadTexts: natv2AddressMapEntry.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapEntry.setDescription('Mapping from internal to external address.')
natv2AddressMapInstanceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 1), Natv2InstanceIndex())
if mibBuilder.loadTexts: natv2AddressMapInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapInstanceIndex.setDescription('Index of the NAT instance that generated this address map.')
natv2AddressMapInternalRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: natv2AddressMapInternalRealm.setReference('DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2AddressMapInternalRealm.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapInternalRealm.setDescription('Realm to which the internal address belongs. In most cases, this is the realm defining the address space of the packet being translated. However, in the case of DS-Lite (RFC 6333), this realm defines the IPv6 outer header address space. It is the combination of that outer header and the inner IPv4 packet header that is remapped to the external address and realm. The corresponding IPv4 realm is restricted in scope to the tunnel, so there is no point in identifying it. The mapped IPv4 address will normally be the well-known value 192.0.0.2, or at least lie in the reserved 192.0.0.0/29 range. If natv2AddressMapSubscriberIndex in this table is a valid subscriber index (i.e., greater than zero), then the value of natv2AddressMapInternalRealm MUST be identical to the value of natv2SubscriberRealm associated with that index.')
natv2AddressMapInternalAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 3), InetAddressType())
if mibBuilder.loadTexts: natv2AddressMapInternalAddressType.setReference('DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel source address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2AddressMapInternalAddressType.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapInternalAddressType.setDescription('Address type in the header of packets on the interior side of this mapping. Any value other than ipv4(1) or ipv6(2) would be unexpected. In the DS-Lite case, the address type is ipv6(2).')
natv2AddressMapInternalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 4), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 16)))
if mibBuilder.loadTexts: natv2AddressMapInternalAddress.setReference('DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2AddressMapInternalAddress.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapInternalAddress.setDescription('Source address of packets originating from the interior of the association provided by this mapping. The address type is given by natv2AddressMapInternalAddressType. In the case of DS-Lite (RFC 6333), this is the IPv6 tunnel source address. The mapping in this case is considered to be from the combination of the IPv6 tunnel source address natv2AddressMapInternalRealmAddress and the well-known IPv4 inner source address natv2AddressMapInternalMappedAddress to the external address.')
natv2AddressMapRowIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 5), Unsigned32())
if mibBuilder.loadTexts: natv2AddressMapRowIndex.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapRowIndex.setDescription('Index of a conceptual row corresponding to a mapping of the given internal realm and address to a single external realm and address. Multiple rows will be present because of a promiscuous external address selection policy, policies associating the same internal address with different address pools, or because the same internal realm-address combination is communicating with multiple external address realms.')
natv2AddressMapInternalMappedAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 6), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2AddressMapInternalMappedAddressType.setReference('DS-Lite: RFC 6333.')
if mibBuilder.loadTexts: natv2AddressMapInternalMappedAddressType.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapInternalMappedAddressType.setDescription('Internal address type actually translated by this mapping. Any value other than ipv4(1) or ipv6(2) would be unexpected. In the general case, this is the same as given by natv2AddressMapInternalRealmAddressType. In the tunneled case, it is the address type used in the encapsulated packet header. In particular, in the DS-Lite case, the mapped address type is ipv4(1).')
natv2AddressMapInternalMappedAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 7), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2AddressMapInternalMappedAddress.setReference('DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2AddressMapInternalMappedAddress.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapInternalMappedAddress.setDescription('Internal address actually translated by this mapping. In the general case, this is the same as natv2AddressMapInternalRealmAddress. The address type is given by natv2AddressMapInternalMappedAddressType. In the case of DS-Lite (RFC 6333), this is the source address of the encapsulated IPv4 packet, normally lying in the well-known range 192.0.0.0/29. The mapping in this case is considered to be from the combination of the IPv6 tunnel source address natv2AddressMapInternalRealmAddress and the well-known IPv4 inner source address natv2AddressMapInternalMappedAddress to the external address.')
natv2AddressMapExternalRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2AddressMapExternalRealm.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapExternalRealm.setDescription("External address realm to which this mapping maps the internal address. This can be the same as the internal realm in the case of a 'hairpin' connection, but otherwise will be different.")
natv2AddressMapExternalAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 9), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2AddressMapExternalAddressType.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapExternalAddressType.setDescription('Address type for the external realm. Any value other than ipv4(1) or ipv6(2) would be unexpected.')
natv2AddressMapExternalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 10), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2AddressMapExternalAddress.setReference('DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2AddressMapExternalAddress.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapExternalAddress.setDescription('External address to which the internal address is mapped. The address type is given by natv2AddressMapExternalAddressType. In the DS-Lite case, the mapping is from the combination of the internal IPv6 tunnel source address as presented in this table and the well-known IPv4 source address of the encapsulated IPv4 packet.')
natv2AddressMapExternalPoolIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 11), Natv2PoolIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2AddressMapExternalPoolIndex.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapExternalPoolIndex.setDescription('Index of the address pool in the external realm from which the mapped external address given in natv2AddressMapExternalAddress was taken. Zero if the implementation does not support address pools but has chosen to support this object or if no pool was configured for the given external realm.')
natv2AddressMapSubscriberIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 5, 1, 12), Natv2SubscriberIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2AddressMapSubscriberIndex.setStatus('current')
if mibBuilder.loadTexts: natv2AddressMapSubscriberIndex.setDescription('Index of the subscriber to which this address mapping applies, or zero if no subscribers are configured on this NAT instance.')
natv2PortMapTable = MibTable((1, 3, 6, 1, 2, 1, 234, 2, 6), )
if mibBuilder.loadTexts: natv2PortMapTable.setReference('RFC 7659, Section 3.3.9. DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2PortMapTable.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapTable.setDescription('Table of port map entries indexed by the NAT instance, protocol, and external realm and address. A port map entry associates an internal upper-layer protocol endpoint with an endpoint for the same protocol in the given external realm. By definition, this is a snapshot of NAT instance state at a given moment. The table provides the basic mapping information. In the case of DS-Lite (RFC 6333), the table provides the internal IPv6 tunnel source address in natv2PortMapInternalRealmAddress and the IPv4 source address of the encapsulated packet that is actually translated in natv2PortMapInternalMappedAddress. In the general (non-DS- Lite) case, those two objects will have the same value.')
natv2PortMapEntry = MibTableRow((1, 3, 6, 1, 2, 1, 234, 2, 6, 1), ).setIndexNames((0, "NATV2-MIB", "natv2PortMapInstanceIndex"), (0, "NATV2-MIB", "natv2PortMapProtocol"), (0, "NATV2-MIB", "natv2PortMapExternalRealm"), (0, "NATV2-MIB", "natv2PortMapExternalAddressType"), (0, "NATV2-MIB", "natv2PortMapExternalAddress"), (0, "NATV2-MIB", "natv2PortMapExternalPort"))
if mibBuilder.loadTexts: natv2PortMapEntry.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapEntry.setDescription('A single NAT mapping.')
natv2PortMapInstanceIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 1), Natv2InstanceIndex())
if mibBuilder.loadTexts: natv2PortMapInstanceIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapInstanceIndex.setDescription('Index of the NAT instance that created this port map entry.')
natv2PortMapProtocol = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 2), ProtocolNumber())
if mibBuilder.loadTexts: natv2PortMapProtocol.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapProtocol.setDescription("The map entry's upper-layer protocol number.")
natv2PortMapExternalRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: natv2PortMapExternalRealm.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapExternalRealm.setDescription('The realm to which natv2PortMapExternalAddress belongs.')
natv2PortMapExternalAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 4), InetAddressType())
if mibBuilder.loadTexts: natv2PortMapExternalAddressType.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapExternalAddressType.setDescription('Address type for the external realm. A value other than ipv4(1) or ipv6(2) would be unexpected.')
natv2PortMapExternalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 5), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 16)))
if mibBuilder.loadTexts: natv2PortMapExternalAddress.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapExternalAddress.setDescription("The mapping's assigned external address. (This address is taken from the address pool identified by natv2PortMapExternalPoolIndex, if the implementation supports address pools and pools are configured for the given external realm.) This is the source address for translated outgoing packets. The address type is given by natv2PortMapExternalAddressType.")
natv2PortMapExternalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 6), InetPortNumber())
if mibBuilder.loadTexts: natv2PortMapExternalPort.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapExternalPort.setDescription("The mapping's assigned external port number. This is the source port for translated outgoing packets. If the internal port number given by natv2PortMapInternalPort is zero, this value MUST also be zero. Otherwise, this MUST be a non-zero value.")
natv2PortMapInternalRealm = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapInternalRealm.setReference('DS-Lite: RFC 6333.')
if mibBuilder.loadTexts: natv2PortMapInternalRealm.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapInternalRealm.setDescription('The realm to which natv2PortMapInternalRealmAddress belongs. In the general case, this realm contains the address that is being translated. In the DS-Lite (RFC 6333) case, this realm defines the IPv6 address space from which the tunnel source address is taken. The realm of the encapsulated IPv4 address is restricted in scope to the tunnel, so there is no point in identifying it separately.')
natv2PortMapInternalAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapInternalAddressType.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapInternalAddressType.setDescription('Address type for addresses in the realm identified by natv2PortMapInternalRealm.')
natv2PortMapInternalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapInternalAddress.setReference('DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2PortMapInternalAddress.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapInternalAddress.setDescription('Source address for packets received under this mapping on the internal side of the NAT instance. In the general case, this address is the same as the address given in natv2PortMapInternalMappedAddress. In the DS-Lite case, natv2PortMapInternalAddress is the IPv6 tunnel source address. The address type is given by natv2PortMapInternalAddressType.')
natv2PortMapInternalMappedAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapInternalMappedAddressType.setReference('DS-Lite: RFC 6333.')
if mibBuilder.loadTexts: natv2PortMapInternalMappedAddressType.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapInternalMappedAddressType.setDescription('Internal address type actually translated by this mapping. Any value other than ipv4(1) or ipv6(2) would be unexpected. In the general case, this is the same as given by natv2AddressMapInternalAddressType. In the DS-Lite case, the address type is ipv4(1).')
natv2PortMapInternalMappedAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 11), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapInternalMappedAddress.setReference('DS-Lite: RFC 6333, Sections 5.7 (for well-known addresses) and 6.6 (on the need to have the IPv6 tunnel address in the NAT mapping tables).')
if mibBuilder.loadTexts: natv2PortMapInternalMappedAddress.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapInternalMappedAddress.setDescription('Internal address actually translated by this mapping. In the general case, this is the same as natv2PortMapInternalRealmAddress. The address type is given by natv2PortMapInternalMappedAddressType. In the case of DS-Lite (RFC 6333), this is the source address of the encapsulated IPv4 packet, normally selected from the well-known range 192.0.0.0/29. The mapping in this case is considered to be from the external address to the combination of the IPv6 tunnel source address natv2PortMapInternalRealmAddress and the well-known IPv4 inner source address natv2PortMapInternalMappedAddress.')
natv2PortMapInternalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 12), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapInternalPort.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapInternalPort.setDescription("The mapping's internal port number. If this is zero, ports are not translated (i.e., the NAT instance is a pure NAT rather than a Network Address and Port Translator (NAPT)).")
natv2PortMapExternalPoolIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 13), Natv2PoolIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapExternalPoolIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapExternalPoolIndex.setDescription('Identifies the address pool from which the external address in this port map entry was taken. Zero if the implementation does not support address pools but has chosen to support this object or if no pools are configured for the given external realm.')
natv2PortMapSubscriberIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 234, 2, 6, 1, 14), Natv2SubscriberIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natv2PortMapSubscriberIndex.setStatus('current')
if mibBuilder.loadTexts: natv2PortMapSubscriberIndex.setDescription('Subscriber using this map entry. Zero if the implementation does not support subscribers but has chosen to support this object.')
natv2MIBConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 234, 3))
natv2MIBCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 234, 3, 1))
natv2MIBGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 234, 3, 2))
natv2MIBBasicCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 234, 3, 1, 1)).setObjects(("NATV2-MIB", "natv2BasicNotificationGroup"), ("NATV2-MIB", "natv2BasicInstanceLevelGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2MIBBasicCompliance = natv2MIBBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: natv2MIBBasicCompliance.setDescription('Describes the requirements for conformance to the basic NAT application of NATV2-MIB.')
natv2MIBPooledNATCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 234, 3, 1, 2)).setObjects(("NATV2-MIB", "natv2BasicNotificationGroup"), ("NATV2-MIB", "natv2BasicInstanceLevelGroup"), ("NATV2-MIB", "natv2PooledNotificationGroup"), ("NATV2-MIB", "natv2PooledInstanceLevelGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2MIBPooledNATCompliance = natv2MIBPooledNATCompliance.setStatus('current')
if mibBuilder.loadTexts: natv2MIBPooledNATCompliance.setDescription('Describes the requirements for conformance to the pooled NAT application of NATV2-MIB.')
natv2MIBCGNCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 234, 3, 1, 3)).setObjects(("NATV2-MIB", "natv2BasicNotificationGroup"), ("NATV2-MIB", "natv2BasicInstanceLevelGroup"), ("NATV2-MIB", "natv2PooledNotificationGroup"), ("NATV2-MIB", "natv2PooledInstanceLevelGroup"), ("NATV2-MIB", "natv2CGNNotificationGroup"), ("NATV2-MIB", "natv2CGNDeviceLevelGroup"), ("NATV2-MIB", "natv2CGNInstanceLevelGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2MIBCGNCompliance = natv2MIBCGNCompliance.setStatus('current')
if mibBuilder.loadTexts: natv2MIBCGNCompliance.setDescription('Describes the requirements for conformance to the carrier-grade NAT application of NATV2-MIB.')
natv2BasicNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 234, 3, 2, 1)).setObjects(("NATV2-MIB", "natv2NotificationInstanceAddressMapEntriesHigh"), ("NATV2-MIB", "natv2NotificationInstancePortMapEntriesHigh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2BasicNotificationGroup = natv2BasicNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: natv2BasicNotificationGroup.setDescription('Notifications that MUST be supported by all NAT applications.')
natv2BasicInstanceLevelGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 234, 3, 2, 2)).setObjects(("NATV2-MIB", "natv2InstanceAlias"), ("NATV2-MIB", "natv2InstancePortMappingBehavior"), ("NATV2-MIB", "natv2InstanceFilteringBehavior"), ("NATV2-MIB", "natv2InstanceFragmentBehavior"), ("NATV2-MIB", "natv2InstanceAddressMapEntries"), ("NATV2-MIB", "natv2InstancePortMapEntries"), ("NATV2-MIB", "natv2InstanceTranslations"), ("NATV2-MIB", "natv2InstanceAddressMapCreations"), ("NATV2-MIB", "natv2InstanceAddressMapEntryLimitDrops"), ("NATV2-MIB", "natv2InstanceAddressMapFailureDrops"), ("NATV2-MIB", "natv2InstancePortMapCreations"), ("NATV2-MIB", "natv2InstancePortMapEntryLimitDrops"), ("NATV2-MIB", "natv2InstancePortMapFailureDrops"), ("NATV2-MIB", "natv2InstanceFragmentDrops"), ("NATV2-MIB", "natv2InstanceOtherResourceFailureDrops"), ("NATV2-MIB", "natv2InstanceDiscontinuityTime"), ("NATV2-MIB", "natv2InstanceThresholdAddressMapEntriesHigh"), ("NATV2-MIB", "natv2InstanceThresholdPortMapEntriesHigh"), ("NATV2-MIB", "natv2InstanceNotificationInterval"), ("NATV2-MIB", "natv2InstanceLimitAddressMapEntries"), ("NATV2-MIB", "natv2InstanceLimitPortMapEntries"), ("NATV2-MIB", "natv2InstanceLimitPendingFragments"), ("NATV2-MIB", "natv2ProtocolPortMapEntries"), ("NATV2-MIB", "natv2ProtocolTranslations"), ("NATV2-MIB", "natv2ProtocolPortMapCreations"), ("NATV2-MIB", "natv2ProtocolPortMapFailureDrops"), ("NATV2-MIB", "natv2AddressMapExternalRealm"), ("NATV2-MIB", "natv2AddressMapExternalAddressType"), ("NATV2-MIB", "natv2AddressMapExternalAddress"), ("NATV2-MIB", "natv2PortMapInternalRealm"), ("NATV2-MIB", "natv2PortMapInternalAddressType"), ("NATV2-MIB", "natv2PortMapInternalAddress"), ("NATV2-MIB", "natv2PortMapInternalPort"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2BasicInstanceLevelGroup = natv2BasicInstanceLevelGroup.setStatus('current')
if mibBuilder.loadTexts: natv2BasicInstanceLevelGroup.setDescription('Per-instance objects that MUST be supported by implementations of all NAT applications.')
natv2PooledNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 234, 3, 2, 3)).setObjects(("NATV2-MIB", "natv2NotificationPoolUsageLow"), ("NATV2-MIB", "natv2NotificationPoolUsageHigh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2PooledNotificationGroup = natv2PooledNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: natv2PooledNotificationGroup.setDescription('Notifications that MUST be supported by pooled and carrier-grade NAT applications.')
natv2PooledInstanceLevelGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 234, 3, 2, 4)).setObjects(("NATV2-MIB", "natv2InstancePoolingBehavior"), ("NATV2-MIB", "natv2PoolRealm"), ("NATV2-MIB", "natv2PoolAddressType"), ("NATV2-MIB", "natv2PoolMinimumPort"), ("NATV2-MIB", "natv2PoolMaximumPort"), ("NATV2-MIB", "natv2PoolAddressMapEntries"), ("NATV2-MIB", "natv2PoolPortMapEntries"), ("NATV2-MIB", "natv2PoolAddressMapCreations"), ("NATV2-MIB", "natv2PoolPortMapCreations"), ("NATV2-MIB", "natv2PoolAddressMapFailureDrops"), ("NATV2-MIB", "natv2PoolPortMapFailureDrops"), ("NATV2-MIB", "natv2PoolDiscontinuityTime"), ("NATV2-MIB", "natv2PoolThresholdUsageLow"), ("NATV2-MIB", "natv2PoolThresholdUsageHigh"), ("NATV2-MIB", "natv2PoolNotifiedPortMapEntries"), ("NATV2-MIB", "natv2PoolNotifiedPortMapProtocol"), ("NATV2-MIB", "natv2PoolNotificationInterval"), ("NATV2-MIB", "natv2PoolRangeBegin"), ("NATV2-MIB", "natv2PoolRangeEnd"), ("NATV2-MIB", "natv2AddressMapExternalPoolIndex"), ("NATV2-MIB", "natv2PortMapExternalPoolIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2PooledInstanceLevelGroup = natv2PooledInstanceLevelGroup.setStatus('current')
if mibBuilder.loadTexts: natv2PooledInstanceLevelGroup.setDescription('Per-instance objects that MUST be supported by implementations of the pooled and carrier-grade NAT applications.')
natv2CGNNotificationGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 234, 3, 2, 5)).setObjects(("NATV2-MIB", "natv2NotificationSubscriberPortMappingEntriesHigh"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2CGNNotificationGroup = natv2CGNNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: natv2CGNNotificationGroup.setDescription('Notification that MUST be supported by implementations of the carrier-grade NAT application.')
natv2CGNDeviceLevelGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 234, 3, 2, 6)).setObjects(("NATV2-MIB", "natv2SubscriberInternalRealm"), ("NATV2-MIB", "natv2SubscriberInternalPrefixType"), ("NATV2-MIB", "natv2SubscriberInternalPrefix"), ("NATV2-MIB", "natv2SubscriberInternalPrefixLength"), ("NATV2-MIB", "natv2SubscriberAddressMapEntries"), ("NATV2-MIB", "natv2SubscriberPortMapEntries"), ("NATV2-MIB", "natv2SubscriberTranslations"), ("NATV2-MIB", "natv2SubscriberAddressMapCreations"), ("NATV2-MIB", "natv2SubscriberPortMapCreations"), ("NATV2-MIB", "natv2SubscriberAddressMapFailureDrops"), ("NATV2-MIB", "natv2SubscriberPortMapFailureDrops"), ("NATV2-MIB", "natv2SubscriberDiscontinuityTime"), ("NATV2-MIB", "natv2SubscriberLimitPortMapEntries"), ("NATV2-MIB", "natv2SubscriberThresholdPortMapEntriesHigh"), ("NATV2-MIB", "natv2SubscriberNotificationInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2CGNDeviceLevelGroup = natv2CGNDeviceLevelGroup.setStatus('current')
if mibBuilder.loadTexts: natv2CGNDeviceLevelGroup.setDescription('Device-level objects that MUST be supported by the carrier-grade NAT application.')
natv2CGNInstanceLevelGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 234, 3, 2, 7)).setObjects(("NATV2-MIB", "natv2InstanceSubscriberActiveLimitDrops"), ("NATV2-MIB", "natv2InstanceLimitSubscriberActives"), ("NATV2-MIB", "natv2AddressMapInternalMappedAddressType"), ("NATV2-MIB", "natv2AddressMapInternalMappedAddress"), ("NATV2-MIB", "natv2AddressMapSubscriberIndex"), ("NATV2-MIB", "natv2PortMapInternalMappedAddressType"), ("NATV2-MIB", "natv2PortMapInternalMappedAddress"), ("NATV2-MIB", "natv2PortMapSubscriberIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    natv2CGNInstanceLevelGroup = natv2CGNInstanceLevelGroup.setStatus('current')
if mibBuilder.loadTexts: natv2CGNInstanceLevelGroup.setDescription('Per-instance objects that MUST be supported by the carrier-grade NAT application.')
mibBuilder.exportSymbols("NATV2-MIB", natv2PortMapExternalPort=natv2PortMapExternalPort, natv2PoolRangeBegin=natv2PoolRangeBegin, natv2PortMapInternalRealm=natv2PortMapInternalRealm, natv2PoolInstanceIndex=natv2PoolInstanceIndex, natv2SubscriberPortMapCreations=natv2SubscriberPortMapCreations, natv2MIB=natv2MIB, natv2BasicNotificationGroup=natv2BasicNotificationGroup, natv2ProtocolEntry=natv2ProtocolEntry, natv2InstanceTranslations=natv2InstanceTranslations, natv2NotificationPoolUsageLow=natv2NotificationPoolUsageLow, natv2PoolRangeEnd=natv2PoolRangeEnd, natv2InstanceThresholdAddressMapEntriesHigh=natv2InstanceThresholdAddressMapEntriesHigh, natv2SubscriberDiscontinuityTime=natv2SubscriberDiscontinuityTime, natv2InstanceAddressMapEntryLimitDrops=natv2InstanceAddressMapEntryLimitDrops, natv2InstanceTable=natv2InstanceTable, natv2PortMapTable=natv2PortMapTable, natv2InstanceDiscontinuityTime=natv2InstanceDiscontinuityTime, natv2MIBBasicCompliance=natv2MIBBasicCompliance, natv2AddressMapExternalAddress=natv2AddressMapExternalAddress, natv2ProtocolNumber=natv2ProtocolNumber, natv2PoolMinimumPort=natv2PoolMinimumPort, natv2PoolRangeEntry=natv2PoolRangeEntry, natv2MIBNotifications=natv2MIBNotifications, natv2InstanceAddressMapFailureDrops=natv2InstanceAddressMapFailureDrops, natv2PoolEntry=natv2PoolEntry, natv2InstanceAddressMapEntries=natv2InstanceAddressMapEntries, natv2ProtocolTranslations=natv2ProtocolTranslations, natv2NotificationSubscriberPortMappingEntriesHigh=natv2NotificationSubscriberPortMappingEntriesHigh, natv2PortMapInternalAddress=natv2PortMapInternalAddress, natv2SubscriberEntry=natv2SubscriberEntry, natv2PortMapExternalAddress=natv2PortMapExternalAddress, natv2MIBGroups=natv2MIBGroups, natv2SubscriberAddressMapEntries=natv2SubscriberAddressMapEntries, natv2InstancePortMapEntryLimitDrops=natv2InstancePortMapEntryLimitDrops, natv2InstanceLimitAddressMapEntries=natv2InstanceLimitAddressMapEntries, natv2PoolRangeTable=natv2PoolRangeTable, natv2MIBDeviceObjects=natv2MIBDeviceObjects, natv2InstanceOtherResourceFailureDrops=natv2InstanceOtherResourceFailureDrops, natv2PoolDiscontinuityTime=natv2PoolDiscontinuityTime, natv2SubscriberThresholdPortMapEntriesHigh=natv2SubscriberThresholdPortMapEntriesHigh, natv2PoolNotifiedPortMapProtocol=natv2PoolNotifiedPortMapProtocol, natv2PoolRangePoolIndex=natv2PoolRangePoolIndex, natv2MIBPooledNATCompliance=natv2MIBPooledNATCompliance, natv2CGNDeviceLevelGroup=natv2CGNDeviceLevelGroup, natv2NotificationInstanceAddressMapEntriesHigh=natv2NotificationInstanceAddressMapEntriesHigh, natv2PoolThresholdUsageHigh=natv2PoolThresholdUsageHigh, natv2PoolIndex=natv2PoolIndex, natv2SubscriberTranslations=natv2SubscriberTranslations, natv2InstancePoolingBehavior=natv2InstancePoolingBehavior, natv2InstanceFilteringBehavior=natv2InstanceFilteringBehavior, natv2PortMapInternalMappedAddressType=natv2PortMapInternalMappedAddressType, natv2SubscriberInternalPrefixType=natv2SubscriberInternalPrefixType, natv2PoolNotifiedPortMapEntries=natv2PoolNotifiedPortMapEntries, natv2NotificationInstancePortMapEntriesHigh=natv2NotificationInstancePortMapEntriesHigh, natv2InstancePortMapEntries=natv2InstancePortMapEntries, natv2PoolRealm=natv2PoolRealm, natv2AddressMapExternalPoolIndex=natv2AddressMapExternalPoolIndex, natv2PoolNotificationInterval=natv2PoolNotificationInterval, natv2PoolAddressMapCreations=natv2PoolAddressMapCreations, natv2SubscriberPortMapEntries=natv2SubscriberPortMapEntries, natv2MIBCompliances=natv2MIBCompliances, Natv2PoolIndexOrZero=Natv2PoolIndexOrZero, natv2PoolAddressMapEntries=natv2PoolAddressMapEntries, natv2SubscriberNotificationInterval=natv2SubscriberNotificationInterval, natv2PoolAddressType=natv2PoolAddressType, natv2AddressMapExternalAddressType=natv2AddressMapExternalAddressType, natv2PoolThresholdUsageLow=natv2PoolThresholdUsageLow, natv2PoolRangeRowIndex=natv2PoolRangeRowIndex, natv2AddressMapInternalMappedAddress=natv2AddressMapInternalMappedAddress, natv2PoolPortMapEntries=natv2PoolPortMapEntries, natv2AddressMapExternalRealm=natv2AddressMapExternalRealm, natv2ProtocolPortMapEntries=natv2ProtocolPortMapEntries, natv2SubscriberInternalPrefix=natv2SubscriberInternalPrefix, natv2SubscriberInternalRealm=natv2SubscriberInternalRealm, natv2AddressMapTable=natv2AddressMapTable, natv2AddressMapEntry=natv2AddressMapEntry, natv2PoolPortMapCreations=natv2PoolPortMapCreations, natv2MIBInstanceObjects=natv2MIBInstanceObjects, natv2ProtocolPortMapFailureDrops=natv2ProtocolPortMapFailureDrops, natv2PortMapInstanceIndex=natv2PortMapInstanceIndex, natv2PoolPortMapFailureDrops=natv2PoolPortMapFailureDrops, natv2InstanceAlias=natv2InstanceAlias, natv2SubscriberIndex=natv2SubscriberIndex, natv2SubscriberAddressMapCreations=natv2SubscriberAddressMapCreations, natv2AddressMapInternalMappedAddressType=natv2AddressMapInternalMappedAddressType, natv2PortMapExternalRealm=natv2PortMapExternalRealm, natv2PortMapExternalAddressType=natv2PortMapExternalAddressType, natv2AddressMapInternalRealm=natv2AddressMapInternalRealm, natv2InstanceIndex=natv2InstanceIndex, natv2InstanceFragmentDrops=natv2InstanceFragmentDrops, natv2AddressMapInternalAddress=natv2AddressMapInternalAddress, natv2PortMapInternalAddressType=natv2PortMapInternalAddressType, natv2ProtocolTable=natv2ProtocolTable, natv2InstanceLimitPendingFragments=natv2InstanceLimitPendingFragments, natv2PortMapProtocol=natv2PortMapProtocol, natv2PoolRangeInstanceIndex=natv2PoolRangeInstanceIndex, natv2PoolMaximumPort=natv2PoolMaximumPort, natv2ProtocolPortMapCreations=natv2ProtocolPortMapCreations, natv2SubscriberAddressMapFailureDrops=natv2SubscriberAddressMapFailureDrops, natv2SubscriberTable=natv2SubscriberTable, natv2InstanceSubscriberActiveLimitDrops=natv2InstanceSubscriberActiveLimitDrops, natv2InstanceLimitPortMapEntries=natv2InstanceLimitPortMapEntries, natv2InstanceLimitSubscriberActives=natv2InstanceLimitSubscriberActives, natv2InstancePortMapCreations=natv2InstancePortMapCreations, natv2PooledInstanceLevelGroup=natv2PooledInstanceLevelGroup, natv2InstanceThresholdPortMapEntriesHigh=natv2InstanceThresholdPortMapEntriesHigh, natv2InstanceFragmentBehavior=natv2InstanceFragmentBehavior, Natv2PoolIndex=Natv2PoolIndex, natv2MIBConformance=natv2MIBConformance, natv2InstancePortMapFailureDrops=natv2InstancePortMapFailureDrops, natv2PoolAddressMapFailureDrops=natv2PoolAddressMapFailureDrops, natv2PortMapEntry=natv2PortMapEntry, natv2CGNNotificationGroup=natv2CGNNotificationGroup, natv2SubscriberPortMapFailureDrops=natv2SubscriberPortMapFailureDrops, natv2AddressMapRowIndex=natv2AddressMapRowIndex, natv2NotificationPoolUsageHigh=natv2NotificationPoolUsageHigh, Natv2SubscriberIndexOrZero=Natv2SubscriberIndexOrZero, Natv2InstanceIndex=Natv2InstanceIndex, natv2InstanceEntry=natv2InstanceEntry, natv2ProtocolInstanceIndex=natv2ProtocolInstanceIndex, natv2PortMapInternalPort=natv2PortMapInternalPort, natv2InstancePortMappingBehavior=natv2InstancePortMappingBehavior, natv2AddressMapInternalAddressType=natv2AddressMapInternalAddressType, natv2SubscriberInternalPrefixLength=natv2SubscriberInternalPrefixLength, natv2InstanceAddressMapCreations=natv2InstanceAddressMapCreations, natv2AddressMapInstanceIndex=natv2AddressMapInstanceIndex, natv2PortMapSubscriberIndex=natv2PortMapSubscriberIndex, natv2AddressMapSubscriberIndex=natv2AddressMapSubscriberIndex, natv2PoolTable=natv2PoolTable, natv2PortMapExternalPoolIndex=natv2PortMapExternalPoolIndex, ProtocolNumber=ProtocolNumber, Natv2SubscriberIndex=Natv2SubscriberIndex, natv2CGNInstanceLevelGroup=natv2CGNInstanceLevelGroup, natv2PooledNotificationGroup=natv2PooledNotificationGroup, natv2PortMapInternalMappedAddress=natv2PortMapInternalMappedAddress, natv2InstanceNotificationInterval=natv2InstanceNotificationInterval, natv2BasicInstanceLevelGroup=natv2BasicInstanceLevelGroup, natv2MIBCGNCompliance=natv2MIBCGNCompliance, PYSNMP_MODULE_ID=natv2MIB, natv2SubscriberLimitPortMapEntries=natv2SubscriberLimitPortMapEntries)

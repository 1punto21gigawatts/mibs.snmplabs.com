#
# PySNMP MIB module NetWare-Host-Ext-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NetWare-Host-Ext-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:25:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
hrDeviceIndex, = mibBuilder.importSymbols("HOST-RESOURCES-MIB", "hrDeviceIndex")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, IpAddress, Integer32, Bits, enterprises, Counter64, ModuleIdentity, Unsigned32, MibIdentifier, Gauge32, NotificationType, iso, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "IpAddress", "Integer32", "Bits", "enterprises", "Counter64", "ModuleIdentity", "Unsigned32", "MibIdentifier", "Gauge32", "NotificationType", "iso", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class TransportDomain(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("noAddress", 1), ("ipx", 2), ("ip", 3), ("appleTalkDDP", 4))

class TransportAddress(OctetString):
    pass

novell = MibIdentifier((1, 3, 6, 1, 4, 1, 23))
mibDoc = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2))
nwHostExtensions = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27))
nwhrStorage = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2))
nwhrDevice = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 3))
nwhrOdi = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 10))
nwhrStorageTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1))
nwhrStorageVolume = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 1))
nwhrStorageMemoryPermanent = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 2))
nwhrStorageMemoryAlloc = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 3))
nwhrStorageCacheBuffers = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 4))
nwhrStorageCacheMovable = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 5))
nwhrStorageCacheNonMovable = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 6))
nwhrStorageCodeAndDataMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 7))
nwhrStorageDOSMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 8))
nwhrStorageIOEngineMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 9))
nwhrStorageMSEngineMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 10))
nwhrStorageUnclaimedMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 2, 1, 11))
nwhrDeviceTypes = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 1))
nwhrDeviceMirroredServerLink = MibIdentifier((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 1, 1))
class KBytes(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

class InternationalDisplayString(OctetString):
    pass

nwhrDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 2), )
if mibBuilder.loadTexts: nwhrDeviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDeviceTable.setDescription('Extensions to the (conceptual) table of devices contained by the host')
nwhrDeviceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 2, 1), ).setIndexNames((0, "HOST-RESOURCES-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: nwhrDeviceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDeviceEntry.setDescription('Extensions to a (conceptual) entry for one device contained by the host')
nwhrDeviceAdapterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDeviceAdapterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDeviceAdapterIndex.setDescription('The index into the nwhrAdapterTable of the adapter/controller to which this device is attached (or physically manifested by, for logical device). Zero if not applicable.')
nwhrDeviceControllerNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDeviceControllerNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDeviceControllerNumber.setDescription('The controller number (relative to its adapter), or the SCSI target ID, or zero if not applicable. Note that zero is a valid value for both controller number and SCSI Target ID.')
nwhrDeviceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDeviceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDeviceNumber.setDescription('The device number (relative to its controller), or the SCSI LUN (Logical Unit Number), or zero if not applicable. Note that zero is a valid value for both device number and SCSI LUN.')
nwhrProcessorCount = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProcessorCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProcessorCount.setDescription('The number of processor devices contained in this host')
nwhrPrinterCount = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterCount.setDescription('The number of printer devices contained in this host')
nwhrDiskStorageCount = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDiskStorageCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageCount.setDescription('The number of Disk Storage devices contained in this host.')
nwhrDiskStorageTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 6), )
if mibBuilder.loadTexts: nwhrDiskStorageTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageTable.setDescription('Extensions to the hrDiskStorageTable')
nwhrDiskStorageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 6, 1), ).setIndexNames((0, "HOST-RESOURCES-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: nwhrDiskStorageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageEntry.setDescription('Extensions to the hrDiskStorageEntry')
nwhrDiskStorageHeads = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDiskStorageHeads.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageHeads.setDescription('The number of read/write heads on the drive')
nwhrDiskStorageCylinders = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDiskStorageCylinders.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageCylinders.setDescription('The number of cylinders on the drive.')
nwhrDiskStorageSectorsPerTrack = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDiskStorageSectorsPerTrack.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageSectorsPerTrack.setDescription('The number of sectors per track on the drive.')
nwhrDiskStorageSectorSize = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDiskStorageSectorSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageSectorSize.setDescription('The size of a sector in bytes.')
nwhrDiskStorageBlockSize = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrDiskStorageBlockSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrDiskStorageBlockSize.setDescription('The driver maximum I/O request size in bytes.')
nwhrPhysicalPartitionTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 7), )
if mibBuilder.loadTexts: nwhrPhysicalPartitionTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPhysicalPartitionTable.setDescription('A table of physical partitions for long-term storage devices contained by the host.')
nwhrPhysicalPartitionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 7, 1), ).setIndexNames((0, "HOST-RESOURCES-MIB", "hrDeviceIndex"), (0, "NetWare-Host-Ext-MIB", "nwhrPhysicalPartitionIndex"))
if mibBuilder.loadTexts: nwhrPhysicalPartitionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPhysicalPartitionEntry.setDescription('An entry for one partition. The hrDeviceIndex in the index represents the entry in the hrDeviceTable that corresponds to the nwhrPhysicalPartitionEntry.')
nwhrPhysicalPartitionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPhysicalPartitionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPhysicalPartitionIndex.setDescription('A unique value for each physical partition on this long-term storage device. The value for each long-term storage device must remain constant from one re- initialization of the agent to the next re- initialization.')
nwhrPhysicalPartitionType = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("netWare", 2), ("dos", 3), ("inwDos", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPhysicalPartitionType.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPhysicalPartitionType.setDescription('The type of this physical partition.')
nwhrPhysicalPartitionDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 7, 1, 3), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPhysicalPartitionDescr.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPhysicalPartitionDescr.setDescription('A textual description of this partition.')
nwhrPhysicalPartitionSize = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 7, 1, 4), KBytes()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPhysicalPartitionSize.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPhysicalPartitionSize.setDescription('The size (in Kilobytes) of this physical partition.')
nwhrHotfixTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 8), )
if mibBuilder.loadTexts: nwhrHotfixTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrHotfixTable.setDescription("The table of hotfix areas of diskStorage devices contained by the host. Note that this table is potentially sparse: an entry exists if the corresponding value of the hrDeviceType object is `hrDeviceDiskStorage' and a NetWare partition exists on the device.")
nwhrHotfixEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 8, 1), ).setIndexNames((0, "HOST-RESOURCES-MIB", "hrDeviceIndex"), (0, "NetWare-Host-Ext-MIB", "nwhrPhysicalPartitionIndex"))
if mibBuilder.loadTexts: nwhrHotfixEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrHotfixEntry.setDescription('An entry for one hotfix redirection area contained by the host.')
nwhrHotfixUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrHotfixUnits.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrHotfixUnits.setDescription('The size, in bytes, of the hotfix blocks.')
nwhrHotfixTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 8, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrHotfixTotal.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrHotfixTotal.setDescription('The size of the total hotfix redirection area represented by this entry, in units of nwhrHotfixUnits.')
nwhrHotfixUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 8, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrHotfixUsed.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrHotfixUsed.setDescription('The number of hotfix redirected blocks, i.e. the number of bad blocks that hotfix has found.')
nwhrHotfixReserved = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 8, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrHotfixReserved.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrHotfixReserved.setDescription('The number of hotfix redirection blocks reserved for system use.')
nwhrAdapterCount = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterCount.setDescription('The number of adapters contained in this host.')
nwhrAdapterTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10), )
if mibBuilder.loadTexts: nwhrAdapterTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterTable.setDescription('General information for each adapter board in the host: driver name and version, Interrupt, DMA, I/O address, and number of attached devices.')
nwhrAdapterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1), ).setIndexNames((0, "NetWare-Host-Ext-MIB", "nwhrAdapterIndex"))
if mibBuilder.loadTexts: nwhrAdapterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterEntry.setDescription('General information for a particular adapter board in the host: driver name and version, Interrupt, DMA, I/O address, and number of attached devices.')
nwhrAdapterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterIndex.setDescription('A unique value for each adapter contained in the host. The value for each adapter must remain constant at least from one re-initialization of the agent to the next re-initialization.')
nwhrAdapterType = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterType.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterType.setDescription('An indication of the type of adapter. This will typically be one of the possible values of hrDeviceType.')
nwhrAdapterDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 3), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterDescr.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterDescr.setDescription('A description the hardware for this adapter. This will usually include manufacturer, model, and version information. For LAN adapters, this could include the short board name and the boards burnt-in MAC address.')
nwhrAdapterDriverDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 4), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterDriverDescr.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterDriverDescr.setDescription('A textual description of the driver for this adapter')
nwhrAdapterDriverMajorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterDriverMajorVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterDriverMajorVer.setDescription('The major version number of the adapter driver.')
nwhrAdapterDriverMinorVer = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterDriverMinorVer.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterDriverMinorVer.setDescription('The minor version number of the adapter driver.')
nwhrAdapterPort1 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterPort1.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterPort1.setDescription('The primary I/O port block. This is the base address of a block of I/O addresses decoded by the adapter. The value will be zero if there is no I/O address associated with this adapter.')
nwhrAdapterPort1Len = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterPort1Len.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterPort1Len.setDescription('The number of I/O ports in the block starting at nwhrAdapterPort1. This value is used in conjunction with nwhrAdapterPort1 to determine the I/O block used by the adapter. The value will be zero if there is no I/O address associated with this adapter.')
nwhrAdapterPort2 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterPort2.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterPort2.setDescription('The secondary I/O port block. This is the base address of a block of I/O addresses decoded by the adapter. The value will be zero if there is no secondary I/O address associated with this adapter.')
nwhrAdapterPort2Len = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterPort2Len.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterPort2Len.setDescription('The number of I/O ports in the block starting at nwhrAdapterPort2. This value is used in conjunction with nwhrAdapterPort2 to determine the secondary I/O block used by the adapter. The value will be zero if there is no I/O address associated with this adapter.')
nwhrAdapterMem1 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterMem1.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterMem1.setDescription('The primary Memory Address. This is the base address of the primary block of memory space decoded by the adapter. The value will be zero if there is no memory address associated with this adapter.')
nwhrAdapterMem1Len = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterMem1Len.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterMem1Len.setDescription('The length, in bytes, of the primary memory address block. From this value and nwhrAdapterMem1, a determination can be made as to which memory address ranges are in use by the adapter.')
nwhrAdapterMem2 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterMem2.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterMem2.setDescription('The secondary Memory Address. This is the address of the secondary block of memory space decoded by the adapter. The value will be zero if there is no secondary memory address associated with this adapter.')
nwhrAdapterMem2Len = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterMem2Len.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterMem2Len.setDescription('The length, in bytes, of the secondary memory address block. From this value and nwhrAdapterMem2, a determination can be made as to which memory address ranges are in use by the adapter.')
nwhrAdapterDMA1 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterDMA1.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterDMA1.setDescription('The primary DMA channel used by the adapter. The value will be 255 if this adapter does not use any DMA channel.')
nwhrAdapterDMA2 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterDMA2.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterDMA2.setDescription('The secondary DMA channel used by the adapter. The value will be 255 if this adapter does not use a secondary DMA channel.')
nwhrAdapterInterrupt1 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterInterrupt1.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterInterrupt1.setDescription('The primary interrupt vector used by the adapter. The value will be 255 if this adapter does not use any Interrupt.')
nwhrAdapterInterrupt2 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterInterrupt2.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterInterrupt2.setDescription('The secondary interrupt vector used by the adapter. The value will be 255 if this adapter does not use a secondary Interrupt.')
nwhrAdapterSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterSlot.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterSlot.setDescription('The slot in which the adapter resides. The value will be zero if the slot information is not available on the platform, such as an ISA based PC, otherwise the value will be the slot number the adapter resides. The slot number starts from 1.')
nwhrAdapterDevices = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 10, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrAdapterDevices.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrAdapterDevices.setDescription('The number of devices associated with this adapter. For instance, the number of drives attached to a disk controller.')
nwhrMslCount = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrMslCount.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslCount.setDescription('The number of Mirrored Server Link (MSL) devices contained in this host.')
nwhrMslTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12), )
if mibBuilder.loadTexts: nwhrMslTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslTable.setDescription('The (conceptual) table of Mirrored Server Link (MSL) devices contained by the host. Note that this table is potentially sparse: a (conceptual) entry exists only if the corresponding value of the hrDeviceType object is nwhrDeviceMirroredServerLink')
nwhrMslEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12, 1), ).setIndexNames((0, "HOST-RESOURCES-MIB", "hrDeviceIndex"))
if mibBuilder.loadTexts: nwhrMslEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslEntry.setDescription(' A (conceptual) entry for one Mirrored Server Link (MSL) device contained by the host. The hrDeviceIndex in the index represents the entry in the hrDeviceTable that corresponds to the nwhrMslEntry.')
nwhrMslState = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("offline", 1), ("startup", 2), ("standby", 3), ("active", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrMslState.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslState.setDescription('The current state of this MSL device.')
nwhrMslSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrMslSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslSpeed.setDescription('The nominal bandwidth of the MSL link in bits per second.')
nwhrMslSends = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrMslSends.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslSends.setDescription('The number of sends from this MSL device.')
nwhrMslReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrMslReceives.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslReceives.setDescription('The number of receives by this MSL device.')
nwhrMslInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrMslInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslInErrors.setDescription('The number of errors in receives by this MSL device.')
nwhrMslOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 12, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrMslOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrMslOutErrors.setDescription('The number of errors on sends by this MSL device.')
nwhrPrinterTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13), )
if mibBuilder.loadTexts: nwhrPrinterTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterTable.setDescription('A set of data for each accessible printer, whether local or remote.')
nwhrPrinterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1), ).setIndexNames((0, "NetWare-Host-Ext-MIB", "nwhrPrinterID"))
if mibBuilder.loadTexts: nwhrPrinterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterEntry.setDescription('A set of data for a particular printer.')
nwhrPrinterID = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterID.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterID.setDescription('A unique value for each accessible printer. This value will be constant for the lifetime of the mapping.')
nwhrPrinterType = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("local", 2), ("netware", 3), ("unixware", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterType.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterType.setDescription('The type of the printer.')
nwhrPrinterLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 3), InternationalDisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterLocalName.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterLocalName.setDescription('The local name for the printer.')
nwhrPrinterQueueName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 4), InternationalDisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterQueueName.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterQueueName.setDescription('The name of the print queue associated with this printer. Zero length string if printer is local.')
nwhrPrinterServerName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 5), InternationalDisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterServerName.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterServerName.setDescription('The name of the server containing the print queue. Zero length string if printer is local.')
nwhrPrinterTransportDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 6), TransportDomain()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterTransportDomain.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterTransportDomain.setDescription('The transport domain associated with the printer (print queue).')
nwhrPrinterTransportAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 7), TransportAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterTransportAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterTransportAddress.setDescription('The transport address associated with this printer (print queue). Zero length string if printer is local.')
nwhrPrinterDeviceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 3, 13, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrPrinterDeviceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrPrinterDeviceIndex.setDescription('The value of hrDeviceIndex for this printer. Zero if non-local.')
nwhrLslOutPkts = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrLslOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrLslOutPkts.setDescription('The total number of of SendPacket requests made to the LSL.')
nwhrLslInPkts = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrLslInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrLslInPkts.setDescription('The total number of GetStackECB requests made by MLIDs to the LSL.')
nwhrLslUnclaimedPkts = MibScalar((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrLslUnclaimedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrLslUnclaimedPkts.setDescription('The total number of times a packet was received and not consumed by a protocol stack.')
nwhrProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4), )
if mibBuilder.loadTexts: nwhrProtocolTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolTable.setDescription('The Protocol Table provides basic information about protocols running in the host, management stations should refer to the appropriate protocol MIBs for the details about each protocol.')
pysmiFakeCol1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1) + (1000, ), Integer32())
nwhrProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1), ).setIndexNames((0, "NetWare-Host-Ext-MIB", "pysmiFakeCol1000"), (0, "NetWare-Host-Ext-MIB", "nwhrProtocolName"))
if mibBuilder.loadTexts: nwhrProtocolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolEntry.setDescription('Information about a particular protocol.')
nwhrProtocolName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1, 1), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProtocolName.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolName.setDescription('The protocol name, for example, IPX, IP, ARP.')
nwhrProtocolID = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProtocolID.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolID.setDescription('The protocol identifier For example: 000000000800 - IP for Ethernet II 00080007809B - AppleTalk for Ethernet SNAP')
nwhrProtocolAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1, 3), InternationalDisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProtocolAddress.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolAddress.setDescription('This object provides protocol address information, for example, the Network Address on IPX network, the IP address on IP network. Note there is no format in the InternationalDisplayString and the information is not guaranteed available.')
nwhrProtocolOutPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProtocolOutPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolOutPkts.setDescription('The total number of send packet requests made to the LSL.')
nwhrProtocolInPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProtocolInPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolInPkts.setDescription('The total number of incoming packets that were consumed by the protocol.')
nwhrProtocolIgnoredPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProtocolIgnoredPkts.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolIgnoredPkts.setDescription('The total number of times the protocol receive handler was called with look ahead and the protocol did not return a receive ECB to the MLID to receive the packet')
nwhrProtocolFullName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 4, 1, 7), InternationalDisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrProtocolFullName.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrProtocolFullName.setDescription("The full name of the protocol name, for example, 'DOD Internet Protocol'.")
nwhrIfTable = MibTable((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 5), )
if mibBuilder.loadTexts: nwhrIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrIfTable.setDescription("Extensions to MIB-II's Interfaces table to add some NetWare specific info.")
pysmiFakeCol1001 = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 5, 1) + (1001, ), Integer32())
nwhrIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 5, 1), ).setIndexNames((0, "NetWare-Host-Ext-MIB", "pysmiFakeCol1001"))
if mibBuilder.loadTexts: nwhrIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrIfEntry.setDescription('NetWare specific info for a particular interface.')
nwhrIfLogicalBoardNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrIfLogicalBoardNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrIfLogicalBoardNumber.setDescription('The logical board number.')
nwhrIfFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 5, 1, 2), InternationalDisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrIfFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrIfFrameType.setDescription('The frame type for this logical board.')
nwhrIfLogicalBoardName = MibTableColumn((1, 3, 6, 1, 4, 1, 23, 2, 27, 10, 5, 1, 3), InternationalDisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 18))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nwhrIfLogicalBoardName.setStatus('mandatory')
if mibBuilder.loadTexts: nwhrIfLogicalBoardName.setDescription('The name assigned to this logical board.')
mibBuilder.exportSymbols("NetWare-Host-Ext-MIB", nwhrProtocolFullName=nwhrProtocolFullName, nwhrHotfixUnits=nwhrHotfixUnits, nwhrAdapterTable=nwhrAdapterTable, nwhrIfEntry=nwhrIfEntry, nwhrAdapterInterrupt1=nwhrAdapterInterrupt1, nwhrDeviceEntry=nwhrDeviceEntry, nwhrPhysicalPartitionType=nwhrPhysicalPartitionType, TransportDomain=TransportDomain, nwhrPrinterDeviceIndex=nwhrPrinterDeviceIndex, nwhrPhysicalPartitionEntry=nwhrPhysicalPartitionEntry, nwhrLslOutPkts=nwhrLslOutPkts, nwhrAdapterType=nwhrAdapterType, nwhrMslSpeed=nwhrMslSpeed, nwhrDiskStorageEntry=nwhrDiskStorageEntry, nwhrAdapterPort1Len=nwhrAdapterPort1Len, nwhrAdapterDevices=nwhrAdapterDevices, nwhrMslState=nwhrMslState, nwhrDiskStorageBlockSize=nwhrDiskStorageBlockSize, nwhrAdapterIndex=nwhrAdapterIndex, nwhrProtocolTable=nwhrProtocolTable, nwhrAdapterPort2Len=nwhrAdapterPort2Len, nwhrDeviceNumber=nwhrDeviceNumber, nwhrAdapterCount=nwhrAdapterCount, nwhrHotfixUsed=nwhrHotfixUsed, nwhrDiskStorageTable=nwhrDiskStorageTable, nwhrDeviceControllerNumber=nwhrDeviceControllerNumber, nwhrStorageCacheMovable=nwhrStorageCacheMovable, nwhrProtocolIgnoredPkts=nwhrProtocolIgnoredPkts, nwhrMslSends=nwhrMslSends, pysmiFakeCol1001=pysmiFakeCol1001, nwhrDeviceTypes=nwhrDeviceTypes, nwHostExtensions=nwHostExtensions, nwhrAdapterMem2Len=nwhrAdapterMem2Len, nwhrLslInPkts=nwhrLslInPkts, nwhrProcessorCount=nwhrProcessorCount, nwhrAdapterInterrupt2=nwhrAdapterInterrupt2, nwhrPrinterType=nwhrPrinterType, nwhrAdapterPort1=nwhrAdapterPort1, nwhrPrinterLocalName=nwhrPrinterLocalName, nwhrAdapterDriverMinorVer=nwhrAdapterDriverMinorVer, nwhrProtocolAddress=nwhrProtocolAddress, nwhrLslUnclaimedPkts=nwhrLslUnclaimedPkts, nwhrAdapterSlot=nwhrAdapterSlot, nwhrPrinterQueueName=nwhrPrinterQueueName, nwhrPhysicalPartitionDescr=nwhrPhysicalPartitionDescr, TransportAddress=TransportAddress, nwhrStorageDOSMemory=nwhrStorageDOSMemory, nwhrStorageVolume=nwhrStorageVolume, nwhrProtocolID=nwhrProtocolID, nwhrPrinterServerName=nwhrPrinterServerName, nwhrMslCount=nwhrMslCount, nwhrDeviceMirroredServerLink=nwhrDeviceMirroredServerLink, nwhrStorageCacheNonMovable=nwhrStorageCacheNonMovable, novell=novell, nwhrProtocolEntry=nwhrProtocolEntry, nwhrPhysicalPartitionTable=nwhrPhysicalPartitionTable, nwhrOdi=nwhrOdi, nwhrStorage=nwhrStorage, nwhrPhysicalPartitionIndex=nwhrPhysicalPartitionIndex, nwhrAdapterMem2=nwhrAdapterMem2, nwhrHotfixTotal=nwhrHotfixTotal, nwhrStorageIOEngineMemory=nwhrStorageIOEngineMemory, nwhrAdapterMem1=nwhrAdapterMem1, nwhrMslTable=nwhrMslTable, nwhrStorageCacheBuffers=nwhrStorageCacheBuffers, nwhrHotfixEntry=nwhrHotfixEntry, nwhrDiskStorageCylinders=nwhrDiskStorageCylinders, mibDoc=mibDoc, nwhrIfLogicalBoardName=nwhrIfLogicalBoardName, nwhrPrinterTransportDomain=nwhrPrinterTransportDomain, nwhrDiskStorageSectorsPerTrack=nwhrDiskStorageSectorsPerTrack, nwhrDeviceAdapterIndex=nwhrDeviceAdapterIndex, nwhrAdapterDMA1=nwhrAdapterDMA1, nwhrDiskStorageCount=nwhrDiskStorageCount, nwhrPrinterEntry=nwhrPrinterEntry, nwhrProtocolOutPkts=nwhrProtocolOutPkts, nwhrMslInErrors=nwhrMslInErrors, nwhrAdapterDMA2=nwhrAdapterDMA2, nwhrStorageCodeAndDataMemory=nwhrStorageCodeAndDataMemory, KBytes=KBytes, nwhrAdapterDescr=nwhrAdapterDescr, nwhrAdapterDriverMajorVer=nwhrAdapterDriverMajorVer, nwhrPrinterID=nwhrPrinterID, nwhrStorageUnclaimedMemory=nwhrStorageUnclaimedMemory, nwhrPrinterCount=nwhrPrinterCount, nwhrMslReceives=nwhrMslReceives, nwhrMslOutErrors=nwhrMslOutErrors, nwhrDiskStorageHeads=nwhrDiskStorageHeads, nwhrPhysicalPartitionSize=nwhrPhysicalPartitionSize, nwhrAdapterEntry=nwhrAdapterEntry, nwhrIfTable=nwhrIfTable, InternationalDisplayString=InternationalDisplayString, nwhrProtocolName=nwhrProtocolName, nwhrDeviceTable=nwhrDeviceTable, nwhrHotfixReserved=nwhrHotfixReserved, nwhrDiskStorageSectorSize=nwhrDiskStorageSectorSize, nwhrPrinterTable=nwhrPrinterTable, nwhrMslEntry=nwhrMslEntry, nwhrStorageMemoryAlloc=nwhrStorageMemoryAlloc, nwhrDevice=nwhrDevice, nwhrPrinterTransportAddress=nwhrPrinterTransportAddress, pysmiFakeCol1000=pysmiFakeCol1000, nwhrHotfixTable=nwhrHotfixTable, nwhrStorageMSEngineMemory=nwhrStorageMSEngineMemory, nwhrAdapterDriverDescr=nwhrAdapterDriverDescr, nwhrProtocolInPkts=nwhrProtocolInPkts, nwhrIfLogicalBoardNumber=nwhrIfLogicalBoardNumber, nwhrStorageTypes=nwhrStorageTypes, nwhrStorageMemoryPermanent=nwhrStorageMemoryPermanent, nwhrIfFrameType=nwhrIfFrameType, nwhrAdapterMem1Len=nwhrAdapterMem1Len, nwhrAdapterPort2=nwhrAdapterPort2)

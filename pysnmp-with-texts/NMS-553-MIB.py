#
# PySNMP MIB module NMS-553-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NMS-553-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:21:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
gdc, = mibBuilder.importSymbols("GDCCMN-MIB", "gdc")
SCinstance, = mibBuilder.importSymbols("GDCMACRO-MIB", "SCinstance")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, ModuleIdentity, Integer32, Gauge32, iso, MibIdentifier, Counter64, Counter32, Unsigned32, IpAddress, TimeTicks, ObjectIdentity, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "ModuleIdentity", "Integer32", "Gauge32", "iso", "MibIdentifier", "Counter64", "Counter32", "Unsigned32", "IpAddress", "TimeTicks", "ObjectIdentity", "Bits")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
dsx1 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6))
nms553 = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7))
nms553Version = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 1))
nms553DS0Allocation = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 2))
nms553Configuration = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 3))
nms553DteStatus = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 4))
nms553Diagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 5))
nms553Maintenance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 6))
nms553Alarms = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7))
nms553AlarmHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 8))
nms553Performance = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 9))
nms553MIBversion = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 7, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(5, 5)).setFixedLength(5)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553MIBversion.setStatus('mandatory')
if mibBuilder.loadTexts: nms553MIBversion.setDescription("Identifies the version of the MIB. The format of the version is x.yzT, where 'x' identifies the major revision number, 'y' identifies the minor revision number, 'z' identifies the typographical revision, and T identifies the test revision. Upon formal release, no designation for the test revision will be present. Acceptable values for the individual revision components are as follows: x: 1 - 9, y: 0 - 9, z: 0 - 9, T: A - Z")
nms553VersionTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 1, 2), )
if mibBuilder.loadTexts: nms553VersionTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553VersionTable.setDescription(' ')
nms553VersionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 1, 2, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553VersionIndex"))
if mibBuilder.loadTexts: nms553VersionEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553VersionEntry.setDescription('An entry in the GDC NMS 553 Version Table.')
nms553VersionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 1, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553VersionIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553VersionIndex.setDescription('Identifies Version parameters associated with the managed object.')
nms553FirmwareRev = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 1, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553FirmwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: nms553FirmwareRev.setDescription('The version number of the firmware, to allow products to know which revision is installed. The released version number is sequenced from --, A-, ... AA, ... ZZ. Test versions are numerical from 01 to 99.')
nms553DS0AllocationSchemeTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 1), )
if mibBuilder.loadTexts: nms553DS0AllocationSchemeTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationSchemeTable.setDescription('The GDC NMS 553 DS0 allocation table')
nms553DS0AllocationSchemeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 1, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553DS0AllocationSchemeIndex"))
if mibBuilder.loadTexts: nms553DS0AllocationSchemeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationSchemeEntry.setDescription('The GDC NMS 553 Configuration table entry.')
nms553DS0AllocationSchemeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553DS0AllocationSchemeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationSchemeIndex.setDescription('The index value which uniquely identifies the DSU to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier. The sub-identifier for this SC instance is the DSU.')
nms553DS0AllocationScheme = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("consecutive", 1), ("alternate", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DS0AllocationScheme.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationScheme.setDescription('Identifies the DSU DS0 allocation scheme.The value consecutive(2) indicates that bundles of DS0s are allocated to channels consecutively from the starting DS0. The value of alternate(3) indicates that bundles of DS0s are allocated to channels alternatly, or every other DS0 from the starting DS0. The unused DS0s are forced to marks. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
nms553DS0AllocationConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 2), )
if mibBuilder.loadTexts: nms553DS0AllocationConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationConfigTable.setDescription('The GDC DS0 Allocation Configuration table. Information in the entries of this table define the configuration of DS0 allocation for channels. There are entries in this table for each channel of the associated DSU.')
nms553DS0AllocationConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 2, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553DS0AllocationConfigIndex"))
if mibBuilder.loadTexts: nms553DS0AllocationConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationConfigEntry.setDescription('The GDC DS0 Allocation Configuration table entry.')
nms553DS0AllocationConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553DS0AllocationConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationConfigIndex.setDescription('The index value which uniquely identifies the channel to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier. The sub-indentifier for this SCinstance is the channel.')
nms553DS0AllocationBaseRate = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nx56k", 1), ("nx64k", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DS0AllocationBaseRate.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationBaseRate.setDescription('Indicates the DS0 base rate: either 56K or 64K bits per second. This is used in conjunction with the number of DS0s to determine the bandwidth of the channel. Note that base rate of 64K defines the DS0 as clear channel in which all 8 bits of the DS0 are used. A base rate of 56K defines the DS0 as non-clear in which bits 1-7 are used for channel data and the 8th bit is either unused and forced to marks or used to pass signaling information.')
nms553DS0AllocationStartingDS0 = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DS0AllocationStartingDS0.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationStartingDS0.setDescription('Indicates the starting DS0 number for the bundle of DS0s used for the channel. DS0 bundles are allocated starting at the DS0 defined by this integer. When this integer is set to 0, the channel is disabled and no DS0s are allocated to the channel. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
nms553DS0AllocationNumberOfDS0s = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 24))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DS0AllocationNumberOfDS0s.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationNumberOfDS0s.setDescription('Indicates the number of DS0s for the bundle allocated to the channel. The number of DS0s, in conjunction with the DS0 base rate, also determines the bandwidth of the channel. Note that DS0 bundles cannot be split across frames (wrap around from the highest numbered DS0 of one frame to DS0 1 of the next frame. For example, on a T1 frame using consecutive DS0 allocation, a channel configuration of starting DS0 = 20 and number of DS0s = 5 is an illegal channel configuration because the DS0 bundle wraps from DS0 #24 of 1 frame to DS0 #1 of the next.')
nms553DS0AllocationInbandDccMode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 2, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("embedded", 2), ("dccDs0", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DS0AllocationInbandDccMode.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DS0AllocationInbandDccMode.setDescription("The mode of propagation of inband Diagnostics Communication Channel to the dedicated remote NMS553 unit. None specifies no inband DCC. Embedded is an allowed value when the mib object nms553DS0BaseRate is set to Nx56K, and specifies that DCC is propagated in the 8th bit of the assigned DS0's. dccDs0 specifies that a DS0 is used for propagation of DCC, this value would be selected if the nms553DS0BaseRate is Nx64k (clear channel) since all data bits are used for user data, a minimum of two DS0's must be assigned to this device in this mode, the last ds0 should be set as the nms553DccDs0 when using this mode.")
nms553ChannelConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1), )
if mibBuilder.loadTexts: nms553ChannelConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelConfigTable.setDescription('The GDC 553 Channel Configuration table.')
nms553ChannelConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553ChannelConfigIndex"))
if mibBuilder.loadTexts: nms553ChannelConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelConfigEntry.setDescription('The nms553 Channel Configuration table entry.')
nms553ChannelConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553ChannelConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelConfigIndex.setDescription('The index value which uniquely identifies the channel to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier. The sub-indentifier for this SCinstance is the channel.')
nms553ChannelSplitTiming = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelSplitTiming.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelSplitTiming.setDescription("Indicates whether or not to use split timing. The value disabled(1) indicates that channel's transmit timing is provided by the DSU. The value enabled(2) indicates that the channel's transmit timing is provided by the customer business equipment (ext Tx Clk). Split timing refers to the activation of elastic storage to allow the channel interface to receive data using the customer business equipment's timing source (ext Tx Clk) and transmit that same data to the network using the networks timing source.")
nms553ChannelChannelType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("v35", 2), ("eia530", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553ChannelChannelType.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelChannelType.setDescription('The channel interface type. The value none(1) indicates that there is no channel interface for the index. The value v35(2) indicates the channel interface is standard V.35 and the value eia530(3) indicates the channel interface is standard EIA 530.')
nms553ChannelClockInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("txClockNormRxClockNorm", 1), ("txClockNormRxClockInvert", 2), ("txClockInvertRxClockNorm", 3), ("txClockInvertRxClockInvert", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelClockInvert.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelClockInvert.setDescription('Clock invert option')
nms553ChannelDataInvert = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("txDataNormRxDataNorm", 1), ("txDataNormRxDataInvert", 2), ("txDataInvertRxDataNorm", 3), ("txDataInvertRxDataInvert", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelDataInvert.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelDataInvert.setDescription('Data invert option')
nms553ChannelLocalDCD = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("followsSignal", 1), ("forcedOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelLocalDCD.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelLocalDCD.setDescription("Controls the operation of Data Carrier Detect (DCD) signal. The value followsSignal(1) indicates that the channel's DCD follows the inband control mode idle (CMI). The value forcedOn(2) indicates that DCD is forced on.")
nms553ChannelLocalDSR = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("followsSignal", 1), ("forcedOn", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelLocalDSR.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelLocalDSR.setDescription("Controls the operation of the Data Set Ready (DSR) signal. The value followsSignal(1) indicates that the channel's DSR follows the inband control mode idle (CMI). The value forcedOn(2) indicates that DSR is forced on.")
nms553ChannelFlowControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("txRtsRxDcd", 1), ("txRtsRxDsr", 2), ("txDtrRxDcd", 3), ("txDtrRxDsr", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelFlowControl.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelFlowControl.setDescription('Flow Control Option. This object is valid only when the control mode idle object nms553ChannelControlModeIdle is set to enabled(2).')
nms553ChannelRTSCTSControl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ctsDelay10ms", 1), ("ctsOn", 2), ("ctsDelayStandard", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelRTSCTSControl.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelRTSCTSControl.setDescription("Controls the function of the channel's Request To Send (RTS) and Clear To Send signals used for flow control. The value of ctsDelay10ms(1) indicates that CTS is to respond to RTS after a 10ms delay. The value of ctsOn(2) indicates that CTS is forced on at all times. The value of ctsDelayStandard(3) indicates that CTS is to respond to RTS after the standard delay of 40 bits times. For 56Kbps applications using CMI flow control, this object must be set for ctsDelayStandard(3).")
nms553ChannelEIAtestLeads = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelEIAtestLeads.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelEIAtestLeads.setDescription("Controls the channel's EIA test leads. The EIA test leads allow customer business equipment to initiate diagnostic tests through the assertion of the EIA test leads RDL, LL, and ST. When this object is enabled(1), then the assertion of these leads is recognized and acted upon by the DSU. When this object is disabled(2), then the assertion of these leads is ignored by the DSU.")
nms553ChannelInbandLoop = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disable", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelInbandLoop.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelInbandLoop.setDescription('In-band loopcode enable/disable. The value disabled(1) indicates the channel does not enter an RDL loop when an inband RDL code is detected. The value enable(2) indicates the channel does enter an RDL loop when an inband RDL code is detected.')
nms553ChannelInbandLoopCode = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("pn127", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553ChannelInbandLoopCode.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelInbandLoopCode.setDescription('In-band RDL code to send and/or receive by the channel. The value pn127(1) indicates that the in-band code sent/received is in accordance with CCITT V.54 PN-127 scrambled codes.')
nms553ChannelInbandLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inhibit", 1), ("enable10Min", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelInbandLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelInbandLoopdown.setDescription("The time limit in seconds before terminating a channel's RDL. The value inhibit(1) indicates that the loopdown time is disabled and the loopback will only terminate by the in-band loopdown code. The value enable10Min(2) indicates the time before terminating the RDL in the event the loopdown code is never received.")
nms553ChannelControlModeIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ChannelControlModeIdle.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ChannelControlModeIdle.setDescription('Control Mode Idle (CMI) enable/disable. When the channel application is Nx56k and RTS/CTS delay is standard, then this object defines the the use of CMI to provide flow control. The value disabled(1) indicates the channel using CMI to pass control flow information. The value enabled(2) indicates the channel is using the DDS secondary channel CMI format to pass flow control information.')
nms553NetworkConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2), )
if mibBuilder.loadTexts: nms553NetworkConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkConfigTable.setDescription('The GDC 553 Network Configuration table.')
nms553NetworkConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553NetworkConfigIndex"))
if mibBuilder.loadTexts: nms553NetworkConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkConfigEntry.setDescription('The nms553 Network Configuration table entry.')
nms553NetworkConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553NetworkConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier.')
nms553NetworkAdminLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("auto", 1), ("manEsf", 2), ("manD4", 3), ("unframed", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkAdminLineType.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkAdminLineType.setDescription("The values, in sequence, describe: 'auto' indicates the unit will determine framing. 'manEsf' indicates manual selection of extended superframe format. 'manD4'indicates manual selection of D4 framing format. 'unframed' indicates manual selection of unframed format.")
nms553NetworkOperLineType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manEsf", 1), ("manD4", 2), ("unframed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553NetworkOperLineType.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkOperLineType.setDescription("The values, in sequence, describe: 'manEsf' indicates the current setting of Line type. 'manD4'indicates the current setting of Line type. 'unframed' indicates the current setting of Line type.")
nms553NetworkInterfaceType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ds1", 1), ("dsx1", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkInterfaceType.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkInterfaceType.setDescription('The operating mode of the interface. Setting the value of this object to ds1(1) configures the interface as standard DS1. Setting the value of this object to dsx1(2) configures the interface to operate as a standard cross-connect DSX-1. This object interoperates with the nms553NetworkPreequalization object. When this object is set to ds1(1), then the value of nms553NetworkPreequalization does not apply. This object interoperates with the nms553NetworkAdminLineBuildout object. When this object is set to dsx1(2), then the value of nms553NetworkLineBuildout does not apply.')
nms553NetworkPreequalization = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("none", 1), ("preeq130", 2), ("preeq260", 3), ("preeq390", 4), ("preeq530", 5), ("preeq655", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkPreequalization.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkPreequalization.setDescription('Is the preequalization of the transmitter of the interface. This object interoperates with the object nms553NetworkInterfaceType. When the value of nms553NetworkInterfaceType is ds1(2) then this value is not applicable.')
nms553NetworkAdminLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("auto", 1), ("man00dB", 2), ("man75dB", 3), ("man150dB", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkAdminLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkAdminLineBuildout.setDescription('This variable is used to set the Transmit Ntwk Build-Out value on the network side and is only valid if the nms553NetworkInterfaceType is set for ds1(1). The values, in sequence, describe: auto(1) indicates auto detection of receive level to determine the appropriate Ntwk build out without controller intervention man00dB(2) indicates manual selection of 0.0 dB transmit Ntwk build out man75dB(3) indicates manual selection of -7.5 dB transmit Ntwk build out man150dB(4) indicates manual selection of -15.0 dB transmit Ntwk build out')
nms553NetworkOperLineBuildout = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("tx00dB", 1), ("tx75dB", 2), ("tx150dB", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553NetworkOperLineBuildout.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkOperLineBuildout.setDescription('This variable is used to report the current Ntwk build-out setting if the nms553NetworkInterfaceType is set for ds1(1). tx00dB(1) indicates the unit is set for 0.0 dB of attenuation when the nms553NetworkAdminLineBuildout is set for auto (1) or man00dB (2) tx75dB(2) indicates the unit is set for -7.5 dB of attenuation when the nms553NetworkAdminLineBuildout is set for auto (1) or man75dB (3) tx150dB(3) indicates the unit is set for -15.0 dB of attenuation when the nms553NetworkAdminLineBuildout is set for auto (1) or man150dB (4)')
nms553NetworkOnesDensity = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("inhibit", 1), ("max15zeros", 2), ("max39zeros", 3), ("restrict8XNplus1", 4), ("min1in8", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkOnesDensity.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkOnesDensity.setDescription('The ones density restriction for the interface. The values of this object define the ones density restriction that is enforced on the interface. The value inhibit(1) indicates that no ones density restriction is enforced. The value max15zeros(2) indicates that a maximum of 15 zeros are transmitted to the network before a one is inserted. The value max39zeros(3) indicates that a maximum of 39 zeros are transmitted to the network before a one is inserted. The value restrict8nX1(4) indicates a minimum of N ones per 8(N+1) bits, where N is in the range 1 to 24. The value min1in8(5) indicates a minimum of 1 one per 8 bits. With this value, pulse density violations are enforced but not recorded.')
nms553NetworkTransmitClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("receive", 1), ("cascade", 2), ("internal", 3), ("station", 4), ("extChannelClkA", 5), ("extChannelClkB", 6), ("extChannelClkC", 7), ("composite", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkTransmitClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkTransmitClockSource.setDescription('')
nms553NetworkFallbackClockSource = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("receive", 1), ("internal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkFallbackClockSource.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkFallbackClockSource.setDescription('')
nms553NetworkFDLdcc = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkFDLdcc.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkFDLdcc.setDescription('Controls whether or not the DCC uses the FDL as its transport. The FDL is only available when the DS1 line type is ESF, a full DS1 interface is being used, and transportation of the FDL completely through the network is supported. The value enabled(1) enables the transportation of the DCC using the FDL. The value disabled(2) disables the use of the FDL to transport the DCC, which implies that the DCC is transported by some other means. This object interoperates with the nms553NetworkLineType object. The value of this object can be set to enabled(1) only when the value of the nms553NetworkLineType is one of the ESF values.')
nms553NetworkAISLoopdown = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(4, 60))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkAISLoopdown.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkAISLoopdown.setDescription('The time in seconds when receiving a continuous AIS signal before a remotely initiated loopback is terminated. When this object has the value 4, then there is no time limit and the loop must be terminated by remotely issued in-band loopdown codes. When the object has a value between 5 and 60, then this is time in seconds of continuous AIS signal before the loopback is terminated.')
nms553NetworkInbandFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("framed", 1), ("unframed", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkInbandFrame.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkInbandFrame.setDescription('This variable is used to set the In-Band DS1 Loopback Code Detection. Framed(1) framing is done upon recognition of he inband loopback code. Unframed(2) no framing is done upon recognition of the inband loopback code.')
nms553NetworkLoopbackConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("payload", 2), ("lineloop", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkLoopbackConfig.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkLoopbackConfig.setDescription('This variable is used to set the In-Band DS1 Loopback Code Detection. none(1) refers to when the in-band loopback codes are ignored. payload(2) designates a payload loopback is done upon recognition of the inband loopback code. lineloop(3) designates a line loopback is done upon recognition of the inband loopback code.')
nms553NetworkLineCoding = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nms553B8ZS", 1), ("nms553AMI", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkLineCoding.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkLineCoding.setDescription('This variable describes the variety of Zero Code Suppression used on the link, which in turn affects a number of its characteristics. nms553B8ZS refers to the use of a specified pat- tern of normal bits and bipolar violations which are used to replace a sequence of eight zero bits. nms553AMI refers to a mode wherein no zero code suppression is present and the line encoding does not solve the problem directly. In this application, the higher layer must provide data which meets or exceeds the pulse density re- quirements, such as inverting HDLC data.')
nms553NetworkFdl = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nms553Fdl-none", 1), ("nms553Ansi-T1-403", 2), ("nms553Att-54016", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553NetworkFdl.setStatus('mandatory')
if mibBuilder.loadTexts: nms553NetworkFdl.setDescription('This bitmap describes the use of the facili- ties data link, and is the sum of the capabili- ties: nms553Fdl-none(1) indicates that the device does not use the FDL. nms553Ansi-T1-403(2) refers to the FDL exchange recommended by ANSI. nms553Att-54016(3) refers to ESF FDL exchanges.')
nms553ConfigurationSave = MibScalar((1, 3, 6, 1, 4, 1, 498, 6, 7, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("network", 1), ("channel", 2), ("both", 3), ("norm", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ConfigurationSave.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ConfigurationSave.setDescription('This variable is used to set the update status flag for saving network and channel configuration settings. Management can only set to network(1), channel(2), or both(3) A norm(4) will always be read. Both Network configuration and Channel configuration are saved at the same time on both(3). Configuration settings are not saved to network element by default. This permits the configuration of several objects before saving. After all objects are set-up, a (1),(2) or (3) must be sent. This will enable and save the new configuration(s). ')
nms553DteStatusTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 4, 1), )
if mibBuilder.loadTexts: nms553DteStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DteStatusTable.setDescription('The nms553 DTE Signal Status table. Information in the entries of this table define the status of DSU channel interface leads. There are entries in this table for each channel of the associated DSU.')
nms553DteStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 4, 1, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553DteStatusIndex"))
if mibBuilder.loadTexts: nms553DteStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DteStatusEntry.setDescription('The nms553 DTE Signal Status table entry.')
nms553DteStatusIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 4, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553DteStatusIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DteStatusIndex.setDescription('The index value: slot, line, drop, and interface')
nms553DteStat = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 4, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553DteStat.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DteStat.setDescription('Returns a bitwise snapshot of the DTE signals. Octet 1 bit 7 - not used bit 6 - CTS (1:ON; 0:OFF) bit 5 - RTS (1:ON; 0:OFF) bit 4 - DTR (1:ON; 0:OFF) bit 3 - DSR (1:ON; 0:OFF) bit 2 - future use bit 1 - DCD (1:ON; 0:OFF) bit 0 - future use Octet 2 bit 7 - not used bit 6 - RXC (1:Transitions) bit 5 - DCD (1:Transitions) bit 4 - RTS (1:Transitions) bit 3 - CTS (1:Transitions) bit 2 - RXD (1:Transitions) bit 1 - TXC (1:Transitions) bit 0 - TXD (1:Transitions)')
nms553DiagTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1), )
if mibBuilder.loadTexts: nms553DiagTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagTable.setDescription('The NMS 553 Diagnostics table.')
nms553DiagEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553DiagIndex"))
if mibBuilder.loadTexts: nms553DiagEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagEntry.setDescription('The SNMP553S Diagnostics table entry.')
nms553DiagIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553DiagIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and sub-identifier, which in this case is a network interface.')
nms553DiagTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16))).clone(namedValues=NamedValues(("testTime30Secs", 1), ("testTime1Min", 2), ("testTime2Mins", 3), ("testTime3Mins", 4), ("testTime4Mins", 5), ("testTime5Mins", 6), ("testTime6Mins", 7), ("testTime7Mins", 8), ("testTime8Mins", 9), ("testTime9Mins", 10), ("testTime10Mins", 11), ("testTime15Mins", 12), ("testTime20Mins", 13), ("testTime25Mins", 14), ("testTime30Mins", 15), ("noLimit", 16)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DiagTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagTestDuration.setDescription('Selects the duration to run a diagnostic test. The value(1) noLimit signifies that the test should run indefinitely until explicitly terminated.')
nms553DiagProgPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DiagProgPattern.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagProgPattern.setDescription('The 16 bit user programmable test pattern. This object works with the nms553DiagSendCode object in that when nms553DiagSendCode is set to sendProgPattern(4), the the value of this object is used as the 16 bit user programmable test pattern. This object is used for all tests defined in both the GDC dsx1 mib.')
nms553DiagBeginSelfTest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("unit511Pattern", 1), ("unit2047Pattern", 2), ("unitQRSPattern", 3), ("unitProgPattern", 4), ("dsu511Pattern", 5), ("dsu2047Pattern", 6), ("dsuQRSPattern", 7), ("dsuProgPattern", 8), ("noselftestrunning", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DiagBeginSelfTest.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagBeginSelfTest.setDescription('A set of 1-8 will start the selected test with the indicated pattern. A 9 cannot be set by management. A read will always return a 9. ')
nms553DiagBeginLoopTest = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("localLoopback", 1), ("digitalLoopback", 2), ("remoteDigitalLoopback", 3), ("nolooptestrunning", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DiagBeginLoopTest.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagBeginLoopTest.setDescription('A set will start the selected test. ')
nms553DiagTestResults = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553DiagTestResults.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagTestResults.setDescription('The results of the last diagnostic test. This can be the current test running or the last completed test. The units of the value of this object depend on the type of diagnostic test run. For all cases except a network delay measurement, the units of the value of this object is the number of bit errors that occurred. Bit errors can be read at any time during the duration of the test. The valid range for bit errors is 0 to 4,095. 65,535 will be returned if for any reason the test was terminated early. 32,770 will be returned if the number of bit errors exceeds 4,095. For a network delay measurement, the units of the value of this test are milliseconds. If the test is terminated early then 65,535 will be returned and if the delay is greater than 4,095 then 32,770 will be returned.')
nms553DiagResetTestToNormal = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("resetTest", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DiagResetTestToNormal.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagResetTestToNormal.setDescription('This object will halt the execution of any and all diagnostic test that may be running with the exception of the Network Delay Test.')
nms553DiagTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 5, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noTestinProgress", 1), ("unitSelfTest", 2), ("dsuSelfTest", 3), ("localLoopback", 4), ("digitalLoopback", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553DiagTestStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DiagTestStatus.setDescription('This object will return the test current test in progress, if any.')
nms553MaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1), )
if mibBuilder.loadTexts: nms553MaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553MaintenanceTable.setDescription('The table describes the maintenance functions for the nms553. ')
nms553MaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553MaintenanceIndex"))
if mibBuilder.loadTexts: nms553MaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553MaintenanceEntry.setDescription('An entry in the GDC maintenance Table')
nms553MaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553MaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553MaintenanceIndex.setDescription('The index value: slot, line, drop, and interface')
nms553LedStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553LedStatus.setStatus('mandatory')
if mibBuilder.loadTexts: nms553LedStatus.setDescription('Returns a bitwise snapshot of the front panel LED state and front panel switches. Octet 1 bit 7 - not used bit 6 - ON (0:LED inactive 1:LED active) bit 5 - DSX1 bit 4 - NMSRSP bit 3 - NMSDAT bit 2 - ER bit 1 - DSX OOF bit 0 - DSX LOS Octet 2 bit 7 - not used bit 6 - NET OOF bit 5 - NET LOS bit 4 - NET BPV bit 3 - NET AIS bit 2 - TM/ALM bit 1 - LBK bit 0 - future use Octet 3 bit 7 - not used bit 6 - CHA SD bit 5 - CHA RD bit 4 - CHB SD bit 3 - CHB RD bit 2 - CHC SD bit 1 - CHC RD bit 0 - future use')
nms553SoftReset = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("reset", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553SoftReset.setStatus('mandatory')
if mibBuilder.loadTexts: nms553SoftReset.setDescription('Supports the action of soft resetting the unit. When this object is set to reset(1), then the unit performs a soft reset. The value norm will be returned when the reset is complete. The value of norm can not be set by management.')
nms553DefaultInit = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("factoryDefault", 1), ("normal", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553DefaultInit.setStatus('mandatory')
if mibBuilder.loadTexts: nms553DefaultInit.setDescription('This is used to allow the NonVolatile Configuration to be set to a factory default state. When this value is set to factoryDefault, the unit will reset to the default configuration. The value of normal will be returned when the initialization is complete. The value normal can not be set by management.')
nms553FrontPanel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inhibit", 1), ("enable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553FrontPanel.setStatus('mandatory')
if mibBuilder.loadTexts: nms553FrontPanel.setDescription('This variable is used to indicate whether the front panel switches are operational or not.')
nms553ProductType = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nms553d1", 1), ("nms553d1ifp", 2), ("nms553d3ifp", 3), ("nms553c", 4), ("nms553cifp", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553ProductType.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ProductType.setDescription('Indicates the product type of the unit.')
nms553ResetStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("norm", 1), ("reset", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ResetStatistics.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ResetStatistics.setDescription('Supports the action of soft resetting the nms553ValidIntervals object. When this object is set to reset(2), then the unit will reset the nms553ValidIntervals object to zero. The value of norm(1) can not be set by management.')
nms553ValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553ValidIntervals.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ValidIntervals.setDescription('The number of previous intervals for which valid data was collected. The value will be 96 unless the interface was brought on-line within the last 24 hours, in which case the value will be the number of complete 15 minute intervals the since interface has been online.')
nms553CascadePresent = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("notPresent", 1), ("present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CascadePresent.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CascadePresent.setDescription('Identifies whether or not the cascade interface cards are installed.')
nms553ReceiveLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 43))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553ReceiveLevel.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ReceiveLevel.setDescription('This variable reports the absolute value of the network relative receive level of -40dB to +3dB when the nms553networkInterfaceType is set for ds1(1). Values 1 thru 40 are to be interpreted as negative values, example a value 10 equals -10dB. Values 41,42,43 are to be interpreted as +1,+2 and +3dB respectively.')
nms553AlarmData = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1))
nms553NoResponseAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 1))
nms553DiagRxErrAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 2))
nms553PowerUpAlm = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 3))
nms553NvRamCorrupt = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 4))
nms553UnitFailure = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 5))
nms553TimingLoss = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 6))
nms553StatusChange = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 7))
nms553UnsolicitedTest = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 8))
nms553LossOfSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 9))
nms553LossOfFrame = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 10))
nms553AlarmIndicationSignal = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 11))
nms553ReceivedYellow = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 12))
nms553UnavailableSignalState = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 13))
nms553ExcessiveZeros = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 14))
nms553LowAverageDensity = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 15))
nms553ControlledSlips = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 16))
nms553BipolarViolations = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 17))
nms553CrcErrors = MibIdentifier((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 1, 18))
nms553AlarmConfigTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 2), )
if mibBuilder.loadTexts: nms553AlarmConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmConfigTable.setDescription('The nms553AlarmConfigTable contains entries that configure alarm reporting. The structure of the table is such that alarm configuration is supported on a unit and interface basis, and then on an alarm type basis within the interface. For simplicity sake alarms, be they unit or interface related, are represented in one table.')
nms553AlarmConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 2, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553AlarmConfigIndex"), (0, "NMS-553-MIB", "nms553AlarmConfigIdentifier"))
if mibBuilder.loadTexts: nms553AlarmConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmConfigEntry.setDescription('An entry in the GDC Alarm Configuration table.')
nms553AlarmConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmConfigIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
nms553AlarmConfigIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmConfigIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmConfigIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
nms553AlarmCountWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("last1sec", 2), ("last1min", 3), ("last1hr", 4), ("infinite", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553AlarmCountWindow.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmCountWindow.setDescription('This variable sets/reads the BPV alarm window. This window is used with the alarm threshold to determine how long the alarm should be active before reporting.')
nms553AlarmCountThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 7, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("thresGT10", 1), ("thresGT100", 2), ("thresGT1000", 3), ("thresGT10000", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553AlarmCountThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmCountThreshold.setDescription('This function sets/reads the BPV alarm threshold criteria. This threshold is used along with the the alarm window to determine the number of instances in a given time frame for an alarm to occur before the alarm is considered active.')
nms553AlarmHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1), )
if mibBuilder.loadTexts: nms553AlarmHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmHistoryTable.setDescription('The nms553AlarmHistoryTable contains entries that report the history of all supported alarms. The history consists of the the number of times the alarm has occurred since last history reset, the time of the first alarm occurence (hours,minutes, seconds,day,month,year), and the time of the last alarm occurrence (hours,minutes,seconds,day,month,year). The structure of the table is such that alarm status is supported on a unit or interface basis, and then on an alarm type basis within the interface. For simplicity sake and to support the reporting of status of all alarms, a unit is treated as an interface 1 in this table.')
nms553AlarmHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553AlarmHistoryIndex"), (0, "NMS-553-MIB", "nms553AlarmHistoryIdentifier"))
if mibBuilder.loadTexts: nms553AlarmHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmHistoryEntry.setDescription('An entry in the GDC NMS553 Alarm History table.')
nms553AlarmHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmHistoryIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
nms553AlarmHistoryIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmHistoryIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmHistoryIdentifier.setDescription('The unique alarm identifier assigned to this alarm type. The format of this identifier is an OBJECT IDENTIFIER that has the following format: {iso(1) org(3) dod(6) internet(1) private(4) enterprises(1) gdc(498) xxx(x) alarm(z) yyy(y) where xxx(x) is the administratively assigned family object identifier (z) is the object identifier for alarms in the family defined MIB and yyy(y) is the administratively assigned alarm type identifier for this alarm.')
nms553AlarmCount = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmCount.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmCount.setDescription('The number of occurrences of this alarm. This objects value is incremented once for each time that the alarm occurs. This count is incremented regardless of whether or not the alarm is masked or is not reporteded because of the threshold configuration.')
nms553AlarmFirstOccurrenceHours = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceHours.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceHours.setDescription('The hour (0-23) the alarm first occurred.')
nms553AlarmFirstOccurrenceMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceMinutes.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceMinutes.setDescription('The minute (0-59) the alarm first occurred.')
nms553AlarmFirstOccurrenceSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceSeconds.setDescription('The second (0-59) the alarm first occurred.')
nms553AlarmFirstOccurrenceMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceMonth.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceMonth.setDescription('The month (1-12) the alarm first occurred.')
nms553AlarmFirstOccurrenceDay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceDay.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceDay.setDescription('The day (1-31) the alarm first occurred.')
nms553AlarmFirstOccurrenceYear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceYear.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmFirstOccurrenceYear.setDescription('The year (0-99) the alarm first occurred.')
nms553AlarmLastOccurrenceHours = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceHours.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceHours.setDescription('The hour (0-23) the alarm last occurred.')
nms553AlarmLastOccurrenceMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceMinutes.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceMinutes.setDescription('The minute (0-59) the alarm last occurred.')
nms553AlarmLastOccurrenceSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceSeconds.setDescription('The second (0-59) the alarm last occurred.')
nms553AlarmLastOccurrenceMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceMonth.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceMonth.setDescription('The month (1-12) the alarm last occurred.')
nms553AlarmLastOccurrenceDay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceDay.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceDay.setDescription('The day (1-31) the alarm last occurred.')
nms553AlarmLastOccurrenceYear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceYear.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmLastOccurrenceYear.setDescription('The year (0-99) the alarm last occurred.')
nms553AlarmMaintenanceTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2), )
if mibBuilder.loadTexts: nms553AlarmMaintenanceTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmMaintenanceTable.setDescription('The nms553AlarmMaintenanceTable contains entries that configure the real time clock and that clear the alarm history table.')
nms553AlarmMaintenanceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553AlarmMaintenanceIndex"))
if mibBuilder.loadTexts: nms553AlarmMaintenanceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmMaintenanceEntry.setDescription('An entry in the GDC nms553 Alarm Maintenance Table.')
nms553AlarmMaintenanceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553AlarmMaintenanceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553AlarmMaintenanceIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable.')
nms553ClearAlarmHistory = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("clear", 1), ("norm", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553ClearAlarmHistory.setStatus('mandatory')
if mibBuilder.loadTexts: nms553ClearAlarmHistory.setDescription('Supports the action of clearing the alarm history table. When this object is set to clear(1), then the unit clears the alarm history table. The value of norm(2) will be returned when the clear is complete. The value of norm(2) can not be set by management.')
nms553RTCHours = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 3), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553RTCHours.setStatus('mandatory')
if mibBuilder.loadTexts: nms553RTCHours.setDescription('The hour of day (0-23) to be set or read.')
nms553RTCMinutes = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553RTCMinutes.setStatus('mandatory')
if mibBuilder.loadTexts: nms553RTCMinutes.setDescription('The minute of the hour (0-59) to be set or read.')
nms553RTCSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553RTCSeconds.setStatus('mandatory')
if mibBuilder.loadTexts: nms553RTCSeconds.setDescription('The second of the minute (0-59) to be set or read.')
nms553RTCMonth = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553RTCMonth.setStatus('mandatory')
if mibBuilder.loadTexts: nms553RTCMonth.setDescription('The month of the year (1-12) to be set or read.')
nms553RTCDay = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553RTCDay.setStatus('mandatory')
if mibBuilder.loadTexts: nms553RTCDay.setDescription('The day of the month (1-31) to be set or read.')
nms553RTCYear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nms553RTCYear.setStatus('mandatory')
if mibBuilder.loadTexts: nms553RTCYear.setDescription('The year (0-99) to be set or read.')
nms553TimeOfLastAlarmClear = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 8, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TimeOfLastAlarmClear.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TimeOfLastAlarmClear.setDescription('Returns the time (hours,minutes,seconds,month,day,year) of the last alarm clear command sent to the unit. Octet 1 - Hour of last alarm clear (0-23) Octet 2 - Minute of last alarm clear (0-59) Octet 3 - Second of last alarm clear (0-59) Octet 4 - Month of last alarm clear (1-12) Octet 5 - Day of last alarm clear (1-31) Octet 6 - Year of last alarm clear (0-99).')
nms553CurrentTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1), )
if mibBuilder.loadTexts: nms553CurrentTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentTable.setDescription('The nms553 Current table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
nms553CurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553CurrentIndex"))
if mibBuilder.loadTexts: nms553CurrentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentEntry.setDescription('An entry in the nms553 Current table.')
nms553CurrentIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CurrentIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
nms553CurrentESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CurrentESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentESs.setDescription('The number of Errored Seconds, encountered by a DS1 interface in the current 15 minute inter- val.')
nms553CurrentSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CurrentSESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentSESs.setDescription('The number of Severely Errored Seconds encoun- tered by a DS1 interface in the current 15 minute interval.')
nms553CurrentBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CurrentBESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a DS1 interface in the current 15 minute interval.')
nms553CurrentUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CurrentUASs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentUASs.setDescription('The number of Unavailable Seconds encountered by a DS1 interface in the current 15 minute in- terval.')
nms553CurrentLOFCs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CurrentLOFCs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentLOFCs.setDescription('The number of Loss of Frame Counts (LOFCs) encountered by a DS1 interface in the current 15 minute interval.')
nms553CurrentCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553CurrentCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553CurrentCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a DS1 interface in the current 15 minute interval.')
nms553IntervalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2), )
if mibBuilder.loadTexts: nms553IntervalTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalTable.setDescription('The nms553 Interval table. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
nms553IntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553IntervalIndex"), (0, "NMS-553-MIB", "nms553IntervalNumber"))
if mibBuilder.loadTexts: nms553IntervalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalEntry.setDescription('An entry in the DS1 Interval table.')
nms553IntervalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
nms553IntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed minute interval and 96 is the least recently completed 15 minutes interval (assuming that all 96 intervals are valid).')
nms553IntervalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalESs.setDescription('The number of Errored Seconds encountered by a DS1 interface in one of the previous 96, indi- vidual 15 minute, intervals.')
nms553IntervalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
nms553IntervalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
nms553IntervalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalUASs.setDescription('The number of Unavailable Seconds encountered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
nms553IntervalLOFCs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalLOFCs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalLOFCs.setDescription('The number of Loss of Frame Counts (LOFCs) encountered by a DS1 interface in the current 15 minute interval.')
nms553IntervalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553IntervalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553IntervalCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a DS1 interface in one of the previous 96, individual 15 minute, intervals.')
nms553TotalTable = MibTable((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3), )
if mibBuilder.loadTexts: nms553TotalTable.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalTable.setDescription('The DS1 Total table. 24 hour interval. This table supplements the entries in the DS1 AT&T performance table of the DS1 MIB defined in RFC1406.')
nms553TotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1), ).setIndexNames((0, "NMS-553-MIB", "nms553TotalIndex"))
if mibBuilder.loadTexts: nms553TotalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalEntry.setDescription('An entry in the DS1 Total table.')
nms553TotalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1, 1), SCinstance()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TotalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalIndex.setDescription('The index value which uniquely identifies the interface to which this entry is applicable. This has the form of a SCinstance which defines the slot, line, drop, and interface, which in this case is a network interface.')
nms553TotalESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TotalESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalESs.setDescription('The number of Errored Seconds encountered by a DS1 interface in the previous 24 hour interval')
nms553TotalSESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TotalSESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalSESs.setDescription('The number of Severely Errored Seconds encoun- tered by a DS1 interface in the previous 24 hour interval.')
nms553TotalBESs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TotalBESs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalBESs.setDescription('The number of Bursty Errored Seconds (BESs) encountered by a DS1 interface in the previous 24 hour interval.')
nms553TotalUASs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TotalUASs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalUASs.setDescription('The number of Unavailable Seconds encountered by a DS1 interface in the previous 24 hour in- terval.')
nms553TotalLOFCs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TotalLOFCs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalLOFCs.setDescription('The number of Loss of Frame Counts (LOFCs) encountered by a DS1interface in the current 15 minute interval.')
nms553TotalCSSs = MibTableColumn((1, 3, 6, 1, 4, 1, 498, 6, 7, 9, 3, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nms553TotalCSSs.setStatus('mandatory')
if mibBuilder.loadTexts: nms553TotalCSSs.setDescription('The number of Controlled Slip Seconds encoun- tered by a DS1 interface in the previous 24 hour interval.')
mibBuilder.exportSymbols("NMS-553-MIB", nms553DiagTable=nms553DiagTable, nms553NetworkFdl=nms553NetworkFdl, nms553CurrentSESs=nms553CurrentSESs, nms553FrontPanel=nms553FrontPanel, nms553StatusChange=nms553StatusChange, nms553Version=nms553Version, nms553NetworkLineCoding=nms553NetworkLineCoding, nms553FirmwareRev=nms553FirmwareRev, nms553ChannelFlowControl=nms553ChannelFlowControl, nms553DiagRxErrAlm=nms553DiagRxErrAlm, nms553TotalBESs=nms553TotalBESs, nms553CurrentIndex=nms553CurrentIndex, nms553Maintenance=nms553Maintenance, nms553AlarmHistoryIndex=nms553AlarmHistoryIndex, nms553CurrentCSSs=nms553CurrentCSSs, nms553ChannelInbandLoopdown=nms553ChannelInbandLoopdown, nms553AlarmConfigIdentifier=nms553AlarmConfigIdentifier, nms553ReceivedYellow=nms553ReceivedYellow, nms553NetworkConfigIndex=nms553NetworkConfigIndex, nms553LowAverageDensity=nms553LowAverageDensity, nms553NetworkTransmitClockSource=nms553NetworkTransmitClockSource, nms553NetworkFallbackClockSource=nms553NetworkFallbackClockSource, nms553DS0AllocationBaseRate=nms553DS0AllocationBaseRate, nms553UnavailableSignalState=nms553UnavailableSignalState, nms553NetworkAISLoopdown=nms553NetworkAISLoopdown, nms553NetworkInbandFrame=nms553NetworkInbandFrame, nms553AlarmHistory=nms553AlarmHistory, nms553IntervalSESs=nms553IntervalSESs, nms553CascadePresent=nms553CascadePresent, nms553ValidIntervals=nms553ValidIntervals, nms553NetworkAdminLineType=nms553NetworkAdminLineType, nms553RTCMonth=nms553RTCMonth, nms553LossOfFrame=nms553LossOfFrame, nms553ChannelConfigTable=nms553ChannelConfigTable, nms553DiagResetTestToNormal=nms553DiagResetTestToNormal, nms553DS0AllocationConfigIndex=nms553DS0AllocationConfigIndex, nms553NetworkInterfaceType=nms553NetworkInterfaceType, nms553AlarmLastOccurrenceDay=nms553AlarmLastOccurrenceDay, nms553AlarmHistoryTable=nms553AlarmHistoryTable, nms553Configuration=nms553Configuration, nms553TotalLOFCs=nms553TotalLOFCs, nms553NvRamCorrupt=nms553NvRamCorrupt, nms553DteStatus=nms553DteStatus, nms553VersionIndex=nms553VersionIndex, nms553NetworkLoopbackConfig=nms553NetworkLoopbackConfig, nms553NetworkConfigEntry=nms553NetworkConfigEntry, nms553DS0AllocationStartingDS0=nms553DS0AllocationStartingDS0, nms553NetworkOperLineBuildout=nms553NetworkOperLineBuildout, nms553AlarmConfigEntry=nms553AlarmConfigEntry, nms553AlarmHistoryIdentifier=nms553AlarmHistoryIdentifier, nms553Diagnostics=nms553Diagnostics, nms553ChannelRTSCTSControl=nms553ChannelRTSCTSControl, nms553RTCDay=nms553RTCDay, nms553CurrentESs=nms553CurrentESs, nms553TotalUASs=nms553TotalUASs, nms553ChannelDataInvert=nms553ChannelDataInvert, nms553ReceiveLevel=nms553ReceiveLevel, nms553AlarmLastOccurrenceMonth=nms553AlarmLastOccurrenceMonth, nms553UnitFailure=nms553UnitFailure, nms553BipolarViolations=nms553BipolarViolations, nms553NetworkAdminLineBuildout=nms553NetworkAdminLineBuildout, nms553ChannelControlModeIdle=nms553ChannelControlModeIdle, nms553CurrentBESs=nms553CurrentBESs, nms553IntervalBESs=nms553IntervalBESs, nms553CrcErrors=nms553CrcErrors, nms553DteStatusTable=nms553DteStatusTable, nms553NoResponseAlm=nms553NoResponseAlm, nms553DS0AllocationSchemeEntry=nms553DS0AllocationSchemeEntry, nms553ChannelInbandLoop=nms553ChannelInbandLoop, nms553MaintenanceEntry=nms553MaintenanceEntry, nms553PowerUpAlm=nms553PowerUpAlm, nms553NetworkConfigTable=nms553NetworkConfigTable, nms553ChannelSplitTiming=nms553ChannelSplitTiming, nms553ExcessiveZeros=nms553ExcessiveZeros, nms553CurrentTable=nms553CurrentTable, nms553UnsolicitedTest=nms553UnsolicitedTest, nms553DteStatusEntry=nms553DteStatusEntry, nms553RTCYear=nms553RTCYear, nms553MaintenanceTable=nms553MaintenanceTable, nms553IntervalEntry=nms553IntervalEntry, nms553DS0AllocationInbandDccMode=nms553DS0AllocationInbandDccMode, nms553AlarmData=nms553AlarmData, nms553AlarmFirstOccurrenceHours=nms553AlarmFirstOccurrenceHours, nms553TimingLoss=nms553TimingLoss, nms553DteStatusIndex=nms553DteStatusIndex, nms553LossOfSignal=nms553LossOfSignal, nms553DiagBeginLoopTest=nms553DiagBeginLoopTest, nms553AlarmConfigTable=nms553AlarmConfigTable, nms553IntervalCSSs=nms553IntervalCSSs, nms553CurrentEntry=nms553CurrentEntry, nms553SoftReset=nms553SoftReset, nms553AlarmFirstOccurrenceMinutes=nms553AlarmFirstOccurrenceMinutes, nms553MaintenanceIndex=nms553MaintenanceIndex, nms553LedStatus=nms553LedStatus, nms553ProductType=nms553ProductType, nms553TotalTable=nms553TotalTable, nms553ChannelInbandLoopCode=nms553ChannelInbandLoopCode, nms553DiagTestDuration=nms553DiagTestDuration, nms553ChannelLocalDCD=nms553ChannelLocalDCD, nms553AlarmLastOccurrenceYear=nms553AlarmLastOccurrenceYear, nms553ClearAlarmHistory=nms553ClearAlarmHistory, nms553CurrentUASs=nms553CurrentUASs, nms553NetworkFDLdcc=nms553NetworkFDLdcc, nms553TotalESs=nms553TotalESs, nms553NetworkOperLineType=nms553NetworkOperLineType, nms553TotalCSSs=nms553TotalCSSs, nms553DiagProgPattern=nms553DiagProgPattern, nms553DS0AllocationConfigEntry=nms553DS0AllocationConfigEntry, nms553AlarmCountWindow=nms553AlarmCountWindow, nms553AlarmFirstOccurrenceMonth=nms553AlarmFirstOccurrenceMonth, nms553AlarmMaintenanceTable=nms553AlarmMaintenanceTable, nms553DefaultInit=nms553DefaultInit, nms553Performance=nms553Performance, nms553ChannelChannelType=nms553ChannelChannelType, nms553DiagTestResults=nms553DiagTestResults, nms553Alarms=nms553Alarms, nms553DiagBeginSelfTest=nms553DiagBeginSelfTest, nms553AlarmLastOccurrenceMinutes=nms553AlarmLastOccurrenceMinutes, nms553DiagIndex=nms553DiagIndex, nms553AlarmLastOccurrenceSeconds=nms553AlarmLastOccurrenceSeconds, nms553IntervalUASs=nms553IntervalUASs, nms553DS0Allocation=nms553DS0Allocation, nms553ConfigurationSave=nms553ConfigurationSave, nms553DteStat=nms553DteStat, dsx1=dsx1, nms553AlarmIndicationSignal=nms553AlarmIndicationSignal, nms553DS0AllocationSchemeIndex=nms553DS0AllocationSchemeIndex, nms553ChannelLocalDSR=nms553ChannelLocalDSR, nms553DS0AllocationSchemeTable=nms553DS0AllocationSchemeTable, nms553AlarmCount=nms553AlarmCount, nms553TotalEntry=nms553TotalEntry, nms553IntervalTable=nms553IntervalTable, nms553ChannelConfigEntry=nms553ChannelConfigEntry, nms553ChannelClockInvert=nms553ChannelClockInvert, nms553VersionTable=nms553VersionTable, nms553ControlledSlips=nms553ControlledSlips, nms553AlarmFirstOccurrenceSeconds=nms553AlarmFirstOccurrenceSeconds, nms553RTCHours=nms553RTCHours, nms553TotalSESs=nms553TotalSESs, nms553IntervalLOFCs=nms553IntervalLOFCs, nms553AlarmFirstOccurrenceDay=nms553AlarmFirstOccurrenceDay, nms553DiagTestStatus=nms553DiagTestStatus, nms553ResetStatistics=nms553ResetStatistics, nms553AlarmCountThreshold=nms553AlarmCountThreshold, nms553ChannelEIAtestLeads=nms553ChannelEIAtestLeads, nms553NetworkPreequalization=nms553NetworkPreequalization, nms553DS0AllocationConfigTable=nms553DS0AllocationConfigTable, nms553AlarmMaintenanceIndex=nms553AlarmMaintenanceIndex, nms553IntervalIndex=nms553IntervalIndex, nms553VersionEntry=nms553VersionEntry, nms553RTCMinutes=nms553RTCMinutes, nms553TotalIndex=nms553TotalIndex, nms553ChannelConfigIndex=nms553ChannelConfigIndex, nms553DiagEntry=nms553DiagEntry, nms553AlarmHistoryEntry=nms553AlarmHistoryEntry, nms553MIBversion=nms553MIBversion, nms553AlarmMaintenanceEntry=nms553AlarmMaintenanceEntry, nms553DS0AllocationNumberOfDS0s=nms553DS0AllocationNumberOfDS0s, nms553IntervalNumber=nms553IntervalNumber, nms553=nms553, nms553CurrentLOFCs=nms553CurrentLOFCs, nms553TimeOfLastAlarmClear=nms553TimeOfLastAlarmClear, nms553RTCSeconds=nms553RTCSeconds, nms553DS0AllocationScheme=nms553DS0AllocationScheme, nms553AlarmLastOccurrenceHours=nms553AlarmLastOccurrenceHours, nms553IntervalESs=nms553IntervalESs, nms553NetworkOnesDensity=nms553NetworkOnesDensity, nms553AlarmFirstOccurrenceYear=nms553AlarmFirstOccurrenceYear, nms553AlarmConfigIndex=nms553AlarmConfigIndex)

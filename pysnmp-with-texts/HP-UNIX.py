#
# PySNMP MIB module HP-UNIX (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-UNIX
# Produced by pysmi-0.3.4 at Wed May  1 13:36:56 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, enterprises, iso, ModuleIdentity, Gauge32, TimeTicks, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, MibIdentifier, Bits, Counter32, Integer32, ObjectIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "enterprises", "iso", "ModuleIdentity", "Gauge32", "TimeTicks", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "MibIdentifier", "Bits", "Counter32", "Integer32", "ObjectIdentity", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
hp = MibIdentifier((1, 3, 6, 1, 4, 1, 11))
nm = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2))
system = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4))
icmp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 7))
snmp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13))
openView = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 17))
general = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 1))
hpux = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 2))
hpsun = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 10))
sparc = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 10, 1))
computerSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1))
fileSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2))
processes = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4))
cluster = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5))
ieee8023Mac = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 4, 1))
trap = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 1))
snmpdConf = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 2))
authfail = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 13, 4))
openViewTrapVars = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 17, 2))
hp386 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 8))
hp9000s300 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 2, 2))
hp9000s800 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 2, 3))
hp9000s700 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 2, 5))
hpOpenView = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 17, 1))
sun4 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 10, 1, 1))
sun5 = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 3, 10, 1, 2))
computerSystemUpTime = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 1), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemUpTime.setDescription('Time since the last boot.')
computerSystemUsers = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 2), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemUsers.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemUsers.setDescription('Number of users logged on to system.')
computerSystemAvgJobs1 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemAvgJobs1.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemAvgJobs1.setDescription('Average number of jobs in the last 1 minute * 100.')
computerSystemAvgJobs5 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemAvgJobs5.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemAvgJobs5.setDescription('Average number of jobs in the last 5 minutes * 100.')
computerSystemAvgJobs15 = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemAvgJobs15.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemAvgJobs15.setDescription('Average number of jobs in the last 15 minutes * 100.')
computerSystemMaxProc = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemMaxProc.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemMaxProc.setDescription('Maximum number of processes allowed in system. Implemented with Extensible SNMP Agent.')
computerSystemFreeMemory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemFreeMemory.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemFreeMemory.setDescription('Free memory. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemPhysMemory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemPhysMemory.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemPhysMemory.setDescription('Physical memory. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemMaxUserMem = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemMaxUserMem.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemMaxUserMem.setDescription('Maximum user memory. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemSwapConfig = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemSwapConfig.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemSwapConfig.setDescription('Swap space configured. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemEnabledSwap = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemEnabledSwap.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemEnabledSwap.setDescription('Enabled via swapon. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemFreeSwap = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemFreeSwap.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemFreeSwap.setDescription('Currently free swap space. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemUserCPU = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemUserCPU.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemUserCPU.setDescription('CPU used by users. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemSysCPU = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemSysCPU.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemSysCPU.setDescription('CPU used by system. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemIdleCPU = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemIdleCPU.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemIdleCPU.setDescription('CPU idle. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
computerSystemNiceCPU = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: computerSystemNiceCPU.setStatus('mandatory')
if mibBuilder.loadTexts: computerSystemNiceCPU.setDescription('CPU nice. SunOS - not implemented. Implemented with Extensible SNMP Agent.')
fileSystemMounted = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemMounted.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemMounted.setDescription('The number of file systems mounted.')
fileSystemTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2), )
if mibBuilder.loadTexts: fileSystemTable.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemTable.setDescription('File system table.')
fileSystemEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1), ).setIndexNames((0, "HP-UNIX", "fileSystemID1"), (0, "HP-UNIX", "fileSystemID2"))
if mibBuilder.loadTexts: fileSystemEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemEntry.setDescription('Each entry contains objects for a particular file system.')
fileSystemID1 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemID1.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemID1.setDescription('First file system ID.')
fileSystemID2 = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemID2.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemID2.setDescription('Second file system ID.')
fileSystemName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemName.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemName.setDescription('Name of mounted file system.')
fileSystemBlock = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemBlock.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemBlock.setDescription('Total blocks in file system.')
fileSystemBfree = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemBfree.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemBfree.setDescription('Free blocks in file system.')
fileSystemBavail = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemBavail.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemBavail.setDescription('Free blocks avail to non-superuser.')
fileSystemBsize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemBsize.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemBsize.setDescription('Fundamental file system block size.')
fileSystemFiles = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemFiles.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemFiles.setDescription('Total file nodes in file system.')
fileSystemFfree = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemFfree.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemFfree.setDescription('Free file nodes in file system.')
fileSystemDir = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 2, 2, 1, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSystemDir.setStatus('mandatory')
if mibBuilder.loadTexts: fileSystemDir.setDescription('File system path prefix.')
processNum = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processNum.setStatus('mandatory')
if mibBuilder.loadTexts: processNum.setDescription('The number of processes running.')
processTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2), )
if mibBuilder.loadTexts: processTable.setStatus('mandatory')
if mibBuilder.loadTexts: processTable.setDescription('Processes Table. Implemented with Extensible SNMP Agent.')
processEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1), ).setIndexNames((0, "HP-UNIX", "processPID"))
if mibBuilder.loadTexts: processEntry.setStatus('mandatory')
if mibBuilder.loadTexts: processEntry.setDescription('Each entry contains information about a process running on the system.')
processPID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processPID.setStatus('mandatory')
if mibBuilder.loadTexts: processPID.setDescription('The process ID (pid).')
processIdx = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processIdx.setStatus('mandatory')
if mibBuilder.loadTexts: processIdx.setDescription('Index for pstat() requests. SunOS - not implemented.')
processUID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processUID.setStatus('mandatory')
if mibBuilder.loadTexts: processUID.setDescription('Process User ID.')
processPPID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processPPID.setStatus('mandatory')
if mibBuilder.loadTexts: processPPID.setDescription('Parent process ID.')
processDsize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processDsize.setStatus('mandatory')
if mibBuilder.loadTexts: processDsize.setDescription('Process data size.')
processTsize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processTsize.setStatus('mandatory')
if mibBuilder.loadTexts: processTsize.setDescription('Process text size.')
processSsize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 7), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processSsize.setStatus('mandatory')
if mibBuilder.loadTexts: processSsize.setDescription('Process stack size.')
processNice = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processNice.setStatus('mandatory')
if mibBuilder.loadTexts: processNice.setDescription('Process nice value.')
processMajor = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processMajor.setStatus('mandatory')
if mibBuilder.loadTexts: processMajor.setDescription('Process tty major number. SunOS - not implemented.')
processMinor = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processMinor.setStatus('mandatory')
if mibBuilder.loadTexts: processMinor.setDescription('Process tty minor number. SunOS - not implemented.')
processPgrp = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processPgrp.setStatus('mandatory')
if mibBuilder.loadTexts: processPgrp.setDescription('Process group of this process.')
processPrio = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processPrio.setStatus('mandatory')
if mibBuilder.loadTexts: processPrio.setDescription('Process priority.')
processAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processAddr.setStatus('mandatory')
if mibBuilder.loadTexts: processAddr.setDescription('Address of process (in memory).')
processCPU = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processCPU.setStatus('mandatory')
if mibBuilder.loadTexts: processCPU.setDescription('Processor utilization for scheduling.')
processUtime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 15), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processUtime.setStatus('mandatory')
if mibBuilder.loadTexts: processUtime.setDescription('User time spent executing.')
processStime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 16), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processStime.setStatus('mandatory')
if mibBuilder.loadTexts: processStime.setDescription('System time spent executing.')
processStart = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 17), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processStart.setStatus('mandatory')
if mibBuilder.loadTexts: processStart.setDescription('Time Process started.')
processFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("incore", 1), ("sys", 2), ("locked", 4), ("trace", 8), ("trace2", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: processFlags.setStatus('mandatory')
if mibBuilder.loadTexts: processFlags.setDescription('Flags associated with process. SunOS - values found in /usr/include/sys/proc.h.')
processStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("sleep", 1), ("run", 2), ("stop", 3), ("zombie", 4), ("other", 5), ("idle", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: processStatus.setStatus('mandatory')
if mibBuilder.loadTexts: processStatus.setDescription('The process status. SunOS - sleep(1), wait(2), run(3), idle (4), zombie(5), stop(6)')
processWchan = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processWchan.setStatus('mandatory')
if mibBuilder.loadTexts: processWchan.setDescription('If processStatus is sleep, value sleeping on.')
processProcNum = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processProcNum.setStatus('mandatory')
if mibBuilder.loadTexts: processProcNum.setDescription('Processor this process last run on. SunOS - not implemented.')
processCmd = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 22), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processCmd.setStatus('mandatory')
if mibBuilder.loadTexts: processCmd.setDescription('Command the process is running.')
processTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processTime.setStatus('mandatory')
if mibBuilder.loadTexts: processTime.setDescription('Resident time for scheduling.')
processCPUticks = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processCPUticks.setStatus('mandatory')
if mibBuilder.loadTexts: processCPUticks.setDescription('Ticks of cpu time.')
processCPUticksTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processCPUticksTotal.setStatus('mandatory')
if mibBuilder.loadTexts: processCPUticksTotal.setDescription('Total ticks for life of process. SunOS - not implemented.')
processFss = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processFss.setStatus('mandatory')
if mibBuilder.loadTexts: processFss.setDescription('Fair Share Schedular Group. SunOS - not implemented.')
processPctCPU = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 27), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processPctCPU.setStatus('mandatory')
if mibBuilder.loadTexts: processPctCPU.setDescription('Percent CPU * 100 for this process.')
processRssize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 28), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processRssize.setStatus('mandatory')
if mibBuilder.loadTexts: processRssize.setDescription('Resident Set Size for process (private pages).')
processSUID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processSUID.setStatus('mandatory')
if mibBuilder.loadTexts: processSUID.setDescription('saved UID.')
processUname = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 30), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processUname.setStatus('mandatory')
if mibBuilder.loadTexts: processUname.setDescription('User name.')
processTTY = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 4, 2, 1, 31), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: processTTY.setStatus('mandatory')
if mibBuilder.loadTexts: processTTY.setDescription('Process TTY. SunOS - not implemented.')
ieee8023MacTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1), )
if mibBuilder.loadTexts: ieee8023MacTable.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacTable.setDescription('A list of IEEE 802.3 Interface entries.')
ieee8023MacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1), ).setIndexNames((0, "HP-UNIX", "ieee8023MacIndex"))
if mibBuilder.loadTexts: ieee8023MacEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacEntry.setDescription('Each entry contains statistics for ieee 802.3 interfaces.')
ieee8023MacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacIndex.setDescription('The index value that uniquely identifies the interface to which this entry is applicable. The interface identified by a particular value of this index is the same interface as identified by the same value of ifIndex.')
ieee8023MacTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacTransmitted.setDescription('The number of frames successfully transmitted.')
ieee8023MacNotTransmitted = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacNotTransmitted.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacNotTransmitted.setDescription('The number of frames not transmitted.')
ieee8023MacDeferred = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacDeferred.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacDeferred.setDescription('The number of frames deferred because the medium was busy.')
ieee8023MacCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacCollisions.setDescription('Total number of transmit attempts that were retransmitted due to collisions. SunOS with Intel 82586 Ethernet driver - total number of collisions.')
ieee8023MacSingleCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacSingleCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacSingleCollisions.setDescription('Number of transmit attempts that are involved in a single collision and are subsequently transmitted successfully. SunOS - this is always 0.')
ieee8023MacMultipleCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacMultipleCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacMultipleCollisions.setDescription('Number of transmit attempts that are involved in between 2 and 15 collision attempts and are subsequently transmitted successfully. SunOS with Intel 82586 is always 0. SunOS with AMD 7990 LANCE driver - number of transmit attempts that are involved in between 1 and 15 collision attempts and are subsequently transmitted successfully.')
ieee8023MacExcessCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacExcessCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacExcessCollisions.setDescription('Number of transmit attempts that are involved in more than 15 collision attempts and are subsequently transmitted successfully. SunOS with Intel 82586 Ethernet driver - this is always 0.')
ieee8023MacLateCollisions = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacLateCollisions.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacLateCollisions.setDescription('Number of transmit attempts aborted because a collision occurred after the allotted channel time had elapsed.')
ieee8023MacCarrierLostErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacCarrierLostErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacCarrierLostErrors.setDescription('Number of times that carrier sense was lost when attempting to transmit.')
ieee8023MacNoHeartBeatErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacNoHeartBeatErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacNoHeartBeatErrors.setDescription('Number of times no heart beat was indicated after a transmission.')
ieee8023MacFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacFramesReceived.setDescription('Number of frames successfully received.')
ieee8023MacUndeliverableFramesReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacUndeliverableFramesReceived.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacUndeliverableFramesReceived.setDescription('Number of frames received that were not delivered because the software buffer was overrun when frames were sent faster than they could be received.')
ieee8023MacCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacCRCErrors.setDescription('Number of Cyclical Redundancy Check (CRC) errors detected.')
ieee8023MacAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacAlignmentErrors.setDescription('Number of frames received that were both misaligned and had bad CRC.')
ieee8023MacResourceErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacResourceErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacResourceErrors.setDescription('Number of frames received that were lost due to lack of resources.')
ieee8023MacControlFieldErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacControlFieldErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacControlFieldErrors.setDescription('Number of frames received with errors in the control field. SunOS - this is always 0.')
ieee8023MacUnknownProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacUnknownProtocolErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacUnknownProtocolErrors.setDescription('Number of frames dropped because the type field or sap field referenced an invalid protocol. SunOS - this is always 0.')
ieee8023MacMulticastsAccepted = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 4, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ieee8023MacMulticastsAccepted.setStatus('mandatory')
if mibBuilder.loadTexts: ieee8023MacMulticastsAccepted.setDescription('Number of accepted muliticast addresses.')
icmpEchoReq = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpEchoReq.setStatus('mandatory')
if mibBuilder.loadTexts: icmpEchoReq.setDescription("The number of milliseconds it takes for an ICMP echo request to respond. IcmpEchoReq is -1 if there is an internal error, -2 if the echo request timed out, -3 if the echo reply is not the correct reply, -4 if the packet size is too large, and -5 if the timeout is invalid. To request the ICMP response time for IP address a1.a2.a3.a4 with a timeout of t and a packet size of s, send a request for icmpEchoReq.s.t.a1.a2.a3.a4. For example, suppose one wanted to find out the number of milliseconds it took to ping 15.2.112.113, with time out of 8 seconds, and packet size of 75. Accordingly, icmpEchoReq.75.8.15.2.112.113 would identify the number of milliseconds. This MIB object is there only to provide for backward compatibility. A new MIB object is provided which does not violate the SNMP standards too, 'icmp.icmpEchoReqTable.icmpEchoReqEntry.icmpEchoReqTime'. This new MIB object is recommended to be used to achieve the same funtionality as provided by this (icmp.icmpEchoReq) MIB object.")
icmpEchoReqTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 7, 2), )
if mibBuilder.loadTexts: icmpEchoReqTable.setStatus('mandatory')
if mibBuilder.loadTexts: icmpEchoReqTable.setDescription('A conceptual table holding the ICMP response times for various remote hosts. The table is a conceptual one in the sense that, the table actually contains no data. When a query for the table object icmpEchoReqTime is received by the agent an ICMP echo request is sent to the remote host, the ICMP echo reply is received, the elapsed time is calculated and is sent back as the response. Note that except the columnar object icmpEchoReqTime other objects in the table, viz., icmpEchoReqPktSize, icmpEchoReqTimeout and icmpEchoReqHost, have ACCESS previlege as not-accessible, those variables cannot be queried for. The table entries have the objects icmpEchoReqPktSize, icmpEchoReqTimeout and icmpEchoReqHost as the indices, which is effectively a way of transfering these required details to the agent, so that the agent could do its function and respond appropriately.')
icmpEchoReqEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 7, 2, 1), ).setIndexNames((0, "HP-UNIX", "icmpEchoReqPktSize"), (0, "HP-UNIX", "icmpEchoReqTimeOut"), (0, "HP-UNIX", "icmpEchoReqHost"))
if mibBuilder.loadTexts: icmpEchoReqEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icmpEchoReqEntry.setDescription('Each entry in the table icmpEchoReqTable is a conceptual one. See description of icmpEchoReqTable for more details.')
icmpEchoReqTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 7, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpEchoReqTime.setStatus('mandatory')
if mibBuilder.loadTexts: icmpEchoReqTime.setDescription('The elapsed time between the time the ICMP echo request is sent to the host identified by the index object icmpEchoReqHost and the time the ICMP echo reply is received at the agent host. The ICMP packet size and the time out to be used for the ICMP echo request are identified by the indices icmpEchoReqPktSize and icmpEchoReqTimeOut. See description of icmpEchoReqTable for more details. In other words, the number of milliseconds it takes for an ICMP echo request to respond. Other return values: -1 if there is an internal error, -2 if the echo request timed out, -3 if the echo reply is not the correct reply, -4 if the packet size is too large, and -5 if the timeout is invalid. To request the ICMP response time for IP address a1.a2.a3.a4 with a timeout of t and a packet size of s, send a request for icmpEchoReqTime.s.t.a1.a2.a3.a4. For example, suppose one wanted to find out the number of milliseconds it took to ping 15.2.112.113, with time out of 8 seconds, and packet size of 75. Accordingly, icmpEchoReqTime.75.8.15.2.112.113 would identify the number of milliseconds.')
icmpEchoReqPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 7, 2, 1, 2), Integer32())
if mibBuilder.loadTexts: icmpEchoReqPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: icmpEchoReqPktSize.setDescription("The packet size to be used for the ICMP echo request, see description of icmpEchoReqTable for more details. The object serves as the first index out of three indices used when the object icmpEchoReqTime is queried. Note that this object's value cannot be queried for, this object serves as an input to the agent itself and a query for this object makes no sense.")
icmpEchoReqTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 7, 2, 1, 3), Integer32())
if mibBuilder.loadTexts: icmpEchoReqTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: icmpEchoReqTimeOut.setDescription("The time period in seconds to wait for an ICMP echo reply message after an ICMP echo request is sent to the identified host, see description of icmpEchoReqTable for more details. The object serves as the second index out of three indices used when the object icmpEchoReqTime is queried. Note that this object's value cannot be queried for, this object serves as an input to the agent itself and a query for this object makes no sense.")
icmpEchoReqHost = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 7, 2, 1, 4), IpAddress())
if mibBuilder.loadTexts: icmpEchoReqHost.setStatus('mandatory')
if mibBuilder.loadTexts: icmpEchoReqHost.setDescription("The host to which the ICMP echo request is to be sent, the ping time between the host identified by this index object and the agent's host is what is queried for, see description of icmpEchoReqTable for more details. The object serves as the last index out of three indices used when the object icmpEchoReqTime is queried. Note that this object's value cannot be queried for, this object serves as an input to the agent itself and a query for this object makes no sense.")
trapDestinationNum = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trapDestinationNum.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestinationNum.setDescription('The number of trap destinations.')
trapDestinationTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 2), )
if mibBuilder.loadTexts: trapDestinationTable.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestinationTable.setDescription('List of addresses to which the agent sends traps.')
trapDestinationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 2, 1), ).setIndexNames((0, "HP-UNIX", "trapDestination"))
if mibBuilder.loadTexts: trapDestinationEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestinationEntry.setDescription('Each entry contains the address of a management station.')
trapDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 1, 2, 1, 1), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: trapDestination.setStatus('mandatory')
if mibBuilder.loadTexts: trapDestination.setDescription('Address to which the agent sends traps.')
snmpdConfRespond = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpdConfRespond.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdConfRespond.setDescription('The SNMP agent was configured to respond to all objects if snmpdConfRespond is true. HP-Internal use only.')
snmpdReConfigure = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpdReConfigure.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdReConfigure.setDescription('The agent will re-configure itself if snmpdReConfigure is set to reset(1)')
snmpdFlag = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("removetrap", 1), ("netwareproxy", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpdFlag.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdFlag.setDescription('Indicates the capability of the agent.')
snmpdLogMask = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpdLogMask.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdLogMask.setDescription("The agent's log mask.")
snmpdVersion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpdVersion.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdVersion.setDescription("The agent's version number.")
snmpdStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: snmpdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdStatus.setDescription('Indicates the status of the agent. Setting the agent to down will kill it.')
snmpdSize = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpdSize.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdSize.setDescription('The amount of memory the agent has allocated.')
snmpdWhatString = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 13, 2, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snmpdWhatString.setStatus('mandatory')
if mibBuilder.loadTexts: snmpdWhatString.setDescription('The what string of the agent.')
isClustered = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("standalone", 1), ("rootserver", 2), ("cnode", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: isClustered.setStatus('mandatory')
if mibBuilder.loadTexts: isClustered.setDescription('Describes whether machine is clustered or not.')
clusterTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2), )
if mibBuilder.loadTexts: clusterTable.setStatus('mandatory')
if mibBuilder.loadTexts: clusterTable.setDescription('List of nodes on the cluster.')
clusterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1), ).setIndexNames((0, "HP-UNIX", "clusterID"))
if mibBuilder.loadTexts: clusterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: clusterEntry.setDescription('Each entry contains information about the clustered node.')
clusterID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterID.setStatus('mandatory')
if mibBuilder.loadTexts: clusterID.setDescription('The cnode id.')
clusterMachineID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterMachineID.setStatus('mandatory')
if mibBuilder.loadTexts: clusterMachineID.setDescription('The cnode machine id.')
clusterType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterType.setStatus('mandatory')
if mibBuilder.loadTexts: clusterType.setDescription('The cnode type (r or c).')
clusterCnodeName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCnodeName.setStatus('mandatory')
if mibBuilder.loadTexts: clusterCnodeName.setDescription('The cnode name.')
clusterSwapServingCnode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterSwapServingCnode.setStatus('mandatory')
if mibBuilder.loadTexts: clusterSwapServingCnode.setDescription('The swap serving cnode.')
clusterKcsp = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterKcsp.setStatus('mandatory')
if mibBuilder.loadTexts: clusterKcsp.setDescription('KCSP.')
clusterCnodeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 2, 1, 7), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCnodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: clusterCnodeAddress.setDescription('The cnode IP Address.')
clusterCnodeID = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 3, 1, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: clusterCnodeID.setStatus('mandatory')
if mibBuilder.loadTexts: clusterCnodeID.setDescription("The machine's cnodes id")
authFailTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 13, 4, 1), )
if mibBuilder.loadTexts: authFailTable.setStatus('mandatory')
if mibBuilder.loadTexts: authFailTable.setDescription('List of managers that caused an authentication failure. This list has a maximum size.')
authFailEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 13, 4, 1, 1), ).setIndexNames((0, "HP-UNIX", "authIpAddress"))
if mibBuilder.loadTexts: authFailEntry.setStatus('mandatory')
if mibBuilder.loadTexts: authFailEntry.setDescription('Each entry contains the ip address of the management station.')
authIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 4, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: authIpAddress.setDescription('The ip address of the management station that sent a request to the agent with an incorrect community name.')
authTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 4, 1, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authTime.setStatus('mandatory')
if mibBuilder.loadTexts: authTime.setDescription('The time since the agent received the un-authenticated request.')
authCommunityName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 13, 4, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: authCommunityName.setStatus('mandatory')
if mibBuilder.loadTexts: authCommunityName.setDescription('The community name used in the request')
openViewSourceId = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 1), Integer32())
if mibBuilder.loadTexts: openViewSourceId.setStatus('mandatory')
if mibBuilder.loadTexts: openViewSourceId.setDescription('The identifier of the software generating the trap/event. This number is used by HP OpenView software when it sends an event to the OpenView event system. It identifies which software component sent the event. This object cannot be retrieved from the SNMP agent.')
openViewSourceName = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 2), OctetString())
if mibBuilder.loadTexts: openViewSourceName.setStatus('mandatory')
if mibBuilder.loadTexts: openViewSourceName.setDescription('The source of the event (may not be the machine upon which the event was generated). This string is used by HP OpenView software when it sends an event. It identifies for which source (node) the event is generated. This object cannot be retrieved from the SNMP agent.')
openViewObjectId = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 3), OctetString())
if mibBuilder.loadTexts: openViewObjectId.setStatus('mandatory')
if mibBuilder.loadTexts: openViewObjectId.setDescription('The OpenView object identifier associated with the source of the trap/event. This object cannot be retrieved from the SNMP agent.')
openViewData = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 4), OctetString())
if mibBuilder.loadTexts: openViewData.setStatus('mandatory')
if mibBuilder.loadTexts: openViewData.setDescription('Any miscellaneous data sent with an OpenView trap/event. This object cannot be retrieved from the SNMP agent.')
openViewSeverity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 5), OctetString())
if mibBuilder.loadTexts: openViewSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: openViewSeverity.setDescription('The OpenView event severity associated with the trap/event. This object cannot be retrieved from the SNMP agent.')
openViewCategory = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 6), OctetString())
if mibBuilder.loadTexts: openViewCategory.setStatus('mandatory')
if mibBuilder.loadTexts: openViewCategory.setDescription('The OpenView event category associated with the trap/event. This object cannot be retrieved from the SNMP agent.')
openViewFilter = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 7), OctetString())
if mibBuilder.loadTexts: openViewFilter.setStatus('mandatory')
if mibBuilder.loadTexts: openViewFilter.setDescription('The event filter for an application connecting to the OpenView event system. This object cannot be retrieved from the SNMP agent.')
openViewEntity = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 8), OctetString())
if mibBuilder.loadTexts: openViewEntity.setStatus('mandatory')
if mibBuilder.loadTexts: openViewEntity.setDescription('The entity (string name) of an application connecting to the OpenView event system. This object cannot be retrieved from the SNMP agent.')
openViewAddress = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 9), OctetString())
if mibBuilder.loadTexts: openViewAddress.setStatus('mandatory')
if mibBuilder.loadTexts: openViewAddress.setDescription('The IP address of the node from where an application is connecting to the OpenView event system. This object cannot be retrieved from the SNMP agent.')
openViewPid = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 17, 2, 10), OctetString())
if mibBuilder.loadTexts: openViewPid.setStatus('mandatory')
if mibBuilder.loadTexts: openViewPid.setDescription('The process ID of an application connecting to the OpenView event system. This object cannot be retrieved from the SNMP agent.')
mibBuilder.exportSymbols("HP-UNIX", hp9000s300=hp9000s300, cluster=cluster, trapDestinationNum=trapDestinationNum, snmpdFlag=snmpdFlag, nm=nm, processFlags=processFlags, openViewSourceName=openViewSourceName, computerSystemAvgJobs1=computerSystemAvgJobs1, hpux=hpux, ieee8023MacNoHeartBeatErrors=ieee8023MacNoHeartBeatErrors, snmpdLogMask=snmpdLogMask, openViewCategory=openViewCategory, processMinor=processMinor, ieee8023MacCollisions=ieee8023MacCollisions, authFailTable=authFailTable, snmpdConf=snmpdConf, processTable=processTable, snmpdVersion=snmpdVersion, hpsun=hpsun, interface=interface, authFailEntry=authFailEntry, ieee8023MacResourceErrors=ieee8023MacResourceErrors, trapDestination=trapDestination, fileSystemBfree=fileSystemBfree, fileSystemBlock=fileSystemBlock, ieee8023MacNotTransmitted=ieee8023MacNotTransmitted, fileSystemFfree=fileSystemFfree, processPgrp=processPgrp, computerSystemUserCPU=computerSystemUserCPU, computerSystemEnabledSwap=computerSystemEnabledSwap, processStatus=processStatus, authTime=authTime, clusterCnodeAddress=clusterCnodeAddress, computerSystemFreeSwap=computerSystemFreeSwap, icmpEchoReqEntry=icmpEchoReqEntry, general=general, processNice=processNice, processUtime=processUtime, sun4=sun4, processPrio=processPrio, fileSystem=fileSystem, sun5=sun5, ieee8023MacExcessCollisions=ieee8023MacExcessCollisions, icmpEchoReqTime=icmpEchoReqTime, fileSystemID1=fileSystemID1, processRssize=processRssize, fileSystemEntry=fileSystemEntry, icmpEchoReqHost=icmpEchoReqHost, snmpdReConfigure=snmpdReConfigure, fileSystemTable=fileSystemTable, ieee8023MacMulticastsAccepted=ieee8023MacMulticastsAccepted, processCPU=processCPU, clusterTable=clusterTable, authfail=authfail, processCPUticksTotal=processCPUticksTotal, snmp=snmp, authCommunityName=authCommunityName, processEntry=processEntry, processCmd=processCmd, processSUID=processSUID, openViewFilter=openViewFilter, processUID=processUID, computerSystemUpTime=computerSystemUpTime, openViewEntity=openViewEntity, computerSystemAvgJobs5=computerSystemAvgJobs5, computerSystemPhysMemory=computerSystemPhysMemory, processStart=processStart, openViewSeverity=openViewSeverity, computerSystemNiceCPU=computerSystemNiceCPU, computerSystemAvgJobs15=computerSystemAvgJobs15, processes=processes, system=system, ieee8023MacFramesReceived=ieee8023MacFramesReceived, ieee8023MacTransmitted=ieee8023MacTransmitted, icmpEchoReqTimeOut=icmpEchoReqTimeOut, processAddr=processAddr, snmpdSize=snmpdSize, processTime=processTime, icmpEchoReqTable=icmpEchoReqTable, processUname=processUname, fileSystemFiles=fileSystemFiles, hpOpenView=hpOpenView, authIpAddress=authIpAddress, ieee8023Mac=ieee8023Mac, clusterSwapServingCnode=clusterSwapServingCnode, processIdx=processIdx, clusterCnodeName=clusterCnodeName, hp9000s800=hp9000s800, ieee8023MacDeferred=ieee8023MacDeferred, ieee8023MacUndeliverableFramesReceived=ieee8023MacUndeliverableFramesReceived, clusterID=clusterID, processStime=processStime, processMajor=processMajor, hp=hp, clusterEntry=clusterEntry, processDsize=processDsize, hp9000s700=hp9000s700, sparc=sparc, ieee8023MacTable=ieee8023MacTable, ieee8023MacSingleCollisions=ieee8023MacSingleCollisions, hp386=hp386, snmpdWhatString=snmpdWhatString, clusterMachineID=clusterMachineID, openViewData=openViewData, clusterCnodeID=clusterCnodeID, computerSystem=computerSystem, trap=trap, computerSystemSwapConfig=computerSystemSwapConfig, ieee8023MacMultipleCollisions=ieee8023MacMultipleCollisions, clusterKcsp=clusterKcsp, openViewObjectId=openViewObjectId, ieee8023MacControlFieldErrors=ieee8023MacControlFieldErrors, processFss=processFss, computerSystemIdleCPU=computerSystemIdleCPU, fileSystemMounted=fileSystemMounted, processTTY=processTTY, snmpdStatus=snmpdStatus, openViewPid=openViewPid, computerSystemSysCPU=computerSystemSysCPU, processWchan=processWchan, openViewTrapVars=openViewTrapVars, ieee8023MacLateCollisions=ieee8023MacLateCollisions, fileSystemBsize=fileSystemBsize, processNum=processNum, computerSystemUsers=computerSystemUsers, ieee8023MacAlignmentErrors=ieee8023MacAlignmentErrors, ieee8023MacIndex=ieee8023MacIndex, ieee8023MacEntry=ieee8023MacEntry, processTsize=processTsize, fileSystemBavail=fileSystemBavail, computerSystemMaxProc=computerSystemMaxProc, ieee8023MacCRCErrors=ieee8023MacCRCErrors, trapDestinationEntry=trapDestinationEntry, openViewSourceId=openViewSourceId, openView=openView, processProcNum=processProcNum, icmp=icmp, processPPID=processPPID, trapDestinationTable=trapDestinationTable, fileSystemID2=fileSystemID2, processSsize=processSsize, isClustered=isClustered, processPctCPU=processPctCPU, processCPUticks=processCPUticks, ieee8023MacCarrierLostErrors=ieee8023MacCarrierLostErrors, icmpEchoReqPktSize=icmpEchoReqPktSize, snmpdConfRespond=snmpdConfRespond, computerSystemMaxUserMem=computerSystemMaxUserMem, ieee8023MacUnknownProtocolErrors=ieee8023MacUnknownProtocolErrors, clusterType=clusterType, fileSystemName=fileSystemName, fileSystemDir=fileSystemDir, processPID=processPID, openViewAddress=openViewAddress, computerSystemFreeMemory=computerSystemFreeMemory, icmpEchoReq=icmpEchoReq)

#
# PySNMP MIB module CXVR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CXVR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:33:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection")
Alias, cxVR = mibBuilder.importSymbols("CXProduct-SMI", "Alias", "cxVR")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, MibIdentifier, Unsigned32, Bits, ModuleIdentity, NotificationType, iso, TimeTicks, ObjectIdentity, Integer32, Counter32, IpAddress, Counter64 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "MibIdentifier", "Unsigned32", "Bits", "ModuleIdentity", "NotificationType", "iso", "TimeTicks", "ObjectIdentity", "Integer32", "Counter32", "IpAddress", "Counter64")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
vrRegTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10), )
if mibBuilder.loadTexts: vrRegTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegTable.setDescription('The Voice Routing group table.')
vrRegEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10, 1), ).setIndexNames((0, "CXVR-MIB", "vrRegDialNo"))
if mibBuilder.loadTexts: vrRegEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegEntry.setDescription('An entry in the Voice Routing Group Table.')
vrRegDialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRegDialNo.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegDialNo.setDescription('This is the table index.')
vrRegState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("vrOk", 1), ("vrAgedOut", 2), ("vrTableFull", 3), ("vrMemallocFail", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRegState.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegState.setDescription('Current registration state. Options: vrOk (1): vrAgedOut (2): vrTableFull (3): vrMemallocFail (4): Default Value: None ')
vrRegVceStationId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRegVceStationId.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegVceStationId.setDescription('Displays the Station ID name. Range of Values: From 0 to 15 ')
vrRegVceSoftId = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRegVceSoftId.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegVceSoftId.setDescription('Displays the VCE software ID name. Range of Values: From 0 to 15 alphanumeric characters.')
vrRegSlotNo = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRegSlotNo.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegSlotNo.setDescription('This parameter displays the slot number in which the VCE CPU resides. Range of Values: From 1 to 16 Default Value: None')
vrRegHuntChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 10, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRegHuntChannel.setStatus('mandatory')
if mibBuilder.loadTexts: vrRegHuntChannel.setDescription('The string that represents the Hunt Channel number in 32 bits wide bit map in hexadecimal format. Range of Values: From 0 to 8 ')
vrConfigGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20))
vrConfigNodeId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31)).clone('VoiceRouting')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigNodeId.setDescription('Allows you to create a unique name for the frame relay node. Range of Values: Up to 32 characters Default Value: VoiveRouting')
vrConfigSoftId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrConfigSoftId.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigSoftId.setDescription('Displays the software version number. ')
vrConfigNoOfSysRouteSupported = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigNoOfSysRouteSupported.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigNoOfSysRouteSupported.setDescription('Maximum number of routing definitions that can be supported in the VR table. Range of Values: From 1 to 1024 Default Value: 1')
vrConfigNoOfDigitSupported = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 7))).clone(namedValues=NamedValues(("dig5", 5), ("dig7", 7))).clone('dig5')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigNoOfDigitSupported.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigNoOfDigitSupported.setDescription('The maximum number of digits to be used for dial extension numbers over the entire network. Options: dig5 (5): The maximum number is five digits. dig7 (7): The maximum number is seven digits. (FOR FUTURE USE ONLY). Default Value: dig5 (5)')
vrConfigMaxBufferPoolSize = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigMaxBufferPoolSize.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigMaxBufferPoolSize.setDescription('Maximum number of OS buffers that can be queued at any time in the VR fifos. Range of Values: From 0 to 1000 Note: Zero (0) means that Voice/Fax packets are routed immediately (never queued). Default Values: 0 ')
vrConfigFastSwitchingOption = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vrprtysmall", 1), ("vrprtyroute", 2))).clone('vrprtysmall')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigFastSwitchingOption.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigFastSwitchingOption.setDescription('This object refers to Dial Digit Packing for transmission of the extension numbers. The digits can be sent either 2 bytes or 4 bytes long. Options: vrprtysmall (1): The priority (using 2 bytes) is to minimize the amount of bandwidth used. This option is more CPU intensive, and slower. vrprtyroute (2): The priority (using 4 bytes) is speed. This option will minimize CPU usage but will require more bandwidth. Default Value: vrprtysmall (1)')
vrConfigStatsSamplingPeriod = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3600)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigStatsSamplingPeriod.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigStatsSamplingPeriod.setDescription('This parameter allows you to set the polling interval (in seconds) for statistics. Range of Values: From 0 to 3600 Default Value: 15')
vrConfigControl = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vrcfgidle", 1), ("vrcfgrte", 2), ("vrcfgreg", 3))).clone('vrcfgidle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigControl.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigControl.setDescription('This object allows you to control the statistics in the VRSR table and the entries in the VR register table. Options: vrcfgidle(1): Control is turned off vrcfgrte(2): This option clears the statistics in the VRSR table. vrcfgreg(3): This options ages out the voice routing register of local extensions. Default Value: vrcfgidle (1)')
vrConfigOptimization = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vroptdisabled", 1), ("vroptenabled", 2), ("vroptbwmgt", 3))).clone('vroptbwmgt')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrConfigOptimization.setStatus('mandatory')
if mibBuilder.loadTexts: vrConfigOptimization.setDescription('This object allows you to enable and disable the optimization in the Voice, VR and FR modules. Options: vroptdisabled(1): Optimization code is turned off. This option enables backwards compatibility with older versions of VR software. This option will be removed in future releases. vroptenabled(2): Optimization code is turned on. This enables VR, Voice application module and Frame Relay Multiprotocol Encapsulation to use less bandwidth. this option will be removed in the future releases. vroptbwmgt(3): Optimization code is turned on plus enhancement for bandwidth management. This option is similar to option 2, in addition to when Bandwidth Management is enabled and there is no more bandwidth left on the link, then by chosing this option, it will stop any new voice call establishement. This is the default value and is the recommended value to use. Default Value: vroptbwmgt (3)')
vrMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 20, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: vrMibLevel.setDescription('Used to determine current MIB module release supported by the agent. Object is in decimal.')
vrStatGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30))
vrStatInitState = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 10))).clone(namedValues=NamedValues(("vrDead", 1), ("vrUnrecoverableError", 2), ("vrTablesBuilt", 3), ("vrConfigRead", 4), ("vrInitialized", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatInitState.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatInitState.setDescription('VR module initialisation state. Options: vrDead (1): vrUnrecoverableError (2): vrTablesBuilt (3): vrConfigRead (4): vrInitialized (10)')
vrStatLongestMuxPassInMs = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatLongestMuxPassInMs.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatLongestMuxPassInMs.setDescription('Longest time recorded yet for a same multiplexing pass. Relevant only if pool is different from zero.')
vrStatNbPacketsForwardedPerSec = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbPacketsForwardedPerSec.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbPacketsForwardedPerSec.setDescription('No. of packets per second forwarded by VR during the last sampling period')
vrStatNbRoutingConflicts = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbRoutingConflicts.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbRoutingConflicts.setDescription('No.of times a routing conflict has been detected when adding a routing entry.')
vrStatRegOverallNumber = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatRegOverallNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatRegOverallNumber.setDescription('Current number of local registration blocks.')
vrStatRegNotOwner = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatRegNotOwner.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatRegNotOwner.setDescription('Dial number not registered or refreshed because the requester is not owner of it.')
vrStatRegInvalidDialNumber = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatRegInvalidDialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatRegInvalidDialNumber.setDescription('The dial number is invalid and cannot be registered.')
vrStatRegFormatError = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatRegFormatError.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatRegFormatError.setDescription('Dial number not registered or refreshed because of a format error in the request.')
vrStatNbVceMsgRx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 75), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbVceMsgRx.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbVceMsgRx.setDescription('Number of messages received from the VCE module.')
vrStatNbVceMsgTx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 76), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbVceMsgTx.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbVceMsgTx.setDescription('Number of messages transmitted from the VCE module.')
vrStatNbBusMsgRx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 77), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbBusMsgRx.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbBusMsgRx.setDescription('Number of messages received from the TBC module.')
vrStatNbBusMsgTx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 78), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbBusMsgTx.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbBusMsgTx.setDescription('Number of messages transmitted from the TBC module.')
vrStatNbWanMsgRx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 79), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbWanMsgRx.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbWanMsgRx.setDescription('Number of messages received from the WAN.')
vrStatNbWanMsgTx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 80), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbWanMsgTx.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbWanMsgTx.setDescription('Number of messages transmitted from the WAN.')
vrStatNbOutboundQueueFull = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 81), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbOutboundQueueFull.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbOutboundQueueFull.setDescription('Number of times the buffer queue has been exceeded. (Irrelevant if pool is set to zero.)')
vrStatNbOverallForwards = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 90), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbOverallForwards.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbOverallForwards.setDescription('Number of overall packets (voice + other applications) forwarded.')
vrStatNbOverallDiscards = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 91), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbOverallDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbOverallDiscards.setDescription('Number of overall packets (voice + other applications) discarded.')
vrStatNbDeadEnds = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 92), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatNbDeadEnds.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatNbDeadEnds.setDescription('Number of times the routing process did not find any routing definition block for a specific dial number. This also increments the alldsc object.')
vrStatError = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 93), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatError.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatError.setDescription('Sum of many counters under vrStat.error.xxx, vrStat.ianIfError, etc.')
vrStatFieldsAddress = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 94), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatFieldsAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatFieldsAddress.setDescription('vrStat starting address. Range of Values: From 0 to 10')
vrStatIamUnxFieldAddress = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 30, 95), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrStatIamUnxFieldAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrStatIamUnxFieldAddress.setDescription('IAM unexpected event table address. Range of Values: From 0 to 10')
vrSrTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40), )
if mibBuilder.loadTexts: vrSrTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrTable.setDescription('The Voice Routing System Routes table.')
vrSrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1), ).setIndexNames((0, "CXVR-MIB", "vrSrIndex"))
if mibBuilder.loadTexts: vrSrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrEntry.setDescription('An entry in the Voice Routing System Routes Table.')
vrSrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrIndex.setDescription('System route index. Range of Values: From 1 to 1024')
vrSrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrSrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrRowStatus.setDescription("Indicates whether this specific entry is configured within the MIB. Entries (rows) may be created by setting this object value to 'valid', or deleted by changing this object value to 'invalid'. Options: invalid (1): Entries can be deleted valid (2): Entries can be created")
vrSrDestAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 3), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrSrDestAlias.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrDestAlias.setDescription('Destination string.')
vrSrSubRef = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrSrSubRef.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrSubRef.setDescription('Sub-reference number for multi-protocol encapsulation. Range of Values: From 1 to 31 Default Value: 1')
vrSrBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrSrBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrBandwidth.setDescription('Maximum Bandwidth allowed for the FR Link in Kbps. Note: If set to zero (0) bandwidth management is disabled')
vrSrBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrSrBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrBwIndex.setDescription('The index for bandwidth that corresponds to the vrBwEntry')
vrSrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("vrSrDown", 1), ("vrSrInFlowCtl", 2), ("vrSrUp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrStatus.setDescription('Current VR system route status. Options: vrSrDown (1): vrSrInFlowCtl (2): vrSrUp (3):')
vrSrConStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("vrNotConfigured", 1), ("vrClose", 2), ("vrWaitForQuery", 3), ("vrWaitForOpenConf", 4), ("vrOpen", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrConStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrConStatus.setDescription('Current status of the connection establishment through IAM. Options: vrNotConfigured (1): vrClose (2): vrWaitForQuery (3): vrWaitForOpenConf (4): vrOpen (5):')
vrSrFailStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15))).clone(namedValues=NamedValues(("vrNoFailure", 1), ("vrInternalError", 2), ("vrLocalMemFail", 3), ("vrRemMemFail", 4), ("vrRemNoAcces", 5), ("vrRemPvcDown", 6), ("vrRemPvcBusy", 7), ("vrLocalFcnFailure", 8), ("vrRemFcnFailure", 9), ("vrLocalDsnFailure", 10), ("vrRemAliasNotFound", 11), ("vrNoPvcService", 12), ("vrOpenReqTimeout", 13), ("vrAdjaReset", 14), ("vrUnsupportedSR", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrFailStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrFailStatus.setDescription('Current fail status of the connection establishment through IAM. Options: vrNoFailure (1): vrInternalError (2): vrLocalMemFail (3): vrRemMemFail (4): vrRemNoAcces (5): vrRemPvcDown (6): vrRemPvcBusy (7): vrLocalFcnFailure (8): vrRemFcnFailure (9): vrLocalDsnFailure (10): vrRemAliasNotFound (11): vrNoPvcService (12): vrOpenReqTimeout (13): vrAdjaReset (14): vrUnsupportedSR (15):')
vrSrNbLinkDown = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbLinkDown.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbLinkDown.setDescription("The number of times that the system route has received a 'LINK_DOWN' with no route available notification.")
vrSrNbResetFrameRx = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbResetFrameRx.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbResetFrameRx.setDescription('Number of reset frames received.')
vrSrNbOutboundFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbOutboundFrame.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbOutboundFrame.setDescription('Number of outbound frames (Voice/FAX, signaling and VR applications).')
vrSrNbInboundFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbInboundFrame.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbInboundFrame.setDescription('Number of inbound frames (Voice/FAX, signaling and VR applications).')
vrSrNbOutboundBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbOutboundBw.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbOutboundBw.setDescription('Outbound WAN bandwidth required in BPS; this figure include the DLCI, the proprietary header for encapsulation (if used) and the CRC. The refresh period of that object depends on the stsmp object int the vrConfig group.')
vrSrNbInboundBw = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbInboundBw.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbInboundBw.setDescription('Inbound WAN bandwidth required in BPS; this figure include the DLCI, the proprietary header for encapsulation (if used) and the CRC. The refresh period of that object depends on the stsmp object int the vrConfig group.')
vrSrBwUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrBwUsed.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrBwUsed.setDescription('The bandwidth utilized in kilo BPS. This value is shown only if the bandwith management for this Source Route is enabled.')
vrSrNbCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbCalls.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbCalls.setDescription('The number of outstanding voice calls on this Vr Source Route. This value is shown only if the bandwith management for this Source Route is enabled.')
vrSrNbPktDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 40, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrSrNbPktDropped.setStatus('mandatory')
if mibBuilder.loadTexts: vrSrNbPktDropped.setDescription('The number of packets discarded due to Bandwidth management. When the bandwidth utilized on this VR Source Route reaches to its maximum bandwidth allowance, then this value represents the number of Voice packets discarded due to this fact.')
vrRouteTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 50), )
if mibBuilder.loadTexts: vrRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrRouteTable.setDescription('The Voice Routing table.')
vrRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 50, 1), ).setIndexNames((0, "CXVR-MIB", "vrRouteDialNo"))
if mibBuilder.loadTexts: vrRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrRouteEntry.setDescription('An entry in the Voice Routing Table.')
vrRouteDialNo = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 50, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRouteDialNo.setStatus('mandatory')
if mibBuilder.loadTexts: vrRouteDialNo.setDescription('Table index.')
vrRouteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 50, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrRouteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrRouteRowStatus.setDescription("Indicates whether this specific entry is configured within the MIB. Entries (rows) may be created by setting this object value to 'valid', or deleted by changing this object value to 'invalid'. Options: invalid (1): Entries can be deleted valid (2): Entries can be created ")
vrRouteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 50, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1111111)).clone(1111111)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrRouteMask.setStatus('mandatory')
if mibBuilder.loadTexts: vrRouteMask.setDescription('The selection of the mask will dictate which of the digits will be read. A zero (0) means that the digit in that position will not be read. A one (1) means that the digit in that position will be read. Range of Values: 0000000 1000000 1100000 1110000 1111000 1111100 1111110 1111111 Default Value: 1111111')
vrRouteSrNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 50, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrRouteSrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vrRouteSrNumber.setDescription('VR system route number to use for the outbound traffic. Range of Values: From 1 to 1024')
vrRouteForwardedPkt = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 50, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrRouteForwardedPkt.setStatus('mandatory')
if mibBuilder.loadTexts: vrRouteForwardedPkt.setDescription('The number of voice packets forwarded over the WAN.')
vrPingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60))
vrPingDialNo = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPingDialNo.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingDialNo.setDescription('Dial number to ping. Range of Values: From 0 to 9999999')
vrPingNbToBeSent = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4000000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPingNbToBeSent.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingNbToBeSent.setDescription('Number of pings to send after the trigger. (4,000,000 would mean one packet sent every 24 ms for 24 hours). 0 means stop the current ping session. Range of Values: From 0 to 4,000,000 Default Value: 1')
vrPingGapsInMs = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000)).clone(24)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPingGapsInMs.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingGapsInMs.setDescription('The interval in milliseconds between ping frames. Range of Values: From 0 to 1000 Default Value: 24')
vrPingMaxHopCount = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPingMaxHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingMaxHopCount.setDescription('Maximum Hop count allowed. Range of Values: From 1 to 256 Default Value: 16')
vrPingProbeReturnAddress = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9999999)).clone(9999999)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPingProbeReturnAddress.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingProbeReturnAddress.setDescription('Probe (i.e. ping/trace/search) return dial number. Range of Values: From 0 to 9999999 Default Value: 9999999')
vrPingTriggerSend = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vrIdle", 1), ("vrSend", 2))).clone('vrIdle')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrPingTriggerSend.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingTriggerSend.setDescription('Trigger the pings to be sent. Options: vrIdle (1): No pings are sent vrSend (2): The counter is set to zero and pings will be sent')
vrPingNbReplyRx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingNbReplyRx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingNbReplyRx.setDescription('Count the number of ping replies received')
vrPingFormatError = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingFormatError.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingFormatError.setDescription('Count the number of non-recognizable ping replies.')
vrPingNbVrNodesCrossedForward = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingNbVrNodesCrossedForward.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingNbVrNodesCrossedForward.setDescription('The number of nodes hopped outbound (forward). When compared to the number of hops inbound (backward) the difference can help trace the path.')
vrPingNbVrNodesCrossedBackward = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingNbVrNodesCrossedBackward.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingNbVrNodesCrossedBackward.setDescription('The number of nodes hopped inbound (Backward). When compared to the number of hops outbound (forward) the difference can help trace the path.')
vrPingLastRoundTripInMs = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingLastRoundTripInMs.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingLastRoundTripInMs.setDescription('The time in milliseconds that the ping took for its last round-trip.')
vrPingLastSequenceNumberRx = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingLastSequenceNumberRx.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingLastSequenceNumberRx.setDescription('The sequence number of the last ping received.')
vrPingSequenceError = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingSequenceError.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingSequenceError.setDescription('The sequence number of the last error received. Not available if the number of pings is set to one.')
vrPingMinRoundTripInMs = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingMinRoundTripInMs.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingMinRoundTripInMs.setDescription('The Minimum round trip time in milliseconds. This is not applicable if pinging is set to one (1).')
vrPingMaxRoundTripInMs = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingMaxRoundTripInMs.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingMaxRoundTripInMs.setDescription('the Maximum round trip time in milliseconds. this is not applicable if pinging is set to one (1).')
vrPingRemStatus = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5))).clone(namedValues=NamedValues(("vrOk", 1), ("vrUnknown", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemStatus.setDescription('The ping returns the status of the remote node. Options: vrOk (1): The remote is OK vrUnknown (5): Status unknown, there is no response.')
vrPingRemVrNodeId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemVrNodeId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemVrNodeId.setDescription('Displays the remote node ID. Range of Values: From 0 to 31')
vrPingRemVceStationId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 41), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemVceStationId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemVceStationId.setDescription('Displays the remote VCE station ID. Range of Values: from 0 to 15')
vrPingRemVrSoftId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 42), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemVrSoftId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemVrSoftId.setDescription('Displays the remote VR software version number. Range of Values: From 0 to 3')
vrPingRemVceSoftId = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemVceSoftId.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemVceSoftId.setDescription('Displays the remote VCE software version number.')
vrPingRemSlotIndex = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemSlotIndex.setDescription('The remote VCE slot number of the registered number')
vrPingRemHuntChannel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 45), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemHuntChannel.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemHuntChannel.setDescription('Displays the remote hunt channel number. Range of Values: From 0 to 8')
vrPingRemNbForwardedPacket = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemNbForwardedPacket.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemNbForwardedPacket.setDescription('Number of forwarded packets using that route definition block.')
vrPingRemNbRestart = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 60, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrPingRemNbRestart.setStatus('mandatory')
if mibBuilder.loadTexts: vrPingRemNbRestart.setDescription('No of times the attached VCE has restarted.')
vrBwTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70), )
if mibBuilder.loadTexts: vrBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwTable.setDescription('The Voice Routing Bandwidth Management table.')
vrBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70, 1), ).setIndexNames((0, "CXVR-MIB", "vrBwIndex"))
if mibBuilder.loadTexts: vrBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwEntry.setDescription('An entry in the Voice Routing Bandwidth Management Table.')
vrBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwIndex.setDescription('Total bandwidth index. Range of Values: From 1 to 32')
vrBwRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBwRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwRowStatus.setDescription("Indicates whether this specific entry is configured within the MIB. Entries (rows) may be created by setting this object value to 'valid', or deleted by changing this object value to 'invalid'. Options: invalid (1): Entries can be deleted valid (2): Entries can be created")
vrBwBandwidthCfg = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: vrBwBandwidthCfg.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwBandwidthCfg.setDescription('Maximum Bandwidth allowed for the FR Link in Kbps. Note: If set to zero (0) bandwidth management is disabled Default: 0 (disabled) Range of Values: From 0 to 65535')
vrBwBandwidthUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBwBandwidthUsed.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwBandwidthUsed.setDescription('Total bandwidth used on the FR Link in Kbps. Range of Values: From 0 to 65535')
vrBwNbCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBwNbCalls.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwNbCalls.setDescription('Total number of outstanding Voice sessions on that FR Link Range of Values: From 0 to 65535')
vrBwNbPktDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 50, 70, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vrBwNbPktDropped.setStatus('mandatory')
if mibBuilder.loadTexts: vrBwNbPktDropped.setDescription('The number of packets discarded due to Bandwidth management. When the bandwidth utilized on this VR Global Bandwidth management entry reaches to its maximum bandwidth allowance, then this value represents the number of Voice packets discarded due to this fact.')
mibBuilder.exportSymbols("CXVR-MIB", vrStatNbVceMsgRx=vrStatNbVceMsgRx, vrSrNbLinkDown=vrSrNbLinkDown, vrRegState=vrRegState, vrPingGroup=vrPingGroup, vrRegHuntChannel=vrRegHuntChannel, vrStatNbOverallForwards=vrStatNbOverallForwards, vrSrNbOutboundFrame=vrSrNbOutboundFrame, vrPingRemSlotIndex=vrPingRemSlotIndex, vrPingRemNbRestart=vrPingRemNbRestart, vrStatRegOverallNumber=vrStatRegOverallNumber, vrStatRegInvalidDialNumber=vrStatRegInvalidDialNumber, vrRouteForwardedPkt=vrRouteForwardedPkt, vrPingProbeReturnAddress=vrPingProbeReturnAddress, vrSrDestAlias=vrSrDestAlias, vrBwNbPktDropped=vrBwNbPktDropped, vrRouteSrNumber=vrRouteSrNumber, vrConfigStatsSamplingPeriod=vrConfigStatsSamplingPeriod, vrRouteTable=vrRouteTable, vrSrFailStatus=vrSrFailStatus, vrPingNbVrNodesCrossedBackward=vrPingNbVrNodesCrossedBackward, vrBwEntry=vrBwEntry, vrPingSequenceError=vrPingSequenceError, vrSrNbOutboundBw=vrSrNbOutboundBw, vrPingNbVrNodesCrossedForward=vrPingNbVrNodesCrossedForward, vrConfigNoOfDigitSupported=vrConfigNoOfDigitSupported, vrStatIamUnxFieldAddress=vrStatIamUnxFieldAddress, vrMibLevel=vrMibLevel, vrRegEntry=vrRegEntry, vrStatNbDeadEnds=vrStatNbDeadEnds, vrPingMaxHopCount=vrPingMaxHopCount, vrStatNbWanMsgTx=vrStatNbWanMsgTx, vrPingMaxRoundTripInMs=vrPingMaxRoundTripInMs, vrStatNbBusMsgTx=vrStatNbBusMsgTx, vrConfigControl=vrConfigControl, vrPingGapsInMs=vrPingGapsInMs, vrPingNbToBeSent=vrPingNbToBeSent, vrStatNbVceMsgTx=vrStatNbVceMsgTx, vrConfigGroup=vrConfigGroup, vrPingRemStatus=vrPingRemStatus, vrStatNbWanMsgRx=vrStatNbWanMsgRx, vrConfigNodeId=vrConfigNodeId, vrRegVceStationId=vrRegVceStationId, vrSrNbPktDropped=vrSrNbPktDropped, vrRegVceSoftId=vrRegVceSoftId, vrStatFieldsAddress=vrStatFieldsAddress, vrStatLongestMuxPassInMs=vrStatLongestMuxPassInMs, vrSrBwUsed=vrSrBwUsed, vrRouteEntry=vrRouteEntry, vrBwTable=vrBwTable, vrConfigOptimization=vrConfigOptimization, vrStatNbRoutingConflicts=vrStatNbRoutingConflicts, vrSrNbInboundFrame=vrSrNbInboundFrame, vrSrIndex=vrSrIndex, vrSrBwIndex=vrSrBwIndex, vrBwNbCalls=vrBwNbCalls, vrPingRemVceSoftId=vrPingRemVceSoftId, vrStatInitState=vrStatInitState, vrStatNbPacketsForwardedPerSec=vrStatNbPacketsForwardedPerSec, vrSrNbResetFrameRx=vrSrNbResetFrameRx, vrRegDialNo=vrRegDialNo, vrPingTriggerSend=vrPingTriggerSend, vrSrConStatus=vrSrConStatus, vrRegTable=vrRegTable, vrSrNbCalls=vrSrNbCalls, vrPingRemNbForwardedPacket=vrPingRemNbForwardedPacket, vrBwBandwidthCfg=vrBwBandwidthCfg, vrStatNbOverallDiscards=vrStatNbOverallDiscards, vrPingRemVrNodeId=vrPingRemVrNodeId, vrStatRegNotOwner=vrStatRegNotOwner, vrStatNbBusMsgRx=vrStatNbBusMsgRx, vrPingLastSequenceNumberRx=vrPingLastSequenceNumberRx, vrSrNbInboundBw=vrSrNbInboundBw, vrPingFormatError=vrPingFormatError, vrPingMinRoundTripInMs=vrPingMinRoundTripInMs, vrSrSubRef=vrSrSubRef, vrPingRemHuntChannel=vrPingRemHuntChannel, vrSrStatus=vrSrStatus, vrPingRemVrSoftId=vrPingRemVrSoftId, vrStatGroup=vrStatGroup, vrStatError=vrStatError, vrRouteDialNo=vrRouteDialNo, vrPingLastRoundTripInMs=vrPingLastRoundTripInMs, vrSrEntry=vrSrEntry, vrStatRegFormatError=vrStatRegFormatError, vrConfigFastSwitchingOption=vrConfigFastSwitchingOption, vrBwIndex=vrBwIndex, vrSrRowStatus=vrSrRowStatus, vrPingNbReplyRx=vrPingNbReplyRx, vrConfigSoftId=vrConfigSoftId, vrBwBandwidthUsed=vrBwBandwidthUsed, vrRouteRowStatus=vrRouteRowStatus, vrPingDialNo=vrPingDialNo, vrConfigMaxBufferPoolSize=vrConfigMaxBufferPoolSize, vrConfigNoOfSysRouteSupported=vrConfigNoOfSysRouteSupported, vrSrBandwidth=vrSrBandwidth, vrStatNbOutboundQueueFull=vrStatNbOutboundQueueFull, vrBwRowStatus=vrBwRowStatus, vrRegSlotNo=vrRegSlotNo, vrRouteMask=vrRouteMask, vrPingRemVceStationId=vrPingRemVceStationId, vrSrTable=vrSrTable)

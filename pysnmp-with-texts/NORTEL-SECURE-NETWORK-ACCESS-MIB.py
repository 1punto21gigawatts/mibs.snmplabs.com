#
# PySNMP MIB module NORTEL-SECURE-NETWORK-ACCESS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/NORTEL-SECURE-NETWORK-ACCESS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:24:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
InetPortNumber, InetAddressPrefixLength, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddressPrefixLength", "InetAddress", "InetAddressType")
VlanId, VlanIdOrNone = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId", "VlanIdOrNone")
IdList, = mibBuilder.importSymbols("RAPID-CITY", "IdList")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ObjectIdentity, MibIdentifier, Bits, Gauge32, Integer32, iso, Unsigned32, Counter64, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, TimeTicks, IpAddress, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "MibIdentifier", "Bits", "Gauge32", "Integer32", "iso", "Unsigned32", "Counter64", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "TimeTicks", "IpAddress", "ModuleIdentity")
DisplayString, TruthValue, RowStatus, MacAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "RowStatus", "MacAddress", "TextualConvention")
bayStackMibs, = mibBuilder.importSymbols("SYNOPTICS-ROOT-MIB", "bayStackMibs")
nortelSecureNetworkAccessMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 45, 5, 10))
nortelSecureNetworkAccessMib.setRevisions(('2007-06-29 00:00', '2007-05-21 00:00', '2007-04-18 00:00', '2007-03-13 00:00', '2006-11-30 00:00', '2006-07-07 00:00', '2006-05-22 00:00', '2006-05-19 00:00', '2006-04-26 00:00', '2006-02-24 00:00', '2005-10-24 00:00', '2005-08-18 00:00', '2005-08-10 00:00', '2005-07-28 00:00', '2005-07-18 00:00', '2005-07-07 00:00', '2005-06-22 00:00', '2005-06-02 00:00', '2005-05-04 00:00', '2005-04-21 00:00', '2005-04-19 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: nortelSecureNetworkAccessMib.setRevisionsDescriptions(('v21: Clarified description of nsnaNsnasStatusQuoInterval.', 'v20: Added additional enumerations in nsnaNsnasConnectionState.', 'v19: Change fail-open vlan objects to VlanIdOrNone.', 'v18: Undo last changes to fail-open objects.', 'v17: Added NSNAS RADIUS and Hub Mode support. Updated fail-open objects.', 'v16: Added nsnaNsnasConnectionVersion.', 'v15: Added nsnaClientStatus.', 'v14: Changes to make Fail-Open configurable on switch.', 'v13: Added objects for MAC authentication and Fail-Open features.', 'v12: Added nsnaSnasConnected.', 'v11: Added nsnaClientExpired.', 'v10: Changes for sscp negotiation of timer intervals.', 'v9: Clarify meaning of maximum status-quo interval value. Added objects for current SSCP connection status. Expanded range of nsnaVlanFilterSetName to 0..255.', 'v8: Add notification types.', 'v7: Add IMPLIED to index of IP phone signature string table.', 'v6: Added support for IP phone signature string configuration.', 'v5: Fixed naming of nsnaNsnasTable.', 'v4: Changed range of nsnaVlanFilterSetId to 0..1024. Changed nsnsPortGreenVlanId from VlanId to VlanIdOrNone.', 'v3: Fixed MAX-ACCESS for nsnaStatusQuoInterval.', 'v2: Added nsnaStatusQuoInterval. Changed DEFVAL for hello interval to 60 seconds.', 'v1: Initial version.',))
if mibBuilder.loadTexts: nortelSecureNetworkAccessMib.setLastUpdated('200706290000Z')
if mibBuilder.loadTexts: nortelSecureNetworkAccessMib.setOrganization('Nortel Networks')
if mibBuilder.loadTexts: nortelSecureNetworkAccessMib.setContactInfo('Nortel Networks')
if mibBuilder.loadTexts: nortelSecureNetworkAccessMib.setDescription("Nortel Networks NSNA MIB Copyright 2004 Nortel Networks, Inc. All rights reserved. This Nortel Networks SNMP Management Information Base Specification embodies Nortel Networks' confidential and proprietary intellectual property. Nortel Networks retains all title and ownership in the Specification, including any revisions. This Specification is supplied 'AS IS,' and Nortel Networks makes no warranty, either express or implied, as to the use, operation, condition, or performance of the Specification.")
nsnaNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 5, 10, 0))
nsnaObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 5, 10, 1))
class NsnaVlanIdOrNone(TextualConvention, Integer32):
    description = "The VLAN ID that uniquely identifies a specific VLAN, or no VLAN. The special value of zero is used to indicate that no VLAN ID is present or used. This can be used in any situation where an object or a table entry must refer either to a specific VLAN, or to no VLAN. Note that a MIB object that is defined using this TEXTUAL-CONVENTION should clarify the meaning of 'no VLAN' (i.e., the special value 0)."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4094), )
nsnaScalars = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1))
nsnaEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaEnabled.setStatus('current')
if mibBuilder.loadTexts: nsnaEnabled.setDescription('Indicates whether NSNA is globally enabled for the system.')
nsnaNsnasConnectionState = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("notConnected", 1), ("connected", 2), ("connecting", 3), ("closing", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasConnectionState.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasConnectionState.setDescription('Indicates whether the switch currently has a connection to an NSNAS, whether the switch is currently in the process of establishing a connection to an NSNAS, or whether an existing connecting to an NSNAS is in the process of being closed.')
nsnaNsnasInetAddressType = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasInetAddressType.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasInetAddressType.setDescription('If a NSNAS is currently connected to the switch, this indicates the type of the internet address from which the NSNAS connected. The contents of nsnaSnasInetAddress will be of this type. If there is not currently a NSNAS connected, the value will be unknown(0).')
nsnaNsnasInetAddress = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasInetAddress.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasInetAddress.setDescription('If a NSNAS is currently connected to the switch, this indicates the internet address from which the NSNAS connected. If there is not currently a NSNAS connected, this will be an empty string.')
nsnaNsnasSendHelloInterval = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasSendHelloInterval.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasSendHelloInterval.setDescription('The interval for sending SSCP Hello messages for the current SSCP connection. If this period of time passes without any SSCP messages being sent, a Hello message will be generated. If there is not curently an NSNAS connected, this value will be zero, otherwise it will be non-zero.')
nsnaNsnasInactivityInterval = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasInactivityInterval.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasInactivityInterval.setDescription('The inactivity interval for the current SSCP connection. If this period of time passes without any SSCP messages being received, the SSCP connection will be closed. If there is not curently an NSNAS connected, this value will be zero, otherwise it will be non-zero.')
nsnaNsnasStatusQuoInterval = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasStatusQuoInterval.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasStatusQuoInterval.setDescription('The status-quo interval for the current or last SSCP connection. If the NSNAS is disconnected from the switch for any reason, the switch will wait this period of time before moving all NSNA enabled ports to the red VLAN. The maximum value, 65535, indicates an infinite status quo interval, i.e., SSA enabled ports will not be moved to the red VLAN. A value of 0 means no status quo interval is used, and ports are immediately moved the the red VLAN if the NSNAS is disconnected. If the NSNAS has disconnected and the status-quo interval timer is running, this value will reflect the remaining time until the status-quo timer will expire.')
nsnaMacAuthenticationEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaMacAuthenticationEnabled.setStatus('current')
if mibBuilder.loadTexts: nsnaMacAuthenticationEnabled.setDescription('This object indicates whether MAC Authentication is currently enabled on the switch.')
nsnaFailOpenEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 10), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaFailOpenEnabled.setStatus('current')
if mibBuilder.loadTexts: nsnaFailOpenEnabled.setDescription('This object indicates whether the Fail-Open feature is currently enabled on the switch.')
nsnaFailOpenVlan = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 11), VlanIdOrNone()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaFailOpenVlan.setStatus('current')
if mibBuilder.loadTexts: nsnaFailOpenVlan.setDescription('This object indicates the current Fail-Open Vlan ID. A value of 0 indicates the value either has not been set, or that the previous value is no longer valid.')
nsnaFailOpenFilterVlan = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 12), VlanIdOrNone()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaFailOpenFilterVlan.setStatus('current')
if mibBuilder.loadTexts: nsnaFailOpenFilterVlan.setDescription('This object indicates the current Vlan ID whose associated filters are to be used as the Fail-Open filters. A value of 0 indicates the value either has not been set, or that the previous value is no longer valid.')
nsnaNsnasConnectionVersion = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasConnectionVersion.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasConnectionVersion.setDescription('This object indicates the SSCP version being used in the current NSNAS connection. If there is no current connection, the value will be 0.')
nsnaNsnasRadiusServerEnabled = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 15), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasRadiusServerEnabled.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasRadiusServerEnabled.setDescription('This object indicates whether the NSNAS currently connected to the switch is acting as a RADIUS server.')
nsnaNsnasRadiusServerPort = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 1, 16), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaNsnasRadiusServerPort.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasRadiusServerPort.setDescription('If there is an NSNAS currently connected to the switch that is acting as a RADIUS server, this object returns the port on which that server listens for RADIUS requests.')
nsnaNsnasTable = MibTable((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 2), )
if mibBuilder.loadTexts: nsnaNsnasTable.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasTable.setDescription('The table of subnets from which NSNASs will connect.')
nsnaNsnasEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 2, 1), ).setIndexNames((0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasAddressType"), (0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasAddress"), (0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasAddressMask"))
if mibBuilder.loadTexts: nsnaNsnasEntry.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasEntry.setDescription('A set of objects that specify a subnet from which NSNASs will connect, along with related configuration parameters.')
nsnaNsnasAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: nsnaNsnasAddressType.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasAddressType.setDescription('The type of internet address contained in nsnaNsnasAddress.')
nsnaNsnasAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 2, 1, 2), InetAddress())
if mibBuilder.loadTexts: nsnaNsnasAddress.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasAddress.setDescription('The internet address portion of the NSNAS subnet. This combined with the value of nsnaNsnasAddressMask specifies the subnet of the NSNAS.')
nsnaNsnasAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 2, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: nsnaNsnasAddressMask.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasAddressMask.setDescription('The address mask portion of the NSNAS subnet. This combined with the value of nsnaNsnasAddress specifies the subnet of the NSNAS.')
nsnaNsnasPort = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 2, 1, 4), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1024, 65535)).clone(5000)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsnaNsnasPort.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasPort.setDescription('The port on which NSNASs connecting from this subnet will connect.')
nsnaNsnasRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsnaNsnasRowStatus.setStatus('current')
if mibBuilder.loadTexts: nsnaNsnasRowStatus.setDescription('This object is used for row create/deletion.')
nsnaPortTable = MibTable((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3), )
if mibBuilder.loadTexts: nsnaPortTable.setStatus('current')
if mibBuilder.loadTexts: nsnaPortTable.setDescription('The table of per-port NSNA configuration parameters. There must be an entry in this table for each NSNA-capable port.')
nsnaPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1), ).setIndexNames((0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaPortIfIndex"))
if mibBuilder.loadTexts: nsnaPortEntry.setStatus('current')
if mibBuilder.loadTexts: nsnaPortEntry.setDescription('NSNA configuration parameters for a port.')
nsnaPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: nsnaPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: nsnaPortIfIndex.setDescription('The ifIndex corresponding to the port.')
nsnaPortMode = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("disabled", 1), ("static", 2), ("dynamic", 3), ("uplink", 4), ("secure", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaPortMode.setStatus('current')
if mibBuilder.loadTexts: nsnaPortMode.setDescription('The NSNA mode of the port.')
nsnaPortGreenVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 3), NsnaVlanIdOrNone()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaPortGreenVlanId.setStatus('current')
if mibBuilder.loadTexts: nsnaPortGreenVlanId.setDescription('The green VLAN ID of the port. This value is only used when the corresponding value of nsnaPortMode is static(2). Otherwise, the value will be 0.')
nsnaPortVoipVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 4), IdList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaPortVoipVlans.setStatus('current')
if mibBuilder.loadTexts: nsnaPortVoipVlans.setDescription('The set of VOIP VLANs to which this port belongs. This value is only used when the corresponding value of nsnaPortMode is static(2), dynamic(3), or secure(5).')
nsnaPortUplinkVlans = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 5), IdList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaPortUplinkVlans.setStatus('current')
if mibBuilder.loadTexts: nsnaPortUplinkVlans.setDescription('The set of uplink VLANs to which this port belongs. This value is only used when the corresponding value of nsnaPortMode is uplink(4).')
nsnaPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("red", 2), ("green", 3), ("yellow", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaPortState.setStatus('current')
if mibBuilder.loadTexts: nsnaPortState.setDescription('The current NSNA color of the port.')
nsnaPortDhcpState = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("blocked", 1), ("unblocked", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaPortDhcpState.setStatus('current')
if mibBuilder.loadTexts: nsnaPortDhcpState.setDescription('The DHCP state of the port.')
nsnaPortHubModeEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaPortHubModeEnabled.setStatus('current')
if mibBuilder.loadTexts: nsnaPortHubModeEnabled.setDescription('Indicates whether Hub Mode is enabled on a port.')
nsnaPortHubModeMaxClients = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaPortHubModeMaxClients.setStatus('current')
if mibBuilder.loadTexts: nsnaPortHubModeMaxClients.setDescription('The maximum number of clients allowed on a port when Hub Mode is enabled. The value is ignored if Hub Mode is disabled.')
nsnaVlanTable = MibTable((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4), )
if mibBuilder.loadTexts: nsnaVlanTable.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanTable.setDescription('The table of per-Vlan NSNA configuration parameters. There must be an entry in this table for every Vlan.')
nsnaVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1), ).setIndexNames((0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaVlanId"))
if mibBuilder.loadTexts: nsnaVlanEntry.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanEntry.setDescription('NSNA configuration parameters for a Vlan.')
nsnaVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1, 1), VlanId())
if mibBuilder.loadTexts: nsnaVlanId.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanId.setDescription('The ID of the Vlan.')
nsnaVlanColor = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("red", 2), ("green", 3), ("yellow", 4), ("voip", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaVlanColor.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanColor.setDescription('The NSNA color of the Vlan.')
nsnaVlanFilterSetName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaVlanFilterSetName.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanFilterSetName.setDescription('The name of the filter set associated with the VLAN. An empty value means that no filter set is associated with the VLAN.')
nsnaVlanFilterSetId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1024))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaVlanFilterSetId.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanFilterSetId.setDescription('The ID of the filter set associated with the VLAN. A value of 0 means that no filter set is associated with the VLAN.')
nsnaVlanYellowSubnetType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1, 5), InetAddressType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaVlanYellowSubnetType.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanYellowSubnetType.setDescription('The type of internet address contained in the corresponding instance of nsnaVlanYellowSubnet.')
nsnaVlanYellowSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1, 6), InetAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaVlanYellowSubnet.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanYellowSubnet.setDescription('The yellow subnet address of the VLAN. This value is only used when the corresponding value of nsnaVlanColor is yellow(4).')
nsnaVlanYellowSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 4, 1, 7), InetAddressPrefixLength()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: nsnaVlanYellowSubnetMask.setStatus('current')
if mibBuilder.loadTexts: nsnaVlanYellowSubnetMask.setDescription('The number of bits in the network mask of the yellow subnet address of the VLAN. This value is only used when the corresponding value of nsnaVlanColor is yellow(4).')
nsnaClientTable = MibTable((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5), )
if mibBuilder.loadTexts: nsnaClientTable.setStatus('current')
if mibBuilder.loadTexts: nsnaClientTable.setDescription('The table of per-client NSNA state information. There must be an entry in this table for every NSNA client.')
nsnaClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1), ).setIndexNames((0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaClientIfIndex"), (0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaClientMacAddress"))
if mibBuilder.loadTexts: nsnaClientEntry.setStatus('current')
if mibBuilder.loadTexts: nsnaClientEntry.setDescription('State information for an NSNA client.')
nsnaClientIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: nsnaClientIfIndex.setStatus('current')
if mibBuilder.loadTexts: nsnaClientIfIndex.setDescription('The ifIndex of the port on which the client is attached.')
nsnaClientMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 2), MacAddress())
if mibBuilder.loadTexts: nsnaClientMacAddress.setStatus('current')
if mibBuilder.loadTexts: nsnaClientMacAddress.setDescription('The MAC address of the client.')
nsnaClientDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unknown", 0), ("pc", 1), ("ipPhone", 2), ("passive", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaClientDeviceType.setStatus('current')
if mibBuilder.loadTexts: nsnaClientDeviceType.setDescription('The type of device of the client.')
nsnaClientVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 4), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaClientVlanId.setStatus('current')
if mibBuilder.loadTexts: nsnaClientVlanId.setDescription('The Vlan ID of the client.')
nsnaClientAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 5), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaClientAddressType.setStatus('current')
if mibBuilder.loadTexts: nsnaClientAddressType.setDescription('The type of address contained in the corresponding instance of nsnaClientAddress.')
nsnaClientAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 6), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaClientAddress.setStatus('current')
if mibBuilder.loadTexts: nsnaClientAddress.setDescription('The IP address of the client.')
nsnaClientExpired = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 7), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaClientExpired.setStatus('current')
if mibBuilder.loadTexts: nsnaClientExpired.setDescription('Indicates whether this client has been aged-out.')
nsnaClientFilterVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 8), VlanId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaClientFilterVlanId.setStatus('current')
if mibBuilder.loadTexts: nsnaClientFilterVlanId.setDescription('The Vlan ID whose associated filter set is installed on this port for this client. This is used when MAC Authentication is enabled. If MAC Authentication is no enabled, this object will return the same value as nsnaClientVlanId.')
nsnaClientStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("authenticatedByNsnas", 1), ("authenticatedLocally", 2), ("disallowedByNsnas", 3), ("isolatedByNsnas", 4), ("blacklistedByNsnas", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nsnaClientStatus.setStatus('current')
if mibBuilder.loadTexts: nsnaClientStatus.setDescription('The status of this client.')
nsnaStaticClientTable = MibTable((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6), )
if mibBuilder.loadTexts: nsnaStaticClientTable.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientTable.setDescription('The table of static NSNA client configuration. This is used for authenticating clients on static NSNA ports.')
nsnaStaticClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6, 1), ).setIndexNames((0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaStaticClientVlanId"), (0, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaStaticClientMacAddress"))
if mibBuilder.loadTexts: nsnaStaticClientEntry.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientEntry.setDescription('Static NSNA client configuration.')
nsnaStaticClientVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6, 1, 1), VlanId())
if mibBuilder.loadTexts: nsnaStaticClientVlanId.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientVlanId.setDescription('The VLAN ID in which a client is allowed.')
nsnaStaticClientMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6, 1, 2), MacAddress())
if mibBuilder.loadTexts: nsnaStaticClientMacAddress.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientMacAddress.setDescription('The MAC address of an allowed client.')
nsnaStaticClientDeviceType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pc", 1), ("ipPhone", 2), ("passive", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsnaStaticClientDeviceType.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientDeviceType.setDescription('The type of device of the allowed client.')
nsnaStaticClientAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6, 1, 4), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsnaStaticClientAddressType.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientAddressType.setDescription('The type of address contained in the corresponding instance of nsnaStaticClientAddress.')
nsnaStaticClientAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6, 1, 5), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsnaStaticClientAddress.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientAddress.setDescription('The IP address to be used for the allowed client.')
nsnaStaticClientRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 6, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsnaStaticClientRowStatus.setStatus('current')
if mibBuilder.loadTexts: nsnaStaticClientRowStatus.setDescription('Used for row creation/deletion. When creating a row, the corresponding instances of nsnaStaticClientDeviceType, nsnaStaticClientAddressType, and nsnaStaticClientAddress must be set before this object can be made active(1).')
nsnaIpPhoneSignatureTable = MibTable((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 7), )
if mibBuilder.loadTexts: nsnaIpPhoneSignatureTable.setStatus('current')
if mibBuilder.loadTexts: nsnaIpPhoneSignatureTable.setDescription('The table of IP phone signature string configuration. This is used for recognizing IP phones.')
nsnaIpPhoneSignatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 7, 1), ).setIndexNames((1, "NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaIpPhoneSignatureString"))
if mibBuilder.loadTexts: nsnaIpPhoneSignatureEntry.setStatus('current')
if mibBuilder.loadTexts: nsnaIpPhoneSignatureEntry.setDescription('IP phone signature string configuration.')
nsnaIpPhoneSignatureString = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 7, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: nsnaIpPhoneSignatureString.setStatus('current')
if mibBuilder.loadTexts: nsnaIpPhoneSignatureString.setDescription('The signature string of an IP phone.')
nsnaIpPhoneSignatureRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 7, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: nsnaIpPhoneSignatureRowStatus.setStatus('current')
if mibBuilder.loadTexts: nsnaIpPhoneSignatureRowStatus.setDescription('Used for row creation/deletion.')
nsnaNotificationObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 8))
nsnaClosedConnectionReason = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 8, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unknown", 1), ("snasClosedConnection", 2), ("dataStreamCorrupted", 3), ("bufferAllocationFailure", 4), ("messageProcessingFailure", 5), ("inactivityIntervalExpired", 6), ("nsnaAdministrativelyDown", 7)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: nsnaClosedConnectionReason.setStatus('current')
if mibBuilder.loadTexts: nsnaClosedConnectionReason.setDescription('Indicates the reason why the connection to the NSNAS was closed.')
nsnaInvalidMessageHeader = MibScalar((1, 3, 6, 1, 4, 1, 45, 5, 10, 1, 8, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: nsnaInvalidMessageHeader.setStatus('current')
if mibBuilder.loadTexts: nsnaInvalidMessageHeader.setDescription('The header of an invalid message from the NSNAS. Note that if an entire header is not available, only the portion that is available will be provided in this object.')
nsnaClosedConnectionToSnas = NotificationType((1, 3, 6, 1, 4, 1, 45, 5, 10, 0, 1)).setObjects(("NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaClosedConnectionReason"))
if mibBuilder.loadTexts: nsnaClosedConnectionToSnas.setStatus('current')
if mibBuilder.loadTexts: nsnaClosedConnectionToSnas.setDescription('This notification is generated whenever the device closes the connection to the NSNAS. The reason why the connection is closed is indicated in nsnaClosedConnectionReason.')
nsnaStatusQuoIntervalExpired = NotificationType((1, 3, 6, 1, 4, 1, 45, 5, 10, 0, 2))
if mibBuilder.loadTexts: nsnaStatusQuoIntervalExpired.setStatus('current')
if mibBuilder.loadTexts: nsnaStatusQuoIntervalExpired.setDescription('This notification is generated whenever the status-quo interval expires after the connection to the NSNAS has closed. Note that if the configured status-quo interval is 0 (indicating no status quo interval), this notification will be generated at the same time as the corresponding nsnaClosedConnectionToSnas notification.')
nsnaInvalidMessageFromSnas = NotificationType((1, 3, 6, 1, 4, 1, 45, 5, 10, 0, 3)).setObjects(("NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaInvalidMessageHeader"))
if mibBuilder.loadTexts: nsnaInvalidMessageFromSnas.setStatus('current')
if mibBuilder.loadTexts: nsnaInvalidMessageFromSnas.setDescription('This notification is generated whenever the device receives an invalid message from the NSNAS. This generally means that the received message is corrupted. As much of the message header as is available will be included in nsnaInvalidMessageHeader.')
nsnaSnasConnected = NotificationType((1, 3, 6, 1, 4, 1, 45, 5, 10, 0, 4)).setObjects(("NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasInetAddressType"), ("NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasInetAddress"), ("NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasSendHelloInterval"), ("NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasInactivityInterval"), ("NORTEL-SECURE-NETWORK-ACCESS-MIB", "nsnaNsnasStatusQuoInterval"))
if mibBuilder.loadTexts: nsnaSnasConnected.setStatus('current')
if mibBuilder.loadTexts: nsnaSnasConnected.setDescription('This notification is generated whenever an NSNAS successfully connects to the switch.')
mibBuilder.exportSymbols("NORTEL-SECURE-NETWORK-ACCESS-MIB", nsnaStatusQuoIntervalExpired=nsnaStatusQuoIntervalExpired, nsnaScalars=nsnaScalars, nsnaVlanFilterSetId=nsnaVlanFilterSetId, nsnaStaticClientTable=nsnaStaticClientTable, nsnaNsnasRowStatus=nsnaNsnasRowStatus, nsnaVlanId=nsnaVlanId, nsnaIpPhoneSignatureEntry=nsnaIpPhoneSignatureEntry, nsnaClosedConnectionReason=nsnaClosedConnectionReason, nsnaStaticClientDeviceType=nsnaStaticClientDeviceType, nsnaStaticClientAddress=nsnaStaticClientAddress, nsnaPortMode=nsnaPortMode, nsnaClientEntry=nsnaClientEntry, nsnaClientIfIndex=nsnaClientIfIndex, nsnaStaticClientRowStatus=nsnaStaticClientRowStatus, nsnaClientFilterVlanId=nsnaClientFilterVlanId, nsnaStaticClientVlanId=nsnaStaticClientVlanId, nsnaIpPhoneSignatureRowStatus=nsnaIpPhoneSignatureRowStatus, nsnaPortHubModeMaxClients=nsnaPortHubModeMaxClients, nsnaClientStatus=nsnaClientStatus, nsnaNsnasEntry=nsnaNsnasEntry, nsnaPortState=nsnaPortState, nsnaNsnasSendHelloInterval=nsnaNsnasSendHelloInterval, nsnaVlanTable=nsnaVlanTable, nsnaClientDeviceType=nsnaClientDeviceType, PYSNMP_MODULE_ID=nortelSecureNetworkAccessMib, nsnaFailOpenEnabled=nsnaFailOpenEnabled, nsnaNotificationObjects=nsnaNotificationObjects, nsnaNsnasPort=nsnaNsnasPort, nsnaClientTable=nsnaClientTable, nsnaClientAddressType=nsnaClientAddressType, nsnaVlanYellowSubnetType=nsnaVlanYellowSubnetType, nsnaNsnasAddress=nsnaNsnasAddress, nsnaInvalidMessageHeader=nsnaInvalidMessageHeader, nsnaNsnasConnectionVersion=nsnaNsnasConnectionVersion, nsnaPortTable=nsnaPortTable, nsnaPortIfIndex=nsnaPortIfIndex, nsnaNsnasRadiusServerPort=nsnaNsnasRadiusServerPort, nsnaNsnasTable=nsnaNsnasTable, nsnaFailOpenFilterVlan=nsnaFailOpenFilterVlan, nsnaClientExpired=nsnaClientExpired, nsnaStaticClientAddressType=nsnaStaticClientAddressType, nsnaPortEntry=nsnaPortEntry, nsnaFailOpenVlan=nsnaFailOpenVlan, nsnaPortGreenVlanId=nsnaPortGreenVlanId, nsnaVlanColor=nsnaVlanColor, nsnaNsnasInetAddressType=nsnaNsnasInetAddressType, nsnaSnasConnected=nsnaSnasConnected, nsnaClosedConnectionToSnas=nsnaClosedConnectionToSnas, nsnaNsnasStatusQuoInterval=nsnaNsnasStatusQuoInterval, NsnaVlanIdOrNone=NsnaVlanIdOrNone, nsnaClientAddress=nsnaClientAddress, nsnaEnabled=nsnaEnabled, nortelSecureNetworkAccessMib=nortelSecureNetworkAccessMib, nsnaMacAuthenticationEnabled=nsnaMacAuthenticationEnabled, nsnaNsnasInetAddress=nsnaNsnasInetAddress, nsnaObjects=nsnaObjects, nsnaNsnasConnectionState=nsnaNsnasConnectionState, nsnaNsnasAddressMask=nsnaNsnasAddressMask, nsnaClientVlanId=nsnaClientVlanId, nsnaInvalidMessageFromSnas=nsnaInvalidMessageFromSnas, nsnaStaticClientEntry=nsnaStaticClientEntry, nsnaPortDhcpState=nsnaPortDhcpState, nsnaPortHubModeEnabled=nsnaPortHubModeEnabled, nsnaNotifications=nsnaNotifications, nsnaVlanEntry=nsnaVlanEntry, nsnaIpPhoneSignatureTable=nsnaIpPhoneSignatureTable, nsnaPortUplinkVlans=nsnaPortUplinkVlans, nsnaVlanFilterSetName=nsnaVlanFilterSetName, nsnaVlanYellowSubnet=nsnaVlanYellowSubnet, nsnaNsnasInactivityInterval=nsnaNsnasInactivityInterval, nsnaVlanYellowSubnetMask=nsnaVlanYellowSubnetMask, nsnaIpPhoneSignatureString=nsnaIpPhoneSignatureString, nsnaStaticClientMacAddress=nsnaStaticClientMacAddress, nsnaNsnasRadiusServerEnabled=nsnaNsnasRadiusServerEnabled, nsnaClientMacAddress=nsnaClientMacAddress, nsnaNsnasAddressType=nsnaNsnasAddressType, nsnaPortVoipVlans=nsnaPortVoipVlans)

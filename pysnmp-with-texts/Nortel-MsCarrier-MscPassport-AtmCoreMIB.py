#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-AtmCoreMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-AtmCoreMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint")
Integer32, Counter32, Gauge32, Unsigned32, DisplayString, StorageType, RowStatus = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Integer32", "Counter32", "Gauge32", "Unsigned32", "DisplayString", "StorageType", "RowStatus")
AsciiStringIndex, Hex, NonReplicated, Link, FixedPoint9, IntegerSequence, FixedPoint7, AsciiString, PassportCounter64 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "AsciiStringIndex", "Hex", "NonReplicated", "Link", "FixedPoint9", "IntegerSequence", "FixedPoint7", "AsciiString", "PassportCounter64")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Integer32, Counter32, Counter64, Gauge32, MibIdentifier, NotificationType, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Unsigned32, TimeTicks, Bits, iso, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Counter32", "Counter64", "Gauge32", "MibIdentifier", "NotificationType", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Unsigned32", "TimeTicks", "Bits", "iso", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
atmCoreMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123))
mscAtmIf = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114))
mscAtmIfRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 1), )
if mibBuilder.loadTexts: mscAtmIfRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIf components.')
mscAtmIfRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"))
if mibBuilder.loadTexts: mscAtmIfRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIf component.')
mscAtmIfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIf components. These components can be added and deleted.')
mscAtmIfComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfStorageType.setDescription('This variable represents the storage type value for the mscAtmIf tables.')
mscAtmIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)))
if mibBuilder.loadTexts: mscAtmIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfIndex.setDescription('This variable represents the index for the mscAtmIf tables.')
mscAtmIfCidDataTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 100), )
if mibBuilder.loadTexts: mscAtmIfCidDataTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCidDataTable.setDescription("This group contains the attribute for a component's Customer Identifier (CID). Refer to the attribute description for a detailed explanation of CIDs.")
mscAtmIfCidDataEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"))
if mibBuilder.loadTexts: mscAtmIfCidDataEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCidDataEntry.setDescription('An entry in the mscAtmIfCidDataTable.')
mscAtmIfCustomerIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 100, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 8191), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCustomerIdentifier.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCustomerIdentifier.setDescription("This attribute holds the Customer Identifier (CID). Every component has a CID. If a component has a cid attribute, the component's CID is the provisioned value of that attribute; otherwise the component inherits the CID of its parent. The top- level component has a CID of 0. Every operator session also has a CID, which is the CID provisioned for the operator's user ID. An operator will see only the stream data for components having a matching CID. Also, the operator will be allowed to issue commands for only those components which have a matching CID. An operator CID of 0 is used to identify the Network Manager (referred to as 'NetMan' in DPN). This CID matches the CID of any component. Values 1 to 8191 inclusive (equivalent to 'basic CIDs' in DPN) may be assigned to specific customers.")
mscAtmIfProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110), )
if mibBuilder.loadTexts: mscAtmIfProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfProvTable.setDescription('This group contains provisionable attributes for the AtmIf component.')
mscAtmIfProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"))
if mibBuilder.loadTexts: mscAtmIfProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfProvEntry.setDescription('An entry in the mscAtmIfProvTable.')
mscAtmIfInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 10), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfInterfaceName.setDescription('This attribute associates the AtmIf component with a specific interface on a Function Processorfor example, Lp/1 Ds3/0. This implicitly defines the logical processor on which the AtmIf is activated.')
mscAtmIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("uni", 0), ("ppi", 1))).clone('uni')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfType.setDescription('This attribute indicates the type of AtmIf, either uni or ppi. These types differ only in their handling of OAM cellsall connections passing through a uni interface terminate segment loopback cells; whereas a ppi interface permits these cells to be passed transparently. This is obsoleted. The value is migrated into oamSegmentBoundary. uni maps to yes. ppi maps to no.')
mscAtmIfOamSegmentBoundary = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfOamSegmentBoundary.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOamSegmentBoundary.setDescription('This attribute specifies whether the interface is on an OAM segment boundary. When yes is selected, the interface is on an OAM segment boundary and all connections passing through the interface terminate OAM segment cells. When no is selected, the interface is not on an OAM segment boundary and the interface permits the segment cells to be passed transparently.')
mscAtmIfMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfMaxVpcs.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfMaxVpcs.setDescription("This attribute specifies the maximum number of VPCs that can be configured on this AtmIf. The value must not exceed the total number of usable VPCs supported by this AtmIf (which is equal to 256 or (256 - (number of VPIs used for VCCs)), according to the ConnectionMapping component). Furthermore, if the AtmIf is linked to an LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + 1) across all AtmIf linked to that Lp must be less than or equal to the totalConnectionPoolCapacity attribute of the Arc component. If the Arc component doesn't exist, the default value of totalConnectionPoolCapacity is used as the limit. This attribute has been migrated to the Ca component.")
mscAtmIfMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(255)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfMaxVccs.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfMaxVccs.setDescription("This attribute specifies the maximum number of usable VCCs that can be configured on this AtmIf. The value must not exceed the number of non-reserved VCC identifiers in the Vcc space supported by this AtmIf (which is specified by the ConnectionMapping component). Furthermore, if the AtmIf is linked to an LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + 1) across all AtmIf linked to that Lp must be less than the totalConnectionPoolCapacity attribute of the Arc component. If the Arc component doesn't exist, the default value of totalConnectionPoolCapacity is used as the limit. This attribute has been migrated to the Ca component.")
mscAtmIfTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfTrafficShaping.setDescription('It is migrated in P6.0 to a combination of the trafficShaping attributes and the emissionPriority attributes under each ATM service category component of the AtmIf CA. This attribute defines whether traffic shaping is enabled or disabled for the entire AtmIf. When this attribute is set to enabled, each provisioned connection under the interface can be individually provisioned to permit or prohibit traffic shaping. When this attribute is set to disabled, no traffic shaping is performed on the transmit path for any of the connections. This attribute may be set to enabled if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl component. If the AtmResourceControl component does not exist, this attribute may not be set to enabled.')
mscAtmIfUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfUnshapedTransmitQueueing.setDescription('It is migrated in P6.0 to the attributes of the same name under each ATM service category component of the AtmIf CA. This attribute applies only for unshaped VCC and VPC connections. This attribute defines the transmit queueing method for all unshaped connections under this AtmIf. Per-VC queueing means that unshaped connections are treated with the same fairness as shaped queues in the transmit round-robin scheduling. The alternative to per-VC queueing is to use the common queue for a particular service category (medium or low priority). The common queue is only counted as one queue in the transmit round-robin scheduling. Thus, if there are multiple connections which are destined for the common queue, they are not fairly allocated a portion of the transmit bandwidth compared to shaped connections. When this attribute is set to perVc, any unshaped connection is allocated its own per-VC queue, and is treated with the same fairness as any shaped connections. Per-VC queues have a maximum rate of 58,962 cell/s (25 Mbit/s) in a multi-port shaping configuration. Per-VC queues also have their own congestion control level. This means that total number of cell/frame blocks allocated for several per-VC queues are higher than would be allowed on the common queue. This can be an advantage in reducing cell loss due to queue congestion. This attribute may only be set to perVc if the interface supports per-VC queueing, (specified by the perVcQueueInterfaces attribute in the AtmResourceControl component). When this attribute is set to common, any unshaped connection is destined for the common queue. The common queue has one set of congestion control levels for all cells enqueued on it. The common queue is only allocated one queue position when scheduling which queue to transmit from. Due to the possibility of unfairness, this value is only recommended in cases where the configuration cannot otherwise achieve full link utilization. When this attribute is set to autoConfigure and the interface support per-VC queueing (specified by the perVcQueueInterfaces attribute in the AtmResourceControl component) per-VC queueing is enabled for all unshaped connections. Otherwise, the common queue is used. The unshapedTransmitQueueingOper attribute indicates whether the transmit queueing is perVc or common.')
mscAtmIfUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfUsageParameterControl.setDescription('It is migrated in P6.0 to the attributes of the same name under each ATM service category component of the AtmIf CA. This attribute defines whether usage parameter control (UPC) is enabled or disabled for receive traffic for Vcc and Vpc connections for this entire AtmIf. When this attribute is set to enabled, each provisioned connection under the interface can be individually provisioned to enforce or ignore UPC. When this attribute is set to disabled, UPC cannot be enabled on the receive path for any of the connections.')
mscAtmIfMaxVpiBits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 85), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(8, 8), ValueRangeConstraint(12, 12), )).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfMaxVpiBits.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfMaxVpiBits.setDescription('This attribute specifies the maximum number of VPI bits that may be active for this AtmIf. These bits start at the least significant bit position and are contiguous. In general, the maximum VPI which may be used on the interface is 2**maxVpiBits - 1. The value of the remaining (inactive) VPI bits is ignored on cells received from the link. If the AtmIf is linked to a LogicalProcessor of cardType 3pOC3MmAtm, 3pOC3SmAtm, 3pE3Atm, 3pDS3Atm, 3pE1Atm, 3pDS1Atm, or 2pJ6MAtm, the value of this attribute must be 8. The maximum VPI supported on these card types is 255. If the AtmIf is linked to a LogicalProcessor of any other cardType, the value of this attribute may be 8 or 12. The maximum VPI supported on these card types is 4095. An exception is that cardType 8pE1Atm and 8pDS1Atm do not support VPI 4095; the maximum VPI on these card types is 4094. If a Uni or an Iisp component is present directly under the AtmIf, the value of this attribute must be 8.')
mscAtmIfRemoteAtmInterfaceLabel = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 90), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 60)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfRemoteAtmInterfaceLabel.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRemoteAtmInterfaceLabel.setDescription("This attribute specifies a unique indication of the remote ATM service or interface component connected to this one. The value of this attribute can be used by network management applications to discover the network's ATM topology from its configuration information. The syntax of the value, such as component ID, address, or other numerical identifier, must follow the conventions of the network management platform. In absence of such convention or platform, the value should be left empty. The value is only stored by the module. It is neither validated nor used to perform any form of remote connectivity validation.")
mscAtmIfTxCellMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 91), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfTxCellMemory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellMemory.setDescription("This attribute specifies the percentage of the Lp/x Eng Arc Aqm/0 txCellMemoryThreshold 0 attribute. This attribute only applies to ATM IP FPs. It is ignored on all other card types. For ATM IP FPs, the cell memory which is displayed in Lp/x Eng Arc Aqm/0 txCellMemoryThreshold 0 is shared across all interfaces for the card. This attribute allows the allocation of a specific proportion of the transmit cell memory for the use of connections under this AtmIf. If the value of this attribute is specified as 100, connections under this AtmIf may use up to 100% of the transmit cell memory. If this attribute is specified as an amount less than 100, then only that percentage of the transmit cell memory may be used by connections under this AtmIf. By specifying values for this attribute under the AtmIf's on a DS3, E3 or MSA32 card, you can limit the transmit cell memory usage for each AtmIf. This is used to guarantee that all cell traffic for an AtmIf will respect the cell loss priority (CLP) bit settings regardless of the atmServiceCategory for the connection.")
mscAtmIfFaultHoldOffTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 100), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 65535))).clone(namedValues=NamedValues(("n0", 0), ("infinity", 65535))).clone('infinity')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfFaultHoldOffTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfFaultHoldOffTime.setDescription('This attribute specifies the delay before faults detected at the VP layer are propagated to the VC layer, and thus to the application using the connection. If the value is 0 (zero), applications using a VirtualPathTerminator are immediately notified of faults detected by the VP. Using this value allows these applications to be advised of faults without requiring loopbacks on each Vcc. Typically, the application goes out of service when advised of a fault. If the value is infinity, applications are not notified of VP layer faults. Using this value allows the applications to survive transient VP layer fault conditions. The value chosen applies only to Vpts and Vccs directly beneath a Vpt.')
mscAtmIfCtdCalculation = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 110, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCtdCalculation.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCtdCalculation.setDescription('This attribute specifies whether cell transfer delay calculation should be performed on loopback cells for each SPVC and SPVP connection under this interface. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. Cell transfer delay calculation is only supported when segment switch side loopback is enabled on the source segment endpoint. Cell transfer delay calculation is only performed on supported connections when the accountCollection attribute of the AtmIf Uni or AtmIf Iisp component has a non-empty reason. Cell transfer delay calculation is not provided for connections under the Vpt.')
mscAtmIfLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 120), )
if mibBuilder.loadTexts: mscAtmIfLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfLbkTable.setDescription('This group contains the default loopback attribute values for all Vcc, Vpc and Vpt components. Note that these attribute values can be overridden by setting different values in the Vcd component of the provisioned Vcc or the Vpd component of the provisioned Vpc or Vpt. Certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the AtmStatus group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed.')
mscAtmIfLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"))
if mibBuilder.loadTexts: mscAtmIfLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfLbkEntry.setDescription('An entry in the mscAtmIfLbkTable.')
mscAtmIfSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 120, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfSegLinkSideLoopback.setDescription('This attribute specifies the default value for link-side segment loopback insertion for all connections under this interface. Link- side segment loopback is not possible if the oamSegmentBoundary attribute of the AtmIf component is no.')
mscAtmIfSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfSegSwitchSideLoopback.setDescription('This attribute specifies the default value for switch-side segment loopback insertion for all connections under this interface. Switch- side segment loopback is not possible if the oamSegmentBoundary attribute of the AtmIf component is no.')
mscAtmIfEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("on", 0), ("off", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEndToEndLoopback.setDescription('This attribute specifies the default value for end-to-end loopback insertion for all connections under this interface. End-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is possible if the connectionPointType attribute of the Vcc or Vpc component is connectionEndPoint. End-to-end loopback insertion is always possible on a Vpt component.')
mscAtmIfStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130), )
if mibBuilder.loadTexts: mscAtmIfStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscAtmIfStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"))
if mibBuilder.loadTexts: mscAtmIfStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfStateEntry.setDescription('An entry in the mscAtmIfStateTable.')
mscAtmIfAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscAtmIfOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscAtmIfUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscAtmIfAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. Usually, the resource remains available for service. The operationalState is almost always enabled. There is one exception where an operationalState of disabled is used in conjunction with degraded for a component which represents a rolled up view of a set of other components. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. The value migrating indicates that a software migration activation is in progress, making the component unavailable for other activities until the migration is complete. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8) migrating(9)')
mscAtmIfProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscAtmIfControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscAtmIfAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below is present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscAtmIfStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below is present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscAtmIfUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 130, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscAtmIfOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 140), )
if mibBuilder.loadTexts: mscAtmIfOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOperTable.setDescription('This group contains operational attributes which show the status of the AtmIf component.')
mscAtmIfOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 140, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"))
if mibBuilder.loadTexts: mscAtmIfOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOperEntry.setDescription('An entry in the mscAtmIfOperTable.')
mscAtmIfTxCellMemoryAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 140, 1, 1), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryAvailable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryAvailable.setDescription("This attribute is only valid for AtmIf's on ATM IP FPs. It is not displayed for AtmIf's on other card types. This attribute indicates the current amount of transmit cells available for this AtmIf. Transmit cell memory is the memory available for storing ATM cells to be transmitted by connections under this AtmIf.")
mscAtmIfTxCellMemoryCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 140, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryCongestionState.setDescription("This attribute is only valid for AtmIf's on ATM IP FPs. It is not displayed for AtmIf's on other card types. This attribute indicates the congestion state of the transmit cell memory for this AtmIf. It indicates which txCellMemoryThreshold corresponds to the current value of txCellMemoryAvailable. The congestion state of memory is indicated by a numeric value ranging from 0 to 3. When memory is in a congested state 'x', only traffic with discard priority (DP) < 'x' is definitely still queued for transmit. Traffic with DP > 'x' is definitely discarded. Traffic with DP = 'x' may be either queued or discarded depending on how close the value of txCellMemoryAvailable is to the next threshold as displayed in txCellMemoryThreshold. For example, CLP1 traffic is queued until the value indicated by txCellMemoryAvailable reaches the DP3 threshold. At that point, the CLP1 traffic is discarded.")
mscAtmIfUnshapedTransmitQueueingOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 140, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfUnshapedTransmitQueueingOper.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfUnshapedTransmitQueueingOper.setDescription('This attribute is HISTORICAL in P6.0. This attribute indicates the state of transmit queuing for unshaped connections under this AtmIf. A value of perVc indicates that any unshaped connections use per- VC queueing in the CQC. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the atmServiceCategory for this connection.')
mscAtmIfStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150), )
if mibBuilder.loadTexts: mscAtmIfStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfStatsTable.setDescription('This group contains operational attributes which keep statistics about the behavior of the AtmIf component.')
mscAtmIfStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"))
if mibBuilder.loadTexts: mscAtmIfStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfStatsEntry.setDescription('An entry in the mscAtmIfStatsTable.')
mscAtmIfTransmittedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTransmittedCells.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfTransmittedCells.setDescription('This attribute is renamed in P6.0 to txCell for naming compatibility with the Vcc and Vpc components. This attribute counts cells transmitted from the ATM interface. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds the maximum value of (2**64)-1.')
mscAtmIfTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCell.setDescription('This attribute counts cells transmitted from the ATM interface. It does not include cells discarded due to congestion before transmit. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells transmitted from the ATM interface which have the CLP bit set to 1. This count is included in the txCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfTxCellEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 15), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCellEfci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellEfci.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells transmitted from the ATM interface which have the EFCI bit set to 1. This count is included in the txCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 16), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellDiscard.setDescription("This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells discarded and not transmitted out the ATM interface. Since cells are discarded before they are transmitted, this count is not included in the txCell attribute. This count is independent of the txFrameDiscard attribute. Transmit cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.")
mscAtmIfTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 17), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellDiscardClp.setDescription("This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells discarded and not transmitted out the ATM interface which have the CLP bit set to 1. Since cells are discarded before they are transmitted, this count is not included in the txCellClp attribute. This count is included in the txCellDiscard attribute, but it is independent of the txFrameDiscardClp attribute. Transmit cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.")
mscAtmIfTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 18), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxFrameDiscard.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames discarded and not transmitted out the ATM interface. This count is independent of txCellDiscard. Transmit frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 19), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxFrameDiscardClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames which have at least one cell with the CLP bit set to 1, and have been discarded and not transmitted out the ATM interface. It is independent of the txCellDiscard attribute. This count is included in the txFrameDiscard attribute. Transmit frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfReceivedCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfReceivedCells.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfReceivedCells.setDescription('This attribute is renamed in P6.0 to rxCell for naming compatibility with the Vcc and Vpc component. This attribute counts valid cells received from the ATM interface. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 23), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxCell.setDescription('This attribute counts valid cells received from the ATM interface. This count includes cells which may be subsequently discarded. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. On ATM IP FPs valid cells include cells that arrive on a VCC whose VPI.VCI cannot be identified. These cells are also counted under the droppedRxCell attribute. The value of this attribute on ATM IP FPs should be greater than or equal to the sum of droppedRxCell and all the VCC and VPC rxCell attributes under this interface. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 24), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxCellClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts valid cells received from the ATM interface which have the CLP bit set to 1. This count includes cells which may be subsequently discarded. This count is included in the rxCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfRxCellEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 25), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxCellEfci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxCellEfci.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts valid cells received from the ATM interface which have the EFCI bit set to 1. This count includes cells which may be subsequently discarded. This count is included in the rxCell attribute. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 26), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxCellDiscard.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts cells received from the ATM interface which have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 27), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxCellDiscardClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts valid cells received from the ATM interface which have the CLP bit set to 1, which have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. This counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 28), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxFrameDiscard.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames received from the ATM interface which have been discarded. This count includes the count of rxFrameDiscardClp and aal5RxErrors. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 29), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxFrameDiscardClp.setDescription('This attribute is not applicable and is not displayed on CQC-based ATM cards. This attribute counts frames received from the ATM interface which have been discarded and which have at least one cell with the CLP bit set to 1. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscardClp attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only for connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. The counter is reset to zero when the component is activated, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1.')
mscAtmIfDroppedRxCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfDroppedRxCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfDroppedRxCells.setDescription('This attribute counts cells received from the interface that were dropped because they contained invalid VPI or VCI values, or dropped because they had no associated connection for the VPI or VCI. On ATM IP FPs this count is included in the rxCell count for the interface. Note that this attribute does not keep an exact count. Idle cells and unassigned cells are ignored without being counted as dropped cells. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last dropped cell are indicated in the attribute lastDroppedRxCellConnection.')
mscAtmIfLastDroppedRxCellConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 31), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfLastDroppedRxCellConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfLastDroppedRxCellConnection.setDescription('This attribute indicates the VPI and VCI of the last cell that was dropped. Cells are dropped because they have no associated connection for the VPI and VCI. Dropped cells are counted in the attribute droppedRxCells.')
mscAtmIfAal5RxErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfAal5RxErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfAal5RxErrors.setDescription('This attribute counts AAL5 frame reassembly errors which have occurred since the component was activated. These errors are either CRC errors or length errors, possibly caused by dropped cells.This attribute includes the count of AAL5 aborted frames. This count is included in the rxFrameDiscard count. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last connection which exhibited AAL5 reassembly errors are indicated in the attribute lastAal5ErrorConnection.')
mscAtmIfLastAal5RxErrorConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 33), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfLastAal5RxErrorConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfLastAal5RxErrorConnection.setDescription('This attribute indicates the VPI and VCI of the last connection that exhibited AAL5 reassembly errors. These errors are counted in the attribute aal5RxErrors.')
mscAtmIfLrcFrameErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfLrcFrameErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfLrcFrameErrors.setDescription('This attribute counts egress LRC frame errors on frames received across the bus. The likely cause of this is a hardware fault on either the sending or receiving card. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last connection which exhibited LRC errors are indicated in the attribute lastLrcFrameErrorConnection.')
mscAtmIfLastLrcFrameErrorConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 35), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfLastLrcFrameErrorConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfLastLrcFrameErrorConnection.setDescription('This attribute indicates the VPI and VCI of the last connection that had LRC frame errors on frames received across the bus. These errors are counted in the attribute lrcFrameErrors.')
mscAtmIfAal5RxAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfAal5RxAborts.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfAal5RxAborts.setDescription('This attribute is not supported on any card type in Release 6.0 or earlier. This attribute counts AAL5 frame aborts which have been received since the component was activated. An AAL5 aborted frame is one in which the AAL5 frame length has been set to zero. This count is included in aal5RxErrors. The counter is reset to zero when the component is created, or when any critical attribute of the component is changed. The counter wraps to zero when it exceeds its maximum value of (2**64)-1. The VPI and VCI of the last connection which received AAL5 abort errors are displayed in the attribute lastAal5RxAbortConnection.')
mscAtmIfLastAal5RxAbortConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 50), IntegerSequence().subtype(subtypeSpec=ValueSizeConstraint(3, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfLastAal5RxAbortConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfLastAal5RxAbortConnection.setDescription('This attribute is not supported on any card type in Release 6.0 or earlier. This attribute indicates the VPI and VCI of the last connection that exhibited AAL5 aborts. These errors are counted in the attribute aal5RxAborts.')
mscAtmIfTxLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 59), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxLinkUtilization.setDescription('This attribute indicates the current transmit interface utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this ATM interface. The attribute is not supported for 4pOC12SmIrAtm and 4pOC12SmLrAtm cards when working in chanelized mode.')
mscAtmIfRxLinkUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 150, 1, 60), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfRxLinkUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfRxLinkUtilization.setDescription('This attribute indicates the current receive interface utilization during the most recent minute, expressed as a percentage of the total bandwidth which can be carried by this ATM interface. This attribute does not consider cells that are counted by the droppedRxCells attribute, nor idle cells, nor unassigned cells. The attribute is not supported for 4pOC12SmIrAtm and 4pOC12SmLrAtm cards when working in chanelized mode.')
mscAtmIfTxCellMemoryThresholdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 441), )
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdTable.setDescription("This attribute is only valid for AtmIf's on ATM IP FPs. It is not displayed for AtmIf's on other card types. This attribute indicates the transmit cell memory size and three discard thresholds for this AtmIf. Transmit cell memory is used for storing ATM cells to be transmitted by connections under this AtmIf. The first value indicates the the total transmit cell memory size. This is derived based upon the txCellMemoryThreshold 0 attribute of the Lp/x eng arc aqm/0 component and Lp/x eng arc aqm/0 Ov, and on the txCellMemory attribute of this AtmIf. When the txCellMemoryAvailable attribute decreases to the second value, the txCellMemoryCongestionState changes from 3 to 2. In congestion state 2, traffic with discard priority (DP) > 2 is discarded. This threshold is set approximately at 25 percent of the first value, the transmit cell memory size. When the txCellMemoryAvailable attribute decreases to the third value, the txCellMemoryCongestionState changes from 2 to 1. In congestion state 1, traffic with discard priority (DP) > 1 is discarded. This threshold is set approximately at 20 percent of the first value, the transmit cell memory size. When the txCellMemoryAvailable attribute decreases to the fourth value, the txCellMemoryCongestionState changes from 1 to 0. In congestion state 0, traffic with discard priority (DP) > 0 is discarded. This threshold is set approximately at 10 percent of the first value, the transmit cell memory size. The opposite effect occurs when the txCellMemoryAvailable attribute increases (txCellMemoryCongestionState changes from 0 to 3 accordingly).")
mscAtmIfTxCellMemoryThresholdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 441, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfTxCellMemoryThresholdIndex"))
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdEntry.setDescription('An entry in the mscAtmIfTxCellMemoryThresholdTable.')
mscAtmIfTxCellMemoryThresholdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 441, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdIndex.setDescription('This variable represents the mscAtmIfTxCellMemoryThresholdTable specific index for the mscAtmIfTxCellMemoryThresholdTable.')
mscAtmIfTxCellMemoryThresholdValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 441, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfTxCellMemoryThresholdValue.setDescription('This variable represents an individual value for the mscAtmIfTxCellMemoryThresholdTable.')
mscAtmIfOpShapingRatesTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 839), )
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesTable.setDescription("This attribute displays the values of the 31 shaping rates currently in use at the interface. It is avector of 31 elements, each representing a shaping rate value. A rate entry of '0' means the entry is empty and can be used. This attribute is only valid for AtmIf's on APC-based FPs. It is not displayed for AtmIf's on other card types.")
mscAtmIfOpShapingRatesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 839, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfOpShapingRatesIndex"))
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesEntry.setDescription('An entry in the mscAtmIfOpShapingRatesTable.')
mscAtmIfOpShapingRatesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 839, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30)))
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesIndex.setDescription('This variable represents the mscAtmIfOpShapingRatesTable specific index for the mscAtmIfOpShapingRatesTable.')
mscAtmIfOpShapingRatesValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 839, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfOpShapingRatesValue.setDescription('This variable represents an individual value for the mscAtmIfOpShapingRatesTable.')
mscAtmIfShapeUsageTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 840), )
if mibBuilder.loadTexts: mscAtmIfShapeUsageTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfShapeUsageTable.setDescription("This attribute displays the number of VCs that currently use the 31 shaping rates. It is a vector of 31 elements each representing the number of VCs using the particular rate which is displayed with the same element index in the opShapingRates attribute. This attribute is only valid for AtmIf's on APC-based FPs. It is not displayed for AtmIf's on other card types.")
mscAtmIfShapeUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 840, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfShapeUsageIndex"))
if mibBuilder.loadTexts: mscAtmIfShapeUsageEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfShapeUsageEntry.setDescription('An entry in the mscAtmIfShapeUsageTable.')
mscAtmIfShapeUsageIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 840, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30)))
if mibBuilder.loadTexts: mscAtmIfShapeUsageIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfShapeUsageIndex.setDescription('This variable represents the mscAtmIfShapeUsageTable specific index for the mscAtmIfShapeUsageTable.')
mscAtmIfShapeUsageValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 840, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 163839))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfShapeUsageValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfShapeUsageValue.setDescription('This variable represents an individual value for the mscAtmIfShapeUsageTable.')
mscAtmIfConnMap = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2))
mscAtmIfConnMapRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfConnMapRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfConnMap components.')
mscAtmIfConnMapRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfConnMapIndex"))
if mibBuilder.loadTexts: mscAtmIfConnMapRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfConnMap component.')
mscAtmIfConnMapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfConnMapRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfConnMap components. These components can be added and deleted.')
mscAtmIfConnMapComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfConnMapStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapStorageType.setDescription('This variable represents the storage type value for the mscAtmIfConnMap tables.')
mscAtmIfConnMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfConnMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapIndex.setDescription('This variable represents the index for the mscAtmIfConnMap tables.')
mscAtmIfConnMapVccProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfConnMapVccProvTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfConnMapVccProvTable.setDescription("This group is obsolete. Please refer to the Override component below for the current provisioning group This group contains provisionable attributes which specify the VCC space to be supported by an ATM interface. The VCC space consists of an optional 'VPI Zero VCC Space' and an optional 'Programmable VCC Space'. The VPI Zero VCC Space is used to support VCCs with a VPI of zero. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case atmNumberOfNonZeroVpisForVccs_m must also be 0. The optional Programmable VCC Space is used to support VCCs with a VPI other than zero. The VPI values supported in this space must lie in a single contiguous range which excludes VPI 0. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the Programmable VCC Space (should it exist) must adhere to the following rules: If (firstNonZeroVpiForVccs = 1) THEN (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi must be a multiple of 256 OTHERWISE numNonZeroVpisForVccs * numVccsPerNonZeroVpi must be a multiple of 256 If the AtmIf is linked to a LogicalProcessor with a cardType of 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm or 2pJ6MAtm, the size of the entire VCC space (both mandatory and optional parts) and VPC space must not exceed the capacity of the port to which the interface is linked, which is defined in the Arc component's totalConnectionPoolCapacity or connectionPoolCapacity attribute (whichever is non-zero). When using the totalConnectionPoolCapacity attribute, the capacity of the port is (totalConnectionPoolCapacity divided by the number of physical ports). The number of connection identifiers in the VCC and VPC space can be determined as follows: IF (numNonZeroVpisForVccs = 0) THEN number of connection ids = 256 + numVccsForVpiZero OTHERWISE IF (firstNonZeroVpiForVccs = 1) THEN number of connection ids = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi OTHERWISE number of connection ids = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs * numVccsPerNonZeroVpi)")
mscAtmIfConnMapVccProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfConnMapIndex"))
if mibBuilder.loadTexts: mscAtmIfConnMapVccProvEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfConnMapVccProvEntry.setDescription('An entry in the mscAtmIfConnMapVccProvTable.')
mscAtmIfConnMapNumVccsForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16128)).clone(768)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsForVpiZero.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsForVpiZero.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the number of VCCs supported for the VPI Zero VCC Space. The VCI values of these VCCs range from 0 to (numVccsForVpiZero - 1). The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case atmNumberOfNonZeroVpisForVccs_m must also be 0. The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
mscAtmIfConnMapNumNonZeroVpisForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscAtmIfConnMapNumNonZeroVpisForVccs.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfConnMapNumNonZeroVpisForVccs.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the number of conti guous VPIs supported in the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
mscAtmIfConnMapFirstNonZeroVpiForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(48, 48), ValueRangeConstraint(64, 64), ValueRangeConstraint(80, 80), ValueRangeConstraint(96, 96), ValueRangeConstraint(112, 112), ValueRangeConstraint(128, 128), ValueRangeConstraint(144, 144), ValueRangeConstraint(160, 160), ValueRangeConstraint(176, 176), ValueRangeConstraint(192, 192), ValueRangeConstraint(208, 208), ValueRangeConstraint(224, 224), ValueRangeConstraint(240, 240), )).clone(1)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscAtmIfConnMapFirstNonZeroVpiForVccs.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfConnMapFirstNonZeroVpiForVccs.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the initial VPI of the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). The initial VPI of the Programmable VCC Space must either be 1 or a non-zero multiple of 16. The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
mscAtmIfConnMapNumVccsPerNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), )).clone(64)).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsPerNonZeroVpi.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsPerNonZeroVpi.setDescription('This attribute is obsolete. Please refer to the Override component for the new attribute. This attribute specifies the number of VCCs supported for each VPI in the Programmable VCC Space. The VCI values of these VCCs range from 0 to (numVccsPerNonZeroVpi - 1) for each VPI in this space. The size of the Programmable VCC Space must be a power of 2. The VCC Space as a whole must adhere to the guidelines laid down in the description of the AtmConnMappingVccProv group.')
mscAtmIfConnMapOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfConnMapOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOperTable.setDescription("This group contains operational attributes which specify the VCC space to be supported by an ATM interface. The VCC space consists of an optional 'VPI Zero VCC Space' and an optional 'Programmable VCC Space'. The VPI Zero VCC Space is used to support VCCs with a VPI of zero. The VCI values supported in this space range from 0 to an optionally provisioned maximum of numVccsForVpiZero. The size of the VPI Zero VCC Space is either 0 or a multiple of 256. A value of 0 implies that not only can no VCCs be provisioned in the VPI Zero VCC Space but no Programmable VCCs can be used. In this case numNonZeroVpisForVccs will also be 0. The optional Programmable VCC Space supports VCCs with a VPI other than zero. The VPI values supported in this space lie in a single contiguous range which excludes VPI 0. The VCI values supported in this space range from 0 to an optionally provisioned maximum. The number of connection identifier resources in the VCC and VPC space (not all of which are available for user connections) is the value reported in the Lp/n Eng Arc totalConnectionPoolAvailable attribute divided by the number of physical ports on the card, and can be determined as follows: IF (numNonZeroVpisForVccs = 0) THEN number of connection ID resources = 256 + numVccsForVpiZero OTHERWISE IF (firstNonZeroVpiForVccs = 1) THEN number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi OTHERWISE number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs * numVccsPerNonZeroVpi)")
mscAtmIfConnMapOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfConnMapIndex"))
if mibBuilder.loadTexts: mscAtmIfConnMapOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOperEntry.setDescription('An entry in the mscAtmIfConnMapOperTable.')
mscAtmIfConnMapNumVccsForVpiZeroOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsForVpiZeroOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsForVpiZeroOper.setDescription('This attribute indicates the number of VCCs supported for the VPI Zero VCC Space. The VCI values of these VCCs range from 0 to (numVccsForVpiZero - 1). For Apc-based cards, the maximum value is 16384. For CQC-based cards, the maximum value is 16128. To override the system default, see the AtmIf ConnMap Ov attribute numVccsForVpiZero.')
mscAtmIfConnMapNumNonZeroVpisForVccsOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapNumNonZeroVpisForVccsOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapNumNonZeroVpisForVccsOper.setDescription('This attribute indicates the number of contiguous VPIs supported in the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). For Apc-based cards, the maximum value of this attribute is 255 for UNI applications and 4095 for NNI applications. For CQC-based cards, the maximum value is 255. To override the system default, see the AtmIf ConnMap Ov attribute numNonZeroVpisForVccs.')
mscAtmIfConnMapFirstNonZeroVpiForVccsOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 110, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapFirstNonZeroVpiForVccsOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapFirstNonZeroVpiForVccsOper.setDescription('This attribute indicates the initial VPI of the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). For Apc-based cards, the maximum value of this attribute is 255 for UNI applications and 4095 for NNI applications. For CQC-based cards, the maximum value is 240. To override the system default, see the AtmIf ConnMap Ov attribute firstNonZeroVpiForVccs.')
mscAtmIfConnMapNumVccsPerNonZeroVpiOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 110, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), ValueRangeConstraint(8192, 8192), ValueRangeConstraint(16384, 16384), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsPerNonZeroVpiOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapNumVccsPerNonZeroVpiOper.setDescription('This attribute indicates the number of VCCs supported for each VPI in the Programmable VCC Space. The VCI values of these VCCs range from 0 to (numVccsPerNonZeroVpi - 1) for each VPI in this space. For Apc-based cards, the maximum value is 16384. For CQC-based cards, the maximum value is 2048). To override the system default, see the AtmIf ConnMap Ov attribute numVccsPerNonZeroVpi.')
mscAtmIfConnMapOv = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120))
mscAtmIfConnMapOvRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 1), )
if mibBuilder.loadTexts: mscAtmIfConnMapOvRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfConnMapOv components.')
mscAtmIfConnMapOvRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfConnMapIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfConnMapOvIndex"))
if mibBuilder.loadTexts: mscAtmIfConnMapOvRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfConnMapOv component.')
mscAtmIfConnMapOvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapOvRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfConnMapOv components. These components cannot be added nor deleted.')
mscAtmIfConnMapOvComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapOvComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfConnMapOvStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfConnMapOvStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvStorageType.setDescription('This variable represents the storage type value for the mscAtmIfConnMapOv tables.')
mscAtmIfConnMapOvIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfConnMapOvIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvIndex.setDescription('This variable represents the index for the mscAtmIfConnMapOv tables.')
mscAtmIfConnMapOvProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 100), )
if mibBuilder.loadTexts: mscAtmIfConnMapOvProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvProvTable.setDescription("This group contains provisionable attributes which specify the VCC space to be supported by this ATM interface. The VCC space consists of an optional 'VPI Zero VCC Space' and an optional 'Programmable VCC Space'. If not specified otherwise, the semantic checks described below are applicable only for the CQC- based cards. The VPI Zero VCC Space is used to support VCCs with a VPI of zero. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case numNonZeroVpisForVccs must also be 0. The optional Programmable VCC Space is used to support VCCs with a VPI other than zero. The VPI values supported in this space must lie in a single contiguous range which excludes VPI 0. The VCI values supported in this space range from 0 to a provisioned maximum. The size of the Programmable VCC Space (should it exist) must adhere to the following rules: If (firstNonZeroVpiForVccs = 1) THEN (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi must be a multiple of 256 OTHERWISE numNonZeroVpisForVccs * numVccsPerNonZeroVpi must be a multiple of 256 The number of connection identifier resources in the VCC and VPC space can be determined as follows: The number of connection identifier resources in the VCC and VPC space (not all of which are available for user connections) is reported in the Lp/n Eng Arc totalConnectionPoolAvailable attribute, and can be determined as follows: IF (numNonZeroVpisForVccs = 0) THEN number of connection ID resources = 256 + numVccsForVpiZero OTHERWISE IF (firstNonZeroVpiForVccs = 1) THEN number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs + 1) * numVccsPerNonZeroVpi OTHERWISE number of connection ID resources = 256 + numVccsForVpiZero + (numNonZeroVpisForVccs * numVccsPerNonZeroVpi) The number of connection identifier resources must not exceed the capacity of the port to which the interface is linked. If the Lp has an Eng Arc Cqc Ov component provisioned with a non-zero connectionPoolCapacity the port's capacity is specified by this attribute. Otherwise the port's capacity is indicated by the Lp/n Eng Arc totalConnectionPoolAvailable divided by the number of physical ports on the card.")
mscAtmIfConnMapOvProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfConnMapIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfConnMapOvIndex"))
if mibBuilder.loadTexts: mscAtmIfConnMapOvProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvProvEntry.setDescription('An entry in the mscAtmIfConnMapOvProvTable.')
mscAtmIfConnMapOvNumVccsForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfConnMapOvNumVccsForVpiZero.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvNumVccsForVpiZero.setDescription('For Apc-based cards, the maximum value of this attribute is 16384, and the default value is 1024. The allowed values are either 1 or powers of 2. For CQC-based cards the following constraints apply: The maximum value is 16128, and the default is 768. This attribute specifies the number of VCCs supported for the VPI Zero VCC Space. The VCI values of these VCCs range from 0 to (numVccsForVpiZero - 1). The size of the VPI Zero VCC Space must either be 0 or a multiple of 256. A value of 0 implies that no programmable VCCs can be used. In this case numNonZeroVpisForVccs must also be 0. The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
mscAtmIfConnMapOvNumNonZeroVpisForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfConnMapOvNumNonZeroVpisForVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvNumNonZeroVpisForVccs.setDescription('This attribute specifies the number of contiguous VPIs supported in the optional Programmable VCC Space. For Apc-based cards, the maximum value of this attribute is 255 for UNI applications and 4095 for NNI applications. For CQC-based cards the following constraints apply: The maximum value is 255. If numNonZeroVpisForVccs is 0 the Programmable VCC Space does not exist. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
mscAtmIfConnMapOvFirstNonZeroVpiForVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfConnMapOvFirstNonZeroVpiForVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvFirstNonZeroVpiForVccs.setDescription('This attribute specifies the initial VPI of the optional Programmable VCC Space. If numNonZeroVpisForVccs is 0 then the Programmable VCC Space does not exist and the value of this attribute is ignored. If numNonZeroVpisForVccs is greater than 0 the Programmable VCC Space exists and covers the VPI values ranging from firstNonZeroVpiForVccs to (firstNonZeroVpiForVccs + numNonZeroVpisForVccs - 1). For Apc-based cards, this value can be any integer number between 1 and 255 for UNI applications and between 1 and 4095 for NNI applications. For CQC-based cards the initial VPI of the Programmable VCC Space must be no greater than 240, and either 1 or a non-zero multiple of 16. The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
mscAtmIfConnMapOvNumVccsPerNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 2, 120, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(512, 512), ValueRangeConstraint(1024, 1024), ValueRangeConstraint(2048, 2048), ValueRangeConstraint(4096, 4096), ValueRangeConstraint(8192, 8192), ValueRangeConstraint(16384, 16384), )).clone(64)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfConnMapOvNumVccsPerNonZeroVpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfConnMapOvNumVccsPerNonZeroVpi.setDescription('This attribute specifies the number of VCCs supported for each VPI in the Programmable VCC Space. The VCI values of these VCCs range from 0 to (numVccsPerNonZeroVpi - 1) for each VPI in this space. For Apc-based cards, the maximum value of this attribute is 16384. For CQC-based cards, the maximum value is 2048. The values of all attributes provisioned in this group must adhere to the guidelines laid down in the description of the Provisioned group.')
mscAtmIfCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3))
mscAtmIfCARowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfCARowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfCA components.')
mscAtmIfCARowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"))
if mibBuilder.loadTexts: mscAtmIfCARowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfCA component.')
mscAtmIfCARowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCARowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfCA components. These components cannot be added nor deleted.')
mscAtmIfCAComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfCAStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAStorageType.setDescription('This variable represents the storage type value for the mscAtmIfCA tables.')
mscAtmIfCAIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfCAIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAIndex.setDescription('This variable represents the index for the mscAtmIfCA tables.')
mscAtmIfCAProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100), )
if mibBuilder.loadTexts: mscAtmIfCAProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAProvTable.setDescription('This group contains provisioned attributes which specify the behavior of Connection Admission Control (CAC) for the ATM connections configured on an ATM interface. Note that the names of some of the attributes follow the conventions of UNI 4.0 for forward compatibility reasons. This does not imply conformance in general with the UNI 4.0 specification.')
mscAtmIfCAProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"))
if mibBuilder.loadTexts: mscAtmIfCAProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAProvEntry.setDescription('An entry in the mscAtmIfCAProvTable.')
mscAtmIfCAMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxVpcs.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAMaxVpcs.setDescription("This attribute specifies the maximum number of Vpcs that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs +1) across all spared AtmIfs linked to that Lp must not exceed the protectedConnectionPoolCapacity attribute of the Arc component. The sum of (maxVpts * 3) across all spared AtmIfs and (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all unspared AtmIfs linked to that Lp must not exceed connectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. Vpts on a spared AtmIf are considered unspared, their resources are allocated from connectionPoolCapacity. If the Arc component doesn't exist, the default value of the Arc connectionPoolCapacity and protectedConnectionPoolCapacity attribute is used as the limit. This attribute has been obsoleted and its value migrated to the maxVpcs attribute.")
mscAtmIfCAMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16384), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMaxVccs.setDescription("This attribute specifies the maximum number of usable Vccs (and Vpt Vccs) that can be configured on this AtmIf. The value must not exceed the number of non-reserved Vcc identifiers in the Vcc space supported by this AtmIf (which is specified by the ConnectionMapping component). Furthermore, if the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all spared AtmIfs linked to that Lp must not exceed the protectedConnectionPoolCapacity attribute of the Arc component. The sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all unspared AtmIfs linked to that Lp must not exceed connectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc connectionPoolCapacity and protectedConnectionPoolCapacity attribute is used as the limit. If this attribute is set to autoConfigure, then on 32 port Multi- Service Access cards its value is configured as 100, and on all other cards it is 255. VALUES ( 65535 = autoConfigure )")
mscAtmIfCAMinMulticastBranches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMinMulticastBranches.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMinMulticastBranches.setDescription('This attribute specifies the guaranteed number of switched multicast branches that can be activated on this AtmIf, including those activated beneath a Vpt. The sum of minMulticastBranches and the number of provisioned branches listed in the nextHop attribute of all Mnrps across all spared AtmIfs linked to that Lp must not exceed the protectedMcstBranchesCapacity attribute of the Arc component. The sum of minMulticastBranches and the number of provisioned branches listed in the nextHop attribute of all Mnrps across all unspared AtmIfs linked to that Lp must not exceed multicastBranchesCapacity attribute of the Arc component. For CQC-based ATM cards, the value of the attribute can not exceed 10752. If this value is non zero, the Arc component must exist and have multicastBranchesCapacity set to a value greater than or equal to this attribute.')
mscAtmIfCAMaxMulticastBranches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 8), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 16384), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxMulticastBranches.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMaxMulticastBranches.setDescription('This attribute specifies the maximum number of provisionable multicast branches that can be activated on this AtmIf, including those activated beneath a Vpt. If this attribute is set to a value other than autoConfigure, it must be greater than or equal to the value of minMulticastBranches of this AtmIf. For CQC-based ATM cards, the value of the attribute can not exceed 10752. When this attribute is set to autoConfigure, an appropriate value is selected based on the card type. It is set to 10752 for all CQC-based ATM cards, and to 16384 for ATM IP cards. VALUES ( 0 = autoConfigure )')
mscAtmIfCAMaxVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxVpts.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAMaxVpts.setDescription("This attribute specifies the maximum number of Vpts that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs +1) across all spared AtmIfs linked to that Lp must not exceed the protectedConnectionPoolCapacity attribute of the Arc component. The sum of (maxVpts * 3) across all spared AtmIfs and (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all unspared AtmIfs linked to that Lp must not exceed connectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. Vpts on a spared AtmIf are considered unspared, their resources are allocated from connectionPoolCapacity. If the Arc component doesn't exist, the default value of the Arc connectionPoolCapacity and protectedConnectionPoolCapacity attribute is used as the limit. This attribute has been obsoleted and its value migrated to the maxVpts attribute.")
mscAtmIfCAMinAutoSelectedVci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(32, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVci.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVci.setDescription('This attribute specifies the default lower boundary for VCIs which are automatically allocated for a switched Vcc. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This attribute has been obsoleted and its value migrated to the minAutoSelectedVciForVpiZero attribute.')
mscAtmIfCAMinAutoSelectedVciForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVciForVpiZero.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVciForVpiZero.setDescription('This attribute specifies the minimum VCI value which is automatically allocated for a switched Vcc with VPI value of zero. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath Vpt/0.')
mscAtmIfCAMinAutoSelectedVciForNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 65535)).clone(32)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVciForNonZeroVpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVciForNonZeroVpi.setDescription('This attribute specifies the minimum VCI value which is automatically allocated for a switched Vcc with a non-zero VPI value. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath a Vpt.')
mscAtmIfCAPermittedSvcAtmServiceCategories = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAPermittedSvcAtmServiceCategories.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAPermittedSvcAtmServiceCategories.setDescription('This attribute specifies which ATM service categories are permitted on this interface for SVCs. The value of this attribute does not affect control VCCs, such as signalling and ILMI channels. If the value is empty, no SVCs may use this interface. This attribute has been obsoleted and its value migrated to the permittedAtmServiceCategories attribute. Description of bits: unspecifiedBitRate(0) constantBitRate(1) rtVariableBitRate(2) nrtVariableBitRate(3)')
mscAtmIfCACbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("pool1", 1), ("pool2", 2), ("pool3", 3))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrPool.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCACbrPool.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. In addition, notApplicable is no longer a valid value of the new attribute. This attribute specifies the bandwidth pool which is to be used to support the constant bit rate (CBR) service category. When the user does not intend to support the CBR service category, this attribute should be set to notApplicable. Otherwise, one of the three bandwidth pools should be selected. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to CBR traffic.')
mscAtmIfCACbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrCdvt.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCACbrCdvt.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. This attribute specifies the cell delay variation tolerance (CDVT) which is to be applied to the entire ATM Interface for CBR traffic.')
mscAtmIfCACbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 0)).clone(-10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrCellLossRatio.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCACbrCellLossRatio.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. In addition, the type and range of the new attribute have been changed. This attribute specifies the tolerable cell loss ratio (CLR) for CBR traffic. The number is the logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then cbrCellLossRatio = -10. This number must be the same as the vbrRtCellLossRatio since CBR and rt-VBR traffic have the same discard priority. The cbrCellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for CBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization.')
mscAtmIfCASvcCbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCASvcCbrHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCASvcCbrHoldingPriority.setDescription('This attribute has been obsoleted and migrated under the Cbr subcomponent. This attribute specifies the default holding priority which applies for SVC CBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released.')
mscAtmIfCASvcVbrRtHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCASvcVbrRtHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCASvcVbrRtHoldingPriority.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. This attribute specifies the default holding priority which applies for SVC rt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released.')
mscAtmIfCASvcVbrNrtHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCASvcVbrNrtHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCASvcVbrNrtHoldingPriority.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. This attribute specifies the default holding priority which applies for SVC nrt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released.')
mscAtmIfCAVbrRtPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("pool1", 1), ("pool2", 2), ("pool3", 3))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAVbrRtPool.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAVbrRtPool.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. In addition, notApplicable is no longer a valid value of the new attribute. This attribute specifies the bandwidth pool which is to be used to support the variable bit rate real time (rt-VBR) service category. When the user does not intend to support the rt-VBR service category, this attribute should be set to notApplicable. Otherwise, one of the three bandwidth pools should be selected. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to rt-VBR traffic.')
mscAtmIfCAVbrRtCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAVbrRtCdvt.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAVbrRtCdvt.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. This attribute specifies the cell delay variation tolerance (CDVT) which is to be applied to the entire ATM Interface for rt-VBR traffic.')
mscAtmIfCAVbrRtCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 80), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 0)).clone(-10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAVbrRtCellLossRatio.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAVbrRtCellLossRatio.setDescription('This attribute has been obsoleted and migrated under the RtVbr subcomponent. In addition, the type and range of this attribute has been changed. This attribute specifies the tolerable cell loss ratio (CLR) for rt- VBR traffic. The number is the logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then vbrRtCellLossRatio = - 10. This number must be the same as the cbrCellLossRatio since CBR and rt-VBR traffic have the same discard priority. The vbrRtCellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for rt-VBR connections. This number must be less than or equal to the vbrNrtCellLossRatio, since rt-VBR traffic has a higher discard priority. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization.')
mscAtmIfCAVbrNrtPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("notApplicable", 0), ("pool1", 1), ("pool2", 2), ("pool3", 3))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAVbrNrtPool.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAVbrNrtPool.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. In addition, notApplicable is no longer a valid value of the new attribute. This attribute specifies the bandwidth pool which is to be used to support the variable bit rate non-real time (nrt-VBR) service category. When the user does not intend to support the nrt-VBR, this attribute should be set to notApplicable. Otherwise, one of the three bandwidth pools should be selected. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to nrt-VBR traffic.')
mscAtmIfCAVbrNrtCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAVbrNrtCdvt.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAVbrNrtCdvt.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. This attribute specifies the cell delay variation tolerance (CDVT), which is to be applied to the entire ATM Interface for nrt-VBR traffic.')
mscAtmIfCAMaxCaVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 105), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4096), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxCaVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMaxCaVpcs.setDescription("This attribute specifies the maximum number of Vpcs that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all spared AtmIfs linked to that Lp must not exceed the protectedConnectionPoolCapacity attribute of the Arc component. The sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all unspared AtmIfs linked to that Lp must not exceed connectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc connectionPoolCapacity and protectedConnectionPoolCapacity attribute is used as the limit. If this attribute is set to autoConfigure, then on 32 port Multi- Service Access cards its value is configured as 16, and on all other cards it is 128. VALUES ( 65535 = autoConfigure )")
mscAtmIfCAMaxCaVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 106), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4096), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxCaVpts.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMaxCaVpts.setDescription("This attribute specifies the maximum number of Vpts that can be activated on this AtmIf. If the AtmIf is linked to a LogicalProcessor of cardType other than 3pE3Atm, 3pDS3Atm, 3pOC3MmAtm, 3pOC3SmAtm, 3pE1Atm, 3pDS1Atm, 2pJ6MAtm, the sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all spared AtmIfs linked to that Lp must not exceed the protectedConnectionPoolCapacity attribute of the Arc component. The sum of (maxVccs + maxVpcs + (maxVpts * 3) + 1) across all unspared AtmIfs linked to that Lp must not exceed connectionPoolCapacity attribute of the Arc component. Note that 3 connections are used for every standard Vpt and 2 for each basic Vpt. If the Arc component doesn't exist, the default value of the Arc connectionPoolCapacity and protectedConnectionPoolCapacity attribute is used as the limit. If this attribute is set to autoConfigure, then on 32 port Multi- Service Access cards its value is configured as 16, and on all other cards it is 128. VALUES ( 65535 = autoConfigure )")
mscAtmIfCAVbrNrtCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 110), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 0)).clone(-7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAVbrNrtCellLossRatio.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAVbrNrtCellLossRatio.setDescription('This attribute has been obsoleted and migrated under the NrtVbr subcomponent. In addition, the type and range of new attribute has been changed. This attribute specifies the tolerable cell loss ratio (CLR) for nrt- VBR traffic. The number is the logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then vbrNrtCellLossRatio = - 10.This number must be greater than or equal to vbrRtCellLossRatio since rt-VBR traffic has a higher discard priority. The vbrNrtCellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for nrt-VBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization.')
mscAtmIfCAUbrMaxConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 120), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384)).clone(16384)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxConnections.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxConnections.setDescription('This attribute is obsolete in P6.0, and has been migrated to the CA Ubr/0 maxVccs and maxVpcs attributes. This attribute specifies the maximum number of unspecified bit rate (UBR) connections which are to be admitted managed by this CA. This number is enforced by the connection admission control (CAC) algorithm for this AtmIf.')
mscAtmIfCAMinAutoSelectedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 121), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMinAutoSelectedVpi.setDescription('This attribute specifies the minimum VPI value which will be automatically allocated for a switched Vpc. A VPI number is automatically allocated when a switched Vpc does not request a specific VPI number.')
mscAtmIfCAPermittedAtmServiceCategories = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 122), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAPermittedAtmServiceCategories.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPermittedAtmServiceCategories.setDescription("This attribute specifies which ATM service categories are permitted on this interface for SVPs and SVCs. The value of this attribute does not affect control VCCs, such as signalling and ILMI channels. If the value is empty, no non-control SVPs or SVCs will use this interface. This attribute is ignored for the admission of provisioned VCCs, VPCs, VPTs, S-PVCs, and S-PVPs. The value of the permittedAtmServiceCategories in a VPT CA overrides this AtmIf CA setting for all the given VPT's VCCs. Description of bits: unspecifiedBitRate(0) constantBitRate(1) rtVariableBitRate(2) nrtVariableBitRate(3)")
mscAtmIfCAMaxAutoSelectedVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 125), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4095)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxAutoSelectedVpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMaxAutoSelectedVpi.setDescription('This attribute specifies the maximumVPI value which will be automatically allocated for a switched Vpc or Vcc. A VPI number is automatically allocated when a switched Vpc or Vcc does not request a specific VPI number.')
mscAtmIfCAMaxAutoSelectedVciForVpiZero = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 126), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(767)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxAutoSelectedVciForVpiZero.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMaxAutoSelectedVciForVpiZero.setDescription('This attribute specifies the maximum VCI value which is automatically allocated for a switched Vcc. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath Vpt/0.')
mscAtmIfCAMaxAutoSelectedVciForNonZeroVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 100, 1, 127), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 65535)).clone(63)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAMaxAutoSelectedVciForNonZeroVpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAMaxAutoSelectedVciForNonZeroVpi.setDescription('This attribute specifies the maximum VCI value which is automatically allocated for a switched Vcc. A VCI number is automatically allocated when a switched Vcc does not request a specific VCI number. This value also applies to switched Vccs created beneath non zero Vpts.')
mscAtmIfCAOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110), )
if mibBuilder.loadTexts: mscAtmIfCAOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAOperTable.setDescription('This group contains operational attributes giving statistics about the ATM connections configured on an ATM interface.')
mscAtmIfCAOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"))
if mibBuilder.loadTexts: mscAtmIfCAOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAOperEntry.setDescription('An entry in the mscAtmIfCAOperTable.')
mscAtmIfCAActualMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAActualMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAActualMaxVccs.setDescription('This attribute indicates the maximum number of VCC connections that can be supported on this interface. The value includes both provisioned and dynamic connections. The value is determined from the provisioned attribute maxVccs.')
mscAtmIfCAPermanentVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPermanentVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPermanentVpcs.setDescription('This attribute indicates the number of permanent Vpcs that are currently provisioned on this interface.')
mscAtmIfCAPermanentVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPermanentVpts.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPermanentVpts.setDescription('This attribute indicates the number of permanent Vpts that are currently provisioned on this interface.')
mscAtmIfCAPermanentVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPermanentVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPermanentVccs.setDescription('This attribute indicates the number of permanent Vccs that are currently provisioned on this interface (this includes Vccs having SrcPvc subcomponents). Vpt Vccs are also included in this count.')
mscAtmIfCASwitchedVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 30), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCASwitchedVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCASwitchedVccs.setDescription('This attribute indicates the number of switched Vccs that are currently active on this interface. Vpt Vccs are also included in this count.')
mscAtmIfCASwitchedMulticastBranches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 40), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCASwitchedMulticastBranches.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCASwitchedMulticastBranches.setDescription('This attribute indicates the number of multicast branches used in switched Vccs, including Vpt Vccs, that are currently active on this interface. The sum of this attribute for all AtmIf components linked to an Lp added to the sum of permanentMulticastBranches for all AtmIf components linked to the same Lp gives the value of multiCastBranchesUsage in the Arc component.')
mscAtmIfCAPermanentMulticastBranches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 55), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPermanentMulticastBranches.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPermanentMulticastBranches.setDescription('This attribute indicates the number of multicast branches used in permanent Vccs and Vpcs that are currently active on this interface. The sum of this attribute for all AtmIf components linked to an Lp added to the sum of switchedMulticastBranches for all AtmIf components linked to the same Lp gives the value of multiCastBranchesUsage in the Arc component.')
mscAtmIfCATroubledVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 60), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCATroubledVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCATroubledVpcs.setDescription("This attribute indicates the number of troubled Vpcs on this interface. A Vpc is 'troubled' if its operational troubled attribute has the value yes.")
mscAtmIfCATroubledVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 65), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCATroubledVpts.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCATroubledVpts.setDescription("This attribute indicates the number of troubled Vpts on this interface. A Vpt is 'troubled' if its operational troubled attribute has the value yes.")
mscAtmIfCATroubledVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCATroubledVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCATroubledVccs.setDescription("This attribute indicates the number of troubled Vccs on this interface. A Vcc is 'troubled' if its operational troubled attribute has the value yes.")
mscAtmIfCAUbrAvailableConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 80), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrAvailableConnections.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAUbrAvailableConnections.setDescription('This attribute is historical in P6.0. Refer instead to the vccUsage and vpcUsage under the AtmIf CA Ubr component. This attribute indicates the available UBR connections. Its value is ubrMaxConnections minus the number of admitted connections.')
mscAtmIfCAConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 81), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAConnectionPoolUsage.setDescription('This attribute indicates the number of enabled VCCs, VPCs, and VPTs in this AtmIf. An example of a VCC not in the enabled state is a Vcc with a Test subcomponent where the test is not started. Each Vcc or Vpc is counted as 1 connection. Each basic Vpt is counted as 2 connections and each standard Vpt is counted as 3 connections. Each connection appropriately reduces the number of connections indicated in Arc totalConnectionPoolAvailable and increases the number of connections indicated in Arc totalConnectionPoolUsage.')
mscAtmIfCASwitchedVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 82), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCASwitchedVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCASwitchedVpcs.setDescription('This attribute indicates the number of switched Vpcs that are currently active on this interface.')
mscAtmIfCAActualMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 105), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAActualMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAActualMaxVpcs.setDescription('This attribute indicates the maximum number of VPC connections that can be supported on this interface. The value includes both provisioned and dynamic connections. The value is determined from the provisioned attribute maxVpcs.')
mscAtmIfCAActualMaxVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 110, 1, 106), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAActualMaxVpts.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAActualMaxVpts.setDescription('This attribute indicates the maximum number of VPT connections that can be supported on this interface. The value includes both provisioned and dynamic connections. The value is determined from the provisioned attribute maxVpts.')
mscAtmIfCAPmTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 120), )
if mibBuilder.loadTexts: mscAtmIfCAPmTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPmTable.setDescription('This group contains the operational attributes indicating the total number of connections on the interface with active Cell Loss Ratio (CLR) and Availability Ratio (AR) measurements on the interface.')
mscAtmIfCAPmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPmEntry.setDescription('An entry in the mscAtmIfCAPmTable.')
mscAtmIfCAOamFPmConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 120, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAOamFPmConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAOamFPmConnections.setDescription('This attribute indicates the total number of connections on the interface receiving OAM Forward Performance Monitoring (FPM) cells on the interface.')
mscAtmIfCAOamBrPmConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 120, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAOamBrPmConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAOamBrPmConnections.setDescription('This attribute indicates the total number of connections receiving OAM Backward Reporting (BR) cells on the interface.')
mscAtmIfCAOamCcConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 120, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAOamCcConnections.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAOamCcConnections.setDescription('This attribute indicates the total number of connections receiving OAM Continuity Check (CC) cells on the interface.')
mscAtmIfCABwPoolTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 293), )
if mibBuilder.loadTexts: mscAtmIfCABwPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCABwPoolTable.setDescription('Link capacity is partitioned into five bandwidth pools. This attribute specifies the percentage of link bandwidth that is allowed for each pool. The percentage for each pool ranges from 0% to 12,800%. This allows for both under and over subscription of the link. Under subscription occurs when the sum of the percentages assigned to the five pools is less than 100%. Over subscription occurs when the sum of the percentages for the five pools exceeds 100%.')
mscAtmIfCABwPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 293, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCABwPoolIndex"))
if mibBuilder.loadTexts: mscAtmIfCABwPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCABwPoolEntry.setDescription('An entry in the mscAtmIfCABwPoolTable.')
mscAtmIfCABwPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 293, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfCABwPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCABwPoolIndex.setDescription('This variable represents the mscAtmIfCABwPoolTable specific index for the mscAtmIfCABwPoolTable.')
mscAtmIfCABwPoolValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 293, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 12800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCABwPoolValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCABwPoolValue.setDescription('This variable represents an individual value for the mscAtmIfCABwPoolTable.')
mscAtmIfCAPoolRequBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 296), )
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwTable.setDescription('This attribute indicates the total requested bandwidth from bandwidthPool. This attribute does not include bandwidth for ATM networking signalling connections, or bandwidth for connections managed by a Vpt CA. Its value is the sum of the equivalent cell rates (ECR) for connections which are admitted, and for connections which are requesting admission but have not yet been admitted.')
mscAtmIfCAPoolRequBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 296, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAPoolRequBwIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwEntry.setDescription('An entry in the mscAtmIfCAPoolRequBwTable.')
mscAtmIfCAPoolRequBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 296, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwIndex.setDescription('This variable represents the mscAtmIfCAPoolRequBwTable specific index for the mscAtmIfCAPoolRequBwTable.')
mscAtmIfCAPoolRequBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 296, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolRequBwValue.setDescription('This variable represents an individual value for the mscAtmIfCAPoolRequBwTable.')
mscAtmIfCAPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 299), )
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwTable.setDescription('This attribute indicates the total admitted bandwidth in bandwidthPool. This attribute does not include bandwidth for ATM networking signalling connections, or bandwidth for connections managed by a Vpt CA. Its value is the sum of the equivalent cell rates (ECR) of the admitted connections.')
mscAtmIfCAPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 299, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAPoolAdmitBwIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwEntry.setDescription('An entry in the mscAtmIfCAPoolAdmitBwTable.')
mscAtmIfCAPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 299, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwIndex.setDescription('This variable represents the mscAtmIfCAPoolAdmitBwTable specific index for the mscAtmIfCAPoolAdmitBwTable.')
mscAtmIfCAPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 299, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmitBwValue.setDescription('This variable represents an individual value for the mscAtmIfCAPoolAdmitBwTable.')
mscAtmIfCAPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 300), )
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwTable.setDescription('This attribute indicates the total available bandwidth in bandwidthPool. Its value is the link capacity reduced by the sum of the equivalent cell rates (ECR) of the admitted connections.')
mscAtmIfCAPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 300, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAPoolAvailBwIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwEntry.setDescription('An entry in the mscAtmIfCAPoolAvailBwTable.')
mscAtmIfCAPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 300, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3)))
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwIndex.setDescription('This variable represents the mscAtmIfCAPoolAvailBwTable specific index for the mscAtmIfCAPoolAvailBwTable.')
mscAtmIfCAPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 300, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailBwValue.setDescription('This variable represents an individual value for the mscAtmIfCAPoolAvailBwTable.')
mscAtmIfCAPoolProvBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 319), )
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwTable.setDescription('This attribute indicates the total bandwidth from bandwidthPool which is specified by provisioned connections except for those managed by a Vpt CA. Its value is the sum of the equivalent cell rates (ECR) of the provisioned connections. Provisioned connections include provisioned AtmIf Vccs, AtmIf Vpcs, AtmIf Vpts, Vpt Vccs, and Vccs or Vpcs with a Src component under them.')
mscAtmIfCAPoolProvBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 319, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAPoolProvBwIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwEntry.setDescription('An entry in the mscAtmIfCAPoolProvBwTable.')
mscAtmIfCAPoolProvBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 319, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwIndex.setDescription('This variable represents the mscAtmIfCAPoolProvBwTable specific index for the mscAtmIfCAPoolProvBwTable.')
mscAtmIfCAPoolProvBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 319, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolProvBwValue.setDescription('This variable represents an individual value for the mscAtmIfCAPoolProvBwTable.')
mscAtmIfCAPoolWaitAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 320), )
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsTable.setDescription('This attribute indicates the total number of connections which have currently requested admission in bandwidthPool but are not yet admitted. This attribute does not include ATM networking signalling connections, or connections managed by a Vpt CA.')
mscAtmIfCAPoolWaitAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 320, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAPoolWaitAdmConnsIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsEntry.setDescription('An entry in the mscAtmIfCAPoolWaitAdmConnsTable.')
mscAtmIfCAPoolWaitAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 320, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsIndex.setDescription('This variable represents the mscAtmIfCAPoolWaitAdmConnsTable specific index for the mscAtmIfCAPoolWaitAdmConnsTable.')
mscAtmIfCAPoolWaitAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 320, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolWaitAdmConnsValue.setDescription('This variable represents an individual value for the mscAtmIfCAPoolWaitAdmConnsTable.')
mscAtmIfCAPoolAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 321), )
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsTable.setDescription('This attribute indicates the total number of connections which are currently admitted in bandwidthPool. This attribute does not include ATM networking signalling connections, or connections managed by a Vpt CA.')
mscAtmIfCAPoolAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 321, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAPoolAdmConnsIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsEntry.setDescription('An entry in the mscAtmIfCAPoolAdmConnsTable.')
mscAtmIfCAPoolAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 321, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsIndex.setDescription('This variable represents the mscAtmIfCAPoolAdmConnsTable specific index for the mscAtmIfCAPoolAdmConnsTable.')
mscAtmIfCAPoolAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 321, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAdmConnsValue.setDescription('This variable represents an individual value for the mscAtmIfCAPoolAdmConnsTable.')
mscAtmIfCAPoolAvailableBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 326), )
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwTable.setDescription('This attribute indicates the total available bandwidth in bandwidthPool. A positive number indicates that there is still bandwidth available in the pool which has not been allocated. A negative value indicates that some bandwidth-elastic provisioned connections are running in reduced mode, where their allocated bandwidth is below their originally allocated ECR. The negative amount is equal to the sum of the bwReduction attribute for all connections under this bandwidthPool.')
mscAtmIfCAPoolAvailableBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 326, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAPoolAvailableBwIndex"))
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwEntry.setDescription('An entry in the mscAtmIfCAPoolAvailableBwTable.')
mscAtmIfCAPoolAvailableBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 326, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwIndex.setDescription('This variable represents the mscAtmIfCAPoolAvailableBwTable specific index for the mscAtmIfCAPoolAvailableBwTable.')
mscAtmIfCAPoolAvailableBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 326, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-2147483648, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAPoolAvailableBwValue.setDescription('This variable represents an individual value for the mscAtmIfCAPoolAvailableBwTable.')
mscAtmIfCACbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2))
mscAtmIfCACbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfCACbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfCACbr components.')
mscAtmIfCACbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCACbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCACbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfCACbr component.')
mscAtmIfCACbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfCACbr components. These components can be added.')
mscAtmIfCACbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCACbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfCACbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCACbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfCACbr tables.')
mscAtmIfCACbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfCACbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrIndex.setDescription('This variable represents the index for the mscAtmIfCACbr tables.')
mscAtmIfCACbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfCACbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrProvTable.setDescription('This group contains provisioned attributes which control the CBR service category for this interface.')
mscAtmIfCACbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCACbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCACbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrProvEntry.setDescription('An entry in the mscAtmIfCACbrProvTable.')
mscAtmIfCACbrProvPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrProvPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrProvPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the constant bit rate (CBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to CBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfCACbrProvCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrProvCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrProvCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the CBR service category except those managed by a Vpt CA. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is used by the CAC function to compute the equivalent cell rate (ECR) required by a given CBR connection. The larger the value of CDVT, the larger is its ECR. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
mscAtmIfCACbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrCdv.setDescription('This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to the entire ATM Interface for CBR traffic. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The worst case value of this attribute can be computed as the txQueueLimit divided by the link rate of this ATM Interface. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the CDV requirements of the connection. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.')
mscAtmIfCACbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to the entire ATM Interface for CBR traffic. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the ATM connection's MaxCTD requirement.")
mscAtmIfCACbrProvClr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrProvClr.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrProvClr.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for CBR traffic except for connections managed by a Vpt CA. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then Cbr cellLossRatio = 10. This number must be the same as the RtVbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The Cbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for CBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for CBR connections, and CAC is effectively turned off. All CBR connections are admitted.')
mscAtmIfCACbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 60), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the CBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75, and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. For a per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75 and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. CQC-based ATM cards and 1pOC12SmLrAtm cards do not support per-VC queues at the CBR service category. When this attribute is set to autoConfigure, an appropriate value is selected based on the card type. It is set to 96 for all Passport ATM cards (DS1, E1, IMA, JT2, DS3, E3, OC3, both CQC- and ATM IP- based), except 1pOC12SmLrAtm. For the 1pOC12SmLrAtm card, the value is set to 350. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. For CQC-based ATM cards, the valid range for this attribute is from 5 to 30000 inclusive. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )")
mscAtmIfCACbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrHoldingPriority.setDescription("This attribute specifies the holding priority which applies to SVP and SVC CBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCACbrSvcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrSvcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCACbrSvcHoldingPriority.setDescription('This attribute specifies the default holding priority which applies to SVC CBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute has been obsoleted and its value migrated to holdingPriority attribute.')
mscAtmIfCACbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC CBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCACbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 80), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 12000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the CBR service category. This attribute is ignored on CQC-based ATM cards, 1pOC48SmSrAtm, and 1pOC12SmLrAtm cards, because they do not support per-VC queues at the CBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
mscAtmIfCACbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 90), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1416905), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the CBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. This attribute is ignored on CQC-based ATM cards and 1pOC12SmLrAtm cards, because they do not support per-VC queues at the CBR service category. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 80000 for all cards which support per-VC queuing at the CBR service category (3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2, 2pOC3MmAtm2). For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, the reference rate is set to 65511 for DS3 and OC3 channels, and set to 262044 for OC12 channels. For Apc-based cards the maximum value is 1416905. For all other cards, the maximum value is 943396. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
mscAtmIfCACbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the CBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCACbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 140), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the CBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any CBR connections. For CQC-based ATM FPs and 1pOC12SmLrAtm FPs, this attribute must be set to disabled. Traffic shaping is not supported for CBR connections on CQC-based ATM FPs. If the Vcc Tm, Vpc Tm, or Vpt Tm, txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, inverseUpc shaping is not available. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. If this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse-UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCACbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 150), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('minimumCdv')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the CBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from the other connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain any delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCACbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 160), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1))).clone('common')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the CBR service category. On ATM IP cards, this attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue for this service category. The common queue has one set of congestion control levels for all cells enqueued on it. For 1pOC12SmLrAtm cards this attribute must be set to common or autoConfigure. This attribute cannot be set to perVc since perVc queueing is not available on the 1pOC12SmLrAtm card. The value autoConfigure is interpreted to mean common queueing. For CQC-based ATM cards, this attribute must be set to common. CQC-based ATM cards do not support per-VC queueing for the CBR service category. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards only perVc queueing is supported. All other attribute values are ignored. For ATM IP cards, if traffic shaping for this service category is not disabled, this attribute must be set to perVc. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCACbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 165), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scr", 1), ("pcr", 2), ("ecr", 3))).clone('ecr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrWeightPolicy.setDescription('This attribute specifies the default policy which is applied when calculating the fairness weight for unshaped connections of the CBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the CBR service category. This attribute is ignored on CQC-based ATM cards. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. If this attribute is set to scr, the fairness weight is proportional to the transmit sustained cell rate (SCR) of a connection. Connections with a higher SCR have a higher fairness weight. For connections with txTrafficDescType 3, which have no SCR, the sustained cell rate is assumed to be equal to the peak cell rate. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCACbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 169), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all CBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is not supported by 4pOC12SmIrAtm and 4pOC12SmLrAtm cards. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This attribute never applies to any type of Vpt.')
mscAtmIfCACbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 100, 1, 170), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCACbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the CBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enforced by default for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all CBR connections. This attribute never applies to any type of Vpt.')
mscAtmIfCACbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfCACbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrOperTable.setDescription('This group contains operational attributes for the CBR service category.')
mscAtmIfCACbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCACbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCACbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrOperEntry.setDescription('An entry in the mscAtmIfCACbrOperTable.')
mscAtmIfCACbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCACbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCACbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
mscAtmIfCARtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3))
mscAtmIfCARtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfCARtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfCARtVbr components.')
mscAtmIfCARtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCARtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCARtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfCARtVbr component.')
mscAtmIfCARtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfCARtVbr components. These components can be added.')
mscAtmIfCARtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCARtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfCARtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCARtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfCARtVbr tables.')
mscAtmIfCARtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfCARtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrIndex.setDescription('This variable represents the index for the mscAtmIfCARtVbr tables.')
mscAtmIfCARtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100), )
if mibBuilder.loadTexts: mscAtmIfCARtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrProvTable.setDescription('This group contains provisioned attributes which control the rt-VBR service category for this interface.')
mscAtmIfCARtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCARtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCARtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrProvEntry.setDescription('An entry in the mscAtmIfCARtVbrProvTable.')
mscAtmIfCARtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the real-time variable bit rate (rt-VBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to rt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfCARtVbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the rt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC to bandwidth usage beyond the traffic contract.")
mscAtmIfCARtVbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1268)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrCdv.setDescription('This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to the entire ATM Interface for rt-VBR traffic. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The worst case value of this attribute can be computed as the txQueueLimit divided by the link rate of this ATM Interface. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the CDV requirement for that connection. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.')
mscAtmIfCARtVbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to the entire ATM Interface for rt-VBR traffic. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this ATM Interface can meet the ATM connection's MaxCTD requirement.")
mscAtmIfCARtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for rt- VBR traffic except for connections managed by a Vpt CA. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then RtVbr cellLossRatio = 10. This number must be the same as the Cbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The RtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for rt-VBR connections. This number must be less than or equal to the NrtVbr cellLossRatio, since rt-VBR traffic has a higher discard priority. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for rt-VBR connections, and CAC is effectively turned off. All rt-VBR are admitted.')
mscAtmIfCARtVbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 60), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the rt-VBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75, and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2, and DP=1 respectively. For a per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75, and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2, and DP=1, respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 288 for low speed cards such as DS1, E1 and IMA, and set to 480 for high speed cards such as JT2, DS3, E3 and OC3 (including ATM IP FPs). For the 1pOC12SmLrAtm card, the value is set to 2048. For the 1pOC48SmSrAtm card, the value is set to 12288. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. For CQC-based ATM cards, the valid range for this attribute is from 5 to 30000 inclusive. For 1pOC48SmSrAtm cards, the value of this attribute is used to set the maximum size of the link-class queue for buffering this traffic type on the egress path. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. VALUES ( 0 = autoConfigure )")
mscAtmIfCARtVbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 160000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the rt-VBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. For the 1pOC12SmLrAtm and 1pOC48SmSrAtm cards, this attribute does not apply since per-VC queueing is not available. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
mscAtmIfCARtVbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 75), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1416905), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the rt-VBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1, and IMA, and set to 14740 for high speed cards such as JT2, DS3, E3 and OC3. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, the reference rate is set to 65511 for DS3 and OC3 channels, and set to 262044 for OC12 channels. For Apc-based cards the maximum value is 1416905. For all other cards, the maximum value is 943396. For the 1pOC12SmLrAtm and 1pOC48SmSrAtm cards, this attribute does not apply since per-VC queueing is not available. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
mscAtmIfCARtVbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVP and SVC rt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs are released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCARtVbrSvcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrSvcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCARtVbrSvcHoldingPriority.setDescription('This attribute specifies the default holding priority which applies to SVC rt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute has been obsoleted and its value migrated to holdingPriority attribute.')
mscAtmIfCARtVbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC rt-VBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCARtVbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 82), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. For the 1pOC48SmSrAtm card, only the default value is supported. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards the default value is 2. This attribute specifies the emission priority (EP) which is used to transmit traffic of the rt-VBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCARtVbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 86), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the rt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any rt-VBR connections. On 1pOC12SmLrAtm cards, this attribute must be set to disabled. For CQC-based ATM cards, this attribute may be set to enabled only if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl Cqc Override component. If that component does not exist, this attribute must be set to disabled. If the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to card type and the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, inverseUpc shaping is not available. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. On CQC-based ATM FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, linear traffic shaping is enabled. On ATM IP FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse- UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCARtVbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 87), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('minimumCdv')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the rt-VBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from another connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities.')
mscAtmIfCARtVbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 88), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the rt-VBR service category. This attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue for this service category. The common queue has one set of congestion control levels for all cells enqueued on it. For 1pOC12SmLrAtm and 1pOC48SmSrAtm cards this attribute must be set to common or autoConfigure. This attribute cannot be set to perVc since per-Vc queueing is not available on the 1pOC12SmLrAtm and 1pOC48SmSrAtm cards. The value autoConfigure is interpreted to mean common queueing. For ATM IP cards, if traffic shaping for this service category is disabled, this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For ATM IP cards, if traffic shaping for this service category is not disabled, the only permitted values are perVc and autoConfigure. In this case, the result is that all connections use per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component permits shaping for this interface, then this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards only perVc queueing is supported. All other attribute values are ignored. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component does not permit shaping for this interface, then this attribute may take values common or autoConfigure. In this case, the value autoConfigure is interpreted to mean common queueing. If this attribute is set to autoConfigure, an override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The opUnshapedTransmitQueueing attribute of this component indicates whether the transmit queueing is perVc or common. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCARtVbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the rt-VBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enforced for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all rt-VBR connections. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCARtVbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scr", 1), ("pcr", 2), ("ecr", 3))).clone('ecr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrWeightPolicy.setDescription('This attribute specifies the policy which is applied when calculating the fairness weight for unshaped connections of the rt-VBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the rt-VBR service category. This attribute is ignored on CQC-based ATM cards and the 1pOC48SmSrAtm card. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. If this attribute is set to scr, the fairness weight is proportional to the transmit sustained cell rate (SCR) of a connection. Connections with a higher SCR have a higher fairness weight. For connections with txTrafficDescType 3, which have no SCR, the sustained cell rate is assumed to be equal to the peak cell rate. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCARtVbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 100, 1, 91), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCARtVbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all rt-VBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is not supported by 4pOC12SmIrAtm and 4pOC12SmLrAtm cards. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This attribute never applies to any type of Vpt.')
mscAtmIfCARtVbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 110), )
if mibBuilder.loadTexts: mscAtmIfCARtVbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrOperTable.setDescription('This group contains operational attributes for the rt-VBR service category.')
mscAtmIfCARtVbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCARtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCARtVbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrOperEntry.setDescription('An entry in the mscAtmIfCARtVbrOperTable.')
mscAtmIfCARtVbrOpUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCARtVbrOpUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrOpUnshapedTransmitQueueing.setDescription('This attribute indicates the state of transmit queueing for unshaped rt-VBR connections. A value of perVc indicates that any unshaped connections use per- VC queueing. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the EP for this service category.')
mscAtmIfCARtVbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 3, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCARtVbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCARtVbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
mscAtmIfCANrtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4))
mscAtmIfCANrtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfCANrtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfCANrtVbr components.')
mscAtmIfCANrtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCANrtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCANrtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfCANrtVbr component.')
mscAtmIfCANrtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfCANrtVbr components. These components can be added.')
mscAtmIfCANrtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfCANrtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfCANrtVbr tables.')
mscAtmIfCANrtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfCANrtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrIndex.setDescription('This variable represents the index for the mscAtmIfCANrtVbr tables.')
mscAtmIfCANrtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100), )
if mibBuilder.loadTexts: mscAtmIfCANrtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrProvTable.setDescription('This group contains provisioned attributes which control the nrt- VBR service category for this interface.')
mscAtmIfCANrtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCANrtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCANrtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrProvEntry.setDescription('An entry in the mscAtmIfCANrtVbrProvTable.')
mscAtmIfCANrtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the non-real-time variable bit rate (nrt-VBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to nrt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfCANrtVbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the nrt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
mscAtmIfCANrtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for nrt- VBR traffic except for connections managed by a Vpt CA. The number is the negative logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then NrtVbr cellLossRatio = 10. This number must be greater than or equal to RtVbr cellLossRatio since rt-VBR traffic has a higher discard priority. The NrtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for nrt-VBR connections. There is a trade-off between the service category CLR and the achievable link utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E-10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower link utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case no bandwidth is reserved for nrt-VBR connections, and CAC is effectively turned off. All nrt-VBR connections are admitted.')
mscAtmIfCANrtVbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrTxQueueLimit.setDescription('This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the nrt-VBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75, and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2, and DP=1 respectively. For per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75, and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2, and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 1792 for low speed cards such as DS1, E1, and IMA, set to 2304 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 10240 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. For the 1pOC12SmLrAtm card, if autoConfigure is selected for this attribute then the value is set to 7680. For the 1pOC48SmSrAtm card, if autoConfigure is selected for this attribute the the value is set to 122880. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. For the 1pOC48SmSrAtm card, the value of this attribute is used to set the maximum size of the link-class queue for buffering the nrt- VBR traffic on the egress path. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components, and the valid range is from 5 to 30000 inclusive. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. When using per-VC queueing, this attribute is used as the default txQueueLimit for all standard Vpts, regardless of their atmServiceCategory. VALUES ( 0 = autoConfigure )')
mscAtmIfCANrtVbrSvcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrSvcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrSvcHoldingPriority.setDescription('This attribute specifies the default holding priority which applies to SVC nrt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute has been obsoleted and its value migrated to holdingPriority attribute.')
mscAtmIfCANrtVbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 160000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the nrt-VBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. This attribute does not apply for the 1pOC12SmLrAtm and 1pOC48SmSrAtm cards, since per-VC queueing is not available. This attribute is used as the default minPerVcQueueLimit for all standard Vpts, regardless of their atmServiceCategory. This attribute does not apply to basic Vpts.')
mscAtmIfCANrtVbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1416905), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the nrt-VBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1 and IMA, set to 14740 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 65511 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, the reference rate is set to 65511 for DS3 and OC3 channels, and set to 262044 for OC12 channels. For Apc-based cards the maximum value is 1416905. For all other cards, the maximum value is 943396. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For the 1pOC12SmLrAtm and 1pOC48SmSrAtm cards, this attribute does not apply since per-VC queueing is not available. This attribute is used as the default perVcQueueLimitReferenceRate for all standard Vpts, regardless of their atmServiceCategory. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )')
mscAtmIfCANrtVbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC nrt-VBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCANrtVbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrHoldingPriority.setDescription("This attribute specifies the holding priority which applies to SVP and SVC nrt-VBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCANrtVbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. For the 1pOC48SmSrAtm card, only the default value is supported. This attribute specifies the emission priority (EP) which is used to transmit traffic of the nrt-VBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCANrtVbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the nrt-VBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any nrt-VBR connections. On 1pOC12SmLrAtm and 1pOC48SmSrAtm cards, this attribute must be set to disabled. For CQC-based ATM cards, this attribute may be set to enabled only if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl Cqc Override component. If that component does not exist, this attribute must be set to disabled. If the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to card type and the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, inverseUpc shaping is not available. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. On CQC-based ATM FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, linear traffic shaping is enabled. On ATM IP FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse- UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCANrtVbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('maximumEfficiency')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the nrt-VBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from the other connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain any delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCANrtVbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the nrt-VBR service category. This attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue. The common queue has one set of congestion control levels for all cells enqueued on it. For ATM IP cards, there is one common queue for the nrt-VBR service category. For CQC-based ATM cards, there is one common queue which is shared by the nrt-VBR, ABR and UBR service categories. For ATM IP cards, if traffic shaping for this service category is disabled, this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For 1pOC12SmLrAtm and 1pOC48SmSrAtm cards this attribute must be set to common or autoConfigure. This attribute cannot be set to perVc since per-Vc queueing is not available on the 1pOC12SmLrAtm and 1pOC48SmSrAtm cards. The value autoConfigure is interpreted to mean common queueing. For ATM IP cards, if traffic shaping for this service category is not disabled, the only permitted values are perVc and autoConfigure. In this case, the result is that all connections use per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component permits shaping for this interface, then this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards only perVc queueing is supported. All other attribute values are ignored. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component does not permit shaping for this interface, then this attribute may take the values common or autoConfigure. In this case, the value autoConfigure is interpreted to mean common queueing. If this attribute is set to autoConfigure, an override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The opUnshapedTransmitQueueing attribute of this component indicates whether the transmit queueing is perVc or common. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCANrtVbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the nrt-VBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enabled for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. For the 1pOC48SmSrAtm card, the value of this attribute must be set to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all nrt-VBR connections. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCANrtVbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("scr", 1), ("pcr", 2), ("ecr", 3))).clone('ecr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrWeightPolicy.setDescription('This attribute specifies the policy which is applied when calculating the fairness weight for unshaped connections of the nrt-VBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the nrt-VBR service category. This attribute is ignored on CQC-based ATM cards. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. This attribute is also ignored for 1pOC48SmSrAtm cards. If this attribute is set to scr, the fairness weight is proportional to the transmit sustained cell rate (SCR) of a connection. Connections with a higher SCR have a higher fairness weight. For connections with txTrafficDescType 3, which have no SCR, the sustained cell rate is assumed to be equal to the peak cell rate. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCANrtVbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 100, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all nrt-VBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is not supported by 4pOC12SmIrAtm and 4pOC12SmLrAtm cards. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This attribute never applies to any type of Vpt.')
mscAtmIfCANrtVbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 110), )
if mibBuilder.loadTexts: mscAtmIfCANrtVbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrOperTable.setDescription('This group contains operational attributes for the nrt-VBR service category.')
mscAtmIfCANrtVbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCANrtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCANrtVbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrOperEntry.setDescription('An entry in the mscAtmIfCANrtVbrOperTable.')
mscAtmIfCANrtVbrOpUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrOpUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrOpUnshapedTransmitQueueing.setDescription('This attribute indicates the state of transmit queueing for unshaped nrt-VBR connections. A value of perVc indicates that any unshaped connections use per- VC queueing. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the EP for this service category.')
mscAtmIfCANrtVbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 4, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCANrtVbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCANrtVbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
mscAtmIfCAAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5))
mscAtmIfCAAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 1), )
if mibBuilder.loadTexts: mscAtmIfCAAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfCAAbr components.')
mscAtmIfCAAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCAAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfCAAbr component.')
mscAtmIfCAAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfCAAbr components. These components can be added.')
mscAtmIfCAAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfCAAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfCAAbr tables.')
mscAtmIfCAAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfCAAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrIndex.setDescription('This variable represents the index for the mscAtmIfCAAbr tables.')
mscAtmIfCAAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100), )
if mibBuilder.loadTexts: mscAtmIfCAAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrProvTable.setDescription('This group contains provisioned attributes which control the ABR service category for this interface.')
mscAtmIfCAAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCAAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrProvEntry.setDescription('An entry in the mscAtmIfCAAbrProvTable.')
mscAtmIfCAAbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the available bit rate (ABR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to ABR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfCAAbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrCdvt.setDescription('This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the ABR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component, or signalled in the SVC Traffic Descriptor Information Element. This attribute is used by dynamic generic cell rate algorithm (DGCRA) policer on ATM IP cards. On CQC-based ATM cards ABR UPC is enforced using PCR and CDVT.')
mscAtmIfCAAbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 12), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 63488), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the ABR service category. It is used as the basis for setting the discard thresholds on ABR per-VC queues. For per-VC queue, the actual limit may be reduced depending on the peak cell rate. The discard thresholds are set at approximately 35, 75 and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 1792 for low speed cards such as DS1, E1 and IMA, set to 2304 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 10240 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. For the 1pOC12SmLrAtm card, the value is set to 6144. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components, and the valid range is from 5 to 30000 inclusive. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )")
mscAtmIfCAAbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 30000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the ABR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the peak cell rate of that queue. This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For the 1pOC12SmLrAtm card, this attribute does not apply since per-VC queueing is not available. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
mscAtmIfCAAbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 943396), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the ABR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1 and IMA, set to 14740 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 65511 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For the 1pOC12SmLrAtm card, this attribute does not apply since per-VC queueing is not available. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
mscAtmIfCAAbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the ABR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCAAbrFairnessPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 4))).clone(namedValues=NamedValues(("mcr", 0), ("pcr", 2), ("pcrMinusMcr", 4))).clone('pcrMinusMcr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrFairnessPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrFairnessPolicy.setDescription('This attribute specifies the fairness policy which is applied to available bandwidth when performing the ER calculation in the ABR service category. This applies to any connection point performing explicit rate calculations. Each ABR connection is assigned a weight. Connections with a higher weight get a greater proportion of the available ABR bandwidth compared with connections that have lower weights. This attribute is ignored on CQC-based ATM cards. If the value is mcr, the congestion fairness weight is based on the Minimum Cell Rate (MCR) of the connection. If the value is pcr, the congestion fairness weight is based on the Peak Cell Rate (PCR) of the connection. If the value is pcrMinusMcr, the congestion fairness weight is based on the difference between the Peak Cell Rate and the Minimum Cell Rate (PCR - MCR) of the connection.')
mscAtmIfCAAbrFrttPortion = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrFrttPortion.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrFrttPortion.setDescription('This attribute specifies the portion of the Fixed Round Trip Time (FRTT) which is added to each ABR call setup which traverses this interface. The FRTT for the entire call is the sum of the FRTT portions for each interface traversed by the call. FRTT is used by the ABR Source or Virtual Source to adjust the value of ICR according to the rules specified in the ATM Forum TM Version 4.0 specification. The frttPortion includes propagation delay through the physical media, plus delays included by the transmission system, plus fixed components of switch processing delay. This attribute is used by ATM Networking at call set-up time for ABR connections directed over this interface.')
mscAtmIfCAAbrAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 5))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("nonAbrInterworking", 5))).clone('abrSwitch')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrAbrConnectionType.setDescription('This attribute specifies the default type for ABR connections. It may be overridden by the abrConnectionType attribute under the Vcd Tm or Vpd Tm component, or by other configuration options. For example, for ABR end point connections originating at this switch, the Vcc Tm abrConnectionType will show sourceDest regardless of the setting of this attribute. If this attribute is set to abrSwitch, traversing ABR connections default to type abrSwitchEr or abrSwitchEfci, depending on the card type. If the interface to which traffic is directed across the backplane is configured as type virtualSourceDest and this is a ATM IP FP, then connection points under this AtmIf are activated as type virtualSourceDest. If this attribute is set to virtualSourceDest, traversing ABR connections may be instantiated as one of the following types: abrSwitchEr, abrSwitchEfci, or virtualSourceDest. A Virtual Source-Virtual Destination (VS/VD) boundary forms a break in the end to end flow of RM cells as defined in the ATM Forum Specification for Traffic Management Version 4.0. On ATM IP cards, a VS/VD boundary can be configured for a connection providing all of the following conditions are met: 1. the ABR connection is traversing (not terminating at) this interface; 2. both this interface and next hop interface to which traffic is directed across the backplane are located on ATM IP cards; 3. one or both connecting points are configured as virtualSourceDest, 4. the next hop interface to which traffic is directed across the backplane is not configured as nonAbrInterworking. If this attribute is set to nonAbrInterworking, this interface is defined as a point of interworking between an ABR and a non-ABR connection. In this case the next hop interface to which traffic is directed across the backplane is activated as type sourceDest. The Vcc Tm or Vpc Tm abrConnectionType operational attribute indicates what type of ABR connection was activated.')
mscAtmIfCAAbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the ABR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. For ATM IP cards, if this attribute is set to enforced, UPC for ABR connection is enforced as a Dynamic Generic Cell Rate Algorithm (DGCRA) based on the connection traffic descriptor. For CQC-based ATM cards, if this attribute is set to enforced, the connection enforces a single GCRA policer at the defined PCR and CDVT for this connection. When UPC is enforced on an ABR connection, non-conforming cells are discarded. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all ABR connections. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCAAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 23), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777218)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrInitialCellRate.setDescription('This attribute specifies the default Initial Cell Rate (ICR) parameter for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Setup Parameters Information Element. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. When this attribute is set to some explicit number, that number is used as the ICR, provided it is between MCR and PCR. If the explicit number is below MCR, then MCR is used as ICR. If the explicit number is above PCR, then PCR is used as ICR. VALUES ( 16777217 = useMcr 16777218 = usePcr )')
mscAtmIfCAAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrRateDecreaseFactor.setDescription('This attribute specifies the default Rate Decrease Factor (RDF) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Setup Parameters Information Element. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (B- RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR.')
mscAtmIfCAAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrRateIncreaseFactor.setDescription('This attribute specifies the default Rate Increase Factor (RIF) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Setup Parameters Information Element. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (B-RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR.')
mscAtmIfCAAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 26), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), )).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrMaxCellPerRmCell.setDescription('This attribute specifies the default number of user cells per Resource Management cell (NRM) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled as the NRM parameter in the ABR Additional Parameters Information Element. NRM is the maximum number of cells an ABR source may transmit for each forward Resource Management (F-RM) cell. The count of the cells transmitted includes user cells, OAM cells, backward RM cells, and the forward RM cell. Note that a value of 2 is not recommended even though it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the Vcc Tm or Vpc Tm operational attribute abrConnectionType indicates explicitRateMarking.')
mscAtmIfCAAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 27), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), )).clone(100000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrMaxTimeBetweenRmCell.setDescription('This attribute specifies the default time between Resource Management cells (TRM) for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Additional Parameters Information Element. TRM provides an upper bound on the time interval between forward Resource Management (F-RM) cells for an ABR source. Since the last F-RM cell was sent, if at least TRM time has elapsed and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the Vcc Tm or Vcd Tm operational attribute abrConnectionType is displayed as explicitRateMarking. The provisioned value of 781 is signalled in the ABR Additional Parameters Information Element as 0. 1563 is signalled as 1. 3125 is signalled as 2. 6250 is signalled as 3. 12500 is signalled as 4. 25000 is signalled as 5. 50000 is signalled as 6. 100000 is signalled as 7.')
mscAtmIfCAAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 28), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), )).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrCutoffDecreaseFactor.setDescription('This attribute specifies the default Cutoff Decrease Factor (CDF) parameter for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Additional Parameters Information Element. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter. CRM is the limit of the number of forward Resource Management (F-RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the MCR, in which case the ACR is set to MCR.')
mscAtmIfCAAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the default Allowed Cell Rate Decrease Time Factor (ADTF) parameter for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component, or signalled in the ABR Additional Parameters Information Element. ADTF is the time interval permitted between sending forward Resource Management (F-RM) cells before the Allowed Cell Rate (ACR) is decreased to the Initial Cell Rate (ICR). In other words, if the source does not transmit a forward RM cell for a period of ADTF centi-seconds (hundredths of a second), it will reduce its ACR to the value of its ICR. If ACR is already at or below ICR, further rate reductions are defined by the CRM ABR parameter.')
mscAtmIfCAAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16700000)).clone(10000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrDgcraMaximumDelay.setDescription('This attribute specifies the default maximum delay for Dynamic General Cell Rate Algorithm (DGCRA) rate changes for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component. This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (B-RM) cell departing from this interface (in the backward direction) is expected to be observed at the interface (in the forward connection). This upper bound may be approximated as the round trip sum of the fixed and propagation delays and the maximum queueing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the DGCRA. A larger value for this attribute implies a more lenient policer. When there is a decrease in the Allowed Cell Rate (ACR), the policer waits a correspondingly longer period of time before it enforces the new cell rate. The value of this attribute must be greater than or equal to dgcraMinimumDelay, since the maximum delay must be greater than or equal to the minimum delay.')
mscAtmIfCAAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 31), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16700000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrDgcraMinimumDelay.setDescription('This attribute specifies the default minimum delay for Dynamic General Cell Rate Algorithm (DGCRA) rate changes for ABR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm Abr or Vpd Tm Abr component. This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (B-RM) cell departing from this interface (in the backward direction) is expected to be observed at the interface (in the forward connection). This lower bound may be approximated as the round trip sum of the fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the DGCRA. A smaller value for this attribute implies a more lenient policer. When there is an increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces the new cell rate. The value of this attribute must be less than or equal to dgcraMaximumDelay, since the maximum delay must be greater than or equal to the minimum delay.')
mscAtmIfCAAbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 100, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAAbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVP and SVC ABR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCAAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 110), )
if mibBuilder.loadTexts: mscAtmIfCAAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrOperTable.setDescription('This group contains operational attributes for the ABR service category.')
mscAtmIfCAAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCAAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrOperEntry.setDescription('An entry in the mscAtmIfCAAbrOperTable.')
mscAtmIfCAAbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 5, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAAbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAAbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
mscAtmIfCAUbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6))
mscAtmIfCAUbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 1), )
if mibBuilder.loadTexts: mscAtmIfCAUbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfCAUbr components.')
mscAtmIfCAUbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAUbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCAUbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfCAUbr component.')
mscAtmIfCAUbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfCAUbr components. These components can be added.')
mscAtmIfCAUbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfCAUbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfCAUbr tables.')
mscAtmIfCAUbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfCAUbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrIndex.setDescription('This variable represents the index for the mscAtmIfCAUbr tables.')
mscAtmIfCAUbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100), )
if mibBuilder.loadTexts: mscAtmIfCAUbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrProvTable.setDescription('This group contains provisioned attributes for the UBR service category.')
mscAtmIfCAUbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAUbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCAUbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrProvEntry.setDescription('An entry in the mscAtmIfCAUbrProvTable.')
mscAtmIfCAUbrMaxVpcs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4096), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxVpcs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxVpcs.setDescription('This attribute specifies the maximum number of UBR Vpcs that can be activated on this AtmIf. The value must not exceed the maxVpcs attribute of the parent CA component. If this attribute is specified as sameAsCa, the maximum number of Vpcs is defined by the AtmIf/n CA maxVpcs attribute. Changes to this attribute do not affect existing Vpcs. If the value is changed to a number smaller than the current number of active UBR VPCs, no new UBR VPCs are admitted until the number of active UBR VPCs drops below the value of this attribute. The current number of active UBR VPCs is indicated by the Ubr/0 vpcUsage operational attribute. VALUES ( 16385 = sameAsCa )')
mscAtmIfCAUbrMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16384), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxVccs.setDescription('This attribute specifies the maximum number of UBR Vccs that can be activated on this AtmIf, including UBR Vpt Vccs. The value must not exceed the maxVccs attribute of the parent CA component. If this attribute is specified as sameAsCa, the maximum number of Vccs is defined by the AtmIf/n CA maxVccs attribute. Changes to this attribute do not affect existing Vccs. If the value is changed to a number smaller than the current number of active UBR VCCs, no new UBR VCCs are admitted until the number of active UBR VCCs drops below the value of this attribute. The current number of active UBR VCCs is indicated by the Ubr/0 vccUsage operational attribute. VALUES ( 16385 = sameAsCa )')
mscAtmIfCAUbrMaxVpts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4096), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxVpts.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrMaxVpts.setDescription('This attribute specifies the maximum number of UBR Vpts that can be activated on this AtmIf. The value must not exceed the maxVpts attribute of the parent CA component. If this attribute is specified as sameAsCa, the maximum number of Vpts is defined by the AtmIf/n CA maxVpts attribute. Changes to this attribute do not affect existing Vpts. If the value is changed to a number smaller than the current number of active UBR VPTs, no new UBR VPTs are admitted until the number of active UBR VPTs drops below the value of this attribute. The current number of active UBR VPTs is indicated by the Ubr/0 vptUsage operational attribute. VALUES ( 16385 = sameAsCa )')
mscAtmIfCAUbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the unspecified bit rate (UBR) service category except for connections managed by a Vpt CA. The percentage of link capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to UBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA. The amount of bandwidth reserved for each UBR connection is specified in the minimumCellRate attribute.')
mscAtmIfCAUbrMinimumCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrMinimumCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrMinimumCellRate.setDescription('This attribute specifies the minimum cell rate (MCR) which is allocated from the UBR bandwidth pool for each UBR connection which is admitted using Connection Admission Control (CAC) except for connections managed by a Vpt CA. UBR connections normally are serviced on a best effort basis, but this attribute allows allocation of a default minimum bandwidth for each connection.')
mscAtmIfCAUbrTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 12), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrTxQueueLimit.setDescription("This attribute specifies the default maximum queue length for the emission queues used to buffer the traffic of the UBR service category. It is used as the basis for setting the discard thresholds on both common and per-VC queues. For the common queue, the discard thresholds are set at approximately 35, 75 and 90 percent of the value of this attribute for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. For per-VC queue, the actual limit may be reduced depending on the shaping rate of the connection (for standard Vpt Vccs, this is the shaping rate of the Vpt). The discard thresholds are set at approximately 35, 75 and 90 percent of the scaled queue limit for traffic at discard priority 3 (DP=3), DP=2 and DP=1 respectively. However, a reduction will never result in a value that is less than the value set for the minPerVcQueueLimit attribute. When the value of this attribute is autoConfigure, an appropriate value is selected based on the card type. It is set to 1792 for low speed cards such as DS1, E1 and IMA, set to 2304 for high speed CQC-based ATM cards such as JT2, DS3, E3 and OC3, and set to 10240 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. For the 1pOC12SmLrAtm card, the value is set to 4096. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components, and the valid range is from 5 to 30000 inclusive. For ATM IP FPs, the per-VC queue limit may be overridden for a permanent connection by specifying a value in the Vcd Tm or Vpd Tm txQueueLimit attribute. The operational value of the maximum length of a queue (common or per-VC) is indicated by the Vcc Tm, Vpc Tm, or Vpt Tm txQueueThresholds attribute. For standard Vpts, this attribute does not apply when using per-VC queuing and only applies when using common queueing. When using per-VC queueing, regardless of the Vpt's service category, standard Vpts use the AtmIf Ca NrtVbr txQueueLimit value as their default. This attribute does not apply to basic Vpts. VALUES ( 0 = autoConfigure )")
mscAtmIfCAUbrMinPerVcQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 30000)).clone(88)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrMinPerVcQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrMinPerVcQueueLimit.setDescription('This attribute specifies the minimum queue limit for the per-VC queues of connections of the UBR service category. The queue limit of a per-VC queue is obtained by scaling down the txQueueLimit based on the shaping rate of that queue (shaping rate for the connection, and for standard Vpt Vccs, the shaping rate of the Vpt). This produces a constant delay for various queue lengths. The txQueueLimit provides an upper bound while minPerVcQueueLimit provides the lower bound. The value of this attribute must not be greater than the value of the txQueueLimit attribute. If this service category is used by Trunks the value of minPerVcQueueLimit must be at least 88. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For the 1pOC12SmLrAtm card, this attribute does not apply since per-VC queueing is not available. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr minPerVcQueueLimit value as their default. To determine the queue limit of a standard Vpt Vcc, the txQueueLimit is scaled down by the Vpt shaping rate.')
mscAtmIfCAUbrPerVcQueueLimitReferenceRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1416905), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrPerVcQueueLimitReferenceRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrPerVcQueueLimitReferenceRate.setDescription('This attribute specifies the shaping rate to be used in computing the tolerable delay for per-VC queues of connections of the UBR service category. The delay is computed as the txQueueLimit divided by the value of this attribute. When the value of this attribute is autoConfigure, an appropriate default is selected based on the card type. It is set to 3685 for low speed cards such as DS1, E1 and IMA, set to 14740 for high speed cards such as JT2, DS3, E3 and OC3, and set to 65511 for high speed ATM IP cards such as 3pDS3Atm2, 3pE3Atm2, 2pOC3SmAtm2 and 2pOC3MmAtm2. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, the reference rate is set to 65511 for DS3 and OC3 channels, and set to 262044 for OC12 channels. For Apc- based cards the maximum value is 1416905. For all other cards, the maximum value is 943396. On CQC-based ATM cards, this attribute must be set to the same value for CA NrtVbr, Abr and Ubr components. For the 1pOC12SmLrAtm card, this attribute does not apply since per-VC queueing is not available. For Vpts, this attribute does not apply. Regardless of Vpt service category, standard Vpts always use the AtmIf Ca NrtVbr perVcQueueLimitReferenceRate value as their default. VALUES ( 0 = autoConfigure )')
mscAtmIfCAUbrEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrEmissionPriority.setDescription('This attribute is not applicable and is ignored for CQC-based ATM cards. This attribute specifies the emission priority (EP) which is used to transmit traffic of the UBR service category. A lower numerical value for this attribute specifies a higher emission priority. 0 is the highest EP and 7 is the lowest. Cells at a higher emission priority receive higher preference for link bandwidth. EPs 0 and 1 are in the absolute priority range, and are unaffected by any minimum bandwidth guarantees. EPs 2 through 7 are in the guaranteed bandwidth range. Minimum bandwidth guarantee is specified in the AtmIf/n Ep/m component. Emission priority setting must comply with all of the following constraints: 1. The emission priority numbers must be in the following order: CBR <= rt-VBR <= nrt-VBR <= ABR <= UBR 2. Two different ATM service categories may share the same EP only if they are both shaped. 3. CBR and rt-VBR may be placed either in the absolute priority range (EP 0 or 1) or in the guaranteed bandwidth range (EP 2 through 7). 4. If both CBR and rt-VBR are shaped, rt-VBR must share the same EP with CBR or ABR. If either one of CBR or rt-VBR are not shaped, then they cannot share the same EP. 5. ABR service category is always deemed to be shaped. If nrt-VBR is shaped, it must share the same EP with ABR. If nrt-VBR is not shaped it must have a higher EP than ABR. 6. If UBR is shaped, it must share the same EP with ABR. If UBR is not shaped, it must have a lower EP than ABR. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCAUbrTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 5), ("inverseUpc", 6))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrTrafficShaping.setDescription('This attribute specifies the default traffic shaping option for connections of the UBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to disabled, traffic shaping cannot be enabled for any UBR connection. On 1pOC12SmLrAtm cards, this attribute must be set to disabled. For CQC-based ATM cards, this attribute may be set to enabled only if the interface supports shaping, as defined by the perVcQueueInterfaces attribute in the AtmResourceControl Cqc Override component. If that component does not exist, this attribute must be set to disabled. If the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType indicates type 1 or 2, this attribute is ignored, and traffic shaping is not applicable for that connection. When this attribute is set to inverseUpc, traffic shaping for a connection is enabled according to card type and the value of the Vcc Tm, Vpc Tm, or Vpt Tm txTrafficDescType. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards, inverseUpc shaping is not available. If this attribute is set to inverseUpc, and the txTrafficDescType is 3, 4, or 5, linear traffic shaping is enabled. Linear traffic shaping uses a single static traffic shaping rate. On CQC-based ATM FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, linear traffic shaping is enabled. On ATM IP FPs, if this attribute is set to inverseUpc, and the txTrafficDescType is 6, 7, or 8, inverse-UPC (also referred to as VBR or dual leaky bucket) traffic shaping is enabled. Inverse-UPC traffic shaping can burst above the sustained cell rate to the peak cell rate for the duration defined by maximum burst size. Inverse- UPC traffic shaping exactly conforms to the requirements of a dual leaky bucket UPC enforcer. When this attribute is set to enabled and the txTrafficDescType is 3, 4, 5, 6, 7, or 8, traffic shaping for a connection is enabled using linear shaping. Enabling or disabling traffic shaping may require a matching change to the emissionPriority attribute and unshapedTransmitQueueing attribute for this service category. Refer to those attributes for the complete description of the interactions. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCAUbrShapeRecoupPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("minimumCdv", 0), ("maximumEfficiency", 1))).clone('maximumEfficiency')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrShapeRecoupPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrShapeRecoupPolicy.setDescription('This attribute specifies the shaping recoup policy for the UBR service category. This is the policy which is used to recoup shaping opportunities which are lost when more than one connection schedules a cell for the same transmit opportunity. In this case, one connection is scheduled, and the cell from the other connection is delayed by one cell time. This attribute affects how the transmit time is calculated for the next cell on the delayed connection. This attribute is ignored if this service category is not shaped. When the connection which was delayed schedules the next cell to transmit, it may calculate the time as a difference from either the previous actual cell transmit time, or the time when the previous cell should have been transmitted. Setting this attribute to maximumEfficiency results in each connection trying to recoup or regain any delays in scheduling. The transmit time from the next cell is calculated from the time when the cell should originally have been sent. Cell delay variation (CDV) occurs in this case since the cells are sent with less than the shaping delay between them. However, in general the shaper recovers (recoups) lost opportunities and improves efficiency. Setting this attribute to minimumCdv results in connections not trying to recoup or regain any delays in scheduling. The transmit time for the next cell is calculated from the time when the previous cell was actually transmitted. This minimizes CDV, but results in missed cell opportunities. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCAUbrUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("autoConfigure", 2))).clone('autoConfigure')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrUnshapedTransmitQueueing.setDescription('This attribute specifies the default queuing option for unshaped connections of the UBR service category. This attribute controls whether common or per-VC queueing is used. Per-VC queueing means that each connection has its own buffering and queue limits. Common queueing means that cells are queued in First In First Out order on a common queue. The common queue has one set of congestion control levels for all cells enqueued on it. For ATM IP cards, there is one common queue for the UBR service category. For CQC-based ATM cards, there is one common queue which is shared by the nrt-VBR, ABR and UBR service categories. For 1pOC12SmLrAtm cards this attribute must be set to common or autoConfigure. This attribute cannot be set to perVc since per-Vc queueing is not available on the 1pOC12SmLrAtm card. The value autoConfigure is interpreted to mean common queueing. For ATM IP cards, if traffic shaping for this service category is disabled, this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For ATM IP cards, if traffic shaping for this service category is not disabled, the only permitted values are perVc and autoConfigure. In this case, the result is that all connections use per-VC queueing. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component permits shaping for this interface, then this attribute may take any of the three values. In this case, the value autoConfigure is interpreted to mean per-VC queueing. For 4pOC12SmIrAtm and 4pOC12SmLrAtm cards only perVc queueing is supported. All other attribute values are ignored. For CQC-based ATM cards, if the perVcQueueInterfaces attribute of the Lp Eng Arc Cqc component does not permit shaping for this interface, then this attribute may take the values common or autoConfigure. In this case, the value autoConfigure is interpreted to mean common queueing. If this attribute is set to autoConfigure, an override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The opUnshapedTransmitQueueing attribute of this component indicates whether the transmit queueing is perVc or common. This attribute does not apply to basic Vpts, andstandard Vpt Vccs.')
mscAtmIfCAUbrUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("monitored", 4))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrUsageParameterControl.setDescription('This attribute specifies the default usage parameter control (UPC) option for connections of the UBR service category. This attribute is ignored if the rxTrafficDescriptorType indicates 1 or 2. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. When this attribute is set to enforced, UPC is enforced for each connection. When UPC is enforced, non-conforming cells are either tagged or discarded depending on the rxTrafficDescriptorType. On ATM IP FPs, when this attribute is set to monitored, UPC conformance checking is performed, except, instead of the non- conforming cells being tagged or discarded, they are merely counted in the UPC violations counts, and passed on unchanged. On CQC-based ATM FPs, when this attribute is set to monitored, it has the same effect as setting it to disabled. When this attribute is set to disabled, UPC is disabled on the receive path for all UBR connections. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCAUbrWeightPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("mcr", 0), ("pcr", 2), ("ecr", 3))).clone('pcr')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrWeightPolicy.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrWeightPolicy.setDescription('This attribute specifies the policy which is applied when calculating the fairness weight for unshaped connections of the UBR service category. The fairness weight for a connection determines the relative amount of bandwidth which that connection obtains, compared to other connections in the same service category. Connections with equal weight get equal transmit opportunities. Connections with higher weights get more transmit opportunities compared with connections that have lower weights. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. The fairness weight for a connection is directly proportional to the value of one of the traffic descriptor parameters for that connection. This attribute specifies which traffic descriptor parameter is used for connections of the UBR service category. This attribute is ignored on CQC-based ATM cards. This attribute is also ignored on ATM IP cards if unshapedTransmitQueueing is set for common queuing. If this attribute is set to mcr, the fairness weight is proportional to the default minimum cell rate (MCR) for UBR connections. If the default minimum cell rate is 0, all UBR connections get a minimum weight, which is 1. If this attribute is set to pcr, the fairness weight is proportional to the transmit peak cell rate (PCR) of a connection. Connections with a higher PCR have a higher fairness weight. Connections with txTrafficDescType 1 or 2 get a minimum weight, which is 1. If this attribute is set to ecr, the fairness weight is proportional to the equivalent cell rate (ECR) of a connection as calculated by connection admission control (CAC). Connections with a higher ECR have a higher fairness weight. Connections with an ECR of 0 get a minimum weight, which is 1. The weight of a connection is visible in the Vcc Tm, Vpc Tm, or Vpt Tm weight attribute. This attribute does not apply to basic Vpts, and standard Vpt Vccs.')
mscAtmIfCAUbrForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrForceTagging.setDescription('This attribute specifies the default of whether to force tagging (CLP=1) of all cells for all UBR connections. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is not supported by 4pOC12SmIrAtm and 4pOC12SmLrAtm cards. When this attribute is set to enabled, CLP is set to 1 for all cells in the transmit direction. This is in conformance with the ATM Forum TM4.0 UBR.2 service definition. Force tagging is only supported on ATM IP FPs. On CQC-based ATM FPs, this attribute must be set to disabled. When this attribute is set to disabled, CLP is unchanged for all cells in the transmit direction. This is in conformance with the ATM Forum TM4.0 UBR.1 service definition. This attribute never applies to any type of Vpt.')
mscAtmIfCAUbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 1200000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for all connections of the UBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
mscAtmIfCAUbrHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVP and SVC UBR connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCAUbrSvcMpHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfCAUbrSvcMpHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrSvcMpHoldingPriority.setDescription("This attribute specifies the default holding priority which applies to SVC UBR point-to-multipoint connections. It takes a value from 0 (highest priority) to 4 (lowest priority). In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This attribute does not apply to Vpt Vccs. When bandwidth fluctuates, the entire Vpt, along with all Vpt Vccs is released as a unit, according to the Vpt's holdingPriority.")
mscAtmIfCAUbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 110), )
if mibBuilder.loadTexts: mscAtmIfCAUbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrOperTable.setDescription('This group contains operational attributes for the UBR service category.')
mscAtmIfCAUbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfCAUbrIndex"))
if mibBuilder.loadTexts: mscAtmIfCAUbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrOperEntry.setDescription('An entry in the mscAtmIfCAUbrOperTable.')
mscAtmIfCAUbrOpUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrOpUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrOpUnshapedTransmitQueueing.setDescription('This attribute indicates the state of transmit queueing for unshaped UBR connections. A value of perVc indicates that any unshaped connections use per- VC queueing. A value of common indicates that traffic for unshaped connections uses the common queue which corresponds to the EP for this service category.')
mscAtmIfCAUbrVpcUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrVpcUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrVpcUsage.setDescription('This attribute indicates the number of active UBR Vpcs under this interface. It includes switched and permanent connections.')
mscAtmIfCAUbrVccUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrVccUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrVccUsage.setDescription('This attribute indicates the number of active UBR Vccs under this interface. It includes switched and permanent connections, and Vpt Vccs.')
mscAtmIfCAUbrVptUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrVptUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrVptUsage.setDescription('This attribute indicates the number of active UBR Vpts under this interface.')
mscAtmIfCAUbrEpdOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 3, 6, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 1024), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfCAUbrEpdOffset.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfCAUbrEpdOffset.setDescription('This attribute indicates the Early Packet Discard (EPD) offset which is currently in use for this service category. The EPD offset is used to derive the EPD thresholds for each CC level. Any connection under this service category which requires the txPacketWiseDiscard feature must specify a transmit queue limit which is at least 5.71 times this offset. This ensures that the derived Epd threshold will never be less than 17.5 % of the transmit queue limit. If this is not done, txPacketWiseDiscard for the connection will be automatically disabled. The value of this EPD offset is specified under the lp/x eng arc aqm ov component.')
mscAtmIfVpc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4))
mscAtmIfVpcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpc components.')
mscAtmIfVpcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpc component.')
mscAtmIfVpcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpc components. These components can be added and deleted.')
mscAtmIfVpcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpc tables.')
mscAtmIfVpcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: mscAtmIfVpcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcIndex.setDescription('This variable represents the index for the mscAtmIfVpc tables.')
mscAtmIfVpcStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 100), )
if mibBuilder.loadTexts: mscAtmIfVpcStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscAtmIfVpcStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStateEntry.setDescription('An entry in the mscAtmIfVpcStateTable.')
mscAtmIfVpcAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVpcOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVpcUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVpcOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 110), )
if mibBuilder.loadTexts: mscAtmIfVpcOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
mscAtmIfVpcOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcOperEntry.setDescription('An entry in the mscAtmIfVpcOperTable.')
mscAtmIfVpcConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
mscAtmIfVpcConnInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 115), )
if mibBuilder.loadTexts: mscAtmIfVpcConnInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcConnInfoTable.setDescription('This group contains operational connection characteristics information for a Vcc component.')
mscAtmIfVpcConnInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 115, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcConnInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcConnInfoEntry.setDescription('An entry in the mscAtmIfVpcConnInfoTable.')
mscAtmIfVpcDistributionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 115, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipoint", 1))).clone('pointToPoint')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcDistributionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcDistributionType.setDescription('This attribute indicates the way data is distributed in the connection. A value of pointToPoint indicates this connection point is part of a point-to-point connection. A value of pointToMultipoint indicates this connection point is part of a point-to-multipoint connection.')
mscAtmIfVpcNumLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 115, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcNumLeaves.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcNumLeaves.setDescription('This attribute indicates the number of destination leaves of the connection. If the distributionType is pointToPoint the value of this attribute is 0.')
mscAtmIfVpcCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 115, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fromLink", 0), ("toLink", 1), ("notApplicable", 2))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcCallDirection.setDescription('This attribute indicates the direction of the call setup request for an SVC. A value of fromLink means that the call setup originated from the link. A value of toLink means that the call setup was directed to the link. For PVC connections, the value of this attribute is notApplicable. For SPVC connections, the value of this attribute is notApplicable for Vccs with the SourcePVC and DestinationPVC subcomponents. For Signalling channels, the value of this attribute is notApplicable.')
mscAtmIfVpcStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120), )
if mibBuilder.loadTexts: mscAtmIfVpcStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc or Vpt component.')
mscAtmIfVpcStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatusEntry.setDescription('An entry in the mscAtmIfVpcStatusTable.')
mscAtmIfVpcOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
mscAtmIfVpcLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
mscAtmIfVpcTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
mscAtmIfVpcSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVpcSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
mscAtmIfVpcEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVpcRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
mscAtmIfVpcAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcAisState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVpcRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVpcTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130), )
if mibBuilder.loadTexts: mscAtmIfVpcTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
mscAtmIfVpcTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTrafficEntry.setDescription('An entry in the mscAtmIfVpcTrafficTable.')
mscAtmIfVpcTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVpcTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
mscAtmIfVpcFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
mscAtmIfVpcTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
mscAtmIfVpcHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVpcRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVpcRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
mscAtmIfVpcBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVpcTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
mscAtmIfVpcBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVpcClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
mscAtmIfVpcBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
mscAtmIfVpcTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVpcRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVpcBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVpcBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVpcStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140), )
if mibBuilder.loadTexts: mscAtmIfVpcStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
mscAtmIfVpcStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsEntry.setDescription('An entry in the mscAtmIfVpcStatsTable.')
mscAtmIfVpcStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCell.setDescription('This attribute counts the number of cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCellClp.setDescription('This attribute counts the number of cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVpcStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVpcPerfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 150), )
if mibBuilder.loadTexts: mscAtmIfVpcPerfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPerfTable.setDescription('This group contains operational attributes which keep performance statistics about the behavior of the AtmIf component.')
mscAtmIfVpcPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 150, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcPerfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPerfEntry.setDescription('An entry in the mscAtmIfVpcPerfTable.')
mscAtmIfVpcLastMinimumCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 150, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcLastMinimumCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLastMinimumCtd.setDescription('This attribute indicates the minimum calculated cell transfer delay value for this connection from the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval if TODA is disabled. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the accountCollection attribute of the AtmIf Uni or AtmIf Iisp component has a non-empty reason. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVpcLastMaximumCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 150, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcLastMaximumCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLastMaximumCtd.setDescription('This attribute indicates the maximum calculated cell transfer delay value for this connection from the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval if TODA is disabled. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the accountCollection attribute of the AtmIf Uni or AtmIf Iisp component has a non-empty reason. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVpcLastAverageCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 150, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcLastAverageCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLastAverageCtd.setDescription('This attribute indicates the average of all calculated cell transfer delay values for this connection from the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval if TODA is disabled. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the accountCollection attribute of the AtmIf Uni or AtmIf Iisp component has a non-empty reason. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVpcCurrentCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 150, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcCurrentCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcCurrentCtd.setDescription('This attribute indicates the most recent cell transfer delay value calculated for this connection. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVpcLastCtdSampleSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 150, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcLastCtdSampleSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLastCtdSampleSize.setDescription('This attribute indicates the number of loopback cells sampled for cell transfer delay calculations during the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval of TODA is disabled.')
mscAtmIfVpcTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 294), )
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVpcTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 294, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpEntry.setDescription('An entry in the mscAtmIfVpcTxTdpTable.')
mscAtmIfVpcTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpIndex.setDescription('This variable represents the mscAtmIfVpcTxTdpTable specific index for the mscAtmIfVpcTxTdpTable.')
mscAtmIfVpcTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcTxTdpTable.')
mscAtmIfVpcRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 295), )
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVpcRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 295, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpEntry.setDescription('An entry in the mscAtmIfVpcRxTdpTable.')
mscAtmIfVpcRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpIndex.setDescription('This variable represents the mscAtmIfVpcRxTdpTable specific index for the mscAtmIfVpcRxTdpTable.')
mscAtmIfVpcRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcRxTdpTable.')
mscAtmIfVpcTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 352), )
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
mscAtmIfVpcTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 352, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshEntry.setDescription('An entry in the mscAtmIfVpcTxQThreshTable.')
mscAtmIfVpcTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshIndex.setDescription('This variable represents the mscAtmIfVpcTxQThreshTable specific index for the mscAtmIfVpcTxQThreshTable.')
mscAtmIfVpcTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVpcTxQThreshTable.')
mscAtmIfVpcFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 357), )
if mibBuilder.loadTexts: mscAtmIfVpcFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVpcFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 357, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcFqpEntry.setDescription('An entry in the mscAtmIfVpcFqpTable.')
mscAtmIfVpcFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcFqpIndex.setDescription('This variable represents the mscAtmIfVpcFqpTable specific index for the mscAtmIfVpcFqpTable.')
mscAtmIfVpcFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcFqpTable.')
mscAtmIfVpcBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 358), )
if mibBuilder.loadTexts: mscAtmIfVpcBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVpcBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 358, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBqpEntry.setDescription('An entry in the mscAtmIfVpcBqpTable.')
mscAtmIfVpcBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBqpIndex.setDescription('This variable represents the mscAtmIfVpcBqpTable specific index for the mscAtmIfVpcBqpTable.')
mscAtmIfVpcBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcBqpTable.')
mscAtmIfVpcVpd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2))
mscAtmIfVpcVpdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcVpd components.')
mscAtmIfVpcVpdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcVpd component.')
mscAtmIfVpcVpdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcVpd components. These components cannot be added nor deleted.')
mscAtmIfVpcVpdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcVpdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcVpd tables.')
mscAtmIfVpcVpdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcVpdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdIndex.setDescription('This variable represents the index for the mscAtmIfVpcVpd tables.')
mscAtmIfVpcVpdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
mscAtmIfVpcVpdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdLbkEntry.setDescription('An entry in the mscAtmIfVpcVpdLbkTable.')
mscAtmIfVpcVpdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
mscAtmIfVpcVpdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
mscAtmIfVpcVpdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
mscAtmIfVpcVpdMCastConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipointRoot", 1), ("pointToMultipointLeaf", 2))).clone('pointToPoint')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdMCastConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdMCastConnectionType.setDescription('This attribute is introduced to exist temporarily to pass to AtmIf the connection type defined under Vcc or Vpc. This attribute will be obsoleted once a more elegant solution is available.')
mscAtmIfVpcVpdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
mscAtmIfVpcVpdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTrafficEntry.setDescription('An entry in the mscAtmIfVpcVpdTrafficTable.')
mscAtmIfVpcVpdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVpcVpdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
mscAtmIfVpcVpdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVpcVpdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
mscAtmIfVpcVpdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
mscAtmIfVpcVpdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
mscAtmIfVpcVpdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVpcVpdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVpcVpdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVpcVpdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
mscAtmIfVpcVpdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVpcVpdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVpcVpdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVpcVpdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVpcVpdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVpcVpdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
mscAtmIfVpcVpdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
mscAtmIfVpcVpdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 111), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
mscAtmIfVpcVpdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 111, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdAcctEntry.setDescription('An entry in the mscAtmIfVpcVpdAcctTable.')
mscAtmIfVpcVpdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
mscAtmIfVpcVpdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 297), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfVpcVpdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 297, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpEntry.setDescription('An entry in the mscAtmIfVpcVpdTxTdpTable.')
mscAtmIfVpcVpdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpIndex.setDescription('This variable represents the mscAtmIfVpcVpdTxTdpTable specific index for the mscAtmIfVpcVpdTxTdpTable.')
mscAtmIfVpcVpdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdTxTdpTable.')
mscAtmIfVpcVpdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 298), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
mscAtmIfVpcVpdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 298, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpEntry.setDescription('An entry in the mscAtmIfVpcVpdRxTdpTable.')
mscAtmIfVpcVpdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpIndex.setDescription('This variable represents the mscAtmIfVpcVpdRxTdpTable specific index for the mscAtmIfVpcVpdRxTdpTable.')
mscAtmIfVpcVpdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdRxTdpTable.')
mscAtmIfVpcVpdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 359), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVpcVpdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 359, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpEntry.setDescription('An entry in the mscAtmIfVpcVpdFqpTable.')
mscAtmIfVpcVpdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpIndex.setDescription('This variable represents the mscAtmIfVpcVpdFqpTable specific index for the mscAtmIfVpcVpdFqpTable.')
mscAtmIfVpcVpdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdFqpTable.')
mscAtmIfVpcVpdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 360), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVpcVpdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 360, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpEntry.setDescription('An entry in the mscAtmIfVpcVpdBqpTable.')
mscAtmIfVpcVpdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpIndex.setDescription('This variable represents the mscAtmIfVpcVpdBqpTable specific index for the mscAtmIfVpcVpdBqpTable.')
mscAtmIfVpcVpdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVpcVpdBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdBqpTable.')
mscAtmIfVpcVpdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2))
mscAtmIfVpcVpdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcVpdTm components.')
mscAtmIfVpcVpdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcVpdTm component.')
mscAtmIfVpcVpdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcVpdTm components. These components cannot be added nor deleted.')
mscAtmIfVpcVpdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcVpdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcVpdTm tables.')
mscAtmIfVpcVpdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmIndex.setDescription('This variable represents the index for the mscAtmIfVpcVpdTm tables.')
mscAtmIfVpcVpdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
mscAtmIfVpcVpdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmProvEntry.setDescription('An entry in the mscAtmIfVpcVpdTmProvTable.')
mscAtmIfVpcVpdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
mscAtmIfVpcVpdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVpcVpdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. An value other than sameAsCa may be specified only for ATM IP and 1pOC48SmSrAtm cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. For the 1pOC48SmSrAtm card, this attribute is used to set the per VC utilization limit. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm or Vpt txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
mscAtmIfVpcVpdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
mscAtmIfVpcVpdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
mscAtmIfVpcVpdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVpcVpdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVpcVpdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. Traffic shaping is not available on the 1pOC12SmLrAtm card, therefore this attribute is ignored. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
mscAtmIfVpcVpdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
mscAtmIfVpcVpdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfVpcVpdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
mscAtmIfVpcVpdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
mscAtmIfVpcVpdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVpcVpdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVpcVpdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVpcVpdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVpcVpdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
mscAtmIfVpcVpdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
mscAtmIfVpcVpdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. For the 1pOC12SmLrAtm card, the only allowable values are sameAsCa or abrSwitch. If abrSwitch is selected, EFCI marking behavior is implemented. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
mscAtmIfVpcVpdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 456), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
mscAtmIfVpcVpdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpEntry.setDescription('An entry in the mscAtmIfVpcVpdTmTxTdpTable.')
mscAtmIfVpcVpdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVpcVpdTmTxTdpTable specific index for the mscAtmIfVpcVpdTmTxTdpTable.')
mscAtmIfVpcVpdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdTmTxTdpTable.')
mscAtmIfVpcVpdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 457), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
mscAtmIfVpcVpdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpEntry.setDescription('An entry in the mscAtmIfVpcVpdTmRxTdpTable.')
mscAtmIfVpcVpdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVpcVpdTmRxTdpTable specific index for the mscAtmIfVpcVpdTmRxTdpTable.')
mscAtmIfVpcVpdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdTmRxTdpTable.')
mscAtmIfVpcVpdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 458), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVpcVpdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpEntry.setDescription('An entry in the mscAtmIfVpcVpdTmFqpTable.')
mscAtmIfVpcVpdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpIndex.setDescription('This variable represents the mscAtmIfVpcVpdTmFqpTable specific index for the mscAtmIfVpcVpdTmFqpTable.')
mscAtmIfVpcVpdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdTmFqpTable.')
mscAtmIfVpcVpdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 459), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVpcVpdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpEntry.setDescription('An entry in the mscAtmIfVpcVpdTmBqpTable.')
mscAtmIfVpcVpdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpIndex.setDescription('This variable represents the mscAtmIfVpcVpdTmBqpTable specific index for the mscAtmIfVpcVpdTmBqpTable.')
mscAtmIfVpcVpdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcVpdTmBqpTable.')
mscAtmIfVpcVpdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2))
mscAtmIfVpcVpdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcVpdTmAbr components.')
mscAtmIfVpcVpdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcVpdTmAbr component.')
mscAtmIfVpcVpdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcVpdTmAbr components. These components can be added and deleted.')
mscAtmIfVpcVpdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcVpdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcVpdTmAbr tables.')
mscAtmIfVpcVpdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVpcVpdTmAbr tables.')
mscAtmIfVpcVpdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
mscAtmIfVpcVpdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrProvEntry.setDescription('An entry in the mscAtmIfVpcVpdTmAbrProvTable.')
mscAtmIfVpcVpdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
mscAtmIfVpcVpdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
mscAtmIfVpcVpdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
mscAtmIfVpcVpdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute.')
mscAtmIfVpcVpdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr.')
mscAtmIfVpcVpdPm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3))
mscAtmIfVpcVpdPmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcVpdPm components.')
mscAtmIfVpcVpdPmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcVpdPm component.')
mscAtmIfVpcVpdPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcVpdPm components. These components can be added and deleted.')
mscAtmIfVpcVpdPmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcVpdPmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcVpdPm tables.')
mscAtmIfVpcVpdPmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmIndex.setDescription('This variable represents the index for the mscAtmIfVpcVpdPm tables.')
mscAtmIfVpcVpdPmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 100), )
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmProvTable.setDescription('This group contains provisioned attributes which specify Performance Monitoring (PM) measurements, namely, Availability Ratio (AR) and Cell Loss Ratio (CLR), and control modes for the connection. The values specified in this group override those specified by AtmIf Pm settings.')
mscAtmIfVpcVpdPmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcVpdPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmProvEntry.setDescription('An entry in the mscAtmIfVpcVpdPmProvTable.')
mscAtmIfVpcVpdPmSegSwitchSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 100, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmSegSwitchSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmSegSwitchSideMeasurement.setDescription('This attribute specifies the set of Performance Monitoring (PM) measurements on the switch side configuration for the connection. sameAsInterface means that the measurements specified by the segSwitchSideMeasurement attribute of the AtmIf Pm component will be performed. No other values may be specified if sameAsInterface is selected. If the value is empty, no switch side PM measurements are done. Description of bits: availabilityRatio(0) cellLossRatio(1) sameAsInterface(2)')
mscAtmIfVpcVpdPmSegLinkSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 100, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmSegLinkSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmSegLinkSideMeasurement.setDescription('This attribute specifies the set of Performance Monitoring (PM) measurements on the link side configuration for the connection. sameAsInterface means that the measurements specified by the segLinkSideMeasurement attribute of the AtmIf Pm component will be performed. No other values may be specified if sameAsInterface is selected. If the value is empty, no link side PM measurements are done. The following are valid sets: (~sameAsInterface ~availabilityRatio ~cellLossRatio) (~sameAsInterface ~availabilityRatio cellLossRatio) (~sameAsInterface availabilityRatio ~cellLossRatio) (~sameAsInterface availabilityRatio cellLossRatio) (sameAsInterface ~availabilityRatio ~cellLossRatio) Description of bits: availabilityRatio(0) cellLossRatio(1) sameAsInterface(2)')
mscAtmIfVpcVpdPmControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 2, 3, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("autoStart", 0), ("onDemand", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmControlMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcVpdPmControlMode.setDescription('This attribute specifies the control mode of Performance Monitoring (PM) measurements for the connection. autoStart means that PM activation procedures will start when the provisioned data is activated. onDemand means that PM activation procedures will start when the operator issues the START command. The PM measurements in this mode will continue until the operator issues the STOP command. sameAsInterface means that the behavior will be as specified by the controlMode attribute of the AtmIf Pm component.')
mscAtmIfVpcLoop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 3))
mscAtmIfVpcLoopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcLoopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLoopRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcLoop components.')
mscAtmIfVpcLoopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcLoopIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcLoopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLoopRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcLoop component.')
mscAtmIfVpcLoopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVpcLoopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLoopRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcLoop components. These components can be added and deleted.')
mscAtmIfVpcLoopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcLoopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLoopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcLoopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcLoopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLoopStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcLoop tables.')
mscAtmIfVpcLoopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcLoopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcLoopIndex.setDescription('This variable represents the index for the mscAtmIfVpcLoop tables.')
mscAtmIfVpcTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9))
mscAtmIfVpcTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcTm components.')
mscAtmIfVpcTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcTm component.')
mscAtmIfVpcTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcTm components. These components cannot be added nor deleted.')
mscAtmIfVpcTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcTm tables.')
mscAtmIfVpcTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmIndex.setDescription('This variable represents the index for the mscAtmIfVpcTm tables.')
mscAtmIfVpcTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100), )
if mibBuilder.loadTexts: mscAtmIfVpcTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
mscAtmIfVpcTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmOperEntry.setDescription('An entry in the mscAtmIfVpcTmOperTable.')
mscAtmIfVpcTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVpcTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current number of cells in the link class queue used by this connection to buffer its traffic. This attribute does not apply to basic Vpts.')
mscAtmIfVpcTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current congestion state of the link class queue used by this connection to buffer its traffic. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
mscAtmIfVpcTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
mscAtmIfVpcTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVpcTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14), ("sameAsFwd", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVpcTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. For the 1pOC12SmLrAtm card, traffic shaping is not available, therefore this attribute is always notApplicable. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is linear. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
mscAtmIfVpcTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVpcTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts. For 1pOC12SmLrAtm cards, perVc queueing is not available thus this attribute only indicates common or notApplicable.')
mscAtmIfVpcTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVpcTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
mscAtmIfVpcTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
mscAtmIfVpcTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc or Vpt. rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection is availableBitRate, a value of enforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection. The traffic descriptor parameters used for DGCRA enforcement are reflected in the rxTrafficDescParm of the connection.")
mscAtmIfVpcTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
mscAtmIfVpcTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
mscAtmIfVpcTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
mscAtmIfVpcTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVpcTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, this attribute value is set to notApplicable. For CQC-based ATM cards and the 1pOC12SmLrAtm card, the notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards other than 1pOC12SmLrAtm, if the displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
mscAtmIfVpcTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 451), )
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVpcTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 451, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpEntry.setDescription('An entry in the mscAtmIfVpcTmTxTdpTable.')
mscAtmIfVpcTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVpcTmTxTdpTable specific index for the mscAtmIfVpcTmTxTdpTable.')
mscAtmIfVpcTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcTmTxTdpTable.')
mscAtmIfVpcTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 452), )
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under the service category subcomponents of the CA component for the service category of this connection. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
mscAtmIfVpcTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 452, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshEntry.setDescription('An entry in the mscAtmIfVpcTmTxQThreshTable.')
mscAtmIfVpcTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshIndex.setDescription('This variable represents the mscAtmIfVpcTmTxQThreshTable specific index for the mscAtmIfVpcTmTxQThreshTable.')
mscAtmIfVpcTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVpcTmTxQThreshTable.')
mscAtmIfVpcTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 453), )
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 is not used. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVpcTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 453, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpEntry.setDescription('An entry in the mscAtmIfVpcTmRxTdpTable.')
mscAtmIfVpcTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVpcTmRxTdpTable specific index for the mscAtmIfVpcTmRxTdpTable.')
mscAtmIfVpcTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcTmRxTdpTable.')
mscAtmIfVpcTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 454), )
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVpcTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 454, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmTqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpEntry.setDescription('An entry in the mscAtmIfVpcTmTqpTable.')
mscAtmIfVpcTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpIndex.setDescription('This variable represents the mscAtmIfVpcTmTqpTable specific index for the mscAtmIfVpcTmTqpTable.')
mscAtmIfVpcTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmTqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcTmTqpTable.')
mscAtmIfVpcTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 455), )
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVpcTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 455, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmRqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpEntry.setDescription('An entry in the mscAtmIfVpcTmRqpTable.')
mscAtmIfVpcTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpIndex.setDescription('This variable represents the mscAtmIfVpcTmRqpTable specific index for the mscAtmIfVpcTmRqpTable.')
mscAtmIfVpcTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmRqpValue.setDescription('This variable represents an individual value for the mscAtmIfVpcTmRqpTable.')
mscAtmIfVpcTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2))
mscAtmIfVpcTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpcTmAbr components.')
mscAtmIfVpcTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcTmAbr component.')
mscAtmIfVpcTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcTmAbr components. These components cannot be added nor deleted.')
mscAtmIfVpcTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcTmAbr tables.')
mscAtmIfVpcTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVpcTmAbr tables.')
mscAtmIfVpcTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
mscAtmIfVpcTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrOperEntry.setDescription('An entry in the mscAtmIfVpcTmAbrOperTable.')
mscAtmIfVpcTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrInitialCellRate.setDescription('This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
mscAtmIfVpcTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrTransientBufferExposure.setDescription('This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVpcTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrFixedRoundTripTime.setDescription('This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVpcTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRateDecreaseFactor.setDescription('This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVpcTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRateIncreaseFactor.setDescription('This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVpcTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrMaxCellPerRmCell.setDescription('This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVpcTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrMaxTimeBetweenRmCell.setDescription('This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVpcTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrCutoffDecreaseFactor.setDescription('This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVpcTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrAcrDecreaseTimeFactor.setDescription('This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVpcTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrForwardRmCellLimit.setDescription('This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
mscAtmIfVpcTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrTxRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrTxRateChangeInfo.setDescription('This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
mscAtmIfVpcTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrAcrRateChangeInfo.setDescription('This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
mscAtmIfVpcTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrTxFwdRmCells.setDescription('This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
mscAtmIfVpcTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 9, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcTmAbrRxEfci.setDescription('This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
mscAtmIfVpcPm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13))
mscAtmIfVpcPmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 1), )
if mibBuilder.loadTexts: mscAtmIfVpcPmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscAtmIfVpcPm components.')
mscAtmIfVpcPmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcPmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpcPm component.')
mscAtmIfVpcPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpcPm components. These components cannot be added nor deleted.')
mscAtmIfVpcPmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVpcPmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpcPm tables.')
mscAtmIfVpcPmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("linkSide", 0), ("switchSide", 1))))
if mibBuilder.loadTexts: mscAtmIfVpcPmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmIndex.setDescription('This variable represents the index for the mscAtmIfVpcPm tables.')
mscAtmIfVpcPmStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 10), )
if mibBuilder.loadTexts: mscAtmIfVpcPmStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains attributes indicating the status of each Performance Monitoring (PM) measurement.')
mscAtmIfVpcPmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcPmStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmStatusEntry.setDescription('An entry in the mscAtmIfVpcPmStatusTable.')
mscAtmIfVpcPmClrMeasurementStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("inactive", 0), ("activating", 1), ("active", 2), ("activationFailed", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmClrMeasurementStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmClrMeasurementStatus.setDescription('This attribute displays the Cell Loss Ratio (CLR) measurement status of the connection. inactive indicates the test is inactive. activating indicates the test is activating. active indicates the test is in progress activationFailed indicates the test failed to be activated. Refer to the failureCause attribute for failure cause.')
mscAtmIfVpcPmArMeasurementStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("inactive", 0), ("activating", 1), ("active", 2), ("activationFailed", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmArMeasurementStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmArMeasurementStatus.setDescription('This attribute indicates the Availability Ratio (AR) measurement status of the connection. inactive indicates the test is inactive. activating indicates the test is activating. active indicates the test is in progress activationFailed indicates the test failed to be activated. Refer to the failureCause attribute for the failure cause.')
mscAtmIfVpcPmFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noError", 0), ("unknownCause", 1), ("softwareResourcesUnavailable", 2), ("hardwareResourcesUnavailable", 3), ("remoteEndNoResponse", 4), ("activationCollision", 5), ("remoteEndRejectedActivation", 6), ("pcrUnsupported", 7), ("nextHopCardUnsupported", 8))).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFailureCause.setDescription('This attribute indicates the failure cause of Performance Monitoring (PM) measurements. The following are possible causes: noError indicates no error. unknownCause indicates unknown failure cause. softwareResourcesUnavailable indicates software resources reserved for a maximum of 255 active PMs on the local FP card have been used up. hardwareResourcesUnavailable indicates hardware resources reserved for a maximum of 512 active PMs CLR have been used up on the Link Side local card. remoteEndNoResponse indicates no response from remote end. activationCollision indicates activation collision was detected. Usually this is caused by both ends of the connection being provisioned to request PM. Only one end should be so provisioned. remoteEndRejectedActivation indicates the remote end has rejected an activation request. Usually this is due to the remote end reaching a resource limit. pcrUnsupported indicates the Tx or Rx PCR was out of range between 0 and 409600. nextHopCardUnsupported indicates the next hop card type is not supported.')
mscAtmIfVpcPmFwdClrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11), )
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdClrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdClrTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains Cell Loss Ratio (CLR) measurements for the forward direction of the connection. The local end is always the provisioned end which sends the activation request, and the remote end is the end which receives the activation request.')
mscAtmIfVpcPmFwdClrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdClrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdClrEntry.setDescription('An entry in the mscAtmIfVpcPmFwdClrTable.')
mscAtmIfVpcPmFwdLastSampleUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsRx0.setDescription('This attribute displays the number of cells with CLP=0 received at the remote end over the last sample period.')
mscAtmIfVpcPmFwdLastSampleUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsTx0.setDescription('This attribute displays the number of cells with CLP=0 transmitted from the local end over the last sample period.')
mscAtmIfVpcPmFwdLastSampleClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 3), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleClr0.setDescription('This attribute displays CLR for CLP=0 traffic over the last sample period.')
mscAtmIfVpcPmFwdLastSampleUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0+1 received at the remote end over the last sample period.')
mscAtmIfVpcPmFwdLastSampleUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the local end over the last sample period.')
mscAtmIfVpcPmFwdLastSampleClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 6), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdLastSampleClr01.setDescription('This attribute indicates CLR for CLP=0+1 traffic over the last sample period.')
mscAtmIfVpcPmFwdTotalClrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalClrInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalClrInterval.setDescription('This attribute indicates the total time duration over which Cell Loss Ratio (CLR) has been calculated.')
mscAtmIfVpcPmFwdTotalUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsRx0.setDescription('This attribute indicates the number of cells with CLP=0 received at the remote end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVpcPmFwdTotalUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsTx0.setDescription('This attribute indicates the number of cells with CLP=0 transmitted from the local end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVpcPmFwdAverageClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 10), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdAverageClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdAverageClr0.setDescription('This attribute indicates the average CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmFwdMaximumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 11), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMaximumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMaximumClr0.setDescription('This attribute indicates the maximum CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmFwdMinimumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 12), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMinimumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMinimumClr0.setDescription('This attribute indicates the minimum CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmFwdTotalUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0+1 received at the remote end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVpcPmFwdTotalUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdTotalUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the local end over the total CLR measurement interval.')
mscAtmIfVpcPmFwdAverageClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 15), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdAverageClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdAverageClr01.setDescription('This attribute displays the average CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmFwdMaximumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 16), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMaximumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMaximumClr01.setDescription('This attribute indicates the maximum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmFwdMinimumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 17), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMinimumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdMinimumClr01.setDescription('This attribute indicates the minimum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmFwdPmCellDiscardCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 11, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdPmCellDiscardCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmFwdPmCellDiscardCount.setDescription('This attribute indicates the total number of Performance Monitoring (PM) cells discarded.')
mscAtmIfVpcPmBwdClrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12), )
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdClrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdClrTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains Cell Loss Ratio (CLR) measurements for the backward direction of the connection. The local end is always the provisioned end which sends the activation request, and the remote end is the end which receives the activation request.')
mscAtmIfVpcPmBwdClrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdClrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdClrEntry.setDescription('An entry in the mscAtmIfVpcPmBwdClrTable.')
mscAtmIfVpcPmBwdLastSampleUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsRx0.setDescription('This attribute indicates the number of cells with CLP=0 received at the local end over the last sample period.')
mscAtmIfVpcPmBwdLastSampleUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsTx0.setDescription('This attribute indicates the number of cells with CLP=0 transmitted from the remote end over the last sample period.')
mscAtmIfVpcPmBwdLastSampleClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 3), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleClr0.setDescription('This attribute indicates CLR for CLP=0 traffic over the last sample period.')
mscAtmIfVpcPmBwdLastSampleUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0+1 received at the local end over the last sample period.')
mscAtmIfVpcPmBwdLastSampleUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the remote end over the last sample period.')
mscAtmIfVpcPmBwdLastSampleClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 6), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdLastSampleClr01.setDescription('This attribute display CLRfor CLP=0+1 traffic over the last sample period.')
mscAtmIfVpcPmBwdTotalClrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalClrInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalClrInterval.setDescription('This attribute indicates the total time duration over which Cell Loss Ratio (CLR) measurement has been calculated.')
mscAtmIfVpcPmBwdTotalUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsRx0.setDescription('This attribute indicates the number of cells with CLP=0 received at the local end over the total Cell Loss Ratio (CLR) measurement interval in the backward direction.')
mscAtmIfVpcPmBwdTotalUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsTx0.setDescription('This attribute indicates the number of cells with CLP=0 transmitted from the remote end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVpcPmBwdAverageClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 10), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdAverageClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdAverageClr0.setDescription('This attribute indicates the average CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmBwdMaximumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 11), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMaximumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMaximumClr0.setDescription('This attribute indicates the maximum CLR for CLP=0 traffi calculated for the total measurement interval.')
mscAtmIfVpcPmBwdMinimumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 12), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMinimumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMinimumClr0.setDescription('This attribute indicates the minimum CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmBwdTotalUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0 received at the local end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVpcPmBwdTotalUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdTotalUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the remote end over the total Cell Loss Ratio (CLR) measurement interval .')
mscAtmIfVpcPmBwdAverageClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 15), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdAverageClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdAverageClr01.setDescription('This attribute displays the average CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmBwdMaximumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 16), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMaximumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMaximumClr01.setDescription('This attribute indicates the maximum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmBwdMinimumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 17), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMinimumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdMinimumClr01.setDescription('This attribute indicates the minimum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVpcPmBwdPmCellDiscardCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 12, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdPmCellDiscardCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmBwdPmCellDiscardCount.setDescription('This attribute indicates the total number of Performance Monitoring (PM) cells discarded.')
mscAtmIfVpcPmArTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 13), )
if mibBuilder.loadTexts: mscAtmIfVpcPmArTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmArTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains Availability Ratio (AR) measurements of the connection.')
mscAtmIfVpcPmArEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVpcPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVpcPmArEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmArEntry.setDescription('An entry in the mscAtmIfVpcPmArTable.')
mscAtmIfVpcPmCurrentAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("available", 1), ("unavailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmCurrentAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmCurrentAvailabilityStatus.setDescription('This attribute indicates the current status of the bidirectional connection for purposes of Availability Ratio (AR) computation. notApplicable means AR measurement was not requested on this connection. available means AR is running and considers the connection available (that is, the arAvailableTime attribute is being incremented). unavailable means AR measurement was requested but the connection is currently unavailable.')
mscAtmIfVpcPmArTotalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmArTotalTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmArTotalTime.setDescription('This attribute indicates the total time used for calculating Availability Ratio (AR) of the bi-directional connection.')
mscAtmIfVpcPmArAvailableTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmArAvailableTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmArAvailableTime.setDescription('This attribute indicates the total time the connection was available.')
mscAtmIfVpcPmArAvailabilityRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 4, 13, 13, 1, 4), FixedPoint7().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVpcPmArAvailabilityRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVpcPmArAvailabilityRatio.setDescription('This attribute indicates the ratio of network availability representing the time to the total time of the connection.')
mscAtmIfVcc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5))
mscAtmIfVccRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 1), )
if mibBuilder.loadTexts: mscAtmIfVccRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVcc components.')
mscAtmIfVccRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVcc component.')
mscAtmIfVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVcc components. These components can be added and deleted.')
mscAtmIfVccComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVcc tables.')
mscAtmIfVccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 1, 1, 10), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(3, 10)))
if mibBuilder.loadTexts: mscAtmIfVccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccIndex.setDescription('This variable represents the index for the mscAtmIfVcc tables.')
mscAtmIfVccStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 100), )
if mibBuilder.loadTexts: mscAtmIfVccStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscAtmIfVccStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStateEntry.setDescription('An entry in the mscAtmIfVccStateTable.')
mscAtmIfVccAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVccOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVccUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVccOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 110), )
if mibBuilder.loadTexts: mscAtmIfVccOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
mscAtmIfVccOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccOperEntry.setDescription('An entry in the mscAtmIfVccOperTable.')
mscAtmIfVccConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
mscAtmIfVccConnInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 115), )
if mibBuilder.loadTexts: mscAtmIfVccConnInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccConnInfoTable.setDescription('This group contains operational connection characteristics information for a Vcc component.')
mscAtmIfVccConnInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 115, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccConnInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccConnInfoEntry.setDescription('An entry in the mscAtmIfVccConnInfoTable.')
mscAtmIfVccDistributionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 115, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipoint", 1))).clone('pointToPoint')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccDistributionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccDistributionType.setDescription('This attribute indicates the way data is distributed in the connection. A value of pointToPoint indicates this connection point is part of a point-to-point connection. A value of pointToMultipoint indicates this connection point is part of a point-to-multipoint connection.')
mscAtmIfVccNumLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 115, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccNumLeaves.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNumLeaves.setDescription('This attribute indicates the number of destination leaves of the connection. If the distributionType is pointToPoint the value of this attribute is 0.')
mscAtmIfVccCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 115, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fromLink", 0), ("toLink", 1), ("notApplicable", 2))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccCallDirection.setDescription('This attribute indicates the direction of the call setup request for an SVC. A value of fromLink means that the call setup originated from the link. A value of toLink means that the call setup was directed to the link. For PVC connections, the value of this attribute is notApplicable. For SPVC connections, the value of this attribute is notApplicable for Vccs with the SourcePVC and DestinationPVC subcomponents. For Signalling channels, the value of this attribute is notApplicable.')
mscAtmIfVccStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120), )
if mibBuilder.loadTexts: mscAtmIfVccStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc or Vpt component.')
mscAtmIfVccStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatusEntry.setDescription('An entry in the mscAtmIfVccStatusTable.')
mscAtmIfVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
mscAtmIfVccLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
mscAtmIfVccTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
mscAtmIfVccSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVccSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
mscAtmIfVccEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVccRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
mscAtmIfVccAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccAisState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVccRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVccTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130), )
if mibBuilder.loadTexts: mscAtmIfVccTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
mscAtmIfVccTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTrafficEntry.setDescription('An entry in the mscAtmIfVccTrafficTable.')
mscAtmIfVccTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVccTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
mscAtmIfVccFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
mscAtmIfVccTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
mscAtmIfVccHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVccRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVccRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
mscAtmIfVccBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVccTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
mscAtmIfVccBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVccClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
mscAtmIfVccBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
mscAtmIfVccTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVccRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVccBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVccBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140), )
if mibBuilder.loadTexts: mscAtmIfVccStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
mscAtmIfVccStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsEntry.setDescription('An entry in the mscAtmIfVccStatsTable.')
mscAtmIfVccStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCell.setDescription('This attribute counts the number of cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCellClp.setDescription('This attribute counts the number of cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVccStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccPerfTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 150), )
if mibBuilder.loadTexts: mscAtmIfVccPerfTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPerfTable.setDescription('This group contains operational attributes which keep performance statistics about the behavior of the AtmIf component.')
mscAtmIfVccPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 150, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVccPerfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPerfEntry.setDescription('An entry in the mscAtmIfVccPerfTable.')
mscAtmIfVccLastMinimumCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 150, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccLastMinimumCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLastMinimumCtd.setDescription('This attribute indicates the minimum calculated cell transfer delay value for this connection from the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval if TODA is disabled. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the accountCollection attribute of the AtmIf Uni or AtmIf Iisp component has a non-empty reason. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVccLastMaximumCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 150, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccLastMaximumCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLastMaximumCtd.setDescription('This attribute indicates the maximum calculated cell transfer delay value for this connection from the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval if TODA is disabled. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the accountCollection attribute of the AtmIf Uni or AtmIf Iisp component has a non-empty reason. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVccLastAverageCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 150, 1, 30), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccLastAverageCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLastAverageCtd.setDescription('This attribute indicates the average of all calculated cell transfer delay values for this connection from the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval if TODA is disabled. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the accountCollection attribute of the AtmIf Uni or AtmIf Iisp component has a non-empty reason. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVccCurrentCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 150, 1, 40), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccCurrentCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccCurrentCtd.setDescription('This attribute indicates the most recent cell transfer delay value calculated for this connection. Cell transfer delay is calculated as half of the measured segment round trip delay of a loopback cell. The value is noMeasurement when the ctdCalculation attribute of the AtmIf component is off. The value is noMeasurement when the segSwitchSideLoopback attribute value is off for the connection. The value is noMeasurement when the switch-side loopback is not working. The value is noMeasurement when the switch-side loopback status cannot be determined. VALUES ( 0 = noMeasurement )')
mscAtmIfVccLastCtdSampleSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 150, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccLastCtdSampleSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLastCtdSampleSize.setDescription('This attribute indicates the number of loopback cells sampled for cell transfer delay calculations during the previous TODA (time of day accounting) interval if TODA is enabled; or for the previous 12 hour interval of TODA is disabled.')
mscAtmIfVccTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 294), )
if mibBuilder.loadTexts: mscAtmIfVccTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVccTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 294, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxTdpEntry.setDescription('An entry in the mscAtmIfVccTxTdpTable.')
mscAtmIfVccTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVccTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxTdpIndex.setDescription('This variable represents the mscAtmIfVccTxTdpTable specific index for the mscAtmIfVccTxTdpTable.')
mscAtmIfVccTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccTxTdpTable.')
mscAtmIfVccRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 295), )
if mibBuilder.loadTexts: mscAtmIfVccRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVccRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 295, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxTdpEntry.setDescription('An entry in the mscAtmIfVccRxTdpTable.')
mscAtmIfVccRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVccRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxTdpIndex.setDescription('This variable represents the mscAtmIfVccRxTdpTable specific index for the mscAtmIfVccRxTdpTable.')
mscAtmIfVccRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccRxTdpTable.')
mscAtmIfVccTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 352), )
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
mscAtmIfVccTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 352, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshEntry.setDescription('An entry in the mscAtmIfVccTxQThreshTable.')
mscAtmIfVccTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshIndex.setDescription('This variable represents the mscAtmIfVccTxQThreshTable specific index for the mscAtmIfVccTxQThreshTable.')
mscAtmIfVccTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVccTxQThreshTable.')
mscAtmIfVccFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 357), )
if mibBuilder.loadTexts: mscAtmIfVccFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVccFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 357, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccFqpEntry.setDescription('An entry in the mscAtmIfVccFqpTable.')
mscAtmIfVccFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccFqpIndex.setDescription('This variable represents the mscAtmIfVccFqpTable specific index for the mscAtmIfVccFqpTable.')
mscAtmIfVccFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccFqpTable.')
mscAtmIfVccBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 358), )
if mibBuilder.loadTexts: mscAtmIfVccBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVccBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 358, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBqpEntry.setDescription('An entry in the mscAtmIfVccBqpTable.')
mscAtmIfVccBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBqpIndex.setDescription('This variable represents the mscAtmIfVccBqpTable specific index for the mscAtmIfVccBqpTable.')
mscAtmIfVccBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccBqpTable.')
mscAtmIfVccVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2))
mscAtmIfVccVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVccVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccVcd components.')
mscAtmIfVccVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccVcd component.')
mscAtmIfVccVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccVcd components. These components cannot be added nor deleted.')
mscAtmIfVccVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccVcd tables.')
mscAtmIfVccVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdIndex.setDescription('This variable represents the index for the mscAtmIfVccVcd tables.')
mscAtmIfVccVcdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVccVcdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
mscAtmIfVccVcdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdLbkEntry.setDescription('An entry in the mscAtmIfVccVcdLbkTable.')
mscAtmIfVccVcdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
mscAtmIfVccVcdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
mscAtmIfVccVcdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
mscAtmIfVccVcdMCastConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipointRoot", 1), ("pointToMultipointLeaf", 2))).clone('pointToPoint')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdMCastConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdMCastConnectionType.setDescription('This attribute is introduced to exist temporarily to pass to AtmIf the connection type defined under Vcc or Vpc. This attribute will be obsoleted once a more elegant solution is available.')
mscAtmIfVccVcdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
mscAtmIfVccVcdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTrafficEntry.setDescription('An entry in the mscAtmIfVccVcdTrafficTable.')
mscAtmIfVccVcdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVccVcdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
mscAtmIfVccVcdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVccVcdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
mscAtmIfVccVcdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
mscAtmIfVccVcdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
mscAtmIfVccVcdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVccVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVccVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVccVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
mscAtmIfVccVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVccVcdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVccVcdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVccVcdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVccVcdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVccVcdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
mscAtmIfVccVcdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
mscAtmIfVccVcdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 111), )
if mibBuilder.loadTexts: mscAtmIfVccVcdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
mscAtmIfVccVcdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 111, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdAcctEntry.setDescription('An entry in the mscAtmIfVccVcdAcctTable.')
mscAtmIfVccVcdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
mscAtmIfVccVcdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 297), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfVccVcdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 297, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpEntry.setDescription('An entry in the mscAtmIfVccVcdTxTdpTable.')
mscAtmIfVccVcdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpIndex.setDescription('This variable represents the mscAtmIfVccVcdTxTdpTable specific index for the mscAtmIfVccVcdTxTdpTable.')
mscAtmIfVccVcdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdTxTdpTable.')
mscAtmIfVccVcdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 298), )
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
mscAtmIfVccVcdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 298, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpEntry.setDescription('An entry in the mscAtmIfVccVcdRxTdpTable.')
mscAtmIfVccVcdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpIndex.setDescription('This variable represents the mscAtmIfVccVcdRxTdpTable specific index for the mscAtmIfVccVcdRxTdpTable.')
mscAtmIfVccVcdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdRxTdpTable.')
mscAtmIfVccVcdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 359), )
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVccVcdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 359, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpEntry.setDescription('An entry in the mscAtmIfVccVcdFqpTable.')
mscAtmIfVccVcdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpIndex.setDescription('This variable represents the mscAtmIfVccVcdFqpTable specific index for the mscAtmIfVccVcdFqpTable.')
mscAtmIfVccVcdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdFqpTable.')
mscAtmIfVccVcdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 360), )
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVccVcdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 360, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpEntry.setDescription('An entry in the mscAtmIfVccVcdBqpTable.')
mscAtmIfVccVcdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpIndex.setDescription('This variable represents the mscAtmIfVccVcdBqpTable specific index for the mscAtmIfVccVcdBqpTable.')
mscAtmIfVccVcdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVccVcdBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdBqpTable.')
mscAtmIfVccVcdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2))
mscAtmIfVccVcdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccVcdTm components.')
mscAtmIfVccVcdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccVcdTm component.')
mscAtmIfVccVcdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccVcdTm components. These components cannot be added nor deleted.')
mscAtmIfVccVcdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccVcdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccVcdTm tables.')
mscAtmIfVccVcdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccVcdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmIndex.setDescription('This variable represents the index for the mscAtmIfVccVcdTm tables.')
mscAtmIfVccVcdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
mscAtmIfVccVcdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmProvEntry.setDescription('An entry in the mscAtmIfVccVcdTmProvTable.')
mscAtmIfVccVcdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
mscAtmIfVccVcdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVccVcdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. An value other than sameAsCa may be specified only for ATM IP and 1pOC48SmSrAtm cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. For the 1pOC48SmSrAtm card, this attribute is used to set the per VC utilization limit. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm or Vpt txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
mscAtmIfVccVcdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
mscAtmIfVccVcdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
mscAtmIfVccVcdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVccVcdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVccVcdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. Traffic shaping is not available on the 1pOC12SmLrAtm card, therefore this attribute is ignored. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
mscAtmIfVccVcdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
mscAtmIfVccVcdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfVccVcdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
mscAtmIfVccVcdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
mscAtmIfVccVcdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVccVcdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVccVcdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVccVcdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVccVcdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
mscAtmIfVccVcdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
mscAtmIfVccVcdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. For the 1pOC12SmLrAtm card, the only allowable values are sameAsCa or abrSwitch. If abrSwitch is selected, EFCI marking behavior is implemented. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
mscAtmIfVccVcdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 456), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
mscAtmIfVccVcdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpEntry.setDescription('An entry in the mscAtmIfVccVcdTmTxTdpTable.')
mscAtmIfVccVcdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVccVcdTmTxTdpTable specific index for the mscAtmIfVccVcdTmTxTdpTable.')
mscAtmIfVccVcdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdTmTxTdpTable.')
mscAtmIfVccVcdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 457), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
mscAtmIfVccVcdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpEntry.setDescription('An entry in the mscAtmIfVccVcdTmRxTdpTable.')
mscAtmIfVccVcdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVccVcdTmRxTdpTable specific index for the mscAtmIfVccVcdTmRxTdpTable.')
mscAtmIfVccVcdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdTmRxTdpTable.')
mscAtmIfVccVcdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 458), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVccVcdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpEntry.setDescription('An entry in the mscAtmIfVccVcdTmFqpTable.')
mscAtmIfVccVcdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpIndex.setDescription('This variable represents the mscAtmIfVccVcdTmFqpTable specific index for the mscAtmIfVccVcdTmFqpTable.')
mscAtmIfVccVcdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdTmFqpTable.')
mscAtmIfVccVcdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 459), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVccVcdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpEntry.setDescription('An entry in the mscAtmIfVccVcdTmBqpTable.')
mscAtmIfVccVcdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpIndex.setDescription('This variable represents the mscAtmIfVccVcdTmBqpTable specific index for the mscAtmIfVccVcdTmBqpTable.')
mscAtmIfVccVcdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccVcdTmBqpTable.')
mscAtmIfVccVcdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2))
mscAtmIfVccVcdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccVcdTmAbr components.')
mscAtmIfVccVcdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccVcdTmAbr component.')
mscAtmIfVccVcdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccVcdTmAbr components. These components can be added and deleted.')
mscAtmIfVccVcdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccVcdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccVcdTmAbr tables.')
mscAtmIfVccVcdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVccVcdTmAbr tables.')
mscAtmIfVccVcdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
mscAtmIfVccVcdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrProvEntry.setDescription('An entry in the mscAtmIfVccVcdTmAbrProvTable.')
mscAtmIfVccVcdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
mscAtmIfVccVcdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
mscAtmIfVccVcdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
mscAtmIfVccVcdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute.')
mscAtmIfVccVcdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr.')
mscAtmIfVccVcdPm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3))
mscAtmIfVccVcdPmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVccVcdPmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccVcdPm components.')
mscAtmIfVccVcdPmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdPmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccVcdPm component.')
mscAtmIfVccVcdPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdPmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccVcdPm components. These components can be added and deleted.')
mscAtmIfVccVcdPmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdPmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccVcdPmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccVcdPmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccVcdPm tables.')
mscAtmIfVccVcdPmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccVcdPmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmIndex.setDescription('This variable represents the index for the mscAtmIfVccVcdPm tables.')
mscAtmIfVccVcdPmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 100), )
if mibBuilder.loadTexts: mscAtmIfVccVcdPmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmProvTable.setDescription('This group contains provisioned attributes which specify Performance Monitoring (PM) measurements, namely, Availability Ratio (AR) and Cell Loss Ratio (CLR), and control modes for the connection. The values specified in this group override those specified by AtmIf Pm settings.')
mscAtmIfVccVcdPmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccVcdPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccVcdPmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmProvEntry.setDescription('An entry in the mscAtmIfVccVcdPmProvTable.')
mscAtmIfVccVcdPmSegSwitchSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 100, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdPmSegSwitchSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmSegSwitchSideMeasurement.setDescription('This attribute specifies the set of Performance Monitoring (PM) measurements on the switch side configuration for the connection. sameAsInterface means that the measurements specified by the segSwitchSideMeasurement attribute of the AtmIf Pm component will be performed. No other values may be specified if sameAsInterface is selected. If the value is empty, no switch side PM measurements are done. Description of bits: availabilityRatio(0) cellLossRatio(1) sameAsInterface(2)')
mscAtmIfVccVcdPmSegLinkSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 100, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdPmSegLinkSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmSegLinkSideMeasurement.setDescription('This attribute specifies the set of Performance Monitoring (PM) measurements on the link side configuration for the connection. sameAsInterface means that the measurements specified by the segLinkSideMeasurement attribute of the AtmIf Pm component will be performed. No other values may be specified if sameAsInterface is selected. If the value is empty, no link side PM measurements are done. The following are valid sets: (~sameAsInterface ~availabilityRatio ~cellLossRatio) (~sameAsInterface ~availabilityRatio cellLossRatio) (~sameAsInterface availabilityRatio ~cellLossRatio) (~sameAsInterface availabilityRatio cellLossRatio) (sameAsInterface ~availabilityRatio ~cellLossRatio) Description of bits: availabilityRatio(0) cellLossRatio(1) sameAsInterface(2)')
mscAtmIfVccVcdPmControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 2, 3, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("autoStart", 0), ("onDemand", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccVcdPmControlMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccVcdPmControlMode.setDescription('This attribute specifies the control mode of Performance Monitoring (PM) measurements for the connection. autoStart means that PM activation procedures will start when the provisioned data is activated. onDemand means that PM activation procedures will start when the operator issues the START command. The PM measurements in this mode will continue until the operator issues the STOP command. sameAsInterface means that the behavior will be as specified by the controlMode attribute of the AtmIf Pm component.')
mscAtmIfVccLoop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 3))
mscAtmIfVccLoopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVccLoopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLoopRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccLoop components.')
mscAtmIfVccLoopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccLoopIndex"))
if mibBuilder.loadTexts: mscAtmIfVccLoopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLoopRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccLoop component.')
mscAtmIfVccLoopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccLoopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLoopRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccLoop components. These components can be added and deleted.')
mscAtmIfVccLoopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccLoopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLoopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccLoopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccLoopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLoopStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccLoop tables.')
mscAtmIfVccLoopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccLoopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccLoopIndex.setDescription('This variable represents the index for the mscAtmIfVccLoop tables.')
mscAtmIfVccNep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5))
mscAtmIfVccNepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 1), )
if mibBuilder.loadTexts: mscAtmIfVccNepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccNep components.')
mscAtmIfVccNepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccNepIndex"))
if mibBuilder.loadTexts: mscAtmIfVccNepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccNep component.')
mscAtmIfVccNepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccNepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccNep components. These components can be added and deleted.')
mscAtmIfVccNepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccNepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccNepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccNepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccNep tables.')
mscAtmIfVccNepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccNepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepIndex.setDescription('This variable represents the index for the mscAtmIfVccNep tables.')
mscAtmIfVccNepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 100), )
if mibBuilder.loadTexts: mscAtmIfVccNepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepProvTable.setDescription('This group contains provisionable attributes for the Nep component.')
mscAtmIfVccNepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccNepIndex"))
if mibBuilder.loadTexts: mscAtmIfVccNepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepProvEntry.setDescription('An entry in the mscAtmIfVccNepProvTable.')
mscAtmIfVccNepApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 5, 100, 1, 10), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccNepApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccNepApplicationName.setDescription("This attribute specifies the application that sends and receives frames using the VCC. This attribute is set, for example, by provisioning the Trunk AtmAccess AtmConnection attribute. If it is properly configured, this attribute will show a value such as 'Trk/22 AtmAccess'.")
mscAtmIfVccTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6))
mscAtmIfVccTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 1), )
if mibBuilder.loadTexts: mscAtmIfVccTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccTest components.')
mscAtmIfVccTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccTest component.')
mscAtmIfVccTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccTest components. These components can be added and deleted.')
mscAtmIfVccTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccTest tables.')
mscAtmIfVccTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestIndex.setDescription('This variable represents the index for the mscAtmIfVccTest tables.')
mscAtmIfVccTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 100), )
if mibBuilder.loadTexts: mscAtmIfVccTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscAtmIfVccTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestStateEntry.setDescription('An entry in the mscAtmIfVccTestStateTable.')
mscAtmIfVccTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVccTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVccTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVccTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110), )
if mibBuilder.loadTexts: mscAtmIfVccTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestSetupTable.setDescription('This group contains attributes that govern the operation of an ATM connection test. These attributes cannot be changed while the test is running.')
mscAtmIfVccTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestSetupEntry.setDescription('An entry in the mscAtmIfVccTestSetupTable.')
mscAtmIfVccTestFrmTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestFrmTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestFrmTypes.setDescription("This attribute specifies the types of the test frames to be transmitted during the ATM connection test. It must contain at least one of the following: loading: A set of 'loading frames' is circulated over the link as rapidly as possible. This frame type should be selected when the test is intended to verify the operation of the connection under a specified load. These frames are not checked for bit errors. verification: A single 'verification frame' is transmitted over the link; when the frame is returned, its contents are verified and the next verification frame in the series is transmitted. This frame type should be selected when the test is intended to verify that frames are not being corrupted as they pass over the connection. Description of bits: loading(0) verification(1)")
mscAtmIfVccTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestFrmSize.setDescription('This attribute defines the size of the test frames used in an ATM connection test.')
mscAtmIfVccTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestFrmPatternType.setDescription('This attribute specifies the bit sequence used to fill the frames used in the ATM connection test. It must contain one of the following values: ccitt32kBitPattern: a pseudo-random sequence of 32 Kbit is used ccitt8MBitPattern: a pseudo-random sequence of 8Mbit is used customizedPattern: the pattern defined in the customizedPattern attribute is used')
mscAtmIfVccTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1, 40), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestCustomizedPattern.setDescription('This attribute specifies a 32 bit sequence to be used to fill frames when the framePatternType attribute is set to customizedPattern. The default value gives a pattern of alternating 0 and 1 bits.')
mscAtmIfVccTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestDuration.setDescription('This attribute specifies the maximum number of minutes that the ATM connection test is allowed to run. The maximum allowed value permits the test to be run for up to 21 days.')
mscAtmIfVccTestBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestBandwidthElastic.setDescription('This attribute specifies whether the connection (VCC) should be configured with elastic bandwidth or not. Elastic bandwidth is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be reduced in bandwidth based on the setting of the bwElastic attribute. If this attribute is set to yes, the Test application signals to the connection that the bandwidth for this connection is elastic, and may be reduced in the case of IMA link failures. If the bandwidth is reduced, the rate of test cells which can be handled by the connection will also be reduced. If this attribute is set to no, the Test application signals to the connection that the bandwidth for this connection must be maintained at the requested level. If the connection cannot maintain the full bandwidth, the connection may be released (cleared) based on the holding priority of the connection.')
mscAtmIfVccTestOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVccTestOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestOverrideHoldingPriority.setDescription("This attribute specifies the override holding priority which should be signalled to the VCC connection at the start of the test. Holding priority is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be released based on the connection's holding priority. Zero (0) is thie highest holding priority, and four (4) is the lowest priority. A setting of zero to four overrides whatever holding priority that has been configured at the connection (VCC). A setting of noOverride means that the connection should use its internally configured holding priority.")
mscAtmIfVccTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120), )
if mibBuilder.loadTexts: mscAtmIfVccTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestResultsTable.setDescription('This group contains attributes that show the result of an ATM connection test; if no test is running, the attribute group contains the results of the most recently completed test. The attributes of the Results group are reset to their inital values whenever a test is started or any attribute of the Setup group is set.')
mscAtmIfVccTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestResultsEntry.setDescription('An entry in the mscAtmIfVccTestResultsTable.')
mscAtmIfVccTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestElapsedTime.setDescription('This attribute displays the number of minutes that the test has been running.')
mscAtmIfVccTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestTimeRemaining.setDescription('This attribute displays the number of minutes that the test will continue to run before stopping automatically.')
mscAtmIfVccTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("neverStarted", 2), ("testRunning", 3))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestCauseOfTermination.setDescription('This attribute displays the reason the test ended. It contains one fo the following values. testTimeExpired: the test ran for the specified duration stoppedByOperator: a STOP command was issued neverStarted: the test has not been started testRunning: the test is currently running')
mscAtmIfVccTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestBytesTx.setDescription('This attribute displays the number of bytes sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestBytesRx.setDescription('This attribute displays the number of bytes received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTestLoadingFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestLoadingFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestLoadingFrmTx.setDescription('This attribute displays the number of loading frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTestLoadingFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestLoadingFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestLoadingFrmRx.setDescription('This attribute displays the number of loading frames received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTestLoadingFrmLost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestLoadingFrmLost.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestLoadingFrmLost.setDescription('This attribute displays the number of loading frames that were lost during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTestVerificationFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestVerificationFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestVerificationFrmTx.setDescription('This attribute displays the number of verification frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTestVerificationFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestVerificationFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestVerificationFrmRx.setDescription('This attribute displays the number of verification frames received during the test (including errored verification frames). The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of verification frames lost during the test can be computed by the expression verificationFrmTx - verificationFrmRx.')
mscAtmIfVccTestVerificationFrmBad = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 110), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestVerificationFrmBad.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestVerificationFrmBad.setDescription('This attribute displays the number of errored verification frames received during the test. A verification frame is considered to be errored if it contains a recognizable verification frame header, but does not match the transmitted frame bit for bit. (Thus, a verification frame that returns after the succeeding verification frame has been transmitted is considered to be errored.) The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of correct verification frames received during the test can be computed by the expression verificationFrmRx - verificationFrmBad.')
mscAtmIfVccTestUnrecognizableFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 6, 120, 1, 120), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTestUnrecognizableFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTestUnrecognizableFrmRx.setDescription('This attribute displays the number of frames received during the test which do not contain a valid loading frame header or verification frame header. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVccTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7))
mscAtmIfVccTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 1), )
if mibBuilder.loadTexts: mscAtmIfVccTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccTm components.')
mscAtmIfVccTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccTm component.')
mscAtmIfVccTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccTm components. These components cannot be added nor deleted.')
mscAtmIfVccTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccTm tables.')
mscAtmIfVccTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmIndex.setDescription('This variable represents the index for the mscAtmIfVccTm tables.')
mscAtmIfVccTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100), )
if mibBuilder.loadTexts: mscAtmIfVccTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
mscAtmIfVccTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmOperEntry.setDescription('An entry in the mscAtmIfVccTmOperTable.')
mscAtmIfVccTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVccTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current number of cells in the link class queue used by this connection to buffer its traffic. This attribute does not apply to basic Vpts.')
mscAtmIfVccTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current congestion state of the link class queue used by this connection to buffer its traffic. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
mscAtmIfVccTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
mscAtmIfVccTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVccTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14), ("sameAsFwd", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVccTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. For the 1pOC12SmLrAtm card, traffic shaping is not available, therefore this attribute is always notApplicable. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is linear. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
mscAtmIfVccTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVccTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts. For 1pOC12SmLrAtm cards, perVc queueing is not available thus this attribute only indicates common or notApplicable.')
mscAtmIfVccTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVccTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
mscAtmIfVccTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
mscAtmIfVccTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc or Vpt. rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection is availableBitRate, a value of enforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection. The traffic descriptor parameters used for DGCRA enforcement are reflected in the rxTrafficDescParm of the connection.")
mscAtmIfVccTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
mscAtmIfVccTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
mscAtmIfVccTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
mscAtmIfVccTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVccTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, this attribute value is set to notApplicable. For CQC-based ATM cards and the 1pOC12SmLrAtm card, the notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards other than 1pOC12SmLrAtm, if the displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
mscAtmIfVccTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 451), )
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVccTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 451, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpEntry.setDescription('An entry in the mscAtmIfVccTmTxTdpTable.')
mscAtmIfVccTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVccTmTxTdpTable specific index for the mscAtmIfVccTmTxTdpTable.')
mscAtmIfVccTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccTmTxTdpTable.')
mscAtmIfVccTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 452), )
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under the service category subcomponents of the CA component for the service category of this connection. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
mscAtmIfVccTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 452, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshEntry.setDescription('An entry in the mscAtmIfVccTmTxQThreshTable.')
mscAtmIfVccTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshIndex.setDescription('This variable represents the mscAtmIfVccTmTxQThreshTable specific index for the mscAtmIfVccTmTxQThreshTable.')
mscAtmIfVccTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVccTmTxQThreshTable.')
mscAtmIfVccTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 453), )
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 is not used. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVccTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 453, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpEntry.setDescription('An entry in the mscAtmIfVccTmRxTdpTable.')
mscAtmIfVccTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVccTmRxTdpTable specific index for the mscAtmIfVccTmRxTdpTable.')
mscAtmIfVccTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVccTmRxTdpTable.')
mscAtmIfVccTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 454), )
if mibBuilder.loadTexts: mscAtmIfVccTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVccTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 454, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmTqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTqpEntry.setDescription('An entry in the mscAtmIfVccTmTqpTable.')
mscAtmIfVccTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTqpIndex.setDescription('This variable represents the mscAtmIfVccTmTqpTable specific index for the mscAtmIfVccTmTqpTable.')
mscAtmIfVccTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmTqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccTmTqpTable.')
mscAtmIfVccTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 455), )
if mibBuilder.loadTexts: mscAtmIfVccTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVccTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 455, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmRqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRqpEntry.setDescription('An entry in the mscAtmIfVccTmRqpTable.')
mscAtmIfVccTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVccTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRqpIndex.setDescription('This variable represents the mscAtmIfVccTmRqpTable specific index for the mscAtmIfVccTmRqpTable.')
mscAtmIfVccTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmRqpValue.setDescription('This variable represents an individual value for the mscAtmIfVccTmRqpTable.')
mscAtmIfVccTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2))
mscAtmIfVccTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVccTmAbr components.')
mscAtmIfVccTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccTmAbr component.')
mscAtmIfVccTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccTmAbr components. These components cannot be added nor deleted.')
mscAtmIfVccTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccTmAbr tables.')
mscAtmIfVccTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVccTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVccTmAbr tables.')
mscAtmIfVccTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVccTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
mscAtmIfVccTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVccTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrOperEntry.setDescription('An entry in the mscAtmIfVccTmAbrOperTable.')
mscAtmIfVccTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrInitialCellRate.setDescription('This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
mscAtmIfVccTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrTransientBufferExposure.setDescription('This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVccTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrFixedRoundTripTime.setDescription('This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVccTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRateDecreaseFactor.setDescription('This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVccTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRateIncreaseFactor.setDescription('This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVccTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrMaxCellPerRmCell.setDescription('This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVccTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrMaxTimeBetweenRmCell.setDescription('This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVccTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrCutoffDecreaseFactor.setDescription('This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVccTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrAcrDecreaseTimeFactor.setDescription('This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVccTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrForwardRmCellLimit.setDescription('This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
mscAtmIfVccTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrTxRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrTxRateChangeInfo.setDescription('This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
mscAtmIfVccTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrAcrRateChangeInfo.setDescription('This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
mscAtmIfVccTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrTxFwdRmCells.setDescription('This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
mscAtmIfVccTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 7, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccTmAbrRxEfci.setDescription('This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
mscAtmIfVccPm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14))
mscAtmIfVccPmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 1), )
if mibBuilder.loadTexts: mscAtmIfVccPmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscAtmIfVccPm components.')
mscAtmIfVccPmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccPmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVccPm component.')
mscAtmIfVccPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVccPm components. These components cannot be added nor deleted.')
mscAtmIfVccPmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVccPmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVccPm tables.')
mscAtmIfVccPmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("linkSide", 0), ("switchSide", 1))))
if mibBuilder.loadTexts: mscAtmIfVccPmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmIndex.setDescription('This variable represents the index for the mscAtmIfVccPm tables.')
mscAtmIfVccPmStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 10), )
if mibBuilder.loadTexts: mscAtmIfVccPmStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains attributes indicating the status of each Performance Monitoring (PM) measurement.')
mscAtmIfVccPmStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccPmStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmStatusEntry.setDescription('An entry in the mscAtmIfVccPmStatusTable.')
mscAtmIfVccPmClrMeasurementStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("inactive", 0), ("activating", 1), ("active", 2), ("activationFailed", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmClrMeasurementStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmClrMeasurementStatus.setDescription('This attribute displays the Cell Loss Ratio (CLR) measurement status of the connection. inactive indicates the test is inactive. activating indicates the test is activating. active indicates the test is in progress activationFailed indicates the test failed to be activated. Refer to the failureCause attribute for failure cause.')
mscAtmIfVccPmArMeasurementStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("inactive", 0), ("activating", 1), ("active", 2), ("activationFailed", 3))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmArMeasurementStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmArMeasurementStatus.setDescription('This attribute indicates the Availability Ratio (AR) measurement status of the connection. inactive indicates the test is inactive. activating indicates the test is activating. active indicates the test is in progress activationFailed indicates the test failed to be activated. Refer to the failureCause attribute for the failure cause.')
mscAtmIfVccPmFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("noError", 0), ("unknownCause", 1), ("softwareResourcesUnavailable", 2), ("hardwareResourcesUnavailable", 3), ("remoteEndNoResponse", 4), ("activationCollision", 5), ("remoteEndRejectedActivation", 6), ("pcrUnsupported", 7), ("nextHopCardUnsupported", 8))).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFailureCause.setDescription('This attribute indicates the failure cause of Performance Monitoring (PM) measurements. The following are possible causes: noError indicates no error. unknownCause indicates unknown failure cause. softwareResourcesUnavailable indicates software resources reserved for a maximum of 255 active PMs on the local FP card have been used up. hardwareResourcesUnavailable indicates hardware resources reserved for a maximum of 512 active PMs CLR have been used up on the Link Side local card. remoteEndNoResponse indicates no response from remote end. activationCollision indicates activation collision was detected. Usually this is caused by both ends of the connection being provisioned to request PM. Only one end should be so provisioned. remoteEndRejectedActivation indicates the remote end has rejected an activation request. Usually this is due to the remote end reaching a resource limit. pcrUnsupported indicates the Tx or Rx PCR was out of range between 0 and 409600. nextHopCardUnsupported indicates the next hop card type is not supported.')
mscAtmIfVccPmFwdClrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11), )
if mibBuilder.loadTexts: mscAtmIfVccPmFwdClrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdClrTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains Cell Loss Ratio (CLR) measurements for the forward direction of the connection. The local end is always the provisioned end which sends the activation request, and the remote end is the end which receives the activation request.')
mscAtmIfVccPmFwdClrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccPmFwdClrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdClrEntry.setDescription('An entry in the mscAtmIfVccPmFwdClrTable.')
mscAtmIfVccPmFwdLastSampleUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsRx0.setDescription('This attribute displays the number of cells with CLP=0 received at the remote end over the last sample period.')
mscAtmIfVccPmFwdLastSampleUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsTx0.setDescription('This attribute displays the number of cells with CLP=0 transmitted from the local end over the last sample period.')
mscAtmIfVccPmFwdLastSampleClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 3), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleClr0.setDescription('This attribute displays CLR for CLP=0 traffic over the last sample period.')
mscAtmIfVccPmFwdLastSampleUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0+1 received at the remote end over the last sample period.')
mscAtmIfVccPmFwdLastSampleUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the local end over the last sample period.')
mscAtmIfVccPmFwdLastSampleClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 6), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdLastSampleClr01.setDescription('This attribute indicates CLR for CLP=0+1 traffic over the last sample period.')
mscAtmIfVccPmFwdTotalClrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalClrInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalClrInterval.setDescription('This attribute indicates the total time duration over which Cell Loss Ratio (CLR) has been calculated.')
mscAtmIfVccPmFwdTotalUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsRx0.setDescription('This attribute indicates the number of cells with CLP=0 received at the remote end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVccPmFwdTotalUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsTx0.setDescription('This attribute indicates the number of cells with CLP=0 transmitted from the local end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVccPmFwdAverageClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 10), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdAverageClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdAverageClr0.setDescription('This attribute indicates the average CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVccPmFwdMaximumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 11), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMaximumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMaximumClr0.setDescription('This attribute indicates the maximum CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVccPmFwdMinimumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 12), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMinimumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMinimumClr0.setDescription('This attribute indicates the minimum CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVccPmFwdTotalUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0+1 received at the remote end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVccPmFwdTotalUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdTotalUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the local end over the total CLR measurement interval.')
mscAtmIfVccPmFwdAverageClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 15), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdAverageClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdAverageClr01.setDescription('This attribute displays the average CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVccPmFwdMaximumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 16), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMaximumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMaximumClr01.setDescription('This attribute indicates the maximum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVccPmFwdMinimumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 17), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMinimumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdMinimumClr01.setDescription('This attribute indicates the minimum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVccPmFwdPmCellDiscardCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 11, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmFwdPmCellDiscardCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmFwdPmCellDiscardCount.setDescription('This attribute indicates the total number of Performance Monitoring (PM) cells discarded.')
mscAtmIfVccPmBwdClrTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12), )
if mibBuilder.loadTexts: mscAtmIfVccPmBwdClrTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdClrTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains Cell Loss Ratio (CLR) measurements for the backward direction of the connection. The local end is always the provisioned end which sends the activation request, and the remote end is the end which receives the activation request.')
mscAtmIfVccPmBwdClrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccPmBwdClrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdClrEntry.setDescription('An entry in the mscAtmIfVccPmBwdClrTable.')
mscAtmIfVccPmBwdLastSampleUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 1), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsRx0.setDescription('This attribute indicates the number of cells with CLP=0 received at the local end over the last sample period.')
mscAtmIfVccPmBwdLastSampleUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 2), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsTx0.setDescription('This attribute indicates the number of cells with CLP=0 transmitted from the remote end over the last sample period.')
mscAtmIfVccPmBwdLastSampleClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 3), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleClr0.setDescription('This attribute indicates CLR for CLP=0 traffic over the last sample period.')
mscAtmIfVccPmBwdLastSampleUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 4), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0+1 received at the local end over the last sample period.')
mscAtmIfVccPmBwdLastSampleUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 5), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the remote end over the last sample period.')
mscAtmIfVccPmBwdLastSampleClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 6), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdLastSampleClr01.setDescription('This attribute display CLRfor CLP=0+1 traffic over the last sample period.')
mscAtmIfVccPmBwdTotalClrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalClrInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalClrInterval.setDescription('This attribute indicates the total time duration over which Cell Loss Ratio (CLR) measurement has been calculated.')
mscAtmIfVccPmBwdTotalUserCellsRx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 8), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsRx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsRx0.setDescription('This attribute indicates the number of cells with CLP=0 received at the local end over the total Cell Loss Ratio (CLR) measurement interval in the backward direction.')
mscAtmIfVccPmBwdTotalUserCellsTx0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 9), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsTx0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsTx0.setDescription('This attribute indicates the number of cells with CLP=0 transmitted from the remote end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVccPmBwdAverageClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 10), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdAverageClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdAverageClr0.setDescription('This attribute indicates the average CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVccPmBwdMaximumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 11), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMaximumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMaximumClr0.setDescription('This attribute indicates the maximum CLR for CLP=0 traffi calculated for the total measurement interval.')
mscAtmIfVccPmBwdMinimumClr0 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 12), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMinimumClr0.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMinimumClr0.setDescription('This attribute indicates the minimum CLR for CLP=0 traffic calculated for the total measurement interval.')
mscAtmIfVccPmBwdTotalUserCellsRx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 13), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsRx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsRx01.setDescription('This attribute indicates the number of cells with CLP=0 received at the local end over the total Cell Loss Ratio (CLR) measurement interval.')
mscAtmIfVccPmBwdTotalUserCellsTx01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 14), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsTx01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdTotalUserCellsTx01.setDescription('This attribute indicates the number of cells with CLP=0+1 transmitted from the remote end over the total Cell Loss Ratio (CLR) measurement interval .')
mscAtmIfVccPmBwdAverageClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 15), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdAverageClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdAverageClr01.setDescription('This attribute displays the average CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVccPmBwdMaximumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 16), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMaximumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMaximumClr01.setDescription('This attribute indicates the maximum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVccPmBwdMinimumClr01 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 17), FixedPoint9().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMinimumClr01.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdMinimumClr01.setDescription('This attribute indicates the minimum CLR for CLP=0+1 traffic calculated for the total measurement interval.')
mscAtmIfVccPmBwdPmCellDiscardCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 12, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmBwdPmCellDiscardCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmBwdPmCellDiscardCount.setDescription('This attribute indicates the total number of Performance Monitoring (PM) cells discarded.')
mscAtmIfVccPmArTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 13), )
if mibBuilder.loadTexts: mscAtmIfVccPmArTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmArTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains Availability Ratio (AR) measurements of the connection.')
mscAtmIfVccPmArEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVccPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVccPmArEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmArEntry.setDescription('An entry in the mscAtmIfVccPmArTable.')
mscAtmIfVccPmCurrentAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("notApplicable", 0), ("available", 1), ("unavailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmCurrentAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmCurrentAvailabilityStatus.setDescription('This attribute indicates the current status of the bidirectional connection for purposes of Availability Ratio (AR) computation. notApplicable means AR measurement was not requested on this connection. available means AR is running and considers the connection available (that is, the arAvailableTime attribute is being incremented). unavailable means AR measurement was requested but the connection is currently unavailable.')
mscAtmIfVccPmArTotalTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 13, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmArTotalTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmArTotalTime.setDescription('This attribute indicates the total time used for calculating Availability Ratio (AR) of the bi-directional connection.')
mscAtmIfVccPmArAvailableTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmArAvailableTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmArAvailableTime.setDescription('This attribute indicates the total time the connection was available.')
mscAtmIfVccPmArAvailabilityRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 5, 14, 13, 1, 4), FixedPoint7().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVccPmArAvailabilityRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVccPmArAvailabilityRatio.setDescription('This attribute indicates the ratio of network availability representing the time to the total time of the connection.')
mscAtmIfNAcct = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8))
mscAtmIfNAcctRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 1), )
if mibBuilder.loadTexts: mscAtmIfNAcctRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfNAcct components.')
mscAtmIfNAcctRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfNAcctIndex"))
if mibBuilder.loadTexts: mscAtmIfNAcctRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfNAcct component.')
mscAtmIfNAcctRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfNAcctRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfNAcct components. These components can be added and deleted.')
mscAtmIfNAcctComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfNAcctComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfNAcctStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfNAcctStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctStorageType.setDescription('This variable represents the storage type value for the mscAtmIfNAcct tables.')
mscAtmIfNAcctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfNAcctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctIndex.setDescription('This variable represents the index for the mscAtmIfNAcct tables.')
mscAtmIfNAcctProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 10), )
if mibBuilder.loadTexts: mscAtmIfNAcctProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctProvTable.setDescription('This group contains the provisionable attributes for PVC accounting.')
mscAtmIfNAcctProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfNAcctIndex"))
if mibBuilder.loadTexts: mscAtmIfNAcctProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctProvEntry.setDescription('An entry in the mscAtmIfNAcctProvTable.')
mscAtmIfNAcctAccountCollection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 10, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfNAcctAccountCollection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctAccountCollection.setDescription('This attribute specifies the reason(s) for which accounting data is collected: billing, test, study, audit or force. If the set of reasons is not empty then accounting records will be generated by this interface in the following situations: - on a TODA (time of day accounting) changeover if TODA is enabled; - every 12 hours (per connection) if TODA is disabled; - when the PVC is deleted (a call record is generated with final cell counts). If none of the reasons is present, then accounting will be suppressed for all PVCs on this interface. Accounting can be suppressed on individual PVCs by specifying a null correlationTag attribute in the AtmIf NAcct component. The reason for collection is recorded in the accounting record, in the attribute callingCollectReason or calledCollectReason, as appropriate. Description of bits: bill(0) test(1) study(2) audit(3) force(4)')
mscAtmIfNAcctAccountConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("origTerm", 0), ("intermediate", 1))).clone('origTerm')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfNAcctAccountConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctAccountConnectionType.setDescription('This attribute specifies whether accounting records generated for the PVCs on this interface should be marked as originating, terminating or intermediate. This attribute, in combination with the direction of the call, determines the value of attribute connPointType of the accounting record. It may be used by downstream accounting processing to correlate the records. If the value is origTerm then the value of attribute connPointType in the accounting records generated for incoming calls will be originating and records generated for outgoing calls will be terminating. If the value is intermediate then the value of attribute connPointType in the accounting records generated for all calls will be intermediate.')
mscAtmIfNAcctAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfNAcctAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctAccountClass.setDescription('This attribute specifies the accounting class associated with the PVCs on this interface. Its meaning is determined by the network operator. Its value is recorded in the accounting records generated by this interface, in the attributes, callingServiceType and calledServiceType.')
mscAtmIfNAcctServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 8, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfNAcctServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfNAcctServiceExchange.setDescription('This attribute specifies the data service exchange associated with this interface. Its meaning is determined by the network operator. Its value is recorded in the accounting records generated by this interface, in the attributes, callingDse and calledDse.')
mscAtmIfVpt = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9))
mscAtmIfVptRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 1), )
if mibBuilder.loadTexts: mscAtmIfVptRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVpt components.')
mscAtmIfVptRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"))
if mibBuilder.loadTexts: mscAtmIfVptRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVpt component.')
mscAtmIfVptRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVpt components. These components can be added and deleted.')
mscAtmIfVptComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVpt tables.')
mscAtmIfVptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)))
if mibBuilder.loadTexts: mscAtmIfVptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptIndex.setDescription('This variable represents the index for the mscAtmIfVpt tables.')
mscAtmIfVptStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 100), )
if mibBuilder.loadTexts: mscAtmIfVptStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscAtmIfVptStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"))
if mibBuilder.loadTexts: mscAtmIfVptStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStateEntry.setDescription('An entry in the mscAtmIfVptStateTable.')
mscAtmIfVptAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVptOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVptUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVptOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 110), )
if mibBuilder.loadTexts: mscAtmIfVptOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
mscAtmIfVptOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"))
if mibBuilder.loadTexts: mscAtmIfVptOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptOperEntry.setDescription('An entry in the mscAtmIfVptOperTable.')
mscAtmIfVptConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
mscAtmIfVptStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120), )
if mibBuilder.loadTexts: mscAtmIfVptStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc or Vpt component.')
mscAtmIfVptStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"))
if mibBuilder.loadTexts: mscAtmIfVptStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatusEntry.setDescription('An entry in the mscAtmIfVptStatusTable.')
mscAtmIfVptOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
mscAtmIfVptLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
mscAtmIfVptTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
mscAtmIfVptSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVptSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
mscAtmIfVptEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVptRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
mscAtmIfVptAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptAisState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVptRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVptTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130), )
if mibBuilder.loadTexts: mscAtmIfVptTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
mscAtmIfVptTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTrafficEntry.setDescription('An entry in the mscAtmIfVptTrafficTable.')
mscAtmIfVptTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVptTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
mscAtmIfVptFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
mscAtmIfVptTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
mscAtmIfVptHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVptRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVptRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
mscAtmIfVptBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
mscAtmIfVptBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVptClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
mscAtmIfVptBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
mscAtmIfVptTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVptRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVptBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVptBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVptStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140), )
if mibBuilder.loadTexts: mscAtmIfVptStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
mscAtmIfVptStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"))
if mibBuilder.loadTexts: mscAtmIfVptStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsEntry.setDescription('An entry in the mscAtmIfVptStatsTable.')
mscAtmIfVptStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCell.setDescription('This attribute counts the number of cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCellClp.setDescription('This attribute counts the number of cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 294), )
if mibBuilder.loadTexts: mscAtmIfVptTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVptTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 294, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxTdpEntry.setDescription('An entry in the mscAtmIfVptTxTdpTable.')
mscAtmIfVptTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxTdpIndex.setDescription('This variable represents the mscAtmIfVptTxTdpTable specific index for the mscAtmIfVptTxTdpTable.')
mscAtmIfVptTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptTxTdpTable.')
mscAtmIfVptRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 295), )
if mibBuilder.loadTexts: mscAtmIfVptRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVptRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 295, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxTdpEntry.setDescription('An entry in the mscAtmIfVptRxTdpTable.')
mscAtmIfVptRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVptRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxTdpIndex.setDescription('This variable represents the mscAtmIfVptRxTdpTable specific index for the mscAtmIfVptRxTdpTable.')
mscAtmIfVptRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptRxTdpTable.')
mscAtmIfVptTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 352), )
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
mscAtmIfVptTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 352, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshEntry.setDescription('An entry in the mscAtmIfVptTxQThreshTable.')
mscAtmIfVptTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshIndex.setDescription('This variable represents the mscAtmIfVptTxQThreshTable specific index for the mscAtmIfVptTxQThreshTable.')
mscAtmIfVptTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVptTxQThreshTable.')
mscAtmIfVptFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 357), )
if mibBuilder.loadTexts: mscAtmIfVptFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 357, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptFqpEntry.setDescription('An entry in the mscAtmIfVptFqpTable.')
mscAtmIfVptFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptFqpIndex.setDescription('This variable represents the mscAtmIfVptFqpTable specific index for the mscAtmIfVptFqpTable.')
mscAtmIfVptFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptFqpTable.')
mscAtmIfVptBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 358), )
if mibBuilder.loadTexts: mscAtmIfVptBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 358, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBqpEntry.setDescription('An entry in the mscAtmIfVptBqpTable.')
mscAtmIfVptBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBqpIndex.setDescription('This variable represents the mscAtmIfVptBqpTable specific index for the mscAtmIfVptBqpTable.')
mscAtmIfVptBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptBqpTable.')
mscAtmIfVptVpd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2))
mscAtmIfVptVpdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVpdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVpd components.')
mscAtmIfVptVpdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVpd component.')
mscAtmIfVptVpdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVpd components. These components cannot be added nor deleted.')
mscAtmIfVptVpdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVpdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVpd tables.')
mscAtmIfVptVpdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVpdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdIndex.setDescription('This variable represents the index for the mscAtmIfVptVpd tables.')
mscAtmIfVptVpdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVpdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
mscAtmIfVptVpdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdLbkEntry.setDescription('An entry in the mscAtmIfVptVpdLbkTable.')
mscAtmIfVptVpdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
mscAtmIfVptVpdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
mscAtmIfVptVpdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
mscAtmIfVptVpdMCastConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipointRoot", 1), ("pointToMultipointLeaf", 2))).clone('pointToPoint')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdMCastConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdMCastConnectionType.setDescription('This attribute is introduced to exist temporarily to pass to AtmIf the connection type defined under Vcc or Vpc. This attribute will be obsoleted once a more elegant solution is available.')
mscAtmIfVptVpdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
mscAtmIfVptVpdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTrafficEntry.setDescription('An entry in the mscAtmIfVptVpdTrafficTable.')
mscAtmIfVptVpdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVptVpdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
mscAtmIfVptVpdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVptVpdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
mscAtmIfVptVpdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
mscAtmIfVptVpdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
mscAtmIfVptVpdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVptVpdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptVpdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVptVpdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
mscAtmIfVptVpdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVptVpdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVptVpdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVpdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVptVpdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVpdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
mscAtmIfVptVpdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
mscAtmIfVptVpdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 111), )
if mibBuilder.loadTexts: mscAtmIfVptVpdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
mscAtmIfVptVpdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 111, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdAcctEntry.setDescription('An entry in the mscAtmIfVptVpdAcctTable.')
mscAtmIfVptVpdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
mscAtmIfVptVpdProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 112), )
if mibBuilder.loadTexts: mscAtmIfVptVpdProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdProvTable.setDescription('This group contains the provisionable ATM Virtual Path Descriptor attributes for a Vpt component.')
mscAtmIfVptVpdProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 112, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdProvEntry.setDescription('An entry in the mscAtmIfVptVpdProvTable.')
mscAtmIfVptVpdVptType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 112, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("basic", 0), ("standard", 1))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdVptType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdVptType.setDescription('This attribute specifies the type of the Vpt. On CQC-based ATM FPs all Vpts must be basic. Vpts on ATM IP FPs may be of any type. A value of basic configures one level of traffic management (TM) for the VPT, at the VC level. VCs within the VP are treated like independent VCC connections, and thus, are scheduled the same as other VCs under the AtmIf, with no scheduling done for the VP itself. A value of standard configures two levels of TM for the VPT, one level for VP TM and one level for VC level TM. VCs within the VP use weighted fair queueing (standard VPT VCC scheduling) to schedule VCs within the VPT, with VCs differentiated as either real-time (CBR, rt-VBR) or non-real-time (nrt-VBR, UBR) connections. The VP itself has a full range of emission scheduling and service category differentiation available between itself and the other connections under the AtmIf.')
mscAtmIfVptVpdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 297), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfVptVpdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 297, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpEntry.setDescription('An entry in the mscAtmIfVptVpdTxTdpTable.')
mscAtmIfVptVpdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpIndex.setDescription('This variable represents the mscAtmIfVptVpdTxTdpTable specific index for the mscAtmIfVptVpdTxTdpTable.')
mscAtmIfVptVpdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdTxTdpTable.')
mscAtmIfVptVpdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 298), )
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
mscAtmIfVptVpdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 298, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpEntry.setDescription('An entry in the mscAtmIfVptVpdRxTdpTable.')
mscAtmIfVptVpdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpIndex.setDescription('This variable represents the mscAtmIfVptVpdRxTdpTable specific index for the mscAtmIfVptVpdRxTdpTable.')
mscAtmIfVptVpdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdRxTdpTable.')
mscAtmIfVptVpdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 359), )
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVpdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 359, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpEntry.setDescription('An entry in the mscAtmIfVptVpdFqpTable.')
mscAtmIfVptVpdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpIndex.setDescription('This variable represents the mscAtmIfVptVpdFqpTable specific index for the mscAtmIfVptVpdFqpTable.')
mscAtmIfVptVpdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdFqpTable.')
mscAtmIfVptVpdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 360), )
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVpdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 360, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpEntry.setDescription('An entry in the mscAtmIfVptVpdBqpTable.')
mscAtmIfVptVpdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpIndex.setDescription('This variable represents the mscAtmIfVptVpdBqpTable specific index for the mscAtmIfVptVpdBqpTable.')
mscAtmIfVptVpdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVpdBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdBqpTable.')
mscAtmIfVptVpdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2))
mscAtmIfVptVpdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVpdTm components.')
mscAtmIfVptVpdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVpdTm component.')
mscAtmIfVptVpdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVpdTm components. These components cannot be added nor deleted.')
mscAtmIfVptVpdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVpdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVpdTm tables.')
mscAtmIfVptVpdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVpdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmIndex.setDescription('This variable represents the index for the mscAtmIfVptVpdTm tables.')
mscAtmIfVptVpdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
mscAtmIfVptVpdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmProvEntry.setDescription('An entry in the mscAtmIfVptVpdTmProvTable.')
mscAtmIfVptVpdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
mscAtmIfVptVpdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVptVpdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. An value other than sameAsCa may be specified only for ATM IP and 1pOC48SmSrAtm cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. For the 1pOC48SmSrAtm card, this attribute is used to set the per VC utilization limit. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm or Vpt txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
mscAtmIfVptVpdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
mscAtmIfVptVpdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
mscAtmIfVptVpdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVptVpdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptVpdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. Traffic shaping is not available on the 1pOC12SmLrAtm card, therefore this attribute is ignored. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
mscAtmIfVptVpdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
mscAtmIfVptVpdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfVptVpdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
mscAtmIfVptVpdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
mscAtmIfVptVpdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVptVpdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVpdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVptVpdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVpdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
mscAtmIfVptVpdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
mscAtmIfVptVpdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. For the 1pOC12SmLrAtm card, the only allowable values are sameAsCa or abrSwitch. If abrSwitch is selected, EFCI marking behavior is implemented. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
mscAtmIfVptVpdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 456), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
mscAtmIfVptVpdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpEntry.setDescription('An entry in the mscAtmIfVptVpdTmTxTdpTable.')
mscAtmIfVptVpdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVptVpdTmTxTdpTable specific index for the mscAtmIfVptVpdTmTxTdpTable.')
mscAtmIfVptVpdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdTmTxTdpTable.')
mscAtmIfVptVpdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 457), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
mscAtmIfVptVpdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpEntry.setDescription('An entry in the mscAtmIfVptVpdTmRxTdpTable.')
mscAtmIfVptVpdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVptVpdTmRxTdpTable specific index for the mscAtmIfVptVpdTmRxTdpTable.')
mscAtmIfVptVpdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdTmRxTdpTable.')
mscAtmIfVptVpdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 458), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVpdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpEntry.setDescription('An entry in the mscAtmIfVptVpdTmFqpTable.')
mscAtmIfVptVpdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpIndex.setDescription('This variable represents the mscAtmIfVptVpdTmFqpTable specific index for the mscAtmIfVptVpdTmFqpTable.')
mscAtmIfVptVpdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdTmFqpTable.')
mscAtmIfVptVpdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 459), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVpdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpEntry.setDescription('An entry in the mscAtmIfVptVpdTmBqpTable.')
mscAtmIfVptVpdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpIndex.setDescription('This variable represents the mscAtmIfVptVpdTmBqpTable specific index for the mscAtmIfVptVpdTmBqpTable.')
mscAtmIfVptVpdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVpdTmBqpTable.')
mscAtmIfVptVpdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2))
mscAtmIfVptVpdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVpdTmAbr components.')
mscAtmIfVptVpdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVpdTmAbr component.')
mscAtmIfVptVpdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVpdTmAbr components. These components can be added and deleted.')
mscAtmIfVptVpdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVpdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVpdTmAbr tables.')
mscAtmIfVptVpdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVptVpdTmAbr tables.')
mscAtmIfVptVpdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
mscAtmIfVptVpdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVpdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrProvEntry.setDescription('An entry in the mscAtmIfVptVpdTmAbrProvTable.')
mscAtmIfVptVpdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
mscAtmIfVptVpdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
mscAtmIfVptVpdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
mscAtmIfVptVpdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute.')
mscAtmIfVptVpdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVpdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr.')
mscAtmIfVptCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5))
mscAtmIfVptCARowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 1), )
if mibBuilder.loadTexts: mscAtmIfVptCARowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptCA components.')
mscAtmIfVptCARowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCARowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptCA component.')
mscAtmIfVptCARowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCARowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptCA components. These components can be added and deleted.')
mscAtmIfVptCAComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptCAStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptCA tables.')
mscAtmIfVptCAIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptCAIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAIndex.setDescription('This variable represents the index for the mscAtmIfVptCA tables.')
mscAtmIfVptCAProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 100), )
if mibBuilder.loadTexts: mscAtmIfVptCAProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) attributes for the ATM connections associated with a Virtual Path Terminator. Note that the names of some of the attributes follow the conventions of UNI 4.0 for forward compatibility reasons. This does not imply conformance in general with the UNI 4.0 specification. The provisioned attributes of this ConnectionAdministrator will override those of the AtmIf CA, for all connections associated with this Vpt. Any attributes of the AtmIf CA that cannot be overridden in the Vpt CA affect all connections, including Vpt Vccs.')
mscAtmIfVptCAProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAProvEntry.setDescription('An entry in the mscAtmIfVptCAProvTable.')
mscAtmIfVptCAMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16384), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAMaxVccs.setDescription('This attribute specifies the maximum number of Vccs that can be associated with this Vpt. The value must not exceed the maxVccs attribute of the Atmif CA. If this attribute is set to autoConfigure, then on 32 port Multi- Service Access cards its value is configured as 100, and on all other cards it is 255. VALUES ( 65535 = autoConfigure )')
mscAtmIfVptCAPermittedAtmServiceCategories = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 100, 1, 25), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAPermittedAtmServiceCategories.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPermittedAtmServiceCategories.setDescription('This attribute specifies which ATM service categories are permitted on this Vpt for SVCs. The value of this attribute does not affect control Vccs, such as signalling and ILMI channels. If the value is empty, no SVCs are permitted to use this Vpt. Description of bits: unspecifiedBitRate(0) constantBitRate(1) rtVariableBitRate(2) nrtVariableBitRate(3)')
mscAtmIfVptCAOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 110), )
if mibBuilder.loadTexts: mscAtmIfVptCAOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAOperTable.setDescription('This group contains operational attributes giving statistics about the ATM connections associated with a Virtual Path Terminator (VPT).')
mscAtmIfVptCAOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAOperEntry.setDescription('An entry in the mscAtmIfVptCAOperTable.')
mscAtmIfVptCAActualMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 110, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAActualMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAActualMaxVccs.setDescription('This attribute indicates the maximum number of VCC connections that can be supported on this Vpt. The value includes both provisioned and dynamic connections. The value is determined from the provisioned attribute maxVccs.')
mscAtmIfVptCAPermanentVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAPermanentVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPermanentVccs.setDescription('This attribute indicates the number of permanent Vccs that are currently associated with this Vpt.')
mscAtmIfVptCASwitchedVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 110, 1, 30), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCASwitchedVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCASwitchedVccs.setDescription('This attribute indicates the number of switched Vccs that are currently associated with this Vpt.')
mscAtmIfVptCATroubledVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 110, 1, 70), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCATroubledVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCATroubledVccs.setDescription("This attribute indicates the number of troubled Vccs associated with this Vpt. A Vcc is 'troubled' if its operational troubled attribute has the value yes.")
mscAtmIfVptCAConnectionPoolUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 110, 1, 81), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 10752))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAConnectionPoolUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAConnectionPoolUsage.setDescription('This attribute indicates the number of allocated VCCs associated with this VPT. Each of these VCCs uses a connection out of the pool defined by the Arc totalConnectionPoolAvailable attribute.')
mscAtmIfVptCAPoolAvailBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 460), )
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwTable.setDescription('This attribute indicates the total available bandwidth in the corresponding bandwidthPool. A non-zero number indicates that there is still bandwidth available in the pool which has not been allocated.')
mscAtmIfVptCAPoolAvailBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 460, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAPoolAvailBwIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwEntry.setDescription('An entry in the mscAtmIfVptCAPoolAvailBwTable.')
mscAtmIfVptCAPoolAvailBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 460, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwIndex.setDescription('This variable represents the mscAtmIfVptCAPoolAvailBwTable specific index for the mscAtmIfVptCAPoolAvailBwTable.')
mscAtmIfVptCAPoolAvailBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 460, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAvailBwValue.setDescription('This variable represents an individual value for the mscAtmIfVptCAPoolAvailBwTable.')
mscAtmIfVptCABwPoolTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 461), )
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolTable.setDescription('Total bandwidth capacity is partitioned into five bandwidth pools. This attribute specifies the percentage of Vpt bandwidth that is allowed for each pool. The percentage for each pool ranges from 0% to 12,800%. This allows for both under and over subscription of the VPT bandwidth. Under subscription occurs when the sum of the percentages assigned to the five pools is less than 100%. Over subscription occurs when the sum of the percentages for the five pools exceeds 100%.')
mscAtmIfVptCABwPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 461, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCABwPoolIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolEntry.setDescription('An entry in the mscAtmIfVptCABwPoolTable.')
mscAtmIfVptCABwPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 461, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolIndex.setDescription('This variable represents the mscAtmIfVptCABwPoolTable specific index for the mscAtmIfVptCABwPoolTable.')
mscAtmIfVptCABwPoolValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 461, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 12800))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCABwPoolValue.setDescription('This variable represents an individual value for the mscAtmIfVptCABwPoolTable.')
mscAtmIfVptCAPoolProvBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 462), )
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwTable.setDescription('This attribute indicates the total provisioned bandwidth from the corresponding bandwidthPool. Its value is the sum of the equivalent cell rates (ECR) of the provisioned connections.')
mscAtmIfVptCAPoolProvBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 462, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAPoolProvBwIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwEntry.setDescription('An entry in the mscAtmIfVptCAPoolProvBwTable.')
mscAtmIfVptCAPoolProvBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 462, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwIndex.setDescription('This variable represents the mscAtmIfVptCAPoolProvBwTable specific index for the mscAtmIfVptCAPoolProvBwTable.')
mscAtmIfVptCAPoolProvBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 462, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolProvBwValue.setDescription('This variable represents an individual value for the mscAtmIfVptCAPoolProvBwTable.')
mscAtmIfVptCAPoolRequBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 463), )
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwTable.setDescription('This attribute indicates the total requested bandwidth from the corresponding bandwidthPool. This attribute does not include the bandwidth for ATM networking signalling connections. Its value is the sum of the equivalent cell rates (ECR) for connections which are admitted and connections which are requesting admission, but have not yet been admitted.')
mscAtmIfVptCAPoolRequBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 463, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAPoolRequBwIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwEntry.setDescription('An entry in the mscAtmIfVptCAPoolRequBwTable.')
mscAtmIfVptCAPoolRequBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 463, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwIndex.setDescription('This variable represents the mscAtmIfVptCAPoolRequBwTable specific index for the mscAtmIfVptCAPoolRequBwTable.')
mscAtmIfVptCAPoolRequBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 463, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolRequBwValue.setDescription('This variable represents an individual value for the mscAtmIfVptCAPoolRequBwTable.')
mscAtmIfVptCAPoolAdmitBwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 464), )
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwTable.setDescription('This attribute indicates the total admitted bandwidth in the corresponding bandwidthPool. Its value is the sum of the equivalent cell rates (ECR) of the admitted connections. This attribute does not include the bandwidth for ATM networking signalling connections.')
mscAtmIfVptCAPoolAdmitBwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 464, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAPoolAdmitBwIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwEntry.setDescription('An entry in the mscAtmIfVptCAPoolAdmitBwTable.')
mscAtmIfVptCAPoolAdmitBwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 464, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwIndex.setDescription('This variable represents the mscAtmIfVptCAPoolAdmitBwTable specific index for the mscAtmIfVptCAPoolAdmitBwTable.')
mscAtmIfVptCAPoolAdmitBwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 464, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmitBwValue.setDescription('This variable represents an individual value for the mscAtmIfVptCAPoolAdmitBwTable.')
mscAtmIfVptCAPoolAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 465), )
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsTable.setDescription('This attribute indicates the total number of connections which are currently admitted in the corresponding bandwidthPool. This attribute does not include ATM networking signalling connections.')
mscAtmIfVptCAPoolAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 465, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAPoolAdmConnsIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsEntry.setDescription('An entry in the mscAtmIfVptCAPoolAdmConnsTable.')
mscAtmIfVptCAPoolAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 465, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsIndex.setDescription('This variable represents the mscAtmIfVptCAPoolAdmConnsTable specific index for the mscAtmIfVptCAPoolAdmConnsTable.')
mscAtmIfVptCAPoolAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 465, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolAdmConnsValue.setDescription('This variable represents an individual value for the mscAtmIfVptCAPoolAdmConnsTable.')
mscAtmIfVptCAPoolWaitAdmConnsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 466), )
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsTable.setDescription('This attribute indicates the total number of connections which are currently admitted in the corresponding bandwidthPool. This attribute does not include ATM networking signalling connections.')
mscAtmIfVptCAPoolWaitAdmConnsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 466, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAPoolWaitAdmConnsIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsEntry.setDescription('An entry in the mscAtmIfVptCAPoolWaitAdmConnsTable.')
mscAtmIfVptCAPoolWaitAdmConnsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 466, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsIndex.setDescription('This variable represents the mscAtmIfVptCAPoolWaitAdmConnsTable specific index for the mscAtmIfVptCAPoolWaitAdmConnsTable.')
mscAtmIfVptCAPoolWaitAdmConnsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 466, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAPoolWaitAdmConnsValue.setDescription('This variable represents an individual value for the mscAtmIfVptCAPoolWaitAdmConnsTable.')
mscAtmIfVptCACbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2))
mscAtmIfVptCACbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptCACbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptCACbr components.')
mscAtmIfVptCACbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCACbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCACbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptCACbr component.')
mscAtmIfVptCACbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCACbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptCACbr components. These components can be added.')
mscAtmIfVptCACbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCACbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptCACbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCACbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptCACbr tables.')
mscAtmIfVptCACbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfVptCACbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrIndex.setDescription('This variable represents the index for the mscAtmIfVptCACbr tables.')
mscAtmIfVptCACbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVptCACbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) and Usage Parameter Control (UPC) attributes for the CBR ATM connections managed by this Vpt. Any attributes of the AtmIf CA Cbr that cannot be overridden in the Vpt CA Cbr affect all connections, including Vpt Vccs.')
mscAtmIfVptCACbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCACbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCACbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrProvEntry.setDescription('An entry in the mscAtmIfVptCACbrProvTable.')
mscAtmIfVptCACbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCACbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the constant bit rate (CBR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to CBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfVptCACbrCdvt = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 100, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 10000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCACbrCdvt.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrCdvt.setDescription("This attribute specifies the default cell delay variation tolerance (CDVT) for connections of the CBR service category. An override to this default may be specified for a provisioned connection under the Vcd Tm or Vpd Tm component. This attribute is used by the CAC function to compute the equivalent cell rate (ECR) required by a given CBR connection. The larger the value of CDVT, the larger is its ECR. If Usage Parameter Control (UPC) is enabled for a connection, CDVT is used by the UPC function on the ingress to decide whether a cell is conforming or non-conforming based on the connection's traffic descriptor type. The larger the CDVT value, the more tolerant is the UPC of bandwidth usage beyond the traffic contract.")
mscAtmIfVptCACbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCACbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrCdv.setDescription("This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to connections associated with this Vpt for CBR traffic. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the ATM connection's CDV requirement. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.")
mscAtmIfVptCACbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCACbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to all connections associated with this Vpt for CBR traffic. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the ATM connection's MaxCTD requirement.")
mscAtmIfVptCACbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 2, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCACbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCACbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for CBR traffic. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then Cbr cellLossRatio = 10. This number must be the same as the RtVbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The Cbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for CBR connections. There is a trade-off between the service category CLR and the achievable Vpt bandwidth utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E- 10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower Vpt bandwidth utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for CBR connections, and CAC is effectively turned off. All CBR connections are admitted.')
mscAtmIfVptCARtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3))
mscAtmIfVptCARtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptCARtVbr components.')
mscAtmIfVptCARtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCARtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptCARtVbr component.')
mscAtmIfVptCARtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptCARtVbr components. These components can be added.')
mscAtmIfVptCARtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptCARtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptCARtVbr tables.')
mscAtmIfVptCARtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrIndex.setDescription('This variable represents the index for the mscAtmIfVptCARtVbr tables.')
mscAtmIfVptCARtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 100), )
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) and UPC attributes for the rt- VBR ATM connections associated with this Vpt. Any attributes of the AtmIf CA RtVbr that cannot be overridden in the Vpt CA RtVbr affect all connections, including Vpt Vccs.')
mscAtmIfVptCARtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCARtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrProvEntry.setDescription('An entry in the mscAtmIfVptCARtVbrProvTable.')
mscAtmIfVptCARtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the real-time variable bit rate (rt-VBR) service category. The percentage of Vpt capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to rt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the Vpt CA.')
mscAtmIfVptCARtVbrCdv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 100, 1, 30), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1268)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrCdv.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrCdv.setDescription('This attribute specifies the peak-to-peak cell delay variation (CDV) which is contributed to all rt-VBR connections associated with this Vpt. The CDV is a measure of the delay jitter introduced mostly by traffic buffering and cell scheduling. The value of this attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the CDV requirement for that connection. If so, the value of this attribute is added to the cumulative CDV field of the extended QoS information element.')
mscAtmIfVptCARtVbrMaxCtd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 100, 1, 40), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrMaxCtd.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrMaxCtd.setDescription("This attribute specifies the maximum cell transfer delay (MaxCTD) which is applied to all rt-VBR connections associated with this Vpt. MaxCTD is the sum of the fixed delay and the CDV. The components of the fixed delay include propagation delay through the physical media, delays induced by the transmission system, and fixed components of switch processing delay. This attribute is used by PNNI in the Resource Availability Information Group (RAIG) topology updates and route selection. It is also used by CAC at connection set-up time to determine whether this Vpt can meet the ATM connection's MaxCTD requirement.")
mscAtmIfVptCARtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 3, 100, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCARtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for rt- VBR traffic. The number is the negative logarithm (base 10) of the CLR. For example, if the target CLR = 1E-10 then RtVbr cellLossRatio = 10. This number must be the same as the Cbr cellLossRatio since CBR and rt-VBR traffic have the same discard priority. The RtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for rt-VBR connections. This number must be less than or equal to the NrtVbr cellLossRatio, since rt-VBR traffic has a higher discard priority. There is a trade-off between the service category CLR and the achievable Vpt bandwidth utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E- 10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower Vpt bandwidth utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for rt-VBR connections and CAC is effectively turned off. All rt-VBR connections are admitted.')
mscAtmIfVptCANrtVbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4))
mscAtmIfVptCANrtVbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 1), )
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptCANrtVbr components.')
mscAtmIfVptCANrtVbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCANrtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptCANrtVbr component.')
mscAtmIfVptCANrtVbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptCANrtVbr components. These components can be added.')
mscAtmIfVptCANrtVbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptCANrtVbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptCANrtVbr tables.')
mscAtmIfVptCANrtVbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrIndex.setDescription('This variable represents the index for the mscAtmIfVptCANrtVbr tables.')
mscAtmIfVptCANrtVbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 100), )
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) and UPC attributes for the nrt-VBR ATM connections associated with this Vpt. Any attributes of the AtmIf CA NrtVbr that cannot be overridden in the Vpt CA NrtVbr affect all connections, including Vpt Vccs.')
mscAtmIfVptCANrtVbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCANrtVbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrProvEntry.setDescription('An entry in the mscAtmIfVptCANrtVbrProvTable.')
mscAtmIfVptCANrtVbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the non-real time variable bit rate (nrt-VBR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to nrt-VBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfVptCANrtVbrCellLossRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 4, 100, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrCellLossRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCANrtVbrCellLossRatio.setDescription('This attribute specifies the tolerable cell loss ratio (CLR) for nrt- VBR traffic. The number is the negative logarithm (base 10) of the CLR. In other words if the target CLR = 1E-10 then NrtVbr cellLossRatio = 10. This number must be greater than or equal to RtVbr cellLossRatio since rt-VBR traffic has a higher discard priority. The NrtVbr cellLossRatio is used by the Connection Admission Control (CAC) algorithm to compute the required (equivalent) cell rate for nrt-VBR connections. There is a trade-off between the service category CLR and the achievable Vpt bandwidth utilization. To guarantee an excellent service category, the CLR should be as small as possible (e.g., 1E- 10). However, a smaller CLR results in a larger equivalent cell rate for a given connection and hence a lower Vpt bandwidth utilization. Setting this attribute to 0 means that a CLR of 1 can be tolerated. In this case, no bandwidth is reserved for nrt-VBR connections, and CAC is effectively turned off. All nrt-VBR connections are admitted.')
mscAtmIfVptCAAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5))
mscAtmIfVptCAAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 1), )
if mibBuilder.loadTexts: mscAtmIfVptCAAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptCAAbr components.')
mscAtmIfVptCAAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptCAAbr component.')
mscAtmIfVptCAAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptCAAbr components. These components can be added.')
mscAtmIfVptCAAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptCAAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptCAAbr tables.')
mscAtmIfVptCAAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfVptCAAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrIndex.setDescription('This variable represents the index for the mscAtmIfVptCAAbr tables.')
mscAtmIfVptCAAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 100), )
if mibBuilder.loadTexts: mscAtmIfVptCAAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) attributes for ABR connections associated with this Vpt. Any attributes of the AtmIf CA Abr that cannot be overridden in the Vpt CA Abr affect all connections, including Vpt Vccs.')
mscAtmIfVptCAAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrProvEntry.setDescription('An entry in the mscAtmIfVptCAAbrProvTable.')
mscAtmIfVptCAAbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 5, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAAbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAAbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the available bit rate (ABR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to ABR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfVptCAUbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6))
mscAtmIfVptCAUbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 1), )
if mibBuilder.loadTexts: mscAtmIfVptCAUbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptCAUbr components.')
mscAtmIfVptCAUbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAUbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAUbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptCAUbr component.')
mscAtmIfVptCAUbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAUbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptCAUbr components. These components can be added.')
mscAtmIfVptCAUbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAUbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptCAUbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAUbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptCAUbr tables.')
mscAtmIfVptCAUbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 0)))
if mibBuilder.loadTexts: mscAtmIfVptCAUbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrIndex.setDescription('This variable represents the index for the mscAtmIfVptCAUbr tables.')
mscAtmIfVptCAUbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 100), )
if mibBuilder.loadTexts: mscAtmIfVptCAUbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrProvTable.setDescription('This group contains provisioned attributes which control Connection Admission Control (CAC) attributes for UBR connections associated with this Vpt. Any attributes of the AtmIf CA Ubr that cannot be overridden in the Vpt CA Ubr affect all connections, including Vpt Vccs.')
mscAtmIfVptCAUbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAUbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAUbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrProvEntry.setDescription('An entry in the mscAtmIfVptCAUbrProvTable.')
mscAtmIfVptCAUbrMaxVccs = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 100, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16384), ValueRangeConstraint(16385, 16385), )).clone(16385)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAUbrMaxVccs.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrMaxVccs.setDescription('This attribute specifies the maximum number of UBR Vccs that can be configured associated with this Vpt. The value must not exceed the maxVccs attribute of the parent Vpt CA component. If this attribute is set to sameAsCa, the maximum number of UBR Vccs is the same as specified by the maxVccs attribute of the Vpt CA. Changes to this attribute are not critical to the Vpt. If the value is changed to a number smaller than the current number of active VCCs, no new VCCs can be admitted until the number of active VCCs drops below the value of this attribute. The current number of active VCCs is indicated by the sum of the permanentVccs and switchedVccs operational attribute under the Vpt CA component. VALUES ( 16385 = sameAsCa )')
mscAtmIfVptCAUbrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("pool1", 1), ("pool2", 2), ("pool3", 3), ("pool4", 4), ("pool5", 5))).clone('pool1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAUbrPool.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrPool.setDescription('This attribute specifies the bandwidth pool which is to be used to support the unspecified bit rate (UBR) service category. The percentage of Vpt bandwidth capacity reserved for the given bandwidth pool is the maximum bandwidth that can be allocated to UBR traffic. The percentage allocated to each bandwidth pool can be provisioned through the bandwidthPool attribute under the CA.')
mscAtmIfVptCAUbrMinimumCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 100, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptCAUbrMinimumCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrMinimumCellRate.setDescription('This attribute specifies the default minimum cell rate (MCR) which is allocated from the UBR pool bandwidth for each UBR connection which is admitted. UBR connections normally are serviced on a best effort basis, but this attribute allows allocation of a default minimum bandwidth for each connection.')
mscAtmIfVptCAUbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 110), )
if mibBuilder.loadTexts: mscAtmIfVptCAUbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrOperTable.setDescription('This group contains operational attributes which show operational attributes for UBR connections associated with this Vpt.')
mscAtmIfVptCAUbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptCAUbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptCAUbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrOperEntry.setDescription('An entry in the mscAtmIfVptCAUbrOperTable.')
mscAtmIfVptCAUbrVccUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 5, 6, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptCAUbrVccUsage.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptCAUbrVccUsage.setDescription('This attribute indicates the number of active UBR Vccs under this Vpt. It includes switched and permanent connections.')
mscAtmIfVptTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9))
mscAtmIfVptTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 1), )
if mibBuilder.loadTexts: mscAtmIfVptTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptTm components.')
mscAtmIfVptTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptTm component.')
mscAtmIfVptTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptTm components. These components cannot be added nor deleted.')
mscAtmIfVptTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptTm tables.')
mscAtmIfVptTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmIndex.setDescription('This variable represents the index for the mscAtmIfVptTm tables.')
mscAtmIfVptTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100), )
if mibBuilder.loadTexts: mscAtmIfVptTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
mscAtmIfVptTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmOperEntry.setDescription('An entry in the mscAtmIfVptTmOperTable.')
mscAtmIfVptTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVptTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current number of cells in the link class queue used by this connection to buffer its traffic. This attribute does not apply to basic Vpts.')
mscAtmIfVptTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current congestion state of the link class queue used by this connection to buffer its traffic. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
mscAtmIfVptTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
mscAtmIfVptTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVptTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14), ("sameAsFwd", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. For the 1pOC12SmLrAtm card, traffic shaping is not available, therefore this attribute is always notApplicable. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is linear. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
mscAtmIfVptTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVptTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts. For 1pOC12SmLrAtm cards, perVc queueing is not available thus this attribute only indicates common or notApplicable.')
mscAtmIfVptTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
mscAtmIfVptTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
mscAtmIfVptTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc or Vpt. rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection is availableBitRate, a value of enforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection. The traffic descriptor parameters used for DGCRA enforcement are reflected in the rxTrafficDescParm of the connection.")
mscAtmIfVptTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
mscAtmIfVptTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
mscAtmIfVptTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
mscAtmIfVptTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVptTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, this attribute value is set to notApplicable. For CQC-based ATM cards and the 1pOC12SmLrAtm card, the notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards other than 1pOC12SmLrAtm, if the displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
mscAtmIfVptTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 451), )
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVptTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 451, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpEntry.setDescription('An entry in the mscAtmIfVptTmTxTdpTable.')
mscAtmIfVptTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVptTmTxTdpTable specific index for the mscAtmIfVptTmTxTdpTable.')
mscAtmIfVptTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptTmTxTdpTable.')
mscAtmIfVptTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 452), )
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under the service category subcomponents of the CA component for the service category of this connection. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
mscAtmIfVptTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 452, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshEntry.setDescription('An entry in the mscAtmIfVptTmTxQThreshTable.')
mscAtmIfVptTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshIndex.setDescription('This variable represents the mscAtmIfVptTmTxQThreshTable specific index for the mscAtmIfVptTmTxQThreshTable.')
mscAtmIfVptTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVptTmTxQThreshTable.')
mscAtmIfVptTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 453), )
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 is not used. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVptTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 453, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpEntry.setDescription('An entry in the mscAtmIfVptTmRxTdpTable.')
mscAtmIfVptTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVptTmRxTdpTable specific index for the mscAtmIfVptTmRxTdpTable.')
mscAtmIfVptTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptTmRxTdpTable.')
mscAtmIfVptTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 454), )
if mibBuilder.loadTexts: mscAtmIfVptTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 454, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmTqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTqpEntry.setDescription('An entry in the mscAtmIfVptTmTqpTable.')
mscAtmIfVptTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTqpIndex.setDescription('This variable represents the mscAtmIfVptTmTqpTable specific index for the mscAtmIfVptTmTqpTable.')
mscAtmIfVptTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmTqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptTmTqpTable.')
mscAtmIfVptTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 455), )
if mibBuilder.loadTexts: mscAtmIfVptTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 455, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmRqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRqpEntry.setDescription('An entry in the mscAtmIfVptTmRqpTable.')
mscAtmIfVptTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRqpIndex.setDescription('This variable represents the mscAtmIfVptTmRqpTable specific index for the mscAtmIfVptTmRqpTable.')
mscAtmIfVptTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmRqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptTmRqpTable.')
mscAtmIfVptTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2))
mscAtmIfVptTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptTmAbr components.')
mscAtmIfVptTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptTmAbr component.')
mscAtmIfVptTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptTmAbr components. These components cannot be added nor deleted.')
mscAtmIfVptTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptTmAbr tables.')
mscAtmIfVptTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVptTmAbr tables.')
mscAtmIfVptTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVptTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
mscAtmIfVptTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrOperEntry.setDescription('An entry in the mscAtmIfVptTmAbrOperTable.')
mscAtmIfVptTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrInitialCellRate.setDescription('This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
mscAtmIfVptTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrTransientBufferExposure.setDescription('This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrFixedRoundTripTime.setDescription('This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRateDecreaseFactor.setDescription('This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRateIncreaseFactor.setDescription('This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrMaxCellPerRmCell.setDescription('This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrMaxTimeBetweenRmCell.setDescription('This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrCutoffDecreaseFactor.setDescription('This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrAcrDecreaseTimeFactor.setDescription('This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrForwardRmCellLimit.setDescription('This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
mscAtmIfVptTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrTxRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrTxRateChangeInfo.setDescription('This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
mscAtmIfVptTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrAcrRateChangeInfo.setDescription('This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
mscAtmIfVptTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrTxFwdRmCells.setDescription('This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
mscAtmIfVptTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 9, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptTmAbrRxEfci.setDescription('This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
mscAtmIfVptVcc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20))
mscAtmIfVptVccRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVcc components.')
mscAtmIfVptVccRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVcc component.')
mscAtmIfVptVccRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVcc components. These components can be added and deleted.')
mscAtmIfVptVccComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVcc tables.')
mscAtmIfVptVccIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: mscAtmIfVptVccIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccIndex.setDescription('This variable represents the index for the mscAtmIfVptVcc tables.')
mscAtmIfVptVccStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscAtmIfVptVccStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStateEntry.setDescription('An entry in the mscAtmIfVptVccStateTable.')
mscAtmIfVptVccAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVptVccOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVptVccUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVptVccOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 110), )
if mibBuilder.loadTexts: mscAtmIfVptVccOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccOperTable.setDescription('This group contains operational information for a Vcc, Vpc, or Vpt component.')
mscAtmIfVptVccOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccOperEntry.setDescription('An entry in the mscAtmIfVptVccOperTable.')
mscAtmIfVptVccConnectionPointType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("connectionEndPoint", 0), ("segmentEndPoint", 1), ("connectingPoint", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccConnectionPointType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccConnectionPointType.setDescription('This attribute reflects the role of the connection component at this interface. A value of connectionEndPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are processed by the connection component. A value of segmentEndPoint indicates that user cells and end-to- end OAM cells are relayed by the connection component, while segment OAM cells are processed by the connection component. A value of connectingPoint indicates that user cells, end-to-end OAM cells, and segment OAM cells are relayed by the connection component. A value of unknown indicates that the connection component is inactive.')
mscAtmIfVptVccConnInfoTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 115), )
if mibBuilder.loadTexts: mscAtmIfVptVccConnInfoTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccConnInfoTable.setDescription('This group contains operational connection characteristics information for a Vcc component.')
mscAtmIfVptVccConnInfoEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 115, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccConnInfoEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccConnInfoEntry.setDescription('An entry in the mscAtmIfVptVccConnInfoTable.')
mscAtmIfVptVccDistributionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 115, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipoint", 1))).clone('pointToPoint')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccDistributionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccDistributionType.setDescription('This attribute indicates the way data is distributed in the connection. A value of pointToPoint indicates this connection point is part of a point-to-point connection. A value of pointToMultipoint indicates this connection point is part of a point-to-multipoint connection.')
mscAtmIfVptVccNumLeaves = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 115, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccNumLeaves.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNumLeaves.setDescription('This attribute indicates the number of destination leaves of the connection. If the distributionType is pointToPoint the value of this attribute is 0.')
mscAtmIfVptVccCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 115, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("fromLink", 0), ("toLink", 1), ("notApplicable", 2))).clone('notApplicable')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccCallDirection.setDescription('This attribute indicates the direction of the call setup request for an SVC. A value of fromLink means that the call setup originated from the link. A value of toLink means that the call setup was directed to the link. For PVC connections, the value of this attribute is notApplicable. For SPVC connections, the value of this attribute is notApplicable for Vccs with the SourcePVC and DestinationPVC subcomponents. For Signalling channels, the value of this attribute is notApplicable.')
mscAtmIfVptVccStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120), )
if mibBuilder.loadTexts: mscAtmIfVptVccStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatusTable.setDescription('This group contains operational status information for a Vcc, Vpc or Vpt component.')
mscAtmIfVptVccStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatusEntry.setDescription('An entry in the mscAtmIfVptVccStatusTable.')
mscAtmIfVptVccOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 0), ("end2endUp", 1), ("end2endDown", 2), ("localUpEnd2endUnknown", 3), ("localDown", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccOperStatus.setDescription('This attribute indicates the present operational status of the Vcc, Vpc or Vpt component. Its value is dependent upon the current state of the segLinkSideLoopbackState and endToEndLoopbackState attributes. The value is end2endUp when the endToEndLoopbackState is good and the segLinkSideLoopbackState is either good or unknown. The value is end2endDown when the endToEndLoopbackState is bad and the segLinkSideLoopbackState is either good or unknown. The value is localUpEnd2endUnknown when the endToEndLoopbackState is unknown and the segLinkSideLoopbackState is good. The value is localDown when segLinkSideLoopbackState is bad. The value is localUpEnd2endUnknown when the endToEndLoopbackState is notApplicable and the segLinkSideLoopbackState is good. The value is unknown when the endToEndLoopbackState is either unknown or notApplicable and the segLinkSideLoopbackState is unknown.')
mscAtmIfVptVccLocalFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("noFailure", 0), ("localBwLoss", 1), ("portDown", 2), ("notAdmitted", 3), ("appNotRegistered", 4), ("disabledByApp", 5), ("bwReduced", 6), ("vpDown", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccLocalFailureCause.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccLocalFailureCause.setDescription('This attribute indicates the failure cause of the Vcc, Vpc or Vpt component. noFailure indicates that there is currently no bandwidth related failure for this connection. portDown indicates that the interface corresponding to the parent AtmIf is down. localBwLoss indicates that the Ima corresponding to this AtmIf has lost some, but not all bandwidth, and as a result, this connection has been released. notAdmitted indicates that this connection has failed to be admitted by the Connection Admission Control (CAC) algorithm. appNotRegistered indicates that there is no application registered to use this connection. This may be the case, for example when there is a Vcc Test application, but the test has not been started. Check the status of the application to determine why it is not functional. disabledByApp indicates that the application using this connection has requested that the connection be disabled. An example is a connection used by a trunk application where the trunk has timed out on an attempt to stage. Check the application to determine why it is not fully functional. bwReduced indicates that this connection is operating in a reduced bandwidth state. It is a bandwidth elastic connection which currently has been allocated less than the requested (equivalent) bandwidth. vpDown indicates that this connection has been notified of a fault detected at the associated VP-layer. vpDown is applicable for Vpt Vccs only.')
mscAtmIfVptVccTroubled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTroubled.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTroubled.setDescription('This attribute indicates whether or not the connection is in a troubled state. Connections become troubled because of OAM failures; when one of the attributes segLinkSideLoopbackState, segSwitchSideLoopbackState, endToEndLoopbackState, aisState (when receiving AIS cells only) or rdiState go bad, this attribute is set to yes; otherwise it is set to no.')
mscAtmIfVptVccSegLinkSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSegLinkSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSegLinkSideLoopbackState.setDescription('This attribute contains the current state of the link-side segment loopback for this connection. Link-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the link (port). The value of this attribute is dependent upon the current setting of the segLinkSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is notApplicable when the connectionPointType is a connectingPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the segment link side loopback is working. The value is bad when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint or a connectionEndPoint, and the link side segment loopback is not working. The value is unknown when the segLinkSideLoopback is off. The value is unknown when the segLinkSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not yet been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVptVccSegSwitchSideLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccSegSwitchSideLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccSegSwitchSideLoopbackState.setDescription('This attribute contains the current state of the switch-side segment loopback for this connection. Switch-side segment loopback cells are transmitted (inserted) by a connection component in the direction of the bus. The value of this attribute is dependent upon the current setting of the segSwitchSideLoopback provisionable attribute, the connection point type as specified by the connectionPointType attribute, and the current loopback state (if applicable). The value is only applicable when the connectionPointType is a segmentEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or connectionEndPoint. The value is notApplicable when the distributionType is pointToMultipoint. The value is good when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback is working. The value is bad when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the switch side segment loopback is not working. The value is unknown when the segSwitchSideLoopback is off. The value is unknown when the segSwitchSideLoopback is on, the connectionPointType is a segmentEndPoint and the segment switch side loopback has not been determined.')
mscAtmIfVptVccEndToEndLoopbackState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccEndToEndLoopbackState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccEndToEndLoopbackState.setDescription('This attribute contains the current state of the end-to-end loopback for this connection. Its value is dependent upon the current setting of the endToEndLoopback provisionable attribute and the connection point type as specified by the connectionPointType attribute. The value is only applicable when the connectionPointType is a connectionEndPoint. The value is notApplicable when the connectionPointType is a connectingPoint or segmentEndPoint. The value is notApplicable when the distributionType is a pointToMultipoint. The value is good when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is working. The value is bad when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback is not working. The value is unknown when the endToEndLoopback is off. The value is unknown when the endToEndLoopback is on, the connectionPointType is a connectionEndPoint and the end-to-end loopback status has not been determined. The state of this attribute determines, in part, the value of the operStatus attribute.')
mscAtmIfVptVccRxOamCellCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRxOamCellCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRxOamCellCongestionState.setDescription('This attribute contains the current state of the receive side OAM cell congestion for this connection. Its value reflects whether the rate of received OAM cells for this connection is below a specified threshold. The connection maintains a count of the number of OAM cells which are terminated per second. Once that count exceeds the specified threshold, extraction of all OAM cells for this connection is disabled for a period of one minute. This is a congestion management mechanism to prevent the processor from being overloaded with handling OAM cells for a particular connection. This mechanism ensures that tasks, such as trunks obtain enough processor cycles to remain in service, and are not adversely affected by excessive rate of OAM cells on a particular connection. The value is good when the rate of received OAM cells is less than the allowed threshold. The value is bad when the arrival rate has exceeded the allowed threshold. It remains bad for one minute, before returning to good again. During this timeout, extraction of all OAM cells is disabled for this connection. As a result, other loopback failure conditions may occur. The value is unknown when the application has not yet begun to use this connection. An example is the Test component before a test has been started. Each type of OAM cell is counted separately. The threshold for AIS cells is three cells per second. If more than three AIS cells are received within a one second interval, this attribute is set to bad. The threshold for RDI cells and each loopback type is also three, but the threshold for trace cells is 250 per second. The state of this attribute has no direct effect on the value of the operStatus attribute or on the number of troubled connections.')
mscAtmIfVptVccAisState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccAisState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccAisState.setDescription("This attribute contains the current state of the Alarm Indication Signal for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVptVccRdiState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 120, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("unknown", 2), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRdiState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccRdiState.setDescription("This attribute indicates the current state of the Remote Defect Indication for this connection. A value of good indicates that the connection's application is active and no alarm has occurred. A value of bad indicates that the connection's application is active and an alarm has occurred. A value of unknown indicates that the connection's application is inactive. A value of notApplicable occurs when the connectionPointType is either a segmentEndPoint or a connectingPoint.")
mscAtmIfVptVccTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130), )
if mibBuilder.loadTexts: mscAtmIfVptVccTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTrafficTable.setDescription('This group is HISTORICAL. Please refer to the group AtmTmOper; This attribute group contains attributes for the Vcc and Vpc components to reflect operational traffic attributes.')
mscAtmIfVptVccTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTrafficEntry.setDescription('An entry in the mscAtmIfVptVccTrafficTable.')
mscAtmIfVptVccTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVptVccTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxQosClass.setDescription("This attribute indicates the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete, replaced by the UNI 4.0 attribute atmServiceCategory.")
mscAtmIfVptVccFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccFwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxQueueLength.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxQueueLength.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the current length of the transmit queue for this connection. If this connection has traffic shaping disabled, then this attribute displays the common queue length. If traffic shaping is enabled, then this attribute displays the per-VC queue length.')
mscAtmIfVptVccTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxQueueCongestionState.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxQueueCongestionState.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the congestion state of the transmit queue for this connection. If the connection has traffic shaping disabled, then this attribute displays the common queue congestion state. If traffic shaping is enabled, then this attribute displays the per-VC queue congestion state. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. Therefore, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue.')
mscAtmIfVptVccHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccHoldingPriority.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVptVccRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxTrafficDescType.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVptVccRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxQosClass.setDescription('This attribute reflects the value of the provisioned attribute in the Vcd or Vpd. Refer to that attribute for more detailed explanation. This attribute is obsolete replaced by the UNI 4.0 attribute atmServiceCategory.')
mscAtmIfVptVccBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBwdQosClass.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccAtmServiceCategory.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value of the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptVccTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTrafficShaping.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case when the atmServiceCategory is constantBitRate, or when the txTrafficDescType is 1 or 2. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4.')
mscAtmIfVptVccBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBearerClassBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr) and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTransferCapabilityBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVptVccClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccClippingBbc.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the value of the clipping susceptibility parameter in the BBC Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccUnshapedTransmitQueueing.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto common transmit queues. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. This is the case when trafficShaping is disabled, but per-VC queueing has been configured for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections.')
mscAtmIfVptVccBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBestEffort.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("notApplicable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccUsageParameterControl.setDescription("This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case when the connection's rxTrafficDescType is 1 or 2. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enabled indicates that UPC is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that UPC is enforced on the connection. In this case the traffic descriptor parameters used for UPC enforcement are reflected in the rxTrafficDescParms of the connection.")
mscAtmIfVptVccTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVptVccRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRxFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxFrameDiscard.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the set of current frame discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an interim connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. Frame discard functions are not applicable for Virtual Path Connections (VPCs). Description of bits: ppd(0) epd(1)')
mscAtmIfVptVccBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccBandwidthElastic.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBandwidthElastic.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for ubr atmServiceCategory or txTrafficDescriptorType 1 or 2 connections.')
mscAtmIfVptVccBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 130, 1, 100), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccBandwidthReduction.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBandwidthReduction.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically be the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. All connections which are running at their full allocated bandwidth, bwReduction have the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVptVccStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140), )
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTable.setDescription('This group contains traffic statistics for a Vcc, Vpc, or Vpt component.')
mscAtmIfVptVccStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsEntry.setDescription('An entry in the mscAtmIfVptVccStatsTable.')
mscAtmIfVptVccStatsTxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 10), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCell.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsTxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 20), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCellClp.setDescription('This attribute counts the number of cells that have been transmitted from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 30), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxDiscard.setDescription("This attribute is replaced by new attributes txCellDiscard and txFrameDiscard. This attribute counts the number of cells or frames received from the bus on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccTxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxDiscardClp.setDescription("This attribute is replaced by new attributes txCellDiscardClp and txFrameDiscardClp. This attribute counts the number of cells or frames received from the bus on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion or when the connection's interface is disabled. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccStatsTxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 42), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCellDiscard.setDescription("This attribute counts the number of cells received from the bus on this connection that have been discarded. Discarded cells are not counted in the txCell attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections usually have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscard values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccStatsTxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 43), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxCellDiscardClp.setDescription("This attribute counts the number of cells received from the bus on this connection with CLP=1 that have been discarded. This count is included in the txCellDiscard attribute. Discarded cells are not counted in the txCellClp attribute. Cells are discarded due to transmit congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection's interface is disabled. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txCellDiscardClp values for all such connections associated with the Vpt. For Vccs on CQC-based ATM cards, if the connection segments frames into cells, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccStatsTxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 46), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxFrameDiscard.setDescription("This attribute counts the number of frames received from the bus on this connection that have been discarded. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is independent of the txCell or txCellDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccStatsTxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 47), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsTxFrameDiscardClp.setDescription("This attribute counts the number of discarded frames on this connection that were received from the bus and composed of one or more CLP=1 cells. Frames are discarded due to congestion, Partial Packet Discard (PPD), Early Packet Discard (EPD), and Weighted Random Early Detection (W-RED) mechanisms, or when the connection interface is disabled. This count is included in the txFrameDiscard attribute. For CQC-based ATM cards, this attribute is applicable only to connections that segment frames into cells. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all txFrameDiscardClp values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to EPD, PPD, and W-RED for a standard Vpt Vcc are not included in this attribute. These discards are counted in the Vcc's parent Vpt txFrameDiscardClp attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccStatsRxCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCell.setDescription('This attribute counts the number of cells that have been received from the interface on this connection. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsRxCellClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCellClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCellClp.setDescription('This attribute counts the number of cells that have been received from the interface on this connection with the CLP=1. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccRxDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRxDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxDiscard.setDescription('This attribute is replaced by new attributes rxCellDiscard and rxFrameDiscard. This attribute counts the number of cells or frames received from the interface on this connection that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccRxDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRxDiscardClp.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxDiscardClp.setDescription('This attribute is replaced by new attributes rxCellDiscardClp and rxFrameDiscardClp. This attribute counts the number of cells or frames received from the interface on this connection with CLP=1 that have been discarded. If the connection segments frames into cells, the counter indicates the number of frames discarded. Connections which segment frames into cells have a connectionPointType of connectionEndPoint. If the connection relays cells without adaptation, the counter indicates the number of cells discarded. Connections which relay cells without adaptation have a connectionPointType of segmentEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. Thus, in the AAL1 case, this attribute counts discarded cells. Discards are done due to congestion, non-conformance with UPC or AAL reassembly problems. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsRxCellDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 82), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCellDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCellDiscard.setDescription("This attribute counts the number of cells received from the interface on this connection that have been discarded. This count is included in the rxCell attribute. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccStatsRxCellDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 83), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCellDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxCellDiscardClp.setDescription("This attribute counts the number of cells received from the interface on this connection with CLP=1 that have been discarded. This count is included in the rxCell and rxCellDiscard attributes. This count includes cells discarded due to non-conformance with UPC, cells which are part of a frame which has been discarded due to an AAL5 frame reassembly error, cells which are discarded due to congestion, or cells which are received while the next hop connection to which the traffic is directed across the backplane is down. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. For CQC-based ATM cards, this attribute is applicable only to connections that relay cells without adaptation. Such connections have a connectionPointType of connectionEndPoint or connectingPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxCellDiscard values for all such connections associated with the Vpt. For CQC-based ATM cards, for Vpcs, and Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. Discards due to non-conformance with UPC at the VP layer, for a standard Vpt Vcc, are not included in this attribute. These discards are counted in the Vcc's parent Vpt rxCellDiscard attribute. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.")
mscAtmIfVptVccStatsRxFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 86), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxFrameDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxFrameDiscard.setDescription('This attribute counts the number of frames received from the interface on this connection that have been discarded. This count is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Connections which reassemble cells into frames have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; even though they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscard values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsRxFrameDiscardClp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 88), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxFrameDiscardClp.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxFrameDiscardClp.setDescription('This attribute counts the number of discarded frames on this connection that were received from the interface and composed of one or more CLP1 cells. This count is included in the rxFrameDiscard attribute. It is independent of the rxCellDiscard attribute. This count includes frames discarded due to an AAL5 frame reassembly error, frames discarded due to early packet discard (EPD), and frames discarded due to processor (CPU) congestion. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxFrameDiscardClp values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsRxUpcViolationOnEnforcer1 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxUpcViolationOnEnforcer1.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxUpcViolationOnEnforcer1.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 1. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. When the value of rxTrafficDescType for this connection is 3, 4, 5, 6, 7 or 8, Enforcer 1 enforces conformance of traffic received from the interface to PCR CLP0+1. When the value of rxTrafficDescType for this connection is 9, Enforcer 1 performs the Dynamic Generic Cell Rate Algorithm (DGCRA) used for the Available Bit Rate (ABR) service category. If UPC is enforced all non-conforming cells are discarded by this enforcer. These discarded cells are included in rxCellDiscard. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer1 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsRxUpcViolationOnEnforcer2 = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 92), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxUpcViolationOnEnforcer2.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxUpcViolationOnEnforcer2.setDescription('This attribute counts the number of UPC violations observed by the Generic Cell Rate Algorithm (GCRA) Enforcer 2. This attribute is only applicable if UPC is enforced or monitored. This attribute is not applicable for standard Vpt Vccs. This attribute is not applicable and is not displayed on CQC-based ATM cards. Enforcer2 is applicable only if the rxTrafficDescType for this connection is 4, 5, 6, 7 or 8. When the value of rxTrafficDescType 4 or 5, Enforcer 2 enforces conformance of traffic received from the interface to PCR CLP0. When the value of rxTrafficDescType 6, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0+1. When the value of rxTrafficDescType 7 or 8, Enforcer 2 enforces conformance of traffic received from the interface to SCR CLP0. If UPC is enforced, enforcer 2 discards non-conforming cells for rxTrafficDescType values of 4, 6 and 7. It tags non-conforming cells for rxTrafficDescType values of 5 and 8. Discarded cells are counted in the rxCellDiscard attribute. For basic Vpts, this attribute provides an aggregated total of all rxUpcViolationOnEnforcer2 values for the Vccs associated with the Vpt. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsRxAal5FrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxAal5FrameError.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxAal5FrameError.setDescription('This attribute counts the number of frames received from the interface on this connection that have AAL5 length errors or AAL5 CRC errors. This attribute is not applicable and is not displayed on CQC-based ATM cards. AAL5 length or CRC errors typically occur because of cell discards due to congestion, UPC, or due to corruption of data between the AAL5 segmentation and reassembly end points. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameError values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccStatsRxAal5FrameAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 140, 1, 102), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxAal5FrameAbort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccStatsRxAal5FrameAbort.setDescription('This attribute counts the number of frames received from the interface on this connection that have the AAL5 length field set to zero. This attribute is not applicable and is not displayed for CQC-based ATM cards. An AAL5 length of zero is an indication by the far end segmentation point to this reassembly point that the frame is to be discarded without reassembly. This mechanism is typically used by a segmentation point if it detects an error in a frame after some of the cells belonging to that frame have already been transmitted. This attribute is applicable only to connections that reassemble incoming cells into frames. Such connections have a connectionPointType of connectionEndPoint. AAL1 connections are an exception to this rule; although they have a connectionPointType of connectionEndPoint, they do not do adaptation at this point. For Vpts, this attribute provides an aggregated total of all rxAal5FrameAbort values for all applicable connections associated with the Vpt. For Vpcs and for Vccs that relay cells without adaptation, this attribute is not applicable and is not displayed. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 294), )
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of five transmit traffic parameters. The first three elements reflect the settings of the first three elements of the txTrafficDescParm attribute in the AtmTrafficProv group. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the Traffic group under the Vcd or Vpd. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. This rate is one of the set of available shaping rates for this type of ATM-FP, based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), the provisioned cell rate, the shapingScalingFactor attribute of the AtmResourceControl component, and whether traffic shaping is enabled. A rate of zero (0) indicates that shaping is not performed. When txTrafficDescType is 3, 4, 5, 6, 7 or 8, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVptVccTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 294, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpEntry.setDescription('An entry in the mscAtmIfVptVccTxTdpTable.')
mscAtmIfVptVccTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 294, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccTxTdpTable specific index for the mscAtmIfVptVccTxTdpTable.')
mscAtmIfVptVccTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 294, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccTxTdpTable.')
mscAtmIfVptVccRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 295), )
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) are expressed in cells/s. Maximum burst size (MBS) is expressed in cells. Cell Delay Variation Tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. If Upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT is a combination of provisioned parameters. If Upc is enabled, the values of PCR, SCR, MBS, and CDVT is exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVptVccRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 295, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpEntry.setDescription('An entry in the mscAtmIfVptVccRxTdpTable.')
mscAtmIfVptVccRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 295, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccRxTdpTable specific index for the mscAtmIfVptVccRxTdpTable.')
mscAtmIfVptVccRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 295, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccRxTdpTable.')
mscAtmIfVptVccTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 352), )
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. The first element indicates the queue limit. Depending upon the atmServiceCategory of the connection, the provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under one of the subcomponents of the AtmIf CA component. If the connection has traffic shaping disabled, then this attribute relates to the common queue. If traffic shaping is enabled, then this attribute relates to the per-VC queue. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set approximately at 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set approximately at 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set approximately at 35 percent of the first parameter, the operational queue limit.')
mscAtmIfVptVccTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 352, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshEntry.setDescription('An entry in the mscAtmIfVptVccTxQThreshTable.')
mscAtmIfVptVccTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 352, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshIndex.setDescription('This variable represents the mscAtmIfVptVccTxQThreshTable specific index for the mscAtmIfVptVccTxQThreshTable.')
mscAtmIfVptVccTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 352, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccTxQThreshTable.')
mscAtmIfVptVccFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 357), )
if mibBuilder.loadTexts: mscAtmIfVptVccFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccFqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptVccFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 357, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccFqpEntry.setDescription('An entry in the mscAtmIfVptVccFqpTable.')
mscAtmIfVptVccFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 357, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccFqpIndex.setDescription('This variable represents the mscAtmIfVptVccFqpTable specific index for the mscAtmIfVptVccFqpTable.')
mscAtmIfVptVccFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 357, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccFqpTable.')
mscAtmIfVptVccBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 358), )
if mibBuilder.loadTexts: mscAtmIfVptVccBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBqpTable.setDescription('This attribute is HISTORICAL. Please refer to the attribute of the same name in the group AtmTmOper. This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptVccBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 358, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBqpEntry.setDescription('An entry in the mscAtmIfVptVccBqpTable.')
mscAtmIfVptVccBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 358, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBqpIndex.setDescription('This variable represents the mscAtmIfVptVccBqpTable specific index for the mscAtmIfVptVccBqpTable.')
mscAtmIfVptVccBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 358, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccBqpTable.')
mscAtmIfVptVccVcd = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2))
mscAtmIfVptVccVcdRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccVcd components.')
mscAtmIfVptVccVcdRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccVcd component.')
mscAtmIfVptVccVcdRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccVcd components. These components cannot be added nor deleted.')
mscAtmIfVptVccVcdComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccVcdStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccVcd tables.')
mscAtmIfVptVccVcdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccVcdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdIndex.setDescription('This variable represents the index for the mscAtmIfVptVccVcd tables.')
mscAtmIfVptVccVcdLbkTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdLbkTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdLbkTable.setDescription('This group contains the provisionable loopback attributes for a Vcc, Vpc, or Vpt component. Note that certain loopback requests may not be possible on a given connection. In such cases, the corresponding operational loopback attribute in the Status group of the Vcc, Vpc, or Vpt component is set to notApplicable and the requested loopback is not performed. If loopbacks are provisioned to be on, and for any reason the segment or end-to-end OAM loopback cells are not relayed, the connection component becomes troubled, and user cell traffic may be discarded. If loopbacks are provisioned to be on, all of the nodes in the segment, and external networks which are in the end-to-end connection must relay the OAM loopback cells.')
mscAtmIfVptVccVcdLbkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdLbkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdLbkEntry.setDescription('An entry in the mscAtmIfVptVccVcdLbkTable.')
mscAtmIfVptVccVcdSegLinkSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdSegLinkSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdSegLinkSideLoopback.setDescription("This attribute specifies whether link-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the link-side segment loopback insertion for the connection is based on the segLinkSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has link-side segment loopback insertion turned on, then link-side segment loopback insertion is also on for the connection. When on or off is selected, link-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that link-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint. Link-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated segLinkSideLoopbackState attribute indicates notApplicable and link-side segment loopback insertion is not performed. Link-side segment loopback insertion is always possible on a Vpt.")
mscAtmIfVptVccVcdSegSwitchSideLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 100, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdSegSwitchSideLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdSegSwitchSideLoopback.setDescription("This attribute specifies whether switch-side segment loopback insertion should be performed on this connection. When sameAsInterface is selected, the switch-side segment loopback for the connection is based on the segSwitchSideLoopback attribute of the connection's parent AtmIf componentif the ATM interface has switch-side segment loopback insertion turned on, then switch-side segment loopback insertion is also on for the connection. When on or off is selected, switch-side segment loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that switch-side segment loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or connectionEndPoint. Switch-side segment loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint In such cases, the associated segSwitchSideLoopbackState attribute indicates notApplicable and switch-side segment loopback insertion is not performed. Switch- side segment loopback is never possible on a Vpt.")
mscAtmIfVptVccVcdEndToEndLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("on", 0), ("off", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdEndToEndLoopback.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdEndToEndLoopback.setDescription("This attribute specifies whether end-to-end loopback insertion should be performed on this connection. When sameAsInterface is selected, the end-to-end loopback for the connection is based on the endToEndLoopback attribute of the connection's parent AtmIf componentif the ATM interface has end-to-end loopback insertion turned on, then end-to-end loopback insertion is also on for the connection. When on or off is selected, end-to-end loopback insertion is turned on or off respectively for the connection regardless of the provisioning of the parent AtmIf component. Note that end-to-end loopback insertion is not possible if the connectionPointType attribute of the Vcc or Vpc component is connectingPoint or segmentEndPoint. End-to-end loopback insertion is also not possible if the distributionType of the Vcc is pointToMultipoint. In such cases, the associated endToEndLoopbackState attribute indicates notApplicable and end- to-end loopback insertion is not performed. End-to-end loopback insertion is always possible on a Vpt.")
mscAtmIfVptVccVcdMCastConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("pointToPoint", 0), ("pointToMultipointRoot", 1), ("pointToMultipointLeaf", 2))).clone('pointToPoint')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdMCastConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdMCastConnectionType.setDescription('This attribute is introduced to exist temporarily to pass to AtmIf the connection type defined under Vcc or Vpc. This attribute will be obsoleted once a more elegant solution is available.')
mscAtmIfVptVccVcdTrafficTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTrafficTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTrafficTable.setDescription("This group contains traffic related provisionable attributes for the Vcc and Vpc components. The attributes' operational values are reflected in the Traffic group for these components. Changing any of the attributes in this group causes a service interruption on the Vcc or Vpc component.")
mscAtmIfVptVccVcdTrafficEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTrafficEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTrafficEntry.setDescription('An entry in the mscAtmIfVptVccVcdTrafficTable.')
mscAtmIfVptVccVcdTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVptVccVcdTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4))).clone('connectionOriented')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxQosClass.setDescription("This attribute specifies the quality of service for the transmit direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. This traffic is highest priority. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic such as Frame Relay or X.25 traffic. The connectionless traffic refers to traffic offered through connectionless trunks such as certain LAN protocols. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. This traffic is lowest priority. This attribute is obsolete. The value is migrated into atmServiceCategory. The atmServiceCategory applies in both transmit and receive directions. unspecified maps to unspecifiedBitRate; constantBitRate maps to constantBitRate; variableBitRate maps to variableBitRateRt; connectionOriented maps to variableBitRateNrt connectionless maps to variableBitRateNrt")
mscAtmIfVptVccVcdFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVptVccVcdHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdHoldingPriority.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdHoldingPriority.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections.')
mscAtmIfVptVccVcdRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTrafficDescType.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTrafficDescType.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute When sameAsTx is selected, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the transmit values.')
mscAtmIfVptVccVcdRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecified", 0), ("constantBitRate", 1), ("variableBitRate", 2), ("connectionOriented", 3), ("connectionless", 4), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxQosClass.setDescription("This attribute specifies the quality of service for the receive direction for this connection. The constantBitRate class refers to traffic offered on services such as a constant bit rate video service. The variableBitRate class refers to traffic offered on services such as packetized audio and video. The connectionOriented class refers to connection-oriented traffic. The connectionless traffic refers to traffic offered through connectionless trunks. The unspecified class supports a 'best effort' type of service, where there is a minimum guarantee of bandwidth. The sameAsTx selection sets the receive quality of service to be the same as the transmit quality of service. This attribute is obsolete. The value of txQosClass is migrated into atmServiceCategory. The value of this attribute is ignored. AtmServiceCategory applies in both transmit and receive directions.")
mscAtmIfVptVccVcdBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBwdQosClass.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBwdQosClass.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVptVccVcdAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdAtmServiceCategory.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdAtmServiceCategory.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc.Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduce value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptVccVcdTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTrafficShaping.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTrafficShaping.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. When sameAsInterface is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's parent AtmIf componentif the ATM interface has traffic shaping enabled, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc and Vpc components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVptVccVcdUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsInterface", 3))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdUnshapedTransmitQueueing.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdUnshapedTransmitQueueing.setDescription('This attribute is migrated to the AtmTmProv group. This attribute only applies when this connection is unshaped. This attribute defines the transmit queueing method for this connection if it is unshaped. Refer to the unshapedTransmitQueueing attribute under the AtmIf for more details on the meaning of this attribute. When this attribute is set to sameAsInterface, the value from the AtmIf is used. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.')
mscAtmIfVptVccVcdUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdUsageParameterControl.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdUsageParameterControl.setDescription("This attribute is migrated to the AtmTmProv group. This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsInterface is selected, UPC for the connection is based on the usageParameterControl attribute of the connection's parent AtmIf componentif the ATM interface has UPC enabled, then UPC is enabled for the connection. Note that enabling UPC may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc and Vpc components. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the parent AtmIf component.")
mscAtmIfVptVccVcdBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBearerClassBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBearerClassBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVptVccVcdTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTransferCapabilityBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTransferCapabilityBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no NotApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVccVcdClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdClippingBbc.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdClippingBbc.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVptVccVcdBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBestEffort.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBestEffort.setDescription('This attribute is migrated to the AtmTmProv group. This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVccVcdFwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the forward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the transmit direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not transmitted. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to transmit traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to transmit traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the forward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, forward frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to txFrameDiscard.")
mscAtmIfVptVccVcdBwdFrameDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 110, 1, 77), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1))).clone('notIndicated')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBwdFrameDiscard.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBwdFrameDiscard.setDescription("This attribute specifies the activation of frame discard functionality in the backward data direction, at relay points, for this connection. It applies to each hop of the connection. Frame discard functions should not be requested if this connection is not transferring frame (AAL5) traffic. Setting the value to indicated for any other traffic type results in all traffic being discarded. If this connection point is a permanent (provisioned) VCC mid- point, this attribute specifies whether the Partial Packet Discard (PPD) function is to be enabled or disabled in the receive direction at this connecting point. The PPD function allows the connecting point to discard the remainder of a cell-forwarded AAL5 frame if one cell of this frame has been discarded. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded by the AAL5 reassembly are not received. At a permanent VCC connecting point which is not a connection endpoint, when this attribute is set to indicated, the PPD function is applied to receive traffic at this connecting point. It should not be indicated for connections whose end points are not performing AAL5 segmentation and reassembly. When this attribute is set to notIndicated, the PPD feature is not applied to receive traffic at this connecting point. At a SPVC origin on a PNNI interface, a value of indicated specifies that frame discard is requested in the backward direction. The frame discard function for SPVCs consists of PPD at the SPVC origin and at all intermediate connecting points. When this attribute is set to notIndicated, backwards frame discard is not requested in the SPVC call setup. Thus PPD is not enabled at the SPVC origin nor at any intermediate connecting point. At all points along a VPC, this setting is ignored. At a permanent VCC connection endpoint, this value is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. This attribute has been migrated to rxFrameDiscard.")
mscAtmIfVptVccVcdAcctTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 111), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdAcctTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdAcctTable.setDescription('This group contains the provisionable ATM accounting attributes for a Vcc, Vpc, or Vpt component.')
mscAtmIfVptVccVcdAcctEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 111, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdAcctEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdAcctEntry.setDescription('An entry in the mscAtmIfVptVccVcdAcctTable.')
mscAtmIfVptVccVcdCorrelationTag = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 111, 1, 10), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdCorrelationTag.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdCorrelationTag.setDescription("This attribute specifies a unique indentifier for each end of a PVC. It that may be used by downstream processing systems to correlate accounting records issued at different nodes in the network. The attribute can be up to 32 bytes long. If it is less than 32 bytes, it is zero filled on the right to create a 32 byte value. The resulting value is recorded in the attribute callConnId for this PVC's ATM accounting records. If the attribute is a null string then this PVC does not have any accounting records generated for it.")
mscAtmIfVptVccVcdTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 297), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next rate less than the PCR. For txTrafficDescType 6, 7 and 8, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR.')
mscAtmIfVptVccVcdTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 297, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpEntry.setDescription('An entry in the mscAtmIfVptVccVcdTxTdpTable.')
mscAtmIfVptVccVcdTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 297, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdTxTdpTable specific index for the mscAtmIfVptVccVcdTxTdpTable.')
mscAtmIfVptVccVcdTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 297, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdTxTdpTable.')
mscAtmIfVptVccVcdRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 298), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR) and sustained cell rate (SCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If this value is zero, the CDVT is taken from the ConnectionAdministrator defaults for the particular atmServiceCategory of this connection. When rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1 000 000 000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335 523 840. I1 + L1 must be less than or equal to 1 342 156 800. I2 + L2 must be less than or equal to 1 342 156 800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41 940 480 or I2 > 41 940 480 or I1 + L1 > 167 769 600 or I2 + L2 > 167 769 600 then both I1 and I2 must be greater than 20 480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values in this attribute are taken from the txTrafficDescParm.')
mscAtmIfVptVccVcdRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 298, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpEntry.setDescription('An entry in the mscAtmIfVptVccVcdRxTdpTable.')
mscAtmIfVptVccVcdRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 298, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdRxTdpTable specific index for the mscAtmIfVptVccVcdRxTdpTable.')
mscAtmIfVptVccVcdRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 298, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdRxTdpTable.')
mscAtmIfVptVccVcdFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 359), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVccVcdFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 359, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpEntry.setDescription('An entry in the mscAtmIfVptVccVcdFqpTable.')
mscAtmIfVptVccVcdFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 359, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdFqpTable specific index for the mscAtmIfVptVccVcdFqpTable.')
mscAtmIfVptVccVcdFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 359, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdFqpTable.')
mscAtmIfVptVccVcdBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 360), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpTable.setDescription('This attribute is migrated to the AtmTmProv group. This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR, and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR, and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVccVcdBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 360, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpEntry.setDescription('An entry in the mscAtmIfVptVccVcdBqpTable.')
mscAtmIfVptVccVcdBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 360, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdBqpTable specific index for the mscAtmIfVptVccVcdBqpTable.')
mscAtmIfVptVccVcdBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 360, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdBqpTable.')
mscAtmIfVptVccVcdTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2))
mscAtmIfVptVccVcdTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccVcdTm components.')
mscAtmIfVptVccVcdTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccVcdTm component.')
mscAtmIfVptVccVcdTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccVcdTm components. These components cannot be added nor deleted.')
mscAtmIfVptVccVcdTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccVcdTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccVcdTm tables.')
mscAtmIfVptVccVcdTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmIndex.setDescription('This variable represents the index for the mscAtmIfVptVccVcdTm tables.')
mscAtmIfVptVccVcdTmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmProvTable.setDescription('This group contains traffic related provisionable attributes for the Vcc, Vpc, and Vpt components. Changing any of the attributes in this group causes a service interruption on the Vcc, Vpc, or Vpt component.')
mscAtmIfVptVccVcdTmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmProvEntry.setDescription('An entry in the mscAtmIfVptVccVcdTmProvTable.')
mscAtmIfVptVccVcdTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9))).clone('n1')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute. This attribute can have a value of 9 if and only if the atmServiceCategory is availableBitRate.')
mscAtmIfVptVccVcdTmFwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n0')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFwdQosClass.setDescription('This attribute specifies the quality of service for the forward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters.')
mscAtmIfVptVccVcdTmTxQueueLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 22), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(5, 512000), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxQueueLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxQueueLimit.setDescription('This attribute specifies an override to the default transmit queue limit for this connection. An value other than sameAsCa may be specified only for ATM IP and 1pOC48SmSrAtm cards. This attribute is not applicable for basic Vpts. A value of sameAsCa means to use the default common or per-VC transmit queue limit as defined by the CA service category for this connection. A value from 5 to 63,488 indicates that a specific transmit queue limit is requested which differs from the default which is defined under the CA component for this service category. A specific value is ignored for connections where common queuing is specified for the service category. For the 1pOC48SmSrAtm card, this attribute is used to set the per VC utilization limit. The actual transmit queue limit for a connection is visible in the Vcc Tm, Vpc Tm or Vpt txQueueThresholds attribute. VALUES ( 0 = sameAsCa )')
mscAtmIfVptVccVcdTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4))).clone('n2')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmHoldingPriority.setDescription('This attribute specifies the holding priority of this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. This value provisioned in the Vcd or Vpd may be overridden by certain applications, for example Vcc Test, which run over this connection. The default holding priority for a provisioned connection is higher then default holding priorities for dynamic (SVC) connections. This attribute is not applicable for Vpt Vccs.')
mscAtmIfVptVccVcdTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 15))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9), ("sameAsTx", 15))).clone('sameAsTx')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTrafficDescType.setDescription('This attribute specifies the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute. When this attribute is set to sameAsTx, the rxTrafficDescType as well as the rxTrafficDescParm are taken from the txTrafficDescType and txTrafficDescParm values.')
mscAtmIfVptVccVcdTmBwdQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("sameAsFwd", 15))).clone('sameAsFwd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBwdQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBwdQosClass.setDescription('This attribute specifies the quality of service for the backward direction for this connection. This attribute is only used for SPVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified bit rate QOS class; no objective is specified for the performance parameters. The sameAsFwd selection sets the backward quality of service to be the same as the forward quality of service.')
mscAtmIfVptVccVcdTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 15))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4), ("derivedFromBBC", 15))).clone('unspecifiedBitRate')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAtmServiceCategory.setDescription("This attribute specifies the ATM service category for both directions of the connection. The value derivedFromBBC may only be used if the SrcPvc component is provisioned under this Vcc. Otherwise a specific ATM service category must be specified. If this attribute is set to derivedFromBBC, the Broadband Bearer Capability (BBC) and bestEffort attributes are used to determine the atmServiceCategory of this connection. If this attribute is set to other than derivedFromBBC, the value of this attribute is used to override the provisioned BBC Information Element parameters. In those cases, the BBC attributes are not used. The constantBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. The rtVariableBitRate service category is intended for real time applications, that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by CTD are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications; that is, those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptVccVcdTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTrafficShaping.setDescription("This attribute specifies whether this connection uses traffic shaping when transmitting traffic to the ATM interface. This attribute is ignored if the atmServiceCategory is availableBitRate. Traffic shaping is not available on the 1pOC12SmLrAtm card, therefore this attribute is ignored. When sameAsCa is selected, traffic shaping for the connection is based on the trafficShaping attribute of the connection's service category component under the CA. If the service category has trafficShaping set to enabled or inverseUpc, then traffic shaping is enabled for the connection. Note that enabling traffic shaping may have no effect under certain cases. These cases are listed in the description of the trafficShaping operational attribute, which is under the Vcc Tm, Vpc Tm, or Vpt Tm components. When disabled is selected, traffic shaping for this connection is disabled regardless of the provisioning of the connection's service category component.")
mscAtmIfVptVccVcdTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("common", 1), ("sameAsCa", 3))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmUnshapedTransmitQueueing.setDescription("This attribute only applies when this connection is unshaped. This attribute specifies the transmit queueing method for this connection if it is unshaped. The two possible methods are per-VC queuing and common queuing. On ATM IP FPs, this attribute must be set to sameAsCa. This attribute is ignored in the following situations: - if the connection has trafficShaping enabled or inverseUpc, or - if the atmServiceCategory is availableBitRate, or - if the atmServiceCategory is constantBitRate and this is a CQC- based ATM FP. - for basic Vpts and standard Vpt Vccs When this attribute is set to sameAsCa, the transmit queueing method for the connection is based on the unshapedTransmitQueueing attribute of the connection's service category component under the CA. When this attribute is set to common, transmit traffic on this unshaped connection is destined for the common queue.")
mscAtmIfVptVccVcdTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 61), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65535, 65535), )).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmWeight.setDescription("This attribute specifies an override for the weight of this unshaped connection. This attribute is ignored for shaped connections, for ABR connections, for connections on a CQC-based ATM FP and basic Vpts. When the value is set to sameAsCa, the weight is determined by the fairnessWeight attribute under the CA service category component for all but standard Vpt Vccs. For standard Vpt Vccs, the weight is determined by the Vcc's service category, when the value is set to sameAsCa. When this attribute is set to a value from 1 to 4095, that value is used for the fairness weight of this connection relative to other connections. For all but standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections in the same service category. For standard Vpt Vccs, fairness weight determines the proportion of transmit cell opportunities which are allocated to this connection, compared to other connections associated with the Vpt. When the value is set to upToQueueLimit, the fairness weight is limited only by the txQueueLimit. VALUES ( 0 = upToQueueLimit 65535 = sameAsCa )")
mscAtmIfVptVccVcdTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1), ("sameAsCa", 2))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmForceTagging.setDescription('This attribute specifies whether force tagging is enforced for this connection for cells in the transmit direction. On CQC-based ATM cards and for Vpts, this attribute is not applicable and is ignored. When the value is set to sameAsCa, the force tagging functionality is determined by the forceTagging attribute under the CA service category component. When the value is set to enabled, force tagging is enabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is set to 1 for all cells in the transmit direction. Cells which are tagged are counted in the txCellClp attribute. When the value is set to disabled, force tagging is disabled for cells in the transmit direction on this connection. When this option is selected, the CLP bit is unchanged for cells in the transmit direction.')
mscAtmIfVptVccVcdTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("sameAsCa", 2), ("monitored", 4))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmUsageParameterControl.setDescription('This attribute specifies whether this connection enforces usage parameter control when receiving traffic from the ATM interface. When sameAsCa is selected, UPC for the connection is based on the usageParameterControl attribute of the service category component under the AtmIf CA. If the service category has UPC enforced or monitored, then UPC is set to that value for the connection. When disabled is selected, UPC for this connection is disabled regardless of the provisioning of the service category. When enforced is selected, UPC for this connection is enforced regardless of the provisioning of the service category. Note that setting UPC to enforced or monitored may have no effect under certain cases. These cases are listed in the description of the usageParameterControl operational attribute, which is under the Vcc, Vpc, and Vpt components.')
mscAtmIfVptVccVcdTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 31))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBearerClassBbc.setDescription('This attribute specifies the bearer capability. This attribute is only used for SPVC and SPVP connections. It is one of the Broadband Bearer Capability (BBC) attributes. The purpose of the BBC information element is to indicate a requested broadband connection-oriented bearer service to be provided by the network. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is set, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements. When c is set, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (vbr or cbr) and timing requirements are user defined (that is, transparent to the network).When x is set the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to specify a transparent VP service. When the value of this attribute is vp, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except or VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP connections.')
mscAtmIfVptVccVcdTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30, 31))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30), ("derivedFromServiceCategory", 31))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTransferCapabilityBbc.setDescription('This attribute specifies the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no notApplicable specifies that the user does not want to specify the transfer capability. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value no indication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required. The value no for end-to-end timing indicates that end-to-end timing is not required. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVccVcdTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmClippingBbc.setDescription('This attribute specifies the value for the clipping susceptibility parameter in the BBC Information Element. This attribute is only used for SPVC connections. It is one of the Broadband Bearer Capability attributes. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through.')
mscAtmIfVptVccVcdTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 15))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("derivedFromServiceCategory", 15))).clone('derivedFromServiceCategory')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBestEffort.setDescription('This attribute specifies the value of the best effort parameter in the ATM Traffic Descriptor Information Element. This attribute is only used for Soft PVC connections. It is one of the Broadband Bearer Capability attributes. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. The value derivedFromServiceCategory specifies that the actual value which is used for this connection is derived from the value of the atmServiceCategory. Either, this attribute must be set to derivedFromServiceCategory, or the atmServiceCategory attribute must be set to derivedFromBBC, but not both.')
mscAtmIfVptVccVcdTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the transmit data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The transmit packet-wise functions are Early Packet Discard (EPD) and Partial Packet Discard (PPD). EPD allows the connection to discard an entire frame once the transmit queue has reached the EPD threshold. EPD increases the 'goodput' of a link, since discarding an entire frame means that some queue capacity is guarded for some other frame which is already partially transmitted. All cells of the frame are discarded from the Beginning of Message (BOM) cell up to and including the End of Message (EOM) cell. PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. On CQC-based ATM cards, the packet-wise discard functions are PPD and EPD. PPD is available at VCC cell-transfer points. PPD is not applicable at frame-cell conversion points, and is not applicable for Vpcs. PPD is configured by this attribute. Packet-wise discard should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in all traffic being discarded. On CQC-based ATM FPs, EPD is automatically enabled at frame-to-cell conversion points, independent of the setting of this attribute. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, packet-wise discard functions include EPD and PPD. PPD and EPD apply to individual VCCs and VCCs within VPCs at all connection points, including tandem VPC connections. Both PPD and EPD are controlled by this attribute. This attribute may safely be set to enabled for any connection (Vcc or Vpc) on ATM IP FPs since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enable packet- wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to transmit traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to transmit traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the backward direction. When this attribute is set to disabled, backward frame discard is not requested in the SPVC call setup. The transmit packet-wise discard functions that are active are visible in the Vcc/Vpc Tm txPacketWiseDiscard operational attribute.")
mscAtmIfVptVccVcdTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxPacketWiseDiscard.setDescription("This attribute specifies whether packet-wise discard functions are to be enabled or disabled in the receive data direction for this connection. Packet-wise discard functions should only be requested if this connection is transferring AAL5 frame traffic. This attribute is not applicable for Vpts. Packet-wise functions increase the 'goodput' of the link. The receive packet-wise function is Partial Packet Discard (PPD). PPD allows the connection to discard the remainder of a cell- forwarded AAL5 frame if one cell of this frame has been discarded, for example due to UPC. All cells are discarded up to but not including the EOM cell. The PPD function increases the 'goodput' of the link, since cells which are only going to be discarded at the AAL5 reassembly point are not transmitted. PPD is available at all VCC connection points where UPC may be activated. PPD is not applicable for Vpcs. On CQC-based ATM FPs, packet-wise discards should only be enabled for connections carrying AAL5 segmentation traffic. Setting the value to enabled for any other traffic type may result in traffic being discarded. On CQC-based ATM cards, at a permanent VCC connection endpoint, this attribute is not applicable and is ignored. If AAL5 segmentation and reassembly has been requested, PPD and Early Packet Discard (EPD) are automatically enabled. On ATM IP cards, this attribute may safely be set to enabled for any connection (Vcc or Vpc) since they have the ability to automatically detect AAL5-segmented traffic on a connection, and only enables packet-wise discards if AAL5-segmented traffic is detected. When this attribute is set to enabled, packet-wise discard functions are applied to receive traffic at this connection point. When this attribute is set to disabled, packet-wise discard functions are not applied to receive traffic at this connection point. At a SPVC origin on a PNNI interface, a value of enabled specifies that frame discard is requested in the forward direction. When this attribute is set to disabled, forward frame discard is not requested in the SPVC call setup. The receive packet-wise discard functions that are active are visible in the Vcc/Vpc Tm rxPacketWiseDiscard operational attribute.")
mscAtmIfVptVccVcdTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 3, 4, 5, 14))).clone(namedValues=NamedValues(("abrSwitch", 0), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("sameAsCa", 14))).clone('sameAsCa')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrConnectionType.setDescription('This attribute specifies the type of ABR behavior which is to be enforced at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServicecategory attribute is not availableBitRate, this attribute value is ignored. The actual ABR functionality which is in effect is visible in the Vcc/Vpc/Vpt Tm abrConnectionType operational attribute. For CQC-based ATM cards, the only allowable values are sameAsCa, nonAbrInterworking or abrSwitch. If abrSwitch is selected, the CQC implements EFCI marking behavior. For the 1pOC12SmLrAtm card, the only allowable values are sameAsCa or abrSwitch. If abrSwitch is selected, EFCI marking behavior is implemented. sameAsCa is used to request the default behavior as specified in the CA Abr component for this Vcc. Otherwise, this attribute overrides the default behavior. virtualSourceDest is used to request that this connection point function as a virtual source/virtual destination. VS/VD functionality is only supported on ATM IP FPs. sourceDest requires that this connection point function as a S/D for RM cells. S/D mode is automatically invoked at this connection point either if this is a connection end point, or if the next hop connection point is configured as nonAbrInterworking. nonAbrInterworking is used to request that this connection point function as an interworking between ABR and non-ABR service categories. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest. abrSwitch is used to request ABR switch behavior for this connection point. The ABR switch behavior is first, to confirm to virtualSourceDest or nonAbrInterworking setting on the next hop, and otherwise to implement ABR ER switch behavior. For CQC- based FPs, ABR switch behavior is implemented as EFCI marking.')
mscAtmIfVptVccVcdTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 456), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpTable.setDescription('This attribute is a vector of five traffic parameters whose meanings are defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR) and requested shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for connection admission control (CAC). The value of CDVT is only used for connections where the atmServiceCategory is constantBitRate. For all other values of atmServiceCategory, CDVT is ignored. The values of PCR, SCR, MCR and requested shaping rate are used to determine the actual shaping rate where traffic shaping is enabled. When txTrafficDescType is 1 or 2, all of the parameters must be set to zero. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be non-zero. Parameters 2 and 3 must be zero. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell discard; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic with cell tagging; parameter 2 represents the PCR for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameter 1 must be greater than or equal to parameter 2. Parameters 1 and 2 must be non-zero. Parameter 3 must be zero. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT; and parameter 5 represents the requested shaping rate. A non-zero value in parameter 5 overrides any value in parameter 1. This result is used as the PCR. Parameters 1, 2 and 3 must be non-zero. Parameter 1 must be greater than or equal to parameter 2. Parameter 5, must either be zero (unused) or greater than or equal to parameter 2. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR; parameter 4 and parameter 5 represent are not used and must be zero. Parameter 1 must be non-zero and must be greater than or equal to parameter 3. Parameter 3 may be optionally zero. Whenever it is valid for PCR to be specified, parameter 5 may also be used to specify a requested shaping rate. A non-zero value in parameter 5 overrides the value in parameter 1 and is used as the peak cell rate in calculations of CAC and shaping rate. When the atmServiceCategory is availableBitRate (ABR), the shaping rate is dynamically chosen, based on the ABR flow control mechanism, as a value between the MCR and the PCR or the requested shaping rate if applicable. For txTrafficDescType 3, 4 and 5, the transmit traffic is shaped at the next available shaping rate less than the PCR. For txTrafficDescType 6, 7 and 8 if linear traffic shaping is selected, the transmit traffic is shaped at the highest available rate which is between PCR and SCR. However, if there is no available shaping rate between PCR and SCR, traffic is shaped at the next rate above the PCR. For txTrafficDescType 6, 7 and 8 if inverse-UPC traffic shaping is selected, the transmit traffic is shaped at a variable rate which conforms to the PCR, SCR and MBS of the connection traffic descriptor. Inverse-UPC traffic shaping is available only on ATM IP cards.')
mscAtmIfVptVccVcdTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 456, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpEntry.setDescription('An entry in the mscAtmIfVptVccVcdTmTxTdpTable.')
mscAtmIfVptVccVcdTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 456, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdTmTxTdpTable specific index for the mscAtmIfVptVccVcdTmTxTdpTable.')
mscAtmIfVptVccVcdTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 456, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdTmTxTdpTable.')
mscAtmIfVptVccVcdTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 457), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR) and Minimum Cell Rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. The value of CDVT is expressed in microseconds. The values of PCR, SCR, MCR, MBS and CDVT are used for usage parameter control (UPC). When rxTrafficDescType is 1 or 2, all of the parameters must be set to zero (unused). When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic. Parameter 1 must be non-zero. Parameters 2 and 3 must be set to zero (unused). When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. Parameters 1 and 2 must be non-zero. Parameter 3 must be set to zero (unused). Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is a 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to Parameter 2. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameters 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. Parameter 1, 2 and 3 must be non- zero. Parameter 1 must be greater than or equal to parameter 2. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the CDVT; parameter 3 represents the MCR. Parameter 4 is not used and must be zero. Parameter 1,must be non- zero and must be greater than or equal to parameter 3. Parameter 3 may optionally be zero. When rxTrafficDescType is any value from 3 through 8, parameter 4 represents the CDVT. If the value of CDVT either in parameter 2 or in parameter 4 is zero, the CDVT is taken from the CA defaults for the particular atmServiceCategory of this connection. On a CQC-based ATM card, when rxTrafficDescriptorType is 3 through 8, there are certain extreme combinations of rxTrafficDescParm which are outside the capabilities of the UPC hardware. The check prov command detects such cases and generates an error message. If this happens, adjust the parameters until they fall within the supported limits. To calculate the limits, use the following formulae: I1 = 1 000 000 000 / PCR L1 = CDVT * 1000 I2 = 1,000,000,000 / SCR L2 = CDVT + (MBS - 1) * (I2 - I1) I1 and I2 must be less than or equal to 335,523,840. I1 + L1 must be less than or equal to 1,342,156,800. I2 + L2 must be less than or equal to 1,342,156,800. Note that I2 and L2 only apply when the rxTrafficDescriptorType is 6 through 8. If the values of I1, L1, I2 or L2 are closer to the limits described above, a further restriction applies. Specifically, if either: I1 > 41,940,480 or I2 > 41,940,480 or I1 + L1 > 167,769,600 or I2 + L2 > 167,769,600 then both I1 and I2 must be greater than 20,480. Parameter 5 of the rxTrafficDescParm is always unused. If the rxTrafficDescType is sameAsTx, the values provisioned in this attribute are ignored. The traffic parameters for the receive direction are taken from the txTrafficDescParm.')
mscAtmIfVptVccVcdTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 457, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpEntry.setDescription('An entry in the mscAtmIfVptVccVcdTmRxTdpTable.')
mscAtmIfVptVccVcdTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 457, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdTmRxTdpTable specific index for the mscAtmIfVptVccVcdTmRxTdpTable.')
mscAtmIfVptVccVcdTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 457, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdTmRxTdpTable.')
mscAtmIfVptVccVcdTmFqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 458), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVccVcdTmFqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 458, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmFqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpEntry.setDescription('An entry in the mscAtmIfVptVccVcdTmFqpTable.')
mscAtmIfVptVccVcdTmFqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 458, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdTmFqpTable specific index for the mscAtmIfVptVccVcdTmFqpTable.')
mscAtmIfVptVccVcdTmFqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 458, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmFqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdTmFqpTable.')
mscAtmIfVptVccVcdTmBqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 459), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpTable.setDescription('This attribute is a vector of three elements that specify the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC connections. The cdv element specifies the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). It is signalled through the extended QoS information element. The ctd specifies the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). It is signalled through the end to end transit delay information element. The clr specifies the acceptable Cell Loss Ratio (CLR) of CBR, rt- VBR, and nrt-VBR connections. It is signalled through the extended QoS information element.')
mscAtmIfVptVccVcdTmBqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 459, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmBqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpEntry.setDescription('An entry in the mscAtmIfVptVccVcdTmBqpTable.')
mscAtmIfVptVccVcdTmBqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 459, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpIndex.setDescription('This variable represents the mscAtmIfVptVccVcdTmBqpTable specific index for the mscAtmIfVptVccVcdTmBqpTable.')
mscAtmIfVptVccVcdTmBqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 459, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmBqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccVcdTmBqpTable.')
mscAtmIfVptVccVcdTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2))
mscAtmIfVptVccVcdTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccVcdTmAbr components.')
mscAtmIfVptVccVcdTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccVcdTmAbr component.')
mscAtmIfVptVccVcdTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccVcdTmAbr components. These components can be added and deleted.')
mscAtmIfVptVccVcdTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccVcdTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccVcdTmAbr tables.')
mscAtmIfVptVccVcdTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVptVccVcdTmAbr tables.')
mscAtmIfVptVccVcdTmAbrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrProvTable.setDescription('This group contains provisioned attributes for the ABR ATM connections configured on an ATM interface.')
mscAtmIfVptVccVcdTmAbrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrProvEntry.setDescription('An entry in the mscAtmIfVptVccVcdTmAbrProvTable.')
mscAtmIfVptVccVcdTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 16777215), ValueRangeConstraint(16777216, 16777216), ValueRangeConstraint(16777217, 16777217), ValueRangeConstraint(16777218, 16777218), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. When this attribute is set to sameAsCa, the initial cell rate is determined by the AtmIf CA Abr/0 icr attribute. When the value of this attribute is set to useMcr, ICR is set to the same value as the Minimum Cell Rate (MCR) for the connection. When the value of this attribute is set to usePcr, ICR is set to the same value as the Peak Cell Rate (PCR) for the connection. If this attribute is specified less than the MCR of the connection, then the MCR is used as the ICR. If this attribute is specified more than PCR of the connection, then PCR is used as the ICR. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa 16777217 = useMcr 16777218 = usePcr )')
mscAtmIfVptVccVcdTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215)).clone(16777215)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrTransientBufferExposure.setDescription('This attribute specifies the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the source to send during start-up periods, before the first Resource Management (RM) cell returns. TBE divided by fixedRoundTripTime determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. TBE divided by maxCellsPerRmCell specifies the operational value of forwardRmCellLimit, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. This attribute is ignored under all conditions where the operational attribute abrConnectionType is set to erSwitch.')
mscAtmIfVptVccVcdTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000)).clone(5000000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrFixedRoundTripTime.setDescription('This attribute specifies the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. The value of transientBufferExposure divided by the value of FRTT (in seconds) determines an upper bound for the operational value of initialCellRate, the rate at which a source should send initially and after an idle period. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch.')
mscAtmIfVptVccVcdTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRateDecreaseFactor.setDescription('This attribute specifies the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrRateIncreaseFactor.setDescription('This attribute specifies the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the provisioned value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrMaxCellPerRmCell.setDescription('This attribute specifies the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. A value of 2 is not recommended although it is permitted according to the ATM Forum standard. When this attribute is set to a value of 2, it is possible that only one forward and one backward RM cell are repeatedly transmitted, and all data traffic is queued up indefinitely. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrMaxTimeBetweenRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrMaxTimeBetweenRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrMaxTimeBetweenRmCells.setDescription('This attribute specifies the TRM parameter for this connection. TRM provides an lower bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least two other cells have been sent, then the next cell to be transmitted would be a forward RM cell. This attribute is ignored under all conditions where the operational attribute abrConnectionType has the value erSwitch. The provisioned value of 781 is signalled as TRM = 0, in the ABR Additional Parameters Information Element. 1563 is signalled as TRM = 1. 3125 is signalled as TRM = 2. 6250 is signalled as TRM = 3. 12500 is signalled as TRM = 4 25000 is signalled as TRM = 5. 50000 is signalled as TRM = 6. 100000 is signalled as TRM = 7. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrCutoffDecreaseFactor.setDescription('This attribute specifies the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the CRM parameter, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is indicated by the forwardRmCellLimit attribute. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 1023), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the maximum time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. This attribute is ignored under all conditions where the operational attribute abrConnectionType indicates erSwitch or efciSwitch. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrDgcraMaximumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrDgcraMaximumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrDgcraMaximumDelay.setDescription('This attribute specifies an upper bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward direction). This upper bound may be approximated as the sum of the round trip fixed and propagation delays and the maximum queuing delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When there is a reduction in the Allowed Cell Rate (ACR), the policer waits for a correspondingly longer period of time before it enforces at the new cell rate. The value of this attribute must not be less than the dgcraMinimumDelay attribute. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrDgcraMinimumDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 16700000), ValueRangeConstraint(16777216, 16777216), )).clone(16777216)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrDgcraMinimumDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrDgcraMinimumDelay.setDescription('This attribute specifies a lower bound on the delay after which the rate change induced by a backward Resource Management (RM) cell departing from this connection point (in the backward direction) is expected to be observed at this connection point (in the forward connection). This lower bound may be approximated as the sum of the round trip fixed and propagation delays between the ABR source and this interface. The value of this attribute is used in policing an ABR connection using the Dynamic General Cell Rate Algorithm (DGCRA). A smaller value for this attribute implies a more lenient policer. When there is a increase in the Allowed Cell Rate (ACR), the policer waits for a correspondingly shorter period of time before it enforces at the new cell rate. VALUES ( 16777216 = sameAsCa )')
mscAtmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor.setDescription('This attribute specifies the Allowed Cell Rate Decrease Time Factor (ADTF) of the far end ABR source. The value specified should be the same as the ADTF parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the value of this attribute, the policer begins to limit enforce the incoming traffic at the initial cell rate (ICR) of the far end, as specified by the farEndInitialCellRate attribute.')
mscAtmIfVptVccVcdTmAbrFarEndInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 2, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrFarEndInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdTmAbrFarEndInitialCellRate.setDescription('This attribute specifies the Initial Cell Rate (ICR) of the far end ABR source. The value specified should be the same as the ICR parameter at the far end of this ABR connection. The value of this attribute is used in policing an ABR connection using the Dynamic Generic Cell Rate Algorithm (DGCRA). A larger value for this attribute implies a more lenient policer. When the delay between two consecutive forward Resource Management (RM) cells received at this interface corresponds to a value greater than the farEndAcrDecreaseTimeFactor attribute, the policer begins to enforce the incoming traffic at the value of this attribute. If this attribute is specified less than the MCR of the connection, then the MCR is used as the feIcr. If this attribute is more than the PCR of the connection, then PCR is used as the feIcr.')
mscAtmIfVptVccVcdPm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3))
mscAtmIfVptVccVcdPmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccVcdPm components.')
mscAtmIfVptVccVcdPmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccVcdPm component.')
mscAtmIfVptVccVcdPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccVcdPm components. These components can be added and deleted.')
mscAtmIfVptVccVcdPmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccVcdPmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccVcdPm tables.')
mscAtmIfVptVccVcdPmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmIndex.setDescription('This variable represents the index for the mscAtmIfVptVccVcdPm tables.')
mscAtmIfVptVccVcdPmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmProvTable.setDescription('This group contains provisioned attributes which specify Performance Monitoring (PM) measurements, namely, Availability Ratio (AR) and Cell Loss Ratio (CLR), and control modes for the connection. The values specified in this group override those specified by AtmIf Pm settings.')
mscAtmIfVptVccVcdPmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccVcdPmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmProvEntry.setDescription('An entry in the mscAtmIfVptVccVcdPmProvTable.')
mscAtmIfVptVccVcdPmSegSwitchSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 100, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmSegSwitchSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmSegSwitchSideMeasurement.setDescription('This attribute specifies the set of Performance Monitoring (PM) measurements on the switch side configuration for the connection. sameAsInterface means that the measurements specified by the segSwitchSideMeasurement attribute of the AtmIf Pm component will be performed. No other values may be specified if sameAsInterface is selected. If the value is empty, no switch side PM measurements are done. Description of bits: availabilityRatio(0) cellLossRatio(1) sameAsInterface(2)')
mscAtmIfVptVccVcdPmSegLinkSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 100, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmSegLinkSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmSegLinkSideMeasurement.setDescription('This attribute specifies the set of Performance Monitoring (PM) measurements on the link side configuration for the connection. sameAsInterface means that the measurements specified by the segLinkSideMeasurement attribute of the AtmIf Pm component will be performed. No other values may be specified if sameAsInterface is selected. If the value is empty, no link side PM measurements are done. The following are valid sets: (~sameAsInterface ~availabilityRatio ~cellLossRatio) (~sameAsInterface ~availabilityRatio cellLossRatio) (~sameAsInterface availabilityRatio ~cellLossRatio) (~sameAsInterface availabilityRatio cellLossRatio) (sameAsInterface ~availabilityRatio ~cellLossRatio) Description of bits: availabilityRatio(0) cellLossRatio(1) sameAsInterface(2)')
mscAtmIfVptVccVcdPmControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 2, 3, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("autoStart", 0), ("onDemand", 1), ("sameAsInterface", 2))).clone('sameAsInterface')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmControlMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccVcdPmControlMode.setDescription('This attribute specifies the control mode of Performance Monitoring (PM) measurements for the connection. autoStart means that PM activation procedures will start when the provisioned data is activated. onDemand means that PM activation procedures will start when the operator issues the START command. The PM measurements in this mode will continue until the operator issues the STOP command. sameAsInterface means that the behavior will be as specified by the controlMode attribute of the AtmIf Pm component.')
mscAtmIfVptVccLoop = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 3))
mscAtmIfVptVccLoopRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 3, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccLoopRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccLoopRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccLoop components.')
mscAtmIfVptVccLoopRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccLoopIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccLoopRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccLoopRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccLoop component.')
mscAtmIfVptVccLoopRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccLoopRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccLoopRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccLoop components. These components can be added and deleted.')
mscAtmIfVptVccLoopComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccLoopComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccLoopComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccLoopStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccLoopStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccLoopStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccLoop tables.')
mscAtmIfVptVccLoopIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccLoopIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccLoopIndex.setDescription('This variable represents the index for the mscAtmIfVptVccLoop tables.')
mscAtmIfVptVccNep = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5))
mscAtmIfVptVccNepRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccNepRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccNep components.')
mscAtmIfVptVccNepRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccNepIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccNepRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccNep component.')
mscAtmIfVptVccNepRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccNepRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccNep components. These components can be added and deleted.')
mscAtmIfVptVccNepComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccNepComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccNepStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccNepStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccNep tables.')
mscAtmIfVptVccNepIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccNepIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepIndex.setDescription('This variable represents the index for the mscAtmIfVptVccNep tables.')
mscAtmIfVptVccNepProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccNepProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepProvTable.setDescription('This group contains provisionable attributes for the Nep component.')
mscAtmIfVptVccNepProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccNepIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccNepProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepProvEntry.setDescription('An entry in the mscAtmIfVptVccNepProvTable.')
mscAtmIfVptVccNepApplicationName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 5, 100, 1, 10), Link()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccNepApplicationName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccNepApplicationName.setDescription("This attribute specifies the application that sends and receives frames using the VCC. This attribute is set, for example, by provisioning the Trunk AtmAccess AtmConnection attribute. If it is properly configured, this attribute will show a value such as 'Trk/22 AtmAccess'.")
mscAtmIfVptVccTest = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6))
mscAtmIfVptVccTestRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccTestRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccTest components.')
mscAtmIfVptVccTestRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTestRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccTest component.')
mscAtmIfVptVccTestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccTest components. These components can be added and deleted.')
mscAtmIfVptVccTestComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccTestStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccTest tables.')
mscAtmIfVptVccTestIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccTestIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestIndex.setDescription('This variable represents the index for the mscAtmIfVptVccTest tables.')
mscAtmIfVptVccTestStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccTestStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which reuses this group. For component-specific information and the valid state combinations, refer to the appropriate NTP.')
mscAtmIfVptVccTestStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTestStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestStateEntry.setDescription('An entry in the mscAtmIfVptVccTestStateTable.')
mscAtmIfVptVccTestAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 100, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock -force or Lock command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscAtmIfVptVccTestOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 100, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscAtmIfVptVccTestUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscAtmIfVptVccTestSetupTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110), )
if mibBuilder.loadTexts: mscAtmIfVptVccTestSetupTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestSetupTable.setDescription('This group contains attributes that govern the operation of an ATM connection test. These attributes cannot be changed while the test is running.')
mscAtmIfVptVccTestSetupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTestSetupEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestSetupEntry.setDescription('An entry in the mscAtmIfVptVccTestSetupTable.')
mscAtmIfVptVccTestFrmTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="c0")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestFrmTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestFrmTypes.setDescription("This attribute specifies the types of the test frames to be transmitted during the ATM connection test. It must contain at least one of the following: loading: A set of 'loading frames' is circulated over the link as rapidly as possible. This frame type should be selected when the test is intended to verify the operation of the connection under a specified load. These frames are not checked for bit errors. verification: A single 'verification frame' is transmitted over the link; when the frame is returned, its contents are verified and the next verification frame in the series is transmitted. This frame type should be selected when the test is intended to verify that frames are not being corrupted as they pass over the connection. Description of bits: loading(0) verification(1)")
mscAtmIfVptVccTestFrmSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 4096)).clone(1024)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestFrmSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestFrmSize.setDescription('This attribute defines the size of the test frames used in an ATM connection test.')
mscAtmIfVptVccTestFrmPatternType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("ccitt32kBitPattern", 0), ("ccitt8MBitPattern", 1), ("customizedPattern", 2))).clone('ccitt32kBitPattern')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestFrmPatternType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestFrmPatternType.setDescription('This attribute specifies the bit sequence used to fill the frames used in the ATM connection test. It must contain one of the following values: ccitt32kBitPattern: a pseudo-random sequence of 32 Kbit is used ccitt8MBitPattern: a pseudo-random sequence of 8Mbit is used customizedPattern: the pattern defined in the customizedPattern attribute is used')
mscAtmIfVptVccTestCustomizedPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1, 40), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1431655765)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestCustomizedPattern.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestCustomizedPattern.setDescription('This attribute specifies a 32 bit sequence to be used to fill frames when the framePatternType attribute is set to customizedPattern. The default value gives a pattern of alternating 0 and 1 bits.')
mscAtmIfVptVccTestDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1, 50), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 30240)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestDuration.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestDuration.setDescription('This attribute specifies the maximum number of minutes that the ATM connection test is allowed to run. The maximum allowed value permits the test to be run for up to 21 days.')
mscAtmIfVptVccTestBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1, 60), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestBandwidthElastic.setDescription('This attribute specifies whether the connection (VCC) should be configured with elastic bandwidth or not. Elastic bandwidth is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be reduced in bandwidth based on the setting of the bwElastic attribute. If this attribute is set to yes, the Test application signals to the connection that the bandwidth for this connection is elastic, and may be reduced in the case of IMA link failures. If the bandwidth is reduced, the rate of test cells which can be handled by the connection will also be reduced. If this attribute is set to no, the Test application signals to the connection that the bandwidth for this connection must be maintained at the requested level. If the connection cannot maintain the full bandwidth, the connection may be released (cleared) based on the holding priority of the connection.')
mscAtmIfVptVccTestOverrideHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 110, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("noOverride", 6))).clone('noOverride')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfVptVccTestOverrideHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestOverrideHoldingPriority.setDescription("This attribute specifies the override holding priority which should be signalled to the VCC connection at the start of the test. Holding priority is of importance in conjuction with IMA links, where some links fail and the resulting bandwidth is less than the requested bandwidth for all connections. In that case, some connections may be released based on the connection's holding priority. Zero (0) is thie highest holding priority, and four (4) is the lowest priority. A setting of zero to four overrides whatever holding priority that has been configured at the connection (VCC). A setting of noOverride means that the connection should use its internally configured holding priority.")
mscAtmIfVptVccTestResultsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120), )
if mibBuilder.loadTexts: mscAtmIfVptVccTestResultsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestResultsTable.setDescription('This group contains attributes that show the result of an ATM connection test; if no test is running, the attribute group contains the results of the most recently completed test. The attributes of the Results group are reset to their inital values whenever a test is started or any attribute of the Setup group is set.')
mscAtmIfVptVccTestResultsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTestIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTestResultsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestResultsEntry.setDescription('An entry in the mscAtmIfVptVccTestResultsTable.')
mscAtmIfVptVccTestElapsedTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestElapsedTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestElapsedTime.setDescription('This attribute displays the number of minutes that the test has been running.')
mscAtmIfVptVccTestTimeRemaining = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30240))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestTimeRemaining.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestTimeRemaining.setDescription('This attribute displays the number of minutes that the test will continue to run before stopping automatically.')
mscAtmIfVptVccTestCauseOfTermination = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("testTimeExpired", 0), ("stoppedByOperator", 1), ("neverStarted", 2), ("testRunning", 3))).clone('neverStarted')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestCauseOfTermination.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestCauseOfTermination.setDescription('This attribute displays the reason the test ended. It contains one fo the following values. testTimeExpired: the test ran for the specified duration stoppedByOperator: a STOP command was issued neverStarted: the test has not been started testRunning: the test is currently running')
mscAtmIfVptVccTestBytesTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 40), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestBytesTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestBytesTx.setDescription('This attribute displays the number of bytes sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTestBytesRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 50), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestBytesRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestBytesRx.setDescription('This attribute displays the number of bytes received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTestLoadingFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 60), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestLoadingFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestLoadingFrmTx.setDescription('This attribute displays the number of loading frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTestLoadingFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 70), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestLoadingFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestLoadingFrmRx.setDescription('This attribute displays the number of loading frames received during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTestLoadingFrmLost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 80), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestLoadingFrmLost.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestLoadingFrmLost.setDescription('This attribute displays the number of loading frames that were lost during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTestVerificationFrmTx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 90), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestVerificationFrmTx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestVerificationFrmTx.setDescription('This attribute displays the number of verification frames sent during the test. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTestVerificationFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 100), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestVerificationFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestVerificationFrmRx.setDescription('This attribute displays the number of verification frames received during the test (including errored verification frames). The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of verification frames lost during the test can be computed by the expression verificationFrmTx - verificationFrmRx.')
mscAtmIfVptVccTestVerificationFrmBad = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 110), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestVerificationFrmBad.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestVerificationFrmBad.setDescription('This attribute displays the number of errored verification frames received during the test. A verification frame is considered to be errored if it contains a recognizable verification frame header, but does not match the transmitted frame bit for bit. (Thus, a verification frame that returns after the succeeding verification frame has been transmitted is considered to be errored.) The counter wraps to zero if it exceeds its maximum value of (2**64)-1. Note that the number of correct verification frames received during the test can be computed by the expression verificationFrmRx - verificationFrmBad.')
mscAtmIfVptVccTestUnrecognizableFrmRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 6, 120, 1, 120), PassportCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTestUnrecognizableFrmRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTestUnrecognizableFrmRx.setDescription('This attribute displays the number of frames received during the test which do not contain a valid loading frame header or verification frame header. The counter wraps to zero if it exceeds its maximum value of (2**64)-1.')
mscAtmIfVptVccTm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7))
mscAtmIfVptVccTmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccTm components.')
mscAtmIfVptVccTmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccTm component.')
mscAtmIfVptVccTmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccTm components. These components cannot be added nor deleted.')
mscAtmIfVptVccTmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccTmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccTm tables.')
mscAtmIfVptVccTmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccTmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmIndex.setDescription('This variable represents the index for the mscAtmIfVptVccTm tables.')
mscAtmIfVptVccTmOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmOperTable.setDescription('This group contains attributes for the Tm component to reflect operational traffic attributes.')
mscAtmIfVptVccTmOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmOperEntry.setDescription('An entry in the mscAtmIfVptVccTmOperTable.')
mscAtmIfVptVccTmTxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTrafficDescType.setDescription('T his attribute indicates the type of traffic management which is applied to the transmit direction of this connection as defined in the ATM Forum. The txTrafficDescType determines the number and meaning of the parameters in the txTrafficDescParm attribute.')
mscAtmIfVptVccTmTxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQosClass.setDescription('This attribute indicates the quality of service for the calling to called direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (Circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (Variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccTmTxQueueLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 32), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 30720))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQueueLength.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQueueLength.setDescription('This attribute indicates the current number of cells in the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the length of the common queue which is used for this atm service category. If this connection has unshapedTransmitQueueing attribute displayed as fifo, this attribute indicates the number of cells for this connection which are enqueued in a first-in-first-out queuing method for this atm service category. This will only occur for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the length of the per-VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current number of cells in the link class queue used by this connection to buffer its traffic. This attribute does not apply to basic Vpts.')
mscAtmIfVptVccTmTxQueueCongestionState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 33), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQueueCongestionState.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQueueCongestionState.setDescription('This attribute indicates the congestion state of the transmit queue for this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the congestion state of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the congestion state of the per- VC queue. For the 1pOC48SmSrAtm card, this attribute displays the current congestion state of the link class queue used by this connection to buffer its traffic. The congestion state of a queue is indicated by a numeric value ranging from 0 to 3. When a queue is in a congested state x, only traffic with discard priority (DP) 0 to x are enqueued. Traffic with DP > x is discarded. For example, if the congestion state is 3, there is no congestion and all traffic is enqueued. Likewise, when the congestion state is 0, there is maximum congestion and only traffic with DP=0 is enqueued on that queue. This attribute does not apply to basic Vpts.')
mscAtmIfVptVccTmHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 6))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmHoldingPriority.setDescription('This attribute indicates the actual holding priority in effect for this connection. In a situation where the link bandwidth fluctuates, such as over an IMA link, holding priority is used to determine which connections are held and which are released. Holding priority 4 connections are the first to be released. Holding priority 0 connections are the last to be released. Some applications, for example Vcc Test, may override the provisioned holding priority. A value of notApplicable is displayed when this is an elastic connection. Holding priority does not apply to bandwidth elastic connections. Holding priority has no effect if the equivalent cell rate (ECR) for a connection is zero. This attribute does not apply to Vpt Vccs.')
mscAtmIfVptVccTmRxTrafficDescType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("n5", 5), ("n6", 6), ("n7", 7), ("n8", 8), ("n9", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTrafficDescType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTrafficDescType.setDescription('This attribute indicates the type of traffic management which is applied to the receive direction of this connection as defined in the ATM Forum. The rxTrafficDescType determines the number and meaning of the parameters in the rxTrafficDescParm attribute.')
mscAtmIfVptVccTmRxQosClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 14, 15))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n3", 3), ("n4", 4), ("notApplicable", 14), ("sameAsFwd", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxQosClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxQosClass.setDescription('This attribute indicates the quality of service for the called to calling direction for this connection. This is only applicable to Soft PVC and SVC connections. Class 1 supports a QOS that meets Service Class A performance requirements (circuit emulation, constant bit rate video). Class 2 supports a QOS that meets Service Class B performance requirements (variable bit rate audio and video). Class 3 supports a QOS that meets Service Class C performance requirements (Connection-Oriented Data Transfer). Class 4 supports a QOS that meets Service Class D performance requirements (Connectionless Data Transfer). Class 0 is the unspecified QOS class; no objective is specified for the performance parameters. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccTmAtmServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("unspecifiedBitRate", 0), ("constantBitRate", 1), ("rtVariableBitRate", 2), ("nrtVariableBitRate", 3), ("availableBitRate", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAtmServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAtmServiceCategory.setDescription("This attribute indicates the ATM service category used for traffic in both directions of the connection. The constantBitRate service category is intended for real time applications, that is, those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. The consistent availability of a fixed quantity of bandwidth is considered appropriate for CBR service. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to have significantly reduced value for the application. The rtVariableBitRate service category is intended for real time applications; that is those requiring tightly constrained delay and delay variation, as would be appropriate for voice and video applications. Sources are expected to transmit at a rate which varies with time. Equivalently, the source can be described as 'bursty'. Cells which are delayed beyond the value specified by Cell Transfer Delay are assumed to be of significantly reduced value to the application. Real time VBR service may support statistical multiplexing of real time sources. The nrtVariableBitRate service category is intended for non-real time applications which have bursty traffic characteristics and which can be characterized in terms of a PCR, SCR, and MBS. For those cells which are transferred within the traffic contract, the application expects a low cell loss ratio. For all connections, it expects a bound on the mean cell transfer delay. Non-real time VBR service may support statistical multiplexing of connections. The availableBitRate service is an ATM layer service category for which the limiting ATM layer transfer characteristics provided by the network may change subsequent to connection establishment. ABR service has a flow control mechanism which supports several types of feedback to control the source rate in response to changing ATM layer transfer characteristics. ABR service is not intended to support real-time applications. The unspecifiedBitRate service is intended for non-real time applications, that is those not requiring tightly constrained delay and delay variation. UBR sources are expected to be bursty. UBR service supports a high degree of statistical multiplexing among sources. UBR service does not specify traffic related service guarantees. No numerical commitments are made with respect to the cell loss ratio experienced by a UBR connection, or as to the cell transfer delay experienced by cells on the connection.")
mscAtmIfVptVccTmTrafficShaping = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("notApplicable", 4), ("linear", 5), ("inverseUpc", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTrafficShaping.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTrafficShaping.setDescription('This attribute indicates the traffic shaping state of the connection. A value of notApplicable indicates that traffic shaping is not applicable or not supported for this connection. This is the case: - when the txTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. - for CQC-based ATM cards, when the atmServiceCategory is constantBitRate. In these cases, the value of notApplicable is set regardless of whether traffic shaping is enabled or disabled in the provisioning data. For the 1pOC12SmLrAtm card, traffic shaping is not available, therefore this attribute is always notApplicable. A value of disabled indicates that traffic shaping is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of linear or inverseUpc indicates that traffic shaping is applicable and supported for the type of connection and has been turned on in the provisioning data. This is the only case that indicates that traffic shaping is performed on the connection. In this case, the actual shaping rate is reflected in the txTrafficDescParm attribute, parameter number 4. A value of linear indicates that traffic is being shaped at the constant rate indicated in txTrafficDescParm 4. A value of inverseUpc is possible only on ATM IP cards. This value indicates that the shaper strictly conforms to the requirements of a dual leaky bucket UPC enforcer. This value is indicated if traffic shaping is enabled, and the txTrafficDescType for this connection is 6, 7 or 8. Traffic shaping for connections with atmServiceCategory as availableBitRate (txTrafficDescType 9) depends upon the abrConnectionType attribute. If abrConnectionType is sourceDest or virtualSourceDest, the value of this attribute is linear. If abrConnectionType is erSwitch or efciSwitch, this attribute is notApplicable.')
mscAtmIfVptVccTmBearerClassBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 16, 24, 30))).clone(namedValues=NamedValues(("a", 1), ("c", 3), ("x", 16), ("vp", 24), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmBearerClassBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmBearerClassBbc.setDescription('This attribute indicates the bearer capability for this connection. Class a service is a connection-oriented, constant bit rate ATM transport service. Class a service has end to end timing requirements and may require stringent cell loss, cell delay and cell delay variation performance.When a is displayed, the user is requesting more than an ATM only service. The network may look at the AAL to provide interworking based upon its contents. Class c service is a connection-oriented, variable bit rate ATM transport service. Class c service has no end-to-end timing requirements.When c is displayed, the user is requesting more than an ATM only service. The network interworking function may look at the AAL and provide service based on it. Class x service is a connection-oriented ATM transport service where the AAL, trafficType (cbr or vbr), and timing requirements are user defined (that is, transparent to the network). When the value of this attribute is x, the user is requesting an ATM only service from the network. In this case, the network shall not process any higher layer protocol. Class vp service is used to indicate a transparent VP service when the user is requesting an ATM only service from the network. In this case, the network does not process any higher layer protocol. This service differs from class x service in that with the class vp service both the VCI field (except for VCI values 0, 3, 4, and 6 through 15) and Payload Type field are transported transparently by the network. This attribute value is only applicable to SPVP and SVP connections. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccTmTransferCapabilityBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 8, 9, 10, 30))).clone(namedValues=NamedValues(("n0", 0), ("n1", 1), ("n2", 2), ("n5", 5), ("n8", 8), ("n9", 9), ("n10", 10), ("notApplicable", 30)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTransferCapabilityBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTransferCapabilityBbc.setDescription('This attribute indicates the transfer capability for this connection. Uni 3.0/3.1 traffic type and end-to-end timing parameters are mapped into this parameter as follows: <transferCapability: TrafficType, Timing> 0: NoIndication, NoIndication 1: NoIndication, yes 2: NoIndication, no 5: CBR, yes 8: VBR, NoIndication 9: VBR, yes 10: VBR, no A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance, or in the case that the transfer capability in the call request was set to NoIndication. The CBR traffic type refers to traffic offered on services such as a constant bit rate video service or a circuit emulation. The VBR traffic type refers to traffic offered on services such as packetized audio and video, or data. The value NoIndication for traffic type is used if the user has not set the traffic type; similarly for end-to-end timing. The value yes for end-to-end timing indicates that end-to-end timing is required for the connection. The value no for end-to-end timing indicates that end-to-end timing is not required for the connection.')
mscAtmIfVptVccTmClippingBbc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 74), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("no", 0), ("yes", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmClippingBbc.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmClippingBbc.setDescription('This attribute indicates the value of the clipping susceptibility parameter in the broadband bearer capability (BBC) Information Element. Clipping is an impairment in which the first fraction of a second of information to be transferred is lost. It occurs after a call is answered and before an associated connection is switched through. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccTmUnshapedTransmitQueueing = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 4, 5))).clone(namedValues=NamedValues(("perVc", 0), ("common", 1), ("notApplicable", 4), ("fifo", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmUnshapedTransmitQueueing.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmUnshapedTransmitQueueing.setDescription('This attribute indicates the unshaped transmit queuing state of the connection. A value of common indicates that transmit traffic is being enqueued onto the common transmit queue for this service category. The txQueueLength attribute indicates the current length of the common transmit queue. A value of fifo indicates that transmit traffic is being queued in a first-in-first-out basis for this service category. This is similar to common queueing, but the txQueueLength attribute indicates the number of cells in this connection queue. A value of fifo will only be indicated for connections on ATM IP cards with atmServiceCategory of nrtVbr or ubr. A value of perVc indicates that transmit traffic is being enqueued onto a per-VC queue for this connection. A value of notApplicable indicates that transmit traffic is being shaped for this connection, or that unshaped transmit queuing is not applicable for this type of connection. Transmit traffic for a shaped connection is enqueued onto a per-VC queue, but this attribute is only applicable for unshaped connections. Unshaped transmit queuing is not applicable for basic Vpts. For 1pOC12SmLrAtm cards, perVc queueing is not available thus this attribute only indicates common or notApplicable.')
mscAtmIfVptVccTmBestEffort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 14))).clone(namedValues=NamedValues(("indicated", 0), ("notIndicated", 1), ("notApplicable", 14)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmBestEffort.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmBestEffort.setDescription('This attribute indicates value of best effort parameter in the ATM Traffic Descriptor Information Element. The value indicated implies that the quality of service for this connection is not guaranteed. The value notIndicated implies that the quality of service for this connection is guaranteed. A value of notApplicable is displayed in the case of nailed-up PVCs for which this attribute has no significance.')
mscAtmIfVptVccTmForceTagging = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 78), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("enabled", 0), ("disabled", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmForceTagging.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmForceTagging.setDescription('This attribute indicates the state of force tagging option for this connection. Force tagging refers to setting the CLP bit for all cells on a connection. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value of enabled indicates that the CLP bit is being set to 1 for all cells in the transmit direction on this connection. A value of disabled indicates that the CLP bit is unchanged for cells in the transmit direction on this connection. disabled is always displayed for Vpts since forced tagging is applied on a per Vpt Vcc basis.')
mscAtmIfVptVccTmWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 79), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 4095), ValueRangeConstraint(65534, 65534), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmWeight.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmWeight.setDescription("This attribute indicates the relative weight of this unshaped connection. Connections with a larger weight get a larger proportion of the link bandwidth or in the case of standard Vpt Vccs, the Vpt bandwidth. For all but standard Vpt Vccs, the default connection weight is determined by the weight policy for a service category and the traffic descriptor for a connection. For standard Vpt Vccs, the default connection weight is determined by the Vcc's service category. For CQC-based ATM cards, this attribute is not applicable and is not displayed. A value from 1 to 4095 indicates an actual weight. The value upToQueueLimit indicates that the weight of a connection is up to the transmit queue limit for this connection. upToQueueLimit is used with common (first-in-first-out) queueing. This attribute is displayed as notApplicable if: - this connection has trafficShaping displayed as linear or inverseUpc. - this is a basic Vpt. VALUES ( 0 = upToQueueLimit 65534 = notApplicable )")
mscAtmIfVptVccTmUsageParameterControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3, 4))).clone(namedValues=NamedValues(("enforced", 0), ("disabled", 1), ("notApplicable", 3), ("monitored", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmUsageParameterControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmUsageParameterControl.setDescription("This attribute indicates the UPC state of the connection. A value of notApplicable indicates that UPC is not applicable or not supported for the connection. This is the case: - when the connection's rxTrafficDescType is 1 or 2. - for standard Vpt Vccs and basic Vpts. A value of notApplicable is set regardless of whether UPC is disabled or enabled in provisioning data. A value of disabled indicates that UPC is applicable and supported for the type of connection but has been turned off in the provisioning data. A value of enforced indicates that UPC is actively checking conformance for the connection and is discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. On ATM IP cards, the counts of UPC violations are visible in the Vcc, Vpc or Vpt rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. ATM IP cards provide the ability to monitor UPC violations without tagging or discarding. A value of monitored indicates that UPC is actively checking conformance for the connection and counting the violations, but is not discarding or tagging cells which do not conform to the connection traffic contract. The traffic descriptor parameters used for UPC conformance are reflected in the rxTrafficDescParms of the connection. The counts of UPC violations are visible in the Vcc, Vpc or Vpt. rxUpcViolationsOnEnforcer1 or rxUpcViolationsOnEnforcer2 attributes. The value of monitored appears only on ATM IP cards. If the atmServiceCategory for this connection is availableBitRate, a value of enforced indicates that Dynamic Generic Cell Rate Algorithm (DGCRA) is active for the connection. The traffic descriptor parameters used for DGCRA enforcement are reflected in the rxTrafficDescParm of the connection.")
mscAtmIfVptVccTmTxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 85), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the transmit data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. On CQC-based ATM cards, PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. A value of wred indicates that Weighted Random Early Detection is in effect at this connection point. W-RED can be enabled by provisioning for PVCs and SPVCs. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1) wred(2)')
mscAtmIfVptVccTmRxPacketWiseDiscard = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 86), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxPacketWiseDiscard.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxPacketWiseDiscard.setDescription('This attribute indicates the current set of packet-wise discard functions in effect in the receive data direction at this connection point. A value of ppd indicates that the Partial Packet Discard (PPD) function is in effect. PPD may be applied at an intermediate connecting point for a connection which is transporting frame traffic (AAL5 at the endpoint). PPD is controlled by provisioning for PVCs and SPVCs, and by call setup parameters in the AAL and Traffic Descriptor Information Elements. A value of epd indicates that the Early Packet Discard (EPD) function is in effect at this connection endpoint. PPD and EPD are enabled by default at a connection endpoint which is performing AAL5 segmentation and assembly. On ATM IP cards, all packet-wise discard functions also apply to provisioned virtual path connections (VPCs). On CQC-based ATM cards, packet-wise functions are not applicable for VPCs. This attribute is not applicable for Vpts. Description of bits: ppd(0) epd(1)')
mscAtmIfVptVccTmBandwidthElastic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 90), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmBandwidthElastic.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmBandwidthElastic.setDescription('This attribute is only of importance for connections which are carried on a link with a variable bandwidth. For example, the bandwidth may be reduced in the event that one or more physical links in the IMA group fail, such that the originally requested bandwidth cannot be maintained. This attribute shows whether the application (for example, Trunk) running on this connection can continue to operate if the bandwidth is reduced. If the bandwidth is reduced, the amount by which it is reduced is displayed in the bandwidthReduction attribute. A value of yes, indicates that this connection is elastic, and the bandwidth may be reduced but the connection is not released. A value of no indicates that the bandwidth for this connection is not reduced in the event of link bandwidth reduction. However, this connection may be released based on its holdingPriority. Bandwidth elasticity has no effect for connections which have an equivalent cell rate (ECR) of zero. This attribute is not applicable for Vpts and Vpt Vccs.')
mscAtmIfVptVccTmBandwidthReduction = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 100), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmBandwidthReduction.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmBandwidthReduction.setDescription('This attribute shows the amount by which the bandwidth has been reduced for this connection. This value is non-zero only for connections which have bandwidthElastic displayed as yes, and which are also operating in a reduced bandwidth mode. This is typically the case for selected connections running over an IMA link. This attribute takes a value from 0 (no reduction) up to the ECR. For all connections which are running at their full allocated bandwidth, bwReduction has the value 0. Connections which have been reduced in allocated bandwidth have a positive number for this attribute. The bwReduction may be subtracted from the ECR (which is displayed as txTrafficDescParm 5) to determine the actual bandwidth allocated to this connection.')
mscAtmIfVptVccTmAbrConnectionType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 100, 1, 110), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 15))).clone(namedValues=NamedValues(("erSwitch", 1), ("efciSwitch", 2), ("virtualSourceDest", 3), ("sourceDest", 4), ("nonAbrInterworking", 5), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrConnectionType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrConnectionType.setDescription('This attribute indicates the type of ABR behavior which is in effect at this connection. This attribute is only applicable if the atmServiceCategory attribute is availableBitRate. If the atmServiceCategory attribute is not availableBitRate, this attribute value is set to notApplicable. For CQC-based ATM cards and the 1pOC12SmLrAtm card, the notApplicable, efciSwitch or nonAbrInterworking. In EFCI marking mode, the Explicit Forward Congestion Indication (EFCI) field in the data cell headers is used to indicate transmit queue congestion. For ATM IP cards other than 1pOC12SmLrAtm, if the displayed as connectionEndPoint, this attribute has the value sourceDest. In this mode, the ABR Source and Destination behavior is in effect at this connection. This attribute is also sourceDest in the case where the next hop connection is specified as nonAbrInterworking. The next hop connection is the Vcc or Vpc identified by the nextHop attribute of the Nrp or Rp component. If the connectionPointType is not connectionEndPoint, the value of this attribute depends upon the abrConnectionType provisioning and the card type to which the traffic is forwarded on the backplane. The default abrConnectionType is provisioned at the CA Abr abrConnectionType attribute, and may be overridden for a provisioned connection in the Vcd Tm abrConnectionType or Vpd Tm abrConnectionType attribute. If the CA Abr abrConnectionType attribute is virtualSourceDest at either one of the two connection points, and if both the connection points are defined on ATM IP cards, virtual source and destination behavior is applied to the connection. In this instance, the attribute displays the value virtualSourceDest. This attribute has the value erSwitch if ABR explicit rate functionality is in effect at this connection. In this mode, the switch may modify the Explicit Rate (ER) field of backward Resource Management (RM) cells to indicate the status of congestion at this connection point. This attribute has the value nonAbrInterworking in the case where this connection point is functioning as an SPVC origin for an ABR connection where the link side of this connection is configured as a non-ABR ATM service category. This means that there are no RM cells on the link side of this connection, and that the next hop connection point is performing as an ABR sourceDest.')
mscAtmIfVptVccTmTxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 451), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpTable.setDescription('This attribute is a vector of five transmit traffic parameters whose mapping is defined by the txTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), Minimum Cell Rate (MCR), actual cell rate (ACR), explicit rate (ER), equivalent cell rate (ECR), and actual shaping rate are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. CDVT is expressed in microseconds. When txTrafficDescType is 1 or 2, parameters 1 through 5 are unused. In this description, PCR is the greater of either the PCR or the requested shaping rate (parameter 1 or parameter 5) specified in the txTrafficDescParm attribute under the Vcd Tm or Vpd Tm component. When txTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 or 1 traffic; parameters 2 and 3 are unused. When txTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard. When txTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging. When txTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic. When txTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic. When txTrafficDescType is 3, 4, 5, 6, 7, or 8, parameter 4 reflects the actual shaping rate in cell/s for this connection. For CQC-based ATM cards, the set of available shaping rates is based on the number of interfaces doing shaping (attribute perVcQueueInterfaces), and the shapingScalingFactor attribute of the Arc Cqc Override component. A rate of zero (0) indicates that shaping is not performed, or that the interface is down. When txTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents the Cell Delay Variation Toleration (CDVT); parameter 3 represents the Minimum Cell Rate (MCR); the meaning of parameter 4 depends upon the value of the abrConnectionType attribute. if abrConnectionType is sourceDest or virtualSourceDest, parameter 4 represents the Allowed Cell Rate (ACR); If abrConnectionType is erSwitch, parameter 4 represents the Explicit Rate (ER); and if abrConnectionType is efciSwitch, parameter 4 reflects the actual shaping rate in cell/s for this connection. When txTrafficDescType is 3, 4, 5, 6, 7, 8, or 9, parameter 5 reflects the equivalent cell rate in cell/s for this connection as determined by the Connection Admission Control (CAC) algorithm. The equivalent cell rate is useful in determining the admission characteristics of this connection.')
mscAtmIfVptVccTmTxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 451, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmTxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpEntry.setDescription('An entry in the mscAtmIfVptVccTmTxTdpTable.')
mscAtmIfVptVccTmTxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 451, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 5)))
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccTmTxTdpTable specific index for the mscAtmIfVptVccTmTxTdpTable.')
mscAtmIfVptVccTmTxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 451, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccTmTxTdpTable.')
mscAtmIfVptVccTmTxQThreshTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 452), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshTable.setDescription('This attribute indicates the queue limit and the discard thresholds for the transmit queue of this connection. If this connection has unshapedTransmitQueueing attribute displayed as common, this attribute displays the thresholds of the common queue. If this connection has unshapedTransmitQueueing attribute displayed as perVc or as notApplicable, this attribute displays the thresholds of the per-VC queue. The first element indicates the queue limit. The provisioned value of the transmit queue limit is derived from the txQueueLimit attribute under the service category subcomponents of the CA component for the service category of this connection. The second element is the threshold that marks the transition from congestion state 1 to congestion state 0. This is the threshold at which traffic with discard priority (DP) = 1 is discarded. This threshold is set at approximately 90 percent of the first parameter, the operational queue limit. The third element is the threshold that marks the transition from congestion state 2 to congestion state 1. This is the threshold at which traffic with DP = 2 is discarded. This threshold is set at approximately 75 percent of the first parameter, the operational queue limit. The fourth element is the threshold that marks the transition from congestion state 3 to congestion state 2. This is the threshold at which traffic with DP = 3 is discarded. This threshold is set at approximately 35 percent of the first parameter, the operational queue limit. This attribute does not apply to basic Vpts.')
mscAtmIfVptVccTmTxQThreshEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 452, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmTxQThreshIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshEntry.setDescription('An entry in the mscAtmIfVptVccTmTxQThreshTable.')
mscAtmIfVptVccTmTxQThreshIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 452, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 3)))
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshIndex.setDescription('This variable represents the mscAtmIfVptVccTmTxQThreshTable specific index for the mscAtmIfVptVccTmTxQThreshTable.')
mscAtmIfVptVccTmTxQThreshValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 452, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 512000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTxQThreshValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccTmTxQThreshTable.')
mscAtmIfVptVccTmRxTdpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 453), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpTable.setDescription('This attribute is a vector of four traffic parameters whose meanings are defined by the rxTrafficDescType attribute. The values of peak cell rate (PCR), sustained cell rate (SCR), minimum cell rate (MCR) are expressed in cell/s. Maximum burst size (MBS) is expressed in cells. Cell delay variation tolerance (CDVT) is expressed in microseconds. When rxTrafficDescType is 1 or 2, none of the parameters are used. When rxTrafficDescType is 3, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 4, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell discard; parameter 4 represents the CDVT. When rxTrafficDescType is 5, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the PCR for CLP equal to 0 traffic with cell tagging; parameter 4 represents the CDVT. When rxTrafficDescType is 6, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 and 1 traffic; parameter 3 represents the MBS for CLP equal to 0 and 1 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 7, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell discard; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 8, parameter 1 represents the PCR for CLP equal to 0 and 1 traffic; parameter 2 represents the SCR for CLP equal to 0 traffic with cell tagging; parameter 3 represents the MBS for CLP equal to 0 traffic; parameter 4 represents the CDVT. When rxTrafficDescType is 9, parameter 1 represents the PCR; parameter 2 represents CDVT; parameter 3 represents the MCR; parameter 4 is not used. If upc is disabled for this connection, the values of PCR, SCR, MBS and CDVT are the provisioned parameters. If upc is enabled, the values of PCR, SCR, MBS, and CDVT are exactly the values used by the usage parameter control hardware in policing the arriving traffic. These may vary slightly from the provisioned values due to granularity of the hardware. In the case where the PCR is equal to the SCR, the effective MBS is zero.')
mscAtmIfVptVccTmRxTdpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 453, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmRxTdpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpEntry.setDescription('An entry in the mscAtmIfVptVccTmRxTdpTable.')
mscAtmIfVptVccTmRxTdpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 453, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpIndex.setDescription('This variable represents the mscAtmIfVptVccTmRxTdpTable specific index for the mscAtmIfVptVccTmRxTdpTable.')
mscAtmIfVptVccTmRxTdpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 453, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRxTdpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccTmRxTdpTable.')
mscAtmIfVptVccTmTqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 454), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the forward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptVccTmTqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 454, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmTqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpEntry.setDescription('An entry in the mscAtmIfVptVccTmTqpTable.')
mscAtmIfVptVccTmTqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 454, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpIndex.setDescription('This variable represents the mscAtmIfVptVccTmTqpTable specific index for the mscAtmIfVptVccTmTqpTable.')
mscAtmIfVptVccTmTqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 454, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmTqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccTmTqpTable.')
mscAtmIfVptVccTmRqpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 455), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpTable.setDescription('This attribute is a vector of three elements that indicate the quality of service parameters for the backward direction for this connection. This attribute is used for SPVC and SVC connections on a PNNI interface. The cdv element indicates the acceptable peak-to-peak Cell Delay Variation (CDV) of real-time connections (CBR and rt-VBR). The ctd element indicates the acceptable maximum Cell Transfer Delay (maxCtd) of real-time connections (CBR and rt-VBR). The clr element indicates the acceptable Cell Loss Ratio (CLR) of CBR, rt-VBR, and nrt-VBR connections.')
mscAtmIfVptVccTmRqpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 455, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmRqpIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpEntry.setDescription('An entry in the mscAtmIfVptVccTmRqpTable.')
mscAtmIfVptVccTmRqpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 455, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("cdv", 0), ("ctd", 1), ("clr", 2))))
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpIndex.setDescription('This variable represents the mscAtmIfVptVccTmRqpTable specific index for the mscAtmIfVptVccTmRqpTable.')
mscAtmIfVptVccTmRqpValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 455, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmRqpValue.setDescription('This variable represents an individual value for the mscAtmIfVptVccTmRqpTable.')
mscAtmIfVptVccTmAbr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2))
mscAtmIfVptVccTmAbrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 1), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfVptVccTmAbr components.')
mscAtmIfVptVccTmAbrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfVptVccTmAbr component.')
mscAtmIfVptVccTmAbrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfVptVccTmAbr components. These components cannot be added nor deleted.')
mscAtmIfVptVccTmAbrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfVptVccTmAbrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrStorageType.setDescription('This variable represents the storage type value for the mscAtmIfVptVccTmAbr tables.')
mscAtmIfVptVccTmAbrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrIndex.setDescription('This variable represents the index for the mscAtmIfVptVccTmAbr tables.')
mscAtmIfVptVccTmAbrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110), )
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrOperTable.setDescription('This group contains operational attributes for connections using ABR service category.')
mscAtmIfVptVccTmAbrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfVptVccTmAbrIndex"))
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrOperEntry.setDescription('An entry in the mscAtmIfVptVccTmAbrOperTable.')
mscAtmIfVptVccTmAbrInitialCellRate = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrInitialCellRate.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrInitialCellRate.setDescription('This attribute indicates the Initial Cell Rate (ICR) parameter for this connection. ICR is the rate at which a source should send initially and after an idle period. For nailed-up connections, this attribute is determined by the provisioned value of the initialCellRate attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element. The ICR for a connection is a value between the MCR and the PCR. Furthermore, ICR has an upper bound determined by the transientBufferExposure divided by fixedRoundTripTime.')
mscAtmIfVptVccTmAbrTransientBufferExposure = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrTransientBufferExposure.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrTransientBufferExposure.setDescription('This attribute indicates the Transient Buffer Exposure (TBE) for this connection. TBE is the negotiated number of cells that the network would like to limit the resource to send during start-up periods, before the first Resource Management (RM) cell returns. For nailed-up connections, this attribute is determined by the provisioned value of the transientBufferExposure attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptVccTmAbrFixedRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16700000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrFixedRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrFixedRoundTripTime.setDescription('This attribute indicates the Fixed Round-Trip Time (FRTT) parameter for this connection. FRTT is the sum of the fixed and propagation delays from the source to a destination and back. For nailed-up connections, this attribute is determined by the provisioned value of the fixedRoundTripTime attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptVccTmAbrRateDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRateDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRateDecreaseFactor.setDescription('This attribute indicates the Rate Decrease Factor (RDF) for this connection. The RDF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 8, RDF is 2E-8 = 1/256. RDF controls the amount by which the cell transmission rate may decrease upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) field set to 1, the Allowed Cell Rate (ACR) value would be reduced by the amount (RDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptVccTmAbrRateIncreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRateIncreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRateIncreaseFactor.setDescription('This attribute indicates the Rate Increase Factor (RIF) for this connection. The RIF value is computed by using the operational value of this attribute, n, as 2 to the inverse power n. For example, if the value of this attribute is 6, RIF is 2E-6 = 1/64. RIF controls the amount by which the cell transmission rate may increase upon receipt of a backward Resource Management (RM) cell. For example, if a backward RM cell is received with the Congestion Indication (CI) and the No Increase (NI) fields both set to 0, the Allowed Cell Rate (ACR) value would be increased by the amount (RIF*ACR). The ACR is not allowed to exceed the Peak Cell Rate (PCR), in which case the ACR is set to PCR. For nailed-up connections, this attribute is determined by the provisioned value of the rateIncreaseFactor attribute. For signalled connections, it is indicated in the ABR Setup Parameters Information Element.')
mscAtmIfVptVccTmAbrMaxCellPerRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 15), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ValueRangeConstraint(128, 128), ValueRangeConstraint(256, 256), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrMaxCellPerRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrMaxCellPerRmCell.setDescription('This attribute indicates the maximum number of cells an ABR source may transmit for each forward Resource Management (RM) cell. The count of the cells transmitted includes data cells, OAM cells, backward RM cells, and the forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxCellsPerRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptVccTmAbrMaxTimeBetweenRmCell = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 16), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(781, 781), ValueRangeConstraint(1563, 1563), ValueRangeConstraint(3125, 3125), ValueRangeConstraint(6250, 6250), ValueRangeConstraint(12500, 12500), ValueRangeConstraint(25000, 25000), ValueRangeConstraint(50000, 50000), ValueRangeConstraint(100000, 100000), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrMaxTimeBetweenRmCell.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrMaxTimeBetweenRmCell.setDescription('This attribute indicates the TRM parameter for this connection. TRM provides an upper bound on the time interval between forward Resource Management (RM) cells for an ABR source. Since the last forward RM cell was sent, if at least TRM time has elapsed since and at least 2 other cells have been sent, the next cell to be transmitted would be a forward RM cell. For nailed-up connections, this attribute is determined by the provisioned value of the maxTimeBetweenRmCell attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptVccTmAbrCutoffDecreaseFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 17), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 1), ValueRangeConstraint(2, 2), ValueRangeConstraint(4, 4), ValueRangeConstraint(8, 8), ValueRangeConstraint(16, 16), ValueRangeConstraint(32, 32), ValueRangeConstraint(64, 64), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrCutoffDecreaseFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrCutoffDecreaseFactor.setDescription('This attribute indicates the Cutoff Decrease Factor (CDF) parameter for this connection. When the value of this attribute is non-zero, CDF is computed as the inverse of the value. For example, if the value is 32, the value of CDF is 1/32. When the value of this attribute is 0, CDF is also zero. CDF controls the decrease in the Allowed Cell Rate (ACR) associated with the forwardRmCellLimit attribute, the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the ACR value would be decreased by the amount (CDF*ACR). The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. For nailed-up connections, this attribute is determined by the provisioned value of the cutoffDecreaseFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptVccTmAbrAcrDecreaseTimeFactor = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrAcrDecreaseTimeFactor.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrAcrDecreaseTimeFactor.setDescription('This attribute indicates the Allowed Cell Rate Decrease Time Factor (ADTF) parameter for this connection. ADTF is the time interval permitted between sending forward Resource Management (RM) cells before the Allowed Cell Rate (ACR) is decreased to initialCellRate. In other words, if the source does not transit a forward RM cell for the period specified by adtf, it reduces its ACR to the value of its initialCellRate. For nailed-up connections, this attribute is determined by the provisioned value of the acrDecreaseTimeFactor attribute. For signalled connections, it is indicated in the ABR Additional Parameters Information Element.')
mscAtmIfVptVccTmAbrForwardRmCellLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 1), ValueRangeConstraint(3, 3), ValueRangeConstraint(7, 7), ValueRangeConstraint(15, 15), ValueRangeConstraint(31, 31), ValueRangeConstraint(63, 63), ValueRangeConstraint(127, 127), ValueRangeConstraint(255, 255), ValueRangeConstraint(511, 511), ValueRangeConstraint(1023, 1023), ValueRangeConstraint(2047, 2047), ValueRangeConstraint(4095, 4095), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrForwardRmCellLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrForwardRmCellLimit.setDescription('This attribute indicates the CRM parameter for this connection. CRM is the limit of the number of forward Resource Management (RM) cells which may be sent in the absence of received backward RM cells. When this limit is crossed, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. The ACR is not allowed to fall below the Minimum Cell Rate (MCR), in which case the ACR is set to MCR. The value of CRM is obtained as transientBufferExposure divided by maxCellsPerRmCell.')
mscAtmIfVptVccTmAbrTxRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("congestionIndicated", 0), ("noIncreaseIndicated", 1), ("explicitRateIndicated", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrTxRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrTxRateChangeInfo.setDescription('This attribute indicates the rate change information put into the last forward Resource Management (RM) cell turned around as a backward-RM cell. For connections configured as an ABR Source or Destination, the turned around backward-RM cell is sent over the interface. For connections configured as an ABR Virtual Source or Virtual Destination, the turned around backward-RM cell is sent over the backplane.')
mscAtmIfVptVccTmAbrAcrRateChangeInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 15))).clone(namedValues=NamedValues(("noChange", 0), ("decreasedByRdf", 1), ("increasedByRif", 2), ("setToExplicitRate", 3), ("notApplicable", 15)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrAcrRateChangeInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrAcrRateChangeInfo.setDescription('This attribute indicates the type of change in the Allowed Cell Rate (ACR) as a result of the information in the last backward Resource Management (B-RM) cell received from the interface. This attribute value is only applicable when the Vcc Tm or Vpc Tm abrConnectionType attribute is sourceDest or VirtualSourceDest. In all other cases, this attribute value is notApplicable. A value of noChange indicates that the rate did not change as a result of the last backward RM cell received. A value of decreasedByRdf or increasedByRif indicates that the ACR was increased or decreased by the corresponding factor. This change is as a result of the CI or NI bit setting in the last backward RM cell, or an ADTF timeout. A value of setToExplicitRate indicates that the ACR was set to the ER value in the last backward RM cell.')
mscAtmIfVptVccTmAbrTxFwdRmCells = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrTxFwdRmCells.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrTxFwdRmCells.setDescription('This attribute counts the number of forward Resource Management (RM) cells sent over the interface since the last backward RM-cell was received from the interface. If the value of this attribute is greater than or equal to the value of forwardRmCellLimit, the Allowed Cell Rate (ACR) value would be decreased by the amount (CDF*ACR), where CDF is determined by the cutoffDecreaseFactor. This counter is reset to zero each time a backward-RM cell is received. This counter does not wrap to zero if it reaches its maximum value of 4095 in order to indicate that no backward RM cell has been received.')
mscAtmIfVptVccTmAbrRxEfci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 9, 20, 7, 2, 110, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("notIndicated", 0), ("indicated", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRxEfci.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfVptVccTmAbrRxEfci.setDescription('This attribute indicates the value of the Explicit Forward Congestion Indication (EFCI) bit of the last data cell received from the interface. When a forward Resource Management (RM) cell is turned around as a backward-RM cell, the Congestion Indication (CI) field of the backward-RM cell is set to 1, if the value of this attribute is indicated. This attribute is set to notIndicated each time a backward-RM cell is transmitted.')
mscAtmIfEp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10))
mscAtmIfEpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 1), )
if mibBuilder.loadTexts: mscAtmIfEpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfEp components.')
mscAtmIfEpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfEpIndex"))
if mibBuilder.loadTexts: mscAtmIfEpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfEp component.')
mscAtmIfEpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfEpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfEp components. These components can be added and deleted.')
mscAtmIfEpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfEpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfEpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfEpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpStorageType.setDescription('This variable represents the storage type value for the mscAtmIfEp tables.')
mscAtmIfEpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(2, 7)))
if mibBuilder.loadTexts: mscAtmIfEpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpIndex.setDescription('This variable represents the index for the mscAtmIfEp tables.')
mscAtmIfEpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 100), )
if mibBuilder.loadTexts: mscAtmIfEpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpProvTable.setDescription('This group contains provisioned attributes which specify the behavior of an emission priority for the ATM interface.')
mscAtmIfEpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfEpIndex"))
if mibBuilder.loadTexts: mscAtmIfEpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpProvEntry.setDescription('An entry in the mscAtmIfEpProvTable.')
mscAtmIfEpMinimumBandwidthGuarantee = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 10, 100, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 100), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfEpMinimumBandwidthGuarantee.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfEpMinimumBandwidthGuarantee.setDescription('This attribute specifies the minimum bandwidth guarantee associated with this EmissionPriority. A minimum bandwidth guarantee is designed to prevent starvation of traffic at this EP by traffic at higher EPs. Minimum bandwidth guarantees only operate for EPs within the guaranteed bandwidth range 2 through 7. Note, that for APC-based cards, EPs 5 and 6 are not supported. The minimum bandwidth guarantee specified is a percentage of the bandwidth which remains after all traffic at EP 0 and EP 1 is served. For example, if EP 0 and EP 1 traffic consumes 20% of link bandwidth, the minimum bandwidth guarantee applies to the remaining 80% of the link bandwidth. A minimum bandwidth guarantee of 2% would actually result in this EP getting 2% of 80% (total 1.6%) of the link bandwidth. The sum of minimumBandwidthGuarantee values for all Eps under an AtmIf must not exceed 100%. The value priority specifies that this Ep gets the bandwidth guarantee which is applicable based on the hierarchy of emission priorities. In this case, there is no minimum bandwidth guarantee. For all non Apc-based cards the allowed value of the attribute is between 0 and 48. Such a value specifies that from 1% to 48% of the remaining link bandwidth is reserved for traffic at this EP. Given a value n of minimumBandwidthGuarantee, then for n% of transmit cell opportunities in the guaranteed bandwidth range, this EP get first opportunity to send a cell. If this EP uses less than n% of the link bandwidth, the extra opportunities are allocated in priority. Due to scheduling and cell arrival times, traffic at this EP may not necessarily achieve full utilization of its minimum bandwidth guarantee. When specifying a value for minimumBandwidthGuarantee, consider the effect on cell delay variation (CDV) of traffic which would normally be of higher priority. For example, if RtVbr service category traffic is assigned to Ep/2 and Ubr traffic is assigned on Ep/7 where Ep/7 has a minimumBandwidthGuarantee of 25%, there can be a large impact on CDV of the RtVbr traffic. Traffic of the Cbr or RtVbr service category which is sensitive to CDV and is of known volume, can be assigned on EP 0 or EP 1 which are independent of the effects of minimum bandwidth guarantee. VALUES ( 0 = priority )')
mscAtmIfPm = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11))
mscAtmIfPmRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 1), )
if mibBuilder.loadTexts: mscAtmIfPmRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmRowStatusTable.setDescription('This entry controls the addition and deletion of mscAtmIfPm components.')
mscAtmIfPmRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfPmIndex"))
if mibBuilder.loadTexts: mscAtmIfPmRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmRowStatusEntry.setDescription('A single entry in the table represents a single mscAtmIfPm component.')
mscAtmIfPmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPmRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscAtmIfPm components. These components cannot be added nor deleted.')
mscAtmIfPmComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPmComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscAtmIfPmStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscAtmIfPmStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmStorageType.setDescription('This variable represents the storage type value for the mscAtmIfPm tables.')
mscAtmIfPmIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscAtmIfPmIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmIndex.setDescription('This variable represents the index for the mscAtmIfPm tables.')
mscAtmIfPmProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 100), )
if mibBuilder.loadTexts: mscAtmIfPmProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmProvTable.setDescription('This group contains provisioned attributes which specify the default Performance Monitoring (PM) measurements, namely, Cell Loss Ratio (CLR) and Availability Ratio (AR), and control modes for all AtmIf Vcc and AtmIf Vpc connections on the ATM interface.')
mscAtmIfPmProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 100, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfIndex"), (0, "Nortel-MsCarrier-MscPassport-AtmCoreMIB", "mscAtmIfPmIndex"))
if mibBuilder.loadTexts: mscAtmIfPmProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmProvEntry.setDescription('An entry in the mscAtmIfPmProvTable.')
mscAtmIfPmSegSwitchSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 100, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPmSegSwitchSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmSegSwitchSideMeasurement.setDescription('This attribute specifies the default Performance Monitoring (PM) measurements on the switch side configuration for all AtmIf Vcc and AtmIf Vpc connections on the ATM interface. Description of bits: availabilityRatio(0) cellLossRatio(1)')
mscAtmIfPmSegLinkSideMeasurement = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 100, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPmSegLinkSideMeasurement.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmSegLinkSideMeasurement.setDescription('This attribute specifies the default Performance Monitoring (PM) measurements on the link side configuration for all AtmIf Vcc and AtmIf Vpc connections, on the ATM interface. Description of bits: availabilityRatio(0) cellLossRatio(1)')
mscAtmIfPmControlMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 114, 11, 100, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("autoStart", 0), ("onDemand", 1))).clone('autoStart')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscAtmIfPmControlMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscAtmIfPmControlMode.setDescription('This attribute specifies the default control mode of Performance Monitoring (PM) measurements for all AtmIf Vcc and AtmIf Vpc connections on the ATM interface. autoStart means Performance Monitoring (PM) measurements start when the provisioned data is activated. onDemand means PM measurements start when the operator issues the START conmmand. The PM measurements in this mode will continue until the operator issues the STOP command.')
atmCoreGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 1))
atmCoreGroupCB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 1, 2))
atmCoreGroupCB02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 1, 2, 3))
atmCoreGroupCB02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 1, 2, 3, 2))
atmCoreCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 3))
atmCoreCapabilitiesCB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 3, 2))
atmCoreCapabilitiesCB02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 3, 2, 3))
atmCoreCapabilitiesCB02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 123, 3, 2, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfCAVbrNrtCdvt=mscAtmIfCAVbrNrtCdvt, mscAtmIfVptVccVcdTmRxPacketWiseDiscard=mscAtmIfVptVccVcdTmRxPacketWiseDiscard, mscAtmIfVptTxQThreshEntry=mscAtmIfVptTxQThreshEntry, mscAtmIfVptVccTestTimeRemaining=mscAtmIfVptVccTestTimeRemaining, mscAtmIfVptStatsRxCell=mscAtmIfVptStatsRxCell, mscAtmIfCAPoolAvailBwIndex=mscAtmIfCAPoolAvailBwIndex, mscAtmIfVptStatusTable=mscAtmIfVptStatusTable, mscAtmIfVptVpdTmComponentName=mscAtmIfVptVpdTmComponentName, mscAtmIfVpcTmTqpIndex=mscAtmIfVpcTmTqpIndex, mscAtmIfVptCAPoolRequBwEntry=mscAtmIfVptCAPoolRequBwEntry, mscAtmIfVccStateTable=mscAtmIfVccStateTable, mscAtmIfVptVccTxTrafficDescType=mscAtmIfVptVccTxTrafficDescType, mscAtmIfTxCell=mscAtmIfTxCell, mscAtmIfVptVccTxQueueCongestionState=mscAtmIfVptVccTxQueueCongestionState, mscAtmIfVptVccTmAbrCutoffDecreaseFactor=mscAtmIfVptVccTmAbrCutoffDecreaseFactor, mscAtmIfVptVpdTmRowStatusTable=mscAtmIfVptVpdTmRowStatusTable, mscAtmIfVptCAPoolAdmitBwIndex=mscAtmIfVptCAPoolAdmitBwIndex, mscAtmIfVptCAAbrRowStatusEntry=mscAtmIfVptCAAbrRowStatusEntry, mscAtmIfCARtVbrCdv=mscAtmIfCARtVbrCdv, mscAtmIfVccTmTxQueueCongestionState=mscAtmIfVccTmTxQueueCongestionState, mscAtmIfVccTxTdpTable=mscAtmIfVccTxTdpTable, mscAtmIfLastLrcFrameErrorConnection=mscAtmIfLastLrcFrameErrorConnection, mscAtmIfVccNepProvTable=mscAtmIfVccNepProvTable, mscAtmIfVptVccNumLeaves=mscAtmIfVptVccNumLeaves, mscAtmIfVptVpdTmBqpIndex=mscAtmIfVptVpdTmBqpIndex, mscAtmIfVptVccVcdBearerClassBbc=mscAtmIfVptVccVcdBearerClassBbc, mscAtmIfVccVcdTmFqpIndex=mscAtmIfVccVcdTmFqpIndex, mscAtmIfCARtVbrSvcMpHoldingPriority=mscAtmIfCARtVbrSvcMpHoldingPriority, mscAtmIfEpRowStatusEntry=mscAtmIfEpRowStatusEntry, mscAtmIfVccFqpIndex=mscAtmIfVccFqpIndex, mscAtmIfAal5RxErrors=mscAtmIfAal5RxErrors, mscAtmIfVptTxQueueLength=mscAtmIfVptTxQueueLength, mscAtmIfVptVccVcdTmAbrRowStatusTable=mscAtmIfVptVccVcdTmAbrRowStatusTable, mscAtmIfOpShapingRatesEntry=mscAtmIfOpShapingRatesEntry, mscAtmIfVptCAPoolRequBwValue=mscAtmIfVptCAPoolRequBwValue, mscAtmIfVpcPmFwdAverageClr0=mscAtmIfVpcPmFwdAverageClr0, mscAtmIfVpcPmBwdLastSampleUserCellsTx01=mscAtmIfVpcPmBwdLastSampleUserCellsTx01, mscAtmIfVptCAAbrIndex=mscAtmIfVptCAAbrIndex, mscAtmIfVccTestStateTable=mscAtmIfVccTestStateTable, mscAtmIfVptTmTxQosClass=mscAtmIfVptTmTxQosClass, mscAtmIfVpcVpdRowStatus=mscAtmIfVpcVpdRowStatus, mscAtmIfCARtVbrUsageParameterControl=mscAtmIfCARtVbrUsageParameterControl, mscAtmIfCAAbrRateIncreaseFactor=mscAtmIfCAAbrRateIncreaseFactor, mscAtmIfVccPmArMeasurementStatus=mscAtmIfVccPmArMeasurementStatus, mscAtmIfVpcVpdComponentName=mscAtmIfVpcVpdComponentName, mscAtmIfVptVccTestBandwidthElastic=mscAtmIfVptVccTestBandwidthElastic, mscAtmIfVptVccStatsTxCellDiscardClp=mscAtmIfVptVccStatsTxCellDiscardClp, mscAtmIfVccTmTransferCapabilityBbc=mscAtmIfVccTmTransferCapabilityBbc, mscAtmIfVptVccTmAbrRateIncreaseFactor=mscAtmIfVptVccTmAbrRateIncreaseFactor, mscAtmIfVptVpdTxTdpTable=mscAtmIfVptVpdTxTdpTable, mscAtmIfVccBqpValue=mscAtmIfVccBqpValue, mscAtmIfVpcRxTdpEntry=mscAtmIfVpcRxTdpEntry, mscAtmIfVptCAComponentName=mscAtmIfVptCAComponentName, mscAtmIfVccCallDirection=mscAtmIfVccCallDirection, mscAtmIfVptTrafficEntry=mscAtmIfVptTrafficEntry, mscAtmIfVptVpdTmFqpTable=mscAtmIfVptVpdTmFqpTable, mscAtmIfVptVccTmOperEntry=mscAtmIfVptVccTmOperEntry, mscAtmIfVptVccVcdTxTdpTable=mscAtmIfVptVccVcdTxTdpTable, mscAtmIfVccTmAtmServiceCategory=mscAtmIfVccTmAtmServiceCategory, mscAtmIfVptVccTmBestEffort=mscAtmIfVptVccTmBestEffort, mscAtmIfCANrtVbrProvEntry=mscAtmIfCANrtVbrProvEntry, mscAtmIfVccStatsRxCell=mscAtmIfVccStatsRxCell, mscAtmIfCANrtVbrShapeRecoupPolicy=mscAtmIfCANrtVbrShapeRecoupPolicy, mscAtmIfVccPmBwdAverageClr0=mscAtmIfVccPmBwdAverageClr0, mscAtmIfVptVccTmUnshapedTransmitQueueing=mscAtmIfVptVccTmUnshapedTransmitQueueing, mscAtmIfVpcStatsTxFrameDiscardClp=mscAtmIfVpcStatsTxFrameDiscardClp, mscAtmIfVptVccTmTxQosClass=mscAtmIfVptVccTmTxQosClass, mscAtmIfVccPmBwdMinimumClr0=mscAtmIfVccPmBwdMinimumClr0, mscAtmIfVpcVpdLbkEntry=mscAtmIfVpcVpdLbkEntry, mscAtmIfCAAbrEmissionPriority=mscAtmIfCAAbrEmissionPriority, mscAtmIfVpcPmBwdTotalUserCellsRx0=mscAtmIfVpcPmBwdTotalUserCellsRx0, mscAtmIfCACbrCellLossRatio=mscAtmIfCACbrCellLossRatio, mscAtmIfVccPmStatusEntry=mscAtmIfVccPmStatusEntry, mscAtmIfVpcVpdTmTrafficShaping=mscAtmIfVpcVpdTmTrafficShaping, mscAtmIfVptVpdAcctTable=mscAtmIfVptVpdAcctTable, mscAtmIfVpcVpdTmAbrProvTable=mscAtmIfVpcVpdTmAbrProvTable, mscAtmIfVccTmAbrFixedRoundTripTime=mscAtmIfVccTmAbrFixedRoundTripTime, mscAtmIfVptVccTmRowStatusEntry=mscAtmIfVptVccTmRowStatusEntry, mscAtmIfVpcStatsRxCellDiscard=mscAtmIfVpcStatsRxCellDiscard, mscAtmIfVptVccTxTdpIndex=mscAtmIfVptVccTxTdpIndex, mscAtmIfCAAbrIndex=mscAtmIfCAAbrIndex, mscAtmIfConnMapStorageType=mscAtmIfConnMapStorageType, mscAtmIfVptVpdTmAbrRateIncreaseFactor=mscAtmIfVptVpdTmAbrRateIncreaseFactor, mscAtmIfVptCACbrRowStatusTable=mscAtmIfVptCACbrRowStatusTable, mscAtmIfVccPmFwdTotalUserCellsRx0=mscAtmIfVccPmFwdTotalUserCellsRx0, mscAtmIfVccTestBandwidthElastic=mscAtmIfVccTestBandwidthElastic, mscAtmIfCAPoolAdmConnsValue=mscAtmIfCAPoolAdmConnsValue, mscAtmIfVpcTmRxTdpIndex=mscAtmIfVpcTmRxTdpIndex, mscAtmIfControlStatus=mscAtmIfControlStatus, mscAtmIfVptVccRxTdpTable=mscAtmIfVptVccRxTdpTable, mscAtmIfVpcPm=mscAtmIfVpcPm, mscAtmIfVccTmAbrConnectionType=mscAtmIfVccTmAbrConnectionType, mscAtmIfVptTmAbr=mscAtmIfVptTmAbr, mscAtmIfVptVccTmTransferCapabilityBbc=mscAtmIfVptVccTmTransferCapabilityBbc, mscAtmIfVccVcdTmAbrRowStatusTable=mscAtmIfVccVcdTmAbrRowStatusTable, atmCoreGroupCB02A=atmCoreGroupCB02A, mscAtmIfVptVpdUnshapedTransmitQueueing=mscAtmIfVptVpdUnshapedTransmitQueueing, mscAtmIfCAAbrUsageParameterControl=mscAtmIfCAAbrUsageParameterControl, mscAtmIfCAAbrProvEntry=mscAtmIfCAAbrProvEntry, mscAtmIfCAUbrOperEntry=mscAtmIfCAUbrOperEntry, mscAtmIfVccVcd=mscAtmIfVccVcd, mscAtmIfConnMapNumVccsPerNonZeroVpiOper=mscAtmIfConnMapNumVccsPerNonZeroVpiOper, mscAtmIfVpcPmBwdClrEntry=mscAtmIfVpcPmBwdClrEntry, mscAtmIfVpcVpdAcctEntry=mscAtmIfVpcVpdAcctEntry, mscAtmIfEpRowStatus=mscAtmIfEpRowStatus, mscAtmIfVptVccTrafficEntry=mscAtmIfVptVccTrafficEntry, mscAtmIfVpcVpdTmTxTdpValue=mscAtmIfVpcVpdTmTxTdpValue, mscAtmIfCAUbrUsageParameterControl=mscAtmIfCAUbrUsageParameterControl, mscAtmIfCAStorageType=mscAtmIfCAStorageType, mscAtmIfPmComponentName=mscAtmIfPmComponentName, mscAtmIfVpcVpdTmFqpTable=mscAtmIfVpcVpdTmFqpTable, mscAtmIfVptVccVcdPmProvTable=mscAtmIfVptVccVcdPmProvTable, mscAtmIfVccPmIndex=mscAtmIfVccPmIndex, mscAtmIfVpcIndex=mscAtmIfVpcIndex, mscAtmIfVptVccVcdFqpValue=mscAtmIfVptVccVcdFqpValue, mscAtmIfVptCAPermanentVccs=mscAtmIfVptCAPermanentVccs, mscAtmIfVptVccFqpValue=mscAtmIfVptVccFqpValue, mscAtmIfVccTestVerificationFrmTx=mscAtmIfVccTestVerificationFrmTx, mscAtmIfVptVccVcdTrafficTable=mscAtmIfVptVccVcdTrafficTable, mscAtmIfVptCANrtVbrComponentName=mscAtmIfVptCANrtVbrComponentName, mscAtmIfVptVccVcdStorageType=mscAtmIfVptVccVcdStorageType, mscAtmIfVptVccTestUnrecognizableFrmRx=mscAtmIfVptVccTestUnrecognizableFrmRx, mscAtmIfVptCARowStatus=mscAtmIfVptCARowStatus, mscAtmIfVpcTxTrafficDescType=mscAtmIfVpcTxTrafficDescType, mscAtmIfCANrtVbrWeightPolicy=mscAtmIfCANrtVbrWeightPolicy, mscAtmIfCACbrTrafficShaping=mscAtmIfCACbrTrafficShaping, mscAtmIfVccPerfEntry=mscAtmIfVccPerfEntry, mscAtmIfVccVcdTm=mscAtmIfVccVcdTm, mscAtmIfVpcLoopComponentName=mscAtmIfVpcLoopComponentName, mscAtmIfVptVccVcdIndex=mscAtmIfVptVccVcdIndex, mscAtmIfVptVccTmRqpValue=mscAtmIfVptVccTmRqpValue, mscAtmIfVpcTmAbrInitialCellRate=mscAtmIfVpcTmAbrInitialCellRate, mscAtmIfVpcCallDirection=mscAtmIfVpcCallDirection, mscAtmIfVpcVpdCorrelationTag=mscAtmIfVpcVpdCorrelationTag, mscAtmIfVccLoopRowStatus=mscAtmIfVccLoopRowStatus, mscAtmIfVptVccVcdTrafficShaping=mscAtmIfVptVccVcdTrafficShaping, mscAtmIfVptVccTmTxQueueCongestionState=mscAtmIfVptVccTmTxQueueCongestionState, mscAtmIfVpcPerfEntry=mscAtmIfVpcPerfEntry, mscAtmIfVptVccStatsTable=mscAtmIfVptVccStatsTable, mscAtmIfVpcPmBwdAverageClr01=mscAtmIfVpcPmBwdAverageClr01, mscAtmIfVpcTmAbrMaxTimeBetweenRmCell=mscAtmIfVpcTmAbrMaxTimeBetweenRmCell, mscAtmIfCAMinAutoSelectedVciForVpiZero=mscAtmIfCAMinAutoSelectedVciForVpiZero, mscAtmIfVptVccTestBytesRx=mscAtmIfVptVccTestBytesRx, mscAtmIfVptCAPoolAdmitBwTable=mscAtmIfVptCAPoolAdmitBwTable, mscAtmIfVptVccVcdPmStorageType=mscAtmIfVptVccVcdPmStorageType, mscAtmIfRxCellEfci=mscAtmIfRxCellEfci, mscAtmIfVccNepApplicationName=mscAtmIfVccNepApplicationName, mscAtmIfVpcFqpEntry=mscAtmIfVpcFqpEntry, mscAtmIfVccTestVerificationFrmBad=mscAtmIfVccTestVerificationFrmBad, mscAtmIfCAActualMaxVpcs=mscAtmIfCAActualMaxVpcs, mscAtmIfVpcRowStatusTable=mscAtmIfVpcRowStatusTable, mscAtmIfCANrtVbrUsageParameterControl=mscAtmIfCANrtVbrUsageParameterControl, mscAtmIfVccTmTxTrafficDescType=mscAtmIfVccTmTxTrafficDescType, mscAtmIfVptVccVcdTmTxTdpValue=mscAtmIfVptVccVcdTmTxTdpValue, mscAtmIfVptCAOperTable=mscAtmIfVptCAOperTable, mscAtmIfVptVccTestBytesTx=mscAtmIfVptVccTestBytesTx, mscAtmIfConnMap=mscAtmIfConnMap, mscAtmIfVpcPmArMeasurementStatus=mscAtmIfVpcPmArMeasurementStatus, mscAtmIfVptVccVcdTmRxTdpTable=mscAtmIfVptVccVcdTmRxTdpTable, mscAtmIfConnMapFirstNonZeroVpiForVccs=mscAtmIfConnMapFirstNonZeroVpiForVccs, mscAtmIfCidDataEntry=mscAtmIfCidDataEntry, mscAtmIfVpcVpdTmBearerClassBbc=mscAtmIfVpcVpdTmBearerClassBbc, mscAtmIfVptCAMaxVccs=mscAtmIfVptCAMaxVccs, mscAtmIfVccVcdRxTrafficDescType=mscAtmIfVccVcdRxTrafficDescType, mscAtmIfVptVccVcdTxQosClass=mscAtmIfVptVccVcdTxQosClass, mscAtmIfVpcVpdTmAbrRateDecreaseFactor=mscAtmIfVpcVpdTmAbrRateDecreaseFactor, mscAtmIfVptStorageType=mscAtmIfVptStorageType, mscAtmIfCAUbrComponentName=mscAtmIfCAUbrComponentName, mscAtmIfVptRxTrafficDescType=mscAtmIfVptRxTrafficDescType, mscAtmIfVptVpdTmTxTdpEntry=mscAtmIfVptVpdTmTxTdpEntry, mscAtmIfVptVccStatsTxCellDiscard=mscAtmIfVptVccStatsTxCellDiscard, mscAtmIfConnMapOvNumVccsForVpiZero=mscAtmIfConnMapOvNumVccsForVpiZero, mscAtmIfVccVcdRowStatusEntry=mscAtmIfVccVcdRowStatusEntry, mscAtmIfVccVcdTmBqpValue=mscAtmIfVccVcdTmBqpValue, mscAtmIfVccVcdTmAbrComponentName=mscAtmIfVccVcdTmAbrComponentName, mscAtmIfVptCAAbrComponentName=mscAtmIfVptCAAbrComponentName, mscAtmIfVptVccTmTxTdpEntry=mscAtmIfVptVccTmTxTdpEntry, mscAtmIfVptVccVcdLbkEntry=mscAtmIfVptVccVcdLbkEntry, mscAtmIfVccVcdTmProvTable=mscAtmIfVccVcdTmProvTable, mscAtmIfCACbrRowStatus=mscAtmIfCACbrRowStatus, mscAtmIfVccVcdTmRowStatusEntry=mscAtmIfVccVcdTmRowStatusEntry, mscAtmIfVptVccTestCustomizedPattern=mscAtmIfVptVccTestCustomizedPattern, mscAtmIfIndex=mscAtmIfIndex, mscAtmIfVptVccVcdAcctEntry=mscAtmIfVptVccVcdAcctEntry, mscAtmIfVpcPmBwdMaximumClr0=mscAtmIfVpcPmBwdMaximumClr0, mscAtmIfVpcStatsTxCellClp=mscAtmIfVpcStatsTxCellClp, mscAtmIfVptCANrtVbrIndex=mscAtmIfVptCANrtVbrIndex, mscAtmIfVptCAPoolProvBwEntry=mscAtmIfVptCAPoolProvBwEntry, mscAtmIfVptTxDiscardClp=mscAtmIfVptTxDiscardClp, mscAtmIfVccLoopRowStatusTable=mscAtmIfVccLoopRowStatusTable, mscAtmIfVptVccLoopRowStatusEntry=mscAtmIfVptVccLoopRowStatusEntry, mscAtmIfCANrtVbrCellLossRatio=mscAtmIfCANrtVbrCellLossRatio, mscAtmIfVptVccStatsRxFrameDiscard=mscAtmIfVptVccStatsRxFrameDiscard, mscAtmIfVpcOperTable=mscAtmIfVpcOperTable, mscAtmIfVpcPmFwdMaximumClr0=mscAtmIfVpcPmFwdMaximumClr0, mscAtmIfVccPmFwdTotalUserCellsTx01=mscAtmIfVccPmFwdTotalUserCellsTx01, mscAtmIfVpcLastCtdSampleSize=mscAtmIfVpcLastCtdSampleSize, mscAtmIfVccTxQThreshEntry=mscAtmIfVccTxQThreshEntry, mscAtmIfVccTrafficEntry=mscAtmIfVccTrafficEntry, mscAtmIfVccTmTxPacketWiseDiscard=mscAtmIfVccTmTxPacketWiseDiscard, mscAtmIfVptVccTmAbrMaxCellPerRmCell=mscAtmIfVptVccTmAbrMaxCellPerRmCell, mscAtmIfVpcTmAbrRateIncreaseFactor=mscAtmIfVpcTmAbrRateIncreaseFactor, mscAtmIfVpcLastAverageCtd=mscAtmIfVpcLastAverageCtd, mscAtmIfVptVccTmTqpTable=mscAtmIfVptVccTmTqpTable, mscAtmIfCAUbrWeightPolicy=mscAtmIfCAUbrWeightPolicy, mscAtmIfVccStatsRxFrameDiscard=mscAtmIfVccStatsRxFrameDiscard, mscAtmIfVccFqpTable=mscAtmIfVccFqpTable, mscAtmIfVccTestElapsedTime=mscAtmIfVccTestElapsedTime, mscAtmIfVccOperEntry=mscAtmIfVccOperEntry, mscAtmIfVptVccVcdPmIndex=mscAtmIfVptVccVcdPmIndex, mscAtmIfVccVcdTmTransferCapabilityBbc=mscAtmIfVccVcdTmTransferCapabilityBbc, mscAtmIfVccVcdTmIndex=mscAtmIfVccVcdTmIndex, mscAtmIfVccTmRqpTable=mscAtmIfVccTmRqpTable, mscAtmIfVptVccLoopComponentName=mscAtmIfVptVccLoopComponentName, mscAtmIfVptVccVcdFqpIndex=mscAtmIfVptVccVcdFqpIndex, mscAtmIfCABwPoolValue=mscAtmIfCABwPoolValue, mscAtmIfVpcTmRqpValue=mscAtmIfVpcTmRqpValue, mscAtmIfVptTmTxQueueCongestionState=mscAtmIfVptTmTxQueueCongestionState, mscAtmIfVptVccTmTrafficShaping=mscAtmIfVptVccTmTrafficShaping, mscAtmIfVccVcdTmAbrRowStatus=mscAtmIfVccVcdTmAbrRowStatus, mscAtmIfVccDistributionType=mscAtmIfVccDistributionType, mscAtmIfVccVcdBwdFrameDiscard=mscAtmIfVccVcdBwdFrameDiscard, mscAtmIfVccStorageType=mscAtmIfVccStorageType, mscAtmIfVptVccNepComponentName=mscAtmIfVptVccNepComponentName, mscAtmIfRowStatus=mscAtmIfRowStatus, mscAtmIfVccPmArTable=mscAtmIfVccPmArTable, mscAtmIfConnMapOvIndex=mscAtmIfConnMapOvIndex, mscAtmIfVptVccVcdTmForceTagging=mscAtmIfVptVccVcdTmForceTagging, mscAtmIfVccPmBwdPmCellDiscardCount=mscAtmIfVccPmBwdPmCellDiscardCount, mscAtmIfCACbrMinPerVcQueueLimit=mscAtmIfCACbrMinPerVcQueueLimit, mscAtmIfVptCAConnectionPoolUsage=mscAtmIfVptCAConnectionPoolUsage, mscAtmIfCAMinAutoSelectedVpi=mscAtmIfCAMinAutoSelectedVpi, mscAtmIfVptVccBandwidthElastic=mscAtmIfVptVccBandwidthElastic, mscAtmIfVptCARtVbrIndex=mscAtmIfVptCARtVbrIndex, mscAtmIfVpcVpdPmControlMode=mscAtmIfVpcVpdPmControlMode, mscAtmIfCAUbrShapeRecoupPolicy=mscAtmIfCAUbrShapeRecoupPolicy, mscAtmIfVptCAUbrVccUsage=mscAtmIfVptCAUbrVccUsage, mscAtmIfVpcVpdTmAbrMaxTimeBetweenRmCells=mscAtmIfVpcVpdTmAbrMaxTimeBetweenRmCells, mscAtmIfVptVpdRxTdpIndex=mscAtmIfVptVpdRxTdpIndex, mscAtmIfVptVccTestVerificationFrmTx=mscAtmIfVptVccTestVerificationFrmTx, mscAtmIfCAPoolAdmConnsIndex=mscAtmIfCAPoolAdmConnsIndex, mscAtmIfVccVcdPmIndex=mscAtmIfVccVcdPmIndex, mscAtmIfVccNepProvEntry=mscAtmIfVccNepProvEntry, mscAtmIfVptTmRqpValue=mscAtmIfVptTmRqpValue, mscAtmIfVpcTmStorageType=mscAtmIfVpcTmStorageType, mscAtmIfVpcTmTqpValue=mscAtmIfVpcTmTqpValue, mscAtmIfVpcBandwidthReduction=mscAtmIfVpcBandwidthReduction, mscAtmIfVptBearerClassBbc=mscAtmIfVptBearerClassBbc, mscAtmIfVpcTmBandwidthReduction=mscAtmIfVpcTmBandwidthReduction, mscAtmIfVpcVpdBqpTable=mscAtmIfVpcVpdBqpTable, mscAtmIfVptVpdTmFqpValue=mscAtmIfVptVpdTmFqpValue, mscAtmIfVccVcdTmAbrRowStatusEntry=mscAtmIfVccVcdTmAbrRowStatusEntry, mscAtmIfVccTestCauseOfTermination=mscAtmIfVccTestCauseOfTermination, mscAtmIfConnMapVccProvTable=mscAtmIfConnMapVccProvTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfVptVccUsageState=mscAtmIfVptVccUsageState, mscAtmIfVptTmTxQThreshIndex=mscAtmIfVptTmTxQThreshIndex, mscAtmIfCAPoolProvBwValue=mscAtmIfCAPoolProvBwValue, mscAtmIfVptTmTxQThreshTable=mscAtmIfVptTmTxQThreshTable, mscAtmIfVptTxTdpEntry=mscAtmIfVptTxTdpEntry, mscAtmIfVpcStatsRxCellDiscardClp=mscAtmIfVpcStatsRxCellDiscardClp, mscAtmIfVptVccVcdTm=mscAtmIfVptVccVcdTm, mscAtmIfVpcLoop=mscAtmIfVpcLoop, mscAtmIfVccVcdTmAbrIndex=mscAtmIfVccVcdTmAbrIndex, mscAtmIfVptVpdTxTdpEntry=mscAtmIfVptVpdTxTdpEntry, mscAtmIfVccVcdTmAbrFixedRoundTripTime=mscAtmIfVccVcdTmAbrFixedRoundTripTime, mscAtmIfVptTmAbrRowStatus=mscAtmIfVptTmAbrRowStatus, mscAtmIfConnMapOv=mscAtmIfConnMapOv, mscAtmIfVptVccVcdBqpEntry=mscAtmIfVptVccVcdBqpEntry, mscAtmIfVptCAPoolAdmConnsTable=mscAtmIfVptCAPoolAdmConnsTable, mscAtmIfVccPmFwdAverageClr0=mscAtmIfVccPmFwdAverageClr0, mscAtmIfVptVccVcdTmAbrRateDecreaseFactor=mscAtmIfVptVccVcdTmAbrRateDecreaseFactor, mscAtmIfVptTmTxQThreshValue=mscAtmIfVptTmTxQThreshValue, mscAtmIfVptVccTestRowStatus=mscAtmIfVptVccTestRowStatus, mscAtmIfStandbyStatus=mscAtmIfStandbyStatus, mscAtmIfVccPmFwdMinimumClr0=mscAtmIfVccPmFwdMinimumClr0, mscAtmIfVccPmBwdLastSampleUserCellsRx0=mscAtmIfVccPmBwdLastSampleUserCellsRx0, mscAtmIfVptVccTxQThreshIndex=mscAtmIfVptVccTxQThreshIndex, mscAtmIfVpcPmFwdTotalUserCellsRx01=mscAtmIfVpcPmFwdTotalUserCellsRx01, mscAtmIfVccEndToEndLoopbackState=mscAtmIfVccEndToEndLoopbackState, mscAtmIfVpcPmFwdLastSampleClr01=mscAtmIfVpcPmFwdLastSampleClr01, mscAtmIfVccVcdTmFqpTable=mscAtmIfVccVcdTmFqpTable, mscAtmIfRxCellClp=mscAtmIfRxCellClp, mscAtmIfVccNepRowStatus=mscAtmIfVccNepRowStatus, mscAtmIfVptVccLoop=mscAtmIfVptVccLoop, mscAtmIfVptTmAbrMaxTimeBetweenRmCell=mscAtmIfVptTmAbrMaxTimeBetweenRmCell, mscAtmIfVptRowStatusEntry=mscAtmIfVptRowStatusEntry, mscAtmIfVccVcdPmRowStatusTable=mscAtmIfVccVcdPmRowStatusTable, mscAtmIfCANrtVbrRowStatus=mscAtmIfCANrtVbrRowStatus, mscAtmIfVccVcdBwdQosClass=mscAtmIfVccVcdBwdQosClass, mscAtmIfVpcDistributionType=mscAtmIfVpcDistributionType, mscAtmIfVccTmWeight=mscAtmIfVccTmWeight, mscAtmIfVpcVpdTmAbrMaxCellPerRmCell=mscAtmIfVpcVpdTmAbrMaxCellPerRmCell, mscAtmIfVpcTmAbrFixedRoundTripTime=mscAtmIfVpcTmAbrFixedRoundTripTime, mscAtmIfVpcTmAbrMaxCellPerRmCell=mscAtmIfVpcTmAbrMaxCellPerRmCell, mscAtmIfVccRxFrameDiscard=mscAtmIfVccRxFrameDiscard, mscAtmIfVptTmAbrCutoffDecreaseFactor=mscAtmIfVptTmAbrCutoffDecreaseFactor, mscAtmIfVptVccVcdRxTrafficDescType=mscAtmIfVptVccVcdRxTrafficDescType, mscAtmIfVccPmFwdTotalClrInterval=mscAtmIfVccPmFwdTotalClrInterval, mscAtmIfCAPoolWaitAdmConnsEntry=mscAtmIfCAPoolWaitAdmConnsEntry, mscAtmIfVptVccTxQosClass=mscAtmIfVptVccTxQosClass, mscAtmIfVpcVpdTmUsageParameterControl=mscAtmIfVpcVpdTmUsageParameterControl, mscAtmIfVpcTxQueueCongestionState=mscAtmIfVpcTxQueueCongestionState, mscAtmIfCAAbrDgcraMaximumDelay=mscAtmIfCAAbrDgcraMaximumDelay, mscAtmIfCANrtVbrTxQueueLimit=mscAtmIfCANrtVbrTxQueueLimit, mscAtmIfVptVccVcdTransferCapabilityBbc=mscAtmIfVptVccVcdTransferCapabilityBbc, mscAtmIfCAOperEntry=mscAtmIfCAOperEntry, mscAtmIfPmRowStatusTable=mscAtmIfPmRowStatusTable, mscAtmIfVccTransferCapabilityBbc=mscAtmIfVccTransferCapabilityBbc, mscAtmIfVccLoopIndex=mscAtmIfVccLoopIndex, mscAtmIfCAAbrComponentName=mscAtmIfCAAbrComponentName, mscAtmIfAdminState=mscAtmIfAdminState, mscAtmIfVccStatusTable=mscAtmIfVccStatusTable, mscAtmIfVpcRxOamCellCongestionState=mscAtmIfVpcRxOamCellCongestionState, mscAtmIfVpcBqpEntry=mscAtmIfVpcBqpEntry, mscAtmIfVccStatsRxFrameDiscardClp=mscAtmIfVccStatsRxFrameDiscardClp, mscAtmIfCARtVbrOperTable=mscAtmIfCARtVbrOperTable, mscAtmIfVptVccVcdTmFqpValue=mscAtmIfVptVccVcdTmFqpValue, mscAtmIfCACbrCdv=mscAtmIfCACbrCdv, mscAtmIfVpcTmForceTagging=mscAtmIfVpcTmForceTagging, mscAtmIfCABwPoolEntry=mscAtmIfCABwPoolEntry, mscAtmIfVccVcdBqpTable=mscAtmIfVccVcdBqpTable, mscAtmIfVccPmBwdMaximumClr01=mscAtmIfVccPmBwdMaximumClr01, mscAtmIfVptVpdBqpIndex=mscAtmIfVptVpdBqpIndex, mscAtmIfVptVccVcdTmAbrMaxCellPerRmCell=mscAtmIfVptVccVcdTmAbrMaxCellPerRmCell, mscAtmIfVptVpdTmBqpEntry=mscAtmIfVptVpdTmBqpEntry, mscAtmIfCARtVbr=mscAtmIfCARtVbr, mscAtmIfVccTroubled=mscAtmIfVccTroubled, mscAtmIfVptVpdTmAbrMaxCellPerRmCell=mscAtmIfVptVpdTmAbrMaxCellPerRmCell, mscAtmIfVpcVpdTxTdpValue=mscAtmIfVpcVpdTxTdpValue, mscAtmIfConnMapOvRowStatusTable=mscAtmIfConnMapOvRowStatusTable, mscAtmIfVptVccTmRxQosClass=mscAtmIfVptVccTmRxQosClass, mscAtmIfVptCARtVbrComponentName=mscAtmIfVptCARtVbrComponentName, mscAtmIfVptCANrtVbrProvEntry=mscAtmIfVptCANrtVbrProvEntry, mscAtmIfVptVccTestRowStatusTable=mscAtmIfVptVccTestRowStatusTable, mscAtmIfVccVcdTmAbr=mscAtmIfVccVcdTmAbr, mscAtmIfVccTestRowStatusEntry=mscAtmIfVccTestRowStatusEntry, mscAtmIfVptVccTmRxTdpTable=mscAtmIfVptVccTmRxTdpTable, mscAtmIfVpcTrafficShaping=mscAtmIfVpcTrafficShaping, mscAtmIfVccUsageParameterControl=mscAtmIfVccUsageParameterControl, mscAtmIfVccVcdTmAtmServiceCategory=mscAtmIfVccVcdTmAtmServiceCategory, mscAtmIfVptVccVcdTmAbrRowStatus=mscAtmIfVptVccVcdTmAbrRowStatus, mscAtmIfCARtVbrStorageType=mscAtmIfCARtVbrStorageType, mscAtmIfVpcBandwidthElastic=mscAtmIfVpcBandwidthElastic, mscAtmIfVpcVpdTmRxTrafficDescType=mscAtmIfVpcVpdTmRxTrafficDescType, mscAtmIfVccPmRowStatusTable=mscAtmIfVccPmRowStatusTable, mscAtmIfAal5RxAborts=mscAtmIfAal5RxAborts, mscAtmIfVpcTmTxPacketWiseDiscard=mscAtmIfVpcTmTxPacketWiseDiscard, mscAtmIfVptStatsTxCellClp=mscAtmIfVptStatsTxCellClp, mscAtmIfVptBqpIndex=mscAtmIfVptBqpIndex, mscAtmIfCAUbrAvailableConnections=mscAtmIfCAUbrAvailableConnections, mscAtmIfVptVpdTmRxTdpValue=mscAtmIfVptVpdTmRxTdpValue, mscAtmIfVccPmBwdLastSampleUserCellsTx0=mscAtmIfVccPmBwdLastSampleUserCellsTx0, mscAtmIfTrafficShaping=mscAtmIfTrafficShaping, mscAtmIfVccVcdTxTdpValue=mscAtmIfVccVcdTxTdpValue, mscAtmIfVccTestOperationalState=mscAtmIfVccTestOperationalState, mscAtmIfVpcTmUsageParameterControl=mscAtmIfVpcTmUsageParameterControl, mscAtmIfVptTmTrafficShaping=mscAtmIfVptTmTrafficShaping, mscAtmIfNAcctRowStatusEntry=mscAtmIfNAcctRowStatusEntry, mscAtmIfVptBwdQosClass=mscAtmIfVptBwdQosClass, mscAtmIfVptVpdBwdQosClass=mscAtmIfVptVpdBwdQosClass, mscAtmIfVptVccBandwidthReduction=mscAtmIfVptVccBandwidthReduction, mscAtmIfVccStateEntry=mscAtmIfVccStateEntry, mscAtmIfVptVpdLbkTable=mscAtmIfVptVpdLbkTable, mscAtmIfVccLoopComponentName=mscAtmIfVccLoopComponentName, mscAtmIfVccVcdPmRowStatusEntry=mscAtmIfVccVcdPmRowStatusEntry, mscAtmIfVptVpdTmIndex=mscAtmIfVptVpdTmIndex, mscAtmIfCACbrShapeRecoupPolicy=mscAtmIfCACbrShapeRecoupPolicy, mscAtmIfVptVccTxFrameDiscard=mscAtmIfVptVccTxFrameDiscard, mscAtmIfVptVccTmAbrTxRateChangeInfo=mscAtmIfVptVccTmAbrTxRateChangeInfo, mscAtmIfVptVpdTmAbrComponentName=mscAtmIfVptVpdTmAbrComponentName, mscAtmIfCAPoolWaitAdmConnsValue=mscAtmIfCAPoolWaitAdmConnsValue, mscAtmIfVpcTmAbrTxRateChangeInfo=mscAtmIfVpcTmAbrTxRateChangeInfo, mscAtmIfVccVcdTmTxTrafficDescType=mscAtmIfVccVcdTmTxTrafficDescType, mscAtmIfVccStatsRxCellDiscardClp=mscAtmIfVccStatsRxCellDiscardClp, mscAtmIfPm=mscAtmIfPm, mscAtmIfVptVccVcdBqpIndex=mscAtmIfVptVccVcdBqpIndex, mscAtmIfVptStatsTxCellDiscardClp=mscAtmIfVptStatsTxCellDiscardClp, mscAtmIfVpcOperEntry=mscAtmIfVpcOperEntry, mscAtmIfVpcVpdBqpEntry=mscAtmIfVpcVpdBqpEntry, mscAtmIfVptVccVcdTmBqpEntry=mscAtmIfVptVccVcdTmBqpEntry, mscAtmIfConnMapIndex=mscAtmIfConnMapIndex, mscAtmIfCAPoolWaitAdmConnsIndex=mscAtmIfCAPoolWaitAdmConnsIndex, mscAtmIfVccTmTxQThreshValue=mscAtmIfVccTmTxQThreshValue, mscAtmIfVccPmFailureCause=mscAtmIfVccPmFailureCause, mscAtmIfVptVccTestDuration=mscAtmIfVptVccTestDuration, mscAtmIfVccTmAbrComponentName=mscAtmIfVccTmAbrComponentName, mscAtmIfVptVccTxQThreshEntry=mscAtmIfVptVccTxQThreshEntry, mscAtmIfVpcTmOperTable=mscAtmIfVpcTmOperTable, mscAtmIfVccVcdTransferCapabilityBbc=mscAtmIfVccVcdTransferCapabilityBbc, mscAtmIfCAVbrRtCdvt=mscAtmIfCAVbrRtCdvt, mscAtmIfCAUbrMaxConnections=mscAtmIfCAUbrMaxConnections, mscAtmIfVptCAPoolWaitAdmConnsValue=mscAtmIfVptCAPoolWaitAdmConnsValue, mscAtmIfVptTmRowStatusEntry=mscAtmIfVptTmRowStatusEntry, mscAtmIfVptVccVcdTmTxTrafficDescType=mscAtmIfVptVccVcdTmTxTrafficDescType, mscAtmIfVptVccTestVerificationFrmRx=mscAtmIfVptVccTestVerificationFrmRx, mscAtmIfVptVccVcdPmComponentName=mscAtmIfVptVccVcdPmComponentName, mscAtmIfVptCANrtVbrRowStatus=mscAtmIfVptCANrtVbrRowStatus, mscAtmIfVccPmBwdLastSampleClr0=mscAtmIfVccPmBwdLastSampleClr0, mscAtmIfVptVccVcdFqpEntry=mscAtmIfVptVccVcdFqpEntry, mscAtmIfCAAbrEpdOffset=mscAtmIfCAAbrEpdOffset, mscAtmIfCAUbrMinPerVcQueueLimit=mscAtmIfCAUbrMinPerVcQueueLimit, mscAtmIfCACbrEpdOffset=mscAtmIfCACbrEpdOffset, mscAtmIfVpcTmAbrConnectionType=mscAtmIfVpcTmAbrConnectionType, mscAtmIfCAUbrVpcUsage=mscAtmIfCAUbrVpcUsage, mscAtmIfVptCANrtVbrCellLossRatio=mscAtmIfVptCANrtVbrCellLossRatio, mscAtmIfVpcTmClippingBbc=mscAtmIfVpcTmClippingBbc, mscAtmIfVccVcdTmFqpValue=mscAtmIfVccVcdTmFqpValue, mscAtmIfVpcVpdTmRxPacketWiseDiscard=mscAtmIfVpcVpdTmRxPacketWiseDiscard, mscAtmIfVptCAProvTable=mscAtmIfVptCAProvTable, mscAtmIfCACbrMaxCtd=mscAtmIfCACbrMaxCtd, mscAtmIfVptVccStatsTxCellClp=mscAtmIfVptVccStatsTxCellClp, mscAtmIfVpcTmRxTdpEntry=mscAtmIfVpcTmRxTdpEntry, mscAtmIfVptVccTmBandwidthElastic=mscAtmIfVptVccTmBandwidthElastic, mscAtmIfVpcRxTrafficDescType=mscAtmIfVpcRxTrafficDescType, mscAtmIfVccVcdTmHoldingPriority=mscAtmIfVccVcdTmHoldingPriority, mscAtmIfVptVpdRxQosClass=mscAtmIfVptVpdRxQosClass, mscAtmIfVptLocalFailureCause=mscAtmIfVptLocalFailureCause, mscAtmIfVpcRxFrameDiscard=mscAtmIfVpcRxFrameDiscard, mscAtmIfVptOperStatus=mscAtmIfVptOperStatus, mscAtmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor=mscAtmIfVptVccVcdTmAbrFarEndAcrDecreaseTimeFactor, mscAtmIfVccVcdTmAbrFarEndInitialCellRate=mscAtmIfVccVcdTmAbrFarEndInitialCellRate, mscAtmIfVptVccHoldingPriority=mscAtmIfVptVccHoldingPriority, mscAtmIfVptStatsRxFrameDiscard=mscAtmIfVptStatsRxFrameDiscard, mscAtmIfVptCAAbr=mscAtmIfVptCAAbr, mscAtmIfVptVccLoopIndex=mscAtmIfVptVccLoopIndex, mscAtmIfVptVccVcdTmFqpTable=mscAtmIfVptVccVcdTmFqpTable, mscAtmIfVptVccVcdTmAbrFarEndInitialCellRate=mscAtmIfVptVccVcdTmAbrFarEndInitialCellRate, mscAtmIfVptVpdTxQosClass=mscAtmIfVptVpdTxQosClass, mscAtmIfVccPmBwdClrEntry=mscAtmIfVccPmBwdClrEntry, mscAtmIfVptTmRqpEntry=mscAtmIfVptTmRqpEntry, mscAtmIfVptTransferCapabilityBbc=mscAtmIfVptTransferCapabilityBbc, mscAtmIfVptBqpTable=mscAtmIfVptBqpTable, mscAtmIfVptCAUbrRowStatusEntry=mscAtmIfVptCAUbrRowStatusEntry, mscAtmIfVptCACbrCdv=mscAtmIfVptCACbrCdv, mscAtmIfLastAal5RxErrorConnection=mscAtmIfLastAal5RxErrorConnection, mscAtmIfVpcTmAbrIndex=mscAtmIfVpcTmAbrIndex, mscAtmIfVpcOperStatus=mscAtmIfVpcOperStatus, mscAtmIfVptVccVcdTmTrafficShaping=mscAtmIfVptVccVcdTmTrafficShaping, mscAtmIfVccStatsTxCellDiscard=mscAtmIfVccStatsTxCellDiscard, mscAtmIfVpcPmRowStatus=mscAtmIfVpcPmRowStatus, mscAtmIfVpcPmRowStatusTable=mscAtmIfVpcPmRowStatusTable, mscAtmIfVccVcdTmBqpEntry=mscAtmIfVccVcdTmBqpEntry, mscAtmIfCAMinAutoSelectedVci=mscAtmIfCAMinAutoSelectedVci, mscAtmIfVptVccVcdAtmServiceCategory=mscAtmIfVptVccVcdAtmServiceCategory, mscAtmIfConnMapOvStorageType=mscAtmIfConnMapOvStorageType, mscAtmIfVptVpdTmForceTagging=mscAtmIfVptVpdTmForceTagging, mscAtmIfEpStorageType=mscAtmIfEpStorageType, mscAtmIfCACbrSvcHoldingPriority=mscAtmIfCACbrSvcHoldingPriority, mscAtmIfVptCARtVbrCdv=mscAtmIfVptCARtVbrCdv, mscAtmIfVptVccVcdHoldingPriority=mscAtmIfVptVccVcdHoldingPriority, mscAtmIfVptTmWeight=mscAtmIfVptTmWeight, mscAtmIfVptRowStatus=mscAtmIfVptRowStatus, mscAtmIfStatsEntry=mscAtmIfStatsEntry, mscAtmIfOperEntry=mscAtmIfOperEntry, mscAtmIfVccPmArAvailableTime=mscAtmIfVccPmArAvailableTime, mscAtmIfVpcUsageParameterControl=mscAtmIfVpcUsageParameterControl, mscAtmIfCAPoolRequBwEntry=mscAtmIfCAPoolRequBwEntry, mscAtmIfVptVccTxQueueLength=mscAtmIfVptVccTxQueueLength, mscAtmIfVptVpdTmTxTdpIndex=mscAtmIfVptVpdTmTxTdpIndex, mscAtmIfVptVccVcdTmAbrTransientBufferExposure=mscAtmIfVptVccVcdTmAbrTransientBufferExposure, mscAtmIfVpcLoopStorageType=mscAtmIfVpcLoopStorageType, mscAtmIfVpcPmBwdMinimumClr01=mscAtmIfVpcPmBwdMinimumClr01, mscAtmIfVptCACbrRowStatusEntry=mscAtmIfVptCACbrRowStatusEntry, mscAtmIfVccVcdBestEffort=mscAtmIfVccVcdBestEffort, mscAtmIfVpcVpdTmAbrInitialCellRate=mscAtmIfVpcVpdTmAbrInitialCellRate, mscAtmIfVptVpdFqpValue=mscAtmIfVptVpdFqpValue, mscAtmIfNAcctAccountConnectionType=mscAtmIfNAcctAccountConnectionType, mscAtmIfVccTrafficShaping=mscAtmIfVccTrafficShaping, mscAtmIfVccVcdBqpIndex=mscAtmIfVccVcdBqpIndex, mscAtmIfVccTestFrmPatternType=mscAtmIfVccTestFrmPatternType, mscAtmIfCAAbrMaxTimeBetweenRmCell=mscAtmIfCAAbrMaxTimeBetweenRmCell, mscAtmIfVptCAUbrIndex=mscAtmIfVptCAUbrIndex, mscAtmIfVptVccTransferCapabilityBbc=mscAtmIfVptVccTransferCapabilityBbc, mscAtmIfVptVpdTmRxTdpTable=mscAtmIfVptVpdTmRxTdpTable, mscAtmIfVccVcdTmTrafficShaping=mscAtmIfVccVcdTmTrafficShaping, mscAtmIfVpcFqpIndex=mscAtmIfVpcFqpIndex, mscAtmIfVptVccLoopStorageType=mscAtmIfVptVccLoopStorageType, mscAtmIfCAPmEntry=mscAtmIfCAPmEntry, mscAtmIfOpShapingRatesValue=mscAtmIfOpShapingRatesValue, mscAtmIfVccPmBwdLastSampleUserCellsRx01=mscAtmIfVccPmBwdLastSampleUserCellsRx01, mscAtmIfVptTxFrameDiscard=mscAtmIfVptTxFrameDiscard, mscAtmIfVptVpdTmBqpValue=mscAtmIfVptVpdTmBqpValue, mscAtmIfVptTmAtmServiceCategory=mscAtmIfVptTmAtmServiceCategory, mscAtmIfVptHoldingPriority=mscAtmIfVptHoldingPriority, mscAtmIfVptVpdFqpTable=mscAtmIfVptVpdFqpTable, mscAtmIfVptVccRxOamCellCongestionState=mscAtmIfVptVccRxOamCellCongestionState, mscAtmIfVptVccVcdPmRowStatusTable=mscAtmIfVptVccVcdPmRowStatusTable, mscAtmIfCANrtVbrOperEntry=mscAtmIfCANrtVbrOperEntry, mscAtmIfCAUbrVccUsage=mscAtmIfCAUbrVccUsage, mscAtmIfVptVccTxTdpEntry=mscAtmIfVptVccTxTdpEntry, mscAtmIfVpcVpdTxTdpEntry=mscAtmIfVpcVpdTxTdpEntry, mscAtmIfCANrtVbrEpdOffset=mscAtmIfCANrtVbrEpdOffset, mscAtmIfVccTxDiscard=mscAtmIfVccTxDiscard, mscAtmIfVptCAPoolAvailBwValue=mscAtmIfVptCAPoolAvailBwValue, mscAtmIfCARtVbrCdvt=mscAtmIfCARtVbrCdvt, mscAtmIfVptTmClippingBbc=mscAtmIfVptTmClippingBbc, mscAtmIfReceivedCells=mscAtmIfReceivedCells, mscAtmIfVptVpdTmRxPacketWiseDiscard=mscAtmIfVptVpdTmRxPacketWiseDiscard, mscAtmIfVpcBwdQosClass=mscAtmIfVpcBwdQosClass, mscAtmIfVpcRdiState=mscAtmIfVpcRdiState, mscAtmIfVccTmBandwidthReduction=mscAtmIfVccTmBandwidthReduction, mscAtmIfVptVccTroubled=mscAtmIfVptVccTroubled, mscAtmIfCANrtVbrUnshapedTransmitQueueing=mscAtmIfCANrtVbrUnshapedTransmitQueueing, mscAtmIfCAUbrStorageType=mscAtmIfCAUbrStorageType, mscAtmIfVpcConnInfoEntry=mscAtmIfVpcConnInfoEntry, mscAtmIfVpcVpdTmAbrConnectionType=mscAtmIfVpcVpdTmAbrConnectionType, mscAtmIfEp=mscAtmIfEp, mscAtmIfVptVccBqpTable=mscAtmIfVptVccBqpTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfVptCARtVbrCellLossRatio=mscAtmIfVptCARtVbrCellLossRatio, mscAtmIfVptCACbrProvEntry=mscAtmIfVptCACbrProvEntry, mscAtmIfVptVccConnectionPointType=mscAtmIfVptVccConnectionPointType, mscAtmIfVptVccVcdTmAbrProvTable=mscAtmIfVptVccVcdTmAbrProvTable, mscAtmIfVccVcdPmSegLinkSideMeasurement=mscAtmIfVccVcdPmSegLinkSideMeasurement, mscAtmIfVccPmFwdMaximumClr0=mscAtmIfVccPmFwdMaximumClr0, mscAtmIfProvEntry=mscAtmIfProvEntry, mscAtmIfVccHoldingPriority=mscAtmIfVccHoldingPriority, mscAtmIfVptStatsTxCell=mscAtmIfVptStatsTxCell, mscAtmIfVptVccTestResultsTable=mscAtmIfVptVccTestResultsTable, mscAtmIfVpcVpdTmRowStatus=mscAtmIfVpcVpdTmRowStatus, mscAtmIfVptVccStatsTxFrameDiscard=mscAtmIfVptVccStatsTxFrameDiscard, mscAtmIfVptVccAtmServiceCategory=mscAtmIfVptVccAtmServiceCategory, mscAtmIfVpcRowStatus=mscAtmIfVpcRowStatus, mscAtmIfVptCAActualMaxVccs=mscAtmIfVptCAActualMaxVccs, mscAtmIfVptIndex=mscAtmIfVptIndex, mscAtmIfVccTmTxQosClass=mscAtmIfVccTmTxQosClass, mscAtmIfVptTmRxPacketWiseDiscard=mscAtmIfVptTmRxPacketWiseDiscard, mscAtmIfCACbrCdvt=mscAtmIfCACbrCdvt, mscAtmIfNAcctComponentName=mscAtmIfNAcctComponentName, mscAtmIfVpcVpdTmAbrRowStatusEntry=mscAtmIfVpcVpdTmAbrRowStatusEntry, mscAtmIfVptVccVcdTmBearerClassBbc=mscAtmIfVptVccVcdTmBearerClassBbc, mscAtmIfCACbrForceTagging=mscAtmIfCACbrForceTagging, mscAtmIfVccVcdTmAbrCutoffDecreaseFactor=mscAtmIfVccVcdTmAbrCutoffDecreaseFactor, mscAtmIfVptVccVcdTmAbrMaxTimeBetweenRmCells=mscAtmIfVptVccVcdTmAbrMaxTimeBetweenRmCells, mscAtmIfCAUbrOperTable=mscAtmIfCAUbrOperTable, mscAtmIfVptTmRxTdpIndex=mscAtmIfVptTmRxTdpIndex, mscAtmIfVccTxQThreshIndex=mscAtmIfVccTxQThreshIndex, mscAtmIfVccVcdTmRxTdpIndex=mscAtmIfVccVcdTmRxTdpIndex, mscAtmIfConnMapNumVccsForVpiZero=mscAtmIfConnMapNumVccsForVpiZero, mscAtmIfVptSegSwitchSideLoopbackState=mscAtmIfVptSegSwitchSideLoopbackState, mscAtmIfVptVpdRxTrafficDescType=mscAtmIfVptVpdRxTrafficDescType, mscAtmIfVccVcdTmTxTdpEntry=mscAtmIfVccVcdTmTxTdpEntry, mscAtmIfCACbrOperTable=mscAtmIfCACbrOperTable, mscAtmIfVccTmAbrIndex=mscAtmIfVccTmAbrIndex, mscAtmIfPmSegSwitchSideMeasurement=mscAtmIfPmSegSwitchSideMeasurement, mscAtmIfVccVcdTxQosClass=mscAtmIfVccVcdTxQosClass, mscAtmIfVpcTm=mscAtmIfVpcTm, mscAtmIfVccVcdTmAbrInitialCellRate=mscAtmIfVccVcdTmAbrInitialCellRate, mscAtmIfVptVpdFqpEntry=mscAtmIfVptVpdFqpEntry, mscAtmIfVpcVpdTmWeight=mscAtmIfVpcVpdTmWeight, atmCoreGroupCB02=atmCoreGroupCB02, mscAtmIfVptVpdTmUnshapedTransmitQueueing=mscAtmIfVptVpdTmUnshapedTransmitQueueing, mscAtmIfVptVccVcdEndToEndLoopback=mscAtmIfVptVccVcdEndToEndLoopback, mscAtmIfCARtVbrHoldingPriority=mscAtmIfCARtVbrHoldingPriority, mscAtmIfVptVpdTmAbrFarEndInitialCellRate=mscAtmIfVptVpdTmAbrFarEndInitialCellRate, mscAtmIfVpcPmBwdAverageClr0=mscAtmIfVpcPmBwdAverageClr0, mscAtmIfMaxVpiBits=mscAtmIfMaxVpiBits, mscAtmIfVptStatsRxCellDiscardClp=mscAtmIfVptStatsRxCellDiscardClp, mscAtmIfVptVpdBqpTable=mscAtmIfVptVpdBqpTable, mscAtmIfCABwPoolIndex=mscAtmIfCABwPoolIndex, mscAtmIfVptTmAbrRowStatusTable=mscAtmIfVptTmAbrRowStatusTable, mscAtmIfVccStatsTxFrameDiscard=mscAtmIfVccStatsTxFrameDiscard, mscAtmIfVptCARtVbr=mscAtmIfVptCARtVbr, mscAtmIfVptVccTmAbrForwardRmCellLimit=mscAtmIfVptVccTmAbrForwardRmCellLimit, mscAtmIfVpcStatsRxFrameDiscardClp=mscAtmIfVpcStatsRxFrameDiscardClp, mscAtmIfCAUbrCdvt=mscAtmIfCAUbrCdvt, mscAtmIfTxCellMemoryThresholdEntry=mscAtmIfTxCellMemoryThresholdEntry, mscAtmIfVptVccVcdTxTdpEntry=mscAtmIfVptVccVcdTxTdpEntry, mscAtmIfVccVcdSegLinkSideLoopback=mscAtmIfVccVcdSegLinkSideLoopback, mscAtmIfVptVccNepRowStatusEntry=mscAtmIfVptVccNepRowStatusEntry, mscAtmIfVptVccVcdRxTdpEntry=mscAtmIfVptVccVcdRxTdpEntry, mscAtmIfVpcTxDiscardClp=mscAtmIfVpcTxDiscardClp, mscAtmIfVptTmRqpIndex=mscAtmIfVptTmRqpIndex, mscAtmIfVptVccTmTxTrafficDescType=mscAtmIfVptVccTmTxTrafficDescType, mscAtmIfCAAbrPool=mscAtmIfCAAbrPool, mscAtmIfVptVccVcdUnshapedTransmitQueueing=mscAtmIfVptVccVcdUnshapedTransmitQueueing, mscAtmIfVpcTxTdpValue=mscAtmIfVpcTxTdpValue, mscAtmIfCANrtVbrComponentName=mscAtmIfCANrtVbrComponentName, mscAtmIfVccTm=mscAtmIfVccTm, mscAtmIfVpcTmRqpIndex=mscAtmIfVpcTmRqpIndex, mscAtmIfVccTmRxTdpTable=mscAtmIfVccTmRxTdpTable, mscAtmIfVccVcdCorrelationTag=mscAtmIfVccVcdCorrelationTag, mscAtmIfVptTmAbrRateIncreaseFactor=mscAtmIfVptTmAbrRateIncreaseFactor, mscAtmIfVccPmStatusTable=mscAtmIfVccPmStatusTable, mscAtmIfVptVccTmAbrMaxTimeBetweenRmCell=mscAtmIfVptVccTmAbrMaxTimeBetweenRmCell, mscAtmIfVpcTmIndex=mscAtmIfVpcTmIndex, mscAtmIfVptVpdTmAbrProvEntry=mscAtmIfVptVpdTmAbrProvEntry, mscAtmIfVpcTxTdpEntry=mscAtmIfVpcTxTdpEntry, mscAtmIfVptCACbrCdvt=mscAtmIfVptCACbrCdvt, mscAtmIfVpcVpdPmStorageType=mscAtmIfVpcVpdPmStorageType, mscAtmIfCACbrComponentName=mscAtmIfCACbrComponentName, mscAtmIfCAUbrOpUnshapedTransmitQueueing=mscAtmIfCAUbrOpUnshapedTransmitQueueing, mscAtmIfVptVccRowStatusEntry=mscAtmIfVptVccRowStatusEntry, mscAtmIfVpcVpdPmRowStatusEntry=mscAtmIfVpcVpdPmRowStatusEntry, mscAtmIfCAMaxVpts=mscAtmIfCAMaxVpts, mscAtmIfVptVccVcdTmAbrInitialCellRate=mscAtmIfVptVccVcdTmAbrInitialCellRate, mscAtmIfVccVcdPmSegSwitchSideMeasurement=mscAtmIfVccVcdPmSegSwitchSideMeasurement, mscAtmIfVpcStatsRxAal5FrameAbort=mscAtmIfVpcStatsRxAal5FrameAbort, mscAtmIfCAAbrDgcraMinimumDelay=mscAtmIfCAAbrDgcraMinimumDelay, mscAtmIfVptCACbrMaxCtd=mscAtmIfVptCACbrMaxCtd, mscAtmIfVptVpdTmAbrCutoffDecreaseFactor=mscAtmIfVptVpdTmAbrCutoffDecreaseFactor, mscAtmIfVptFqpValue=mscAtmIfVptFqpValue, mscAtmIfVpcVpdTrafficShaping=mscAtmIfVpcVpdTrafficShaping, mscAtmIfVptVpdTmRowStatusEntry=mscAtmIfVptVpdTmRowStatusEntry, mscAtmIfVccLoopStorageType=mscAtmIfVccLoopStorageType, mscAtmIfVccVcdTmTxQueueLimit=mscAtmIfVccVcdTmTxQueueLimit, mscAtmIfVccTmAbrStorageType=mscAtmIfVccTmAbrStorageType, mscAtmIfVpcVpdRxTdpIndex=mscAtmIfVpcVpdRxTdpIndex, mscAtmIfVccVcdBearerClassBbc=mscAtmIfVccVcdBearerClassBbc, mscAtmIfVptCAUbrMaxVccs=mscAtmIfVptCAUbrMaxVccs, mscAtmIfVptVccVcdPmRowStatusEntry=mscAtmIfVptVccVcdPmRowStatusEntry, mscAtmIfVptVpdTrafficShaping=mscAtmIfVptVpdTrafficShaping, mscAtmIfVccTestRowStatus=mscAtmIfVccTestRowStatus, mscAtmIfNAcctIndex=mscAtmIfNAcctIndex, mscAtmIfVptVccOperTable=mscAtmIfVptVccOperTable, mscAtmIfVccVcdLbkEntry=mscAtmIfVccVcdLbkEntry, mscAtmIfVptVccIndex=mscAtmIfVptVccIndex, atmCoreCapabilitiesCB02=atmCoreCapabilitiesCB02, mscAtmIfVccLocalFailureCause=mscAtmIfVccLocalFailureCause, mscAtmIfConnMapRowStatusEntry=mscAtmIfConnMapRowStatusEntry, atmCoreGroup=atmCoreGroup, mscAtmIfVccVcdTxTrafficDescType=mscAtmIfVccVcdTxTrafficDescType, mscAtmIfVpcVpdFqpTable=mscAtmIfVpcVpdFqpTable, mscAtmIfVptVccUnshapedTransmitQueueing=mscAtmIfVptVccUnshapedTransmitQueueing, mscAtmIfVptCAAbrStorageType=mscAtmIfVptCAAbrStorageType, mscAtmIfVptCAPoolAdmitBwEntry=mscAtmIfVptCAPoolAdmitBwEntry, mscAtmIfVptVccOperStatus=mscAtmIfVptVccOperStatus, mscAtmIfCACbrOperEntry=mscAtmIfCACbrOperEntry, mscAtmIfVpcTxQueueLength=mscAtmIfVpcTxQueueLength, mscAtmIfVpcTmHoldingPriority=mscAtmIfVpcTmHoldingPriority, mscAtmIfVccVcdUnshapedTransmitQueueing=mscAtmIfVccVcdUnshapedTransmitQueueing, mscAtmIfVptRowStatusTable=mscAtmIfVptRowStatusTable, mscAtmIfCAOamBrPmConnections=mscAtmIfCAOamBrPmConnections, mscAtmIfVptVccVcdTmTxQueueLimit=mscAtmIfVptVccVcdTmTxQueueLimit, mscAtmIfPmRowStatusEntry=mscAtmIfPmRowStatusEntry, mscAtmIfVpcTmRxPacketWiseDiscard=mscAtmIfVpcTmRxPacketWiseDiscard, mscAtmIfVccVcdTmTxPacketWiseDiscard=mscAtmIfVccVcdTmTxPacketWiseDiscard, mscAtmIfCAUbr=mscAtmIfCAUbr, mscAtmIfVptVccTestIndex=mscAtmIfVptVccTestIndex, mscAtmIfVptTmTxTdpIndex=mscAtmIfVptTmTxTdpIndex, mscAtmIfVccVcdStorageType=mscAtmIfVccVcdStorageType, mscAtmIfVpcRxTdpValue=mscAtmIfVpcRxTdpValue, mscAtmIfCANrtVbrIndex=mscAtmIfCANrtVbrIndex, mscAtmIfVptCABwPoolIndex=mscAtmIfVptCABwPoolIndex, mscAtmIfVptCANrtVbrStorageType=mscAtmIfVptCANrtVbrStorageType, mscAtmIfVccVcdTmAbrProvEntry=mscAtmIfVccVcdTmAbrProvEntry, mscAtmIfVccVcdTmBwdQosClass=mscAtmIfVccVcdTmBwdQosClass, mscAtmIfVpcVpdTmIndex=mscAtmIfVpcVpdTmIndex, mscAtmIfRxFrameDiscard=mscAtmIfRxFrameDiscard, mscAtmIfVptAisState=mscAtmIfVptAisState, mscAtmIfVpcTxQThreshTable=mscAtmIfVpcTxQThreshTable, mscAtmIfVptAtmServiceCategory=mscAtmIfVptAtmServiceCategory, mscAtmIfVptVccVcdTmRxTdpValue=mscAtmIfVptVccVcdTmRxTdpValue, mscAtmIfVptCARtVbrRowStatus=mscAtmIfVptCARtVbrRowStatus, mscAtmIfVccOperStatus=mscAtmIfVccOperStatus, mscAtmIfTxLinkUtilization=mscAtmIfTxLinkUtilization, mscAtmIfCAActualMaxVccs=mscAtmIfCAActualMaxVccs, mscAtmIfVpcVpdRxTrafficDescType=mscAtmIfVpcVpdRxTrafficDescType, mscAtmIfVptVccTmAbrConnectionType=mscAtmIfVptVccTmAbrConnectionType, mscAtmIfVccVcdTmRowStatusTable=mscAtmIfVccVcdTmRowStatusTable, mscAtmIfVccConnInfoEntry=mscAtmIfVccConnInfoEntry, mscAtmIfVpcTmBearerClassBbc=mscAtmIfVpcTmBearerClassBbc, mscAtmIfVpcVpdTmTxTdpEntry=mscAtmIfVpcVpdTmTxTdpEntry, mscAtmIfVccTmRxTrafficDescType=mscAtmIfVccTmRxTrafficDescType, mscAtmIfVptVccTmAbrTxFwdRmCells=mscAtmIfVptVccTmAbrTxFwdRmCells, mscAtmIfVpcVpdBqpValue=mscAtmIfVpcVpdBqpValue, mscAtmIfVptVpdCorrelationTag=mscAtmIfVptVpdCorrelationTag, mscAtmIfVptCACbrProvTable=mscAtmIfVptCACbrProvTable, mscAtmIfVptVccVcdTmAbrAcrDecreaseTimeFactor=mscAtmIfVptVccVcdTmAbrAcrDecreaseTimeFactor, mscAtmIfVpcTmAbrRxEfci=mscAtmIfVpcTmAbrRxEfci, mscAtmIfVpcPmFailureCause=mscAtmIfVpcPmFailureCause, mscAtmIfConnMapOvNumVccsPerNonZeroVpi=mscAtmIfConnMapOvNumVccsPerNonZeroVpi, mscAtmIfVpcStorageType=mscAtmIfVpcStorageType, mscAtmIfVptVccRxTdpEntry=mscAtmIfVptVccRxTdpEntry, mscAtmIfVptVccStatsTxCell=mscAtmIfVptVccStatsTxCell, mscAtmIfVccNepStorageType=mscAtmIfVccNepStorageType, mscAtmIfVpcTmAbrForwardRmCellLimit=mscAtmIfVpcTmAbrForwardRmCellLimit, mscAtmIfVpcVpdTmRxTdpTable=mscAtmIfVpcVpdTmRxTdpTable, mscAtmIfTxCellEfci=mscAtmIfTxCellEfci, atmCoreCapabilitiesCB02A=atmCoreCapabilitiesCB02A, mscAtmIfVpcAtmServiceCategory=mscAtmIfVpcAtmServiceCategory, mscAtmIfVccPmFwdMinimumClr01=mscAtmIfVccPmFwdMinimumClr01, mscAtmIfVccTestStateEntry=mscAtmIfVccTestStateEntry, mscAtmIfVptTmAbrAcrRateChangeInfo=mscAtmIfVptTmAbrAcrRateChangeInfo, mscAtmIfVccVcdTmComponentName=mscAtmIfVccVcdTmComponentName, mscAtmIfVptVpdBearerClassBbc=mscAtmIfVptVpdBearerClassBbc, mscAtmIfUsageState=mscAtmIfUsageState, mscAtmIfVptVccTmRowStatus=mscAtmIfVptVccTmRowStatus, mscAtmIfVccTmTxQueueLength=mscAtmIfVccTmTxQueueLength, mscAtmIfVpcTmOperEntry=mscAtmIfVpcTmOperEntry, mscAtmIfVptVccVcdTmAbrComponentName=mscAtmIfVptVccVcdTmAbrComponentName, mscAtmIfVccTmAbrRowStatus=mscAtmIfVccTmAbrRowStatus, mscAtmIfVptVccNepRowStatus=mscAtmIfVptVccNepRowStatus, mscAtmIfCANrtVbrOperTable=mscAtmIfCANrtVbrOperTable, mscAtmIfVccTmRowStatus=mscAtmIfVccTmRowStatus, mscAtmIfOperTable=mscAtmIfOperTable, mscAtmIfVptVccTestFrmPatternType=mscAtmIfVptVccTestFrmPatternType, mscAtmIfVpcLoopRowStatus=mscAtmIfVpcLoopRowStatus, mscAtmIfVptCARtVbrRowStatusTable=mscAtmIfVptCARtVbrRowStatusTable, mscAtmIfVptCAAbrProvTable=mscAtmIfVptCAAbrProvTable, mscAtmIfVpcTxTdpTable=mscAtmIfVpcTxTdpTable, mscAtmIfVptTrafficShaping=mscAtmIfVptTrafficShaping, mscAtmIfVpcVpdTransferCapabilityBbc=mscAtmIfVpcVpdTransferCapabilityBbc, mscAtmIfVpcPmFwdPmCellDiscardCount=mscAtmIfVpcPmFwdPmCellDiscardCount, mscAtmIfTxFrameDiscardClp=mscAtmIfTxFrameDiscardClp, mscAtmIfVccVcdRxTdpValue=mscAtmIfVccVcdRxTdpValue, mscAtmIfVccFqpValue=mscAtmIfVccFqpValue, mscAtmIfVptVpdTmAbrStorageType=mscAtmIfVptVpdTmAbrStorageType, mscAtmIfVptStateTable=mscAtmIfVptStateTable, mscAtmIfCACbrRowStatusEntry=mscAtmIfCACbrRowStatusEntry, mscAtmIfVptVccTestAdminState=mscAtmIfVptVccTestAdminState, mscAtmIfVptVccVcdRxTdpIndex=mscAtmIfVptVccVcdRxTdpIndex, mscAtmIfVptVccTmComponentName=mscAtmIfVptVccTmComponentName, mscAtmIfCAAbrPerVcQueueLimitReferenceRate=mscAtmIfCAAbrPerVcQueueLimitReferenceRate, mscAtmIfCAProvEntry=mscAtmIfCAProvEntry, mscAtmIfVccTxFrameDiscard=mscAtmIfVccTxFrameDiscard, mscAtmIfVptVccVcdTmAbrConnectionType=mscAtmIfVptVccVcdTmAbrConnectionType, mscAtmIfVpcBestEffort=mscAtmIfVpcBestEffort, mscAtmIfVpcVpdPmSegLinkSideMeasurement=mscAtmIfVpcVpdPmSegLinkSideMeasurement, mscAtmIfCAUbrEmissionPriority=mscAtmIfCAUbrEmissionPriority, mscAtmIfVccNumLeaves=mscAtmIfVccNumLeaves, mscAtmIfVccPmFwdLastSampleUserCellsRx01=mscAtmIfVccPmFwdLastSampleUserCellsRx01, mscAtmIfVptVccTmAbrAcrDecreaseTimeFactor=mscAtmIfVptVccTmAbrAcrDecreaseTimeFactor, mscAtmIfVpcVpdFqpEntry=mscAtmIfVpcVpdFqpEntry, mscAtmIfVptVccVcdTxTdpValue=mscAtmIfVptVccVcdTxTdpValue, mscAtmIfVccTest=mscAtmIfVccTest, mscAtmIfVptCARtVbrPool=mscAtmIfVptCARtVbrPool, mscAtmIfVpcTmRowStatus=mscAtmIfVpcTmRowStatus, mscAtmIfVpcStatusEntry=mscAtmIfVpcStatusEntry, mscAtmIfVpcVpdTmFqpIndex=mscAtmIfVpcVpdTmFqpIndex, mscAtmIfVccStatusEntry=mscAtmIfVccStatusEntry, mscAtmIfCAMaxAutoSelectedVciForVpiZero=mscAtmIfCAMaxAutoSelectedVciForVpiZero, mscAtmIfVptTmAbrComponentName=mscAtmIfVptTmAbrComponentName, mscAtmIfVpcPmArAvailabilityRatio=mscAtmIfVpcPmArAvailabilityRatio, mscAtmIfVptCARowStatusEntry=mscAtmIfVptCARowStatusEntry, mscAtmIfVptVccVcdPmSegLinkSideMeasurement=mscAtmIfVptVccVcdPmSegLinkSideMeasurement, mscAtmIfVpcVpdBqpIndex=mscAtmIfVpcVpdBqpIndex, mscAtmIfVptVccTmRqpEntry=mscAtmIfVptVccTmRqpEntry, mscAtmIfVptVccStatsRxUpcViolationOnEnforcer2=mscAtmIfVptVccStatsRxUpcViolationOnEnforcer2, mscAtmIfVpcStateTable=mscAtmIfVpcStateTable, mscAtmIfCAUbrTrafficShaping=mscAtmIfCAUbrTrafficShaping, mscAtmIfVccTmRqpValue=mscAtmIfVccTmRqpValue, mscAtmIfVptTmStorageType=mscAtmIfVptTmStorageType, mscAtmIfVccPmArAvailabilityRatio=mscAtmIfVccPmArAvailabilityRatio, mscAtmIfCAPermanentMulticastBranches=mscAtmIfCAPermanentMulticastBranches, mscAtmIfCARtVbrIndex=mscAtmIfCARtVbrIndex, mscAtmIfVpcStatusTable=mscAtmIfVpcStatusTable, mscAtmIfNAcctRowStatus=mscAtmIfNAcctRowStatus, mscAtmIfVccVcdRxTdpIndex=mscAtmIfVccVcdRxTdpIndex, mscAtmIfVptVpdTmTxTdpTable=mscAtmIfVptVpdTmTxTdpTable, mscAtmIfVptVccVcdTmAbrFixedRoundTripTime=mscAtmIfVptVccVcdTmAbrFixedRoundTripTime, mscAtmIfVpcPmFwdLastSampleClr0=mscAtmIfVpcPmFwdLastSampleClr0, mscAtmIfVccTxQThreshValue=mscAtmIfVccTxQThreshValue, mscAtmIfVptRxTdpValue=mscAtmIfVptRxTdpValue, mscAtmIfVccLastMinimumCtd=mscAtmIfVccLastMinimumCtd, mscAtmIfCARtVbrRowStatusTable=mscAtmIfCARtVbrRowStatusTable, mscAtmIfStateEntry=mscAtmIfStateEntry, mscAtmIfVccBqpTable=mscAtmIfVccBqpTable, mscAtmIfVccVcdTmAbrDgcraMaximumDelay=mscAtmIfVccVcdTmAbrDgcraMaximumDelay, mscAtmIfVptVpdTmTxQueueLimit=mscAtmIfVptVpdTmTxQueueLimit, mscAtmIfVpcTmAbrTxFwdRmCells=mscAtmIfVpcTmAbrTxFwdRmCells, mscAtmIfCAMaxCaVpts=mscAtmIfCAMaxCaVpts, mscAtmIfVccTmAbrAcrRateChangeInfo=mscAtmIfVccTmAbrAcrRateChangeInfo)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfVptVccVcdPmControlMode=mscAtmIfVptVccVcdPmControlMode, mscAtmIfVptVccVcdTrafficEntry=mscAtmIfVptVccVcdTrafficEntry, mscAtmIfVptVccTxTdpTable=mscAtmIfVptVccTxTdpTable, mscAtmIfVpcPmArEntry=mscAtmIfVpcPmArEntry, mscAtmIfCABwPoolTable=mscAtmIfCABwPoolTable, mscAtmIfPmControlMode=mscAtmIfPmControlMode, mscAtmIfVccPmBwdTotalUserCellsTx01=mscAtmIfVccPmBwdTotalUserCellsTx01, mscAtmIfLbkEntry=mscAtmIfLbkEntry, mscAtmIfVptVccBearerClassBbc=mscAtmIfVptVccBearerClassBbc, mscAtmIfCAVbrNrtPool=mscAtmIfCAVbrNrtPool, mscAtmIfVccStatsEntry=mscAtmIfVccStatsEntry, mscAtmIfVptCARowStatusTable=mscAtmIfVptCARowStatusTable, mscAtmIfVptVccVcdTmComponentName=mscAtmIfVptVccVcdTmComponentName, mscAtmIfVccNepComponentName=mscAtmIfVccNepComponentName, mscAtmIfVptVpdFwdQosClass=mscAtmIfVptVpdFwdQosClass, mscAtmIfVptVccStatsRxFrameDiscardClp=mscAtmIfVptVccStatsRxFrameDiscardClp, mscAtmIfVpcTxQosClass=mscAtmIfVpcTxQosClass, mscAtmIfCAMaxVccs=mscAtmIfCAMaxVccs, mscAtmIfOamSegmentBoundary=mscAtmIfOamSegmentBoundary, mscAtmIfVptTmTqpValue=mscAtmIfVptTmTqpValue, mscAtmIfVptTmOperTable=mscAtmIfVptTmOperTable, mscAtmIfVptTxDiscard=mscAtmIfVptTxDiscard, mscAtmIfCARtVbrRowStatusEntry=mscAtmIfCARtVbrRowStatusEntry, mscAtmIfVptVccStateTable=mscAtmIfVptVccStateTable, mscAtmIfVpcOperationalState=mscAtmIfVpcOperationalState, mscAtmIfVptVccOperationalState=mscAtmIfVptVccOperationalState, mscAtmIfVpcAdminState=mscAtmIfVpcAdminState, mscAtmIfCARtVbrProvTable=mscAtmIfCARtVbrProvTable, mscAtmIfVptCAPoolAdmConnsEntry=mscAtmIfVptCAPoolAdmConnsEntry, mscAtmIfShapeUsageEntry=mscAtmIfShapeUsageEntry, atmCoreCapabilities=atmCoreCapabilities, mscAtmIfVpcVpdTmRxTdpEntry=mscAtmIfVpcVpdTmRxTdpEntry, mscAtmIfVpcPmBwdMinimumClr0=mscAtmIfVpcPmBwdMinimumClr0, mscAtmIfVptVccStatsEntry=mscAtmIfVptVccStatsEntry, mscAtmIfVptCASwitchedVccs=mscAtmIfVptCASwitchedVccs, mscAtmIfVptVccNepRowStatusTable=mscAtmIfVptVccNepRowStatusTable, mscAtmIfVpcPmFwdLastSampleUserCellsRx0=mscAtmIfVpcPmFwdLastSampleUserCellsRx0, mscAtmIfVptFwdQosClass=mscAtmIfVptFwdQosClass, mscAtmIfCAUbrMaxVccs=mscAtmIfCAUbrMaxVccs, mscAtmIfVpcPmFwdLastSampleUserCellsRx01=mscAtmIfVpcPmFwdLastSampleUserCellsRx01, mscAtmIfVptCA=mscAtmIfVptCA, mscAtmIfCACbrProvCdvt=mscAtmIfCACbrProvCdvt, mscAtmIfVpcTmRxTrafficDescType=mscAtmIfVpcTmRxTrafficDescType, mscAtmIfVccPmFwdClrTable=mscAtmIfVccPmFwdClrTable, mscAtmIfCACbrProvEntry=mscAtmIfCACbrProvEntry, mscAtmIfVccRowStatusEntry=mscAtmIfVccRowStatusEntry, mscAtmIfVptTxTdpValue=mscAtmIfVptTxTdpValue, mscAtmIfCARtVbrForceTagging=mscAtmIfCARtVbrForceTagging, mscAtmIfVpcVpdTmTxTdpIndex=mscAtmIfVpcVpdTmTxTdpIndex, mscAtmIfVccTxQueueCongestionState=mscAtmIfVccTxQueueCongestionState, mscAtmIfVptVpdBqpEntry=mscAtmIfVptVpdBqpEntry, mscAtmIfVptCACbrPool=mscAtmIfVptCACbrPool, mscAtmIfProvTable=mscAtmIfProvTable, mscAtmIfCANrtVbrRowStatusTable=mscAtmIfCANrtVbrRowStatusTable, mscAtmIfVpcVpdTmAbr=mscAtmIfVpcVpdTmAbr, mscAtmIfVccNepIndex=mscAtmIfVccNepIndex, mscAtmIfConnMapNumVccsForVpiZeroOper=mscAtmIfConnMapNumVccsForVpiZeroOper, mscAtmIfVpcVpdFqpIndex=mscAtmIfVpcVpdFqpIndex, mscAtmIfVccRxOamCellCongestionState=mscAtmIfVccRxOamCellCongestionState, mscAtmIfVptVccTxDiscard=mscAtmIfVptVccTxDiscard, mscAtmIfVptTmAbrForwardRmCellLimit=mscAtmIfVptTmAbrForwardRmCellLimit, mscAtmIfPmStorageType=mscAtmIfPmStorageType, mscAtmIfCACbrPool=mscAtmIfCACbrPool, mscAtmIfVpcVpdTmHoldingPriority=mscAtmIfVpcVpdTmHoldingPriority, mscAtmIfLbkTable=mscAtmIfLbkTable, mscAtmIfVptVccTmRowStatusTable=mscAtmIfVptVccTmRowStatusTable, mscAtmIfCACbrProvPool=mscAtmIfCACbrProvPool, mscAtmIfVptVccVcdCorrelationTag=mscAtmIfVptVccVcdCorrelationTag, mscAtmIfVptTmRqpTable=mscAtmIfVptTmRqpTable, mscAtmIfVccRxDiscardClp=mscAtmIfVccRxDiscardClp, mscAtmIfVccFwdQosClass=mscAtmIfVccFwdQosClass, mscAtmIfVptVccBqpEntry=mscAtmIfVptVccBqpEntry, mscAtmIfInterfaceName=mscAtmIfInterfaceName, mscAtmIfVccPmFwdTotalUserCellsTx0=mscAtmIfVccPmFwdTotalUserCellsTx0, mscAtmIfVptVccStatsTxFrameDiscardClp=mscAtmIfVptVccStatsTxFrameDiscardClp, mscAtmIfVccTmAbrOperTable=mscAtmIfVccTmAbrOperTable, mscAtmIfVpcVpdTmUnshapedTransmitQueueing=mscAtmIfVpcVpdTmUnshapedTransmitQueueing, mscAtmIfVpcTmAbrRateDecreaseFactor=mscAtmIfVpcTmAbrRateDecreaseFactor, mscAtmIfCAOamFPmConnections=mscAtmIfCAOamFPmConnections, mscAtmIfVptTmUnshapedTransmitQueueing=mscAtmIfVptTmUnshapedTransmitQueueing, mscAtmIfCAOperTable=mscAtmIfCAOperTable, mscAtmIfCAAbrRowStatus=mscAtmIfCAAbrRowStatus, mscAtmIfVccVcdSegSwitchSideLoopback=mscAtmIfVccVcdSegSwitchSideLoopback, mscAtmIfVptVpdTmAbrRateDecreaseFactor=mscAtmIfVptVpdTmAbrRateDecreaseFactor, mscAtmIfVpcPmArAvailableTime=mscAtmIfVpcPmArAvailableTime, mscAtmIfVpcSegLinkSideLoopbackState=mscAtmIfVpcSegLinkSideLoopbackState, mscAtmIfCAIndex=mscAtmIfCAIndex, mscAtmIfVptVpdTmAbrAcrDecreaseTimeFactor=mscAtmIfVptVpdTmAbrAcrDecreaseTimeFactor, mscAtmIfVccRxQosClass=mscAtmIfVccRxQosClass, mscAtmIfVccVcdTmClippingBbc=mscAtmIfVccVcdTmClippingBbc, mscAtmIfVpcPmStatusEntry=mscAtmIfVpcPmStatusEntry, mscAtmIfVptVccTmTxPacketWiseDiscard=mscAtmIfVptVccTmTxPacketWiseDiscard, mscAtmIfVptVccVcdBestEffort=mscAtmIfVptVccVcdBestEffort, mscAtmIfVccTmTxTdpValue=mscAtmIfVccTmTxTdpValue, mscAtmIfVpcLocalFailureCause=mscAtmIfVpcLocalFailureCause, mscAtmIfVptVccTmAbrRowStatus=mscAtmIfVptVccTmAbrRowStatus, mscAtmIfVptVccTestSetupEntry=mscAtmIfVptVccTestSetupEntry, mscAtmIfShapeUsageValue=mscAtmIfShapeUsageValue, mscAtmIfCACbrPerVcQueueLimitReferenceRate=mscAtmIfCACbrPerVcQueueLimitReferenceRate, mscAtmIfVptVccVcdPmSegSwitchSideMeasurement=mscAtmIfVptVccVcdPmSegSwitchSideMeasurement, mscAtmIfVptRxTdpTable=mscAtmIfVptRxTdpTable, mscAtmIfVptStatsTxCellDiscard=mscAtmIfVptStatsTxCellDiscard, mscAtmIfVpcConnectionPointType=mscAtmIfVpcConnectionPointType, mscAtmIfVpcVpdTmAtmServiceCategory=mscAtmIfVpcVpdTmAtmServiceCategory, mscAtmIfCARtVbrCellLossRatio=mscAtmIfCARtVbrCellLossRatio, mscAtmIfVptVccVcdTmFqpIndex=mscAtmIfVptVccVcdTmFqpIndex, mscAtmIfVccBearerClassBbc=mscAtmIfVccBearerClassBbc, mscAtmIfVptVccVcdTmProvEntry=mscAtmIfVptVccVcdTmProvEntry, mscAtmIfVpcTxQThreshEntry=mscAtmIfVpcTxQThreshEntry, mscAtmIfVptVccNepProvEntry=mscAtmIfVptVccNepProvEntry, mscAtmIfVccRxTdpIndex=mscAtmIfVccRxTdpIndex, mscAtmIfVptVpdTmTxTrafficDescType=mscAtmIfVptVpdTmTxTrafficDescType, mscAtmIfVptCAUbrStorageType=mscAtmIfVptCAUbrStorageType, mscAtmIfCAAbrAcrDecreaseTimeFactor=mscAtmIfCAAbrAcrDecreaseTimeFactor, mscAtmIfVptVccBwdQosClass=mscAtmIfVptVccBwdQosClass, mscAtmIfEpMinimumBandwidthGuarantee=mscAtmIfEpMinimumBandwidthGuarantee, mscAtmIfCAMinMulticastBranches=mscAtmIfCAMinMulticastBranches, mscAtmIfVccVcdFwdQosClass=mscAtmIfVccVcdFwdQosClass, mscAtmIfVpt=mscAtmIfVpt, mscAtmIfCAActualMaxVpts=mscAtmIfCAActualMaxVpts, mscAtmIfCARtVbrWeightPolicy=mscAtmIfCARtVbrWeightPolicy, mscAtmIfVpcVpdHoldingPriority=mscAtmIfVpcVpdHoldingPriority, mscAtmIfVptVccStatsRxCellClp=mscAtmIfVptVccStatsRxCellClp, mscAtmIfVccVcdPmControlMode=mscAtmIfVccVcdPmControlMode, mscAtmIfVptVpdTmBearerClassBbc=mscAtmIfVptVpdTmBearerClassBbc, mscAtmIfConnMapComponentName=mscAtmIfConnMapComponentName, mscAtmIfVccTestLoadingFrmLost=mscAtmIfVccTestLoadingFrmLost, mscAtmIfVpcConnInfoTable=mscAtmIfVpcConnInfoTable, mscAtmIfVptStatsRxFrameDiscardClp=mscAtmIfVptStatsRxFrameDiscardClp, mscAtmIfCAUbrProvEntry=mscAtmIfCAUbrProvEntry, mscAtmIfVpcPmFwdTotalUserCellsRx0=mscAtmIfVpcPmFwdTotalUserCellsRx0, mscAtmIfVptVpdTmAbrTransientBufferExposure=mscAtmIfVptVpdTmAbrTransientBufferExposure, mscAtmIfVptVpdFqpIndex=mscAtmIfVptVpdFqpIndex, mscAtmIfVpcTmBestEffort=mscAtmIfVpcTmBestEffort, mscAtmIfLrcFrameErrors=mscAtmIfLrcFrameErrors, mscAtmIfVccStatsTxCellDiscardClp=mscAtmIfVccStatsTxCellDiscardClp, mscAtmIfVpcTmRxTdpTable=mscAtmIfVpcTmRxTdpTable, mscAtmIfVccTestResultsEntry=mscAtmIfVccTestResultsEntry, mscAtmIfVccVcdFwdFrameDiscard=mscAtmIfVccVcdFwdFrameDiscard, mscAtmIfCAUbrTxQueueLimit=mscAtmIfCAUbrTxQueueLimit, mscAtmIfVptTrafficTable=mscAtmIfVptTrafficTable, mscAtmIfVptVccTestLoadingFrmRx=mscAtmIfVptVccTestLoadingFrmRx, mscAtmIfCATroubledVccs=mscAtmIfCATroubledVccs, mscAtmIfVpcStatsRxFrameDiscard=mscAtmIfVpcStatsRxFrameDiscard, mscAtmIfVptVccTmRxTrafficDescType=mscAtmIfVptVccTmRxTrafficDescType, mscAtmIfVptVccSegSwitchSideLoopbackState=mscAtmIfVptVccSegSwitchSideLoopbackState, mscAtmIfTxCellMemoryThresholdTable=mscAtmIfTxCellMemoryThresholdTable, mscAtmIfVptCAUbrRowStatusTable=mscAtmIfVptCAUbrRowStatusTable, mscAtmIfVptVccVcdTmUnshapedTransmitQueueing=mscAtmIfVptVccVcdTmUnshapedTransmitQueueing, mscAtmIfVccPmFwdTotalUserCellsRx01=mscAtmIfVccPmFwdTotalUserCellsRx01, mscAtmIfVccTmAbrTransientBufferExposure=mscAtmIfVccTmAbrTransientBufferExposure, mscAtmIfCAAbrCutoffDecreaseFactor=mscAtmIfCAAbrCutoffDecreaseFactor, mscAtmIfVccPmClrMeasurementStatus=mscAtmIfVccPmClrMeasurementStatus, mscAtmIfVptVccRxTdpIndex=mscAtmIfVptVccRxTdpIndex, mscAtmIfVpcPmBwdLastSampleUserCellsRx01=mscAtmIfVpcPmBwdLastSampleUserCellsRx01, mscAtmIfVccClippingBbc=mscAtmIfVccClippingBbc, mscAtmIfVpcTmWeight=mscAtmIfVpcTmWeight, mscAtmIfVpcLoopRowStatusTable=mscAtmIfVpcLoopRowStatusTable, mscAtmIfVptTmRowStatus=mscAtmIfVptTmRowStatus, mscAtmIfVptVccVcdTmAbrDgcraMaximumDelay=mscAtmIfVptVccVcdTmAbrDgcraMaximumDelay, mscAtmIfVccTxTdpValue=mscAtmIfVccTxTdpValue, mscAtmIfVptVpdTmAbrRowStatusEntry=mscAtmIfVptVpdTmAbrRowStatusEntry, mscAtmIfVpcVpdBwdFrameDiscard=mscAtmIfVpcVpdBwdFrameDiscard, mscAtmIfVptVpdTxTrafficDescType=mscAtmIfVptVpdTxTrafficDescType, mscAtmIfVptVccTmTqpEntry=mscAtmIfVptVccTmTqpEntry, mscAtmIfVccRowStatus=mscAtmIfVccRowStatus, mscAtmIfCAAbrFairnessPolicy=mscAtmIfCAAbrFairnessPolicy, mscAtmIfPmProvTable=mscAtmIfPmProvTable, mscAtmIfVptVccVcdTxTdpIndex=mscAtmIfVptVccVcdTxTdpIndex, mscAtmIfVccTmBearerClassBbc=mscAtmIfVccTmBearerClassBbc, mscAtmIfVptVpdBestEffort=mscAtmIfVptVpdBestEffort, mscAtmIfVptCAUbrProvEntry=mscAtmIfVptCAUbrProvEntry, mscAtmIfVptTmIndex=mscAtmIfVptTmIndex, mscAtmIfVpcVpdPmComponentName=mscAtmIfVpcVpdPmComponentName, mscAtmIfVccRowStatusTable=mscAtmIfVccRowStatusTable, mscAtmIfVpcTmAbrTransientBufferExposure=mscAtmIfVpcTmAbrTransientBufferExposure, mscAtmIfVpcTmTxQThreshTable=mscAtmIfVpcTmTxQThreshTable, mscAtmIfVpcTmRowStatusTable=mscAtmIfVpcTmRowStatusTable, mscAtmIfVptVccVcdTmAbrIndex=mscAtmIfVptVccVcdTmAbrIndex, mscAtmIfVccTestDuration=mscAtmIfVccTestDuration, mscAtmIfVpcVpdTmAbrRowStatusTable=mscAtmIfVpcVpdTmAbrRowStatusTable, mscAtmIfVpcTxQThreshIndex=mscAtmIfVpcTxQThreshIndex, mscAtmIfVptTmRxTdpEntry=mscAtmIfVptTmRxTdpEntry, mscAtmIfVpcVpdTmFwdQosClass=mscAtmIfVpcVpdTmFwdQosClass, mscAtmIfVccBestEffort=mscAtmIfVccBestEffort, mscAtmIfVptCAPoolRequBwTable=mscAtmIfVptCAPoolRequBwTable, mscAtmIfVptVccVcdTmTxTdpEntry=mscAtmIfVptVccVcdTmTxTdpEntry, mscAtmIfConnMapOperTable=mscAtmIfConnMapOperTable, mscAtmIfVccTmAbrRowStatusTable=mscAtmIfVccTmAbrRowStatusTable, mscAtmIfShapeUsageIndex=mscAtmIfShapeUsageIndex, mscAtmIfVptOperTable=mscAtmIfVptOperTable, mscAtmIfVptTmTqpEntry=mscAtmIfVptTmTqpEntry, mscAtmIfVpcAisState=mscAtmIfVpcAisState, mscAtmIfVpcVpdTmFqpEntry=mscAtmIfVpcVpdTmFqpEntry, mscAtmIfVptTxQueueCongestionState=mscAtmIfVptTxQueueCongestionState, mscAtmIfVpcVpdTmAbrFixedRoundTripTime=mscAtmIfVpcVpdTmAbrFixedRoundTripTime, mscAtmIfTxFrameDiscard=mscAtmIfTxFrameDiscard, mscAtmIfVpcVpdFqpValue=mscAtmIfVpcVpdFqpValue, mscAtmIfVptVccStatsRxCellDiscard=mscAtmIfVptVccStatsRxCellDiscard, mscAtmIfVptTmRxQosClass=mscAtmIfVptTmRxQosClass, mscAtmIfCAConnectionPoolUsage=mscAtmIfCAConnectionPoolUsage, mscAtmIfVccTmRxQosClass=mscAtmIfVccTmRxQosClass, mscAtmIfVptVccVcdTmBqpIndex=mscAtmIfVptVccVcdTmBqpIndex, mscAtmIfCARtVbrEpdOffset=mscAtmIfCARtVbrEpdOffset, mscAtmIfVpcVpdTxTrafficDescType=mscAtmIfVpcVpdTxTrafficDescType, mscAtmIfVccVcdTmBestEffort=mscAtmIfVccVcdTmBestEffort, mscAtmIfVpcTmTxQosClass=mscAtmIfVpcTmTxQosClass, mscAtmIfVpcTxDiscard=mscAtmIfVpcTxDiscard, mscAtmIfVpcVpdTrafficEntry=mscAtmIfVpcVpdTrafficEntry, mscAtmIfVpcVpdBearerClassBbc=mscAtmIfVpcVpdBearerClassBbc, mscAtmIfVptVccVcdTmBestEffort=mscAtmIfVptVccVcdTmBestEffort, mscAtmIfVccRxDiscard=mscAtmIfVccRxDiscard, mscAtmIfCASwitchedMulticastBranches=mscAtmIfCASwitchedMulticastBranches, mscAtmIfVptVccVcdTmAbrProvEntry=mscAtmIfVptVccVcdTmAbrProvEntry, mscAtmIfCAPoolAvailableBwIndex=mscAtmIfCAPoolAvailableBwIndex, mscAtmIfVptCANrtVbrRowStatusTable=mscAtmIfVptCANrtVbrRowStatusTable, mscAtmIfVccTxDiscardClp=mscAtmIfVccTxDiscardClp, mscAtmIfSegSwitchSideLoopback=mscAtmIfSegSwitchSideLoopback, mscAtmIfVptVccRxQosClass=mscAtmIfVptVccRxQosClass, mscAtmIfCAPermanentVpts=mscAtmIfCAPermanentVpts, mscAtmIfVccTxTdpEntry=mscAtmIfVccTxTdpEntry, mscAtmIfVptVccVcdRowStatusEntry=mscAtmIfVptVccVcdRowStatusEntry, mscAtmIfVpcBqpIndex=mscAtmIfVpcBqpIndex, mscAtmIfVptVpdTmRxTdpIndex=mscAtmIfVptVpdTmRxTdpIndex, mscAtmIfVccNepRowStatusTable=mscAtmIfVccNepRowStatusTable, mscAtmIfVpcTmRqpEntry=mscAtmIfVpcTmRqpEntry, mscAtmIfComponentName=mscAtmIfComponentName, mscAtmIfVptVcc=mscAtmIfVptVcc, mscAtmIfCAAbrRateDecreaseFactor=mscAtmIfCAAbrRateDecreaseFactor, mscAtmIfVpcVpdTmRxTdpIndex=mscAtmIfVpcVpdTmRxTdpIndex, mscAtmIfVptCAUbrPool=mscAtmIfVptCAUbrPool, mscAtmIfVccVcdTmRxTdpValue=mscAtmIfVccVcdTmRxTdpValue, mscAtmIfCACbrStorageType=mscAtmIfCACbrStorageType, mscAtmIfVpcPmBwdTotalUserCellsTx0=mscAtmIfVpcPmBwdTotalUserCellsTx0, mscAtmIfVccTmAbrMaxCellPerRmCell=mscAtmIfVccTmAbrMaxCellPerRmCell, mscAtmIfCAAbrCdvt=mscAtmIfCAAbrCdvt, mscAtmIfVccFqpEntry=mscAtmIfVccFqpEntry, mscAtmIfDroppedRxCells=mscAtmIfDroppedRxCells, mscAtmIfEpRowStatusTable=mscAtmIfEpRowStatusTable, mscAtmIfUsageParameterControl=mscAtmIfUsageParameterControl, mscAtmIfVccBqpIndex=mscAtmIfVccBqpIndex, mscAtmIfCAUbrPerVcQueueLimitReferenceRate=mscAtmIfCAUbrPerVcQueueLimitReferenceRate, mscAtmIfOpShapingRatesIndex=mscAtmIfOpShapingRatesIndex, mscAtmIfCAPoolAdmitBwTable=mscAtmIfCAPoolAdmitBwTable, mscAtmIfVptVccVcdBqpTable=mscAtmIfVptVccVcdBqpTable, mscAtmIfVpcVpdLbkTable=mscAtmIfVpcVpdLbkTable, mscAtmIfVccVcdTmTxTdpValue=mscAtmIfVccVcdTmTxTdpValue, mscAtmIfVptVccFqpEntry=mscAtmIfVptVccFqpEntry, mscAtmIfVptVccTmTxTdpIndex=mscAtmIfVptVccTmTxTdpIndex, mscAtmIfVpcTmAbrRowStatusEntry=mscAtmIfVpcTmAbrRowStatusEntry, mscAtmIfVptVccTmRxTdpValue=mscAtmIfVptVccTmRxTdpValue, mscAtmIfCARtVbrMaxCtd=mscAtmIfCARtVbrMaxCtd, mscAtmIfCARtVbrUnshapedTransmitQueueing=mscAtmIfCARtVbrUnshapedTransmitQueueing, mscAtmIfVptBqpValue=mscAtmIfVptBqpValue)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfVptVccVcdTmFwdQosClass=mscAtmIfVptVccVcdTmFwdQosClass, mscAtmIfVpcVpdBestEffort=mscAtmIfVpcVpdBestEffort, mscAtmIfVccTmUnshapedTransmitQueueing=mscAtmIfVccTmUnshapedTransmitQueueing, mscAtmIfRxCell=mscAtmIfRxCell, mscAtmIfVpcVpdIndex=mscAtmIfVpcVpdIndex, mscAtmIfVpcVpdTmBestEffort=mscAtmIfVpcVpdTmBestEffort, mscAtmIfVccTestResultsTable=mscAtmIfVccTestResultsTable, mscAtmIfUnknownStatus=mscAtmIfUnknownStatus, mscAtmIfVptSegLinkSideLoopbackState=mscAtmIfVptSegLinkSideLoopbackState, mscAtmIfVccPmFwdLastSampleClr01=mscAtmIfVccPmFwdLastSampleClr01, mscAtmIfVccVcdTmWeight=mscAtmIfVccVcdTmWeight, mscAtmIfVpcTxTdpIndex=mscAtmIfVpcTxTdpIndex, mscAtmIfVccVcdPmComponentName=mscAtmIfVccVcdPmComponentName, mscAtmIfVptVpdUsageParameterControl=mscAtmIfVptVpdUsageParameterControl, mscAtmIfVptVpdTmProvTable=mscAtmIfVptVpdTmProvTable, mscAtmIfVpcRxQosClass=mscAtmIfVpcRxQosClass, mscAtmIfCAUbrEpdOffset=mscAtmIfCAUbrEpdOffset, mscAtmIfVptCANrtVbrProvTable=mscAtmIfVptCANrtVbrProvTable, mscAtmIfVpcBqpValue=mscAtmIfVpcBqpValue, mscAtmIfVptVpdRxTdpEntry=mscAtmIfVptVpdRxTdpEntry, mscAtmIfVptVpdTmTransferCapabilityBbc=mscAtmIfVptVpdTmTransferCapabilityBbc, mscAtmIfVccVcdPmProvEntry=mscAtmIfVccVcdPmProvEntry, mscAtmIfCACbr=mscAtmIfCACbr, mscAtmIfCARtVbrEmissionPriority=mscAtmIfCARtVbrEmissionPriority, mscAtmIfVccTestFrmTypes=mscAtmIfVccTestFrmTypes, mscAtmIfVptVccAisState=mscAtmIfVptVccAisState, mscAtmIfVpcTmAbrRowStatusTable=mscAtmIfVpcTmAbrRowStatusTable, mscAtmIfCAPoolProvBwEntry=mscAtmIfCAPoolProvBwEntry, mscAtmIfCARowStatusTable=mscAtmIfCARowStatusTable, mscAtmIfVptTxQosClass=mscAtmIfVptTxQosClass, mscAtmIfConnMapRowStatus=mscAtmIfConnMapRowStatus, mscAtmIfVccTestLoadingFrmRx=mscAtmIfVccTestLoadingFrmRx, mscAtmIfVccPmFwdClrEntry=mscAtmIfVccPmFwdClrEntry, mscAtmIfCARtVbrRowStatus=mscAtmIfCARtVbrRowStatus, mscAtmIfVccVcdTmAbrRateDecreaseFactor=mscAtmIfVccVcdTmAbrRateDecreaseFactor, mscAtmIfConnMapOvRowStatus=mscAtmIfConnMapOvRowStatus, mscAtmIfVptVccTmTxQThreshIndex=mscAtmIfVptVccTmTxQThreshIndex, mscAtmIfVpcVpdTmTxTdpTable=mscAtmIfVpcVpdTmTxTdpTable, mscAtmIfVptVpdComponentName=mscAtmIfVptVpdComponentName, mscAtmIfVpcTmTxQThreshIndex=mscAtmIfVpcTmTxQThreshIndex, mscAtmIfCASwitchedVccs=mscAtmIfCASwitchedVccs, mscAtmIfVptVpdTransferCapabilityBbc=mscAtmIfVptVpdTransferCapabilityBbc, mscAtmIfVccBwdQosClass=mscAtmIfVccBwdQosClass, mscAtmIfVccTmOperTable=mscAtmIfVccTmOperTable, mscAtmIfVccUsageState=mscAtmIfVccUsageState, mscAtmIfVptTmAbrRateDecreaseFactor=mscAtmIfVptTmAbrRateDecreaseFactor, mscAtmIfVccVcdTmTxTdpIndex=mscAtmIfVccVcdTmTxTdpIndex, mscAtmIfVccTmRqpIndex=mscAtmIfVccTmRqpIndex, mscAtmIfVpcTroubled=mscAtmIfVpcTroubled, mscAtmIfVpcStatsTable=mscAtmIfVpcStatsTable, mscAtmIfVpcRxTdpIndex=mscAtmIfVpcRxTdpIndex, mscAtmIfVptCAPoolAvailBwEntry=mscAtmIfVptCAPoolAvailBwEntry, mscAtmIfVptVccNepApplicationName=mscAtmIfVptVccNepApplicationName, mscAtmIfVpcPmBwdTotalUserCellsRx01=mscAtmIfVpcPmBwdTotalUserCellsRx01, mscAtmIfCARtVbrOperEntry=mscAtmIfCARtVbrOperEntry, mscAtmIfVpcVpdRxQosClass=mscAtmIfVpcVpdRxQosClass, mscAtmIfVptVccStatsRxCellDiscardClp=mscAtmIfVptVccStatsRxCellDiscardClp, mscAtmIfVpcVpdTxQosClass=mscAtmIfVpcVpdTxQosClass, mscAtmIfAvailabilityStatus=mscAtmIfAvailabilityStatus, mscAtmIfVccRxTdpValue=mscAtmIfVccRxTdpValue, mscAtmIfVptVpdTmUsageParameterControl=mscAtmIfVptVpdTmUsageParameterControl, mscAtmIfVpcVpdTmAbrDgcraMinimumDelay=mscAtmIfVpcVpdTmAbrDgcraMinimumDelay, mscAtmIfVptVccTest=mscAtmIfVptVccTest, mscAtmIfVptBestEffort=mscAtmIfVptBestEffort, mscAtmIfVptVccTmAbrComponentName=mscAtmIfVptVccTmAbrComponentName, mscAtmIfCAPoolRequBwIndex=mscAtmIfCAPoolRequBwIndex, mscAtmIfVpcEndToEndLoopbackState=mscAtmIfVpcEndToEndLoopbackState, mscAtmIfVptCACbrRowStatus=mscAtmIfVptCACbrRowStatus, mscAtmIfVccTrafficTable=mscAtmIfVccTrafficTable, mscAtmIfCANrtVbrEmissionPriority=mscAtmIfCANrtVbrEmissionPriority, mscAtmIfCACbrTxQueueLimit=mscAtmIfCACbrTxQueueLimit, mscAtmIfVccTmUsageParameterControl=mscAtmIfVccTmUsageParameterControl, mscAtmIfVptVccTestOperationalState=mscAtmIfVptVccTestOperationalState, mscAtmIfCAVbrRtPool=mscAtmIfCAVbrRtPool, mscAtmIfVccTestCustomizedPattern=mscAtmIfVccTestCustomizedPattern, mscAtmIfVccTestBytesRx=mscAtmIfVccTestBytesRx, mscAtmIfPmSegLinkSideMeasurement=mscAtmIfPmSegLinkSideMeasurement, mscAtmIfVpcTmAbrRowStatus=mscAtmIfVpcTmAbrRowStatus, mscAtmIfVptVccConnInfoTable=mscAtmIfVptVccConnInfoTable, mscAtmIfVccTmAbrOperEntry=mscAtmIfVccTmAbrOperEntry, mscAtmIfVptVccRxTrafficDescType=mscAtmIfVptVccRxTrafficDescType, mscAtmIfVptTmAbrOperTable=mscAtmIfVptTmAbrOperTable, mscAtmIfVptVpdTmAbrDgcraMaximumDelay=mscAtmIfVptVpdTmAbrDgcraMaximumDelay, mscAtmIfVpcPmFwdAverageClr01=mscAtmIfVpcPmFwdAverageClr01, mscAtmIfVptTmTqpTable=mscAtmIfVptTmTqpTable, mscAtmIfVccVcdPmRowStatus=mscAtmIfVccVcdPmRowStatus, mscAtmIfVptCABwPoolValue=mscAtmIfVptCABwPoolValue, mscAtmIfVpcFqpTable=mscAtmIfVpcFqpTable, mscAtmIfStateTable=mscAtmIfStateTable, mscAtmIfVpcStatsTxFrameDiscard=mscAtmIfVpcStatsTxFrameDiscard, mscAtmIfVptVccTmTxTdpTable=mscAtmIfVptVccTmTxTdpTable, mscAtmIfVpcPerfTable=mscAtmIfVpcPerfTable, mscAtmIfVccTestLoadingFrmTx=mscAtmIfVccTestLoadingFrmTx, mscAtmIfVptVccVcdTmUsageParameterControl=mscAtmIfVptVccVcdTmUsageParameterControl, mscAtmIfVpcVpdTmClippingBbc=mscAtmIfVpcVpdTmClippingBbc, mscAtmIfVptTmRxTdpTable=mscAtmIfVptTmRxTdpTable, mscAtmIfVptVccEndToEndLoopbackState=mscAtmIfVptVccEndToEndLoopbackState, mscAtmIfVccVcdAcctEntry=mscAtmIfVccVcdAcctEntry, mscAtmIfCANrtVbrSvcMpHoldingPriority=mscAtmIfCANrtVbrSvcMpHoldingPriority, mscAtmIfCANrtVbrRowStatusEntry=mscAtmIfCANrtVbrRowStatusEntry, mscAtmIfVptVpdProvEntry=mscAtmIfVptVpdProvEntry, mscAtmIfVptCACbrCellLossRatio=mscAtmIfVptCACbrCellLossRatio, mscAtmIfEpComponentName=mscAtmIfEpComponentName, mscAtmIfVptVccVcdTmRxTrafficDescType=mscAtmIfVptVccVcdTmRxTrafficDescType, mscAtmIfVptVccTestLoadingFrmTx=mscAtmIfVptVccTestLoadingFrmTx, mscAtmIfCAPermanentVccs=mscAtmIfCAPermanentVccs, mscAtmIfVpc=mscAtmIfVpc, mscAtmIfVpcComponentName=mscAtmIfVpcComponentName, mscAtmIfVccIndex=mscAtmIfVccIndex, mscAtmIfCAUbrMinimumCellRate=mscAtmIfCAUbrMinimumCellRate, mscAtmIfCAPoolRequBwTable=mscAtmIfCAPoolRequBwTable, mscAtmIfVptVccVcdTmProvTable=mscAtmIfVptVccVcdTmProvTable, mscAtmIfVptCAIndex=mscAtmIfVptCAIndex, mscAtmIfVptVpdTmRxTdpEntry=mscAtmIfVptVpdTmRxTdpEntry, mscAtmIfVccVcdClippingBbc=mscAtmIfVccVcdClippingBbc, mscAtmIfVptVpdTrafficEntry=mscAtmIfVptVpdTrafficEntry, mscAtmIfNAcctStorageType=mscAtmIfNAcctStorageType, mscAtmIfVptVpdTmAbrFixedRoundTripTime=mscAtmIfVptVpdTmAbrFixedRoundTripTime, mscAtmIfVptVccVcdClippingBbc=mscAtmIfVptVccVcdClippingBbc, mscAtmIfVptVpdTmBqpTable=mscAtmIfVptVpdTmBqpTable, mscAtmIfVpcTmTxQThreshEntry=mscAtmIfVpcTmTxQThreshEntry, mscAtmIfVccTmAbrAcrDecreaseTimeFactor=mscAtmIfVccTmAbrAcrDecreaseTimeFactor, mscAtmIfVptVccTestSetupTable=mscAtmIfVptVccTestSetupTable, mscAtmIfTxCellMemory=mscAtmIfTxCellMemory, mscAtmIfVccTestComponentName=mscAtmIfVccTestComponentName, mscAtmIfCAUbrSvcMpHoldingPriority=mscAtmIfCAUbrSvcMpHoldingPriority, mscAtmIfVptTmAbrMaxCellPerRmCell=mscAtmIfVptTmAbrMaxCellPerRmCell, mscAtmIfAlarmStatus=mscAtmIfAlarmStatus, mscAtmIfCASvcCbrHoldingPriority=mscAtmIfCASvcCbrHoldingPriority, mscAtmIfVccTmAbrRowStatusEntry=mscAtmIfVccTmAbrRowStatusEntry, mscAtmIfVptVpdTxTdpValue=mscAtmIfVptVpdTxTdpValue, mscAtmIfCANrtVbrProvTable=mscAtmIfCANrtVbrProvTable, mscAtmIfVpcVpdTmRxTdpValue=mscAtmIfVpcVpdTmRxTdpValue, mscAtmIfVpcVpdTmTxTrafficDescType=mscAtmIfVpcVpdTmTxTrafficDescType, mscAtmIfVptUnshapedTransmitQueueing=mscAtmIfVptUnshapedTransmitQueueing, mscAtmIfVpcVpdPmIndex=mscAtmIfVpcVpdPmIndex, mscAtmIfCANrtVbrSvcHoldingPriority=mscAtmIfCANrtVbrSvcHoldingPriority, mscAtmIfVccPmBwdClrTable=mscAtmIfVccPmBwdClrTable, mscAtmIfNAcctRowStatusTable=mscAtmIfNAcctRowStatusTable, mscAtmIfVptCAPoolAdmitBwValue=mscAtmIfVptCAPoolAdmitBwValue, mscAtmIfCACbrProvTable=mscAtmIfCACbrProvTable, atmCoreGroupCB=atmCoreGroupCB, mscAtmIfVptCAUbrOperEntry=mscAtmIfVptCAUbrOperEntry, mscAtmIfVccPmFwdMaximumClr01=mscAtmIfVccPmFwdMaximumClr01, mscAtmIfVpcTmComponentName=mscAtmIfVpcTmComponentName, mscAtmIfVptOperEntry=mscAtmIfVptOperEntry, mscAtmIfVpcTmAbrComponentName=mscAtmIfVpcTmAbrComponentName, mscAtmIfVpcPmRowStatusEntry=mscAtmIfVpcPmRowStatusEntry, mscAtmIfVccTmRqpEntry=mscAtmIfVccTmRqpEntry, mscAtmIfVpcVpdRxTdpTable=mscAtmIfVpcVpdRxTdpTable, mscAtmIfVptVccTestElapsedTime=mscAtmIfVptVccTestElapsedTime, mscAtmIfCAPoolAdmConnsTable=mscAtmIfCAPoolAdmConnsTable, mscAtmIfVccVcdTmAbrProvTable=mscAtmIfVccVcdTmAbrProvTable, mscAtmIfVccTestOverrideHoldingPriority=mscAtmIfVccTestOverrideHoldingPriority, mscAtmIfVptVccFqpTable=mscAtmIfVptVccFqpTable, mscAtmIfVpcTmTxTdpValue=mscAtmIfVpcTmTxTdpValue, mscAtmIfVptTmAbrAcrDecreaseTimeFactor=mscAtmIfVptTmAbrAcrDecreaseTimeFactor, mscAtmIfStatsTable=mscAtmIfStatsTable, mscAtmIfVccTestVerificationFrmRx=mscAtmIfVccTestVerificationFrmRx, mscAtmIfVccLastAverageCtd=mscAtmIfVccLastAverageCtd, mscAtmIfVptVccVcdTmRowStatusEntry=mscAtmIfVptVccVcdTmRowStatusEntry, mscAtmIfVpcVpdSegSwitchSideLoopback=mscAtmIfVpcVpdSegSwitchSideLoopback, mscAtmIfVccStatsRxAal5FrameAbort=mscAtmIfVccStatsRxAal5FrameAbort, mscAtmIfNAcctProvEntry=mscAtmIfNAcctProvEntry, mscAtmIfVccTmAbr=mscAtmIfVccTmAbr, mscAtmIfVpcVpdTmStorageType=mscAtmIfVpcVpdTmStorageType, mscAtmIfVptCAAbrPool=mscAtmIfVptCAAbrPool, mscAtmIfVpcPmFwdMinimumClr0=mscAtmIfVpcPmFwdMinimumClr0, mscAtmIfVccTmTxQThreshIndex=mscAtmIfVccTmTxQThreshIndex, mscAtmIfVptVccVcdComponentName=mscAtmIfVptVccVcdComponentName, mscAtmIfVptVccVcdBwdFrameDiscard=mscAtmIfVptVccVcdBwdFrameDiscard, mscAtmIfVpcTrafficTable=mscAtmIfVpcTrafficTable, mscAtmIfVccTestStorageType=mscAtmIfVccTestStorageType, mscAtmIfVpcVpdRxTdpValue=mscAtmIfVpcVpdRxTdpValue, mscAtmIfVccVcdTmUsageParameterControl=mscAtmIfVccVcdTmUsageParameterControl, mscAtmIfVptTmAbrInitialCellRate=mscAtmIfVptTmAbrInitialCellRate, mscAtmIfPmIndex=mscAtmIfPmIndex, mscAtmIfVccVcdTmBearerClassBbc=mscAtmIfVccVcdTmBearerClassBbc, mscAtmIfTxCellMemoryCongestionState=mscAtmIfTxCellMemoryCongestionState, mscAtmIfVpcVpdTmRowStatusTable=mscAtmIfVpcVpdTmRowStatusTable, mscAtmIfVccUnshapedTransmitQueueing=mscAtmIfVccUnshapedTransmitQueueing, mscAtmIfVptVpdTmClippingBbc=mscAtmIfVptVpdTmClippingBbc, mscAtmIfVptVccVcdLbkTable=mscAtmIfVptVccVcdLbkTable, mscAtmIfVptVccTestVerificationFrmBad=mscAtmIfVptVccTestVerificationFrmBad, mscAtmIfVccPmArEntry=mscAtmIfVccPmArEntry, mscAtmIfVptStatsTable=mscAtmIfVptStatsTable, mscAtmIfVpcUsageState=mscAtmIfVpcUsageState, mscAtmIfVccNep=mscAtmIfVccNep, mscAtmIfVpcTmAbrOperEntry=mscAtmIfVpcTmAbrOperEntry, mscAtmIfVpcVpdTmBqpTable=mscAtmIfVpcVpdTmBqpTable, mscAtmIfVpcVpdTmAbrFarEndInitialCellRate=mscAtmIfVpcVpdTmAbrFarEndInitialCellRate, mscAtmIfVccVcdFqpIndex=mscAtmIfVccVcdFqpIndex, mscAtmIfVpcVpdMCastConnectionType=mscAtmIfVpcVpdMCastConnectionType, mscAtmIfVpcTmRxQosClass=mscAtmIfVpcTmRxQosClass, mscAtmIfVccVcdRowStatusTable=mscAtmIfVccVcdRowStatusTable, mscAtmIfVccVcdIndex=mscAtmIfVccVcdIndex, mscAtmIfRxCellDiscardClp=mscAtmIfRxCellDiscardClp, mscAtmIfTxCellDiscard=mscAtmIfTxCellDiscard, mscAtmIfVptVpdTmTxTdpValue=mscAtmIfVptVpdTmTxTdpValue, mscAtmIfVptVccTmAbrIndex=mscAtmIfVptVccTmAbrIndex, mscAtmIfVptVpdIndex=mscAtmIfVptVpdIndex, mscAtmIfVptTmRxTrafficDescType=mscAtmIfVptTmRxTrafficDescType, mscAtmIfVptVccVcdTmWeight=mscAtmIfVptVccVcdTmWeight, mscAtmIfVpcRowStatusEntry=mscAtmIfVpcRowStatusEntry, mscAtmIfVpcPmFwdTotalClrInterval=mscAtmIfVpcPmFwdTotalClrInterval, mscAtmIfCA=mscAtmIfCA, mscAtmIfVptTmAbrFixedRoundTripTime=mscAtmIfVptTmAbrFixedRoundTripTime, mscAtmIfVptVccRxDiscardClp=mscAtmIfVptVccRxDiscardClp, mscAtmIfVptRxDiscardClp=mscAtmIfVptRxDiscardClp, mscAtmIfVptVccNep=mscAtmIfVptVccNep, mscAtmIfEpProvEntry=mscAtmIfEpProvEntry, mscAtmIfVpcTmTxTdpEntry=mscAtmIfVpcTmTxTdpEntry, mscAtmIfVccTmForceTagging=mscAtmIfVccTmForceTagging, mscAtmIfCAAbrTxQueueLimit=mscAtmIfCAAbrTxQueueLimit, mscAtmIfVptVccVcdTmAbrDgcraMinimumDelay=mscAtmIfVptVccVcdTmAbrDgcraMinimumDelay, mscAtmIfVpcVpdPmProvEntry=mscAtmIfVpcVpdPmProvEntry, mscAtmIfVpcPmFwdTotalUserCellsTx0=mscAtmIfVpcPmFwdTotalUserCellsTx0, mscAtmIfVccPmArTotalTime=mscAtmIfVccPmArTotalTime, mscAtmIfVccVcdTrafficEntry=mscAtmIfVccVcdTrafficEntry, mscAtmIfVccVcdTmFqpEntry=mscAtmIfVccVcdTmFqpEntry, mscAtmIfVptVccVcdTmTxTdpIndex=mscAtmIfVptVccVcdTmTxTdpIndex, mscAtmIfVccRxTdpEntry=mscAtmIfVccRxTdpEntry, mscAtmIfCAAbrMaxCellPerRmCell=mscAtmIfCAAbrMaxCellPerRmCell, mscAtmIfVpcVpdFwdFrameDiscard=mscAtmIfVpcVpdFwdFrameDiscard, mscAtmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor=mscAtmIfVptVpdTmAbrFarEndAcrDecreaseTimeFactor, mscAtmIfCACbrIndex=mscAtmIfCACbrIndex, mscAtmIfCARtVbrProvEntry=mscAtmIfCARtVbrProvEntry, mscAtmIfCASvcVbrRtHoldingPriority=mscAtmIfCASvcVbrRtHoldingPriority, mscAtmIfProceduralStatus=mscAtmIfProceduralStatus, mscAtmIfVccTmTrafficShaping=mscAtmIfVccTmTrafficShaping, mscAtmIfVptVpdTxTdpIndex=mscAtmIfVptVpdTxTdpIndex, mscAtmIfVpcVpdTmAbrComponentName=mscAtmIfVpcVpdTmAbrComponentName, mscAtmIfCACbrRowStatusTable=mscAtmIfCACbrRowStatusTable, mscAtmIfVptCAUbrOperTable=mscAtmIfVptCAUbrOperTable, mscAtmIfConnMapNumVccsPerNonZeroVpi=mscAtmIfConnMapNumVccsPerNonZeroVpi, mscAtmIf=mscAtmIf, mscAtmIfConnMapOperEntry=mscAtmIfConnMapOperEntry, mscAtmIfVccBandwidthReduction=mscAtmIfVccBandwidthReduction, mscAtmIfVptTmTxTrafficDescType=mscAtmIfVptTmTxTrafficDescType, mscAtmIfVccVcdTmAbrAcrDecreaseTimeFactor=mscAtmIfVccVcdTmAbrAcrDecreaseTimeFactor, mscAtmIfVptVccTmAbrOperTable=mscAtmIfVptVccTmAbrOperTable, mscAtmIfCAPoolRequBwValue=mscAtmIfCAPoolRequBwValue, mscAtmIfVccPmBwdAverageClr01=mscAtmIfVccPmBwdAverageClr01, mscAtmIfVpcTxQThreshValue=mscAtmIfVpcTxQThreshValue, mscAtmIfVpcRxTdpTable=mscAtmIfVpcRxTdpTable, mscAtmIfVptVpdTmRowStatus=mscAtmIfVptVpdTmRowStatus, mscAtmIfVccTmOperEntry=mscAtmIfVccTmOperEntry, mscAtmIfVccStatsRxUpcViolationOnEnforcer1=mscAtmIfVccStatsRxUpcViolationOnEnforcer1, mscAtmIfVccTxTdpIndex=mscAtmIfVccTxTdpIndex, mscAtmIfFaultHoldOffTime=mscAtmIfFaultHoldOffTime, mscAtmIfTxCellMemoryThresholdValue=mscAtmIfTxCellMemoryThresholdValue, mscAtmIfLastDroppedRxCellConnection=mscAtmIfLastDroppedRxCellConnection, mscAtmIfVptRdiState=mscAtmIfVptRdiState, mscAtmIfConnMapVccProvEntry=mscAtmIfConnMapVccProvEntry)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfVpcVpdStorageType=mscAtmIfVpcVpdStorageType, mscAtmIfVccTmAbrInitialCellRate=mscAtmIfVccTmAbrInitialCellRate, mscAtmIfVptFqpTable=mscAtmIfVptFqpTable, mscAtmIfVptVccTmRqpTable=mscAtmIfVptVccTmRqpTable, mscAtmIfVccTmTxQThreshTable=mscAtmIfVccTmTxQThreshTable, mscAtmIfVccAisState=mscAtmIfVccAisState, mscAtmIfVccStatsRxAal5FrameError=mscAtmIfVccStatsRxAal5FrameError, mscAtmIfCARtVbrTrafficShaping=mscAtmIfCARtVbrTrafficShaping, mscAtmIfVccTmAbrTxRateChangeInfo=mscAtmIfVccTmAbrTxRateChangeInfo, mscAtmIfCAPermanentVpcs=mscAtmIfCAPermanentVpcs, mscAtmIfVptCAProvEntry=mscAtmIfVptCAProvEntry, mscAtmIfVptVccTmStorageType=mscAtmIfVptVccTmStorageType, mscAtmIfVptVpdBqpValue=mscAtmIfVptVpdBqpValue, mscAtmIfVptVccTmTxQueueLength=mscAtmIfVptVccTmTxQueueLength, mscAtmIfVccLoopRowStatusEntry=mscAtmIfVccLoopRowStatusEntry, mscAtmIfCAMaxCaVpcs=mscAtmIfCAMaxCaVpcs, mscAtmIfVpcPmFwdTotalUserCellsTx01=mscAtmIfVpcPmFwdTotalUserCellsTx01, mscAtmIfVptCAPoolWaitAdmConnsTable=mscAtmIfVptCAPoolWaitAdmConnsTable, mscAtmIfCAAbrOperEntry=mscAtmIfCAAbrOperEntry, mscAtmIfVptVccTmAbrOperEntry=mscAtmIfVptVccTmAbrOperEntry, mscAtmIfVptVccRowStatus=mscAtmIfVptVccRowStatus, mscAtmIfCANrtVbrStorageType=mscAtmIfCANrtVbrStorageType, mscAtmIfVpcStatsRxUpcViolationOnEnforcer1=mscAtmIfVpcStatsRxUpcViolationOnEnforcer1, mscAtmIfConnMapNumNonZeroVpisForVccs=mscAtmIfConnMapNumNonZeroVpisForVccs, mscAtmIfVccComponentName=mscAtmIfVccComponentName, mscAtmIfVptCAPoolProvBwTable=mscAtmIfVptCAPoolProvBwTable, mscAtmIfCAUbrForceTagging=mscAtmIfCAUbrForceTagging, mscAtmIfVptCAStorageType=mscAtmIfVptCAStorageType, mscAtmIfVptCAOperEntry=mscAtmIfVptCAOperEntry, mscAtmIfVccVcdTmBqpIndex=mscAtmIfVccVcdTmBqpIndex, mscAtmIfVptVccTxDiscardClp=mscAtmIfVptVccTxDiscardClp, mscAtmIfVptVpdTmBwdQosClass=mscAtmIfVptVpdTmBwdQosClass, mscAtmIfVpcStatsEntry=mscAtmIfVpcStatsEntry, mscAtmIfVptVccNepProvTable=mscAtmIfVptVccNepProvTable, mscAtmIfCustomerIdentifier=mscAtmIfCustomerIdentifier, mscAtmIfVccTmTqpIndex=mscAtmIfVccTmTqpIndex, mscAtmIfVptCARtVbrProvEntry=mscAtmIfVptCARtVbrProvEntry, mscAtmIfVptVpdTm=mscAtmIfVptVpdTm, mscAtmIfOperationalState=mscAtmIfOperationalState, mscAtmIfVpcVpdTmTxQueueLimit=mscAtmIfVpcVpdTmTxQueueLimit, mscAtmIfVccRdiState=mscAtmIfVccRdiState, mscAtmIfVpcPmStorageType=mscAtmIfVpcPmStorageType, mscAtmIfCAAbrMinPerVcQueueLimit=mscAtmIfCAAbrMinPerVcQueueLimit, mscAtmIfVccConnectionPointType=mscAtmIfVccConnectionPointType, mscAtmIfVptVpdTmAbrIndex=mscAtmIfVptVpdTmAbrIndex, mscAtmIfCARtVbrSvcHoldingPriority=mscAtmIfCARtVbrSvcHoldingPriority, mscAtmIfCACbrWeightPolicy=mscAtmIfCACbrWeightPolicy, mscAtmIfCAUbrPool=mscAtmIfCAUbrPool, mscAtmIfVptVccTrafficShaping=mscAtmIfVptVccTrafficShaping, mscAtmIfVptVccVcdSegLinkSideLoopback=mscAtmIfVptVccVcdSegLinkSideLoopback, mscAtmIfVpcTmTxTdpIndex=mscAtmIfVpcTmTxTdpIndex, mscAtmIfVpcVpdTmFqpValue=mscAtmIfVpcVpdTmFqpValue, mscAtmIfRowStatusEntry=mscAtmIfRowStatusEntry, mscAtmIfVccTmHoldingPriority=mscAtmIfVccTmHoldingPriority, mscAtmIfVptVpdTmAbrRowStatus=mscAtmIfVptVpdTmAbrRowStatus, mscAtmIfVccVcdLbkTable=mscAtmIfVccVcdLbkTable, mscAtmIfVpcVpdTmAbrStorageType=mscAtmIfVpcVpdTmAbrStorageType, mscAtmIfVptStatsTxFrameDiscardClp=mscAtmIfVptStatsTxFrameDiscardClp, mscAtmIfVccVcdTmAbrConnectionType=mscAtmIfVccVcdTmAbrConnectionType, mscAtmIfVptVpdTmWeight=mscAtmIfVptVpdTmWeight, mscAtmIfVccTxQThreshTable=mscAtmIfVccTxQThreshTable, mscAtmIfVccLoop=mscAtmIfVccLoop, mscAtmIfVpcPmCurrentAvailabilityStatus=mscAtmIfVpcPmCurrentAvailabilityStatus, mscAtmIfVccBqpEntry=mscAtmIfVccBqpEntry, mscAtmIfVccVcdTmRowStatus=mscAtmIfVccVcdTmRowStatus, mscAtmIfCAMaxMulticastBranches=mscAtmIfCAMaxMulticastBranches, mscAtmIfVptCAUbrProvTable=mscAtmIfVptCAUbrProvTable, mscAtmIfVptVccTxQThreshTable=mscAtmIfVptVccTxQThreshTable, mscAtmIfVptVccVcd=mscAtmIfVptVccVcd, mscAtmIfCAUbrProvTable=mscAtmIfCAUbrProvTable, mscAtmIfCANrtVbrHoldingPriority=mscAtmIfCANrtVbrHoldingPriority, mscAtmIfVptVpdTmFqpEntry=mscAtmIfVptVpdTmFqpEntry, mscAtmIfVptTmAbrOperEntry=mscAtmIfVptTmAbrOperEntry, mscAtmIfEpIndex=mscAtmIfEpIndex, mscAtmIfVpcVpdBwdQosClass=mscAtmIfVpcVpdBwdQosClass, mscAtmIfVpcTmRowStatusEntry=mscAtmIfVpcTmRowStatusEntry, mscAtmIfVptTmAbrRowStatusEntry=mscAtmIfVptTmAbrRowStatusEntry, mscAtmIfVpcPmFwdClrTable=mscAtmIfVpcPmFwdClrTable, mscAtmIfVccVcdPmProvTable=mscAtmIfVccVcdPmProvTable, mscAtmIfVccPmFwdLastSampleClr0=mscAtmIfVccPmFwdLastSampleClr0, mscAtmIfVptBandwidthReduction=mscAtmIfVptBandwidthReduction, mscAtmIfVptStatsRxUpcViolationOnEnforcer1=mscAtmIfVptStatsRxUpcViolationOnEnforcer1, mscAtmIfConnMapRowStatusTable=mscAtmIfConnMapRowStatusTable, mscAtmIfCANrtVbrOpUnshapedTransmitQueueing=mscAtmIfCANrtVbrOpUnshapedTransmitQueueing, mscAtmIfVpcPmFwdMaximumClr01=mscAtmIfVpcPmFwdMaximumClr01, mscAtmIfVptStatsRxAal5FrameError=mscAtmIfVptStatsRxAal5FrameError, mscAtmIfVccVcdTmBqpTable=mscAtmIfVccVcdTmBqpTable, mscAtmIfNAcctProvTable=mscAtmIfNAcctProvTable, mscAtmIfCANrtVbrMinPerVcQueueLimit=mscAtmIfCANrtVbrMinPerVcQueueLimit, mscAtmIfCARtVbrShapeRecoupPolicy=mscAtmIfCARtVbrShapeRecoupPolicy, mscAtmIfCAMaxAutoSelectedVciForNonZeroVpi=mscAtmIfCAMaxAutoSelectedVciForNonZeroVpi, mscAtmIfVpcTransferCapabilityBbc=mscAtmIfVpcTransferCapabilityBbc, mscAtmIfVccVcdBqpValue=mscAtmIfVccVcdBqpValue, mscAtmIfVpcVpdEndToEndLoopback=mscAtmIfVpcVpdEndToEndLoopback, mscAtmIfVpcUnshapedTransmitQueueing=mscAtmIfVpcUnshapedTransmitQueueing, mscAtmIfVptVpdEndToEndLoopback=mscAtmIfVptVpdEndToEndLoopback, mscAtmIfVptComponentName=mscAtmIfVptComponentName, mscAtmIfVptVpdRowStatusTable=mscAtmIfVptVpdRowStatusTable, mscAtmIfVpcPmBwdLastSampleClr01=mscAtmIfVpcPmBwdLastSampleClr01, mscAtmIfVptVccVcdBwdQosClass=mscAtmIfVptVccVcdBwdQosClass, mscAtmIfVpcVpdTmComponentName=mscAtmIfVpcVpdTmComponentName, atmCoreMIB=atmCoreMIB, mscAtmIfCANrtVbrTrafficShaping=mscAtmIfCANrtVbrTrafficShaping, mscAtmIfVpcTmAtmServiceCategory=mscAtmIfVpcTmAtmServiceCategory, mscAtmIfVpcPmClrMeasurementStatus=mscAtmIfVpcPmClrMeasurementStatus, mscAtmIfVptTmUsageParameterControl=mscAtmIfVptTmUsageParameterControl, mscAtmIfEpProvTable=mscAtmIfEpProvTable, mscAtmIfVpcVpdTmBqpEntry=mscAtmIfVpcVpdTmBqpEntry, mscAtmIfVptVpdClippingBbc=mscAtmIfVptVpdClippingBbc, mscAtmIfCAPoolAvailBwValue=mscAtmIfCAPoolAvailBwValue, mscAtmIfCAUbrHoldingPriority=mscAtmIfCAUbrHoldingPriority, mscAtmIfVpcPmArTable=mscAtmIfVpcPmArTable, mscAtmIfVptOperationalState=mscAtmIfVptOperationalState, mscAtmIfCANrtVbrPool=mscAtmIfCANrtVbrPool, mscAtmIfCAOamCcConnections=mscAtmIfCAOamCcConnections, mscAtmIfVccSegLinkSideLoopbackState=mscAtmIfVccSegLinkSideLoopbackState, mscAtmIfVptVpdTmFwdQosClass=mscAtmIfVptVpdTmFwdQosClass, mscAtmIfVpcTmTxQueueLength=mscAtmIfVpcTmTxQueueLength, mscAtmIfCAPoolAdmConnsEntry=mscAtmIfCAPoolAdmConnsEntry, mscAtmIfCACbrUnshapedTransmitQueueing=mscAtmIfCACbrUnshapedTransmitQueueing, mscAtmIfVccVcdPm=mscAtmIfVccVcdPm, mscAtmIfVptVpdStorageType=mscAtmIfVptVpdStorageType, mscAtmIfCAAbrAbrConnectionType=mscAtmIfCAAbrAbrConnectionType, mscAtmIfVptVccVcdTmHoldingPriority=mscAtmIfVptVccVcdTmHoldingPriority, mscAtmIfSegLinkSideLoopback=mscAtmIfSegLinkSideLoopback, mscAtmIfVptCAPoolWaitAdmConnsIndex=mscAtmIfVptCAPoolWaitAdmConnsIndex, mscAtmIfVptVpdSegLinkSideLoopback=mscAtmIfVptVpdSegLinkSideLoopback, mscAtmIfVptVccVcdTmTxPacketWiseDiscard=mscAtmIfVptVccVcdTmTxPacketWiseDiscard, mscAtmIfVpcTmAbrOperTable=mscAtmIfVpcTmAbrOperTable, mscAtmIfVccVcdEndToEndLoopback=mscAtmIfVccVcdEndToEndLoopback, mscAtmIfVpcVpdTmTxPacketWiseDiscard=mscAtmIfVpcVpdTmTxPacketWiseDiscard, mscAtmIfVpcVpdTmBqpIndex=mscAtmIfVpcVpdTmBqpIndex, mscAtmIfCATroubledVpcs=mscAtmIfCATroubledVpcs, mscAtmIfVptVccLoopRowStatus=mscAtmIfVptVccLoopRowStatus, mscAtmIfVptVccNepIndex=mscAtmIfVptVccNepIndex, mscAtmIfVptVccVcdTmAtmServiceCategory=mscAtmIfVptVccVcdTmAtmServiceCategory, mscAtmIfVptVccTmAbrTransientBufferExposure=mscAtmIfVptVccTmAbrTransientBufferExposure, mscAtmIfVccPmBwdLastSampleUserCellsTx01=mscAtmIfVccPmBwdLastSampleUserCellsTx01, mscAtmIfVpcVpdUnshapedTransmitQueueing=mscAtmIfVpcVpdUnshapedTransmitQueueing, mscAtmIfVpcVpdTmProvTable=mscAtmIfVpcVpdTmProvTable, mscAtmIfVpcPmFwdLastSampleUserCellsTx0=mscAtmIfVpcPmFwdLastSampleUserCellsTx0, mscAtmIfVptVccTmForceTagging=mscAtmIfVptVccTmForceTagging, mscAtmIfVptTmComponentName=mscAtmIfVptTmComponentName, mscAtmIfVccTmTxTdpEntry=mscAtmIfVccTmTxTdpEntry, mscAtmIfVpcVpdTrafficTable=mscAtmIfVpcVpdTrafficTable, mscAtmIfVpcBearerClassBbc=mscAtmIfVpcBearerClassBbc, mscAtmIfVpcVpdPmRowStatus=mscAtmIfVpcVpdPmRowStatus, mscAtmIfVptVccVcdTmStorageType=mscAtmIfVptVccVcdTmStorageType, mscAtmIfVccCurrentCtd=mscAtmIfVccCurrentCtd, mscAtmIfVpcStatsTxCellDiscard=mscAtmIfVpcStatsTxCellDiscard, mscAtmIfVptVccTestRowStatusEntry=mscAtmIfVptVccTestRowStatusEntry, mscAtmIfVccPmComponentName=mscAtmIfVccPmComponentName, mscAtmIfVccVcdTmForceTagging=mscAtmIfVccVcdTmForceTagging, mscAtmIfConnMapOvFirstNonZeroVpiForVccs=mscAtmIfConnMapOvFirstNonZeroVpiForVccs, mscAtmIfVptVccVcdTmBwdQosClass=mscAtmIfVptVccVcdTmBwdQosClass, mscAtmIfVccVcdHoldingPriority=mscAtmIfVccVcdHoldingPriority, mscAtmIfVccPmBwdTotalClrInterval=mscAtmIfVccPmBwdTotalClrInterval, mscAtmIfVpcVpdTmBwdQosClass=mscAtmIfVpcVpdTmBwdQosClass, mscAtmIfVpcTmAbrAcrDecreaseTimeFactor=mscAtmIfVpcTmAbrAcrDecreaseTimeFactor, mscAtmIfVccTmRowStatusEntry=mscAtmIfVccTmRowStatusEntry, mscAtmIfVpcStatsRxCellClp=mscAtmIfVpcStatsRxCellClp, mscAtmIfCtdCalculation=mscAtmIfCtdCalculation, mscAtmIfVptTxTdpTable=mscAtmIfVptTxTdpTable, mscAtmIfVccPmBwdMaximumClr0=mscAtmIfVccPmBwdMaximumClr0, mscAtmIfVccTmStorageType=mscAtmIfVccTmStorageType, mscAtmIfVpcVpdTmAbrAcrDecreaseTimeFactor=mscAtmIfVpcVpdTmAbrAcrDecreaseTimeFactor, mscAtmIfVptVccTestLoadingFrmLost=mscAtmIfVptVccTestLoadingFrmLost, mscAtmIfVptVccTmAbr=mscAtmIfVptVccTmAbr, mscAtmIfVptCATroubledVccs=mscAtmIfVptCATroubledVccs, mscAtmIfVptTmAbrTxFwdRmCells=mscAtmIfVptTmAbrTxFwdRmCells, mscAtmIfVptVpdTmHoldingPriority=mscAtmIfVptVpdTmHoldingPriority, mscAtmIfVptUsageParameterControl=mscAtmIfVptUsageParameterControl, mscAtmIfVptRxTdpIndex=mscAtmIfVptRxTdpIndex, mscAtmIfCARtVbrComponentName=mscAtmIfCARtVbrComponentName, mscAtmIfVptVpdVptType=mscAtmIfVptVpdVptType, mscAtmIfVccVcdTrafficTable=mscAtmIfVccVcdTrafficTable, mscAtmIfCAPoolAvailableBwEntry=mscAtmIfCAPoolAvailableBwEntry, mscAtmIfVptVccTmAbrRowStatusEntry=mscAtmIfVptVccTmAbrRowStatusEntry, mscAtmIfVccTmTxTdpIndex=mscAtmIfVccTmTxTdpIndex, mscAtmIfVptVccTmRxTdpEntry=mscAtmIfVptVccTmRxTdpEntry, mscAtmIfUnshapedTransmitQueueing=mscAtmIfUnshapedTransmitQueueing, mscAtmIfVccTmAbrMaxTimeBetweenRmCell=mscAtmIfVccTmAbrMaxTimeBetweenRmCell, mscAtmIfVptTmTxTdpTable=mscAtmIfVptTmTxTdpTable, mscAtmIfVptCAPoolWaitAdmConnsEntry=mscAtmIfVptCAPoolWaitAdmConnsEntry, mscAtmIfVpcLastMinimumCtd=mscAtmIfVpcLastMinimumCtd, mscAtmIfVptTmTxTdpValue=mscAtmIfVptTmTxTdpValue, mscAtmIfVccStatsRxCellDiscard=mscAtmIfVccStatsRxCellDiscard, mscAtmIfVptVccTrafficTable=mscAtmIfVptVccTrafficTable, mscAtmIfVpcPmBwdLastSampleUserCellsTx0=mscAtmIfVpcPmBwdLastSampleUserCellsTx0, mscAtmIfVptVccVcdTmRowStatusTable=mscAtmIfVptVccVcdTmRowStatusTable, mscAtmIfCARtVbrMinPerVcQueueLimit=mscAtmIfCARtVbrMinPerVcQueueLimit, mscAtmIfCANrtVbrForceTagging=mscAtmIfCANrtVbrForceTagging, mscAtmIfVpcPmBwdClrTable=mscAtmIfVpcPmBwdClrTable, mscAtmIfVccTestRowStatusTable=mscAtmIfVccTestRowStatusTable, mscAtmIfCAPmTable=mscAtmIfCAPmTable, mscAtmIfVpcPmBwdLastSampleClr0=mscAtmIfVpcPmBwdLastSampleClr0, mscAtmIfVptVpdRowStatus=mscAtmIfVptVpdRowStatus, mscAtmIfVccOperationalState=mscAtmIfVccOperationalState, mscAtmIfVptVccVcdRxTdpTable=mscAtmIfVptVccVcdRxTdpTable, mscAtmIfVptVccVcdFwdFrameDiscard=mscAtmIfVptVccVcdFwdFrameDiscard, mscAtmIfVccTmRxTdpValue=mscAtmIfVccTmRxTdpValue, mscAtmIfVccVcdUsageParameterControl=mscAtmIfVccVcdUsageParameterControl, mscAtmIfVptVccTmAbrAcrRateChangeInfo=mscAtmIfVptVccTmAbrAcrRateChangeInfo, mscAtmIfVccVcdTxTdpEntry=mscAtmIfVccVcdTxTdpEntry, mscAtmIfVccLastCtdSampleSize=mscAtmIfVccLastCtdSampleSize, mscAtmIfTxCellMemoryThresholdIndex=mscAtmIfTxCellMemoryThresholdIndex, mscAtmIfVccTmAbrCutoffDecreaseFactor=mscAtmIfVccTmAbrCutoffDecreaseFactor, mscAtmIfVpcTmBandwidthElastic=mscAtmIfVpcTmBandwidthElastic, mscAtmIfVptVccSegLinkSideLoopbackState=mscAtmIfVptVccSegLinkSideLoopbackState, mscAtmIfVptVccTestStateTable=mscAtmIfVptVccTestStateTable, mscAtmIfVptCAUbr=mscAtmIfVptCAUbr, mscAtmIfVccSegSwitchSideLoopbackState=mscAtmIfVccSegSwitchSideLoopbackState, mscAtmIfVptVccVcdPm=mscAtmIfVptVccVcdPm, mscAtmIfVptVpdTmAbrInitialCellRate=mscAtmIfVptVpdTmAbrInitialCellRate, mscAtmIfVptFqpEntry=mscAtmIfVptFqpEntry, mscAtmIfVptCAPoolAvailBwTable=mscAtmIfVptCAPoolAvailBwTable, mscAtmIfVpcVpdRxTdpEntry=mscAtmIfVpcVpdRxTdpEntry, mscAtmIfVccTmIndex=mscAtmIfVccTmIndex, mscAtmIfVccVcdRxTdpTable=mscAtmIfVccVcdRxTdpTable, mscAtmIfVpcPmArTotalTime=mscAtmIfVpcPmArTotalTime, mscAtmIfVptVpdTmAbrMaxTimeBetweenRmCells=mscAtmIfVptVpdTmAbrMaxTimeBetweenRmCells, mscAtmIfVptRxDiscard=mscAtmIfVptRxDiscard, mscAtmIfEndToEndLoopback=mscAtmIfEndToEndLoopback, mscAtmIfVccVcdTmAbrRateIncreaseFactor=mscAtmIfVccVcdTmAbrRateIncreaseFactor, mscAtmIfCAUbrMaxVpcs=mscAtmIfCAUbrMaxVpcs, mscAtmIfVpcTmTxQThreshValue=mscAtmIfVpcTmTxQThreshValue, mscAtmIfRxCellDiscard=mscAtmIfRxCellDiscard, mscAtmIfVptTxQThreshTable=mscAtmIfVptTxQThreshTable, mscAtmIfVptVccVcdTmAbr=mscAtmIfVptVccVcdTmAbr, mscAtmIfVptVpdHoldingPriority=mscAtmIfVptVpdHoldingPriority, mscAtmIfVptVpdTmBestEffort=mscAtmIfVptVpdTmBestEffort, mscAtmIfVpcStatsTxCell=mscAtmIfVpcStatsTxCell, mscAtmIfVptVccStatsRxCell=mscAtmIfVptVccStatsRxCell, mscAtmIfVptVccTmOperTable=mscAtmIfVptVccTmOperTable, mscAtmIfVptTxQThreshValue=mscAtmIfVptTxQThreshValue, mscAtmIfVptVccTmClippingBbc=mscAtmIfVptVccTmClippingBbc, mscAtmIfVccVcdPmStorageType=mscAtmIfVccVcdPmStorageType, mscAtmIfVccTmAbrRateIncreaseFactor=mscAtmIfVccTmAbrRateIncreaseFactor, mscAtmIfCAMinAutoSelectedVciForNonZeroVpi=mscAtmIfCAMinAutoSelectedVciForNonZeroVpi, mscAtmIfVptVccStatusEntry=mscAtmIfVptVccStatusEntry, mscAtmIfCAAbr=mscAtmIfCAAbr, mscAtmIfVccStatsRxUpcViolationOnEnforcer2=mscAtmIfVccStatsRxUpcViolationOnEnforcer2, mscAtmIfShapeUsageTable=mscAtmIfShapeUsageTable, mscAtmIfVccTmAbrRxEfci=mscAtmIfVccTmAbrRxEfci, mscAtmIfVptVccComponentName=mscAtmIfVptVccComponentName, mscAtmIfVptVccBqpValue=mscAtmIfVptVccBqpValue, mscAtmIfCAUbrUnshapedTransmitQueueing=mscAtmIfCAUbrUnshapedTransmitQueueing, mscAtmIfCANrtVbrCdvt=mscAtmIfCANrtVbrCdvt, mscAtmIfVccVcdTmProvEntry=mscAtmIfVccVcdTmProvEntry, mscAtmIfCAPermittedSvcAtmServiceCategories=mscAtmIfCAPermittedSvcAtmServiceCategories, mscAtmIfVptUsageState=mscAtmIfVptUsageState, mscAtmIfVpcRxDiscard=mscAtmIfVpcRxDiscard, mscAtmIfVccTmRxTdpIndex=mscAtmIfVccTmRxTdpIndex, mscAtmIfVccPmStorageType=mscAtmIfVccPmStorageType)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfVpcPmBwdPmCellDiscardCount=mscAtmIfVpcPmBwdPmCellDiscardCount, mscAtmIfVptVccVcdTmClippingBbc=mscAtmIfVptVccVcdTmClippingBbc, mscAtmIfVptTmAbrRxEfci=mscAtmIfVptTmAbrRxEfci, mscAtmIfVpcTmTqpTable=mscAtmIfVpcTmTqpTable, mscAtmIfVptTroubled=mscAtmIfVptTroubled, mscAtmIfVptVccVcdTmRowStatus=mscAtmIfVptVccVcdTmRowStatus, mscAtmIfVptVpdTmAtmServiceCategory=mscAtmIfVptVpdTmAtmServiceCategory, mscAtmIfVccVcdTmAbrDgcraMinimumDelay=mscAtmIfVccVcdTmAbrDgcraMinimumDelay, mscAtmIfVptVccVcdPmProvEntry=mscAtmIfVptVccVcdPmProvEntry, mscAtmIfVptVccVcdTmIndex=mscAtmIfVptVccVcdTmIndex, mscAtmIfVccVcdTmTxTdpTable=mscAtmIfVccVcdTmTxTdpTable, mscAtmIfRxLinkUtilization=mscAtmIfRxLinkUtilization, mscAtmIfVpcVpdTmAbrDgcraMaximumDelay=mscAtmIfVpcVpdTmAbrDgcraMaximumDelay, mscAtmIfVccVcdTmAbrTransientBufferExposure=mscAtmIfVccVcdTmAbrTransientBufferExposure, mscAtmIfMaxVpcs=mscAtmIfMaxVpcs, mscAtmIfType=mscAtmIfType, mscAtmIfVpcTmAbrAcrRateChangeInfo=mscAtmIfVpcTmAbrAcrRateChangeInfo, mscAtmIfVccConnInfoTable=mscAtmIfVccConnInfoTable, mscAtmIfVptVccVcdRowStatusTable=mscAtmIfVptVccVcdRowStatusTable, mscAtmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor=mscAtmIfVpcVpdTmAbrFarEndAcrDecreaseTimeFactor, mscAtmIfCASwitchedVpcs=mscAtmIfCASwitchedVpcs, mscAtmIfVptVccVcdBqpValue=mscAtmIfVptVccVcdBqpValue, mscAtmIfVptVccTmWeight=mscAtmIfVptVccTmWeight, mscAtmIfVpcPmFwdClrEntry=mscAtmIfVpcPmFwdClrEntry, mscAtmIfVpcVpdFwdQosClass=mscAtmIfVpcVpdFwdQosClass, mscAtmIfVptVccVcdPmRowStatus=mscAtmIfVptVccVcdPmRowStatus, mscAtmIfVpcStatsTxCellDiscardClp=mscAtmIfVpcStatsTxCellDiscardClp, mscAtmIfVccTxQosClass=mscAtmIfVccTxQosClass, mscAtmIfVptCABwPoolTable=mscAtmIfVptCABwPoolTable, mscAtmIfCAPermittedAtmServiceCategories=mscAtmIfCAPermittedAtmServiceCategories, mscAtmIfVpcPmBwdTotalClrInterval=mscAtmIfVpcPmBwdTotalClrInterval, mscAtmIfVpcVpdAcctTable=mscAtmIfVpcVpdAcctTable, mscAtmIfVpcPmBwdMaximumClr01=mscAtmIfVpcPmBwdMaximumClr01, mscAtmIfVccTmTxTdpTable=mscAtmIfVccTmTxTdpTable, mscAtmIfCANrtVbrPerVcQueueLimitReferenceRate=mscAtmIfCANrtVbrPerVcQueueLimitReferenceRate, mscAtmIfVccPmFwdAverageClr01=mscAtmIfVccPmFwdAverageClr01, mscAtmIfVptVccVcdTmAbrStorageType=mscAtmIfVptVccVcdTmAbrStorageType, mscAtmIfVpcVpdTmAbrRowStatus=mscAtmIfVpcVpdTmAbrRowStatus, mscAtmIfCAVbrNrtCellLossRatio=mscAtmIfCAVbrNrtCellLossRatio, mscAtmIfVccStatsTxCell=mscAtmIfVccStatsTxCell, mscAtmIfVpcVpdTmAbrIndex=mscAtmIfVpcVpdTmAbrIndex, mscAtmIfVptVpdTmAbrDgcraMinimumDelay=mscAtmIfVptVpdTmAbrDgcraMinimumDelay, mscAtmIfCAPoolProvBwTable=mscAtmIfCAPoolProvBwTable, mscAtmIfConnMapOvComponentName=mscAtmIfConnMapOvComponentName, mscAtmIfVpcVpdTmAbrTransientBufferExposure=mscAtmIfVpcVpdTmAbrTransientBufferExposure, mscAtmIfVptVccTestStorageType=mscAtmIfVptVccTestStorageType, mscAtmIfVpcVpdTmBqpValue=mscAtmIfVpcVpdTmBqpValue, mscAtmIfVptVpdRxTdpTable=mscAtmIfVptVpdRxTdpTable, mscAtmIfVptTmAbrIndex=mscAtmIfVptTmAbrIndex, mscAtmIfVpcVpdPmRowStatusTable=mscAtmIfVpcVpdPmRowStatusTable, mscAtmIfVpcPmBwdTotalUserCellsTx01=mscAtmIfVpcPmBwdTotalUserCellsTx01, mscAtmIfVpcVpdPmProvTable=mscAtmIfVpcVpdPmProvTable, mscAtmIfVptVccStatusTable=mscAtmIfVptVccStatusTable, mscAtmIfVccTxTrafficDescType=mscAtmIfVccTxTrafficDescType, mscAtmIfVccTmRowStatusTable=mscAtmIfVccTmRowStatusTable, mscAtmIfCASvcVbrNrtHoldingPriority=mscAtmIfCASvcVbrNrtHoldingPriority, mscAtmIfCAPoolAvailableBwTable=mscAtmIfCAPoolAvailableBwTable, mscAtmIfVptVccTm=mscAtmIfVptVccTm, mscAtmIfVptVccTmHoldingPriority=mscAtmIfVptVccTmHoldingPriority, mscAtmIfVptVccTmAbrStorageType=mscAtmIfVptVccTmAbrStorageType, mscAtmIfVptVpdRxTdpValue=mscAtmIfVptVpdRxTdpValue, mscAtmIfCAPoolAvailBwEntry=mscAtmIfCAPoolAvailBwEntry, mscAtmIfVccVcdTmRxTdpTable=mscAtmIfVccVcdTmRxTdpTable, mscAtmIfVptVccVcdFqpTable=mscAtmIfVptVccVcdFqpTable, mscAtmIfVptCACbrStorageType=mscAtmIfVptCACbrStorageType, mscAtmIfVptTxTdpIndex=mscAtmIfVptTxTdpIndex, mscAtmIfVptVccRowStatusTable=mscAtmIfVptVccRowStatusTable, mscAtmIfVptVccOperEntry=mscAtmIfVptVccOperEntry, mscAtmIfCAAbrProvTable=mscAtmIfCAAbrProvTable, mscAtmIfVpcTmRqpTable=mscAtmIfVpcTmRqpTable, mscAtmIfVccVcdMCastConnectionType=mscAtmIfVccVcdMCastConnectionType, mscAtmIfVptBqpEntry=mscAtmIfVptBqpEntry, mscAtmIfVccPm=mscAtmIfVccPm, mscAtmIfVccTmRxTdpEntry=mscAtmIfVccTmRxTdpEntry, mscAtmIfVptCARtVbrProvTable=mscAtmIfVptCARtVbrProvTable, mscAtmIfVptVccTmAtmServiceCategory=mscAtmIfVptVccTmAtmServiceCategory, mscAtmIfVptVpd=mscAtmIfVptVpd, mscAtmIfVccStatsTxCellClp=mscAtmIfVccStatsTxCellClp, mscAtmIfCAPoolAvailableBwValue=mscAtmIfCAPoolAvailableBwValue, mscAtmIfVccTmClippingBbc=mscAtmIfVccTmClippingBbc, mscAtmIfVptVccVcdRxQosClass=mscAtmIfVptVccVcdRxQosClass, mscAtmIfVptTmTxQueueLength=mscAtmIfVptTmTxQueueLength, mscAtmIfVccVcdRowStatus=mscAtmIfVccVcdRowStatus, mscAtmIfVptVccTmAbrInitialCellRate=mscAtmIfVptVccTmAbrInitialCellRate, mscAtmIfCANrtVbr=mscAtmIfCANrtVbr, mscAtmIfCAAbrInitialCellRate=mscAtmIfCAAbrInitialCellRate, mscAtmIfVptVccNepStorageType=mscAtmIfVptVccNepStorageType, mscAtmIfVpcTmTxTrafficDescType=mscAtmIfVpcTmTxTrafficDescType, mscAtmIfVptVccBqpIndex=mscAtmIfVptVccBqpIndex, mscAtmIfCARtVbrPerVcQueueLimitReferenceRate=mscAtmIfCARtVbrPerVcQueueLimitReferenceRate, mscAtmIfVptVccStatsRxAal5FrameAbort=mscAtmIfVptVccStatsRxAal5FrameAbort, mscAtmIfVpcTrafficEntry=mscAtmIfVpcTrafficEntry, mscAtmIfVpcStateEntry=mscAtmIfVpcStateEntry, mscAtmIfVpcLastMaximumCtd=mscAtmIfVpcLastMaximumCtd, mscAtmIfVptCAPoolAvailBwIndex=mscAtmIfVptCAPoolAvailBwIndex, mscAtmIfVptVccTmAbrRxEfci=mscAtmIfVptVccTmAbrRxEfci, mscAtmIfVccTestTimeRemaining=mscAtmIfVccTestTimeRemaining, mscAtmIfCARtVbrPool=mscAtmIfCARtVbrPool, mscAtmIfVpcVpdTmProvEntry=mscAtmIfVpcVpdTmProvEntry, mscAtmIfVpcVpdSegLinkSideLoopback=mscAtmIfVpcVpdSegLinkSideLoopback, mscAtmIfVptVccBestEffort=mscAtmIfVptVccBestEffort, mscAtmIfVptVccStorageType=mscAtmIfVptVccStorageType, mscAtmIfVptVccRxTdpValue=mscAtmIfVptVccRxTdpValue, mscAtmIfVccTmAbrForwardRmCellLimit=mscAtmIfVccTmAbrForwardRmCellLimit, mscAtmIfVptStatsEntry=mscAtmIfVptStatsEntry, mscAtmIfCAMaxAutoSelectedVpi=mscAtmIfCAMaxAutoSelectedVpi, mscAtmIfVptVpdTmStorageType=mscAtmIfVptVpdTmStorageType, mscAtmIfVptTmForceTagging=mscAtmIfVptTmForceTagging, mscAtmIfVptVccClippingBbc=mscAtmIfVptVccClippingBbc, mscAtmIfVccVcdFqpEntry=mscAtmIfVccVcdFqpEntry, mscAtmIfVptVpdTmTrafficShaping=mscAtmIfVptVpdTmTrafficShaping, mscAtmIfVpcVpdTmTransferCapabilityBbc=mscAtmIfVpcVpdTmTransferCapabilityBbc, mscAtmIfVccVcdTmUnshapedTransmitQueueing=mscAtmIfVccVcdTmUnshapedTransmitQueueing, mscAtmIfVptVpdSegSwitchSideLoopback=mscAtmIfVptVpdSegSwitchSideLoopback, mscAtmIfLastAal5RxAbortConnection=mscAtmIfLastAal5RxAbortConnection, mscAtmIfVptCAAbrRowStatus=mscAtmIfVptCAAbrRowStatus, mscAtmIfVccTestUnrecognizableFrmRx=mscAtmIfVccTestUnrecognizableFrmRx, mscAtmIfVccTmComponentName=mscAtmIfVccTmComponentName, mscAtmIfConnMapOvProvTable=mscAtmIfConnMapOvProvTable, mscAtmIfVccTestBytesTx=mscAtmIfVccTestBytesTx, mscAtmIfVptVpdFwdFrameDiscard=mscAtmIfVptVpdFwdFrameDiscard, mscAtmIfVccPmFwdLastSampleUserCellsRx0=mscAtmIfVccPmFwdLastSampleUserCellsRx0, mscAtmIfVptVccVcdTmBqpValue=mscAtmIfVptVccVcdTmBqpValue, mscAtmIfVptVccTestFrmTypes=mscAtmIfVptVccTestFrmTypes, mscAtmIfVptVccTmAbrFixedRoundTripTime=mscAtmIfVptVccTmAbrFixedRoundTripTime, mscAtmIfVccVcdTxTdpIndex=mscAtmIfVccVcdTxTdpIndex, mscAtmIfVccTmBestEffort=mscAtmIfVccTmBestEffort, mscAtmIfVpcTmAbrCutoffDecreaseFactor=mscAtmIfVpcTmAbrCutoffDecreaseFactor, mscAtmIfRxFrameDiscardClp=mscAtmIfRxFrameDiscardClp, mscAtmIfVccVcdTmAbrMaxCellPerRmCell=mscAtmIfVccVcdTmAbrMaxCellPerRmCell, mscAtmIfCAPoolProvBwIndex=mscAtmIfCAPoolProvBwIndex, mscAtmIfVpcFqpValue=mscAtmIfVpcFqpValue, mscAtmIfVptTmTxQThreshEntry=mscAtmIfVptTmTxQThreshEntry, mscAtmIfVptTmAbrStorageType=mscAtmIfVptTmAbrStorageType, mscAtmIfVptCAAbrProvEntry=mscAtmIfVptCAAbrProvEntry, mscAtmIfVptVccVcdTxTrafficDescType=mscAtmIfVptVccVcdTxTrafficDescType, mscAtmIfVptTmBandwidthReduction=mscAtmIfVptTmBandwidthReduction, mscAtmIfCAUbrIndex=mscAtmIfCAUbrIndex, mscAtmIfVptEndToEndLoopbackState=mscAtmIfVptEndToEndLoopbackState, mscAtmIfVptVccTestResultsEntry=mscAtmIfVptVccTestResultsEntry, mscAtmIfVccLastMaximumCtd=mscAtmIfVccLastMaximumCtd, mscAtmIfVpcStatsRxUpcViolationOnEnforcer2=mscAtmIfVpcStatsRxUpcViolationOnEnforcer2, atmCoreCapabilitiesCB=atmCoreCapabilitiesCB, mscAtmIfVptVccTestStateEntry=mscAtmIfVptVccTestStateEntry, mscAtmIfVpcVpdTxTdpIndex=mscAtmIfVpcVpdTxTdpIndex, mscAtmIfVptVpdTmProvEntry=mscAtmIfVptVpdTmProvEntry, mscAtmIfVptRxTdpEntry=mscAtmIfVptRxTdpEntry, mscAtmIfVptVccFwdQosClass=mscAtmIfVptVccFwdQosClass, mscAtmIfVptVpdTmRxTrafficDescType=mscAtmIfVptVpdTmRxTrafficDescType, mscAtmIfVptTmBearerClassBbc=mscAtmIfVptTmBearerClassBbc, mscAtmIfVptTmAbrConnectionType=mscAtmIfVptTmAbrConnectionType, mscAtmIfCAUbrRowStatusEntry=mscAtmIfCAUbrRowStatusEntry, mscAtmIfVpcTmAbrStorageType=mscAtmIfVpcTmAbrStorageType, mscAtmIfVccVcdAtmServiceCategory=mscAtmIfVccVcdAtmServiceCategory, mscAtmIfVptVccTestCauseOfTermination=mscAtmIfVptVccTestCauseOfTermination, mscAtmIfVpcVpdTmForceTagging=mscAtmIfVpcVpdTmForceTagging, mscAtmIfVpcPmFwdMinimumClr01=mscAtmIfVpcPmFwdMinimumClr01, mscAtmIfVpcBqpTable=mscAtmIfVpcBqpTable, mscAtmIfCAAbrFrttPortion=mscAtmIfCAAbrFrttPortion, mscAtmIfCAAbrOperTable=mscAtmIfCAAbrOperTable, mscAtmIfVccPmRowStatusEntry=mscAtmIfVccPmRowStatusEntry, mscAtmIfCAAbrHoldingPriority=mscAtmIfCAAbrHoldingPriority, mscAtmIfVptVccTmUsageParameterControl=mscAtmIfVptVccTmUsageParameterControl, mscAtmIfVptVpdTmTxPacketWiseDiscard=mscAtmIfVptVpdTmTxPacketWiseDiscard, mscAtmIfVptVccVcdTmAbrCutoffDecreaseFactor=mscAtmIfVptVccVcdTmAbrCutoffDecreaseFactor, mscAtmIfVptVccTestUsageState=mscAtmIfVptVccTestUsageState, mscAtmIfVptCANrtVbr=mscAtmIfVptCANrtVbr, mscAtmIfVpcLoopIndex=mscAtmIfVpcLoopIndex, mscAtmIfVccPmFwdLastSampleUserCellsTx01=mscAtmIfVccPmFwdLastSampleUserCellsTx01, mscAtmIfConnMapOvNumNonZeroVpisForVccs=mscAtmIfConnMapOvNumNonZeroVpisForVccs, mscAtmIfVccVcdFqpTable=mscAtmIfVccVcdFqpTable, mscAtmIfVptCAPoolAdmConnsValue=mscAtmIfVptCAPoolAdmConnsValue, mscAtmIfTxCellDiscardClp=mscAtmIfTxCellDiscardClp, mscAtmIfVptVccVcdTmTxTdpTable=mscAtmIfVptVccVcdTmTxTdpTable, mscAtmIfVptTmTxPacketWiseDiscard=mscAtmIfVptTmTxPacketWiseDiscard, mscAtmIfVptTmTransferCapabilityBbc=mscAtmIfVptTmTransferCapabilityBbc, mscAtmIfTxCellMemoryAvailable=mscAtmIfTxCellMemoryAvailable, mscAtmIfVccTestSetupTable=mscAtmIfVccTestSetupTable, mscAtmIfConnMapOvProvEntry=mscAtmIfConnMapOvProvEntry, mscAtmIfVccPmFwdLastSampleUserCellsTx0=mscAtmIfVccPmFwdLastSampleUserCellsTx0, mscAtmIfVptVccTmBandwidthReduction=mscAtmIfVptVccTmBandwidthReduction, mscAtmIfVptCAPoolProvBwIndex=mscAtmIfVptCAPoolProvBwIndex, mscAtmIfVptCAUbrRowStatus=mscAtmIfVptCAUbrRowStatus, mscAtmIfVptVpdBwdFrameDiscard=mscAtmIfVptVpdBwdFrameDiscard, mscAtmIfCAUbrRowStatusTable=mscAtmIfCAUbrRowStatusTable, mscAtmIfVptCAPoolAdmConnsIndex=mscAtmIfVptCAPoolAdmConnsIndex, mscAtmIfVptVpdTmAbrConnectionType=mscAtmIfVptVpdTmAbrConnectionType, mscAtmIfCAPoolAvailBwTable=mscAtmIfCAPoolAvailBwTable, mscAtmIfCAAbrRowStatusTable=mscAtmIfCAAbrRowStatusTable, mscAtmIfVpcPmComponentName=mscAtmIfVpcPmComponentName, mscAtmIfVccVcdTmAbrStorageType=mscAtmIfVccVcdTmAbrStorageType, mscAtmIfVptCARtVbrMaxCtd=mscAtmIfVptCARtVbrMaxCtd, mscAtmIfVpcTmTxQueueCongestionState=mscAtmIfVpcTmTxQueueCongestionState, mscAtmIfCARtVbrTxQueueLimit=mscAtmIfCARtVbrTxQueueLimit, mscAtmIfVccPmBwdLastSampleClr01=mscAtmIfVccPmBwdLastSampleClr01, mscAtmIfVpcHoldingPriority=mscAtmIfVpcHoldingPriority, mscAtmIfVpcVpd=mscAtmIfVpcVpd, mscAtmIfVptFqpIndex=mscAtmIfVptFqpIndex, mscAtmIfCACbrSvcMpHoldingPriority=mscAtmIfCACbrSvcMpHoldingPriority, mscAtmIfCACbrHoldingPriority=mscAtmIfCACbrHoldingPriority, mscAtmIfVptTmRxTdpValue=mscAtmIfVptTmRxTdpValue, mscAtmIfVptVccVcdRxTdpValue=mscAtmIfVptVccVcdRxTdpValue, mscAtmIfCARowStatusEntry=mscAtmIfCARowStatusEntry, mscAtmIfVccVcdRxTdpEntry=mscAtmIfVccVcdRxTdpEntry, mscAtmIfVptVccVcdMCastConnectionType=mscAtmIfVptVccVcdMCastConnectionType, mscAtmIfVccVcdTmRxTrafficDescType=mscAtmIfVccVcdTmRxTrafficDescType, mscAtmIfVccTmTxQThreshEntry=mscAtmIfVccTmTxQThreshEntry, mscAtmIfVptVccFqpIndex=mscAtmIfVptVccFqpIndex, mscAtmIfVpcVpdPmSegSwitchSideMeasurement=mscAtmIfVpcVpdPmSegSwitchSideMeasurement, mscAtmIfVccTmTqpEntry=mscAtmIfVccTmTqpEntry, mscAtmIfNAcct=mscAtmIfNAcct, mscAtmIfVptCAPermittedAtmServiceCategories=mscAtmIfVptCAPermittedAtmServiceCategories, mscAtmIfVpcTmTxTdpTable=mscAtmIfVpcTmTxTdpTable, mscAtmIfVccTmAbrRateDecreaseFactor=mscAtmIfVccTmAbrRateDecreaseFactor, mscAtmIfVptVccLoopRowStatusTable=mscAtmIfVptVccLoopRowStatusTable, mscAtmIfCARowStatus=mscAtmIfCARowStatus, mscAtmIfVptVpdTmFqpIndex=mscAtmIfVptVpdTmFqpIndex, mscAtmIfStorageType=mscAtmIfStorageType, mscAtmIfVpcTmRxTdpValue=mscAtmIfVpcTmRxTdpValue, mscAtmIfVptStateEntry=mscAtmIfVptStateEntry, mscAtmIfVpcTmTransferCapabilityBbc=mscAtmIfVpcTmTransferCapabilityBbc, mscAtmIfVccStatsTable=mscAtmIfVccStatsTable, mscAtmIfVpcTmTqpEntry=mscAtmIfVpcTmTqpEntry, mscAtmIfVccStatsTxFrameDiscardClp=mscAtmIfVccStatsTxFrameDiscardClp, mscAtmIfVptStatsRxUpcViolationOnEnforcer2=mscAtmIfVptStatsRxUpcViolationOnEnforcer2, mscAtmIfCidDataTable=mscAtmIfCidDataTable, mscAtmIfVccRxTrafficDescType=mscAtmIfVccRxTrafficDescType, mscAtmIfVccPmCurrentAvailabilityStatus=mscAtmIfVccPmCurrentAvailabilityStatus, mscAtmIfNAcctAccountCollection=mscAtmIfNAcctAccountCollection, mscAtmIfVccVcdAcctTable=mscAtmIfVccVcdAcctTable, mscAtmIfVpcPmFwdLastSampleUserCellsTx01=mscAtmIfVpcPmFwdLastSampleUserCellsTx01, mscAtmIfCACbrUsageParameterControl=mscAtmIfCACbrUsageParameterControl, mscAtmIfVcc=mscAtmIfVcc, mscAtmIfVptCACbr=mscAtmIfVptCACbr, mscAtmIfVptVccUsageParameterControl=mscAtmIfVptVccUsageParameterControl, mscAtmIfCAPoolAdmitBwIndex=mscAtmIfCAPoolAdmitBwIndex, mscAtmIfTxCellClp=mscAtmIfTxCellClp, mscAtmIfVptConnectionPointType=mscAtmIfVptConnectionPointType, mscAtmIfVptVccRxFrameDiscard=mscAtmIfVptVccRxFrameDiscard, mscAtmIfVpcVpdTmAbrRateIncreaseFactor=mscAtmIfVpcVpdTmAbrRateIncreaseFactor, mscAtmIfPmProvEntry=mscAtmIfPmProvEntry, mscAtmIfVptVccVcdTmAbrRowStatusEntry=mscAtmIfVptVccVcdTmAbrRowStatusEntry, mscAtmIfVptCABwPoolEntry=mscAtmIfVptCABwPoolEntry, mscAtmIfVptVccTxTdpValue=mscAtmIfVptVccTxTdpValue, mscAtmIfVpcVpdClippingBbc=mscAtmIfVpcVpdClippingBbc, mscAtmIfRemoteAtmInterfaceLabel=mscAtmIfRemoteAtmInterfaceLabel, mscAtmIfVpcVpdPm=mscAtmIfVpcVpdPm, mscAtmIfVpcFwdQosClass=mscAtmIfVpcFwdQosClass, mscAtmIfVptVccVcdTmBqpTable=mscAtmIfVptVccVcdTmBqpTable, mscAtmIfVptCAUbrMinimumCellRate=mscAtmIfVptCAUbrMinimumCellRate, mscAtmIfVccBandwidthElastic=mscAtmIfVccBandwidthElastic, mscAtmIfVccVcdRxQosClass=mscAtmIfVccVcdRxQosClass, mscAtmIfCAComponentName=mscAtmIfCAComponentName, mscAtmIfVptCACbrComponentName=mscAtmIfVptCACbrComponentName)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-AtmCoreMIB", mscAtmIfVptVccVcdTmRxTdpEntry=mscAtmIfVptVccVcdTmRxTdpEntry, mscAtmIfVptVpdLbkEntry=mscAtmIfVptVpdLbkEntry, mscAtmIfVptVccVcdTmTransferCapabilityBbc=mscAtmIfVptVccVcdTmTransferCapabilityBbc, mscAtmIfVptTxTrafficDescType=mscAtmIfVptTxTrafficDescType, mscAtmIfRowStatusTable=mscAtmIfRowStatusTable, mscAtmIfVptVpdTmAbr=mscAtmIfVptVpdTmAbr, mscAtmIfVptVccCallDirection=mscAtmIfVptVccCallDirection, mscAtmIfVptVccTestComponentName=mscAtmIfVptVccTestComponentName, mscAtmIfVptTxQThreshIndex=mscAtmIfVptTxQThreshIndex, mscAtmIfVccVcdTmStorageType=mscAtmIfVccVcdTmStorageType, mscAtmIfVccTestSetupEntry=mscAtmIfVccTestSetupEntry, mscAtmIfVptTmHoldingPriority=mscAtmIfVptTmHoldingPriority, mscAtmIfVptStatsRxCellDiscard=mscAtmIfVptStatsRxCellDiscard, mscAtmIfVptCANrtVbrPool=mscAtmIfVptCANrtVbrPool, mscAtmIfVpcPmBwdLastSampleUserCellsRx0=mscAtmIfVpcPmBwdLastSampleUserCellsRx0, mscAtmIfVpcVpdUsageParameterControl=mscAtmIfVpcVpdUsageParameterControl, mscAtmIfPmRowStatus=mscAtmIfPmRowStatus, mscAtmIfConnMapFirstNonZeroVpiForVccsOper=mscAtmIfConnMapFirstNonZeroVpiForVccsOper, mscAtmIfVptVccTestFrmSize=mscAtmIfVptVccTestFrmSize, mscAtmIfVccPmBwdTotalUserCellsTx0=mscAtmIfVccPmBwdTotalUserCellsTx0, mscAtmIfVptTmTxTdpEntry=mscAtmIfVptTmTxTdpEntry, mscAtmIfVccTestAdminState=mscAtmIfVccTestAdminState, mscAtmIfVccVcdTxTdpTable=mscAtmIfVccVcdTxTdpTable, mscAtmIfVpcVpdRowStatusEntry=mscAtmIfVpcVpdRowStatusEntry, mscAtmIfVpcVpdTmRowStatusEntry=mscAtmIfVpcVpdTmRowStatusEntry, mscAtmIfVccTestFrmSize=mscAtmIfVccTestFrmSize, mscAtmIfVccPmBwdMinimumClr01=mscAtmIfVccPmBwdMinimumClr01, mscAtmIfVpcVpdAtmServiceCategory=mscAtmIfVpcVpdAtmServiceCategory, mscAtmIfVccVcdFqpValue=mscAtmIfVccVcdFqpValue, mscAtmIfVptVccStatsRxAal5FrameError=mscAtmIfVptVccStatsRxAal5FrameError, mscAtmIfVptVccTmAbrRateDecreaseFactor=mscAtmIfVptVccTmAbrRateDecreaseFactor, mscAtmIfVptVpdAtmServiceCategory=mscAtmIfVptVpdAtmServiceCategory, mscAtmIfVptCAUbrComponentName=mscAtmIfVptCAUbrComponentName, mscAtmIfVptStatsRxAal5FrameAbort=mscAtmIfVptStatsRxAal5FrameAbort, mscAtmIfVccTxQueueLength=mscAtmIfVccTxQueueLength, mscAtmIfVptVccStatsRxUpcViolationOnEnforcer1=mscAtmIfVptVccStatsRxUpcViolationOnEnforcer1, mscAtmIfCAPoolAdmitBwEntry=mscAtmIfCAPoolAdmitBwEntry, mscAtmIfVptVccTmBearerClassBbc=mscAtmIfVptVccTmBearerClassBbc, mscAtmIfCAAbrStorageType=mscAtmIfCAAbrStorageType, mscAtmIfVptVccTestOverrideHoldingPriority=mscAtmIfVptVccTestOverrideHoldingPriority, mscAtmIfVptVccTmRxPacketWiseDiscard=mscAtmIfVptVccTmRxPacketWiseDiscard, mscAtmIfVptClippingBbc=mscAtmIfVptClippingBbc, mscAtmIfVptTmTqpIndex=mscAtmIfVptTmTqpIndex, mscAtmIfVptVccVcdUsageParameterControl=mscAtmIfVptVccVcdUsageParameterControl, mscAtmIfVccTmTqpValue=mscAtmIfVccTmTqpValue, mscAtmIfCACbrEmissionPriority=mscAtmIfCACbrEmissionPriority, mscAtmIfConnMapOvRowStatusEntry=mscAtmIfConnMapOvRowStatusEntry, mscAtmIfVpcStatsRxAal5FrameError=mscAtmIfVpcStatsRxAal5FrameError, mscAtmIfCACbrProvClr=mscAtmIfCACbrProvClr, mscAtmIfVptTm=mscAtmIfVptTm, mscAtmIfVccPmBwdTotalUserCellsRx0=mscAtmIfVccPmBwdTotalUserCellsRx0, mscAtmIfVptStatsRxCellClp=mscAtmIfVptStatsRxCellClp, mscAtmIfVpcTmTrafficShaping=mscAtmIfVpcTmTrafficShaping, mscAtmIfVptVccRxDiscard=mscAtmIfVptVccRxDiscard, mscAtmIfVptVccTmTxQThreshValue=mscAtmIfVptVccTmTxQThreshValue, mscAtmIfVptAdminState=mscAtmIfVptAdminState, mscAtmIfVptTmAbrTransientBufferExposure=mscAtmIfVptTmAbrTransientBufferExposure, mscAtmIfTransmittedCells=mscAtmIfTransmittedCells, mscAtmIfVccTestIndex=mscAtmIfVccTestIndex, mscAtmIfVccAdminState=mscAtmIfVccAdminState, mscAtmIfVptStatusEntry=mscAtmIfVptStatusEntry, mscAtmIfVpcVpdTm=mscAtmIfVpcVpdTm, mscAtmIfVptVccStateEntry=mscAtmIfVptVccStateEntry, mscAtmIfVptCAPoolProvBwValue=mscAtmIfVptCAPoolProvBwValue, mscAtmIfOpShapingRatesTable=mscAtmIfOpShapingRatesTable, mscAtmIfVptCARtVbrRowStatusEntry=mscAtmIfVptCARtVbrRowStatusEntry, mscAtmIfVccVcdComponentName=mscAtmIfVccVcdComponentName, mscAtmIfCAAbrRowStatusEntry=mscAtmIfCAAbrRowStatusEntry, mscAtmIfVptRxOamCellCongestionState=mscAtmIfVptRxOamCellCongestionState, mscAtmIfVptVccVcdTmRxTdpIndex=mscAtmIfVptVccVcdTmRxTdpIndex, mscAtmIfVccVcdTrafficShaping=mscAtmIfVccVcdTrafficShaping, mscAtmIfVccOperTable=mscAtmIfVccOperTable, mscAtmIfVptRxFrameDiscard=mscAtmIfVptRxFrameDiscard, mscAtmIfVpcStatsRxCell=mscAtmIfVpcStatsRxCell, mscAtmIfVptVccVcdSegSwitchSideLoopback=mscAtmIfVptVccVcdSegSwitchSideLoopback, mscAtmIfNAcctAccountClass=mscAtmIfNAcctAccountClass, mscAtmIfVpcTxFrameDiscard=mscAtmIfVpcTxFrameDiscard, mscAtmIfVptVccTmRxTdpIndex=mscAtmIfVptVccTmRxTdpIndex, mscAtmIfVptVccLocalFailureCause=mscAtmIfVptVccLocalFailureCause, mscAtmIfVpcSegSwitchSideLoopbackState=mscAtmIfVpcSegSwitchSideLoopbackState, mscAtmIfCAUbrVptUsage=mscAtmIfCAUbrVptUsage, mscAtmIfVccTmBandwidthElastic=mscAtmIfVccTmBandwidthElastic, mscAtmIfCAUbrRowStatus=mscAtmIfCAUbrRowStatus, mscAtmIfVptCARtVbrStorageType=mscAtmIfVptCARtVbrStorageType, mscAtmIfVptVpdAcctEntry=mscAtmIfVptVpdAcctEntry, mscAtmIfVptVpdMCastConnectionType=mscAtmIfVptVpdMCastConnectionType, mscAtmIfVptTmBandwidthElastic=mscAtmIfVptTmBandwidthElastic, mscAtmIfVptVccTmAbrRowStatusTable=mscAtmIfVptVccTmAbrRowStatusTable, mscAtmIfVptVccVcdAcctTable=mscAtmIfVptVccVcdAcctTable, mscAtmIfVptCANrtVbrRowStatusEntry=mscAtmIfVptCANrtVbrRowStatusEntry, mscAtmIfCAProvTable=mscAtmIfCAProvTable, mscAtmIfVpcNumLeaves=mscAtmIfVpcNumLeaves, mscAtmIfVccVcdTmAbrMaxTimeBetweenRmCells=mscAtmIfVccVcdTmAbrMaxTimeBetweenRmCells, mscAtmIfVptVpdTrafficTable=mscAtmIfVptVpdTrafficTable, mscAtmIfVccVcdTmRxTdpEntry=mscAtmIfVccVcdTmRxTdpEntry, mscAtmIfMaxVccs=mscAtmIfMaxVccs, mscAtmIfVccPerfTable=mscAtmIfVccPerfTable, mscAtmIfVpcVpdRowStatusTable=mscAtmIfVpcVpdRowStatusTable, mscAtmIfCATroubledVpts=mscAtmIfCATroubledVpts, mscAtmIfCAPoolAdmitBwValue=mscAtmIfCAPoolAdmitBwValue, mscAtmIfCAVbrRtCellLossRatio=mscAtmIfCAVbrRtCellLossRatio, mscAtmIfVpcClippingBbc=mscAtmIfVpcClippingBbc, mscAtmIfVccTmAbrTxFwdRmCells=mscAtmIfVccTmAbrTxFwdRmCells, mscAtmIfVccTestUsageState=mscAtmIfVccTestUsageState, mscAtmIfVptCACbrIndex=mscAtmIfVptCACbrIndex, mscAtmIfVptVccTmTqpIndex=mscAtmIfVptVccTmTqpIndex, mscAtmIfVpcVpdTxTdpTable=mscAtmIfVpcVpdTxTdpTable, mscAtmIfCAUbrMaxVpts=mscAtmIfCAUbrMaxVpts, mscAtmIfVptVccVcdRowStatus=mscAtmIfVptVccVcdRowStatus, mscAtmIfVptBandwidthElastic=mscAtmIfVptBandwidthElastic, mscAtmIfVptVccTxQThreshValue=mscAtmIfVptVccTxQThreshValue, mscAtmIfVccTmTqpTable=mscAtmIfVccTmTqpTable, mscAtmIfVptVccVcdFwdQosClass=mscAtmIfVptVccVcdFwdQosClass, mscAtmIfVptVccVcdTmFqpEntry=mscAtmIfVptVccVcdTmFqpEntry, mscAtmIfVptStatsTxFrameDiscard=mscAtmIfVptStatsTxFrameDiscard, mscAtmIfVptVccTmRqpIndex=mscAtmIfVptVccTmRqpIndex, mscAtmIfVptVccVcdTmAbrRateIncreaseFactor=mscAtmIfVptVccVcdTmAbrRateIncreaseFactor, mscAtmIfVccTmRxPacketWiseDiscard=mscAtmIfVccTmRxPacketWiseDiscard, mscAtmIfCAPoolWaitAdmConnsTable=mscAtmIfCAPoolWaitAdmConnsTable, mscAtmIfVpcRxDiscardClp=mscAtmIfVpcRxDiscardClp, mscAtmIfVptVccTmTqpValue=mscAtmIfVptVccTmTqpValue, mscAtmIfVptVccTmTxTdpValue=mscAtmIfVptVccTmTxTdpValue, mscAtmIfVpcPmStatusTable=mscAtmIfVpcPmStatusTable, mscAtmIfVccVcdBqpEntry=mscAtmIfVccVcdBqpEntry, mscAtmIfVpcTmAbr=mscAtmIfVpcTmAbr, mscAtmIfVpcLoopRowStatusEntry=mscAtmIfVpcLoopRowStatusEntry, mscAtmIfVptVccConnInfoEntry=mscAtmIfVptVccConnInfoEntry, mscAtmIfCAMaxVpcs=mscAtmIfCAMaxVpcs, mscAtmIfVptVccAdminState=mscAtmIfVptVccAdminState, mscAtmIfVptCAAbrRowStatusTable=mscAtmIfVptCAAbrRowStatusTable, mscAtmIfVpcCurrentCtd=mscAtmIfVpcCurrentCtd, mscAtmIfVccPmFwdPmCellDiscardCount=mscAtmIfVccPmFwdPmCellDiscardCount, mscAtmIfVccPmRowStatus=mscAtmIfVccPmRowStatus, mscAtmIfVptVpdTmAbrProvTable=mscAtmIfVptVpdTmAbrProvTable, mscAtmIfVptVccTmTxQThreshEntry=mscAtmIfVptVccTmTxQThreshEntry, mscAtmIfVptTmAbrTxRateChangeInfo=mscAtmIfVptTmAbrTxRateChangeInfo, mscAtmIfVccStatsRxCellClp=mscAtmIfVccStatsRxCellClp, mscAtmIfVpcVpdTmAbrCutoffDecreaseFactor=mscAtmIfVpcVpdTmAbrCutoffDecreaseFactor, mscAtmIfVptTmBestEffort=mscAtmIfVptTmBestEffort, mscAtmIfVptCAPoolRequBwIndex=mscAtmIfVptCAPoolRequBwIndex, mscAtmIfVptVccDistributionType=mscAtmIfVptVccDistributionType, mscAtmIfVccNepRowStatusEntry=mscAtmIfVccNepRowStatusEntry, mscAtmIfVptVccTmTxQThreshTable=mscAtmIfVptVccTmTxQThreshTable, mscAtmIfVccAtmServiceCategory=mscAtmIfVccAtmServiceCategory, mscAtmIfVptVccRdiState=mscAtmIfVptVccRdiState, mscAtmIfVptRxQosClass=mscAtmIfVptRxQosClass, mscAtmIfVptTmOperEntry=mscAtmIfVptTmOperEntry, mscAtmIfVptVpdProvTable=mscAtmIfVptVpdProvTable, mscAtmIfNAcctServiceExchange=mscAtmIfNAcctServiceExchange, mscAtmIfVpcTmUnshapedTransmitQueueing=mscAtmIfVpcTmUnshapedTransmitQueueing, mscAtmIfVptVccTmIndex=mscAtmIfVptVccTmIndex, mscAtmIfVccVcdTmRxPacketWiseDiscard=mscAtmIfVccVcdTmRxPacketWiseDiscard, mscAtmIfVptVpdRowStatusEntry=mscAtmIfVptVpdRowStatusEntry, mscAtmIfVccPmBwdTotalUserCellsRx01=mscAtmIfVccPmBwdTotalUserCellsRx01, mscAtmIfVptTmRowStatusTable=mscAtmIfVptTmRowStatusTable, mscAtmIfVpcPmIndex=mscAtmIfVpcPmIndex, mscAtmIfVccRxTdpTable=mscAtmIfVccRxTdpTable, mscAtmIfVptVpdTmAbrRowStatusTable=mscAtmIfVptVpdTmAbrRowStatusTable, mscAtmIfConnMapNumNonZeroVpisForVccsOper=mscAtmIfConnMapNumNonZeroVpisForVccsOper, mscAtmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor=mscAtmIfVccVcdTmAbrFarEndAcrDecreaseTimeFactor, mscAtmIfVccVcdTmFwdQosClass=mscAtmIfVccVcdTmFwdQosClass, mscAtmIfUnshapedTransmitQueueingOper=mscAtmIfUnshapedTransmitQueueingOper, mscAtmIfCARtVbrOpUnshapedTransmitQueueing=mscAtmIfCARtVbrOpUnshapedTransmitQueueing, mscAtmIfVpcVpdTmAbrProvEntry=mscAtmIfVpcVpdTmAbrProvEntry)

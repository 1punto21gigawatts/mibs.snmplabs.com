#
# PySNMP MIB module AXON-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AXON-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:33:02 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter32, iso, MibIdentifier, Unsigned32, Integer32, Counter64, NotificationType, ModuleIdentity, Gauge32, TimeTicks, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "iso", "MibIdentifier", "Unsigned32", "Integer32", "Counter64", "NotificationType", "ModuleIdentity", "Gauge32", "TimeTicks", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Bits")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
directory = MibIdentifier((1, 3, 6, 1, 1))
mgmt = MibIdentifier((1, 3, 6, 1, 2))
experimental = MibIdentifier((1, 3, 6, 1, 3))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
mib_2 = MibIdentifier((1, 3, 6, 1, 2, 1)).setLabel("mib-2")
axon = MibIdentifier((1, 3, 6, 1, 4, 1, 370))
clone = MibIdentifier((1, 3, 6, 1, 4, 1, 370, 1))
product = MibIdentifier((1, 3, 6, 1, 4, 1, 370, 2))
common = MibIdentifier((1, 3, 6, 1, 4, 1, 370, 2, 1))
application = MibIdentifier((1, 3, 6, 1, 4, 1, 370, 3))
axFddi = MibIdentifier((1, 3, 6, 1, 4, 1, 370, 4))
axFddiStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 370, 4, 1))
axFddiHistory = MibIdentifier((1, 3, 6, 1, 4, 1, 370, 4, 2))
fddiStatsTable = MibTable((1, 3, 6, 1, 4, 1, 370, 4, 1, 1), )
if mibBuilder.loadTexts: fddiStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsTable.setDescription('A list of promiscuous FDDI statistics entries')
fddiStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1), ).setIndexNames((0, "AXON-MIB", "fddiStatsIndex"))
if mibBuilder.loadTexts: fddiStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsEntry.setDescription('A collection of promiscuous statistics kept for packets on a particular FDDI interface.')
fddiStatsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsIndex.setDescription('The value of this object uniquely identifies this fddiStats entry.')
fddiStatsDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddiStatsDataSource.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsDataSource.setDescription('This object identifies the source of the data that this fddiStats entry is configured to analyze. This source can be any FDDI interface on this device. In order to identify a particular interface, this object shall identify the instance of the ifIndex object, defined in RFC 1213 and RFC 1573 [4,6], for the desired interface. For example, if an entry were to receive data from interface #1, this object would be set to ifIndex.1. The statistics in this group reflect all packets on the local network segment attached to the identified interface. This object may not be modified if the associated fddiStatsStatus object is equal to valid(1).')
fddiStatsDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources. Note that this number is not necessarily the number of packets dropped; it is just the number of times this condition has been detected.')
fddiStatsOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsOctets.setDescription('The total number of octets of LLC data (including those in bad packets) received on the network (excluding framing bits but including FCS octets).')
fddiStatsPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts.setDescription('The total number of LLC packets (including bad packets, broadcast packets, and multicast packets) received.')
fddiStatsBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsBroadcastPkts.setDescription('The total number of packets received that were directed to the broadcast address (0xFFFFFFFFFFFF). Note that this does not include multicast packets.')
fddiStatsMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsMulticastPkts.setDescription('The total number of packets received that were directed to a local or global multicast or functional address. Note that this number does not include packets directed to the broadcast address.')
fddiStatsErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsErrors.setDescription('The total number of packets received that had either a bad Frame Check Sequence (FCS) or a invalid data length. A packet with a invalid data length is one that is too short (length less than 21 octets / 42 symbols) or had an odd number of symbols.')
fddiStatsPkts22Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts22Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts22Octets.setDescription('The total number of good packets received that were 22 octets, or less, in length (excluding framing bits but including FCS octets).')
fddiStatsPkts23to63Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts23to63Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts23to63Octets.setDescription('The total number of good packets received that were between 23 and 63 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsPkts64to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts64to127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts64to127Octets.setDescription('The total number of good packets received that were between 64 and 127 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts128to255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts128to255Octets.setDescription('The total number of good packets received that were between 128 and 255 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts256to511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts256to511Octets.setDescription('The total number of good packets received that were between 256 and 511 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts512to1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts512to1023Octets.setDescription('The total number of good packets received that were between 512 and 1023 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsPkts1024to2047Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts1024to2047Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts1024to2047Octets.setDescription('The total number of good packets received that were between 1024 and 2047 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsPkts2048to4095Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts2048to4095Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts2048to4095Octets.setDescription('The total number of good packets received that were between 2048 and 4095 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsPkts4096to4500Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsPkts4096to4500Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsPkts4096to4500Octets.setDescription('The total number of good packets received that were between 4096 and 4500 octets in length inclusive (excluding framing bits but including FCS octets).')
fddiStatsTNEG = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsTNEG.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsTNEG.setDescription('The Negotiated Token Rotation Time, TNeg, in nano-seconds')
fddiStatsTokens = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsTokens.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsTokens.setDescription('The number of valid tokens received')
fddiStatsSMTs = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsSMTs.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsSMTs.setDescription('The number of SMT frames received')
fddiStatsClaims = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsClaims.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsClaims.setDescription('The number of Claim frames received')
fddiStatsDirBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsDirBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsDirBeacons.setDescription('The number of Directed Beacon frames received. Directed Beacon frames have an FC field of 0xC2, a Destination Address of non-canonical: 80:01:43:00:80:00, canonical: 01:80:C2:00:01:00, a Source Address of this station, and a info field of 0x01 (Beacon Type) + pad field (0x000000).')
fddiStatsBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsBeacons.setDescription('The number of MAC Beacon frames received. MAC Beacon frames have an FC field of 0xC2, a Destination Address of the null address a Source Address of this station, and a info field of 0x00 (Beacon Type) + pad field (0x000000).')
fddiStatsBeaconAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 24), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsBeaconAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsBeaconAddr.setDescription('The MAC address of the last station to send a Beacon Frame')
fddiStatsDirBeaconAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 25), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsDirBeaconAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsDirBeaconAddr.setDescription('The MAC address of the last station to send a Directed Beacon Frame')
fddiStatsClaimAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 26), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsClaimAddr.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsClaimAddr.setDescription('The MAC address of the last station to send a Claim Frame')
fddiStatsRingState = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsRingState.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsRingState.setDescription('The current detected state of the ring. 1 Operational 2 Non Operational Claim 3 Non Operational Beacon 4 Non Operational Dir. Beacon')
fddiStatsOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 28), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddiStatsOwner.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsOwner.setDescription('The entity that configured this entry and is therefore using the resources assigned to it.')
fddiStatsStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 29), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fddiStatsStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsStatus.setDescription('The status of this fddiStats entry.')
fddiStatsOtherPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsOtherPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsOtherPkts.setDescription('The total number of other packets (including bad packets, broadcast packets, and multicast packets) received. Other packets which are packets which are not LLC, SMT or recognized MAC beacon packets.')
fddiStatsOtherOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 1, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiStatsOtherOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiStatsOtherOctets.setDescription('The total number of other octets (including those in bad packets) received on the network (excluding framing bits but including FCS octets). Other octets are those from packets which are packets which are not LLC, SMT or recognized MAC beacon packets.')
fddiHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 370, 4, 2, 5), )
if mibBuilder.loadTexts: fddiHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryTable.setDescription('A list of FDDI history entries.')
fddiHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1), ).setIndexNames((0, "AXON-MIB", "fddiHistoryIndex"), (0, "AXON-MIB", "fddiHistorySampleIndex"))
if mibBuilder.loadTexts: fddiHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryEntry.setDescription('An historical sample of FDDI statistics on a particular FDDI interface. This sample is associated with the historyControlEntry which set up the parameters for a regular collection of these samples. As an example, an instance of the fddiHistoryPkts object might be named fddiHistoryPkts.2.89')
fddiHistoryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryIndex.setDescription('The history of which this entry is a part. The history identified by a particular value of this index is the same history as identified by the same value of historyControlIndex.')
fddiHistorySampleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistorySampleIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistorySampleIndex.setDescription('An index that uniquely identifies the particular sample this entry represents among all samples associated with the same historyControlEntry. This index starts at 1 and increases by one as each new sample is taken.')
fddiHistoryIntervalStart = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryIntervalStart.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryIntervalStart.setDescription('The value of sysUpTime at the start of the interval over which this sample was measured. If the probe keeps track of the time of day, it should start the first sample of the history at a time such that when the next hour of the day begins, a sample is started at that instant. Note that following this rule may require the probe to delay collecting the first sample of the history, as each sample must be of the same interval. Also note that the sample which is currently being collected is not accessible in this table until the end of its interval.')
fddiHistoryDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryDropEvents.setDescription('The total number of events in which packets were dropped by the probe due to lack of resources during this sampling interval. Note that this number is not necessarily the number of packets dropped, it is just the number of times this condition has been detected.')
fddiHistoryOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryOctets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryOctets.setDescription('The total number of octets of LLC data (including those in bad packets) received on the network (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts.setDescription('The total number of LLC packets (including bad packets, broadcast packets, and multicast packets) received during this sampling interval.')
fddiHistoryBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryBroadcastPkts.setDescription('The total number of packets received that were directed to the broadcast address (0xFFFFFFFFFFFF) during this sampling interval. Note that this does not include multicast packets.')
fddiHistoryMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryMulticastPkts.setDescription('The total number of packets received that were directed to a local or global multicast or functional address during this sampling interval. Note that this number does not include packets directed to the broadcast address.')
fddiHistoryErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryErrors.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryErrors.setDescription('The total number of packets received that had either a bad Frame Check Sequence (FCS) or a invalid data length during this sampling interval. A packet with a invalid data length is one that is too short (length less than 21 octets / 42 symbols) or had an odd number of symbols.')
fddiHistoryPkts22Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts22Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts22Octets.setDescription('The total number of good packets received that were 22 octets, or less, in length (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts23to63Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts23to63Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts23to63Octets.setDescription('The total number of good packets received that were between 23 and 63 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts64to127Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts64to127Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts64to127Octets.setDescription('The total number of good packets received that were between 64 and 127 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts128to255Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts128to255Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts128to255Octets.setDescription('The total number of good packets received that were between 128 and 255 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts256to511Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts256to511Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts256to511Octets.setDescription('The total number of good packets received that were between 256 and 511 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts512to1023Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts512to1023Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts512to1023Octets.setDescription('The total number of good packets received that were between 512 and 1023 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts1024to2047Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts1024to2047Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts1024to2047Octets.setDescription('The total number of good packets received that were between 1024 and 2047 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts2048to4095Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts2048to4095Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts2048to4095Octets.setDescription('The total number of good packets received that were between 2048 and 4095 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryPkts4096to4500Octets = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryPkts4096to4500Octets.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryPkts4096to4500Octets.setDescription('The total number of good packets received that were between 4096 and 4500 octets in length inclusive (excluding framing bits but including FCS octets) during this sampling interval.')
fddiHistoryUtilization = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryUtilization.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryUtilization.setDescription('The best estimate of the mean physical layer network utilization on this interface during this sampling interval, in hundredths of a percent. This is calculated as: utilize = ((bits/s used) * 10000) / (MAX bits/s) = ((bits/ms used) * 10000000) / 100000000 = (bits/ms used) / 10 = (((pkts * 5) + octets) * 8) / (interval * 10)')
fddiHistoryTNEG = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryTNEG.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryTNEG.setDescription('The Negotiated Token Rotation Time, TNeg, in nano-seconds at the end of the sample interval.')
fddiHistoryMeanTRT = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryMeanTRT.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryMeanTRT.setDescription('The Mean token rotation time. This calculated as the tokens received during the sample interval divided by the sample interval.')
fddiHistorySMTs = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistorySMTs.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistorySMTs.setDescription('The number of SMT frames received during the sample interval.')
fddiHistoryClaims = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryClaims.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryClaims.setDescription('The number of Claim frames received during the sample interval.')
fddiHistoryDirBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryDirBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryDirBeacons.setDescription('The number of Directed Beacon frames received during the sample interval. Directed Beacon frames have an FC field of 0xC2, a Destination Address of non-canonical: 80:01:43:00:80:00, canonical: 01:80:C2:00:01:00, a Source Address of this station, and a info field of 0x01 (Beacon Type) + pad field (0x000000).')
fddiHistoryBeacons = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryBeacons.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryBeacons.setDescription('The number of MAC Beacon frames received during the sample interval. MAC Beacon frames have an FC field of 0xC2, a Destination Address of the null address a Source Address of this station, and a info field of 0x00 (Beacon Type) + pad field (0x000000).')
fddiHistoryRingStateChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 370, 4, 2, 5, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fddiHistoryRingStateChanges.setStatus('mandatory')
if mibBuilder.loadTexts: fddiHistoryRingStateChanges.setDescription('Count of changes of the state of the ring during the sample interval.')
mibBuilder.exportSymbols("AXON-MIB", fddiStatsPkts23to63Octets=fddiStatsPkts23to63Octets, fddiStatsPkts4096to4500Octets=fddiStatsPkts4096to4500Octets, fddiStatsEntry=fddiStatsEntry, fddiStatsClaims=fddiStatsClaims, fddiHistoryPkts22Octets=fddiHistoryPkts22Octets, fddiStatsPkts1024to2047Octets=fddiStatsPkts1024to2047Octets, fddiStatsPkts512to1023Octets=fddiStatsPkts512to1023Octets, fddiStatsDirBeaconAddr=fddiStatsDirBeaconAddr, fddiHistoryMulticastPkts=fddiHistoryMulticastPkts, axFddiHistory=axFddiHistory, fddiStatsPkts256to511Octets=fddiStatsPkts256to511Octets, fddiHistoryBeacons=fddiHistoryBeacons, fddiStatsTable=fddiStatsTable, mib_2=mib_2, fddiStatsRingState=fddiStatsRingState, fddiHistoryTable=fddiHistoryTable, enterprises=enterprises, fddiStatsBroadcastPkts=fddiStatsBroadcastPkts, fddiStatsTNEG=fddiStatsTNEG, fddiHistoryPkts=fddiHistoryPkts, fddiStatsMulticastPkts=fddiStatsMulticastPkts, fddiStatsBeacons=fddiStatsBeacons, fddiHistoryTNEG=fddiHistoryTNEG, org=org, fddiStatsPkts128to255Octets=fddiStatsPkts128to255Octets, fddiStatsBeaconAddr=fddiStatsBeaconAddr, fddiStatsErrors=fddiStatsErrors, fddiStatsOtherPkts=fddiStatsOtherPkts, fddiHistoryUtilization=fddiHistoryUtilization, fddiHistoryPkts256to511Octets=fddiHistoryPkts256to511Octets, fddiStatsClaimAddr=fddiStatsClaimAddr, dod=dod, fddiHistoryRingStateChanges=fddiHistoryRingStateChanges, fddiStatsStatus=fddiStatsStatus, fddiHistoryPkts512to1023Octets=fddiHistoryPkts512to1023Octets, fddiStatsIndex=fddiStatsIndex, private=private, fddiHistoryPkts1024to2047Octets=fddiHistoryPkts1024to2047Octets, application=application, fddiHistoryPkts2048to4095Octets=fddiHistoryPkts2048to4095Octets, common=common, clone=clone, fddiStatsPkts64to127Octets=fddiStatsPkts64to127Octets, axon=axon, fddiHistoryIndex=fddiHistoryIndex, fddiHistoryMeanTRT=fddiHistoryMeanTRT, fddiHistoryErrors=fddiHistoryErrors, fddiHistorySampleIndex=fddiHistorySampleIndex, fddiHistoryPkts64to127Octets=fddiHistoryPkts64to127Octets, fddiHistoryPkts4096to4500Octets=fddiHistoryPkts4096to4500Octets, internet=internet, fddiStatsPkts22Octets=fddiStatsPkts22Octets, fddiHistoryDirBeacons=fddiHistoryDirBeacons, fddiStatsTokens=fddiStatsTokens, axFddiStatistics=axFddiStatistics, fddiHistoryDropEvents=fddiHistoryDropEvents, fddiHistoryEntry=fddiHistoryEntry, fddiHistoryPkts23to63Octets=fddiHistoryPkts23to63Octets, experimental=experimental, fddiStatsOctets=fddiStatsOctets, product=product, fddiStatsDirBeacons=fddiStatsDirBeacons, fddiStatsOtherOctets=fddiStatsOtherOctets, fddiHistorySMTs=fddiHistorySMTs, fddiHistoryBroadcastPkts=fddiHistoryBroadcastPkts, fddiHistoryIntervalStart=fddiHistoryIntervalStart, fddiStatsDropEvents=fddiStatsDropEvents, directory=directory, fddiHistoryOctets=fddiHistoryOctets, fddiStatsOwner=fddiStatsOwner, mgmt=mgmt, axFddi=axFddi, fddiHistoryPkts128to255Octets=fddiHistoryPkts128to255Octets, fddiStatsPkts=fddiStatsPkts, fddiStatsSMTs=fddiStatsSMTs, fddiHistoryClaims=fddiHistoryClaims, fddiStatsPkts2048to4095Octets=fddiStatsPkts2048to4095Octets, fddiStatsDataSource=fddiStatsDataSource)

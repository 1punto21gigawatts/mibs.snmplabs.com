#
# PySNMP MIB module CISCO-CABLE-METERING-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-CABLE-METERING-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:51:55 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetPortNumber, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
TimeTicks, Unsigned32, IpAddress, MibIdentifier, Counter32, ObjectIdentity, NotificationType, Bits, Integer32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Gauge32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Unsigned32", "IpAddress", "MibIdentifier", "Counter32", "ObjectIdentity", "NotificationType", "Bits", "Integer32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Gauge32", "ModuleIdentity")
TextualConvention, RowStatus, DateAndTime, DisplayString, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "RowStatus", "DateAndTime", "DisplayString", "TruthValue")
ciscoCableMeteringMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 424))
ciscoCableMeteringMIB.setRevisions(('2009-10-13 00:00', '2009-05-18 00:00', '2004-03-30 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoCableMeteringMIB.setRevisionsDescriptions(('Added a new enum type ipdr to ccmtrCollectionType.', 'Deprecated ccmtrCollectionInterval. Deprecated ciscoCableMeteringCompliance and added ciscoCableMeteringComplianceRev1 to replace it. Deprecated ccmtrMeteringObjGroup. Added the following new objects: ccmtrCollectionSrcIfIndex ccmtrCollectionRevInterval ccmtrCollectionDataPerSession ccmtrCollectionDataTimer Added the following new OBJECT-GROUP: ccmtrMeteringObjGroupRev1 ccmtrMeteringSrcIntfObjGroup ccmtrMeteringRateCtrlObjGroup', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoCableMeteringMIB.setLastUpdated('200910130000Z')
if mibBuilder.loadTexts: ciscoCableMeteringMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoCableMeteringMIB.setContactInfo('Cisco Systems Customer Service Postal: Cisco Systems 170 West Tasman Drive San Jose, CA 95134 U.S.A. Phone: +1 800 553-NETS E-mail: cs-ubr@cisco.com')
if mibBuilder.loadTexts: ciscoCableMeteringMIB.setDescription('This is the MIB module for Usage Based Metering for the DOCSIS-compliant Cable Modem Termination Systems (CMTS). Usage Based Metering is a software feature provided in the CMTS so that cable operators can perform subscriber account management and metering in a uniform and consistent manner. It involves the implementation of Subscriber Account Management Interface Specification (SAMIS) as defined by DOCSIS-OSSI specification. Usage-Based Metering is essential in the processing of bills based on services rendered to and consumed by paying subscribers. The SAMIS specification focuses primarily on bandwidth centric usage-based metering scenarios. The DOCSIS 1.1 RFI specification provides a mechanism for a Cable Modem (CM) to register with its Cable Modem Termination System (CMTS) and to configure itself based on external Quality of Service (QoS) parameters when it is powered up or reset. The principal mechanism for providing enhanced QoS is to classify packets traversing the RF MAC interface into a Service Flow. A Service Flow is a unidirectional flow of packets that is provided a particular Quality of Service. The mediation system can then rate the charges differently for each of the Service Flow traffic counts based on its Service Class. Thus, the mediation system obtains from the CMTS the traffic counts for each named Service Flow (identified by SFID) that a subscribers CM uses during the metering data collection interval. The Usage Based Metering requirement is that the CMTS must be able to provide formatted Subscriber Usage Metering Records for all subscribers attached to the CMTS, on demand to an external collection system. Optionally, the metering records can be stored locally so that it is available via ftp to the external collection server. The CMTS provides two configuration options to handle the export of metering data. Local : Store the record locally on the CMTS after collection. The metering system should then(operating at its own schedule) take the file out of the CMTS and is also responsible for deletion of the local file on the CMTS. The deletion of the file is an indication to the metering collector to start construction of the new metering record which will then be written to the local filesystem and the cycle continues. Streaming: Stream the records to an external collection system as they get generated. The time interval in which the record will be generated is configurable at the CMTS. A secure and reliable stream is used to transport the metering record out of the CMTS. In case the connection to external metering system is not possible, CMTS will retry establishing channel for a max specified times. The MIB allows for configuration of the parameters that control the metering record collection like interval, amount of metering information required, location or IP address of the collection server, and metering filename. In addition it provides for some important notificatons to the NMS to indicate the success/failure of the metering collection.')
class CcmtrStatus(TextualConvention, Integer32):
    description = "The CcmtrStatus is used to indicate success or failure status that occurred during the process of writing the metering records to the non-volatile memory device or during streaming them to an external mediation or collection server It has the following defined values: - 'unknown', indicates other reasons for failure of write/stream of the metering records . - 'success', indicates that write of the metering file or streaming to the collection server was successful. - 'deviceFull', indicates that there is not enough space on the non-volatile memory device for writing the metering record file. - 'writeError', indicates that there was a write error when trying to write the metering record file or stream to the collection server. - 'fileNotExist', indicates that the metering file has not yet been created for access by the collection server. - 'connectionTimeout', indicates a failure to connect to the collection server. - 'dataIncomplete', indicates that there was a failure during write or streaming and that the metering record might be incomplete."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("unknown", 1), ("success", 2), ("deviceFull", 3), ("writeError", 4), ("fileNotExist", 5), ("connectionTimeout", 6), ("dataIncomplete", 7))

class CcmtrCollectionServer(TextualConvention, Integer32):
    description = "The CcmtrCollectionServer is used to indicate the type of the collection server. It has the following defined values: - 'primary', indicates that the collection server is primary and will be the first server to which streaming will be attempted. - 'secondary', indicates that the collection server is secondary and that it will be used only if streaming to the primary server failed."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("primary", 1), ("secondary", 2))

ciscoCableMeteringMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 424, 0))
ciscoCableMeteringMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 424, 1))
ccmtrMeteringConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1))
ccmtrMetering = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 2))
ccmtrCollectionType = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("local", 2), ("stream", 3), ("ipdr", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionType.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionType.setDescription('Current method of export for metering data. The enumerations are: none(1) : Metering collection has not been enabled. local(2) : Store the collected metering records locally on the CMTS. stream(3) : Stream the metering records to an external collection or mediation server. ipdr(4) : Stream the metering records to an ipdr (Internet Proticol Detail Record)collector.')
ccmtrCollectionFilesystem = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 80))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionFilesystem.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionFilesystem.setDescription("The filesystem where metering records are to be stored. This object makes sense only if ccmtrCollectionType object is local which indicates that the metering records are to be stored in the local filesystem. When ccmtrCollectionType is 'stream' this object will retain its set value though it will not be used.")
ccmtrCollectionTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 3), )
if mibBuilder.loadTexts: ccmtrCollectionTable.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionTable.setDescription('This table is used only if ccmtrCollectionType object is stream which indicates that the metering records are to be streamed to an external collection server. It contains IP address information of the collection server. In addition it contains other configurable parameters like interval, retries etc needed for streaming the metering records.')
ccmtrCollectionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-CABLE-METERING-MIB", "ccmtrCollectionID"))
if mibBuilder.loadTexts: ccmtrCollectionEntry.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionEntry.setDescription('A set of IP attributes of the mediation or collection server and configuration parameters for streaming the metering records. An entry in this table exists for each configured mediation or collection server.')
ccmtrCollectionID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 3, 1, 1), CcmtrCollectionServer())
if mibBuilder.loadTexts: ccmtrCollectionID.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionID.setDescription('Identification of a IP address and port number associated with the mediation or collection server. The ccmtrCollectionID is used in determining the order of the IP address, port number to which the streaming will take place. The primary represents the first collection server and secondary represents the second collection server if streaming to the primary failed for any reason. Thus primary entry must be created before the secondary.')
ccmtrCollectionIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 3, 1, 2), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccmtrCollectionIpAddrType.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionIpAddrType.setDescription('The type of internet address of ccmtrCollectionIpAddress.')
ccmtrCollectionIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 3, 1, 3), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccmtrCollectionIpAddress.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionIpAddress.setDescription('The IP address of the collection server. It will be of type as referred by ccmtrCollectionIpAddrType. The ccmtrCollectionPort should be also valid along with ccmtrCollectionIpAddress for a row to be created. The primary collection server IP address represented by ccmtrCollectionID equal to 1 must be created before the secondary collection server IP address.')
ccmtrCollectionPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 3, 1, 4), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccmtrCollectionPort.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionPort.setDescription('The port number of the collection server. This port number chosen should not be any of the well defined ports. The ccmtrCollectionIpAddress should be also valid along with ccmtrCollectionPort for a row to be created. The primary collection server port represented by ccmtrCollectionID equal to 1 must be created before the secondary collection server port.')
ccmtrCollectionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 3, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ccmtrCollectionRowStatus.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionRowStatus.setDescription('Controls and reflects the status of rows in this table. It can use used for creation, modifying and deleting entries in this table. The ccmtrCollectionPort should also be valid along with ccmtrCollectionIpAddress for a row to be created. The ccmtrCollectionID 1 represents the primary collection server and ccmtrCollectionID 2 represents the secondary collection server. Thus ccmtrCollectionID of 1 must be created before the ccmtrCollectionID of 2.')
ccmtrCollectionInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(15, 1440)).clone(30)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionInterval.setStatus('deprecated')
if mibBuilder.loadTexts: ccmtrCollectionInterval.setDescription('The interval in which the metering information is collected. This object makes sense only if ccmtrCollectionType object is stream which indicates that the metering records are to be streamed to an external collection server. This object is deprecated and replaced by ccmtrCollectionRevInterval. While retrieving the value of ccmtrCollectionInterval, the minimum value of 15 will be returned if the value of ccmtrCollectionRevInterval is lower than 15.')
ccmtrCollectionRetries = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionRetries.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionRetries.setDescription('The number of retries to stream the metering records to the external collection server before an error is flagged. This object makes sense only if ccmtrCollectionType object is stream which indicates that the metering records are to be streamed to an external collection server.')
ccmtrCollectionSecure = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionSecure.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionSecure.setDescription('An indication of whether the streaming to the collection server should be secure or not. The value of true indicates that the streaming will be secure and false indicates non-secure. However the secure option is available only if the image on the CMTS allows for security. This object makes sense only if ccmtrCollectionType object is stream which indicates that the metering records are to be streamed to an external collection server.')
ccmtrCollectionCpeList = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 7), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionCpeList.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionCpeList.setDescription('An indication if one would like the metering records to contain the CPE(Customer premises equipment) IP addresses. This option is provided to improve performance. By default, this object is true which means the CPE information will always be present.')
ccmtrCollectionAggregate = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionAggregate.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionAggregate.setDescription('An indication if one would like only aggregate Service Flow information per Cable Modem to be recorded. In this case the record will have a SFID of 0 and a blank Service Class Name. The distinction between upstream and downstream will however be maintained. The counters present in the metering records in this case will be the aggregate. i.e., sum of all upstream/downstream service flows. By default, this object is false which means that the metering records will contain service flow counter information for all service flows per CM.')
ccmtrCollectionSrcIfIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 9), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionSrcIfIndex.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionSrcIfIndex.setDescription("The ifIndex of the interface which will be used as the source interface for the billing packets. When ccmtrCollectionType is 'local', the IP address of this source interface will be used as the CMTS IP address in the billing packets. When ccmtrCollectionType is 'stream', the source IP address of the billing packets as well as the CMTS IP address in billing packets will be changed to the IP address of this interface. In both the cases, the mac address of the source interface would be used in the billing packet headers. A value of zero on this object indicates that the source interface is not specifically configured and the system will determine the source interface to use for billing packets dynamically. This object can only be set when ccmtrCollectionType is either 'local' or 'stream'.")
ccmtrCollectionRevInterval = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(30)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionRevInterval.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionRevInterval.setDescription("The interval at which the metering information is collected. This object is of significance only if ccmtrCollectionType object is 'stream' which indicates that the metering records are to be streamed to an external collection server.")
ccmtrCollectionDataPerSession = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 30)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionDataPerSession.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionDataPerSession.setDescription('This object specifies the number of service flow data that would be collected at a Cable linecard in one session. ccmtrCollectionDataPerSession together with ccmtrCollectionDataTimer aims to control as well as throttle the rate of export of the service flow data from the Cable linecard to the Route Processor. This means that a Cable linecard would collect ccmtrCollectionDataPerSession number of service flow data and then pause for ccmtrCollectionDataTimer before resuming collection. The cable linecard to route processor throttling in turn affects the time to export all of the service flow data from the CMTS to a collection server. Time to export (minutes) = (total flows in system * ccmtrCollectionDataTimer) / (ccmtrCollectionDataPerSession * 1000 * 60) This object cannot be modified during data export from the CMTS to a collection server.')
ccmtrCollectionDataTimer = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(8, 500)).clone(100)).setUnits('milliseconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrCollectionDataTimer.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionDataTimer.setDescription('This object specifies the time interval before the start of the next session of service flow data collection at a Cable linecard. After collection of ccmtrCollectionDataPerSession service flow data at a Cable linecard, the linecard would resume collection only after an interval of ccmtrCollectionDataTimer milliseconds. This object cannot be modified during data export from the CMTS to a collection server.')
ccmtrCollectionStatus = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 2, 1), CcmtrStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccmtrCollectionStatus.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionStatus.setDescription('The status of the last metering data export. It indicates the success or failure of writing the metering record file or streaming the record to the collection server.')
ccmtrCollectionDestination = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 2, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccmtrCollectionDestination.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionDestination.setDescription('It represents the name of the file that is created to store the metering record or the IP address and port number to which the metering information was streamed in both the success and failure scenerios. In the case of local storage it is the filename generated as the CMTS host name followed by the timestamp when the file was created. The file will be stored in the filesystem as specified in ccmtrCollectionFilesystem. In the case of streaming it is the IP address and port number in the format IPADDRESS:PORT# to which the last streaming took place.')
ccmtrCollectionTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 2, 3), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccmtrCollectionTimestamp.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionTimestamp.setDescription('The time when the last metering record was exported successfully or with some failure.')
ccmtrMeteringNotifEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 424, 1, 2, 4), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccmtrMeteringNotifEnable.setStatus('current')
if mibBuilder.loadTexts: ccmtrMeteringNotifEnable.setDescription('An indication of whether the notifications associated with metering are enabled or disabled. true indicates the notification is enabled and false indicates the notification is disabled.')
ccmtrCollectionNotification = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 424, 0, 1)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrCollectionStatus"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionDestination"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionTimestamp"))
if mibBuilder.loadTexts: ccmtrCollectionNotification.setStatus('current')
if mibBuilder.loadTexts: ccmtrCollectionNotification.setDescription('A notification that is sent to indicate the success or failure in creating the metering record file or streaming it to the collection server. ccmtrCollectionStatus represents the success or failure of the export. ccmtrCollectionDestination and ccmtrCollectionTimestamp represent the destinaton and timestamp of the export in both the success and failure scenerios. The receipt of this notification is an indication to the collection server that the file can be accessed via ftp or any file transfer protocol in the case of local storage.')
ciscoCableMeteringMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 424, 3))
ciscoCableMeteringMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 1))
ciscoCableMeteringMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 2))
ciscoCableMeteringCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 1, 1)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrMeteringObjGroup"), ("CISCO-CABLE-METERING-MIB", "ccmtrMeteringNotifCtrlGroup"), ("CISCO-CABLE-METERING-MIB", "ccmtrMeteringNotifGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCableMeteringCompliance = ciscoCableMeteringCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ciscoCableMeteringCompliance.setDescription('The compliance statement for CMTS devices that implement the Usage Based Metering feature. This compliance is deprecated by ciscoCableMeteringComplianceRev1.')
ciscoCableMeteringComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 1, 2)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrMeteringNotifCtrlGroup"), ("CISCO-CABLE-METERING-MIB", "ccmtrMeteringNotifGroup"), ("CISCO-CABLE-METERING-MIB", "ccmtrMeteringObjGroupRev1"), ("CISCO-CABLE-METERING-MIB", "ccmtrMeteringSrcIntfObjGroup"), ("CISCO-CABLE-METERING-MIB", "ccmtrMeteringRateCtrlObjGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoCableMeteringComplianceRev1 = ciscoCableMeteringComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: ciscoCableMeteringComplianceRev1.setDescription('The compliance statement for CMTS devices that implement the Usage Based Metering feature.')
ccmtrMeteringObjGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 2, 1)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrCollectionType"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionFilesystem"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionIpAddrType"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionIpAddress"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionPort"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionInterval"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionRetries"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionSecure"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionRowStatus"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionCpeList"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionAggregate"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionStatus"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionDestination"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionTimestamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccmtrMeteringObjGroup = ccmtrMeteringObjGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ccmtrMeteringObjGroup.setDescription('Group of objects implemented in CMTS providing for usage based metering configuration and notification information. This group is deprecated by ccmtrMeteringObjGroupRev1.')
ccmtrMeteringNotifCtrlGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 2, 2)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrMeteringNotifEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccmtrMeteringNotifCtrlGroup = ccmtrMeteringNotifCtrlGroup.setStatus('current')
if mibBuilder.loadTexts: ccmtrMeteringNotifCtrlGroup.setDescription('The notification control which a CISCO-CABLE-METERING-MIB is required to implement.')
ccmtrMeteringNotifGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 2, 3)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrCollectionNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccmtrMeteringNotifGroup = ccmtrMeteringNotifGroup.setStatus('current')
if mibBuilder.loadTexts: ccmtrMeteringNotifGroup.setDescription('The notification which a CISCO-CABLE-METERING-MIB is required to implement.')
ccmtrMeteringObjGroupRev1 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 2, 4)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrCollectionType"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionFilesystem"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionIpAddrType"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionIpAddress"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionPort"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionRowStatus"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionRetries"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionSecure"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionCpeList"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionAggregate"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionRevInterval"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionStatus"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionDestination"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionTimestamp"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccmtrMeteringObjGroupRev1 = ccmtrMeteringObjGroupRev1.setStatus('current')
if mibBuilder.loadTexts: ccmtrMeteringObjGroupRev1.setDescription('Group of objects implemented in CMTS providing for usage based metering configuration and notification information.')
ccmtrMeteringSrcIntfObjGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 2, 5)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrCollectionSrcIfIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccmtrMeteringSrcIntfObjGroup = ccmtrMeteringSrcIntfObjGroup.setStatus('current')
if mibBuilder.loadTexts: ccmtrMeteringSrcIntfObjGroup.setDescription('Group of objects implemented in CMTS to define the source interface for the billing packets.')
ccmtrMeteringRateCtrlObjGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 424, 3, 2, 6)).setObjects(("CISCO-CABLE-METERING-MIB", "ccmtrCollectionDataPerSession"), ("CISCO-CABLE-METERING-MIB", "ccmtrCollectionDataTimer"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ccmtrMeteringRateCtrlObjGroup = ccmtrMeteringRateCtrlObjGroup.setStatus('current')
if mibBuilder.loadTexts: ccmtrMeteringRateCtrlObjGroup.setDescription('Group of objects implemented in CMTS to control as well as throttle the rate of export of the service flow data.')
mibBuilder.exportSymbols("CISCO-CABLE-METERING-MIB", ciscoCableMeteringMIB=ciscoCableMeteringMIB, ccmtrCollectionIpAddrType=ccmtrCollectionIpAddrType, ccmtrCollectionSrcIfIndex=ccmtrCollectionSrcIfIndex, ccmtrCollectionStatus=ccmtrCollectionStatus, ccmtrCollectionIpAddress=ccmtrCollectionIpAddress, ccmtrMeteringObjGroupRev1=ccmtrMeteringObjGroupRev1, ccmtrMeteringConfig=ccmtrMeteringConfig, ccmtrCollectionRetries=ccmtrCollectionRetries, ccmtrCollectionDataPerSession=ccmtrCollectionDataPerSession, ccmtrCollectionEntry=ccmtrCollectionEntry, ccmtrCollectionDestination=ccmtrCollectionDestination, ccmtrCollectionPort=ccmtrCollectionPort, ciscoCableMeteringMIBGroups=ciscoCableMeteringMIBGroups, ciscoCableMeteringMIBConformance=ciscoCableMeteringMIBConformance, CcmtrCollectionServer=CcmtrCollectionServer, ccmtrMeteringRateCtrlObjGroup=ccmtrMeteringRateCtrlObjGroup, ccmtrCollectionTimestamp=ccmtrCollectionTimestamp, ccmtrCollectionDataTimer=ccmtrCollectionDataTimer, ccmtrMetering=ccmtrMetering, ccmtrCollectionRowStatus=ccmtrCollectionRowStatus, ccmtrCollectionRevInterval=ccmtrCollectionRevInterval, ciscoCableMeteringCompliance=ciscoCableMeteringCompliance, ciscoCableMeteringComplianceRev1=ciscoCableMeteringComplianceRev1, ccmtrCollectionInterval=ccmtrCollectionInterval, ccmtrCollectionAggregate=ccmtrCollectionAggregate, ccmtrMeteringNotifCtrlGroup=ccmtrMeteringNotifCtrlGroup, ccmtrCollectionSecure=ccmtrCollectionSecure, ccmtrCollectionCpeList=ccmtrCollectionCpeList, ccmtrMeteringNotifGroup=ccmtrMeteringNotifGroup, ccmtrCollectionID=ccmtrCollectionID, CcmtrStatus=CcmtrStatus, ccmtrCollectionType=ccmtrCollectionType, ccmtrMeteringObjGroup=ccmtrMeteringObjGroup, ccmtrMeteringNotifEnable=ccmtrMeteringNotifEnable, ccmtrMeteringSrcIntfObjGroup=ccmtrMeteringSrcIntfObjGroup, ciscoCableMeteringMIBObjects=ciscoCableMeteringMIBObjects, ciscoCableMeteringMIBCompliances=ciscoCableMeteringMIBCompliances, ccmtrCollectionFilesystem=ccmtrCollectionFilesystem, ccmtrCollectionNotification=ccmtrCollectionNotification, ciscoCableMeteringMIBNotifs=ciscoCableMeteringMIBNotifs, ccmtrCollectionTable=ccmtrCollectionTable, PYSNMP_MODULE_ID=ciscoCableMeteringMIB)

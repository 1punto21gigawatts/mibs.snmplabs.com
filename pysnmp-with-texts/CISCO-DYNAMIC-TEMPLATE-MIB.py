#
# PySNMP MIB module CISCO-DYNAMIC-TEMPLATE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-DYNAMIC-TEMPLATE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:56:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ValueSizeConstraint")
CbpElementName, = mibBuilder.importSymbols("CISCO-CBP-TC-MIB", "CbpElementName")
DynamicTemplateTargetType, DynamicTemplateType, DynamicTemplateTargetId, DynamicTemplateName = mibBuilder.importSymbols("CISCO-DYNAMIC-TEMPLATE-TC-MIB", "DynamicTemplateTargetType", "DynamicTemplateType", "DynamicTemplateTargetId", "DynamicTemplateName")
UnicastRpfOptions, UnicastRpfType = mibBuilder.importSymbols("CISCO-IP-URPF-MIB", "UnicastRpfOptions", "UnicastRpfType")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
CiscoVrfName, = mibBuilder.importSymbols("CISCO-TC", "CiscoVrfName")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressPrefixLength, InetAddressIPv6, InetAddressIPv4 = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressPrefixLength", "InetAddressIPv6", "InetAddressIPv4")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
iso, Unsigned32, Counter64, ModuleIdentity, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, NotificationType, TimeTicks, MibIdentifier, Counter32, ObjectIdentity, IpAddress, Gauge32 = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "Unsigned32", "Counter64", "ModuleIdentity", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "NotificationType", "TimeTicks", "MibIdentifier", "Counter32", "ObjectIdentity", "IpAddress", "Gauge32")
StorageType, TextualConvention, MacAddress, DisplayString, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "TextualConvention", "MacAddress", "DisplayString", "TruthValue", "RowStatus")
ciscoDynamicTemplateMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 784))
ciscoDynamicTemplateMIB.setRevisions(('2007-09-06 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoDynamicTemplateMIB.setRevisionsDescriptions(('The initial version of the MIB module.',))
if mibBuilder.loadTexts: ciscoDynamicTemplateMIB.setLastUpdated('200709060000Z')
if mibBuilder.loadTexts: ciscoDynamicTemplateMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoDynamicTemplateMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 Tel: +1 800 553-NETS E-mail: cs-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoDynamicTemplateMIB.setDescription('This MIB defines objects that describe dynamic templates. A dynamic template is a set of configuration attributes that a system can dynamically apply to a target. The target of a dynamic template is the entity configured by the system using the configuration attributes contained by a template. At the time of this writing, an interface represents the only valid target of a dynamic template. However, the architecture does not prevent other target types, and hence, the MIB definition generalizes the notion of a target to allow for this. Generally, the system does not directly apply the attributes contained by a dynamic template to an associated target. The system might generate a derived configuration from the set of dynamic templates associated with the target. A derived configuration represents the union of the configuration attributes contained by each associated dynamic template. In the case of a conflict (i.e., more than one dynamic template specifies the same configuration attribute), the system accepts the configuration attribute from the dynamic template with the highest precedence.')
ciscoDynamicTemplateMIBNotifs = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 0))
ciscoDynamicTemplateMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1))
ciscoDynamicTemplateMIBConform = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 2))
cdtBase = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1))
cdtCommonIf = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2))
cdtPpp = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3))
cdtEthernet = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4))
cdtIpSubscriber = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 5))
cdtService = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6))
cdtSubscriberGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 7))
cdtTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1), )
if mibBuilder.loadTexts: cdtTemplateTable.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateTable.setDescription('This table lists the dynamic templates maintained by the system, including those that have been locally-configured on the system and those pushed to the system by external policy servers.')
cdtTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"))
if mibBuilder.loadTexts: cdtTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateEntry.setDescription("An entry describes a dynamic template, which serves as a container for configuration attributes. The configuration attributes contained by a dynamic template depends on its type. The system automatically creates a corresponding entry when a dynamic template has been created through another management entity (e.g., the system's local console). Likewise, the system automatically destroys a corresponding entry when a dynamic template has been destroyed through another management entity. The system automatically creates a corresponding entry when an external policy server pushes a user profile or a service profile to the system. The system automatically creates a corresponding entry when it generates a derived configuration.")
cdtTemplateName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1, 1, 1), DynamicTemplateName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdtTemplateName.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateName.setDescription("This object indicates a string-value that uniquely identifies the dynamic template. If the corresponding instance of cdtTemplateSrc is not 'local', then the system automatically generates the name identifying the dynamic template.")
cdtTemplateStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtTemplateStatus.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateStatus.setDescription("This object specifies the status of the dynamic template. The following columns must be valid before activating a dynamic template: - cdtTemplateStorage - cdtTemplateType However, these objects specify a default value. Thus, it is possible to use create-and-go semantics without setting any additional columns. An implementation must allow the EMS/NMS to modify any column when this column is 'active', including columns defined in tables that have a one-to-one or sparse dependent relationship on this table.")
cdtTemplateStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1, 1, 3), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtTemplateStorage.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateStorage.setDescription("This object specifies what happens to the dynamic template upon restart. If the corresponding instance of cdtTemplateSrc is not 'local', then this column must be 'volatile'.")
cdtTemplateType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1, 1, 4), DynamicTemplateType().clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtTemplateType.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateType.setDescription('This object indicates the types of dynamic template.')
cdtTemplateSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("other", 1), ("derived", 2), ("local", 3), ("aaaUserProfile", 4), ("aaaServiceProfile", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdtTemplateSrc.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateSrc.setDescription("This object specifies the source of the dynamic template: 'other' The implementation of the MIB module does not recognize the source of the dynamic template. 'derived' The system created the set of attributes from one or more dynamic templates. 'local' The dynamic template was locally configured through a management entity, such as the local console or a SNMP entity. 'aaaUserProfile' The dynamic template originated from a user profile pushed from an external policy server. 'aaaServiceProfile' The dynamic template originated from a service profile pushed from an external policy server.")
cdtTemplateUsageCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdtTemplateUsageCount.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateUsageCount.setDescription('This object specifies the number of targets using a dynamic template')
cdtTemplateTargetTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 2), )
if mibBuilder.loadTexts: cdtTemplateTargetTable.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateTargetTable.setDescription('This table contains a list of targets associated with one or more dynamic templates.')
cdtTemplateTargetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateTargetType"), (0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateTargetId"))
if mibBuilder.loadTexts: cdtTemplateTargetEntry.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateTargetEntry.setDescription('An entry describes a target associated with one or more dynamic templates. The system automatically creates an entry when it associates a dynamic template to a target. Likewise, the system automatically destroys an entry when a target no longer has any associated dynamic templates.')
cdtTemplateTargetType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 2, 1, 1), DynamicTemplateTargetType())
if mibBuilder.loadTexts: cdtTemplateTargetType.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateTargetType.setDescription('This object indicates the type of target.')
cdtTemplateTargetId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 2, 1, 2), DynamicTemplateTargetId())
if mibBuilder.loadTexts: cdtTemplateTargetId.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateTargetId.setDescription('This object uniquely identifies the target within the scope of its type.')
cdtTemplateTargetStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtTemplateTargetStatus.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateTargetStatus.setDescription("This object specifies the status of the dynamic template target. The following columns must be valid before activating a subscriber access profile: - cdtTemplateTargetStorage However, these objects specify a default value. Thus, it is possible to use create-and-go semantics without setting any additional columns. An implementation must allow the EMS/NMS to modify any column when this column is 'active', including columns defined in tables that have a one-to-one or sparse dependent relationship on this table.")
cdtTemplateTargetStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 2, 1, 4), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtTemplateTargetStorage.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateTargetStorage.setDescription('This object specifies what happens to the dynamic template target upon restart.')
cdtTemplateAssociationTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 3), )
if mibBuilder.loadTexts: cdtTemplateAssociationTable.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateAssociationTable.setDescription('This table contains a list of templates associated with each target. This table has an expansion dependent relationship on the cdtTemplateTargetTable, containing zero or more rows for each target.')
cdtTemplateAssociationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 3, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateTargetType"), (0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateTargetId"), (0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateAssociationName"))
if mibBuilder.loadTexts: cdtTemplateAssociationEntry.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateAssociationEntry.setDescription('An entry indicates an association of a dynamic template with a target. The system automatically creates an entry when it associates a dynamic template to a target. The system also creates an entry when it derives the configuration that it applies to a target. The system automatically destroys an entry under the following circumstances: 1) The target indicated by the entry no longer exists. 2) The association between the target and the dynamic template no longer exists.')
cdtTemplateAssociationName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 3, 1, 1), DynamicTemplateName()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdtTemplateAssociationName.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateAssociationName.setDescription('This object indicates the name of the template associated with the target.')
cdtTemplateAssociationPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdtTemplateAssociationPrecedence.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateAssociationPrecedence.setDescription('This object indicates the relative precedence of the associated dynamic template. Lower values have higher precedence than higher values.')
cdtTemplateUsageTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 4), )
if mibBuilder.loadTexts: cdtTemplateUsageTable.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateUsageTable.setDescription('This table contains a list of targets using each dynamic template. This table has an expansion dependent relationship on the cdtTemplateTable, containing zero or more rows for each dynamic template.')
cdtTemplateUsageEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"), (0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateUsageTargetType"), (0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateUsageTargetId"))
if mibBuilder.loadTexts: cdtTemplateUsageEntry.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateUsageEntry.setDescription('An entry indicates a target using the dynamic template. The system automatically creates an entry when it associates a dynamic template to a target. The system also creates an entry when it derives the configuration that it applies to a target. The system automatically destroys an entry under the following circumstances: 1) The target indicated by the entry no longer exists. 2) The association between the target and the dynamic template no longer exists.')
cdtTemplateUsageTargetType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 4, 1, 1), DynamicTemplateTargetType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdtTemplateUsageTargetType.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateUsageTargetType.setDescription('This object indicates the type of target using the dynamic template.')
cdtTemplateUsageTargetId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 4, 1, 2), DynamicTemplateTargetId()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cdtTemplateUsageTargetId.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateUsageTargetId.setDescription('This object indicates the name of the target using the dynamic template')
cdtTemplateCommonTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5), )
if mibBuilder.loadTexts: cdtTemplateCommonTable.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateCommonTable.setDescription("This table contains attributes relating to all dynamic templates. Observe that the type of dynamic templates containing these attributes may change with the addition of new dynamic template types. This table has a sparse-dependent relationship on the cdtTemplateTable, containing a row for each dynamic template having a cdtTemplateType of one of the following values: 'derived' 'ppp' 'ethernet' 'ipSubscriber' 'service'")
cdtTemplateCommonEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"))
if mibBuilder.loadTexts: cdtTemplateCommonEntry.setStatus('current')
if mibBuilder.loadTexts: cdtTemplateCommonEntry.setDescription("An entry containing attributes relating to any target. The system automatically creates an entry when the system or the EMS/NMS creates a row in the cdtTemplateTable with a cdtTemplateType of on the following values: 'derived' 'ppp' 'ethernet' 'ipSubscriber' 'service' Likewise, the system automatically destroys an entry when the system or the EMS/NMS destroys the corresponding row in the cdtTemplateTable.")
cdtCommonValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 1), Bits().clone(namedValues=NamedValues(("descr", 0), ("keepalive", 1), ("vrf", 2), ("addrPool", 3), ("ipv4AccessGroup", 4), ("ipv4Unreachables", 5), ("ipv6AccessGroup", 6), ("ipv6Unreachables", 7), ("srvSubControl", 8), ("srvRedirect", 9), ("srvAcct", 10), ("srvQos", 11), ("srvNetflow", 12)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonValid.setStatus('current')
if mibBuilder.loadTexts: cdtCommonValid.setDescription("This object specifies which attributes in the dynamic template have been configured to valid values. Each bit in this bit string corresponds to a column in this table. If the bit is '0', then the value of the corresponding column is not valid. If the bit is '1', then the value of the corresponding column has been configured to a valid value. The following list specifies the mappings between bits and the columns: 'descr' => cdtCommonDescr 'keepaliveInt' => cdtCommonKeepaliveInt 'keepaliveRetries' => cdtCommonKeepaliveRetries 'vrf' => cdtCommonVrf 'addrPool' => cdtCommonAddrPool 'ipv4AccessGroup' => cdtCommonIpv4AccessGroup 'ipv4Unreachables' => cdtCommonIpv4Unreachables 'ipv6AccessGroup' => cdtCommonIpv6AccessGroup 'ipv6Unreachables' => cdtCommonIpv6Unreachables 'srvSubControl' => cdtCommonSrvSubControl 'srvRedirect' => cdtCommonSrvRedirect 'srvAcct' => cdtCommonSrvAcct 'srvQos' => cdtCommonSrvQos 'srvNetflow' => cdtCommonSrvNetflow")
cdtCommonDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonDescr.setStatus('current')
if mibBuilder.loadTexts: cdtCommonDescr.setDescription("This object specifies a human-readable description for the dynamic template. This column is valid only if the 'descr' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonKeepaliveInt = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonKeepaliveInt.setStatus('current')
if mibBuilder.loadTexts: cdtCommonKeepaliveInt.setDescription("This object specifies the interval that the system sends keepalive messages to a target. This column is valid only if the 'keepaliveInterval' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonKeepaliveRetries = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(5)).setUnits('retries').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonKeepaliveRetries.setStatus('current')
if mibBuilder.loadTexts: cdtCommonKeepaliveRetries.setDescription("This object specifies the number of times the system will resend a keepalive message without a response before it transitions a target to an operationally down state. This column is valid only if the 'keepaliveRetries' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonVrf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 5), CiscoVrfName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonVrf.setStatus('current')
if mibBuilder.loadTexts: cdtCommonVrf.setDescription("This object specifies the name of the VRF with which a target has an association. This column is valid only if the 'vrf' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonAddrPool = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 6), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonAddrPool.setStatus('current')
if mibBuilder.loadTexts: cdtCommonAddrPool.setDescription("This object specifies the name of the IP address pool the system will use to assign an IP address to a peer of a target. This column is valid only if the 'addrPool' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonIpv4AccessGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 7), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonIpv4AccessGroup.setStatus('current')
if mibBuilder.loadTexts: cdtCommonIpv4AccessGroup.setDescription("This object specifies the name (or number) of the IPv4 ACL applied to a target. This column is valid only if the 'ipv4AccessGroup' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonIpv4Unreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 8), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonIpv4Unreachables.setStatus('current')
if mibBuilder.loadTexts: cdtCommonIpv4Unreachables.setDescription("This object specifies whether a target generates ICMPv4 unreachable messages. This column is valid only if the 'ipv4Unreachables' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonIpv6AccessGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonIpv6AccessGroup.setStatus('current')
if mibBuilder.loadTexts: cdtCommonIpv6AccessGroup.setDescription("This object specifies the name (or number) of the IPv4 ACL applied to a target. This column is valid only if the 'ipv6AccessGroup' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonIpv6Unreachables = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 10), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonIpv6Unreachables.setStatus('current')
if mibBuilder.loadTexts: cdtCommonIpv6Unreachables.setDescription("This object specifies whether a target generates ICMPv6 unreachable messages. This column is valid only if the 'ipv6Unreachables' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonSrvSubControl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 11), CbpElementName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonSrvSubControl.setStatus('current')
if mibBuilder.loadTexts: cdtCommonSrvSubControl.setDescription("This object specifies the name of the subscriber control policy applied to a target. The system should assume that the cbpPolicyMapType (defined by the CISCO-CBP-BASE-CFG-MIB) of the policy is cbpPmtControlSubscriber (defined by the CISCO-CBP-TYPE-OID-MIB). This column is valid only if the 'srvSubControl' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonSrvRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 12), CbpElementName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonSrvRedirect.setStatus('current')
if mibBuilder.loadTexts: cdtCommonSrvRedirect.setDescription("This object specifies the name of the traffic redirect policy applied to a target. The system should assume that the cbpPolicyMapType (defined by the CISCO-CBP-BASE-CFG-MIB) of the policy is cbpPmtTrafficRedirect (defined by the CISCO-CBP-TYPE-OID-MIB). This column is valid only if the 'srvRedirect' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonSrvAcct = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 13), CbpElementName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonSrvAcct.setStatus('current')
if mibBuilder.loadTexts: cdtCommonSrvAcct.setDescription("This object specifies the name of the traffic accounting policy applied to a target. The system should assume that the cbpPolicyMapType (defined by the CISCO-CBP-BASE-CFG-MIB) of the policy is cbpPmtTrafficAccounting (defined by the CISCO-CBP-TYPE-OID-MIB). This column is valid only if the 'srvAcct' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonSrvQos = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 14), CbpElementName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonSrvQos.setStatus('current')
if mibBuilder.loadTexts: cdtCommonSrvQos.setDescription("This object specifies the name of the traffic QoS policy applied to a target. The system should assume that the cbpPolicyMapType (defined by the CISCO-CBP-BASE-CFG-MIB) of the policy is cbpPmtQos (defined by the CISCO-CBP-TYPE-OID-MIB). This column is valid only if the 'srvQos' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtCommonSrvNetflow = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 1, 5, 1, 15), CbpElementName()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtCommonSrvNetflow.setStatus('current')
if mibBuilder.loadTexts: cdtCommonSrvNetflow.setDescription("This object specifies the name of the NetFlow policy applied to a target. The system should assume that the cbpPolicyMapType (defined by the CISCO-CBP-BASE-CFG-MIB) of the policy is cbpPmtNetflow (defined by the CISCO-CBP-TYPE-OID-MIB). This column is valid only if the 'srvNetflow' bit of the corresponding instance of cdtCommonValid is '1'.")
cdtIfTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1), )
if mibBuilder.loadTexts: cdtIfTemplateTable.setStatus('current')
if mibBuilder.loadTexts: cdtIfTemplateTable.setDescription("This table contains attributes relating to interface configuration. This table has a sparse-dependent relationship on the cdtTemplateTable, containing a row for each dynamic template having a cdtTemplateType of one of the following values: 'derived' 'ppp' 'ethernet' 'ipSubscriber'")
cdtIfTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"))
if mibBuilder.loadTexts: cdtIfTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: cdtIfTemplateEntry.setDescription("An entry containing attributes relating to interface configuration. The system automatically creates an entry when the system or the EMS/NMS creates a row in the cdtTemplateTable with a cdtTemplateType of one of the following values: 'derived' 'ppp' 'ethernet' 'ipSubscriber' Likewise, the system automatically destroys an entry when the system or the EMS/NMS destroys the corresponding row in the cdtTemplateTable.")
cdtIfValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 1), Bits().clone(namedValues=NamedValues(("mtu", 0), ("cdpEnable", 1), ("flowMonitor", 2), ("ipv4Unnumbered", 3), ("ipv4SubEnable", 4), ("ipv4Mtu", 5), ("ipv4TcpMssAdjust", 6), ("ipv4VerifyUniRpf", 7), ("ipv4VerifyUniRpfAcl", 8), ("ipv4VerifyUniRpfOpts", 9), ("ipv6Enable", 10), ("ipv6SubEnable", 11), ("ipv6TcpMssAdjust", 12), ("ipv6VerifyUniRpf", 13), ("ipv6VerifyUniRpfAcl", 14), ("ipv6VerifyUniRpfOpts", 15), ("ipv6NdPrefix", 16), ("ipv6NdValidLife", 17), ("ipv6NdPreferredLife", 18), ("ipv6NdOpts", 19), ("ipv6NdDadAttempts", 20), ("ipv6NdNsInterval", 21), ("ipv6NdReachableTime", 22), ("ipv6NdRaIntervalMax", 23), ("ipv6NdRaIntervalMin", 24), ("ipv6NdRaLife", 25), ("ipv6NdRaRouterPreference", 26)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfValid.setStatus('current')
if mibBuilder.loadTexts: cdtIfValid.setDescription("This object specifies which attributes in the dynamic template have been configured to valid values. Each bit in this bit string corresponds to a column in this table. If the bit is '0', then the value of the corresponding column is not valid. If the bit is '1', then the value of the corresponding column has been configured to a valid value. The following list specifies the mappings between bits and the columns: 'mtu' => cdtIfMtu 'cdpEnable' => cdtIfCdpEnable 'flowMonitor' => cdtIfFlowMonitor 'ipv4Unnumbered' => cdtIfIpv4Unnumbered 'ipv4SubEnable' => cdtIfIpv4SubEnable 'ipv4Mtu' => cdtIfIpv4Mtu 'ipv4TcpMssAdjust' => cdtIfIpv4TcpMssAdjust 'ipv4VerifyUniRpf' => cdtIfIpv4VerifyUniRpf 'ipv4VerifyUniRpfAcl' => cdtIfIpv4VerifyUniRpfAcl 'ipv4VerifyUniRpfOpts' => cdtIfIpv4VerifyUniRpfOpts 'ipv6Enable' => cdtIfIpv6Enable 'ipv6SubEnable' => cdtIfIpv6SubEnable 'ipv6TcpMssAdjust' => cdtIfIpv6TcpMssAdjust 'ipv6VerifyUniRpf' => cdtIfIpv6VerifyUniRpf 'ipv6VerifyUniRpfAcl' => cdtIfIpv6VerifyUniRpfAcl 'ipv6VerifyUniRpfOpts' => cdtIfIpv6VerifyUniRpfOpts 'ipv6NdPrefix' => cdtIfIpv6NdPrefix, cdtIfIpv6NdPrefixLength 'ipv6NdValidLife' => cdtIfIpv6NdValidLife 'ipv6NdPreferredLife' => cdtIfIpv6NdPreferredLife 'ipv6NdOpts' => cdtIfIpv6NdOpts 'ipv6NdDadAttempts' => cdtIfIpv6NdDadAttempts 'ipv6NdNsInterval' => cdtIfIpv6NdNsInterval 'ipv6NdReacableTime' => cdtIfIpv6NdReacableTime 'ipv6NdRaIntervalMax' => cdtIfIpv6NdRaIntervalUnits, cdtIfIpv6NdRaIntervalMax 'ipv6NdRaIntervalMin' => cdtIfIpv6NdRaIntervalMin 'ipv6NdRaLife' => cdtIfIpv6NdRaLife 'ipv6NdRouterPreference'' => cdtIfIpv6NdRouterPreference")
cdtIfMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(64, 65535), ))).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfMtu.setStatus('current')
if mibBuilder.loadTexts: cdtIfMtu.setDescription("This object specifies the Maximum Transfer Unit (MTU) size for all packets sent on the target interface. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This column is valid only if the 'mtu' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfCdpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfCdpEnable.setStatus('current')
if mibBuilder.loadTexts: cdtIfCdpEnable.setDescription("This object specifies whether the target interface participates in the Cisco Discovery Protocol (CDP). This column is valid only if the 'cdpEnable' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfFlowMonitor = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfFlowMonitor.setStatus('current')
if mibBuilder.loadTexts: cdtIfFlowMonitor.setDescription("This object specifies the name of the flow monitor associated with the target interface. This column is valid only if the 'flowMonitor' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv4Unnumbered = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv4Unnumbered.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv4Unnumbered.setDescription("This object specifies the interface of the source address that the target interface uses when originating IPv4 packets. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid (e.g., immediately following the creation of an instance of the object). This column is valid only if the 'ipv4Unnumbered' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv4SubEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv4SubEnable.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv4SubEnable.setDescription("This object specifies whether the target interface allows IPv4 subscriber sessions. This column is valid only if the 'ipv4SubEnable' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv4Mtu = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(128, 65535), ))).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv4Mtu.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv4Mtu.setDescription("This object specifies the Maximum Transfer Unit (MTU) size for IPv4 packets sent on the target interface. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This column is valid only if the 'ipv4Mtu' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv4TcpMssAdjust = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(500, 1460), ))).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv4TcpMssAdjust.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv4TcpMssAdjust.setDescription("This object specifies the adjustment to the Maximum Segment Size (MSS) of TCP SYN packets received by the target interface contained in IPv4 datagrams. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This column is valid only if the 'ipv4TcpMssAdjust' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv4VerifyUniRpf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 9), UnicastRpfType().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv4VerifyUniRpf.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv4VerifyUniRpf.setDescription("This object specifies whether the type of unicast RPF the system performs on IPv4 packets received by the target interface. This column is valid only if the 'ipv4VerifyUniRpf' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv4VerifyUniRpfAcl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 10), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv4VerifyUniRpfAcl.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv4VerifyUniRpfAcl.setDescription("This object specifies the name (or number) of the IPv4 ACL used to determine whether the system should permit/deny packets received by the target interface that fail unicast RPF verification. This column is valid only if the 'ipv4VerifyUniRpfAcl' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv4VerifyUniRpfOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 11), UnicastRpfOptions()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv4VerifyUniRpfOpts.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv4VerifyUniRpfOpts.setDescription("This object specifies the options that affect how the system performs unicast RPF on IPv4 packets received by the target interface. This column is valid only if the 'ipv4VerifyUniRpfOpts' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6Enable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 12), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6Enable.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6Enable.setDescription("This object specifies whether the system processes IPv6 packets received by the target interface. This column is valid only if the 'ipv6Enable' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6SubEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 13), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6SubEnable.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6SubEnable.setDescription("This object specifies whether the target interface allows IPv6 subscriber sessions. This column is valid only if the 'ipv6SubEnable' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6TcpMssAdjust = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 14), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(500, 1460), ))).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6TcpMssAdjust.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6TcpMssAdjust.setDescription("This object specifies the adjustment to the Maximum Segment Size (MSS) of TCP SYN packets received by the target interface contained in IPv6 datagrams. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This column is valid only if the 'ipv6TcpMssAdjust' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6VerifyUniRpf = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 15), UnicastRpfType().clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6VerifyUniRpf.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6VerifyUniRpf.setDescription("This object specifies whether the type of unicast RPF the system performs on IPv6 packets received by the target interface. This column is valid only if the 'ipv6VerifyUniRpf' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6VerifyUniRpfAcl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 16), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6VerifyUniRpfAcl.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6VerifyUniRpfAcl.setDescription("This object specifies the name (or number) of the IPv6 ACL used to determine whether the system should permit/deny packets received by the target interface that fail unicast RPF verification. This column is valid only if the 'ipv6VerifyUniRpfAcl' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6VerifyUniRpfOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 17), UnicastRpfOptions()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6VerifyUniRpfOpts.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6VerifyUniRpfOpts.setDescription("This object specifies the options that affect how the system performs unicast RPF on IPv6 packets received by the target interface. This column is valid only if the 'ipv6VerifyUniRpfOpts' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdPrefix = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 18), InetAddressIPv6().clone(hexValue="00000000000000000000000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdPrefix.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdPrefix.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdPrefix.setDescription("This object specifies the IPv6 network number included in IPv6 router advertisements sent on the target interface. This column is valid only if the 'ipv6NdPrefix' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdPrefixLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 19), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdPrefixLength.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdPrefixLength.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdPrefixLength.setDescription("This object specifies the length of the IPv6 prefix specified by the corresponding instance of cdtIpv6NdPrefix. This column is valid only if the 'ipv6NdPrefix' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdValidLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(2592000)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdValidLife.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdValidLife.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdValidLife.setDescription("This object specifies the interval that the system advertises the IPv6 prefix (i.e., the corresponding instance of cdtIfIpv6NdPrefix) as 'valid' for IPv6 router advertisements sent on the target interface. This column is valid only if the 'ipv6NdValidLife' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdPreferredLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(604800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdPreferredLife.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdPreferredLife.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdPreferredLife.setDescription("This object specifies the interval that the system advertises the IPv6 prefix (i.e., the corresponding instance of cdtIfIpv6NdPrefix) as 'preferred' for IPv6 router advertisements sent on the target interface. This column is valid only if the 'ipv6NdPreferredLife' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 22), Bits().clone(namedValues=NamedValues(("advertise", 0), ("onlink", 1), ("router", 2), ("autoConfig", 3), ("advertisementInterval", 4), ("managedConfigFlag", 5), ("otherConfigFlag", 6), ("framedIpv6Prefix", 7), ("raSuppress", 8))).clone(namedValues=NamedValues(("advertise", 0), ("onlink", 1), ("router", 2), ("autoConfig", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdOpts.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdOpts.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdOpts.setDescription("This object specifies options that affect advertisements sent on the target interface: 'advertise' This option specifies that the system should advertise the IPv6 prefix (i.e., the corresponding instance of cdtIfIpv6NdPrefix). 'onlink' This option specifies that the IPv6 prefix has been assigned to a link. If set to '0', the system advertises the IPv6 prefix as 'offlink'. 'router' This option indicates that the router will send the full router address and not set the 'R' bit in prefix advertisements. 'autoConfig' This option indicates to hosts on the local link that the specified prefix supports IPv6 auto-configuration. 'advertisementInterval' This option specifies the advertisement interval option in router advertisements sent on the target interface. 'managedConfigFlag' This option causes the system to set the 'managed address configuration flag' in router advertisements sent on the target interface. 'otherConfigFlag' This option causes the system to set the 'other stateful configuration' flag in router advertisements sent on the target interface. 'frameIpv6Prefix' This option causes the system to add the prefix in a received RADIUS framed IPv6 prefix attribute to the target interface's neighbor discovery prefix queue and includes it in router advertisements sent on the target interface. 'raSupress' This option suppresses the transmission of router advertisements on the target interface. This column is valid only if the 'ipv6NdOpts' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdDadAttempts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 600)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdDadAttempts.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdDadAttempts.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdDadAttempts.setDescription("This object specifies the number of consecutive neighbor solitication messages the system sends on the target interface while performing duplicate address detection on unicast IPv6 addresses on the target interface. The value '0' disables duplicate address detection on the target interface. This column is valid only if the 'ipv6NdDadAttempts' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdNsInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1000, 3600000)).clone(1000)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdNsInterval.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdNsInterval.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdNsInterval.setDescription("This object specifies the interval between neighbor solicitation retransmissions on the target interface. This column is valid only if the 'ipv6NdNsIntervals' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdReachableTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdReachableTime.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdReachableTime.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdReachableTime.setDescription("This object specifies the amount of time the system considers a neighbor of the target interface reachable after a reachability confirmation event has occurred. The value '0' disables neighbor reachability detection on the target interface. This column is valid only if the 'ipv6NdReachable' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdRaIntervalUnits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("seconds", 1), ("milliseconds", 2))).clone('seconds')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalUnits.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalUnits.setDescription("This object specifies the units of time for the corresponding instances of cdtIfIpv6NdRaIntervalMin and cdtIfIpv6NdRaIntervalMax. This column is valid only if the 'ipv6NdRaInterval' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdRaIntervalMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalMax.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalMax.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalMax.setDescription("This object specifies the maximum interval between IPv6 router advertisements sent on the target interface. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This column is valid only if the 'ipv6NdRaInterval' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdRaIntervalMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 28), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalMin.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalMin.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdRaIntervalMin.setDescription("This object specifies the minimum interval between IPv6 router advertisements sent on the target interface. The value of this column has the following restrictions: 1) This value cannot be less than 75% of the value specified for cdtIfIpv6NdRaIntervalMax. 2) If the corresponding instance of cdtIfIpv6NdRaIntervalUnits is 'seconds', then this value cannot be less than '3'. 3) If the corresponding instance of cdtIfIpv6NdRaIntervalUnits is 'milliseconds', then this value cannot be less than '30'. If the target interface template does not specify this value, then the system automatically assumes a minimum interval that is 75% of the corresponding instance of cdtIfIpv6NdRaIntervalMax. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This column is valid only if the 'ipv6NdRaInterval' bit of the corresponding instance of cdtIfValid is '1'.")
cdtIfIpv6NdRaLife = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 29), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)).clone(1800)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdRaLife.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdRaLife.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdRaLife.setDescription("This object specifies the router lifetime value in IPv6 router advertisements sent on the target interface. The value '0' specifies that neighbors should not consider the router as a default router.")
cdtIfIpv6NdRouterPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 2, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("high", 1), ("medium", 2), ("low", 3))).clone('medium')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtIfIpv6NdRouterPreference.setReference("T. Narten, E. Nordmark, W. Simpson, H. Soliman, 'Neighbor Discovery for IP version 6 (IPv6)', RFC-4861, September 2007.")
if mibBuilder.loadTexts: cdtIfIpv6NdRouterPreference.setStatus('current')
if mibBuilder.loadTexts: cdtIfIpv6NdRouterPreference.setDescription("This object specifies the Default Router Preference (DRP) for the router on the target interface. This column is valid only if the 'ipv6NdRouterPreference' bit of the corresponding instance of cdtIfValid is '1'.")
cdtPppTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1), )
if mibBuilder.loadTexts: cdtPppTemplateTable.setStatus('current')
if mibBuilder.loadTexts: cdtPppTemplateTable.setDescription("This table contains attributes relating to PPP connection configuration. This table has a sparse-dependent relationship on the cdtTemplateTable, containing a row for each dynamic template having a cdtTemplateType of one of the following values: 'derived' 'ppp'")
cdtPppTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"))
if mibBuilder.loadTexts: cdtPppTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: cdtPppTemplateEntry.setDescription("An entry containing attributes relating to PPP connection configuration. The system automatically creates an entry when the system or the EMS/NMS creates a row in the cdtTemplateTable with a cdtTemplateType of one of the following values: 'derived' 'ppp' Likewise, the system automatically destroys an entry when the system or the EMS/NMS destroys the corresponding row in the cdtTemplateTable.")
cdtPppValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 1), Bits().clone(namedValues=NamedValues(("valid", 0), ("accounting", 1), ("authentication", 2), ("autthenticationMethods", 3), ("authorization", 4), ("loopbackIgnore", 5), ("maxBadAuth", 6), ("maxConfigure", 7), ("maxFailure", 8), ("maxTerminate", 9), ("timeoutAuthentication", 10), ("timeoutRetry", 11), ("chapOpts", 12), ("chapHostname", 13), ("chapPassword", 14), ("msChapV1Opts", 15), ("msChapV1Hostname", 16), ("msChapV1Password", 17), ("msChapV2Opts", 18), ("msChapV2Hostname", 19), ("msChapV2Password", 20), ("papOpts", 21), ("papUsername", 22), ("papPassword", 23), ("eapOpts", 24), ("eapIdentity", 25), ("eapPassword", 26), ("ipcpAddrOption", 27), ("ipcpDnsOption", 28), ("ipcpDnsPrimary", 29), ("ipcpDnsSecondary", 30), ("ipcpWinsOption", 31), ("ipcpWinsPrimary", 32), ("ipcpWinsSecondary", 33), ("ipcpMaskOption", 34), ("ipcpMask", 35), ("peerDefIpAddrOpts", 36), ("peerDefIpAddrSrc", 37), ("peerDefIpAddr", 38)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppValid.setStatus('current')
if mibBuilder.loadTexts: cdtPppValid.setDescription("This object specifies which attributes in the dynamic template have been configured to valid values. Each bit in this bit string corresponds to a column in this table. If the bit is '0', then the value of the corresponding column is not valid. If the bit is '1', then the value of the corresponding column has been configured to a valid value. The following list specifies the mappings between bits and the columns: accounting => cdtPppAccounting authentication => cdtPppAuthentication authenticationMethods => cdtPppAuthenticationMethods authorization => cdtPppAuthorization loopbackIgnore => cdtPppLoopbackIgnore maxBadAuth => cdtPppMaxBadAuth maxConfigure => cdtPppMaxConfigure maxFailure => cdtPppMaxFailure maxTerminate => cdtPppMaxTerminate timeoutAuthentication => cdtPppTimeoutAuthentication timeoutRetry => cdtPppTimeoutRetry chapOpts => cdtPppChapOpts chapHostname => cdtPppChapHostname chapPassword => cdtPppChapPassword msChapV1Opts => cdtPppMsChapV1Opts msChapV1Hostname => cdtPppMsChapV1Hostname msChapV1Password => cdtPppMsChapV1Password msChapV2Opts => cdtPppMsChapV2Opts msChapV2Hostname => cdtPppMsChapV2Hostname msChapV2Password => cdtPppMsChapV2Password papOpts => cdtPppPapOpts papSentUsername => cdtPppPapUsername papSentPassword => cdtPppPapPassword eapOpts => cdtPppEapOpts eapIdentity => cdtPppEapIdentity eapPassword => cdtPppEapPassword ipcpAddrOption => cdtPppIpcpAddrOption ipcpDnsOption => cdtPppIpcpDnsOption ipcpDnsPrimary => cdtPppIpcpDnsPrimary ipcpDnsSecondary => cdtPppIpcpDnsSecondary ipcpWinsOption => cdtPppIpcpWinsOption ipcpWinsPrimary => cdtPppIpcpWinsPrimary ipcpWinsSecondary => cdtPppIpcpWinsSecondary ipcpMaskOption => cdtPppIpcpMaskOption ipcpMask => cdtPppIpcpMask peerDefIpAddrOpts => cdtPppPeerOpts peerDefIpAddrSrc => cdtPppPeerDefIpAddrSrc peerDefIpAddr => cdtPppPeerDefIpAddr")
cdtPppAccounting = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppAccounting.setStatus('current')
if mibBuilder.loadTexts: cdtPppAccounting.setDescription("This object specifies whether the system applies accounting services to the target PPP connection. This column is valid only if the 'accounting' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 3), Bits().clone(namedValues=NamedValues(("chap", 0), ("msChap", 1), ("msChapV2", 2), ("pap", 3), ("eap", 4), ("optional", 5), ("callin", 6), ("oneTime", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppAuthentication.setStatus('current')
if mibBuilder.loadTexts: cdtPppAuthentication.setDescription("This object specifies authentication services applied to a target PPP connection and other options affecting authentication services: 'chap' This option enables the Challenge Handshake Protocol (CHAP) on a target PPP connection. 'msChap' This option enables Microsoft's CHAP on a target PPP connection. 'msChapV2' This option enables version 2 of Microsoft's CHAP on a target PPP connection. 'pap' This option enables Password Authentication Protocol (PAP) on a target PPP connection. 'eap' This option enables Extensible Authentication Protocol (EAP) on a target PPP connection. 'optional' This option specifies that the system accepts the connection even if the peer of a target PPP connection refuses to accept the authentication methods the system has requested. 'callin' This option specifies that authentication should only happen for incoming calls. 'oneTime' This option specifies that the system accepts the username and password in the username field of authentication responses received on a target PPP connection. This column is valid only if the 'authentication' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppAuthenticationMethods = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppAuthenticationMethods.setStatus('current')
if mibBuilder.loadTexts: cdtPppAuthenticationMethods.setDescription("This object specifies the name of a list of authentication methods used on a target PPP connection. If the template does not include this attribute, then the system uses the default method list. This column is valid only if the 'authentication' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppAuthorization = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 5), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppAuthorization.setStatus('current')
if mibBuilder.loadTexts: cdtPppAuthorization.setDescription("This object specifies whether the system applies authorization services to a target PPP connection. This column is valid only if the 'authorization' bit of the corresponding instance of cditPppValid is '1'.")
cdtPppLoopbackIgnore = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppLoopbackIgnore.setReference("W. Simpson, 'The Point-to-Point Protocol (PPP)', RFC-1661, July 1994.")
if mibBuilder.loadTexts: cdtPppLoopbackIgnore.setStatus('current')
if mibBuilder.loadTexts: cdtPppLoopbackIgnore.setDescription("This object specifies whether the system ignores loopback on a target PPP connection. When the system ignores loopback, loopback detection is disabled. This column is valid only if the 'loopbackIgnore' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMaxBadAuth = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMaxBadAuth.setStatus('current')
if mibBuilder.loadTexts: cdtPppMaxBadAuth.setDescription("This object specifies the number of authentication failures allowed by the system before a target PPP connection is reset. The value '0' cannot be written to an instance of this object. However, it serves as a convenient value when the column is not valid. This column is valid only if the 'maxBadAuth' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMaxConfigure = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(10)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMaxConfigure.setReference("W. Simpson, 'The Point-to-Point Protocol (PPP)', RFC-1661, July 1994.")
if mibBuilder.loadTexts: cdtPppMaxConfigure.setStatus('current')
if mibBuilder.loadTexts: cdtPppMaxConfigure.setDescription("This object specifies the number of unacknowledged Configure-Request messages a target PPP connection can send before the system abandons LCP or NCP negotiations. This column is valid only if the 'maxConfigure' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMaxFailure = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMaxFailure.setReference("W. Simpson, 'The Point-to-Point Protocol (PPP)', RFC-1661, July 1994.")
if mibBuilder.loadTexts: cdtPppMaxFailure.setStatus('current')
if mibBuilder.loadTexts: cdtPppMaxFailure.setDescription("This object specifies the number of Configure-Nak messages a target PPP connection can receive before the system abandons LCP or NCP negotiations. This column is valid only if the 'maxFailure' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMaxTerminate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(2)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMaxTerminate.setReference("W. Simpson, 'The Point-to-Point Protocol (PPP)', RFC-1661, July 1994.")
if mibBuilder.loadTexts: cdtPppMaxTerminate.setStatus('current')
if mibBuilder.loadTexts: cdtPppMaxTerminate.setDescription("This object specifies the number of unacknowledged Terminate-Request messages a target PPP connection can send before the system abandons LCP or NCP negotiations. This column is valid only if the 'maxTerminate' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppTimeoutAuthentication = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(10)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppTimeoutAuthentication.setStatus('current')
if mibBuilder.loadTexts: cdtPppTimeoutAuthentication.setDescription("This objects specifies the maximum time the system will wait for a response to an authentication request on a target PPP connection. This column is valid only if the 'timeoutAuthentication' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppTimeoutRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(3)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppTimeoutRetry.setReference("W. Simpson, 'The Point-to-Point Protocol (PPP)', RFC-1661, July 1994.")
if mibBuilder.loadTexts: cdtPppTimeoutRetry.setStatus('current')
if mibBuilder.loadTexts: cdtPppTimeoutRetry.setDescription("This objects specifies the maximum time the system will wait for a response to a PPP control packets on a target PPP connection. This column is valid only if the 'timeoutRetry' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppChapOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 13), Bits().clone(namedValues=NamedValues(("refuse", 0), ("callin", 1), ("wait", 2), ("encrypted", 3))).clone(namedValues=NamedValues(("wait", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppChapOpts.setReference("W. Simpson, 'PPP Challenge Handshake Authentication Protocol (CHAP)', RFC-1994, August 1996.")
if mibBuilder.loadTexts: cdtPppChapOpts.setStatus('current')
if mibBuilder.loadTexts: cdtPppChapOpts.setDescription("This object specifies how the system processes the CHAP on a target PPP connection: 'refuse' This option specifies that the system should refuse CHAP requests from peers of a target PPP connection. 'callin' This option specifies that the system should only refuse CHAP requests for incoming calls on a target PPP connection. This option is only relevant if the 'refuse' option is set to '1'. 'wait' This option delays CHAP authentication until after the peer of a target PPP connection has authenticated itself to the system. 'encrypted' This option specifies that the value specified by the corresponding instance of cdtPppChapPassword is already encrypted. This column is valid only if the 'chapOpts' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppChapHostname = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 14), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppChapHostname.setReference("W. Simpson, 'PPP Challenge Handshake Authentication Protocol (CHAP)', RFC-1994, August 1996.")
if mibBuilder.loadTexts: cdtPppChapHostname.setStatus('current')
if mibBuilder.loadTexts: cdtPppChapHostname.setDescription("This object specifies the hostname sent in a CHAP response on a target PPP connection. If the template does not include this attribute, then the system uses its assigned hostname. This column is valid only if the 'chapHostname' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppChapPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 15), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppChapPassword.setReference("W. Simpson, 'PPP Challenge Handshake Authentication Protocol (CHAP)', RFC-1994, August 1996.")
if mibBuilder.loadTexts: cdtPppChapPassword.setStatus('current')
if mibBuilder.loadTexts: cdtPppChapPassword.setDescription("This object specifies the password used to construct a CHAP response on the target PPP connection. This column is valid only if the 'chapPassword' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMsChapV1Opts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 16), Bits().clone(namedValues=NamedValues(("refuse", 0), ("callin", 1), ("wait", 2), ("encrypted", 3))).clone(namedValues=NamedValues(("wait", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMsChapV1Opts.setReference("G. Zorn, S. Cobb, 'Microsoft PPP CHAP Extensions', RFC-2433, October 1998.")
if mibBuilder.loadTexts: cdtPppMsChapV1Opts.setStatus('current')
if mibBuilder.loadTexts: cdtPppMsChapV1Opts.setDescription("This object specifies how the system processes version 1 of Microsoft CHAP on a target PPP connection: 'refuse' This option specifies that the system should refuse Microsoft CHAP (v1) requests from peers of a target PPP connection. 'callin' This option specifies that the system should only refuse Microsoft CHAP (v1) requests for incoming calls on a target PPP connection. This option is only relevant if the 'refuse' option is set to '1'. 'wait' This option delays Microsoft CHAP (v1) authentication until after the peer of a target PPP connection has authenticated itself to the system. 'encrypted' This option specifies that the value specified by the corresponding instance of cdtPppMsChapV1Password is already encrypted. This column is valid only if the 'msChapV1Opts' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMsChapV1Hostname = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 17), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMsChapV1Hostname.setReference("G. Zorn, S. Cobb, 'Microsoft PPP CHAP Extensions', RFC-2433, October 1998.")
if mibBuilder.loadTexts: cdtPppMsChapV1Hostname.setStatus('current')
if mibBuilder.loadTexts: cdtPppMsChapV1Hostname.setDescription("This object specifies the hostname sent in a Microsoft CHAP (v1) response on a target PPP connection. If the template does not include this attribute, then the system uses its assigned hostname. This column is valid only if the 'msChapV1Hostname' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMsChapV1Password = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 18), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMsChapV1Password.setReference("G. Zorn, S. Cobb, 'Microsoft PPP CHAP Extensions', RFC-2433, October 1998.")
if mibBuilder.loadTexts: cdtPppMsChapV1Password.setStatus('current')
if mibBuilder.loadTexts: cdtPppMsChapV1Password.setDescription("This object specifies the password used to construct a Microsoft CHAP (v1) response on a target PPP connection. This column is valid only if the 'msChapV1Password' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMsChapV2Opts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 19), Bits().clone(namedValues=NamedValues(("refuse", 0), ("callin", 1), ("wait", 2), ("encrypted", 3))).clone(namedValues=NamedValues(("wait", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMsChapV2Opts.setReference("G. Zorn, 'Microsoft PPP CHAP Extensions, Version 2', RFC-2759, January 2000.")
if mibBuilder.loadTexts: cdtPppMsChapV2Opts.setStatus('current')
if mibBuilder.loadTexts: cdtPppMsChapV2Opts.setDescription("This object specifies how the system processes version 2 of Microsoft CHAP on a target PPP connection: 'refuse' This option specifies that the system should refuse Microsoft CHAP (v2) requests from peers of a target PPP connection. 'callin' This option specifies that the system should only refuse Microsoft CHAP (v2) requests for incoming calls on a target PPP connection. This option is only relevant if the 'refuse' option is set to '1'. 'wait' This option delays Microsoft CHAP (v2) authentication until after the peer of a target PPP connection has authenticated itself to the system. 'encrypted' This option specifies that the value specified by the corresponding instance of cdtPppMsChapV2Password is already encrypted. This column is valid only if the 'msChapV2Opts' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMsChapV2Hostname = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 20), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMsChapV2Hostname.setReference("G. Zorn, 'Microsoft PPP CHAP Extensions, Version 2', RFC-2759, January 2000.")
if mibBuilder.loadTexts: cdtPppMsChapV2Hostname.setStatus('current')
if mibBuilder.loadTexts: cdtPppMsChapV2Hostname.setDescription("This object specifies the hostname sent in a Microsoft CHAP (v2) response on a target PPP connection. If the template does not include this attribute, then the system uses its assigned hostname. This column is valid only if the 'msChapV2Hostname' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppMsChapV2Password = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 21), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppMsChapV2Password.setReference("G. Zorn, 'Microsoft PPP CHAP Extensions, Version 2', RFC-2759, January 2000.")
if mibBuilder.loadTexts: cdtPppMsChapV2Password.setStatus('current')
if mibBuilder.loadTexts: cdtPppMsChapV2Password.setDescription("This object specifies the password used to construct a Microsoft CHAP (v2) response on a target PPP connection. This column is valid only if the 'msChapV2Password' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppPapOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 22), Bits().clone(namedValues=NamedValues(("refuse", 0), ("encrypted", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPapOpts.setReference("B. Lloyd and W. Simpson, 'PPP Authentication Protocols', RFC-1334, October 1992.")
if mibBuilder.loadTexts: cdtPppPapOpts.setStatus('current')
if mibBuilder.loadTexts: cdtPppPapOpts.setDescription("This object specifies how the system processes the PAP on a target PPP connection: 'refuse' This option specifies that the system should refuse PAP requests from peers of a target PPP connection. 'encrypted' This option specifies that the value specified by the corresponding instance of cdtPppPapSentPassword is already encrypted. This column is valid only if the 'papOpts' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppPapUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 23), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPapUsername.setReference("B. Lloyd and W. Simpson, 'PPP Authentication Protocols', RFC-1334, October 1992.")
if mibBuilder.loadTexts: cdtPppPapUsername.setStatus('current')
if mibBuilder.loadTexts: cdtPppPapUsername.setDescription("This object specifies the username sent in a PAP response on a target PPP connection. This column is valid only if the 'papUsername' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppPapPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 24), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPapPassword.setReference("B. Lloyd and W. Simpson, 'PPP Authentication Protocols', RFC-1334, October 1992.")
if mibBuilder.loadTexts: cdtPppPapPassword.setStatus('current')
if mibBuilder.loadTexts: cdtPppPapPassword.setDescription("This object specifies the username used to construct a PAP response on a target PPP connection. This column is valid only if the 'papPassword' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppEapOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 25), Bits().clone(namedValues=NamedValues(("refuse", 0), ("callin", 1), ("wait", 2), ("local", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppEapOpts.setReference("B. Aboba, L. Blunk, J. Vollbrecht, J. Carlson, and H. Levkowetz, 'Extensible Authentication Protocol (EAP)', RFC-3748, June 2004.")
if mibBuilder.loadTexts: cdtPppEapOpts.setStatus('current')
if mibBuilder.loadTexts: cdtPppEapOpts.setDescription("This object specifies how the system processes the EAP on a target PPP connection: 'refuse' This option specifies that the system should refuse EAP requests from peers of a target PPP connection. 'callin' This option specifies that the system should only refuse EAP requests for incoming calls on a target PPP connection. This option is only relevant if the 'refuse' option is set to '1'. 'wait' This option delays EAP authentication until after the peer of a target PPP connection has authenticated itself to the system. 'local' This option specifies that the system should locally authenticate the peer of a target PPP connection, rather than acting as a proxy to an external AAA server. This column is valid only if the 'eapOpts' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppEapIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 26), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppEapIdentity.setReference("B. Aboba, L. Blunk, J. Vollbrecht, J. Carlson, and H. Levkowetz, 'Extensible Authentication Protocol (EAP)', RFC-3748, June 2004.")
if mibBuilder.loadTexts: cdtPppEapIdentity.setStatus('current')
if mibBuilder.loadTexts: cdtPppEapIdentity.setDescription("This object specifies the identity sent in an EAP response on a target PPP connection. This column is valid only if the 'eapIdentity' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppEapPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 27), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppEapPassword.setReference("B. Aboba, L. Blunk, J. Vollbrecht, J. Carlson, and H. Levkowetz, 'Extensible Authentication Protocol (EAP)', RFC-3748, June 2004.")
if mibBuilder.loadTexts: cdtPppEapPassword.setStatus('current')
if mibBuilder.loadTexts: cdtPppEapPassword.setDescription("This object specifies the password used to construct an EAP response on a target PPP connection. This column is valid only if the 'eapPassword' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpAddrOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("accept", 2), ("required", 3), ("unique", 4))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpAddrOption.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpAddrOption.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpAddrOption.setDescription("This object specifies the IPCP address option for a target PPP connection: 'other' The implementation of this MIB module does not recognize the configured IPCP address option. 'accept' The system accepts any non-zero IP address from the peer of a target PPP connection. 'required' The system disconnects the peer of a target PPP connection if it could not negotiate an IP address. 'unique' The system disconnects the peer of a target PPP connection if the IP address is already in use. This column is valid only if the 'ipcpAddrOption' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpDnsOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("accept", 2), ("request", 3), ("reject", 4))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpDnsOption.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpDnsOption.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpDnsOption.setDescription("This object specifies the IPCP DNS option for the dynamic interface: 'other' The implementation of this MIB module does not recognize the configured DNS option. 'accept' The system accepts any non-zero DNS address form the peer of a target PPP connection. 'request' The system requests the DNS address from the peer of a target PPP connection. 'reject' The system rejects the DNS option from the peer of a target PPP connection. This column is valid only if the 'ipcpDnsOption' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpDnsPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 30), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpDnsPrimary.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpDnsPrimary.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpDnsPrimary.setDescription("This object specifies the IP address of the primary DNS server offered to the peer of a target PPP connection. This column is valid only if the 'ipcpDnsPrimary' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpDnsSecondary = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 31), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpDnsSecondary.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpDnsSecondary.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpDnsSecondary.setDescription("This object specifies the IP address of the secondary DNS server offered to the peer of a target PPP connection. This column is valid only if the 'ipcpDnsSecondary' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpWinsOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("accept", 2), ("request", 3), ("reject", 4))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpWinsOption.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpWinsOption.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpWinsOption.setDescription("This object specifies the IPCP WINS option for a target PPP connection: 'other' The implementation of this MIB module does not recognize the configured WINS option. 'accept' The system accepts any non-zero WINS address from the peer of a target PPP connection. 'request' The system requests the WINS address from the peer of a target PPP connection. 'reject' The system rejects the WINS option from the peer of a target PPP connection. This column is valid only if the 'ipcpWinsOption' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpWinsPrimary = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 33), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpWinsPrimary.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpWinsPrimary.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpWinsPrimary.setDescription("This object specifies the IP address of the primary WINS server offered to the peer of a target PPP connection. This column is valid only if the 'ipcpWinsPrimary' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpWinsSecondary = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 34), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpWinsSecondary.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpWinsSecondary.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpWinsSecondary.setDescription("This object specifies the IP address of the secondary WINS server offered to the peer of a target PPP connection. This column is valid only if the 'ipcpWinsSecondary' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpMaskOption = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("other", 1), ("request", 2), ("reject", 3))).clone('other')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpMaskOption.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpMaskOption.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpMaskOption.setDescription("This object specifies the IPCP IP subnet mask option for a target PPP connection: 'other' The implementation of this MIB module does not recognize the configured IP subnet mask option. 'request' The system requests the IP subnet mask from the peer of a target PPP connection. 'reject' The system rejects the IP subnet mask option from the peer of a target PPP connection. This column is valid only if the 'ipcpMaskOption' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppIpcpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 36), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppIpcpMask.setReference("G. McGregor, 'The PPP Internet Protocol Control Protocol (IPCP)', RFC-1332, May 1992.")
if mibBuilder.loadTexts: cdtPppIpcpMask.setStatus('current')
if mibBuilder.loadTexts: cdtPppIpcpMask.setDescription("This object specifies the IP address mask offered to the peer of a target PPP connection. This column is valid only if the 'ipcpMask' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppPeerDefIpAddrOpts = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 37), Bits().clone(namedValues=NamedValues(("ipAddrForced", 0), ("matchAaaPools", 1), ("staticPool", 2))).clone(namedValues=NamedValues(("ipAddrForced", 0)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPeerDefIpAddrOpts.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerDefIpAddrOpts.setDescription("This object specifies options that affect how the system assigns an IP address to the peer of a target PPP connection: 'ipAddrForced' This option forces the system to assign the next available IP address in the pool to the peer of a target PPP connection. When disabled, the peer may negotiate a specific IP address or the system can assign the peer its previously assigned IP address. 'matchAaaPools' This option specifies that the names of the IP address pools provided by an external AAA server must appear in the corresponding list of IP address pool specified by the cdtPppPeerIpAddrPoolTable. 'backupPools' This option specifies that the corresponding names of the IP address pools specified by the cditPppPeerIpAddrPoolTable serve as backup pools to those provided by an external AAA server. 'staticPools' This option suppresses an attempt to load pools from an external AAA server when the system encounters a missing pool name. This column is valid only if the 'peerIpAddrOpts' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppPeerDefIpAddrSrc = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("static", 1), ("pool", 2), ("dhcp", 3))).clone('pool')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPeerDefIpAddrSrc.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerDefIpAddrSrc.setDescription("This object specifies how the system assigns an IP address to the peer of a target PPP connection: 'static' The system assigns the IP address specified by the corresponding instance of cdtPppPeerDefIpAddr. 'pool' The system allocates the first available IP address from the corresponding list of named pools contained by the cdtPppPeerIpAddrPoolTable. 'dhcp' The system acts as a DHCP proxy-client to obtain an IP address. This column is valid only if the 'peerDefIpAddrSrc' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppPeerDefIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 1, 1, 39), InetAddressIPv4().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPeerDefIpAddr.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerDefIpAddr.setDescription("This object specifies the IP address the system assigns to the peer of a target PPP connection. This column is valid only if the 'peerDefIpAddr' bit of the corresponding instance of cdtPppValid is '1'.")
cdtPppPeerIpAddrPoolTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 2), )
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolTable.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolTable.setDescription('This table contains a prioritized list of named pools for each PPP template. A list corresponding to a PPP template specifies the pools the system searches in an attempt to assign an IP address to the peer of a target PPP connection. The system searches the pools in the order of their priority. This table has an expansion dependent relationship on the cdtPppTemplateTable, containing zero or more rows for each PPP template.')
cdtPppPeerIpAddrPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"), (0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPeerIpAddrPoolPriority"))
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolEntry.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolEntry.setDescription("An entry specifies a named pool in a list of pools associated with a PPP template. A PPP template can only have named pools associated with it if it has a cdtPppPeerIpAddrSrc of 'pool'. Any attempt to create an entry for a PPP template that does not have a cdtPppPeerIpAddrSrc of 'pool' must result in a response having an error-status of 'inconsistentValue'. The system automatically creates a corresponding entry when the system associates a named pool with a PPP template through another management entity (e.g., the system's local console). The system automatically destroys an entry under the following circumstances: 1) The system or EMS/NMS destroys the corresponding row in the cdtTemplateTable. 2) The system or EMS/NMS sets the corresponding instance of cdtPppPeerIpAddrSrc with a value other than 'pool'.")
cdtPppPeerIpAddrPoolPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolPriority.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolPriority.setDescription('This object indicates the relative priority of the named pool in the list corresponding to a PPP template. The system searches pools in the order of priority, where lower values represent higher priority.')
cdtPppPeerIpAddrPoolStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolStatus.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolStatus.setDescription("This object specifies the status of the entry. The following columns must be valid before activating a subscriber access profile: - cdtPppPeerIpAddrPoolStorage - cdtPppPeerIpAddrPoolName However, these objects specify a default value. Thus, it is possible to use create-and-go semantics without setting any additional columns. An implementation must not allow the EMS/NMS to create an entry if the corresponding instance of cdtPppPeerIpAddrSrc is not 'pool'. An implementation must allow the EMS/NMS to modify any column when this column is 'active'.")
cdtPppPeerIpAddrPoolStorage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 2, 1, 3), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolStorage.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolStorage.setDescription("This object specifies what happens to the name pool entry upon restart. If the corresponding instance of cdtTemplateSrc is not 'local', then this column must be 'volatile'.")
cdtPppPeerIpAddrPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 3, 2, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolName.setStatus('current')
if mibBuilder.loadTexts: cdtPppPeerIpAddrPoolName.setDescription('This object specifies the name of the IP address pool associated with the PPP template.')
cdtEthernetTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4, 1), )
if mibBuilder.loadTexts: cdtEthernetTemplateTable.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetTemplateTable.setDescription("This table contains attributes relating to dynamic interfaces initiated on Ethernet virtual interfaces (e.g., EoMPLS) or automatically created VLANs. This table has a sparse-dependent relationship on the cdtTemplateTable, containing a row for each dynamic template having a cdtTemplateType of one of the following values: 'derived' 'ethernet'")
cdtEthernetTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"))
if mibBuilder.loadTexts: cdtEthernetTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetTemplateEntry.setDescription("An entry containing attributes relating to dynamic interfaces initiated on Ethernet virtual interfaces (e.g., EoMPLS) or automatically created VLANs. The system automatically creates an entry when the system or the EMS/NMS creates a row in the cdtTemplateTable with a cdtTemplateType of one of the following values: 'derived' 'ethernet' Likewise, the system automatically destroys an entry when the system or the EMS/NMS destroys the corresponding row in the cdtTemplateTable.")
cdtEthernetValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4, 1, 1, 1), Bits().clone(namedValues=NamedValues(("bridgeDomain", 0), ("pppoeEnable", 1), ("ipv4PointToPoint", 2), ("macAddr", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtEthernetValid.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetValid.setDescription("This object specifies which attributes in the dynamic template have been configured to valid values. Each bit in this bit string corresponds to a column in this table. If the bit is '0', then the value of the corresponding column is not valid. If the bit is '1', then the value of the corresponding column has been configured to a valid value. The following list specifies the mappings between bits and the columns: bridgeDomain => cdtEthernetBridgeDomain pppoeEnable => cdtEthernetPppoeEnable ipv4PointToPoint => cdtEthernetIpv4PointToPoint macAddr => cdtEthernetMacAddr")
cdtEthernetBridgeDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtEthernetBridgeDomain.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetBridgeDomain.setDescription('This object specifies the name of the bridge domain...')
cdtEthernetPppoeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtEthernetPppoeEnable.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetPppoeEnable.setDescription('This object specifies whether...')
cdtEthernetIpv4PointToPoint = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4, 1, 1, 4), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtEthernetIpv4PointToPoint.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetIpv4PointToPoint.setDescription('This object specifies whether...')
cdtEthernetMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 4, 1, 1, 5), MacAddress().clone(hexValue="000000000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtEthernetMacAddr.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetMacAddr.setDescription('This object specifies the...')
cdtSrvTemplateTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1), )
if mibBuilder.loadTexts: cdtSrvTemplateTable.setStatus('current')
if mibBuilder.loadTexts: cdtSrvTemplateTable.setDescription("This table contains attributes relating to a service. This table has a sparse-dependent relationship on the cdtTemplateTable, containing a row for each dynamic template having a cdtTemplateType of one of the following values: 'derived' 'service'")
cdtSrvTemplateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1, 1), ).setIndexNames((0, "CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateName"))
if mibBuilder.loadTexts: cdtSrvTemplateEntry.setStatus('current')
if mibBuilder.loadTexts: cdtSrvTemplateEntry.setDescription("An entry containing attributes relating to a service. The system automatically creates entry when the system or the EMS/NMS creates a row in the cdtTemplateTable with a cdtTemplateType of one of the following values: 'derived' 'service' Likewise, the system automatically destroys an entry when the system or the EMS/NMS destroys the corresponding row in the cdtTemplateTable.")
cdtSrvValid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1, 1, 1), Bits().clone(namedValues=NamedValues(("networkSrv", 0), ("vpdnGroup", 1), ("sgSrvGroup", 2), ("sgSrvType", 3), ("multicast", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtSrvValid.setStatus('current')
if mibBuilder.loadTexts: cdtSrvValid.setDescription("This object specifies which attributes in the dynamic template have been configured to valid values. Each bit in this bit string corresponds to a column in this table. If the bit is '0', then the value of the corresponding column is not valid. If the bit is '1', then the value of the corresponding column has been configured to a valid value. The following list specifies the mappings between bits and the columns: networkSrv => cdtSrvNetworkSrv vpdnGroup => cdtSrvVpdnGroup sgSrvGroup => cdtSrvGroup sgSrvType => cdtSrvSgSrvType multicast => cdtSrvMulticast")
cdtSrvNetworkSrv = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("none", 2), ("local", 3), ("vpdn", 4))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtSrvNetworkSrv.setStatus('current')
if mibBuilder.loadTexts: cdtSrvNetworkSrv.setDescription("This object specifies the type of network service provided by the target service: 'other' The implementation of this MIB module does not recognize the configured network service. 'none' The target subscriber service does not provide a network service to subscribers sessions. 'local' The target subscriber service provides local termination for subscriber sessions. 'vpdn' The target subscriber service provides a Virtual Private Dialup Network service for subscriber sessions. This column is valid only if the 'networkSrv' bit of the corresponding instance of cdtSrvValid is '1'.")
cdtSrvVpdnGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtSrvVpdnGroup.setStatus('current')
if mibBuilder.loadTexts: cdtSrvVpdnGroup.setDescription("This object specifies the name of the VPDN group used to configure the network service. This column is valid only if the 'vpdnGroup' bit of the corresponding instance of cdtSrvValid is '1'.")
cdtSrvSgSrvGroup = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtSrvSgSrvGroup.setStatus('current')
if mibBuilder.loadTexts: cdtSrvSgSrvGroup.setDescription("This object specifies the name of the service group with which the system associates subscriber sessions. A service group specifies a set of services that may be active simultaneously for a given subscriber session. Typically, a service group contains a primary service and one or more secondary services. This column is valid only if the 'sgSrvGroup' bit of the corresponding instance of cdtSrvValid is '1'.")
cdtSrvSgSrvType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("primary", 1), ("secondary", 2))).clone('secondary')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtSrvSgSrvType.setStatus('current')
if mibBuilder.loadTexts: cdtSrvSgSrvType.setDescription("This object specifies whether the target service specifies a network-forwarding policy: 'primary' The target service specifies a network-forwarding policy. Primary services are mutually exclusive; that is, only one primary service can be activated for any given subscriber session. 'secondary' The target service has a dependence on the primary service in the group specified by the corresponding instance of cdtSuBSrvSgSrvGroup. After the system activates the primary service, it activates secondary services. When the system deactivates the primary service, then it deactivates all the secondary services in the service group. This column is valid only if the 'sgSrvType' bit of the corresponding instance of cdtSrvValid is '1'.")
cdtSrvMulticast = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 784, 1, 6, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cdtSrvMulticast.setStatus('current')
if mibBuilder.loadTexts: cdtSrvMulticast.setDescription("This objects specifies whether the system enables multicast service for subscriber sessions of the target service. This column is valid only if the 'sgSrvMcastRoutingIf' bit of the corresponding instance of cdtSrvValid is '1'.")
ciscoDynamicTemplateMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 1))
ciscoDynamicTemplateMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 2))
ciscoDynamicTemplateR1Compliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 1, 1)).setObjects(("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtBaseGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtEthernetGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtSrvGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoDynamicTemplateR1Compliance = ciscoDynamicTemplateR1Compliance.setStatus('current')
if mibBuilder.loadTexts: ciscoDynamicTemplateR1Compliance.setDescription('This compliance statement specifies the minimal requirements an implementation must meet in order to claim full compliance with the definition of the CISCO-DYNAMIC-TEMPLATE-MIB.')
cdtBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 2, 1)).setObjects(("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateStatus"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateStorage"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateType"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateSrc"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateUsageCount"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateTargetStatus"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateTargetStorage"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateAssociationPrecedence"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateUsageTargetType"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtTemplateUsageTargetId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdtBaseGroup = cdtBaseGroup.setStatus('current')
if mibBuilder.loadTexts: cdtBaseGroup.setDescription('This group contains objects describing dynamic templates, targets of dynamic templates, and the associations between dynamic templates and targets.')
cdtCommonGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 2, 2)).setObjects(("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonValid"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonDescr"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonKeepaliveInt"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonKeepaliveRetries"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonVrf"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonAddrPool"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonIpv4AccessGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonIpv4Unreachables"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonIpv6AccessGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonIpv6Unreachables"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonSrvSubControl"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonSrvRedirect"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonSrvAcct"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonSrvQos"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtCommonSrvNetflow"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdtCommonGroup = cdtCommonGroup.setStatus('current')
if mibBuilder.loadTexts: cdtCommonGroup.setDescription('This group contains objects describing attributes common to all dynamic templates.')
cdtIfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 2, 3)).setObjects(("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfValid"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfMtu"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfCdpEnable"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfFlowMonitor"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv4Unnumbered"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv4SubEnable"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv4Mtu"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv4TcpMssAdjust"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv4VerifyUniRpf"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv4VerifyUniRpfAcl"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv4VerifyUniRpfOpts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6Enable"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6SubEnable"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6TcpMssAdjust"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6VerifyUniRpf"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6VerifyUniRpfAcl"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6VerifyUniRpfOpts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdPrefix"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdPrefixLength"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdValidLife"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdPreferredLife"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdOpts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdDadAttempts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdNsInterval"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdReachableTime"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdRaIntervalUnits"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdRaIntervalMax"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdRaIntervalMin"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdRaLife"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtIfIpv6NdRouterPreference"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdtIfGroup = cdtIfGroup.setStatus('current')
if mibBuilder.loadTexts: cdtIfGroup.setDescription('This group contains objects describing attributes common to dynamic templates applied to dynamic interfaces.')
cdtPppGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 2, 4)).setObjects(("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppValid"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppAccounting"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppAuthentication"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppAuthenticationMethods"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppAuthorization"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppLoopbackIgnore"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMaxBadAuth"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMaxConfigure"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMaxFailure"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMaxTerminate"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppTimeoutAuthentication"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppTimeoutRetry"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppChapOpts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppChapHostname"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppChapPassword"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMsChapV1Opts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMsChapV1Hostname"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMsChapV1Password"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMsChapV2Opts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMsChapV2Hostname"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppMsChapV2Password"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPapOpts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPapUsername"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPapPassword"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppEapOpts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppEapIdentity"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppEapPassword"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpAddrOption"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpDnsOption"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpDnsPrimary"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpDnsSecondary"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpWinsOption"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpWinsPrimary"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpWinsSecondary"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpMaskOption"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppIpcpMask"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPeerDefIpAddrOpts"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPeerDefIpAddrSrc"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPeerDefIpAddr"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPeerIpAddrPoolStatus"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPeerIpAddrPoolStorage"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtPppPeerIpAddrPoolName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdtPppGroup = cdtPppGroup.setStatus('current')
if mibBuilder.loadTexts: cdtPppGroup.setDescription('This group contains objects describing attributes contained by PPP templates.')
cdtEthernetGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 2, 5)).setObjects(("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtEthernetValid"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtEthernetBridgeDomain"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtEthernetPppoeEnable"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtEthernetIpv4PointToPoint"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtEthernetMacAddr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdtEthernetGroup = cdtEthernetGroup.setStatus('current')
if mibBuilder.loadTexts: cdtEthernetGroup.setDescription('This group contains objects describing attributes contained by Ethernet templates.')
cdtSrvGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 784, 2, 2, 6)).setObjects(("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtSrvValid"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtSrvNetworkSrv"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtSrvVpdnGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtSrvSgSrvGroup"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtSrvSgSrvType"), ("CISCO-DYNAMIC-TEMPLATE-MIB", "cdtSrvMulticast"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cdtSrvGroup = cdtSrvGroup.setStatus('current')
if mibBuilder.loadTexts: cdtSrvGroup.setDescription('This group contains objects describing attributes contained by service templates.')
mibBuilder.exportSymbols("CISCO-DYNAMIC-TEMPLATE-MIB", cdtEthernetPppoeEnable=cdtEthernetPppoeEnable, cdtCommonSrvRedirect=cdtCommonSrvRedirect, cdtIfIpv4Unnumbered=cdtIfIpv4Unnumbered, cdtTemplateCommonEntry=cdtTemplateCommonEntry, cdtCommonIpv6Unreachables=cdtCommonIpv6Unreachables, cdtPppTemplateTable=cdtPppTemplateTable, cdtPppAccounting=cdtPppAccounting, cdtSrvTemplateTable=cdtSrvTemplateTable, cdtPppIpcpWinsSecondary=cdtPppIpcpWinsSecondary, cdtPppAuthentication=cdtPppAuthentication, cdtIfMtu=cdtIfMtu, cdtPppMsChapV2Opts=cdtPppMsChapV2Opts, cdtTemplateTargetStatus=cdtTemplateTargetStatus, cdtBaseGroup=cdtBaseGroup, cdtTemplateUsageTable=cdtTemplateUsageTable, cdtIfIpv6NdRaIntervalMax=cdtIfIpv6NdRaIntervalMax, cdtCommonValid=cdtCommonValid, cdtIfIpv6NdPrefix=cdtIfIpv6NdPrefix, cdtIfIpv6NdRaLife=cdtIfIpv6NdRaLife, cdtPppChapPassword=cdtPppChapPassword, cdtIfTemplateEntry=cdtIfTemplateEntry, ciscoDynamicTemplateMIB=ciscoDynamicTemplateMIB, cdtIfIpv4SubEnable=cdtIfIpv4SubEnable, cdtPppPeerIpAddrPoolName=cdtPppPeerIpAddrPoolName, cdtSrvMulticast=cdtSrvMulticast, cdtIfTemplateTable=cdtIfTemplateTable, cdtPppEapIdentity=cdtPppEapIdentity, cdtPppTimeoutRetry=cdtPppTimeoutRetry, cdtPppMaxBadAuth=cdtPppMaxBadAuth, cdtPppValid=cdtPppValid, ciscoDynamicTemplateMIBNotifs=ciscoDynamicTemplateMIBNotifs, cdtPppIpcpDnsPrimary=cdtPppIpcpDnsPrimary, cdtIfGroup=cdtIfGroup, cdtTemplateName=cdtTemplateName, cdtCommonIpv6AccessGroup=cdtCommonIpv6AccessGroup, cdtCommonKeepaliveRetries=cdtCommonKeepaliveRetries, cdtPppPeerIpAddrPoolTable=cdtPppPeerIpAddrPoolTable, cdtPppAuthenticationMethods=cdtPppAuthenticationMethods, cdtPppLoopbackIgnore=cdtPppLoopbackIgnore, cdtEthernetTemplateTable=cdtEthernetTemplateTable, cdtIpSubscriber=cdtIpSubscriber, cdtTemplateCommonTable=cdtTemplateCommonTable, cdtIfFlowMonitor=cdtIfFlowMonitor, cdtIfIpv4VerifyUniRpf=cdtIfIpv4VerifyUniRpf, cdtCommonSrvNetflow=cdtCommonSrvNetflow, cdtTemplateAssociationPrecedence=cdtTemplateAssociationPrecedence, ciscoDynamicTemplateMIBConform=ciscoDynamicTemplateMIBConform, cdtIfValid=cdtIfValid, cdtCommonAddrPool=cdtCommonAddrPool, cdtCommonSrvAcct=cdtCommonSrvAcct, cdtTemplateUsageCount=cdtTemplateUsageCount, cdtIfIpv6SubEnable=cdtIfIpv6SubEnable, cdtPppMsChapV2Password=cdtPppMsChapV2Password, cdtIfIpv4Mtu=cdtIfIpv4Mtu, cdtPppGroup=cdtPppGroup, cdtSrvNetworkSrv=cdtSrvNetworkSrv, cdtPppPapOpts=cdtPppPapOpts, cdtCommonDescr=cdtCommonDescr, cdtPppChapHostname=cdtPppChapHostname, cdtTemplateSrc=cdtTemplateSrc, cdtPppPapUsername=cdtPppPapUsername, cdtTemplateTargetTable=cdtTemplateTargetTable, cdtSrvSgSrvType=cdtSrvSgSrvType, cdtIfIpv6NdRouterPreference=cdtIfIpv6NdRouterPreference, cdtIfIpv6NdDadAttempts=cdtIfIpv6NdDadAttempts, cdtPppIpcpMaskOption=cdtPppIpcpMaskOption, cdtPppPeerIpAddrPoolStorage=cdtPppPeerIpAddrPoolStorage, cdtTemplateUsageTargetType=cdtTemplateUsageTargetType, cdtEthernetIpv4PointToPoint=cdtEthernetIpv4PointToPoint, cdtPppIpcpMask=cdtPppIpcpMask, cdtSrvVpdnGroup=cdtSrvVpdnGroup, cdtCommonIf=cdtCommonIf, cdtPppPeerIpAddrPoolPriority=cdtPppPeerIpAddrPoolPriority, cdtPppPapPassword=cdtPppPapPassword, cdtIfIpv6Enable=cdtIfIpv6Enable, cdtCommonVrf=cdtCommonVrf, cdtPpp=cdtPpp, cdtTemplateTable=cdtTemplateTable, cdtSrvSgSrvGroup=cdtSrvSgSrvGroup, cdtPppMsChapV1Hostname=cdtPppMsChapV1Hostname, cdtTemplateAssociationEntry=cdtTemplateAssociationEntry, cdtPppPeerDefIpAddrSrc=cdtPppPeerDefIpAddrSrc, cdtIfIpv6NdPreferredLife=cdtIfIpv6NdPreferredLife, cdtPppIpcpWinsOption=cdtPppIpcpWinsOption, cdtIfIpv6NdNsInterval=cdtIfIpv6NdNsInterval, cdtTemplateTargetId=cdtTemplateTargetId, cdtPppIpcpDnsSecondary=cdtPppIpcpDnsSecondary, cdtTemplateTargetStorage=cdtTemplateTargetStorage, cdtCommonSrvQos=cdtCommonSrvQos, cdtSubscriberGroup=cdtSubscriberGroup, cdtCommonGroup=cdtCommonGroup, cdtIfIpv6NdReachableTime=cdtIfIpv6NdReachableTime, cdtIfIpv4TcpMssAdjust=cdtIfIpv4TcpMssAdjust, cdtTemplateUsageEntry=cdtTemplateUsageEntry, cdtPppIpcpDnsOption=cdtPppIpcpDnsOption, cdtPppIpcpWinsPrimary=cdtPppIpcpWinsPrimary, cdtCommonIpv4Unreachables=cdtCommonIpv4Unreachables, cdtIfIpv6TcpMssAdjust=cdtIfIpv6TcpMssAdjust, cdtIfIpv4VerifyUniRpfAcl=cdtIfIpv4VerifyUniRpfAcl, cdtService=cdtService, cdtPppEapPassword=cdtPppEapPassword, cdtIfIpv6NdRaIntervalMin=cdtIfIpv6NdRaIntervalMin, cdtIfIpv6NdOpts=cdtIfIpv6NdOpts, cdtPppMsChapV2Hostname=cdtPppMsChapV2Hostname, cdtPppEapOpts=cdtPppEapOpts, cdtPppMaxTerminate=cdtPppMaxTerminate, cdtIfIpv6VerifyUniRpfOpts=cdtIfIpv6VerifyUniRpfOpts, cdtPppTimeoutAuthentication=cdtPppTimeoutAuthentication, cdtPppPeerIpAddrPoolStatus=cdtPppPeerIpAddrPoolStatus, cdtTemplateStorage=cdtTemplateStorage, cdtTemplateTargetType=cdtTemplateTargetType, cdtPppPeerDefIpAddrOpts=cdtPppPeerDefIpAddrOpts, PYSNMP_MODULE_ID=ciscoDynamicTemplateMIB, cdtTemplateUsageTargetId=cdtTemplateUsageTargetId, cdtPppMsChapV1Password=cdtPppMsChapV1Password, cdtIfIpv6VerifyUniRpfAcl=cdtIfIpv6VerifyUniRpfAcl, cdtEthernetGroup=cdtEthernetGroup, cdtIfCdpEnable=cdtIfCdpEnable, cdtPppAuthorization=cdtPppAuthorization, cdtIfIpv6NdRaIntervalUnits=cdtIfIpv6NdRaIntervalUnits, cdtPppMsChapV1Opts=cdtPppMsChapV1Opts, cdtEthernetMacAddr=cdtEthernetMacAddr, cdtPppMaxFailure=cdtPppMaxFailure, cdtSrvValid=cdtSrvValid, cdtTemplateAssociationName=cdtTemplateAssociationName, cdtEthernetBridgeDomain=cdtEthernetBridgeDomain, cdtPppTemplateEntry=cdtPppTemplateEntry, ciscoDynamicTemplateMIBGroups=ciscoDynamicTemplateMIBGroups, cdtPppChapOpts=cdtPppChapOpts, cdtPppPeerIpAddrPoolEntry=cdtPppPeerIpAddrPoolEntry, cdtTemplateTargetEntry=cdtTemplateTargetEntry, cdtEthernetValid=cdtEthernetValid, cdtTemplateAssociationTable=cdtTemplateAssociationTable, cdtPppMaxConfigure=cdtPppMaxConfigure, ciscoDynamicTemplateMIBCompliances=ciscoDynamicTemplateMIBCompliances, ciscoDynamicTemplateR1Compliance=ciscoDynamicTemplateR1Compliance, cdtBase=cdtBase, cdtEthernet=cdtEthernet, cdtTemplateType=cdtTemplateType, cdtCommonSrvSubControl=cdtCommonSrvSubControl, cdtIfIpv6VerifyUniRpf=cdtIfIpv6VerifyUniRpf, cdtIfIpv4VerifyUniRpfOpts=cdtIfIpv4VerifyUniRpfOpts, ciscoDynamicTemplateMIBObjects=ciscoDynamicTemplateMIBObjects, cdtSrvGroup=cdtSrvGroup, cdtSrvTemplateEntry=cdtSrvTemplateEntry, cdtTemplateStatus=cdtTemplateStatus, cdtEthernetTemplateEntry=cdtEthernetTemplateEntry, cdtIfIpv6NdValidLife=cdtIfIpv6NdValidLife, cdtCommonIpv4AccessGroup=cdtCommonIpv4AccessGroup, cdtCommonKeepaliveInt=cdtCommonKeepaliveInt, cdtPppPeerDefIpAddr=cdtPppPeerDefIpAddr, cdtTemplateEntry=cdtTemplateEntry, cdtIfIpv6NdPrefixLength=cdtIfIpv6NdPrefixLength, cdtPppIpcpAddrOption=cdtPppIpcpAddrOption)

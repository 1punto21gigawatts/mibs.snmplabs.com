#
# PySNMP MIB module HP-ICF-BRIDGE (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-ICF-BRIDGE
# Produced by pysmi-0.3.4 at Wed May  1 13:33:31 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint")
dot1dBasePortEntry, = mibBuilder.importSymbols("BRIDGE-MIB", "dot1dBasePortEntry")
VidList, = mibBuilder.importSymbols("HP-ICF-FTRCO", "VidList")
hpSwitch, = mibBuilder.importSymbols("HP-ICF-OID", "hpSwitch")
ConfigStatus, = mibBuilder.importSymbols("HP-ICF-TC", "ConfigStatus")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
VlanId, dot1qVlanStaticEntry, VlanIndex = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanId", "dot1qVlanStaticEntry", "VlanIndex")
portCopyEntry, = mibBuilder.importSymbols("SMON-MIB", "portCopyEntry")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
ObjectIdentity, IpAddress, Gauge32, MibIdentifier, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Integer32, NotificationType, TimeTicks, Counter64, Bits, Counter32, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "ObjectIdentity", "IpAddress", "Gauge32", "MibIdentifier", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Integer32", "NotificationType", "TimeTicks", "Counter64", "Bits", "Counter32", "ModuleIdentity")
TextualConvention, DisplayString, TruthValue, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TruthValue", "TimeStamp")
hpicfBridge = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12))
hpicfBridge.setRevisions(('2014-04-27 00:00', '2013-10-11 00:00', '2012-07-13 00:00', '2012-05-30 00:00', '2010-06-26 00:00', '2009-12-15 00:00', '2009-02-11 00:00', '2006-09-30 00:00', '2006-09-26 00:00', '2006-08-13 17:38', '2003-02-20 00:00', '2002-05-23 17:38', '2001-10-03 20:50', '2000-11-03 06:42',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hpicfBridge.setRevisionsDescriptions(('Added hpicfBridgeStpBpduThrottleStatus, hpicfBridgeStpBpduThrottleValue, hpicfBridgeStpBpduThrottleConfigGroup and hpicfBridgeStpBpduThrottleConfigCompliance', 'The description of selected MIB objects is modified for clarity and usability.', 'A new textual convention disableTxRx(3) is added for the hpicfBridgeLoopProtectPortReceiverAction MIB.', "Added 'hpicfBridgeGvrpStateMachineTable'with the following mib objects: hpicfGenericVlanId,hpicfApplicantStateMachine,hpicfApplicantStateMachine. Added hpicfBridgeGvrpPortGroup1, hpicfBridgeComplianceRevFour1 and deprecated hpicfBridgeGvrpPortGroup, hpicfBridgeComplianceRevFour.", 'This MIB module supports loop protect per vlan feature.', "Added 'hpicfBridgeMirrorSessionType' MIB object.", "Added 'hpicfBridgeVoiceVlanConfigTable', 'hpicfBridgeJumboInterfaceConfigTable' 'hpicfBridgeManagementInterfaceConfigTable' objects.", "Added 'hpicfBridgeMirrorSessionID' MIB object.", "Added 'hpicfBridgeRstpAutoEdgePort' MIB object.", 'Added hpicfLoopProtect MIB and updated conformance statements.', "Added 'mstpOperation' option to the 'hpicfBridgeRstpForceVersion' MIB object. Added 'ieee8021s' option to the 'hpicfBridgeRstpProtocolVersion' MIB object.", 'Added conformance information.', 'Modified hpicfBridgeRstp MIB to contain ConfigStatus.', 'Initial revision.',))
if mibBuilder.loadTexts: hpicfBridge.setLastUpdated('201404270000Z')
if mibBuilder.loadTexts: hpicfBridge.setOrganization('HP Networking')
if mibBuilder.loadTexts: hpicfBridge.setContactInfo('Hewlett-Packard Company 8000 Foothills Blvd. Roseville, CA 95747')
if mibBuilder.loadTexts: hpicfBridge.setDescription('This MIB module contains HP proprietary extensions to the standard Bridge MIBs.')
class BridgeId(TextualConvention, OctetString):
    description = 'The Bridge Identifier as used in the Spanning Tree Protocol to uniquely identify a bridge.'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(8, 8)
    fixedLength = 8

hpicfBridgeObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1))
hpicfBridgeBase = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 1))
hpicfBridgeMaxVlans = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4094))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeMaxVlans.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMaxVlans.setDescription('Defines the number of VLANs that the switch will support for dynamic use without requiring a reboot.')
hpicfBridgeVlanEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVlanEnable.setDescription('Administrative status of VLAN support on this switch.')
hpicfBridgePrimaryVlan = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 1, 3), VlanIndex()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgePrimaryVlan.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgePrimaryVlan.setDescription('The 802.1Q VLAN ID of the primary VLAN for this switch.')
hpicfBridgeVlanConfigStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 1, 4), ConfigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeVlanConfigStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVlanConfigStatus.setDescription("If one or more variables in this group has been reconfigured since the last reboot in such a way as to require a reboot to take effect, the value of this variable will be set to 'notInService'.")
hpicfBridgeGvrp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2))
hpicfBridgeGvrpPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 1), )
if mibBuilder.loadTexts: hpicfBridgeGvrpPortTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeGvrpPortTable.setDescription('A table that contains information about the GVRP port configurations on this switch.')
hpicfBridgeGvrpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 1, 1), )
dot1dBasePortEntry.registerAugmentions(("HP-ICF-BRIDGE", "hpicfBridgeGvrpPortEntry"))
hpicfBridgeGvrpPortEntry.setIndexNames(*dot1dBasePortEntry.getIndexNames())
if mibBuilder.loadTexts: hpicfBridgeGvrpPortEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeGvrpPortEntry.setDescription('GVRP information associated with a single port.')
hpicfBridgeGvrpRestrictedVlanReg = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeGvrpRestrictedVlanReg.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeGvrpRestrictedVlanReg.setDescription("Controls GVRP's ability to learn new VLANs on this port. When set to 'false', GVRP will accept JOIN requests for new VLANs on this port. When set to 'true', GVRP will only process protocol packets that concern themselves with known VLANs.")
hpicfBridgeGvrpStateMachineTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 2), )
if mibBuilder.loadTexts: hpicfBridgeGvrpStateMachineTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeGvrpStateMachineTable.setDescription('A table that contains information about the GVRP state Machine(s) configuration.')
hpicfBridgeGvrpStateMachineEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 2, 1), ).setIndexNames((0, "HP-ICF-BRIDGE", "hpicfGenericVlanId"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hpicfBridgeGvrpStateMachineEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeGvrpStateMachineEntry.setDescription('A row in a table, containing the VLAN ID and Portlist.')
hpicfGenericVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 2, 1, 1), VlanId())
if mibBuilder.loadTexts: hpicfGenericVlanId.setStatus('current')
if mibBuilder.loadTexts: hpicfGenericVlanId.setDescription('The VLAN ID to which this entry belongs.')
hpicfApplicantStateMachine = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("va", 0), ("aa", 1), ("qa", 2), ("la", 3), ("vp", 4), ("ap", 5), ("qp", 6), ("vo", 7), ("ao", 8), ("qo", 9), ("lo", 10), ("von", 11), ("aon", 12), ("qon", 13)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfApplicantStateMachine.setStatus('current')
if mibBuilder.loadTexts: hpicfApplicantStateMachine.setDescription('This MIB provides the Applicant State Machine values of the GVRP enabled port as follows,0 = va, 1 = aa,2 = qa, 3 = la,4 = vp,5 = ap,6 = qp,7 = vo,8 = ao,9 = qo,10 = lo, 11 = von,12 = aon,13 = qon. Whereas, the first letter indicates the state: V for Very anxious, A for Anxious, Q for Quiet, and L for Leaving. The second letter indicates the membership state: A for Active member,P for Passive member, O for Observer. And the third letter N (if any) stands for Non-participant.')
hpicfRegistarStateMachine = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("inn", 0), ("lv", 1), ("l3", 2), ("l2", 3), ("l1", 4), ("mt", 5), ("inr", 6), ("lvr", 7), ("l3r", 8), ("l2r", 9), ("l1r", 10), ("mtr", 11), ("inf", 12), ("lvf", 13), ("l3f", 14), ("l2f", 15), ("l1f", 16), ("mtf", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfRegistarStateMachine.setStatus('current')
if mibBuilder.loadTexts: hpicfRegistarStateMachine.setDescription('This MIB provides the Registrar state machine value for the GVRP enabled port as follows,0 = inn,1 = lv,2 = l3,3 = l2, 4 = l1,5 = mt,6 = inr,7 = lvr,8 = l3r,9 = l2r,10 = l1r,11 = mtr, 12 = inf,13 = lvf,14 = l3f,15 = l2f,16 = l1f,17 = mtf . Whereas, the first two letters/numbers indicate the state: IN stands for In; LV, L3, L2, and L1 all stand for Leaving, and L3, L2, L1 are three sub-states of LV; MT stands for Empty. And the third letter indicates the registration mode: N (or the third letter being absent) for normal registration,R for Registration fixed, and F for Registration forbidden.. indicating the fixed registration mode in Empty state.')
hpicfBridgeRstp = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4))
hpicfBridgeRstpForceVersion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("stpCompatibility", 0), ("rstpOperation", 2), ("mstpOperation", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpForceVersion.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpForceVersion.setDescription("The operational mode of the Spanning Tree Protocol. A value of stpCompatibility (0) indicates that the Spanning Tree Protocol operates in IEEE 802.1d mode on all ports. A value of rstpOperation (2) indicates that the Spanning Tree Protocol operates in IEEE 802.1w mode on all ports, except for the ports to which bridges are connected. The ports to which bridges are connected operate in IEEE 802.1d mode for backward compatibility. A value of mstpOperation (3) indicates that the Spanning Tree Protocol operates in IEEE 802.1s mode on all ports, except for the ports to which bridges are connected. The ports to which bridges are connected operate in IEEE 802.1d mode for backward compatibility. This option is available only if object 'hpicfBridgeRstpProtocolVersion' is set to 'ieee8021s'.")
hpicfBridgeRstpConfigStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 2), ConfigStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeRstpConfigStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpConfigStatus.setDescription("The configuration status of this group of objects. The value of this object is set to 'notInService' if any variable in this group is reconfigured since the last reboot and a system reboot is required for the configuration to take effect.")
hpicfBridgeRstpProtocolVersion = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("ieee8021d", 0), ("ieee8021w", 2), ("ieee8021s", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpProtocolVersion.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpProtocolVersion.setDescription('The version of Spanning Tree Protocol currently running on the switch. - ieee8021d is the version of Spanning Tree Protocol defined as IEEE 802.1d (STP). - ieee8021w is the version of Spanning Tree Protocol defined as IEEE 802.1w (RSTP). - ieee8021s is the version of Spanning Tree Protocol defined as IEEE 802.1s (MSTP).')
hpicfBridgeRstpAdminStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpAdminStatus.setDescription('The operational status of the Spanning Tree Protocol')
hpicfBridgeRstpPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5), )
if mibBuilder.loadTexts: hpicfBridgeRstpPortTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortTable.setDescription('A table that contains information about STP configuration on all ports.')
hpicfBridgeRstpPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1), ).setIndexNames((0, "HP-ICF-BRIDGE", "hpicfBridgeRstpPortIndex"))
if mibBuilder.loadTexts: hpicfBridgeRstpPortEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortEntry.setDescription('An entry in the hpicfBridgeRstpPortTable which holds the information of STP configuration of a port. An entry is available for each port in this table.')
hpicfBridgeRstpPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeRstpPortIndex.setReference('IEEE 802.1w')
if mibBuilder.loadTexts: hpicfBridgeRstpPortIndex.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortIndex.setDescription('The port number of the port for which this entry contains Spanning Tree Protocol management information.')
hpicfBridgeRstpAdminEdgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpAdminEdgePort.setReference('IEEE P802.1w Clause 17.3; IEEE P802.1t Clause 18')
if mibBuilder.loadTexts: hpicfBridgeRstpAdminEdgePort.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpAdminEdgePort.setDescription("Indicate that port is connected to LAN segment that don't have any bridge connected to it")
hpicfBridgeRstpOperEdgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeRstpOperEdgePort.setReference('IEEE P802.1w Clause 17.3; IEEE P802.1t Clause 18')
if mibBuilder.loadTexts: hpicfBridgeRstpOperEdgePort.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpOperEdgePort.setDescription('Reflects the value of the operEdgePort parameter, as defined by the operation of the Bridge Detection state machine (Clause 18 of P802.1t). The value of this parameter is used by a Designated Port in order to determine how rapidly it may transition to the Forwarding Port State (see 17.23, Port Role Transitions state machine). The Bridge Detection state machine sets this parameter to the value of adminEdgePort (P802.1t 18.1.3) on initialization, and forces its value to FALSE if any BPDUs are received on the Port.')
hpicfBridgeRstpAdminPointToPointMac = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("forceTrue", 1), ("forceFalse", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpAdminPointToPointMac.setReference('IEEE P802.1w; IEEE P802.1t')
if mibBuilder.loadTexts: hpicfBridgeRstpAdminPointToPointMac.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpAdminPointToPointMac.setDescription(' forceTrue: This value indicates that the administrator requires the MAC to be treated as if it is connected to a point-to-point LAN segment, regardless of any indications to the contrary that are generated by the MAC entity. forceFalse: This value indicates that the administrator requires the MAC to be treated as if it is connected to a non-point-to-point LAN segment, regardless of any indications to the contrary that are generated by the MAC entity. auto: This value indicates that the administrator requires the point-to-point status of the MAC to be determined in accordance with the specific MAC procedures defined in 6.5.')
hpicfBridgeRstpOperPointToPointMac = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 5), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeRstpOperPointToPointMac.setReference('IEEE P802.1w; IEEE P802.1t')
if mibBuilder.loadTexts: hpicfBridgeRstpOperPointToPointMac.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpOperPointToPointMac.setDescription(' true: This value indicates that the MAC is connected to a point-to-point LAN segment; i.e., there is at most one other system attached to the LAN segment. false: This value indicates that the MAC is connected to a non-point-to-point LAN segment; i.e., there can be more than one other system attached to the LAN segment.')
hpicfBridgeRstpPortPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 200000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpPortPathCost.setReference('IEEE 802.1w')
if mibBuilder.loadTexts: hpicfBridgeRstpPortPathCost.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortPathCost.setDescription('Rapid Reconfiguration Port Path Cost - 32 bit values')
hpicfBridgeRstpForceBpduMigrationCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 7), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpForceBpduMigrationCheck.setReference('IEEE P802.1w')
if mibBuilder.loadTexts: hpicfBridgeRstpForceBpduMigrationCheck.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpForceBpduMigrationCheck.setDescription('When operating in RSTP version 2 or later, writing TRUE(1) to this object forces this port to transmit RSTP BPDUs. Any other operation on this object always returns FALSE(2) when read.')
hpicfBridgeRstpAutoEdgePort = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 8), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpAutoEdgePort.setReference('IEEE 802.1D-2004')
if mibBuilder.loadTexts: hpicfBridgeRstpAutoEdgePort.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpAutoEdgePort.setDescription('This object determines the identification of edge ports. When set to TRUE, it is used by the bridge detection state machine for automatic identification of edge ports. The default value is FALSE.')
hpicfBridgeRstpPortBpduFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 5, 1, 9), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeRstpPortBpduFiltering.setReference('IEEE P802.1w')
if mibBuilder.loadTexts: hpicfBridgeRstpPortBpduFiltering.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortBpduFiltering.setDescription('This objects determines the BPDU filtering on ports. When set to TRUE, the port does not transmit any BPDU and all the received BPDUs are dropped. When set to FALSE, all the BPDUs are processed normally. The default is false.')
hpicfBridgeStpBpduThrottleConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 6))
hpicfBridgeStpBpduThrottleStatus = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 6, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2))).clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeStpBpduThrottleStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeStpBpduThrottleStatus.setDescription('This object is used to enable or disable the BPDU Throttling feature on the device.')
hpicfBridgeStpBpduThrottleValue = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 4, 6, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(256)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeStpBpduThrottleValue.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeStpBpduThrottleValue.setDescription('This object provides the inbound rate limit value to throttle the MSTP BPDUs on the device. The valid throttle values are 64, 128, and 256 packets per second (pps). The default throttle value is 256 pps')
class LoopProtectReceiverAction(TextualConvention, Integer32):
    description = ' This TC describes the actions a port that receives a Loop Protection Protocol packet can take. The disableTx(1) enumeration indicates that the sender of the Loop Protect packet will be disabled. The noDisable(2) enumeration indicates that no port is to be disabled. The disableTxRx(3) enumeration indicates that the senders and receivers of the Loop Protect packets will be disabled.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("disableTx", 1), ("noDisable", 2), ("disableTxRx", 3))

hpicfBridgeLoopProtect = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5))
hpicfBridgeLoopProtectNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 0))
hpicfBridgeLoopProtectBase = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 1))
hpicfBridgeLoopProtectPort = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2))
hpicfBridgeLoopProtectInterval = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectInterval.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectInterval.setDescription('The interval in seconds at which Loop Protection packets are transmitted. The default value is 5 seconds.')
hpicfBridgeLoopProtectTrapLoopDetectEnable = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 1, 2), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectTrapLoopDetectEnable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectTrapLoopDetectEnable.setDescription('Indicates whether notifications should be sent when a loop is detected on a port. By default this object will have a value of false(2).')
hpicfBridgeLoopProtectEnableTimer = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectEnableTimer.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectEnableTimer.setDescription('The time in seconds to wait before re-enabling a port disabled by Loop Protection. When a port is disabled by Loop Protection, a re-enable timer for the port is initialized. If the re-enable timer value is specified as zero seconds the port remains disabled, else the port is re-enabled after the specified time.')
hpicfBridgeLoopProtectMode = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("port", 1), ("vlan", 2))).clone('port')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectMode.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectMode.setDescription('This object is used to configure the operational mode of Loop Protection feature. The Loop Protection feature can be configured to operate in port mode or VLAN mode.')
hpicfBridgeLoopProtectVIDList = MibScalar((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 1, 5), VidList()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectVIDList.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectVIDList.setDescription('A list of VLANs on which Loop Protection is enabled.')
hpicfBridgeLoopProtectPortTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1), )
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortTable.setDescription('Per-interface configuration for Loop Protection.')
hpicfBridgeLoopProtectPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortEntry.setDescription('Loop Protection configuration information for a single port.')
hpicfBridgeLoopProtectPortEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1, 1, 1), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortEnable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortEnable.setDescription('This object indicates whether the Loop Protection is enabled on a port. The default value is FALSE')
hpicfBridgeLoopProtectPortLoopDetected = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1, 1, 2), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortLoopDetected.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortLoopDetected.setDescription("This object will be set to TRUE when a loop is detected on the port. The value of this object will be reset to FALSE when the port's hpicfBridgeLoopProtectPortEnable is set to FALSE.")
hpicfBridgeLoopProtectPortLastLoopTime = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1, 1, 3), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortLastLoopTime.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortLastLoopTime.setDescription('The value of sysUpTime when a loop was last detected on this port. A value of 0 means that the timestamp has not been set.')
hpicfBridgeLoopProtectPortLoopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortLoopCount.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortLoopCount.setDescription('This object provides the number of loops detected on a Loop Protection enabled port. The value of this object is set to zero when Loop Protection is disabled on a port.')
hpicfBridgeLoopProtectPortReceiverAction = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1, 1, 5), LoopProtectReceiverAction()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortReceiverAction.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectPortReceiverAction.setDescription("Controls the action taken when a Loop Protection packet is received on this port. When set to 'disableTx' the port that transmitted the packet is disabled. When set to 'noDisable' the transmitting port is not disabled. When set to 'disableTxRx' the ports transmitting and receiving the packets are disabled.")
hpicfBridgeLoopDetectedVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfBridgeLoopDetectedVlan.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopDetectedVlan.setDescription('Refers to this object for the port on which loop is detected.')
hpicfBridgeLoopProtectLoopDetectedNotification = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 0, 1)).setObjects(("IF-MIB", "ifIndex"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortLoopCount"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortReceiverAction"))
if mibBuilder.loadTexts: hpicfBridgeLoopProtectLoopDetectedNotification.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectLoopDetectedNotification.setDescription('A hpicfBridgeLoopProtectLoopDetectedNotification signifies that a loop is detected by the Loop Protection Protocol. Generation of this notification is controlled by hpicfBridgeLoopProtectTrapLoopDetectEnable. To prevent excessive notifications, this trap allows only one notifications every 30 seconds. Notifications that are missed due to this limitation are dropped and are not sent later.')
hpicfBridgeVlanLoopProtectLoopDetectedNotification = NotificationType((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 5, 0, 2)).setObjects(("IF-MIB", "ifIndex"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortLoopCount"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortReceiverAction"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopDetectedVlan"))
if mibBuilder.loadTexts: hpicfBridgeVlanLoopProtectLoopDetectedNotification.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVlanLoopProtectLoopDetectedNotification.setDescription('A hpicfBridgeLoopProtectLoopDetectedNotification signifies that a loop is detected by the Loop Protection feature while operating in VLAN mode. Generation of this notification is controlled by hpicfBridgeLoopProtectTrapLoopDetectEnable. To prevent excessive notifications, this trap allows only one notifications every 30 seconds. Notifications that are missed due to this limitation are dropped and are not sent later.')
hpicfBridgeMirrorSession = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6))
hpicfBridgeMirrorSessionBase = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6, 1))
hpicfBridgeMirrorSessionDestination = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6, 2))
hpicfBridgeMirrorSessionTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6, 2, 1), )
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionTable.setDescription('This table contains mirror session information related to a given specified destination. A mirror session is a group of one or more portCopyEntries all having the same specified destination. A given specified destination may be associated with more then one mirror session.')
hpicfBridgeMirrorSessionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6, 2, 1, 1), )
portCopyEntry.registerAugmentions(("HP-ICF-BRIDGE", "hpicfBridgeMirrorSessionEntry"))
hpicfBridgeMirrorSessionEntry.setIndexNames(*portCopyEntry.getIndexNames())
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionEntry.setDescription('An entry in the hpicfBridgeMirrorSessionEntry contains mirror session specific identification information.')
hpicfBridgeMirrorSessionID = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionID.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionID.setDescription('This variable is valid only for mirroring transfers. It allows mirroring destinations to be grouped. A given hpicfBridgeMirrorSessionID can only be used with 1 destination. However, multiple sources may be related to the same hpicfBridgeMirrorSessionID. To ensure that the hpicfBridgeMirrorSessionID is properly assigned, it can only be updated when the respective portCopyEntry object is in the notReady state. For non-mirroring transfers, the value should be set to 0. ')
hpicfBridgeDontTagWithVlan = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeDontTagWithVlan.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeDontTagWithVlan.setDescription("This objects determines whether to include IEEE 802.1Q tag in the mirrored copy of the packet. When the value of this object is set to 1 ('enabled'), the IEEE 802.1Q VLAN tag is not included in the mirrored packet. When the value of this object is set to 2 ('disabled'), the IEEE 802.1Q VLAN tag is included in the mirrored packet. After this value is set, it is retained even after system reboot.")
hpicfBridgeMirrorSessionType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 6, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("noMirror", 1), ("mirrorAddresses", 2), ("mirrorPolicies", 3), ("mirrorPorts", 4), ("mirrorVlan", 5))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionType.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionType.setDescription('This oid mentions what is the source type of traffic associated with mirror session. noMirror Not associated with any mirroring. mirrorAddresses Mirror traffic based on addresses mirrorPolicies Mirror traffic based on policies. mirrorPorts Mirror traffic based on ports. mirrorVlan Mirror traffic based on vlan. ')
hpicfBridgeVoiceVlanConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 7))
hpicfBridgeVoiceVlanConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 7, 1), )
if mibBuilder.loadTexts: hpicfBridgeVoiceVlanConfigTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVoiceVlanConfigTable.setDescription('An HP proprietary extension to the dot1qVlanStaticTable to configure a Voice VLAN.')
hpicfBridgeVoiceVlanConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 7, 1, 1), )
dot1qVlanStaticEntry.registerAugmentions(("HP-ICF-BRIDGE", "hpicfBridgeVoiceVlanConfigEntry"))
hpicfBridgeVoiceVlanConfigEntry.setIndexNames(*dot1qVlanStaticEntry.getIndexNames())
if mibBuilder.loadTexts: hpicfBridgeVoiceVlanConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVoiceVlanConfigEntry.setDescription('An entry for HP Specific extension table.')
hpicfBridgeVoiceVlanEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 7, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeVoiceVlanEnable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVoiceVlanEnable.setDescription('Labels the VLAN as a Voice VLAN which allows to separate, prioritize, and authenticate voice traffic moving through the network.')
hpicfBridgeJumboInterfaceConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 8))
hpicfBridgeJumboInterfaceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 8, 1), )
if mibBuilder.loadTexts: hpicfBridgeJumboInterfaceConfigTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeJumboInterfaceConfigTable.setDescription('This table contains the jumbo frame configuration of all interfaces.')
hpicfBridgeJumboInterfaceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 8, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hpicfBridgeJumboInterfaceConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeJumboInterfaceConfigEntry.setDescription('An entry in the hpicfBridgeJumboInterfaceConfigTable, which contains the jumbo frame configuration of an interface.')
hpicfBridgeJumboInterfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 8, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeJumboInterfaceEnable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeJumboInterfaceEnable.setDescription('This object enables or disables the support for jumbo frames. This configuration is supported only on VLAN interfaces.')
hpicfBridgeManagementInterfaceConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 9))
hpicfBridgeManagementInterfaceConfigTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 9, 1), )
if mibBuilder.loadTexts: hpicfBridgeManagementInterfaceConfigTable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeManagementInterfaceConfigTable.setDescription('This table contains objects for configuring interface as Management interface.')
hpicfBridgeManagementInterfaceConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 9, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: hpicfBridgeManagementInterfaceConfigEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeManagementInterfaceConfigEntry.setDescription('An entry in the hpicfBridgeManagementInterfaceConfigEntry contains objects for configuring interface as management interface.')
hpicfBridgeManagementInterfaceEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 1, 9, 1, 1, 1), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hpicfBridgeManagementInterfaceEnable.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeManagementInterfaceEnable.setDescription('This object configures a VLAN as a Secure Management VLAN. When the value of this object is set to TRUE, a VLAN acts as a Secure Management VLAN. The default value of this object is FALSE for all VLANs. For VLAN with VID 1, which is the Secure Management VLAN of the switch by default, the value is TRUE. Only one VLAN can be configured as a Secure Management VLAN at any given time.')
hpicfBridgeConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2))
hpicfBridgeGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1))
hpicfBridgeCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2))
hpicfBridgeNotGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 3))
hpicfBridgeVlanBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 1)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeMaxVlans"), ("HP-ICF-BRIDGE", "hpicfBridgeVlanEnable"), ("HP-ICF-BRIDGE", "hpicfBridgePrimaryVlan"), ("HP-ICF-BRIDGE", "hpicfBridgeVlanConfigStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeVlanBaseGroup = hpicfBridgeVlanBaseGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVlanBaseGroup.setDescription('Basic VLAN configuration information that is not in the standard 802.1Q Bridge MIB.')
hpicfBridgeGvrpPortGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 2)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeGvrpRestrictedVlanReg"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeGvrpPortGroup = hpicfBridgeGvrpPortGroup.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfBridgeGvrpPortGroup.setDescription('********* THIS GROUP IS DEPRECATED ********* GVRP configuration information that is not (yet) in the standard 802.1Q Bridge MIB. Note that this information is very likely to be added to a future update of the 802.1Q Bridge MIB, at which time, support for objects in this group will most likely be deprecated. This object has been deprecated and replaced with hpicfBridgeGvrpPortGroup1')
hpicfBridgeRstpBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 3)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeRstpForceVersion"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpConfigStatus"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpProtocolVersion"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpAdminStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeRstpBaseGroup = hpicfBridgeRstpBaseGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpBaseGroup.setDescription('Rapid Spanning Tree Protocol (RSTP) configuration information that is in neither the standard 802.1w MIB, nor the standard 802.1d (STP) MIB. Note that as RSTP improves compatibility, some objects in this MIB will likely be deprecated.')
hpicfBridgeLoopProtectBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 4)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectInterval"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectEnableTimer"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectTrapLoopDetectEnable"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortEnable"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortLoopDetected"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortLastLoopTime"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortLoopCount"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectPortReceiverAction"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeLoopProtectBaseGroup = hpicfBridgeLoopProtectBaseGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectBaseGroup.setDescription('A collection of objects providing basic instrumentation and control of the HP Loop protection entity.')
hpicfBridgeVoiceVlanConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 7)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVoiceVlanEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeVoiceVlanConfigGroup = hpicfBridgeVoiceVlanConfigGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVoiceVlanConfigGroup.setDescription('A collection of objects for voice configuration on vlan.')
hpicfBridgeJumboInterfaceConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 8)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeJumboInterfaceEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeJumboInterfaceConfigGroup = hpicfBridgeJumboInterfaceConfigGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeJumboInterfaceConfigGroup.setDescription('A collection of objects providing Jumbo configuration on a interface.')
hpicfBridgeManagementInterfaceConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 9)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeManagementInterfaceEnable"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeManagementInterfaceConfigGroup = hpicfBridgeManagementInterfaceConfigGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeManagementInterfaceConfigGroup.setDescription('A collection of objects for management interface configuration.')
hpicfBridgeLoopProtectVLANGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 10)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectMode"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectVIDList"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopDetectedVlan"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeLoopProtectVLANGroup = hpicfBridgeLoopProtectVLANGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectVLANGroup.setDescription('A collection of objects providing support for Loop Protect per VLAN feature.')
hpicfBridgeRstpPortEntryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 11)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeRstpAdminEdgePort"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpOperEdgePort"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpAdminPointToPointMac"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpOperPointToPointMac"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpPortPathCost"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpForceBpduMigrationCheck"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpAutoEdgePort"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpPortBpduFiltering"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeRstpPortEntryGroup = hpicfBridgeRstpPortEntryGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortEntryGroup.setDescription('A collection of objects providing support for Rstp.')
hpicfBridgeMirrorSessionEntryGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 12)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeDontTagWithVlan"), ("HP-ICF-BRIDGE", "hpicfBridgeMirrorSessionType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeMirrorSessionEntryGroup = hpicfBridgeMirrorSessionEntryGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionEntryGroup.setDescription('A collection of objects providing mirror session information related to a given specific destination.')
hpicfBridgeRstpPortEntryGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 13)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeRstpPortIndex"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeRstpPortEntryGroup1 = hpicfBridgeRstpPortEntryGroup1.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortEntryGroup1.setDescription('A collection of objects providing support for Rstp.')
hpicfBridgeGvrpPortGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 14)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeGvrpRestrictedVlanReg"), ("HP-ICF-BRIDGE", "hpicfApplicantStateMachine"), ("HP-ICF-BRIDGE", "hpicfRegistarStateMachine"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeGvrpPortGroup1 = hpicfBridgeGvrpPortGroup1.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeGvrpPortGroup1.setDescription('GVRP configuration information that is not (yet) in the standard 802.1Q Bridge MIB. Note that this information is very likely to be added to a future update of the 802.1Q Bridge MIB, at which time, support for objects in this group will most likely be deprecated.')
hpicfBridgeStpBpduThrottleConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 15)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeStpBpduThrottleStatus"), ("HP-ICF-BRIDGE", "hpicfBridgeStpBpduThrottleValue"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeStpBpduThrottleConfigGroup = hpicfBridgeStpBpduThrottleConfigGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeStpBpduThrottleConfigGroup.setDescription('A group of objects that are used to configure the BPDU Throttling feature.')
hpicfBridgeLoopProtectNotGrp = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 3, 1)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectLoopDetectedNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeLoopProtectNotGrp = hpicfBridgeLoopProtectNotGrp.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectNotGrp.setDescription('Notifications for Loop protection.')
hpicfBridgeVlanLoopProtectNotGrp = NotificationGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 3, 2)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVlanLoopProtectLoopDetectedNotification"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeVlanLoopProtectNotGrp = hpicfBridgeVlanLoopProtectNotGrp.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVlanLoopProtectNotGrp.setDescription('Notifications for Loop protect per VLAN')
hpicfBridgeMirrorSessionBaseGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 1, 5)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeMirrorSessionID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeMirrorSessionBaseGroup = hpicfBridgeMirrorSessionBaseGroup.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionBaseGroup.setDescription('A collection of objects providing identification of a mirroring session entity.')
hpicfBridgeCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 1)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVlanBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeGvrpPortGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeCompliance = hpicfBridgeCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfBridgeCompliance.setDescription('The compliance statement for HP Switches with IEEE 802.1Q VLAN support for bridging objects not found in the standard Bridge MIBs.')
hpicfBridgeComplianceRevTwo = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 2)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVlanBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeGvrpPortGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpBaseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeComplianceRevTwo = hpicfBridgeComplianceRevTwo.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfBridgeComplianceRevTwo.setDescription('The compliance statement for HP Switches with IEEE 802.1W Rapid Spanning Tree Protocol support for bridging objects not found in the standard Bridge MIBs.')
hpicfBridgeComplianceRevThree = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 3)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVlanBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeGvrpPortGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpBaseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeComplianceRevThree = hpicfBridgeComplianceRevThree.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfBridgeComplianceRevThree.setDescription('The compliance statement for HP Switches with IEEE 802.1W Rapid Spanning Tree Protocol support for bridging objects not found in the standard Bridge MIBs.')
hpicfBridgeComplianceRevFour = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 4)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVlanBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeGvrpPortGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeMirrorSessionBaseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeComplianceRevFour = hpicfBridgeComplianceRevFour.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfBridgeComplianceRevFour.setDescription('The compliance statement for HP Switches with IEEE 802.1W Rapid Spanning Tree Protocol support for bridging objects not found in the standard Bridge MIBs.')
hpicfBridgeLoopProtectCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 5)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectNotifications"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectNotifications"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeLoopProtectCompliance = hpicfBridgeLoopProtectCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeLoopProtectCompliance.setDescription('The compliance statement for HP Switches with support for hpicfBridge loop protection objects.')
hpicfBridgeVlanBaseConfigCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 6)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVoiceVlanConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeVlanBaseConfigCompliance = hpicfBridgeVlanBaseConfigCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVlanBaseConfigCompliance.setDescription('The compliance statement for HP Switches that support basic vlan configuration.')
hpicfBridgeInterfaceConfigCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 7)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeJumboInterfaceConfigGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeManagementInterfaceConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeInterfaceConfigCompliance = hpicfBridgeInterfaceConfigCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeInterfaceConfigCompliance.setDescription('The compliance statement for HP Switches that support basic interface configuration.')
hpicfBridgeVlanLoopProtConfigCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 8)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectVLANGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeVlanLoopProtectNotGrp"), ("HP-ICF-BRIDGE", "hpicfBridgeLoopProtectNotGrp"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeVlanLoopProtConfigCompliance = hpicfBridgeVlanLoopProtConfigCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeVlanLoopProtConfigCompliance.setDescription('The compliance statement for HP Switches that support loop protect per VLAN feature.')
hpicfBridgeRstpPortEntryCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 9)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeRstpPortEntryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeRstpPortEntryCompliance = hpicfBridgeRstpPortEntryCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortEntryCompliance.setDescription('The compliance statement for HP Switches that support Rstp.')
hpicfBridgeMirrorSessionEntryCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 10)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeMirrorSessionEntryGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeMirrorSessionEntryCompliance = hpicfBridgeMirrorSessionEntryCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeMirrorSessionEntryCompliance.setDescription('The compliance statement for HP Switches that support mirror sessions.')
hpicfBridgeRstpPortEntryCompliance1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 11)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeRstpPortEntryGroup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeRstpPortEntryCompliance1 = hpicfBridgeRstpPortEntryCompliance1.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeRstpPortEntryCompliance1.setDescription('The compliance statement for HP Switches that support Rstp.')
hpicfBridgeComplianceRevFour1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 12)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeVlanBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeGvrpPortGroup1"), ("HP-ICF-BRIDGE", "hpicfBridgeRstpBaseGroup"), ("HP-ICF-BRIDGE", "hpicfBridgeMirrorSessionBaseGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeComplianceRevFour1 = hpicfBridgeComplianceRevFour1.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeComplianceRevFour1.setDescription('The compliance statement for HP Switches with IEEE 802.1W Rapid Spanning Tree Protocol support for bridging objects not found in the standard Bridge MIBs.')
hpicfBridgeStpBpduThrottleConfigCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 12, 2, 2, 13)).setObjects(("HP-ICF-BRIDGE", "hpicfBridgeStpBpduThrottleConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfBridgeStpBpduThrottleConfigCompliance = hpicfBridgeStpBpduThrottleConfigCompliance.setStatus('current')
if mibBuilder.loadTexts: hpicfBridgeStpBpduThrottleConfigCompliance.setDescription('The compliance statement for the MSTP BPDU Throttling feature.')
mibBuilder.exportSymbols("HP-ICF-BRIDGE", hpicfBridgeManagementInterfaceEnable=hpicfBridgeManagementInterfaceEnable, hpicfBridgeJumboInterfaceEnable=hpicfBridgeJumboInterfaceEnable, hpicfBridgeLoopProtectPortLoopDetected=hpicfBridgeLoopProtectPortLoopDetected, hpicfBridgeRstp=hpicfBridgeRstp, hpicfBridgeRstpPortPathCost=hpicfBridgeRstpPortPathCost, hpicfBridge=hpicfBridge, hpicfBridgeRstpOperEdgePort=hpicfBridgeRstpOperEdgePort, hpicfBridgeRstpPortEntryGroup1=hpicfBridgeRstpPortEntryGroup1, hpicfBridgeRstpAdminStatus=hpicfBridgeRstpAdminStatus, hpicfBridgeVlanLoopProtectLoopDetectedNotification=hpicfBridgeVlanLoopProtectLoopDetectedNotification, hpicfBridgeRstpAdminPointToPointMac=hpicfBridgeRstpAdminPointToPointMac, hpicfBridgeComplianceRevFour=hpicfBridgeComplianceRevFour, hpicfBridgeMirrorSessionTable=hpicfBridgeMirrorSessionTable, hpicfBridgeLoopProtectPortEntry=hpicfBridgeLoopProtectPortEntry, hpicfBridgeMirrorSessionEntry=hpicfBridgeMirrorSessionEntry, hpicfBridgeRstpPortIndex=hpicfBridgeRstpPortIndex, hpicfBridgeLoopProtectTrapLoopDetectEnable=hpicfBridgeLoopProtectTrapLoopDetectEnable, hpicfBridgeLoopProtectBase=hpicfBridgeLoopProtectBase, hpicfBridgeVlanLoopProtectNotGrp=hpicfBridgeVlanLoopProtectNotGrp, hpicfBridgeRstpPortEntryCompliance=hpicfBridgeRstpPortEntryCompliance, hpicfBridgeGvrpRestrictedVlanReg=hpicfBridgeGvrpRestrictedVlanReg, hpicfBridgeLoopProtectPortLastLoopTime=hpicfBridgeLoopProtectPortLastLoopTime, hpicfBridgeVoiceVlanConfigEntry=hpicfBridgeVoiceVlanConfigEntry, hpicfBridgeLoopProtectVLANGroup=hpicfBridgeLoopProtectVLANGroup, hpicfBridgeStpBpduThrottleConfigCompliance=hpicfBridgeStpBpduThrottleConfigCompliance, hpicfBridgeMirrorSessionBaseGroup=hpicfBridgeMirrorSessionBaseGroup, hpicfRegistarStateMachine=hpicfRegistarStateMachine, hpicfBridgeManagementInterfaceConfigGroup=hpicfBridgeManagementInterfaceConfigGroup, hpicfBridgeLoopProtectNotifications=hpicfBridgeLoopProtectNotifications, hpicfBridgeLoopProtectPortLoopCount=hpicfBridgeLoopProtectPortLoopCount, hpicfBridgeLoopProtectMode=hpicfBridgeLoopProtectMode, hpicfBridgeManagementInterfaceConfig=hpicfBridgeManagementInterfaceConfig, hpicfBridgeLoopProtectPortReceiverAction=hpicfBridgeLoopProtectPortReceiverAction, hpicfBridgePrimaryVlan=hpicfBridgePrimaryVlan, hpicfBridgeComplianceRevFour1=hpicfBridgeComplianceRevFour1, hpicfApplicantStateMachine=hpicfApplicantStateMachine, hpicfBridgeMirrorSessionDestination=hpicfBridgeMirrorSessionDestination, hpicfBridgeLoopProtectEnableTimer=hpicfBridgeLoopProtectEnableTimer, hpicfBridgeGvrpPortGroup1=hpicfBridgeGvrpPortGroup1, hpicfBridgeRstpPortEntry=hpicfBridgeRstpPortEntry, hpicfBridgeStpBpduThrottleConfigGroup=hpicfBridgeStpBpduThrottleConfigGroup, hpicfBridgeVoiceVlanConfig=hpicfBridgeVoiceVlanConfig, hpicfBridgeGroups=hpicfBridgeGroups, hpicfBridgeRstpPortBpduFiltering=hpicfBridgeRstpPortBpduFiltering, hpicfBridgeNotGroups=hpicfBridgeNotGroups, LoopProtectReceiverAction=LoopProtectReceiverAction, hpicfBridgeRstpOperPointToPointMac=hpicfBridgeRstpOperPointToPointMac, hpicfBridgeCompliances=hpicfBridgeCompliances, BridgeId=BridgeId, hpicfBridgeStpBpduThrottleConfig=hpicfBridgeStpBpduThrottleConfig, hpicfGenericVlanId=hpicfGenericVlanId, hpicfBridgeRstpForceVersion=hpicfBridgeRstpForceVersion, hpicfBridgeLoopProtectVIDList=hpicfBridgeLoopProtectVIDList, hpicfBridgeGvrpPortEntry=hpicfBridgeGvrpPortEntry, hpicfBridgeMirrorSessionEntryCompliance=hpicfBridgeMirrorSessionEntryCompliance, hpicfBridgeJumboInterfaceConfig=hpicfBridgeJumboInterfaceConfig, hpicfBridgeVoiceVlanEnable=hpicfBridgeVoiceVlanEnable, hpicfBridgeVlanBaseConfigCompliance=hpicfBridgeVlanBaseConfigCompliance, hpicfBridgeLoopDetectedVlan=hpicfBridgeLoopDetectedVlan, hpicfBridgeLoopProtectPortEnable=hpicfBridgeLoopProtectPortEnable, hpicfBridgeLoopProtectLoopDetectedNotification=hpicfBridgeLoopProtectLoopDetectedNotification, hpicfBridgeVlanBaseGroup=hpicfBridgeVlanBaseGroup, hpicfBridgeRstpForceBpduMigrationCheck=hpicfBridgeRstpForceBpduMigrationCheck, hpicfBridgeVoiceVlanConfigTable=hpicfBridgeVoiceVlanConfigTable, hpicfBridgeLoopProtectPort=hpicfBridgeLoopProtectPort, hpicfBridgeMirrorSessionEntryGroup=hpicfBridgeMirrorSessionEntryGroup, hpicfBridgeLoopProtect=hpicfBridgeLoopProtect, hpicfBridgeStpBpduThrottleValue=hpicfBridgeStpBpduThrottleValue, hpicfBridgeRstpPortTable=hpicfBridgeRstpPortTable, hpicfBridgeInterfaceConfigCompliance=hpicfBridgeInterfaceConfigCompliance, hpicfBridgeVlanEnable=hpicfBridgeVlanEnable, hpicfBridgeGvrpStateMachineTable=hpicfBridgeGvrpStateMachineTable, hpicfBridgeVoiceVlanConfigGroup=hpicfBridgeVoiceVlanConfigGroup, hpicfBridgeLoopProtectCompliance=hpicfBridgeLoopProtectCompliance, hpicfBridgeBase=hpicfBridgeBase, hpicfBridgeVlanLoopProtConfigCompliance=hpicfBridgeVlanLoopProtConfigCompliance, hpicfBridgeRstpAutoEdgePort=hpicfBridgeRstpAutoEdgePort, hpicfBridgeComplianceRevTwo=hpicfBridgeComplianceRevTwo, hpicfBridgeJumboInterfaceConfigEntry=hpicfBridgeJumboInterfaceConfigEntry, hpicfBridgeComplianceRevThree=hpicfBridgeComplianceRevThree, hpicfBridgeRstpPortEntryCompliance1=hpicfBridgeRstpPortEntryCompliance1, hpicfBridgeGvrp=hpicfBridgeGvrp, hpicfBridgeJumboInterfaceConfigTable=hpicfBridgeJumboInterfaceConfigTable, hpicfBridgeGvrpPortTable=hpicfBridgeGvrpPortTable, hpicfBridgeMirrorSession=hpicfBridgeMirrorSession, hpicfBridgeDontTagWithVlan=hpicfBridgeDontTagWithVlan, hpicfBridgeLoopProtectNotGrp=hpicfBridgeLoopProtectNotGrp, hpicfBridgeRstpProtocolVersion=hpicfBridgeRstpProtocolVersion, hpicfBridgeObjects=hpicfBridgeObjects, hpicfBridgeVlanConfigStatus=hpicfBridgeVlanConfigStatus, hpicfBridgeManagementInterfaceConfigEntry=hpicfBridgeManagementInterfaceConfigEntry, hpicfBridgeGvrpStateMachineEntry=hpicfBridgeGvrpStateMachineEntry, PYSNMP_MODULE_ID=hpicfBridge, hpicfBridgeLoopProtectInterval=hpicfBridgeLoopProtectInterval, hpicfBridgeMirrorSessionType=hpicfBridgeMirrorSessionType, hpicfBridgeGvrpPortGroup=hpicfBridgeGvrpPortGroup, hpicfBridgeLoopProtectBaseGroup=hpicfBridgeLoopProtectBaseGroup, hpicfBridgeStpBpduThrottleStatus=hpicfBridgeStpBpduThrottleStatus, hpicfBridgeMirrorSessionID=hpicfBridgeMirrorSessionID, hpicfBridgeJumboInterfaceConfigGroup=hpicfBridgeJumboInterfaceConfigGroup, hpicfBridgeLoopProtectPortTable=hpicfBridgeLoopProtectPortTable, hpicfBridgeConformance=hpicfBridgeConformance, hpicfBridgeRstpConfigStatus=hpicfBridgeRstpConfigStatus, hpicfBridgeRstpAdminEdgePort=hpicfBridgeRstpAdminEdgePort, hpicfBridgeCompliance=hpicfBridgeCompliance, hpicfBridgeManagementInterfaceConfigTable=hpicfBridgeManagementInterfaceConfigTable, hpicfBridgeMirrorSessionBase=hpicfBridgeMirrorSessionBase, hpicfBridgeRstpPortEntryGroup=hpicfBridgeRstpPortEntryGroup, hpicfBridgeRstpBaseGroup=hpicfBridgeRstpBaseGroup, hpicfBridgeMaxVlans=hpicfBridgeMaxVlans)

#
# PySNMP MIB module USB-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/USB-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:28:54 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Gauge32, NotificationType, Counter32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, MibIdentifier, Unsigned32, Counter64, TimeTicks, iso, Bits, experimental, Integer32, IpAddress, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "NotificationType", "Counter32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "MibIdentifier", "Unsigned32", "Counter64", "TimeTicks", "iso", "Bits", "experimental", "Integer32", "IpAddress", "ModuleIdentity")
TruthValue, DisplayString, MacAddress, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "MacAddress", "TextualConvention")
usbMib = ModuleIdentity((1, 3, 6, 1, 3, 103))
if mibBuilder.loadTexts: usbMib.setLastUpdated('200008070000Z')
if mibBuilder.loadTexts: usbMib.setOrganization('3Com')
if mibBuilder.loadTexts: usbMib.setContactInfo(' Benjamin Dolnik Postal: 3Com Corporation 3800 Golf Road Rolling Meadows, IL 60008 USA Phone: +1 847 262 2098 E-mail: benjamin-dolnik@3com.com')
if mibBuilder.loadTexts: usbMib.setDescription('The MIB module to describe the USB interface.')
usbMibObjects = MibIdentifier((1, 3, 6, 1, 3, 103, 1))
usbNumber = MibScalar((1, 3, 6, 1, 3, 103, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbNumber.setStatus('current')
if mibBuilder.loadTexts: usbNumber.setDescription('The number of ports regardless of their current state in the usb general port table')
usbPortTable = MibTable((1, 3, 6, 1, 3, 103, 1, 2), )
if mibBuilder.loadTexts: usbPortTable.setStatus('current')
if mibBuilder.loadTexts: usbPortTable.setDescription('A list of port entries. The number of entries is given by the value usbNumber.')
usbPortEntry = MibTableRow((1, 3, 6, 1, 3, 103, 1, 2, 1), ).setIndexNames((0, "USB-MIB", "usbPortIndex"))
if mibBuilder.loadTexts: usbPortEntry.setStatus('current')
if mibBuilder.loadTexts: usbPortEntry.setDescription('Status and parameter values for the USB port.')
usbPortIndex = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbPortIndex.setStatus('current')
if mibBuilder.loadTexts: usbPortIndex.setDescription('The unique identifier of the USB port hardware. By convention and if possible, hardware port numbers map directly to external connectors.')
usbPortType = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("host", 1), ("device", 2), ("hub", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbPortType.setStatus('current')
if mibBuilder.loadTexts: usbPortType.setDescription('The type of the USB port')
usbPortRate = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("low-speed", 1), ("full-speed", 2), ("high-speed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbPortRate.setStatus('current')
if mibBuilder.loadTexts: usbPortRate.setDescription('The USB port rate that could be low-speed(1) for 1.5 Mbps, full-speed(2) for 12Mbps or high-speed(3) for USB 2.0')
usbDeviceTable = MibTable((1, 3, 6, 1, 3, 103, 1, 3), )
if mibBuilder.loadTexts: usbDeviceTable.setStatus('current')
if mibBuilder.loadTexts: usbDeviceTable.setDescription('A list of USB device ports. Usually the device has only one USB device port')
usbDeviceEntry = MibTableRow((1, 3, 6, 1, 3, 103, 1, 3, 1), ).setIndexNames((0, "USB-MIB", "usbDeviceIndex"))
if mibBuilder.loadTexts: usbDeviceEntry.setStatus('current')
if mibBuilder.loadTexts: usbDeviceEntry.setDescription('Status and parameter values for the USB device port.')
usbDeviceIndex = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceIndex.setStatus('current')
if mibBuilder.loadTexts: usbDeviceIndex.setDescription('The index is identical to usbPortIndex for the correspondent USB port')
usbDevicePower = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("self-powered", 2), ("bus-powered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDevicePower.setStatus('current')
if mibBuilder.loadTexts: usbDevicePower.setDescription('the way USB device port is powered')
usbDeviceVendorID = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceVendorID.setStatus('current')
if mibBuilder.loadTexts: usbDeviceVendorID.setDescription('The USB device port vendor HEX-formatted string as it is provided to the USB host by the USB device')
usbDeviceProductID = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceProductID.setStatus('current')
if mibBuilder.loadTexts: usbDeviceProductID.setDescription('The product ID HEX-formatted string as it is provided to the USB host by the USB device')
usbDeviceNumberConfigurations = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceNumberConfigurations.setStatus('current')
if mibBuilder.loadTexts: usbDeviceNumberConfigurations.setDescription('The total number of configurations the USB port supports. Device port should support at least one configuration')
usbDeviceActiveClass = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("cdc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceActiveClass.setStatus('current')
if mibBuilder.loadTexts: usbDeviceActiveClass.setDescription('This object returns USB Device Class type of the active configuration')
usbDeviceStatus = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("unattached", 1), ("attached", 2), ("powered", 3), ("default", 4), ("address", 5), ("configured", 6), ("suspended", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceStatus.setStatus('current')
if mibBuilder.loadTexts: usbDeviceStatus.setDescription('Current status of the USB device state machine')
usbDeviceEnumCounter = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceEnumCounter.setStatus('current')
if mibBuilder.loadTexts: usbDeviceEnumCounter.setDescription('Total number reconnections (enumerations) since device is operational')
usbDeviceRemoteWakeup = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 9), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceRemoteWakeup.setStatus('current')
if mibBuilder.loadTexts: usbDeviceRemoteWakeup.setDescription("If set to true(1), the device supports Remote Wakeup function. If set to false(2), the device doesn't support it")
usbDeviceRemoteWakeupOn = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 3, 1, 10), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbDeviceRemoteWakeupOn.setStatus('current')
if mibBuilder.loadTexts: usbDeviceRemoteWakeupOn.setDescription('If set to true(1), the remote wakeup function is activated by the host. If set to false(2), remote wakeup function is not active.')
usbCDCTable = MibTable((1, 3, 6, 1, 3, 103, 1, 4), )
if mibBuilder.loadTexts: usbCDCTable.setStatus('current')
if mibBuilder.loadTexts: usbCDCTable.setDescription('A list of Communication Device Class (CDC) interfaces supported by the USB device. It could be more then one CDC interface for the device that expose more then one interface to the network')
usbCDCEntry = MibTableRow((1, 3, 6, 1, 3, 103, 1, 4, 1), ).setIndexNames((0, "USB-MIB", "usbCDCIndex"), (0, "USB-MIB", "usbCDCIfIndex"))
if mibBuilder.loadTexts: usbCDCEntry.setStatus('current')
if mibBuilder.loadTexts: usbCDCEntry.setDescription('Status and parameter values for CDC device')
usbCDCIndex = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCIndex.setStatus('current')
if mibBuilder.loadTexts: usbCDCIndex.setDescription('The index is identical to usbPortIndex for the correspondent USB port')
usbCDCIfIndex = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 4, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCIfIndex.setStatus('current')
if mibBuilder.loadTexts: usbCDCIfIndex.setDescription('The variable uniquely identifies the interface index which this CDC device is representing')
usbCDCSubclass = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("other", 0), ("directLine", 1), ("acm", 2), ("telephony", 3), ("multichannel", 4), ("capi", 5), ("ethernet", 6), ("atm", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCSubclass.setReference('USB Class definitions for Communication Devices ver 1.1, p.28 ')
if mibBuilder.loadTexts: usbCDCSubclass.setStatus('current')
if mibBuilder.loadTexts: usbCDCSubclass.setDescription('Subclass used in data transfer in Communication Device Class')
usbCDCVersion = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCVersion.setStatus('current')
if mibBuilder.loadTexts: usbCDCVersion.setDescription('String that describes the version of Communication Device Class in HEX format (Major, Minor) ')
usbCDCDataTransferType = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("synchronous", 1), ("asynchronous", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCDataTransferType.setStatus('current')
if mibBuilder.loadTexts: usbCDCDataTransferType.setDescription('Type of data transfer for Data Class Interface used by the Communication Device. Isochronious mode is used for synchronous(1) and bulk transfer mode is used for asynchronous(2)')
usbCDCDataEndpoints = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCDataEndpoints.setStatus('current')
if mibBuilder.loadTexts: usbCDCDataEndpoints.setDescription('Number of the data endpoints (IN and OUT) used by the Communication Device. If the networking device is in default interface setting, there are are no data endpoints and no traffic is exchanged. Under the normal operation there should be 2 Data Endpoints (one IN and one OUT) for the networking device. For the multichannel model this number could be larger then 2')
usbCDCStalls = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCStalls.setStatus('current')
if mibBuilder.loadTexts: usbCDCStalls.setDescription("Total number of times USB Data interface recovered from stall since re-initialization and while the port state was 'up' or 'test'.")
usbCDCEtherTable = MibTable((1, 3, 6, 1, 3, 103, 1, 5), )
if mibBuilder.loadTexts: usbCDCEtherTable.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherTable.setDescription('A list of Communication Device Class (CDC) USB devices that support Ethernet Networking Control Model.')
usbCDCEtherEntry = MibTableRow((1, 3, 6, 1, 3, 103, 1, 5, 1), ).setIndexNames((0, "USB-MIB", "usbCDCEtherIndex"), (0, "USB-MIB", "usbCDCEtherIfIndex"))
if mibBuilder.loadTexts: usbCDCEtherEntry.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherEntry.setDescription('Status and parameter values for CDC devices that support Ethernet Networking Control Model')
usbCDCEtherIndex = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCEtherIndex.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherIndex.setDescription('The index is identical to usbPortIndex for the correspondent USB port')
usbCDCEtherIfIndex = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 5, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCEtherIfIndex.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherIfIndex.setDescription('The variable uniquely identifies the interface index to which this CDC device is connected ')
usbCDCEtherMacAddress = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 5, 1, 3), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCEtherMacAddress.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherMacAddress.setDescription('The 48bit MAC address that is provided by USB CDC device to the host. This address will be used as the source address of Ethernet frames sent by the host over the particular CDC interface.')
usbCDCEtherPacketFilter = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 5, 1, 4), Bits().clone(namedValues=NamedValues(("packetPromiscuous", 0), ("packetAllMulticast", 1), ("packetDirected", 2), ("packetBroadcast", 3), ("packetMulticast", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCEtherPacketFilter.setReference('USB Class definitions for Communication Devices ver 1.1, p.66 Table 62')
if mibBuilder.loadTexts: usbCDCEtherPacketFilter.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherPacketFilter.setDescription('Bitmap indicates the host requirements to the USB device to perform Ethernet packet filtering of the particular type frames directed to the host')
usbCDCEtherDataStatisticsCapabilities = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 5, 1, 5), Bits().clone(namedValues=NamedValues(("frameXmitOk", 0), ("frameRcvOk", 1), ("frameXmitErr", 2), ("frameRcvErr", 3), ("frameRcvNoBuff", 4), ("bytesXmitDirectOk", 5), ("framesXmitDirectOk", 6), ("bytesXmitMulticastOk", 7), ("framesXmitMulticastOk", 8), ("bytesXmitBroadcastOk", 9), ("framesXmitBroadcastOk", 10), ("bytesRcvDirectOk", 11), ("framesRcvDirectOk", 12), ("bytesRcvMulticastOk", 13), ("framesRcvMulticastOk", 14), ("bytesRcvBroadcastOk", 15), ("framesRcvBroadcastOk", 16), ("framesRcvCrcErr", 17), ("xmitQueueLen", 18), ("rcvErrAlignment", 19), ("xmitOneCollision", 20), ("xmitMoreCollisions", 21), ("xmitDeferred", 22), ("xmitMaxCollision", 23), ("rcvOverrun", 24), ("xmitUnderrun", 25), ("xmitHearbeatFailure", 26), ("xmitTimesCrsLost", 27), ("xmitLateCollisions", 28)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCEtherDataStatisticsCapabilities.setReference('USB Class definitions for Communication Devices ver 1.1, p.46 Table 42')
if mibBuilder.loadTexts: usbCDCEtherDataStatisticsCapabilities.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherDataStatisticsCapabilities.setDescription('Bitmap indicates the ability to collect Ethernet statistics of different types as it provided in Ethernet Networking Functional Descriptor. If the Particular bit is set, the device could provide the corresponding statistics counter to the host')
usbCDCEtherDataCheckErrs = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 5, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: usbCDCEtherDataCheckErrs.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherDataCheckErrs.setDescription("Total number of frames with an invalid frame check sequence, input from the USB Data interface since system re-initialization and while the port state was 'up' or 'test'.")
usbCDCEtherXmtAddressTable = MibTable((1, 3, 6, 1, 3, 103, 1, 6), )
if mibBuilder.loadTexts: usbCDCEtherXmtAddressTable.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherXmtAddressTable.setDescription('This table contains an entry for each multicast address for which the system will transmit packets/frames on a particular USB interface.')
usbCDCEtherXmtAddressEntry = MibTableRow((1, 3, 6, 1, 3, 103, 1, 6, 1), ).setIndexNames((0, "USB-MIB", "usbCDCEtherIndex"), (0, "USB-MIB", "usbCDCEtherIfIndex"), (0, "USB-MIB", "ifCDCEtherXmtAddress"))
if mibBuilder.loadTexts: usbCDCEtherXmtAddressEntry.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherXmtAddressEntry.setDescription('A list of objects identifying an address for which the system will send packets/frames on the particular USB interface identified by the index values usbCDCIndex and ifIndex.')
ifCDCEtherXmtAddress = MibTableColumn((1, 3, 6, 1, 3, 103, 1, 6, 1, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifCDCEtherXmtAddress.setStatus('current')
if mibBuilder.loadTexts: ifCDCEtherXmtAddress.setDescription('An address for which the system will will send packets/frames on the particular USB interface. The address only could be set by the host by using the command for USB interface.')
usbMibNotification = MibIdentifier((1, 3, 6, 1, 3, 103, 2))
usbMibConformance = MibIdentifier((1, 3, 6, 1, 3, 103, 3))
usbMibCompliances = MibIdentifier((1, 3, 6, 1, 3, 103, 3, 1))
usbMibGroups = MibIdentifier((1, 3, 6, 1, 3, 103, 3, 2))
usbMibBasicCompliance = ModuleCompliance((1, 3, 6, 1, 3, 103, 3, 1, 1)).setObjects(("USB-MIB", "usbMibBasicGroup"), ("USB-MIB", "usbMibBasicGroup"), ("USB-MIB", "usbMibCDCGroup"), ("USB-MIB", "usbMibCDCEtherGroup"), ("USB-MIB", "usbCDCEtherXmtAddressGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    usbMibBasicCompliance = usbMibBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: usbMibBasicCompliance.setDescription('The compliance statement for devices that implement USB MIB')
usbMibBasicGroup = ObjectGroup((1, 3, 6, 1, 3, 103, 3, 2, 1)).setObjects(("USB-MIB", "usbNumber"), ("USB-MIB", "usbPortIndex"), ("USB-MIB", "usbPortType"), ("USB-MIB", "usbPortRate"), ("USB-MIB", "usbDeviceIndex"), ("USB-MIB", "usbDevicePower"), ("USB-MIB", "usbDeviceVendorID"), ("USB-MIB", "usbDeviceProductID"), ("USB-MIB", "usbDeviceNumberConfigurations"), ("USB-MIB", "usbDeviceActiveClass"), ("USB-MIB", "usbDeviceStatus"), ("USB-MIB", "usbDeviceEnumCounter"), ("USB-MIB", "usbDeviceRemoteWakeup"), ("USB-MIB", "usbDeviceRemoteWakeupOn"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    usbMibBasicGroup = usbMibBasicGroup.setStatus('current')
if mibBuilder.loadTexts: usbMibBasicGroup.setDescription('Group of objects that are mandatory to support by device implementing this MIB')
usbMibCDCGroup = ObjectGroup((1, 3, 6, 1, 3, 103, 3, 2, 2)).setObjects(("USB-MIB", "usbCDCIndex"), ("USB-MIB", "usbCDCIfIndex"), ("USB-MIB", "usbCDCSubclass"), ("USB-MIB", "usbCDCVersion"), ("USB-MIB", "usbCDCDataTransferType"), ("USB-MIB", "usbCDCDataEndpoints"), ("USB-MIB", "usbCDCStalls"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    usbMibCDCGroup = usbMibCDCGroup.setStatus('current')
if mibBuilder.loadTexts: usbMibCDCGroup.setDescription('This group is implemented only in devices having at least one CDC interface')
usbMibCDCEtherGroup = ObjectGroup((1, 3, 6, 1, 3, 103, 3, 2, 3)).setObjects(("USB-MIB", "usbCDCEtherIndex"), ("USB-MIB", "usbCDCEtherIfIndex"), ("USB-MIB", "usbCDCEtherMacAddress"), ("USB-MIB", "usbCDCEtherPacketFilter"), ("USB-MIB", "usbCDCEtherDataStatisticsCapabilities"), ("USB-MIB", "usbCDCEtherDataCheckErrs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    usbMibCDCEtherGroup = usbMibCDCEtherGroup.setStatus('current')
if mibBuilder.loadTexts: usbMibCDCEtherGroup.setDescription('This group is implemented only in devices having at least one CDC interface that uses Ethernet Networking Control Model or remote NDIS')
usbCDCEtherXmtAddressGroup = ObjectGroup((1, 3, 6, 1, 3, 103, 3, 2, 4)).setObjects(("USB-MIB", "ifCDCEtherXmtAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    usbCDCEtherXmtAddressGroup = usbCDCEtherXmtAddressGroup.setStatus('current')
if mibBuilder.loadTexts: usbCDCEtherXmtAddressGroup.setDescription('This group is implemented only for USB CDC interfaces that have transmit multicast filtering capabilities.')
mibBuilder.exportSymbols("USB-MIB", usbMibCDCEtherGroup=usbMibCDCEtherGroup, usbMibCDCGroup=usbMibCDCGroup, usbDeviceIndex=usbDeviceIndex, usbCDCEtherDataStatisticsCapabilities=usbCDCEtherDataStatisticsCapabilities, usbDeviceVendorID=usbDeviceVendorID, usbDeviceRemoteWakeup=usbDeviceRemoteWakeup, usbDeviceRemoteWakeupOn=usbDeviceRemoteWakeupOn, usbCDCEtherMacAddress=usbCDCEtherMacAddress, usbMibBasicCompliance=usbMibBasicCompliance, usbCDCSubclass=usbCDCSubclass, usbPortEntry=usbPortEntry, usbCDCEtherIfIndex=usbCDCEtherIfIndex, usbMibObjects=usbMibObjects, usbCDCIfIndex=usbCDCIfIndex, usbCDCTable=usbCDCTable, usbCDCEtherXmtAddressTable=usbCDCEtherXmtAddressTable, usbPortRate=usbPortRate, usbCDCEtherIndex=usbCDCEtherIndex, usbMibNotification=usbMibNotification, usbCDCDataTransferType=usbCDCDataTransferType, usbMibGroups=usbMibGroups, usbCDCEtherDataCheckErrs=usbCDCEtherDataCheckErrs, usbCDCEtherEntry=usbCDCEtherEntry, usbCDCIndex=usbCDCIndex, usbCDCEtherXmtAddressEntry=usbCDCEtherXmtAddressEntry, usbPortType=usbPortType, usbMibConformance=usbMibConformance, usbNumber=usbNumber, usbDeviceProductID=usbDeviceProductID, usbDeviceTable=usbDeviceTable, usbCDCEtherPacketFilter=usbCDCEtherPacketFilter, usbDeviceNumberConfigurations=usbDeviceNumberConfigurations, usbCDCDataEndpoints=usbCDCDataEndpoints, usbDeviceStatus=usbDeviceStatus, usbPortIndex=usbPortIndex, usbCDCEntry=usbCDCEntry, usbCDCEtherTable=usbCDCEtherTable, usbCDCEtherXmtAddressGroup=usbCDCEtherXmtAddressGroup, ifCDCEtherXmtAddress=ifCDCEtherXmtAddress, usbDevicePower=usbDevicePower, usbPortTable=usbPortTable, usbDeviceActiveClass=usbDeviceActiveClass, usbMibCompliances=usbMibCompliances, usbMibBasicGroup=usbMibBasicGroup, usbMib=usbMib, usbCDCVersion=usbCDCVersion, PYSNMP_MODULE_ID=usbMib, usbCDCStalls=usbCDCStalls, usbDeviceEnumCounter=usbDeviceEnumCounter, usbDeviceEntry=usbDeviceEntry)

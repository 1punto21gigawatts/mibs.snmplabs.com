#
# PySNMP MIB module DISMAN-SCRIPT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/DISMAN-SCRIPT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:47:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Bits, Counter32, Gauge32, MibIdentifier, ObjectIdentity, ModuleIdentity, mib_2, Integer32, IpAddress, iso, TimeTicks, Unsigned32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Bits", "Counter32", "Gauge32", "MibIdentifier", "ObjectIdentity", "ModuleIdentity", "mib-2", "Integer32", "IpAddress", "iso", "TimeTicks", "Unsigned32", "NotificationType")
StorageType, DateAndTime, DisplayString, TimeInterval, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "StorageType", "DateAndTime", "DisplayString", "TimeInterval", "TextualConvention", "RowStatus")
scriptMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 64))
scriptMIB.setRevisions(('2001-08-21 00:00', '1999-02-22 18:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: scriptMIB.setRevisionsDescriptions(('Revised version, published as RFC 3165. This revision introduces several new objects: smScriptError, smScriptLastChange, smLaunchError, smLaunchLastChange, smLaunchRowExpireTime, smRunResultTime, and smRunErrorTime. The following existing objects were updated: the maximum value of smRunLifeTime now disables the timer, an autostart value was added to the smLaunchAdminStatus object, and a new expired state was added to the smLaunchOperStatus object. A new smScriptException notification has been added to support runtime error notifications. Created new conformance and compliance statements that take care of the new objects and notifications. Clarifications have been added in several places to remove ambiguities or contradictions that were discovered and reported by implementors.', 'Initial version, published as RFC 2592.',))
if mibBuilder.loadTexts: scriptMIB.setLastUpdated('200108210000Z')
if mibBuilder.loadTexts: scriptMIB.setOrganization('IETF Distributed Management Working Group')
if mibBuilder.loadTexts: scriptMIB.setContactInfo('WG EMail: disman@dorothy.bmc.com Subscribe: disman-request@dorothy.bmc.com Chair: Randy Presuhn BMC Software, Inc. Postal: Office 1-3141 2141 North First Street San Jose, California 95131 USA EMail: rpresuhn@bmc.com Phone: +1 408 546-1006 Editor: David B. Levi Nortel Networks Postal: 4401 Great America Parkway Santa Clara, CA 95052-8185 USA EMail: dlevi@nortelnetworks.com Phone: +1 423 686 0432 Editor: Juergen Schoenwaelder TU Braunschweig Postal: Bueltenweg 74/75 38106 Braunschweig Germany EMail: schoenw@ibr.cs.tu-bs.de Phone: +49 531 391-3283')
if mibBuilder.loadTexts: scriptMIB.setDescription('This MIB module defines a set of objects that allow to delegate management scripts to distributed managers.')
smObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 1))
smNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 2))
smConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 3))
smLangTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 1), )
if mibBuilder.loadTexts: smLangTable.setStatus('current')
if mibBuilder.loadTexts: smLangTable.setDescription('This table lists supported script languages.')
smLangEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 1, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLangIndex"))
if mibBuilder.loadTexts: smLangEntry.setStatus('current')
if mibBuilder.loadTexts: smLangEntry.setDescription('An entry describing a particular language.')
smLangIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: smLangIndex.setStatus('current')
if mibBuilder.loadTexts: smLangIndex.setDescription("The locally arbitrary, but unique identifier associated with this language entry. The value is expected to remain constant at least from one re-initialization of the entity's network management system to the next re-initialization. Note that the data type and the range of this object must be consistent with the definition of smScriptLanguage.")
smLangLanguage = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangLanguage.setStatus('current')
if mibBuilder.loadTexts: smLangLanguage.setDescription('The globally unique identification of the language.')
smLangVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangVersion.setStatus('current')
if mibBuilder.loadTexts: smLangVersion.setDescription('The version number of the language. The zero-length string shall be used if the language does not have a version number. It is suggested that the version number consist of one or more decimal numbers separated by dots, where the first number is called the major version number.')
smLangVendor = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangVendor.setStatus('current')
if mibBuilder.loadTexts: smLangVendor.setDescription('An object identifier which identifies the vendor who provides the implementation of the language. This object identifier SHALL point to the object identifier directly below the enterprise object identifier {1 3 6 1 4 1} allocated for the vendor. The value must be the object identifier {0 0} if the vendor is not known.')
smLangRevision = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangRevision.setStatus('current')
if mibBuilder.loadTexts: smLangRevision.setDescription('The version number of the language implementation. The value of this object must be an empty string if version number of the implementation is unknown. It is suggested that the value consist of one or more decimal numbers separated by dots, where the first number is called the major version number.')
smLangDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 1, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLangDescr.setStatus('current')
if mibBuilder.loadTexts: smLangDescr.setDescription('A textual description of the language.')
smExtsnTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 2), )
if mibBuilder.loadTexts: smExtsnTable.setStatus('current')
if mibBuilder.loadTexts: smExtsnTable.setDescription('This table lists supported language extensions.')
smExtsnEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 2, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLangIndex"), (0, "DISMAN-SCRIPT-MIB", "smExtsnIndex"))
if mibBuilder.loadTexts: smExtsnEntry.setStatus('current')
if mibBuilder.loadTexts: smExtsnEntry.setDescription('An entry describing a particular language extension.')
smExtsnIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: smExtsnIndex.setStatus('current')
if mibBuilder.loadTexts: smExtsnIndex.setDescription("The locally arbitrary, but unique identifier associated with this language extension entry. The value is expected to remain constant at least from one re-initialization of the entity's network management system to the next re-initialization.")
smExtsnExtension = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnExtension.setStatus('current')
if mibBuilder.loadTexts: smExtsnExtension.setDescription('The globally unique identification of the language extension.')
smExtsnVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnVersion.setStatus('current')
if mibBuilder.loadTexts: smExtsnVersion.setDescription('The version number of the language extension. It is suggested that the version number consist of one or more decimal numbers separated by dots, where the first number is called the major version number.')
smExtsnVendor = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnVendor.setStatus('current')
if mibBuilder.loadTexts: smExtsnVendor.setDescription('An object identifier which identifies the vendor who provides the implementation of the extension. The object identifier value should point to the OID node directly below the enterprise OID {1 3 6 1 4 1} allocated for the vendor. The value must by the object identifier {0 0} if the vendor is not known.')
smExtsnRevision = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 5), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnRevision.setStatus('current')
if mibBuilder.loadTexts: smExtsnRevision.setDescription('The version number of the extension implementation. The value of this object must be an empty string if version number of the implementation is unknown. It is suggested that the value consist of one or more decimal numbers separated by dots, where the first number is called the major version number.')
smExtsnDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 2, 1, 6), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smExtsnDescr.setStatus('current')
if mibBuilder.loadTexts: smExtsnDescr.setDescription('A textual description of the language extension.')
smScriptObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 1, 3))
smScriptTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 3, 1), )
if mibBuilder.loadTexts: smScriptTable.setStatus('current')
if mibBuilder.loadTexts: smScriptTable.setDescription('This table lists and describes locally known scripts.')
smScriptEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smScriptOwner"), (0, "DISMAN-SCRIPT-MIB", "smScriptName"))
if mibBuilder.loadTexts: smScriptEntry.setStatus('current')
if mibBuilder.loadTexts: smScriptEntry.setDescription('An entry describing a particular script. Every script that is stored in non-volatile memory is required to appear in this script table.')
smScriptOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: smScriptOwner.setStatus('current')
if mibBuilder.loadTexts: smScriptOwner.setDescription('The manager who owns this row in the smScriptTable.')
smScriptName = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: smScriptName.setStatus('current')
if mibBuilder.loadTexts: smScriptName.setDescription('The locally-unique, administratively assigned name for this script. This object allows an smScriptOwner to have multiple entries in the smScriptTable. This value of this object may be used to derive the name (e.g. a file name) which is used by the Script MIB implementation to access the script in non-volatile storage. The details of this mapping are implementation specific. However, the mapping needs to ensure that scripts created by different owners with the same script name do not map to the same name in non-volatile storage.')
smScriptDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptDescr.setStatus('current')
if mibBuilder.loadTexts: smScriptDescr.setDescription('A description of the purpose of the script.')
smScriptLanguage = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptLanguage.setStatus('current')
if mibBuilder.loadTexts: smScriptLanguage.setDescription("The value of this object type identifies an entry in the smLangTable which is used to execute this script. The special value 0 may be used by hard-wired scripts that can not be modified and that are executed by internal functions. Set requests to change this object are invalid if the value of smScriptOperStatus is `enabled' or `compiling' and will result in an inconsistentValue error. Note that the data type and the range of this object must be consistent with the definition of smLangIndex.")
smScriptSource = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 5), DisplayString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptSource.setStatus('current')
if mibBuilder.loadTexts: smScriptSource.setDescription("This object either contains a reference to the script source or an empty string. A reference must be given in the form of a Uniform Resource Locator (URL) as defined in RFC 2396. The allowed character sets and the encoding rules defined in RFC 2396 section 2 apply. When the smScriptAdminStatus object is set to `enabled', the Script MIB implementation will `pull' the script source from the URL contained in this object if the URL is not empty. An empty URL indicates that the script source is loaded from local storage. The script is read from the smCodeTable if the value of smScriptStorageType is volatile. Otherwise, the script is read from non-volatile storage. Note: This document does not mandate implementation of any specific URL scheme. An attempt to load a script from a nonsupported URL scheme will cause the smScriptOperStatus to report an `unknownProtocol' error. Set requests to change this object are invalid if the value of smScriptOperStatus is `enabled', `editing', `retrieving' or `compiling' and will result in an inconsistentValue error.")
smScriptAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("editing", 3))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptAdminStatus.setStatus('current')
if mibBuilder.loadTexts: smScriptAdminStatus.setDescription("The value of this object indicates the desired status of the script. See the definition of smScriptOperStatus for a description of the values. When the smScriptAdminStatus object is set to `enabled' and the smScriptOperStatus is `disabled' or one of the error states, the Script MIB implementation will `pull' the script source from the URL contained in the smScriptSource object if the URL is not empty.")
smScriptOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("editing", 3), ("retrieving", 4), ("compiling", 5), ("noSuchScript", 6), ("accessDenied", 7), ("wrongLanguage", 8), ("wrongVersion", 9), ("compilationFailed", 10), ("noResourcesLeft", 11), ("unknownProtocol", 12), ("protocolFailure", 13), ("genericError", 14))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: smScriptOperStatus.setStatus('current')
if mibBuilder.loadTexts: smScriptOperStatus.setDescription("The actual status of the script in the runtime system. The value of this object is only meaningful when the value of the smScriptRowStatus object is `active'. The smScriptOperStatus object may have the following values: - `enabled' indicates that the script is available and can be started by a launch table entry. - `disabled' indicates that the script can not be used. - `editing' indicates that the script can be modified in the smCodeTable. - `retrieving' indicates that the script is currently being loaded from non-volatile storage or a remote system. - `compiling' indicates that the script is currently being compiled by the runtime system. - `noSuchScript' indicates that the script does not exist at the smScriptSource. - `accessDenied' indicates that the script can not be loaded from the smScriptSource due to a lack of permissions. - `wrongLanguage' indicates that the script can not be loaded from the smScriptSource because of a language mismatch. - `wrongVersion' indicates that the script can not be loaded from the smScriptSource because of a language version mismatch. - `compilationFailed' indicates that the compilation failed. - `noResourcesLeft' indicates that the runtime system does not have enough resources to load the script. - `unknownProtocol' indicates that the script could not be loaded from the smScriptSource because the requested protocol is not supported. - `protocolFailure' indicates that the script could not be loaded from the smScriptSource because of a protocol failure. - `genericError' indicates that the script could not be loaded due to an error condition not listed above. The `retrieving' and `compiling' states are transient states which will either lead to one of the error states or the `enabled' state. The `disabled' and `editing' states are administrative states which are only reached by explicit management operations. All launch table entries that refer to this script table entry shall have an smLaunchOperStatus value of `disabled' when the value of this object is not `enabled'.")
smScriptStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 8), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptStorageType.setStatus('current')
if mibBuilder.loadTexts: smScriptStorageType.setDescription("This object defines whether this row and the script controlled by this row are kept in volatile storage and lost upon reboot or if this row is backed up by non-volatile or permanent storage. The storage type of this row always complies with the value of this entry if the value of the corresponding RowStatus object is `active'. However, the storage type of the script controlled by this row may be different, if the value of this entry is `non-volatile'. The script controlled by this row is written into local non-volatile storage if the following condition becomes true: (a) the URL contained in the smScriptSource object is empty and (b) the smScriptStorageType is `nonVolatile' and (c) the smScriptOperStatus is `enabled' Setting this object to `volatile' removes a script from non-volatile storage if the script controlled by this row has been in non-volatile storage before. Attempts to set this object to permanent will always fail with an inconsistentValue error. The value of smScriptStorageType is only meaningful if the value of the corresponding RowStatus object is `active'. If smScriptStorageType has the value permanent(4), then all objects whose MAX-ACCESS value is read-create must be writable, with the exception of the smScriptStorageType and smScriptRowStatus objects, which shall be read-only.")
smScriptRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smScriptRowStatus.setStatus('current')
if mibBuilder.loadTexts: smScriptRowStatus.setDescription("A control that allows entries to be added and removed from this table. Changing the smScriptRowStatus from `active' to `notInService' will remove the associated script from the runtime system. Deleting conceptual rows from this table may affect the deletion of other resources associated with this row. For example, a script stored in non-volatile storage may be removed from non-volatile storage. An entry may not exist in the `active' state unless all required objects in the entry have appropriate values. Rows that are not complete or not in service are not known by the script runtime system. Attempts to `destroy' a row or to set a row `notInService' while the smScriptOperStatus is `enabled' will result in an inconsistentValue error. Attempts to `destroy' a row or to set a row `notInService' where the value of the smScriptStorageType object is `permanent' or `readOnly' will result in an inconsistentValue error. The value of this object has no effect on whether other objects in this conceptual row can be modified.")
smScriptError = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 10), SnmpAdminString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smScriptError.setStatus('current')
if mibBuilder.loadTexts: smScriptError.setDescription("This object contains a descriptive error message if the transition into the operational status `enabled' failed. Implementations must reset the error message to a zero-length string when a new attempt to change the script status to `enabled' is started.")
smScriptLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 1, 1, 11), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smScriptLastChange.setStatus('current')
if mibBuilder.loadTexts: smScriptLastChange.setDescription("The date and time when this script table entry was last modified. The value '0000000000000000'H is returned if the script table entry has not yet been modified. Note that the resetting of smScriptError is not considered a change of the script table entry.")
smCodeTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 3, 2), )
if mibBuilder.loadTexts: smCodeTable.setStatus('current')
if mibBuilder.loadTexts: smCodeTable.setDescription('This table contains the script code for scripts that are written via SNMP write operations.')
smCodeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smScriptOwner"), (0, "DISMAN-SCRIPT-MIB", "smScriptName"), (0, "DISMAN-SCRIPT-MIB", "smCodeIndex"))
if mibBuilder.loadTexts: smCodeEntry.setStatus('current')
if mibBuilder.loadTexts: smCodeEntry.setDescription('An entry describing a particular fragment of a script.')
smCodeIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: smCodeIndex.setStatus('current')
if mibBuilder.loadTexts: smCodeIndex.setDescription('The index value identifying this code fragment.')
smCodeText = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1024))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smCodeText.setStatus('current')
if mibBuilder.loadTexts: smCodeText.setDescription('The code that makes up a fragment of a script. The format of this code fragment depends on the script language which is identified by the associated smScriptLanguage object.')
smCodeRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 3, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smCodeRowStatus.setStatus('current')
if mibBuilder.loadTexts: smCodeRowStatus.setDescription('A control that allows entries to be added and removed from this table. The value of this object has no effect on whether other objects in this conceptual row can be modified.')
smRunObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 1, 4))
smLaunchTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 4, 1), )
if mibBuilder.loadTexts: smLaunchTable.setStatus('current')
if mibBuilder.loadTexts: smLaunchTable.setDescription('This table lists and describes scripts that are ready to be executed together with their parameters.')
smLaunchEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLaunchOwner"), (0, "DISMAN-SCRIPT-MIB", "smLaunchName"))
if mibBuilder.loadTexts: smLaunchEntry.setStatus('current')
if mibBuilder.loadTexts: smLaunchEntry.setDescription('An entry describing a particular executable script.')
smLaunchOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)))
if mibBuilder.loadTexts: smLaunchOwner.setStatus('current')
if mibBuilder.loadTexts: smLaunchOwner.setDescription('The manager who owns this row in the smLaunchTable. Every instance of a running script started from a particular entry in the smLaunchTable (i.e. entries in the smRunTable) will be owned by the same smLaunchOwner used to index the entry in the smLaunchTable. This owner is not necessarily the same as the owner of the script itself (smLaunchScriptOwner).')
smLaunchName = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: smLaunchName.setStatus('current')
if mibBuilder.loadTexts: smLaunchName.setDescription('The locally-unique, administratively assigned name for this launch table entry. This object allows an smLaunchOwner to have multiple entries in the smLaunchTable. The smLaunchName is an arbitrary name that must be different from any other smLaunchTable entries with the same smLaunchOwner but can be the same as other entries in the smLaunchTable with different smLaunchOwner values. Note that the value of smLaunchName is not related in any way to the name of the script being launched.')
smLaunchScriptOwner = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchScriptOwner.setStatus('current')
if mibBuilder.loadTexts: smLaunchScriptOwner.setDescription("The value of this object in combination with the value of smLaunchScriptName identifies the script that can be launched from this smLaunchTable entry. Attempts to write this object will fail with an inconsistentValue error if the value of smLaunchOperStatus is `enabled'.")
smLaunchScriptName = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 4), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32)).clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchScriptName.setStatus('current')
if mibBuilder.loadTexts: smLaunchScriptName.setDescription("The value of this object in combination with the value of the smLaunchScriptOwner identifies the script that can be launched from this smLaunchTable entry. The zero-length string may be used to point to a non-existing script. Attempts to write this object will fail with an inconsistentValue error if the value of smLaunchOperStatus is `enabled'.")
smLaunchArgument = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 5), OctetString().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchArgument.setStatus('current')
if mibBuilder.loadTexts: smLaunchArgument.setDescription('The argument supplied to the script. When a script is invoked, the value of this object is used to initialize the smRunArgument object.')
smLaunchMaxRunning = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchMaxRunning.setStatus('current')
if mibBuilder.loadTexts: smLaunchMaxRunning.setDescription('The maximum number of concurrently running scripts that may be invoked from this entry in the smLaunchTable. Lowering the current value of this object does not affect any scripts that are already executing.')
smLaunchMaxCompleted = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)).clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchMaxCompleted.setStatus('current')
if mibBuilder.loadTexts: smLaunchMaxCompleted.setDescription('The maximum number of finished scripts invoked from this entry in the smLaunchTable allowed to be retained in the smRunTable. Whenever the value of this object is changed and whenever a script terminates, entries in the smRunTable are deleted if necessary until the number of completed scripts is smaller than the value of this object. Scripts whose smRunEndTime value indicates the oldest completion time are deleted first.')
smLaunchLifeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 8), TimeInterval().clone(360000)).setUnits('centi-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchLifeTime.setStatus('current')
if mibBuilder.loadTexts: smLaunchLifeTime.setDescription('The default maximum amount of time a script launched from this entry may run. The value of this object is used to initialize the smRunLifeTime object when a script is launched. Changing the value of an smLaunchLifeTime instance does not affect scripts previously launched from this entry.')
smLaunchExpireTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 9), TimeInterval().clone(360000)).setUnits('centi-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchExpireTime.setStatus('current')
if mibBuilder.loadTexts: smLaunchExpireTime.setDescription('The default maximum amount of time information about a script launched from this entry is kept in the smRunTable after the script has completed execution. The value of this object is used to initialize the smRunExpireTime object when a script is launched. Changing the value of an smLaunchExpireTime instance does not affect scripts previously launched from this entry.')
smLaunchStart = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchStart.setStatus('current')
if mibBuilder.loadTexts: smLaunchStart.setDescription("This object is used to start the execution of scripts. When retrieved, the value will be the value of smRunIndex for the last script that started execution by manipulating this object. The value will be zero if no script started execution yet. A script is started by setting this object to an unused smRunIndex value. A new row in the smRunTable will be created which is indexed by the value supplied by the set-request in addition to the value of smLaunchOwner and smLaunchName. An unused value can be obtained by reading the smLaunchRunIndexNext object. Setting this object to the special value 0 will start the script with a self-generated smRunIndex value. The consequence is that the script invoker has no reliable way to determine the smRunIndex value for this script invocation and that the invoker has therefore no way to obtain the results from this script invocation. The special value 0 is however useful for scheduled script invocations. If this object is set, the following checks must be performed: 1) The value of the smLaunchOperStatus object in this entry of the smLaunchTable must be `enabled'. 2) The values of smLaunchScriptOwner and smLaunchScriptName of this row must identify an existing entry in the smScriptTable. 3) The value of smScriptOperStatus of this entry must be `enabled'. 4) The principal performing the set operation must have read access to the script. This must be checked by calling the isAccessAllowed abstract service interface defined in RFC 2271 on the row in the smScriptTable identified by smLaunchScriptOwner and smLaunchScriptName. The isAccessAllowed abstract service interface must be called on all columnar objects in the smScriptTable with a MAX-ACCESS value different than `not-accessible'. The test fails as soon as a call indicates that access is not allowed. 5) If the value provided by the set operation is not 0, a check must be made that the value is currently not in use. Otherwise, if the value provided by the set operation is 0, a suitable unused value must be generated. 6) The number of currently executing scripts invoked from this smLaunchTable entry must be less than smLaunchMaxRunning. Attempts to start a script will fail with an inconsistentValue error if one of the checks described above fails. Otherwise, if all checks have been passed, a new entry in the smRunTable will be created indexed by smLaunchOwner, smLaunchName and the new value for smRunIndex. The value of smLaunchArgument will be copied into smRunArgument, the value of smLaunchLifeTime will be copied to smRunLifeTime, and the value of smLaunchExpireTime will be copied to smRunExpireTime. The smRunStartTime will be set to the current time and the smRunState will be set to `initializing' before the script execution is initiated in the appropriate runtime system. Note that the data type and the range of this object must be consistent with the smRunIndex object. Since this object might be written from the scheduling MIB, the data type Integer32 rather than Unsigned32 is used.")
smLaunchControl = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("abort", 1), ("suspend", 2), ("resume", 3), ("nop", 4))).clone('nop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchControl.setStatus('current')
if mibBuilder.loadTexts: smLaunchControl.setDescription("This object is used to request a state change for all running scripts in the smRunTable that were started from this row in the smLaunchTable. Setting this object to abort(1), suspend(2) or resume(3) will set the smRunControl object of all applicable rows in the smRunTable to abort(1), suspend(2) or resume(3) respectively. The phrase `applicable rows' means the set of rows which were created from this entry in the smLaunchTable and whose value of smRunState allows the corresponding state change as described in the definition of the smRunControl object. Setting this object to nop(4) has no effect. Attempts to set this object lead to an inconsistentValue error only if all implicated sets on all the applicable rows lead to inconsistentValue errors. It is not allowed to return an inconsistentValue error if at least one state change on one of the applicable rows was successful.")
smLaunchAdminStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("autostart", 3))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchAdminStatus.setStatus('current')
if mibBuilder.loadTexts: smLaunchAdminStatus.setDescription("The value of this object indicates the desired status of this launch table entry. The values enabled(1) and autostart(3) both indicate that the launch table entry should transition into the operational enabled(1) state as soon as the associated script table entry is enabled(1). The value autostart(3) further indicates that the script is started automatically by conceptually writing the value 0 into the associated smLaunchStart object during the transition from the `disabled' into the `enabled' operational state. This is useful for scripts that are to be launched on system start-up.")
smLaunchOperStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("expired", 3))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchOperStatus.setStatus('current')
if mibBuilder.loadTexts: smLaunchOperStatus.setDescription("The value of this object indicates the actual status of this launch table entry. The smLaunchOperStatus object may have the following values: - `enabled' indicates that the launch table entry is available and can be used to start scripts. - `disabled' indicates that the launch table entry can not be used to start scripts. - `expired' indicates that the launch table entry can not be used to start scripts and will disappear as soon as all smRunTable entries associated with this launch table entry have disappeared. The value `enabled' requires that the smLaunchRowStatus object is active. The value `disabled' requires that there are no entries in the smRunTable associated with this smLaunchTable entry.")
smLaunchRunIndexNext = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchRunIndexNext.setStatus('current')
if mibBuilder.loadTexts: smLaunchRunIndexNext.setDescription('This variable is used for creating rows in the smRunTable. The value of this variable is a currently unused value for smRunIndex, which can be written into the smLaunchStart object associated with this row to launch a script. The value returned when reading this variable must be unique for the smLaunchOwner and smLaunchName associated with this row. Subsequent attempts to read this variable must return different values. This variable will return the special value 0 if no new rows can be created. Note that the data type and the range of this object must be consistent with the definition of smRunIndex.')
smLaunchStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 15), StorageType().clone('volatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchStorageType.setStatus('current')
if mibBuilder.loadTexts: smLaunchStorageType.setDescription('This object defines if this row is kept in volatile storage and lost upon reboot or if this row is backed up by stable storage. The value of smLaunchStorageType is only meaningful if the value of the corresponding RowStatus object is active. If smLaunchStorageType has the value permanent(4), then all objects whose MAX-ACCESS value is read-create must be writable, with the exception of the smLaunchStorageType and smLaunchRowStatus objects, which shall be read-only.')
smLaunchRowStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 16), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchRowStatus.setStatus('current')
if mibBuilder.loadTexts: smLaunchRowStatus.setDescription("A control that allows entries to be added and removed from this table. Attempts to `destroy' a row or to set a row `notInService' while the smLaunchOperStatus is `enabled' will result in an inconsistentValue error. Attempts to `destroy' a row or to set a row `notInService' where the value of the smLaunchStorageType object is `permanent' or `readOnly' will result in an inconsistentValue error. The value of this object has no effect on whether other objects in this conceptual row can be modified.")
smLaunchError = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 17), SnmpAdminString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchError.setStatus('current')
if mibBuilder.loadTexts: smLaunchError.setDescription('This object contains a descriptive error message if an attempt to launch a script fails. Implementations must reset the error message to a zero-length string when a new attempt to launch a script is started.')
smLaunchLastChange = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 18), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smLaunchLastChange.setStatus('current')
if mibBuilder.loadTexts: smLaunchLastChange.setDescription("The date and time when this launch table entry was last modified. The value '0000000000000000'H is returned if the launch table entry has not yet been modified. Note that a change of smLaunchStart, smLaunchControl, smLaunchRunIndexNext, smLaunchRowExpireTime, or the resetting of smLaunchError is not considered a change of this launch table entry.")
smLaunchRowExpireTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 1, 1, 19), TimeInterval().clone(2147483647)).setUnits('centi-seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: smLaunchRowExpireTime.setStatus('current')
if mibBuilder.loadTexts: smLaunchRowExpireTime.setDescription("The value of this object specifies how long this row remains in the `enabled' or `disabled' operational state. The value reported by this object ticks backwards. When the value reaches 0, it stops ticking backward and the row is deleted if there are no smRunTable entries associated with this smLaunchTable entry. Otherwise, the smLaunchOperStatus changes to `expired' and the row deletion is deferred until there are no smRunTable entries associated with this smLaunchTable entry. The smLaunchRowExpireTime will not tick backwards if it is set to its maximum value (2147483647). In other words, setting this object to its maximum value turns the timer off. The value of this object may be set in order to increase or reduce the remaining time that the launch table entry may be used. Setting the value to 0 will cause an immediate row deletion or transition into the `expired' operational state. It is not possible to set this object while the operational status is `expired'. Attempts to modify this object while the operational status is `expired' leads to an inconsistentValue error. Note that the timer ticks backwards independent of the operational state of the launch table entry.")
smRunTable = MibTable((1, 3, 6, 1, 2, 1, 64, 1, 4, 2), )
if mibBuilder.loadTexts: smRunTable.setStatus('current')
if mibBuilder.loadTexts: smRunTable.setDescription('This table lists and describes scripts that are currently running or have been running in the past.')
smRunEntry = MibTableRow((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1), ).setIndexNames((0, "DISMAN-SCRIPT-MIB", "smLaunchOwner"), (0, "DISMAN-SCRIPT-MIB", "smLaunchName"), (0, "DISMAN-SCRIPT-MIB", "smRunIndex"))
if mibBuilder.loadTexts: smRunEntry.setStatus('current')
if mibBuilder.loadTexts: smRunEntry.setDescription('An entry describing a particular running or finished script.')
smRunIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: smRunIndex.setStatus('current')
if mibBuilder.loadTexts: smRunIndex.setDescription('The locally arbitrary, but unique identifier associated with this running or finished script. This value must be unique for all rows in the smRunTable with the same smLaunchOwner and smLaunchName. Note that the data type and the range of this object must be consistent with the definition of smLaunchRunIndexNext and smLaunchStart.')
smRunArgument = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 2), OctetString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunArgument.setStatus('current')
if mibBuilder.loadTexts: smRunArgument.setDescription('The argument supplied to the script when it started.')
smRunStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 3), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunStartTime.setStatus('current')
if mibBuilder.loadTexts: smRunStartTime.setDescription("The date and time when the execution started. The value '0000000000000000'H is returned if the script has not started yet.")
smRunEndTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 4), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunEndTime.setStatus('current')
if mibBuilder.loadTexts: smRunEndTime.setDescription("The date and time when the execution terminated. The value '0000000000000000'H is returned if the script has not terminated yet.")
smRunLifeTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 5), TimeInterval()).setUnits('centi-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: smRunLifeTime.setStatus('current')
if mibBuilder.loadTexts: smRunLifeTime.setDescription("This object specifies how long the script can execute. This object returns the remaining time that the script may run. The object is initialized with the value of the associated smLaunchLifeTime object and ticks backwards. The script is aborted immediately when the value reaches 0. The value of this object may be set in order to increase or reduce the remaining time that the script may run. Setting this value to 0 will abort script execution immediately, and, if the value of smRunExpireTime is also 0, will remove this entry from the smRunTable once it has terminated. If smRunLifeTime is set to its maximum value (2147483647), either by a set operation or by its initialization from the smLaunchLifeTime object, then it will not tick backwards. A running script with a maximum smRunLifeTime value will thus never be terminated with a `lifeTimeExceeded' exit code. The value of smRunLifeTime reflects the real-time execution time as seen by the outside world. The value of this object will always be 0 for a script that finished execution, that is smRunState has the value `terminated'. The value of smRunLifeTime does not change while a script is suspended, that is smRunState has the value `suspended'. Note that this does not affect set operations. It is legal to modify smRunLifeTime via set operations while a script is suspended.")
smRunExpireTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 6), TimeInterval()).setUnits('centi-seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: smRunExpireTime.setStatus('current')
if mibBuilder.loadTexts: smRunExpireTime.setDescription("The value of this object specifies how long this row can exist in the smRunTable after the script has terminated. This object returns the remaining time that the row may exist before it is aged out. The object is initialized with the value of the associated smLaunchExpireTime object and ticks backwards. The entry in the smRunTable is destroyed when the value reaches 0 and the smRunState has the value `terminated'. The value of this object may be set in order to increase or reduce the remaining time that the row may exist. Setting the value to 0 will destroy this entry as soon as the smRunState has the value `terminated'.")
smRunExitCode = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("noError", 1), ("halted", 2), ("lifeTimeExceeded", 3), ("noResourcesLeft", 4), ("languageError", 5), ("runtimeError", 6), ("invalidArgument", 7), ("securityViolation", 8), ("genericError", 9))).clone('noError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunExitCode.setStatus('current')
if mibBuilder.loadTexts: smRunExitCode.setDescription("The value of this object indicates the reason why a script finished execution. The smRunExitCode code may have one of the following values: - `noError', which indicates that the script completed successfully without errors; - `halted', which indicates that the script was halted by a request from an authorized manager; - `lifeTimeExceeded', which indicates that the script exited because a time limit was exceeded; - `noResourcesLeft', which indicates that the script exited because it ran out of resources (e.g. memory); - `languageError', which indicates that the script exited because of a language error (e.g. a syntax error in an interpreted language); - `runtimeError', which indicates that the script exited due to a runtime error (e.g. a division by zero); - `invalidArgument', which indicates that the script could not be run because of invalid script arguments; - `securityViolation', which indicates that the script exited due to a security violation; - `genericError', which indicates that the script exited for an unspecified reason. If the script has not yet begun running, or is currently running, the value will be `noError'.")
smRunResult = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 8), OctetString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunResult.setStatus('current')
if mibBuilder.loadTexts: smRunResult.setDescription('The result value produced by the running script. Note that the result may change while the script is executing.')
smRunControl = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("abort", 1), ("suspend", 2), ("resume", 3), ("nop", 4))).clone('nop')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smRunControl.setStatus('current')
if mibBuilder.loadTexts: smRunControl.setDescription("The value of this object indicates the desired status of the script execution defined by this row. Setting this object to `abort' will abort execution if the value of smRunState is `initializing', `executing', `suspending', `suspended' or `resuming'. Setting this object to `abort' when the value of smRunState is `aborting' or `terminated', or if the implementation can determine that the attempt to abort the execution would fail, will result in an inconsistentValue error. Setting this object to `suspend' will suspend execution if the value of smRunState is `executing'. Setting this object to `suspend' will cause an inconsistentValue error if the value of smRunState is not `executing' or if the implementation can determine that the attempt to suspend the execution would fail. Setting this object to `resume' will resume execution if the value of smRunState is `suspending' or `suspended'. Setting this object to `resume' will cause an inconsistentValue error if the value of smRunState is not `suspended' or if the implementation can determine that the attempt to resume the execution would fail. Setting this object to nop(4) has no effect.")
smRunState = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("initializing", 1), ("executing", 2), ("suspending", 3), ("suspended", 4), ("resuming", 5), ("aborting", 6), ("terminated", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunState.setStatus('current')
if mibBuilder.loadTexts: smRunState.setDescription("The value of this object indicates the script's execution state. If the script has been invoked but has not yet begun execution, the value will be `initializing'. If the script is running, the value will be `executing'. A running script which received a request to suspend execution first transitions into a temporary `suspending' state. The temporary `suspending' state changes to `suspended' when the script has actually been suspended. The temporary `suspending' state changes back to `executing' if the attempt to suspend the running script fails. A suspended script which received a request to resume execution first transitions into a temporary `resuming' state. The temporary `resuming' state changes to `running' when the script has actually been resumed. The temporary `resuming' state changes back to `suspended' if the attempt to resume the suspended script fails. A script which received a request to abort execution but which is still running first transitions into a temporary `aborting' state. A script which has finished its execution is `terminated'.")
smRunError = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 11), SnmpAdminString().clone(hexValue="")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunError.setStatus('current')
if mibBuilder.loadTexts: smRunError.setDescription("This object contains a descriptive error message if the script startup or execution raised an abnormal condition. An implementation must store a descriptive error message in this object if the script exits with the smRunExitCode `genericError'.")
smRunResultTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 12), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunResultTime.setStatus('current')
if mibBuilder.loadTexts: smRunResultTime.setDescription("The date and time when the smRunResult was last updated. The value '0000000000000000'H is returned if smRunResult has not yet been updated after the creation of this smRunTable entry.")
smRunErrorTime = MibTableColumn((1, 3, 6, 1, 2, 1, 64, 1, 4, 2, 1, 13), DateAndTime().clone(hexValue="0000000000000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: smRunErrorTime.setStatus('current')
if mibBuilder.loadTexts: smRunErrorTime.setDescription("The date and time when the smRunError was last updated. The value '0000000000000000'H is returned if smRunError has not yet been updated after the creation of this smRunTable entry.")
smTraps = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 2, 0))
smScriptAbort = NotificationType((1, 3, 6, 1, 2, 1, 64, 2, 0, 1)).setObjects(("DISMAN-SCRIPT-MIB", "smRunExitCode"), ("DISMAN-SCRIPT-MIB", "smRunEndTime"), ("DISMAN-SCRIPT-MIB", "smRunError"))
if mibBuilder.loadTexts: smScriptAbort.setStatus('current')
if mibBuilder.loadTexts: smScriptAbort.setDescription("This notification is generated whenever a running script terminates with an smRunExitCode unequal to `noError'.")
smScriptResult = NotificationType((1, 3, 6, 1, 2, 1, 64, 2, 0, 2)).setObjects(("DISMAN-SCRIPT-MIB", "smRunResult"))
if mibBuilder.loadTexts: smScriptResult.setStatus('current')
if mibBuilder.loadTexts: smScriptResult.setDescription('This notification can be used by scripts to notify other management applications about results produced by the script. This notification is not automatically generated by the Script MIB implementation. It is the responsibility of the executing script to emit this notification where it is appropriate to do so.')
smScriptException = NotificationType((1, 3, 6, 1, 2, 1, 64, 2, 0, 3)).setObjects(("DISMAN-SCRIPT-MIB", "smRunError"))
if mibBuilder.loadTexts: smScriptException.setStatus('current')
if mibBuilder.loadTexts: smScriptException.setDescription('This notification can be used by scripts to notify other management applications about script errors. This notification is not automatically generated by the Script MIB implementation. It is the responsibility of the executing script or the runtime system to emit this notification where it is appropriate to do so.')
smCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 3, 1))
smGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 64, 3, 2))
smCompliance2 = ModuleCompliance((1, 3, 6, 1, 2, 1, 64, 3, 1, 2)).setObjects(("DISMAN-SCRIPT-MIB", "smLanguageGroup"), ("DISMAN-SCRIPT-MIB", "smScriptGroup2"), ("DISMAN-SCRIPT-MIB", "smLaunchGroup2"), ("DISMAN-SCRIPT-MIB", "smRunGroup2"), ("DISMAN-SCRIPT-MIB", "smNotificationsGroup2"), ("DISMAN-SCRIPT-MIB", "smCodeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smCompliance2 = smCompliance2.setStatus('current')
if mibBuilder.loadTexts: smCompliance2.setDescription('The compliance statement for SNMP entities which implement the Script MIB.')
smLanguageGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 1)).setObjects(("DISMAN-SCRIPT-MIB", "smLangLanguage"), ("DISMAN-SCRIPT-MIB", "smLangVersion"), ("DISMAN-SCRIPT-MIB", "smLangVendor"), ("DISMAN-SCRIPT-MIB", "smLangRevision"), ("DISMAN-SCRIPT-MIB", "smLangDescr"), ("DISMAN-SCRIPT-MIB", "smExtsnExtension"), ("DISMAN-SCRIPT-MIB", "smExtsnVersion"), ("DISMAN-SCRIPT-MIB", "smExtsnVendor"), ("DISMAN-SCRIPT-MIB", "smExtsnRevision"), ("DISMAN-SCRIPT-MIB", "smExtsnDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smLanguageGroup = smLanguageGroup.setStatus('current')
if mibBuilder.loadTexts: smLanguageGroup.setDescription('A collection of objects providing information about the capabilities of the scripting engine.')
smScriptGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 7)).setObjects(("DISMAN-SCRIPT-MIB", "smScriptDescr"), ("DISMAN-SCRIPT-MIB", "smScriptLanguage"), ("DISMAN-SCRIPT-MIB", "smScriptSource"), ("DISMAN-SCRIPT-MIB", "smScriptAdminStatus"), ("DISMAN-SCRIPT-MIB", "smScriptOperStatus"), ("DISMAN-SCRIPT-MIB", "smScriptStorageType"), ("DISMAN-SCRIPT-MIB", "smScriptRowStatus"), ("DISMAN-SCRIPT-MIB", "smScriptError"), ("DISMAN-SCRIPT-MIB", "smScriptLastChange"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smScriptGroup2 = smScriptGroup2.setStatus('current')
if mibBuilder.loadTexts: smScriptGroup2.setDescription('A collection of objects providing information about installed scripts.')
smCodeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 3)).setObjects(("DISMAN-SCRIPT-MIB", "smCodeText"), ("DISMAN-SCRIPT-MIB", "smCodeRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smCodeGroup = smCodeGroup.setStatus('current')
if mibBuilder.loadTexts: smCodeGroup.setDescription('A collection of objects used to download or modify scripts by using SNMP set requests.')
smLaunchGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 8)).setObjects(("DISMAN-SCRIPT-MIB", "smLaunchScriptOwner"), ("DISMAN-SCRIPT-MIB", "smLaunchScriptName"), ("DISMAN-SCRIPT-MIB", "smLaunchArgument"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxRunning"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxCompleted"), ("DISMAN-SCRIPT-MIB", "smLaunchLifeTime"), ("DISMAN-SCRIPT-MIB", "smLaunchExpireTime"), ("DISMAN-SCRIPT-MIB", "smLaunchStart"), ("DISMAN-SCRIPT-MIB", "smLaunchControl"), ("DISMAN-SCRIPT-MIB", "smLaunchAdminStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchOperStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchRunIndexNext"), ("DISMAN-SCRIPT-MIB", "smLaunchStorageType"), ("DISMAN-SCRIPT-MIB", "smLaunchRowStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchError"), ("DISMAN-SCRIPT-MIB", "smLaunchLastChange"), ("DISMAN-SCRIPT-MIB", "smLaunchRowExpireTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smLaunchGroup2 = smLaunchGroup2.setStatus('current')
if mibBuilder.loadTexts: smLaunchGroup2.setDescription('A collection of objects providing information about scripts that can be launched.')
smRunGroup2 = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 9)).setObjects(("DISMAN-SCRIPT-MIB", "smRunArgument"), ("DISMAN-SCRIPT-MIB", "smRunStartTime"), ("DISMAN-SCRIPT-MIB", "smRunEndTime"), ("DISMAN-SCRIPT-MIB", "smRunLifeTime"), ("DISMAN-SCRIPT-MIB", "smRunExpireTime"), ("DISMAN-SCRIPT-MIB", "smRunExitCode"), ("DISMAN-SCRIPT-MIB", "smRunResult"), ("DISMAN-SCRIPT-MIB", "smRunState"), ("DISMAN-SCRIPT-MIB", "smRunControl"), ("DISMAN-SCRIPT-MIB", "smRunError"), ("DISMAN-SCRIPT-MIB", "smRunResultTime"), ("DISMAN-SCRIPT-MIB", "smRunErrorTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smRunGroup2 = smRunGroup2.setStatus('current')
if mibBuilder.loadTexts: smRunGroup2.setDescription('A collection of objects providing information about running scripts.')
smNotificationsGroup2 = NotificationGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 10)).setObjects(("DISMAN-SCRIPT-MIB", "smScriptAbort"), ("DISMAN-SCRIPT-MIB", "smScriptResult"), ("DISMAN-SCRIPT-MIB", "smScriptException"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smNotificationsGroup2 = smNotificationsGroup2.setStatus('current')
if mibBuilder.loadTexts: smNotificationsGroup2.setDescription('The notifications emitted by the Script MIB.')
smCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 64, 3, 1, 1)).setObjects(("DISMAN-SCRIPT-MIB", "smLanguageGroup"), ("DISMAN-SCRIPT-MIB", "smScriptGroup"), ("DISMAN-SCRIPT-MIB", "smLaunchGroup"), ("DISMAN-SCRIPT-MIB", "smRunGroup"), ("DISMAN-SCRIPT-MIB", "smCodeGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smCompliance = smCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: smCompliance.setDescription('The compliance statement for SNMP entities which implement the Script MIB.')
smScriptGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 2)).setObjects(("DISMAN-SCRIPT-MIB", "smScriptDescr"), ("DISMAN-SCRIPT-MIB", "smScriptLanguage"), ("DISMAN-SCRIPT-MIB", "smScriptSource"), ("DISMAN-SCRIPT-MIB", "smScriptAdminStatus"), ("DISMAN-SCRIPT-MIB", "smScriptOperStatus"), ("DISMAN-SCRIPT-MIB", "smScriptStorageType"), ("DISMAN-SCRIPT-MIB", "smScriptRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smScriptGroup = smScriptGroup.setStatus('deprecated')
if mibBuilder.loadTexts: smScriptGroup.setDescription('A collection of objects providing information about installed scripts.')
smLaunchGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 4)).setObjects(("DISMAN-SCRIPT-MIB", "smLaunchScriptOwner"), ("DISMAN-SCRIPT-MIB", "smLaunchScriptName"), ("DISMAN-SCRIPT-MIB", "smLaunchArgument"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxRunning"), ("DISMAN-SCRIPT-MIB", "smLaunchMaxCompleted"), ("DISMAN-SCRIPT-MIB", "smLaunchLifeTime"), ("DISMAN-SCRIPT-MIB", "smLaunchExpireTime"), ("DISMAN-SCRIPT-MIB", "smLaunchStart"), ("DISMAN-SCRIPT-MIB", "smLaunchControl"), ("DISMAN-SCRIPT-MIB", "smLaunchAdminStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchOperStatus"), ("DISMAN-SCRIPT-MIB", "smLaunchRunIndexNext"), ("DISMAN-SCRIPT-MIB", "smLaunchStorageType"), ("DISMAN-SCRIPT-MIB", "smLaunchRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smLaunchGroup = smLaunchGroup.setStatus('deprecated')
if mibBuilder.loadTexts: smLaunchGroup.setDescription('A collection of objects providing information about scripts that can be launched.')
smRunGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 5)).setObjects(("DISMAN-SCRIPT-MIB", "smRunArgument"), ("DISMAN-SCRIPT-MIB", "smRunStartTime"), ("DISMAN-SCRIPT-MIB", "smRunEndTime"), ("DISMAN-SCRIPT-MIB", "smRunLifeTime"), ("DISMAN-SCRIPT-MIB", "smRunExpireTime"), ("DISMAN-SCRIPT-MIB", "smRunExitCode"), ("DISMAN-SCRIPT-MIB", "smRunResult"), ("DISMAN-SCRIPT-MIB", "smRunState"), ("DISMAN-SCRIPT-MIB", "smRunControl"), ("DISMAN-SCRIPT-MIB", "smRunError"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smRunGroup = smRunGroup.setStatus('deprecated')
if mibBuilder.loadTexts: smRunGroup.setDescription('A collection of objects providing information about running scripts.')
smNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 64, 3, 2, 6)).setObjects(("DISMAN-SCRIPT-MIB", "smScriptAbort"), ("DISMAN-SCRIPT-MIB", "smScriptResult"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smNotificationsGroup = smNotificationsGroup.setStatus('deprecated')
if mibBuilder.loadTexts: smNotificationsGroup.setDescription('The notifications emitted by the Script MIB.')
mibBuilder.exportSymbols("DISMAN-SCRIPT-MIB", smLaunchLifeTime=smLaunchLifeTime, smCompliances=smCompliances, smScriptOperStatus=smScriptOperStatus, smRunError=smRunError, smCompliance2=smCompliance2, smLaunchEntry=smLaunchEntry, smScriptResult=smScriptResult, smLaunchStart=smLaunchStart, smLaunchOwner=smLaunchOwner, smLanguageGroup=smLanguageGroup, smScriptError=smScriptError, smRunIndex=smRunIndex, smRunState=smRunState, smLangRevision=smLangRevision, smScriptStorageType=smScriptStorageType, smScriptAbort=smScriptAbort, smScriptAdminStatus=smScriptAdminStatus, smScriptRowStatus=smScriptRowStatus, smScriptLastChange=smScriptLastChange, smScriptSource=smScriptSource, smConformance=smConformance, smExtsnDescr=smExtsnDescr, smRunResult=smRunResult, smLangLanguage=smLangLanguage, smExtsnIndex=smExtsnIndex, smLaunchGroup=smLaunchGroup, smLaunchArgument=smLaunchArgument, smLangEntry=smLangEntry, smRunLifeTime=smRunLifeTime, smLaunchName=smLaunchName, smLaunchRowStatus=smLaunchRowStatus, smLaunchMaxRunning=smLaunchMaxRunning, smRunExpireTime=smRunExpireTime, smLangIndex=smLangIndex, smObjects=smObjects, smRunEntry=smRunEntry, smScriptLanguage=smScriptLanguage, smLaunchAdminStatus=smLaunchAdminStatus, smCodeTable=smCodeTable, smLaunchOperStatus=smLaunchOperStatus, smScriptGroup2=smScriptGroup2, smRunArgument=smRunArgument, smLaunchExpireTime=smLaunchExpireTime, smLaunchRunIndexNext=smLaunchRunIndexNext, smExtsnVersion=smExtsnVersion, smScriptObjects=smScriptObjects, smRunEndTime=smRunEndTime, smLangVendor=smLangVendor, smScriptDescr=smScriptDescr, smNotificationsGroup2=smNotificationsGroup2, smCodeGroup=smCodeGroup, smLangVersion=smLangVersion, smLaunchLastChange=smLaunchLastChange, smScriptName=smScriptName, smRunControl=smRunControl, smRunExitCode=smRunExitCode, smLaunchScriptName=smLaunchScriptName, smLaunchGroup2=smLaunchGroup2, smRunObjects=smRunObjects, smRunGroup=smRunGroup, smCodeEntry=smCodeEntry, smLangTable=smLangTable, smScriptEntry=smScriptEntry, smScriptOwner=smScriptOwner, smGroups=smGroups, PYSNMP_MODULE_ID=scriptMIB, smNotificationsGroup=smNotificationsGroup, smRunTable=smRunTable, smExtsnRevision=smExtsnRevision, smCodeRowStatus=smCodeRowStatus, smScriptTable=smScriptTable, smExtsnEntry=smExtsnEntry, smTraps=smTraps, smRunStartTime=smRunStartTime, smCodeIndex=smCodeIndex, smNotifications=smNotifications, scriptMIB=scriptMIB, smRunErrorTime=smRunErrorTime, smCodeText=smCodeText, smLaunchError=smLaunchError, smScriptGroup=smScriptGroup, smLaunchMaxCompleted=smLaunchMaxCompleted, smExtsnTable=smExtsnTable, smCompliance=smCompliance, smLaunchControl=smLaunchControl, smScriptException=smScriptException, smLaunchStorageType=smLaunchStorageType, smExtsnExtension=smExtsnExtension, smRunResultTime=smRunResultTime, smLaunchRowExpireTime=smLaunchRowExpireTime, smLangDescr=smLangDescr, smExtsnVendor=smExtsnVendor, smRunGroup2=smRunGroup2, smLaunchScriptOwner=smLaunchScriptOwner, smLaunchTable=smLaunchTable)

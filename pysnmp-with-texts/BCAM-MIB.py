#
# PySNMP MIB module BCAM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BCAM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:36:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, ObjectIdentity, Unsigned32, ModuleIdentity, Integer32, Counter32, mgmt, MibIdentifier, TimeTicks, iso, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, IpAddress, NotificationType, NotificationType, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "ObjectIdentity", "Unsigned32", "ModuleIdentity", "Integer32", "Counter32", "mgmt", "MibIdentifier", "TimeTicks", "iso", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "IpAddress", "NotificationType", "NotificationType", "enterprises")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
sni = MibIdentifier((1, 3, 6, 1, 4, 1, 231))
sniProductMibs = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2))
sniBcam = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17))
class PhysAddress(OctetString):
    pass

bcamTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 1))
bcamGlobal = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 2))
bcamMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 3))
bcamTrace = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 4))
bcamTsap = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 5))
bcamCep = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 6))
bcamRoute = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 7))
bcamIf = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 8))
bcamRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 9))
bcamHost = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 17, 10))
bcamTrapString = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 1, 1), DisplayString())
if mibBuilder.loadTexts: bcamTrapString.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTrapString.setDescription(' Textual description of the trap. The trap string contains the values sent with the trap in printable form separated by the keywords given at the description of the individual traps. ')
bcamTrapOutPoolOverCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 1, 2), Integer32())
if mibBuilder.loadTexts: bcamTrapOutPoolOverCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTrapOutPoolOverCurrent.setDescription(' The number of bytes of resident memory used for output cells when the trap condition (output pool over maximum) has been recognized. ')
bcamTrapOutPoolUnderCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 1, 3), Integer32())
if mibBuilder.loadTexts: bcamTrapOutPoolUnderCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTrapOutPoolUnderCurrent.setDescription(' The number of bytes of resident memory used for output cells when the trap condition (output pool under maximum) has been recognized. ')
bcamTrapInPoolOverCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 1, 4), Integer32())
if mibBuilder.loadTexts: bcamTrapInPoolOverCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTrapInPoolOverCurrent.setDescription(' The number of bytes of resident memory used for input cells when the trap condition (input pool over maximum) has been recognized. ')
bcamTrapInPoolUnderCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 1, 5), Integer32())
if mibBuilder.loadTexts: bcamTrapInPoolUnderCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTrapInPoolUnderCurrent.setDescription(' The number of bytes of resident memory used for input cells when the trap condition (input pool under maximum) has been recognized. ')
bcamTrapOutPoolOver = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 17) + (0,301)).setObjects(("BCAM-MIB", "bcamGlobalUpTime"), ("BCAM-MIB", "bcamGlobalHostName"), ("BCAM-MIB", "bcamMemoryPoolOutputLimitTrap"), ("BCAM-MIB", "bcamTrapOutPoolOverCurrent"), ("BCAM-MIB", "bcamTrapString"))
if mibBuilder.loadTexts: bcamTrapOutPoolOver.setDescription(' This trap will be sent if the resident memory used for output cells exceeds the limit (bcamMemoryPoolOutputLimitTrap) for more than 5 seconds. bcamTrapString has the fields: $HOST$: <hostname> $UPTIME$: <bcamuptime> $OUTLIMIT$: <memlimit> $OUTCURRENT$: <memcurrent> The following values will be sent together with the trap: bcamGlobalHostName bcamGlobalUpTime bcamMemoryPoolOutputLimitTrap bcamMemoryPoolOverCurrent bcamTrapString ')
bcamTrapOutPoolUnder = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 17) + (0,302)).setObjects(("BCAM-MIB", "bcamGlobalUpTime"), ("BCAM-MIB", "bcamGlobalHostName"), ("BCAM-MIB", "bcamMemoryPoolOutputLimitTrap"), ("BCAM-MIB", "bcamTrapOutPoolUnderCurrent"), ("BCAM-MIB", "bcamTrapString"))
if mibBuilder.loadTexts: bcamTrapOutPoolUnder.setDescription(' This trap will be sent if the resident memory used for output cells has exceeded the limit (bcamMemoryPoolOutputLimitTrap) and falls under the limit for more than 5 seconds. bcamTrapString has the fields: $HOST$: <hostname> $UPTIME$: <bcamuptime> $OUTLIMIT$: <memlimit> $OUTCURRENT$: <memcurrent> The following values will be sent together with the trap: bcamGlobalHostName bcamGlobalUpTime bcamMemoryPoolOutputLimitTrap bcamMemoryPoolUnderCurrent bcamTrapString ')
bcamTrapInPoolOver = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 17) + (0,303)).setObjects(("BCAM-MIB", "bcamGlobalUpTime"), ("BCAM-MIB", "bcamGlobalHostName"), ("BCAM-MIB", "bcamMemoryPoolInputLimitTrap"), ("BCAM-MIB", "bcamTrapInPoolOverCurrent"), ("BCAM-MIB", "bcamTrapString"))
if mibBuilder.loadTexts: bcamTrapInPoolOver.setDescription(' This trap will be sent if the resident memory used for input cells exceeds the limit (bcamMemoryPoolInputLimitTrap) for more than 5 seconds. bcamTrapString has the fields: $HOST$: <hostname> $UPTIME$: <bcamuptime> $INLIMIT$: <memlimit> $INCURRENT$: <memcurrent> The following values will be sent together with the trap: bcamGlobalHostName bcamGlobalUpTime bcamMemoryPoolInputLimitTrap bcamTrapInPoolOverCurrent bcamTrapString ')
bcamTrapInPoolUnder = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 17) + (0,304)).setObjects(("BCAM-MIB", "bcamGlobalUpTime"), ("BCAM-MIB", "bcamGlobalHostName"), ("BCAM-MIB", "bcamMemoryPoolInputLimitTrap"), ("BCAM-MIB", "bcamTrapInPoolUnderCurrent"), ("BCAM-MIB", "bcamTrapString"))
if mibBuilder.loadTexts: bcamTrapInPoolUnder.setDescription(' This trap will be sent if the resident memory used for input cells has exceeded the limit (bcamMemoryPoolInputLimitTrap) and falls under the limit for more than 5 seconds. bcamTrapString has the fields: $HOST$: <hostname> $UPTIME$: <bcamuptime> $INLIMIT$: <memlimit> $INCURRENT$: <memcurrent> The following values will be sent together with the trap: bcamGlobalHostName bcamGlobalUpTime bcamMemoryPoolInputLimitTrap bcamTrapInPoolUnderCurrent bcamTrapString ')
bcamTrapLinkUp = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 17) + (0,305)).setObjects(("BCAM-MIB", "bcamGlobalUpTime"), ("BCAM-MIB", "bcamGlobalHostName"), ("BCAM-MIB", "bcamIfTabNumbers"), ("BCAM-MIB", "bcamIfTabName"), ("BCAM-MIB", "bcamTrapString"))
if mibBuilder.loadTexts: bcamTrapLinkUp.setDescription(' This trap will be sent if an interface enters the state active (bcamIfAdminState). bcamTrapString has the fields: $HOST$: <hostname> $UPTIME$: <bcamuptime> $NUMBER$: <linknumber> $NAME$: <linkname> The following values will be sent together with the trap: bcamGlobalHostName bcamGlobalUpTime bcamIfTabNumbers bcamIfTabName bcamTrapString ')
bcamTrapLinkDown = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 17) + (0,306)).setObjects(("BCAM-MIB", "bcamGlobalUpTime"), ("BCAM-MIB", "bcamGlobalHostName"), ("BCAM-MIB", "bcamIfTabNumbers"), ("BCAM-MIB", "bcamIfTabName"), ("BCAM-MIB", "bcamTrapString"))
if mibBuilder.loadTexts: bcamTrapLinkDown.setDescription(' This trap will be sent if an interface leaves the state active (bcamIfAdminState). bcamTrapString has the fields: $HOST$: <hostname> $UPTIME$: <bcamuptime> $NUMBER$: <linknumber> $NAME$: <linkname> The following values will be sent together with the trap: bcamGlobalHostName bcamGlobalUpTime bcamIfTabNumbers bcamIfTabName bcamTrapString ')
bcamTrapSystemUp = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 17) + (0,307)).setObjects(("BCAM-MIB", "bcamGlobalUpTime"), ("BCAM-MIB", "bcamGlobalHostName"), ("BCAM-MIB", "bcamTrapString"))
if mibBuilder.loadTexts: bcamTrapSystemUp.setDescription(' This trap will be sent after a successful start of BCAM. bcamTrapString has the fields: $HOST$: <hostname> $UPTIME$: <bcamuptime> The following values will be sent together with the trap: bcamGlobalHostName bcamGlobalUpTime bcamTrapString ')
bcamGlobalBcamVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalBcamVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalBcamVersion.setDescription('The version of BCAM in the form xx.yy xx: mainversion yy: subversion')
bcamGlobalMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalMibVersion.setDescription('Version of BCAM specific MIB (beginning with 1). Will be increased with every enhancement of this MIB')
bcamGlobalUpTime = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalUpTime.setDescription('Time in seconds since start of BCAM')
bcamGlobalPortNonpriv = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalPortNonpriv.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalPortNonpriv.setDescription('The lowest port number that may be used by non privileged applications')
bcamGlobalPortFree = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalPortFree.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalPortFree.setDescription('The lowest port number that will be assigned dynamical by BCAM')
bcamGlobalNumBitmap = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalNumBitmap.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalNumBitmap.setDescription('The number of bitmaps to administer slots in the data slot pool. Every bitmap can administer 2048 slots. So the maximum number of slots in a pool is bcamGlobalNumBitmap*2048')
bcamGlobalMaxRemoteIp = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalMaxRemoteIp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalMaxRemoteIp.setDescription('The maximum length in bytes BCAM uses for an NSDU for an endsystem that is reached over at least one router')
bcamGlobalEsCreationIp = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("ipOff", 1), ("ipInData", 2), ("ipOutData", 4), ("ipRoutingProt", 8), ("ipRoutingData", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalEsCreationIp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalEsCreationIp.setDescription(' The types of IP protocols that will lead to automatic endsystem creation: ipOff (1) : no automatic endsystem creation due to IP protocols. ipInData (2) : automatic endsystem creation due to IP data received. ipOutData (4) : automatic endsystem creation due to IP data sent. ipRoutingProt (8) : automatic endsystem creation due to IP routing protocols. ipRoutingData (16) : automatic endsystem creation due to routed IP protocols. ')
bcamGlobalEsCreationIso = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("isoOff", 1), ("isoInData", 2), ("isoOutData", 4), ("isoRoutingProt", 8), ("isoRoutingData", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalEsCreationIso.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalEsCreationIso.setDescription(' The types of ISO 8473 and ISO 9542 protocols that will lead to automatic endsystem creation: isoOff (1) : no automatic endsystem creation due to ISO protocols. isoInData (2) : automatic endsystem creation due to ISO data received. isoOutData (4) : automatic endsystem creation due to ISO data sent. isoRoutingProt (8) : automatic endsystem creation due to ISO routing protocols. isoRoutingData (16) : automatic endsystem creation due to routed ISO protocols. ')
bcamGlobalBroadcast = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalBroadcast.setDescription('Describes how incoming broadcasts will be treated. on (2) : broadcasts will be evaluated and answered if necessary. off (1) : broadcasts will be ignored. ')
bcamGlobalArp = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("quiet", 2), ("on", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalArp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalArp.setDescription('Describes if the address resolution protocol is used. off (1) : no ARP will be used. quiet (2) : ARP will be used the first time a route is used and periodically if there exists a transport connection to the system described by this route and there was no data transfer in the last supervision interval. on (4) : ARP will be used the first time a route is used and periodically after the supervision interval.')
bcamGlobalRarp = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalRarp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalRarp.setDescription('Describes if the reverse address resolution protocol will be supported. off (1) : RARP not supported. on (2) : RARP supported.')
bcamGlobalInWaitLimit1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInWaitLimit1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInWaitLimit1.setDescription(' The lowest bucket limit for the recording of the input wait times in milliseconds. The input wait time is the time interval between the announcement of a message to an application and corresponding receive call. Every change will reset all counters for the input wait time.')
bcamGlobalInWaitLimit2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInWaitLimit2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInWaitLimit2.setDescription(' The second bucket limit for the recording of the input wait times in milliseconds. The input wait time is the time interval between the announcement of a message to an application and corresponding receive call. Every change will reset all counters for the input wait time.')
bcamGlobalInWaitLimit3 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 15), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInWaitLimit3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInWaitLimit3.setDescription(' The third bucket limit for the recording of the input wait times in milliseconds. The input wait time is the time interval between the announcement of a message to an application and corresponding receive call. Every change will reset all counters for the input wait time.')
bcamGlobalInWaitLimit4 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 16), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInWaitLimit4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInWaitLimit4.setDescription(' The highest bucket limit for the recording of the input wait times in milliseconds. The input wait time is the time interval between the announcement of a message to an application and corresponding receive call. Every change will reset all counters for the input wait time.')
bcamGlobalInWaitChange = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalInWaitChange.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInWaitChange.setDescription(' The number of times the limits of the input wait time buckets have been changed.')
bcamGlobalInWaitSet = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInWaitSet.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInWaitSet.setDescription(' The state of counting into the input wait time buckets. off (2) : the counting is stopped. on (1) : the counting is running. ')
bcamGlobalReactLimit1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 19), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalReactLimit1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalReactLimit1.setDescription(' The lowest bucket limit for the recording of the application reaction times in milliseconds. The application reaction time is the time interval between a receive call and a directly following send call. Every change will reset all counters for the application reaction time. ')
bcamGlobalReactLimit2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalReactLimit2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalReactLimit2.setDescription(' The second bucket limit for the recording of the application reaction times in milliseconds. The application reaction time is the time interval between a receive call and a directly following send call. Every change will reset all counters for the application reaction time. ')
bcamGlobalReactLimit3 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalReactLimit3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalReactLimit3.setDescription(' The third bucket limit for the recording of the application reaction times in milliseconds. The application reaction time is the time interval between a receive call and a directly following send call. Every change will reset all counters for the application reaction time. ')
bcamGlobalReactLimit4 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 22), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalReactLimit4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalReactLimit4.setDescription(' The highest bucket limit for the recording of the application reaction times in milliseconds. The application reaction time is the time interval between a receive call and a directly following send call. Every change will reset all counters for the application reaction time. ')
bcamGlobalReactChange = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalReactChange.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalReactChange.setDescription(' The number of times the limits of the application reaction time buckets have been changed.')
bcamGlobalReactSet = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalReactSet.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalReactSet.setDescription(' The state of counting into the application reaction time buckets. off (2) : the counting is stopped. on (1) : the counting is running. ')
bcamGlobalInProcLimit1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 25), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInProcLimit1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInProcLimit1.setDescription(' The lowest bucket limit for the recording of the inbound processing times in milliseconds. The inbound processing time is the time interval between the arrival of the first byte of a message at layer 2 and the receive of the last byte this message by the application. Every change will reset all counters for the inbound processing time. ')
bcamGlobalInProcLimit2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 26), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInProcLimit2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInProcLimit2.setDescription(' The second bucket limit for the recording of the inbound processing times in milliseconds. The inbound processing time is the time interval between the arrival of the first byte of a message at layer 2 and the receive of the last byte this message by the application. Every change will reset all counters for the inbound processing time. ')
bcamGlobalInProcLimit3 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 27), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInProcLimit3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInProcLimit3.setDescription(' The third bucket limit for the recording of the inbound processing times in milliseconds. The inbound processing time is the time interval between the arrival of the first byte of a message at layer 2 and the receive of the last byte this message by the application. Every change will reset all counters for the inbound processing time. ')
bcamGlobalInProcLimit4 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 28), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInProcLimit4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInProcLimit4.setDescription(' The highest bucket limit for the recording of the inbound processing times in milliseconds. The inbound processing time is the time interval between the arrival of the first byte of a message at layer 2 and the receive of the last byte this message by the application. Every change will reset all counters for the inbound processing time. ')
bcamGlobalInProcChange = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalInProcChange.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInProcChange.setDescription(' The number of times the limits of the inbound processing time buckets have been changed.')
bcamGlobalInProcSet = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalInProcSet.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalInProcSet.setDescription(' The state of counting into the inbound processing time buckets. off (2) : the counting is stopped. on (1) : the counting is running. ')
bcamGlobalOutProcLimit1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 31), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalOutProcLimit1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalOutProcLimit1.setDescription(' The lowest bucket limit for the recording of the outbound processing times in milliseconds. The outbound processing time is the time interval between the send call of an application and the confirmation for the processing of the last byte of the message by layer 1. Every change will reset all counters for the outbound processing time. ')
bcamGlobalOutProcLimit2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 32), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalOutProcLimit2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalOutProcLimit2.setDescription(' The second bucket limit for the recording of the outbound processing times in milliseconds. The outbound processing time is the time interval between the send call of an application and the confirmation for the processing of the last byte of the message by layer 1. Every change will reset all counters for the outbound processing time. ')
bcamGlobalOutProcLimit3 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 33), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalOutProcLimit3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalOutProcLimit3.setDescription(' The third bucket limit for the recording of the outbound processing times in milliseconds. The outbound processing time is the time interval between the send call of an application and the confirmation for the processing of the last byte of the message by layer 1. Every change will reset all counters for the outbound processing time. ')
bcamGlobalOutProcLimit4 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 34), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalOutProcLimit4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalOutProcLimit4.setDescription(' The highest bucket limit for the recording of the outbound processing times in milliseconds. The outbound processing time is the time interval between the send call of an application and the confirmation for the processing of the last byte of the message by layer 1. Every change will reset all counters for the outbound processing time. ')
bcamGlobalOutProcChange = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalOutProcChange.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalOutProcChange.setDescription(' The number of times the limits of the outbound processing time buckets have been changed.')
bcamGlobalOutProcSet = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalOutProcSet.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalOutProcSet.setDescription(' The state of counting into the outbound processing time buckets. off (2) : the counting is stopped. on (1) : the counting is running. ')
bcamGlobalSnmpRelease = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalSnmpRelease.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalSnmpRelease.setDescription(' The time interval in minutes for which the values for already closed connections and applications are still available. ')
bcamGlobalTrapPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32767))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamGlobalTrapPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalTrapPollInterval.setDescription(' The time interval in seconds after which the SNMP agent will poll for traps.')
bcamGlobalFileApplTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 39), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(54, 54)).setFixedLength(54)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalFileApplTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalFileApplTable.setDescription('The name of the file that contains the assignments of NEA or ISO applications to the virtual host on which they shall run.')
bcamGlobalFileSocketHostTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(54, 54)).setFixedLength(54)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalFileSocketHostTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalFileSocketHostTable.setDescription('The name of the file that contains the assignments of IP adresses to socket host names for automatic created endsystems.')
bcamGlobalFileProcTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 41), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(54, 54)).setFixedLength(54)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalFileProcTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalFileProcTable.setDescription('The name of the file that contains the assignments of host names to net addresses for automatic created endsystems.')
bcamGlobalAccessProcTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("read", 1), ("update", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalAccessProcTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalAccessProcTable.setDescription('The access of the file named in bcamGlobalFileProcTable: read (1) : only endsystems contained in the file will be created by automatic endsystem creation. update (2) : the file will be extended if a new endsystem is created.')
bcamGlobalHostName = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 2, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamGlobalHostName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamGlobalHostName.setDescription(' NEA name of the local endsystem ')
bcamMemoryClass3 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryClass3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryClass3.setDescription(' The number of bytes of class 3 memory requested by BCAM. ')
bcamMemoryClass4 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryClass4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryClass4.setDescription(' The number of bytes of class 4 memory requested by BCAM. ')
bcamMemoryLenLongEventSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenLongEventSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenLongEventSlot.setDescription(' The length of one long event slot in bytes. ')
bcamMemoryOccLongEventSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccLongEventSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccLongEventSlot.setDescription(' The number of long event slots currently used. ')
bcamMemoryLenShortEventSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenShortEventSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenShortEventSlot.setDescription(' The length of one short event slot in bytes. ')
bcamMemoryOccShortEventSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccShortEventSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccShortEventSlot.setDescription(' The number of short event slots currently used. ')
bcamMemoryLenTransParamSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenTransParamSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenTransParamSlot.setDescription(' The length of one transport parameter block in bytes. ')
bcamMemoryOccTransParamSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccTransParamSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccTransParamSlot.setDescription(' The number of transport parameter blocks currently used. ')
bcamMemoryLenSnmpParamSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenSnmpParamSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenSnmpParamSlot.setDescription(' The length of one SNMP parameter block in bytes. ')
bcamMemoryOccSnmpParamSlot = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccSnmpParamSlot.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccSnmpParamSlot.setDescription(' The number of SNMP parameter blocks currently used. ')
bcamMemoryLenApplCb = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenApplCb.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenApplCb.setDescription(' The length of one application control block in bytes. ')
bcamMemoryOccApplCb = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccApplCb.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccApplCb.setDescription(' The number of application control blocks currently used. ')
bcamMemoryLenEnaCb = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenEnaCb.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenEnaCb.setDescription(' The length of one control block in bytes. ')
bcamMemoryOccEnaCb = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccEnaCb.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccEnaCb.setDescription(' The number of control blocks currently used. ')
bcamMemoryLenExtApplCb = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenExtApplCb.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenExtApplCb.setDescription(' The length of one extended application control block in bytes. ')
bcamMemoryOccExtApplCb = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccExtApplCb.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccExtApplCb.setDescription(' The number of extended application control blocks currently used. ')
bcamMemoryLenShortResConn2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenShortResConn2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenShortResConn2.setDescription(' The length of one short resident connection control block 2 in bytes. ')
bcamMemoryOccShortResConn2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccShortResConn2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccShortResConn2.setDescription(' The number of short resident connection control blocks 2 currently used. ')
bcamMemoryLenLongResConn2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenLongResConn2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenLongResConn2.setDescription(' The length of one long resident connection control block 2 in bytes. ')
bcamMemoryOccLongResConn2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccLongResConn2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccLongResConn2.setDescription(' The number of long resident connection control blocks 2 currently used. ')
bcamMemoryLenShortPagConn1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenShortPagConn1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenShortPagConn1.setDescription(' The length of one short pageable connection control block 1 in bytes. ')
bcamMemoryOccShortPagConn1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccShortPagConn1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccShortPagConn1.setDescription(' The number of short pageable connection control blocks 1 currently used. ')
bcamMemoryLenSnmpConn = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenSnmpConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenSnmpConn.setDescription(' The length of one SNMP connection control block in bytes. ')
bcamMemoryOccSnmpConn = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccSnmpConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccSnmpConn.setDescription(' The number of SNMP connection control blocks currently used. ')
bcamMemoryLenLongPagConn1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenLongPagConn1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenLongPagConn1.setDescription(' The length of one long pageable connection control block 1 in bytes. ')
bcamMemoryOccLongPagConn1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccLongPagConn1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccLongPagConn1.setDescription(' The number of long pageable connection control blocks 1 currently used. ')
bcamMemoryLenShortPagConn2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryLenShortPagConn2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryLenShortPagConn2.setDescription(' The length of one short pageable connection control block 2 in bytes. ')
bcamMemoryOccShortPagConn2 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryOccShortPagConn2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryOccShortPagConn2.setDescription(' The number of short pageable connection control blocks 2 currently used. ')
bcamMemoryPoolInputCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 29), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolInputCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolInputCurrent.setDescription(' The number of bytes of resident memory currently used for input cells ')
bcamMemoryPoolInputResume = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 30), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolInputResume.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolInputResume.setDescription(' Describes whether an interface waits for memory for input . If zero, some interfaces will not have enough input buffer( A cell request was rejected because bcamMemoryPoolInputCurrent exceeded bcamMemoryPoolInputLimitTrap). ')
bcamMemoryPoolInputMonMax = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolInputMonMax.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolInputMonMax.setDescription(' The maximum number of bytes of resident memory used for input cells for the last 5 seconds. ')
bcamMemoryPoolInputMonMin = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolInputMonMin.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolInputMonMin.setDescription(' The minimum number of bytes of resident memory used for input cells for the last 5 seconds. ')
bcamMemoryPoolInputLimit = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolInputLimit.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolInputLimit.setDescription(' The maximum number of bytes of resident memory to be used for input cells. ')
bcamMemoryPoolInputLimitTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolInputLimitTrap.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolInputLimitTrap.setDescription(' The trap limit for the number of bytes of resident memory for input cells (if bcamMemoryPoolInputMonMin is greater than bcamMemoryPoolInputLimitTrap, a trap will be sent). ')
bcamMemoryPoolMaxResident = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 35), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamMemoryPoolMaxResident.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolMaxResident.setDescription(' The maximum number of bytes of resident memory to be used for input and output cells. ')
bcamMemoryPoolMaxPageable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 36), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bcamMemoryPoolMaxPageable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolMaxPageable.setDescription(' The maximum number of bytes of pageable memory to be used for input and output cells. ')
bcamMemoryPoolInputMaxPageable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolInputMaxPageable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolInputMaxPageable.setDescription(' The maximum number of bytes of pageable memory to be used for input cells. ')
bcamMemoryPoolOutputCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolOutputCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolOutputCurrent.setDescription(' The number of bytes of resident memory currently used for output cells. ')
bcamMemoryPoolOutputResume = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolOutputResume.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolOutputResume.setDescription(' Describes whether an interface waits for memory for output . If zero, some interfaces will not have enough output buffer( A cell request was rejected because bcamMemoryPoolOutputCurrent exceeded bcamMemoryPoolOutputLimitTrap). ')
bcamMemoryPoolOutputMonMax = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolOutputMonMax.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolOutputMonMax.setDescription(' The maximum number of bytes of resident memory used for output cells for the last 5 seconds. ')
bcamMemoryPoolOutputMonMin = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolOutputMonMin.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolOutputMonMin.setDescription(' The minimum number of bytes of resident memory used for output cells for the last 5 seconds. ')
bcamMemoryPoolOutputLimit = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolOutputLimit.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolOutputLimit.setDescription(' The maximum number of bytes of resident memory to be used for output cells. ')
bcamMemoryPoolOutputLimitTrap = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 43), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolOutputLimitTrap.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolOutputLimitTrap.setDescription(' The trap limit for the number of bytes of resident memory for output cells (if bcamMemoryPoolOutputMonMin is greater than bcamMemoryPoolOutputLimitTrap, a trap will be sent). ')
bcamMemoryPoolMaxCells = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolMaxCells.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolMaxCells.setDescription(' The maximum number of cells contained in every pool type. ')
bcamMemoryPoolOutputMaxPageable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolOutputMaxPageable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolOutputMaxPageable.setDescription(' The maximum number of bytes of pageable memory to be used for output cells. ')
bcamMemoryPoolRoutingCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolRoutingCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolRoutingCurrent.setDescription(' The number of bytes of resident memory currently used for routing cells ')
bcamMemoryPoolRoutingLimit = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolRoutingLimit.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolRoutingLimit.setDescription(' The maximum number of bytes of resident memory to be used for routing cells. ')
bcamMemoryPoolPageableCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolPageableCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolPageableCurrent.setDescription(' The number of bytes of pageable memory currently used for pools ')
bcamMemoryPoolPageableFixed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryPoolPageableFixed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryPoolPageableFixed.setDescription(' The number of bytes of pageable fixed memory currently used for output cells. ')
bcamMemoryCellReqSucc = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqSucc.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqSucc.setDescription(' The number of successful cell requests. ')
bcamMemoryCellReqResOutExceed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqResOutExceed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqResOutExceed.setDescription(' The number of requests for resident output cells that failed because the limit has been reached. ')
bcamMemoryCellReqResInExceed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqResInExceed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqResInExceed.setDescription(' The number of requests for resident input cells that failed because limit has been reached. ')
bcamMemoryCellReqTempExceed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqTempExceed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqTempExceed.setDescription(' The number of cell requests failed because of temporary shortage. ')
bcamMemoryCellReqBitmapFull = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 54), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqBitmapFull.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqBitmapFull.setDescription(' The number of cell requests failed because bitmap was full. ')
bcamMemoryCellReqNoMemory = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 55), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqNoMemory.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqNoMemory.setDescription(' The number of cell requests failed because memory request failed. ')
bcamMemoryCellReqPagInExceed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqPagInExceed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqPagInExceed.setDescription(' The number of requests for pageable input cells that failed because limit has been reached. ')
bcamMemoryCellReqPagOutExceed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 3, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamMemoryCellReqPagOutExceed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamMemoryCellReqPagOutExceed.setDescription(' The number of requests for pageable output cells that failed because limit has been reached. ')
bcamTraceSavingState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("initiated", 1), ("active", 2), ("shutting", 4), ("passive", 8), ("waiting", 16), ("noSaving", 32)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceSavingState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceSavingState.setDescription(' Describes if any of the running BCAM traces are saved to a file. noSaving (32) : no trace will be written initiated (1) : the trace saving task has been created active (2) : the trace saving task is active shutting (4) : the trace saving task is terminating passive (8) : the trace file has been closed waiting (16) : the trace saving task is waiting for trace data to write Several bits may be set simultaneous.')
bcamTraceFilename = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(54, 54)).setFixedLength(54)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceFilename.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceFilename.setDescription(' The name of the file currently used for saving BCAM traces.')
bcamTraceMaxFilesize = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceMaxFilesize.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceMaxFilesize.setDescription(' The maximum size of one file used for saving BCAM traces in bytes. ')
bcamTraceNumberFiles = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceNumberFiles.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceNumberFiles.setDescription(' The number of files used for saving BCAM traces. ')
bcamTraceAdmState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceAdmState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceAdmState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceAdmNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceAdmNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceAdmNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceAdmBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceAdmBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceAdmBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceBasicState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceBasicState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceBasicState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceBasicNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceBasicNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceBasicNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceBasicBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceBasicBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceBasicBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceConnState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceConnState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceConnState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceConnNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceConnNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceConnNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceConnBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceConnBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceConnBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceLocalState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceLocalState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceLocalState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceLocalNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceLocalNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceLocalNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceLocalBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceLocalBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceLocalBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceMappingState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceMappingState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceMappingState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceMappingNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceMappingNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceMappingNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceMappingBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceMappingBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceMappingBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceMgmtState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceMgmtState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceMgmtState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceMgmtNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceMgmtNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceMgmtNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceMgmtBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceMgmtBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceMgmtBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceNetState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceNetState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceNetState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceNetNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceNetNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceNetNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceNetBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceNetBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceNetBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceSnmpState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceSnmpState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceSnmpState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceSnmpNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceSnmpNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceSnmpNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceSnmpBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceSnmpBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceSnmpBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceTransState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceTransState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceTransState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceTransNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceTransNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceTransNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceTransBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceTransBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceTransBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTraceInfoState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceInfoState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceInfoState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamTraceInfoNumberBuffer = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceInfoNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceInfoNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamTraceInfoBufferLen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 4, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTraceInfoBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTraceInfoBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamTsapCurrOpen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapCurrOpen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapCurrOpen.setDescription('The number of currently active TSAPs (including BCAM internal applications). ')
bcamTsapTotOpen = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTotOpen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTotOpen.setDescription('The number of TSAPs opened since start of BCAM (excluding the active TSAPs). ')
bcamTsapSendCall = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapSendCall.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapSendCall.setDescription('Number of successful send calls of all TSAPs since start of BCAM')
bcamTsapSendByteHigh = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapSendByteHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapSendByteHigh.setDescription('Number of bytes given to BCAM-interface to send from all TSAPs since start of BCAM (high word, multiply by 4294967296).')
bcamTsapSendByteLow = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapSendByteLow.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapSendByteLow.setDescription('Number of bytes given to BCAM-interface to send from all TSAPs since start of BCAM (low word, add to high word). ')
bcamTsapRecvCall = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRecvCall.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRecvCall.setDescription('Number of successful receive calls of all TSAPs since start of BCAM')
bcamTsapRecvByteHigh = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRecvByteHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRecvByteHigh.setDescription('Number of bytes given from BCAM to all TSAPs since start of BCAM (high word, multiply by 4294967296).')
bcamTsapRecvByteLow = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRecvByteLow.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRecvByteLow.setDescription('Number of bytes given from BCAM to all TSAPs since start of BCAM (low word, add to high word).')
bcamTsapSendCallCless = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapSendCallCless.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapSendCallCless.setDescription(' The number of successful send calls for connectionless data of all TSAPs since start of BCAM')
bcamTsapSendByteClessHigh = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapSendByteClessHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapSendByteClessHigh.setDescription(' The number of bytes given to BCAM-interface to send connectionless from all TSAPs since start of BCAM (high word, multiply by 4294967296). ')
bcamTsapSendByteClessLow = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapSendByteClessLow.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapSendByteClessLow.setDescription(' The number of bytes given to BCAM-interface to send connectionless from all TSAPs since start of BCAM (low word, add to high word). ')
bcamTsapRecvCallCless = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRecvCallCless.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRecvCallCless.setDescription(' The number of successful send calls for connectionless data of all TSAPs since start of BCAM')
bcamTsapRecvByteClessHigh = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRecvByteClessHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRecvByteClessHigh.setDescription(' The number of bytes received connectionless given from BCAM to all TSAPs since start of BCAM (high word, multiply by 4294967296). ')
bcamTsapRecvByteClessLow = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRecvByteClessLow.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRecvByteClessLow.setDescription(' The number of bytes received connectionless given from BCAM to all TSAPs since start of BCAM (low word, add to high word). ')
bcamTsapNumTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapNumTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapNumTable.setDescription(' The number of table entries. ')
bcamTsapMaxTsap = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapMaxTsap.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapMaxTsap.setDescription(' The maximum number of not predefined applications that may be opened simultaneously. ')
bcamTsapMaxTsapTask = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapMaxTsapTask.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapMaxTsapTask.setDescription(' The maximum number of not predefined applications that may be opened simultaneously by one task. ')
bcamTsapMaxCepTsap = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapMaxCepTsap.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapMaxCepTsap.setDescription(' The maximum number of connections a non system application may have opened concurrently. ')
bcamTsapRejTsap = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRejTsap.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRejTsap.setDescription(' The number of rejected tsap openings because of reached maximum (see bcamTsapMaxTsap). ')
bcamTsapRejTsapTask = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRejTsapTask.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRejTsapTask.setDescription(' The number of rejected tsap openings because of reached maximum for one task (see bcamTsapMaxTsapTask). ')
bcamTsapRejCepTsap = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapRejCepTsap.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapRejCepTsap.setDescription(' The number of connection requests rejected because the maximum number of connections for this tsap has been reached (see bcamTsapMaxCepTsap). ')
bcamTsapTab = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22), )
if mibBuilder.loadTexts: bcamTsapTab.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTab.setDescription(' Table of all active TSAPs ')
bcamTsapTabEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1), ).setIndexNames((0, "BCAM-MIB", "bcamTsapTabNumbers"))
if mibBuilder.loadTexts: bcamTsapTabEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabEntry.setDescription(' Information about a current active TSAP ')
bcamTsapTabNumbers = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabNumbers.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabNumbers.setDescription(' The definite identifier for this application. Even if the same application is disabled and then reenabled, the identfier will get a new value. ')
bcamTsapTabState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 8))).clone(namedValues=NamedValues(("opening", 1), ("open", 2), ("closing", 3), ("closed", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabState.setDescription(' The current state of this application. opening (1) : the application enableing is in progress. open (2): the application is ready for requesting or accepting connections. closing (3): the termination of the application is in progress. closed (4): the application has been closed. Several bits may be set simultaneous.')
bcamTsapTabDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabDuration.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabDuration.setDescription(' The time in seconds the application was enabled. ')
bcamTsapTabDateApplEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabDateApplEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabDateApplEnable.setDescription(' The date of the application enableing. Format: YYYYMMDD ')
bcamTsapTabTimeApplEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabTimeApplEnable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabTimeApplEnable.setDescription(' The time of the application enableing. Format: HHMMSS ')
bcamTsapTabTypName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("neaName", 1), ("socketName", 2), ("isoName", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabTypName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabTypName.setDescription(' The type of name of this application. NeaName (1) : the name consists of 8 byte application name and 8 byte name of endsystem. SocketName (2) : the name consists of up to 32 byte socket name. IsoName (3) : the name consists of up to 78 byte iso name. ')
bcamTsapTabName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 78))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabName.setDescription(' The name of this application according the type of the name (bcamTsapTabTypName). ')
bcamTsapTabPortnumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabPortnumber.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabPortnumber.setDescription(' The port number used by this application (if known). ')
bcamTsapTabOsiTsel = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabOsiTsel.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabOsiTsel.setDescription(' The OSI transport selector of this application (if known). ')
bcamTsapTabNeaTsel = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabNeaTsel.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabNeaTsel.setDescription(' The NEA transport selector of this application (if known). ')
bcamTsapTabHost = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabHost.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabHost.setDescription(' The name of the host in which the application resides. ')
bcamTsapTabDiagnostic = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabDiagnostic.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabDiagnostic.setDescription(' The reason why the application was disabled (for diagnostic purposes only). ')
bcamTsapTabTsduSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabTsduSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabTsduSends.setDescription(' The number of packets to send given to BCAM at the TSAP by this application. ')
bcamTsapTabByteSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabByteSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabByteSends.setDescription(' The number of bytes to send given to BCAM at the TSAP by this application. ')
bcamTsapTabTsduReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabTsduReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabTsduReceiveds.setDescription(' The number of packets received at the TSAP by this application. ')
bcamTsapTabByteReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabByteReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabByteReceiveds.setDescription(' The number of bytes received at the TSAP by this application. ')
bcamTsapTabSendCallOverMaxs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabSendCallOverMaxs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabSendCallOverMaxs.setDescription(' The number of send calls of this application while BCAM limits have been reached. ')
bcamTsapTabLetterTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabLetterTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabLetterTimeouts.setDescription(' The number of packets that were deleted without being delivered to the application due to timeout of the letter timer. ')
bcamTsapTabInWaitBuck1Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck1Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck1Hist.setDescription(' The number of times the input wait time was in the time interval between zero and bcamGlobalInWaitLimit1 for meanwhile closed applications. ')
bcamTsapTabInWaitBuck2Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck2Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck2Hist.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit1 and bcamGlobalInWaitLimit2 for meanwhile closed applications. ')
bcamTsapTabInWaitBuck3Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck3Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck3Hist.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit2 and bcamGlobalInWaitLimit3 for meanwhile closed applications. ')
bcamTsapTabInWaitBuck4Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck4Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck4Hist.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit3 and bcamGlobalInWaitLimit4 for meanwhile closed applications. ')
bcamTsapTabInWaitBuck5Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck5Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck5Hist.setDescription(' The number of times the input wait time was longer than bcamGlobalInWaitLimit4 for meanwhile closed applications. ')
bcamTsapTabReactBuck1Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck1Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck1Hist.setDescription(' The number of times the application reaction time was in the time interval between zero and bcamGlobalReactLimit1 for meanwhile closed applications. ')
bcamTsapTabReactBuck2Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck2Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck2Hist.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit1 and bcamGlobalReactLimit2 for meanwhile closed applications. ')
bcamTsapTabReactBuck3Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck3Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck3Hist.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit2 and bcamGlobalReactLimit3 for meanwhile closed applications. ')
bcamTsapTabReactBuck4Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck4Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck4Hist.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit3 and bcamGlobalReactLimit4 for meanwhile closed applications. ')
bcamTsapTabReactBuck5Hist = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck5Hist.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck5Hist.setDescription(' The number of times the application reaction time was longer than bcamGlobalReactLimit4 for meanwhile closed applications. ')
bcamTsapTabInWaitBuck1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck1.setDescription(' The number of times the input wait time was in the time interval between zero and bcamGlobalInWaitLimit1 for opened applications. ')
bcamTsapTabInWaitBuck2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck2.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit1 and bcamGlobalInWaitLimit2 for opened applications. ')
bcamTsapTabInWaitBuck3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck3.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit2 and bcamGlobalInWaitLimit3 for opened applications. ')
bcamTsapTabInWaitBuck4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck4.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit3 and bcamGlobalInWaitLimit4 for opened applications. ')
bcamTsapTabInWaitBuck5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInWaitBuck5.setDescription(' The number of times the input wait time was longer than bcamGlobalInWaitLimit4 for opened applications. ')
bcamTsapTabReactBuck1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck1.setDescription(' The number of times the application reaction time was in the time interval between zero and bcamGlobalReactLimit1 for opened applications. ')
bcamTsapTabReactBuck2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck2.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit1 and bcamGlobalReactLimit2 for opened applications. ')
bcamTsapTabReactBuck3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck3.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit2 and bcamGlobalReactLimit3 for opened applications. ')
bcamTsapTabReactBuck4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck4.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit3 and bcamGlobalReactLimit4 for opened applications. ')
bcamTsapTabReactBuck5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabReactBuck5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabReactBuck5.setDescription(' The number of times the application reaction time was longer than bcamGlobalReactLimit4 for opened applications. ')
bcamTsapTabTsduSendHists = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabTsduSendHists.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabTsduSendHists.setDescription(' The number of packets to send given to BCAM at the TSAP by this application for meanwhile closed connections. ')
bcamTsapTabByteSendHists = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabByteSendHists.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabByteSendHists.setDescription(' The number of bytes to send given to BCAM at the TSAP by this application for meanwhile closed connections. ')
bcamTsapTabTsduReceivedHists = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabTsduReceivedHists.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabTsduReceivedHists.setDescription(' The number of packets received at the TSAP by this application for meanwhile closed connections. ')
bcamTsapTabByteReceivedHists = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabByteReceivedHists.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabByteReceivedHists.setDescription(' The number of bytes received at the TSAP by this application for meanwhile closed connections. ')
bcamTsapTabSendCallOverMaxHists = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabSendCallOverMaxHists.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabSendCallOverMaxHists.setDescription(' The number of send calls of this application while BCAM limits have been reached for meanwhile closed connections. ')
bcamTsapTabLetterTimeoutHists = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabLetterTimeoutHists.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabLetterTimeoutHists.setDescription(' The number of packets that were deleted without being delivered to the application due to timeout of the letter timer for meanwhile closed connections. ')
bcamTsapTabFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nea", 1), ("iso", 2), ("streams", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabFunction.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabFunction.setDescription('Interfacefunctionality of TSAP. nea (1) : functionality according proprietary NEA . iso (2) : functionality according ISO IS 8072. streams (3) : functionality according the one defined in the INTERNET. ')
bcamTsapTabCurrConn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 46), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabCurrConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabCurrConn.setDescription('Number of connections of this TSAP not in the connection state closed.')
bcamTsapTabCloseConns = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabCloseConns.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabCloseConns.setDescription('Number of connections of this TSAP that have been opened and are now in the connection state closing or closed.')
bcamTsapTabClessSendBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabClessSendBytes.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabClessSendBytes.setDescription('Number of bytes sent connectionless by this application')
bcamTsapTabClessRecvBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabClessRecvBytes.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabClessRecvBytes.setDescription('Number of bytes received connectionless by this application')
bcamTsapTabClessSendCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabClessSendCalls.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabClessSendCalls.setDescription('Number of successful send calls for connectionless data')
bcamTsapTabClessRecvCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabClessRecvCalls.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabClessRecvCalls.setDescription('Number of successful receive calls for connectionless data')
bcamTsapTabOutbufTsdu = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 52), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabOutbufTsdu.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabOutbufTsdu.setDescription(' The number of packets to send connectionoriented that are currently buffered by BCAM for this application. ')
bcamTsapTabOutbufByte = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 53), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabOutbufByte.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabOutbufByte.setDescription(' The number of bytes to send connectionoriented that are currently buffered by BCAM for this application. ')
bcamTsapTabInbufTsdu = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 54), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInbufTsdu.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInbufTsdu.setDescription(' The number of packets to receive connectionoriented that are currently buffered by BCAM for this application. ')
bcamTsapTabInbufByte = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 55), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInbufByte.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInbufByte.setDescription(' The number of bytes to receive connectionoriented that are currently buffered by BCAM for this application. ')
bcamTsapTabOutbufTsduCless = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 56), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabOutbufTsduCless.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabOutbufTsduCless.setDescription(' The number of packets to send connectionless that are currently buffered by BCAM for this application. ')
bcamTsapTabOutbufByteCless = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 57), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabOutbufByteCless.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabOutbufByteCless.setDescription(' The number of bytes to send connectionless that are currently buffered by BCAM for this application. ')
bcamTsapTabInbufTsduCless = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 58), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInbufTsduCless.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInbufTsduCless.setDescription(' The number of packets to receive connectionless that are currently buffered by BCAM for this application. ')
bcamTsapTabInbufByteCless = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 59), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabInbufByteCless.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabInbufByteCless.setDescription(' The number of bytes to receive connectionless that are currently buffered by BCAM for this application. ')
bcamTsapTabClessTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 5, 22, 1, 60), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamTsapTabClessTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: bcamTsapTabClessTimeout.setDescription(' The number of packets discarded because the datagram timer elapsed. ')
bcamCepCurrent = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepCurrent.setDescription('The number of connections in the state open. ')
bcamCepClosed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepClosed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepClosed.setDescription('The number of connections that had reached the state open and are now in the state closing or closed. ')
bcamCepNotClosed = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepNotClosed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepNotClosed.setDescription('The number of connections in the states opening, open, or closing. ')
bcamCepRerouting = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepRerouting.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepRerouting.setDescription('The number of times an alternative route has been tried. ')
bcamCepActiveTrials = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepActiveTrials.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepActiveTrials.setDescription(' The number of active trials of connection establishment. ')
bcamCepActiveTrialFailures = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepActiveTrialFailures.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepActiveTrialFailures.setDescription(' The number of active trials of connection establishment that failed. ')
bcamCepPassiveTrials = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepPassiveTrials.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepPassiveTrials.setDescription(' The number of passive trials of connection establishment. ')
bcamCepPassiveTrialFailures = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepPassiveTrialFailures.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepPassiveTrialFailures.setDescription(' The number of passive trials of connection establishment that failed. ')
bcamCepNumTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepNumTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepNumTable.setDescription('The number of table entries. ')
bcamCepTab = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10), )
if mibBuilder.loadTexts: bcamCepTab.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTab.setDescription('Table of all active connections')
bcamCepTabEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1), ).setIndexNames((0, "BCAM-MIB", "bcamCepTabConnectionNumbers"))
if mibBuilder.loadTexts: bcamCepTabEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabEntry.setDescription('Information about a connection')
bcamCepTabProtocolClass = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("local", 1), ("nea", 2), ("iso", 3), ("tcp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabProtocolClass.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabProtocolClass.setDescription(' The protocol class used for this connection. local (1) : the partner application resides in the same host. nea (2) : the proprietary NEA protocol is used as transport protocol. iso (3) : the ISO protocol is used as transport protocol. tcp (4) : the TCP protocol is used as transport protocol.')
bcamCepTabConnectionNumbers = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabConnectionNumbers.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabConnectionNumbers.setDescription(' The definite identifier for this connection. Even if a connection is closed and then reopened between the same applications, the identfier will get a new value. ')
bcamCepTabDisconCommand = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabDisconCommand.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabDisconCommand.setDescription(' First word that contains the reason for the closing of the connection (for diagnostic purposes only). ')
bcamCepTabDisconInfoWord = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabDisconInfoWord.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabDisconInfoWord.setDescription(' Second word that contains the reason for the closing of the connection (for diagnostic purposes only). ')
bcamCepTabTsduSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabTsduSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabTsduSends.setDescription(' The number of packets to send given to BCAM at the TSAP for this connection. ')
bcamCepTabByteSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabByteSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabByteSends.setDescription(' The number of bytes to send given to BCAM at the TSAP for this connection. ')
bcamCepTabTsduReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabTsduReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabTsduReceiveds.setDescription(' The number of packets received by BCAM for this connection. ')
bcamCepTabByteReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabByteReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabByteReceiveds.setDescription(' The number of bytes received by BCAM for this connection. ')
bcamCepTabSendCallOverMaxs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabSendCallOverMaxs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabSendCallOverMaxs.setDescription(' The number of send calls at the TSAP for this connection when connection specific limits have been reached. ')
bcamCepTabLetterTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabLetterTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabLetterTimeouts.setDescription(' The number of packets that have been deleted without delivering to the application due to the timeout of the letter timer. ')
bcamCepTabOutbufTsduSend = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutbufTsduSend.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutbufTsduSend.setDescription(' The number of packets to send that are currently buffered by BCAM for this connection. ')
bcamCepTabOutbufByteSend = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 12), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutbufByteSend.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutbufByteSend.setDescription(' The number of bytes to send that are currently buffered by BCAM for this connection. ')
bcamCepTabOutbufMaxTsduSend = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutbufMaxTsduSend.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutbufMaxTsduSend.setDescription(' The maximum number of packets to send that will be buffered by BCAM for this connection. ')
bcamCepTabOutbufMaxByteSend = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutbufMaxByteSend.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutbufMaxByteSend.setDescription(' The maximum number of bytes to send that will be buffered by BCAM for this connection. ')
bcamCepTabInbufTsdu = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 15), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInbufTsdu.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInbufTsdu.setDescription(' The number of packets to receive that are currently buffered by BCAM for this connection. ')
bcamCepTabInbufByte = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInbufByte.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInbufByte.setDescription(' The number of bytes to receive that are currently buffered by BCAM for this connection. ')
bcamCepTabInbufMaxTsduReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInbufMaxTsduReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInbufMaxTsduReceived.setDescription(' The maximum number of packets to receive that will be buffered by BCAM for this connection. ')
bcamCepTabInbufMaxByteReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 18), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInbufMaxByteReceived.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInbufMaxByteReceived.setDescription(' The maximum number of bytes to receive that will be buffered by BCAM for this connection. ')
bcamCepTabPacketsDataSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabPacketsDataSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabPacketsDataSends.setDescription(' The number of packets sent by BCAM that contained at least one byte of user data. ')
bcamCepTabPacketsWindowSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabPacketsWindowSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabPacketsWindowSends.setDescription(' The number of packets sent by BCAM that contained only window information. ')
bcamCepTabPacketsDataReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabPacketsDataReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabPacketsDataReceiveds.setDescription(' The number of packets received by BCAM that contained at least one byte of user data. ')
bcamCepTabPacketsWindowReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabPacketsWindowReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabPacketsWindowReceiveds.setDescription(' The number of packets received by BCAM that contained only window information. ')
bcamCepTabGlobalZeroWindowSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabGlobalZeroWindowSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabGlobalZeroWindowSends.setDescription(' The number of packets sent by BCAM that contained zero window due to global shortage of ressources. ')
bcamCepTabConnectionZeroWindowSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabConnectionZeroWindowSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabConnectionZeroWindowSends.setDescription(' The number of packets sent by BCAM that contained zero window due to shortage of connection specific ressources. ')
bcamCepTabZeroWindowReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabZeroWindowReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabZeroWindowReceiveds.setDescription(' The number of packets received that contained zero window. ')
bcamCepTabRoundTripTime = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabRoundTripTime.setDescription(' The round trip time for this connection in milliseconds. ')
bcamCepTabRetransmitPacketsSends = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabRetransmitPacketsSends.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabRetransmitPacketsSends.setDescription(' The number of packets sent that contain at least one byte of data that have been already sent. ')
bcamCepTabDetectedGapsReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabDetectedGapsReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabDetectedGapsReceiveds.setDescription(' The number of packets received where there is a gap between the highest already received byte and the lowest byte in the packet. ')
bcamCepTabDuplicatePacketsReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabDuplicatePacketsReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabDuplicatePacketsReceiveds.setDescription(' The number of packets received that contain at least one byte of user data which has already been received. ')
bcamCepTabErrorPacketsReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabErrorPacketsReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabErrorPacketsReceiveds.setDescription(' The number of packets received that were discarded because of weak protocol violations.')
bcamCepTabConnectionState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("opening", 1), ("open", 2), ("closing", 3), ("closed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabConnectionState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabConnectionState.setDescription(' The current state of the connection. opening (1) : the connection establishment is in progress. open (2) : the connection is ready for data transfer. closing (3) : the connection is terminating. closed (4) : the connection has been closed.')
bcamCepTabApplicationNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabApplicationNumber.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabApplicationNumber.setDescription(' The definite identifier of the local application the connection belongs to. ')
bcamCepTabRouteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabRouteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabRouteNumber.setDescription(' The definite identifier of the route that is used for the connection. ')
bcamCepTabDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 34), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabDuration.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabDuration.setDescription(' The time the connection was in the state open. ')
bcamCepTabDateConnectionEstablishment = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 35), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabDateConnectionEstablishment.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabDateConnectionEstablishment.setDescription(' The date of the connection establishment. Format: YYYYMMDD ')
bcamCepTabTimeConnectionEstablishment = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 36), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabTimeConnectionEstablishment.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabTimeConnectionEstablishment.setDescription(' The time of the connection establishment. Format: HHMMSS ')
bcamCepTabTypPartnerName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("neaName", 1), ("socketName", 2), ("isoName", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabTypPartnerName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabTypPartnerName.setDescription(' The type of name used for the partner application. neaName (1) : the name consists of 8 byte application name and 8 byte name of endsystem. socketName (2) : the name consists of up to 32 byte socket name. isoName (3) : the name consists of up to 78 byte iso name. ')
bcamCepTabPartnerName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 38), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 78))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabPartnerName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabPartnerName.setDescription(' The name of the partner application according the type of the name (bcamCepTabTypPartnerName). ')
bcamCepTabLocalName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 39), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 78))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabLocalName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabLocalName.setDescription(' The name of the local application according the type of the name (bcamCepTabTypPartnerName). ')
bcamCepTabTypeL4Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("portNumber", 1), ("neaTsel", 2), ("osiTsel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabTypeL4Addr.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabTypeL4Addr.setDescription(' The type of layer 4 addresses used for this connection. portNumber (1) : the address consists of 2 byte port number. neaTsel (2) : the address consists of 8 byte NEA transport selector. osiTsel (3) : the address consists of up to 33 byte OSI transport selector.')
bcamCepTabL4AddrPartner = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 41), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabL4AddrPartner.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabL4AddrPartner.setDescription(' The layer 4 address of the partner application according the type of the address (bcamCepTabTypeL4Addr).')
bcamCepTabL4AddrLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 42), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabL4AddrLocal.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabL4AddrLocal.setDescription(' The layer 4 address of the partner application according the type of the address (bcamCepTabTypeL4Addr).')
bcamCepTabPartnerEndsystem = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabPartnerEndsystem.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabPartnerEndsystem.setDescription(' The name of the host where the partner application resides. ')
bcamCepTabInWaitBuck1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInWaitBuck1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInWaitBuck1.setDescription(' The number of times the input wait time was in the time interval between zero and bcamGlobalInWaitLimit1. ')
bcamCepTabInWaitBuck2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 45), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInWaitBuck2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInWaitBuck2.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit1 and bcamGlobalInWaitLimit2. ')
bcamCepTabInWaitBuck3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 46), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInWaitBuck3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInWaitBuck3.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit2 and bcamGlobalInWaitLimit3. ')
bcamCepTabInWaitBuck4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 47), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInWaitBuck4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInWaitBuck4.setDescription(' The number of times the input wait time was in the time interval between bcamGlobalInWaitLimit3 and bcamGlobalInWaitLimit4. ')
bcamCepTabInWaitBuck5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 48), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInWaitBuck5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInWaitBuck5.setDescription(' The number of times the input wait time was longer than bcamGlobalInWaitLimit4. ')
bcamCepTabReactBuck1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 49), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabReactBuck1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabReactBuck1.setDescription(' The number of times the application reaction time was in the time interval between zero and bcamGlobalReactLimit1. ')
bcamCepTabReactBuck2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 50), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabReactBuck2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabReactBuck2.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit1 and bcamGlobalReactLimit2. ')
bcamCepTabReactBuck3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 51), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabReactBuck3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabReactBuck3.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit2 and bcamGlobalReactLimit3 ')
bcamCepTabReactBuck4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 52), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabReactBuck4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabReactBuck4.setDescription(' The number of times the application reaction time was in the time interval between bcamGlobalReactLimit3 and bcamGlobalReactLimit4. ')
bcamCepTabReactBuck5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabReactBuck5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabReactBuck5.setDescription(' The number of times the application reaction time was longer than bcamGlobalReactLimit4. ')
bcamCepTabOutProcBuck1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutProcBuck1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutProcBuck1.setDescription(' The number of times the outbound processing time was in the time interval between zero and bcamGlobalOutProcLimit1. ')
bcamCepTabOutProcBuck2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutProcBuck2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutProcBuck2.setDescription(' The number of times the outbound processing time was in the time interval between bcamGlobalOutProcLimit1 and bcamGlobalOutProcLimit2. ')
bcamCepTabOutProcBuck3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutProcBuck3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutProcBuck3.setDescription(' The number of times the outbound processing time was in the time interval between bcamGlobalOutProcLimit2 and bcamGlobalOutProcLimit3. ')
bcamCepTabOutProcBuck4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutProcBuck4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutProcBuck4.setDescription(' The number of times the outbound processing time was in the time interval between bcamGlobalOutProcLimit3 and bcamGlobalOutProcLimit4. ')
bcamCepTabOutProcBuck5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabOutProcBuck5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabOutProcBuck5.setDescription(' The number of times the outbound processing time was longer than bcamGlobalOutProcLimit4. ')
bcamCepTabInProcBuck1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 59), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInProcBuck1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInProcBuck1.setDescription(' The number of times the inbound processing time was in the time interval between zero and bcamGlobalInProcLimit1. ')
bcamCepTabInProcBuck2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInProcBuck2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInProcBuck2.setDescription(' The number of times the inbound processing time was in the time interval between bcamGlobalInProcLimit1 and bcamGlobalInProcLimit2. ')
bcamCepTabInProcBuck3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 61), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInProcBuck3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInProcBuck3.setDescription(' The number of times the inbound processing time was in the time interval between bcamGlobalInProcLimit2 and bcamGlobalInProcLimit3. ')
bcamCepTabInProcBuck4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 62), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInProcBuck4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInProcBuck4.setDescription(' The number of times the inbound processing time was in the time interval between bcamGlobalInProcLimit3 and bcamGlobalInProcLimit4. ')
bcamCepTabInProcBuck5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 63), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabInProcBuck5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabInProcBuck5.setDescription(' The number of times the inbound processing time was longer than bcamGlobalInProcLimit4. ')
bcamCepTabMaxSendLen = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 64), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabMaxSendLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabMaxSendLen.setDescription(' The maximum number of bytes per send call that can be given to BCAM at the interface. ')
bcamCepTabMaxIndLen = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 65), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabMaxIndLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabMaxIndLen.setDescription(' The maximum number of bytes BCAM will announce per data indication. ')
bcamCepTabLocalEndsystem = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 6, 10, 1, 66), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamCepTabLocalEndsystem.setStatus('mandatory')
if mibBuilder.loadTexts: bcamCepTabLocalEndsystem.setDescription(' The name of the host where the local application resides. ')
bcamRouteNumTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteNumTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteNumTable.setDescription('The number of all routes known by BCAM')
bcamRouteActive = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteActive.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteActive.setDescription('The number of active routes')
bcamRouteArpDefault = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("quiet", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteArpDefault.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteArpDefault.setDescription(' The ARP state to use as default when a route of type node (bcamRouteTabTyp) is activated. Several bits may be set simultaneous. off (1) : No usage of ARP. on (2) : periodic usage of ARP. quiet (4) : ARP will only be used if no connection oriented data were transferred during the last ARP period.')
bcamRouteRoutingReqIp = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteRoutingReqIp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteRoutingReqIp.setDescription(' The number of forwarding requests for IP ')
bcamRouteRoutingReqIso = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteRoutingReqIso.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteRoutingReqIso.setDescription(' The number of forwarding requests for ISO ')
bcamRouteRoutingReqNea = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteRoutingReqNea.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteRoutingReqNea.setDescription(' The number of forwarding requests for NEA ')
bcamRouteSuccRoutingReqIp = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteSuccRoutingReqIp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteSuccRoutingReqIp.setDescription(' The number of successful forwarding requests for IP ')
bcamRouteSuccRoutingReqIso = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteSuccRoutingReqIso.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteSuccRoutingReqIso.setDescription(' The number of successful forwarding requests for ISO ')
bcamRouteSuccRoutingReqNea = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteSuccRoutingReqNea.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteSuccRoutingReqNea.setDescription(' The number of successful forwarding requests for NEA ')
bcamRouteTab = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10), )
if mibBuilder.loadTexts: bcamRouteTab.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTab.setDescription('Table of all Routes')
bcamRouteTabEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1), ).setIndexNames((0, "BCAM-MIB", "bcamRouteTabNumbers"))
if mibBuilder.loadTexts: bcamRouteTabEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabEntry.setDescription('Information about a route')
bcamRouteTabNumbers = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNumbers.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNumbers.setDescription(' The definite identifier for this route. ')
bcamRouteTabName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabName.setDescription(' The name of this route. ')
bcamRouteTabNumNeaConn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 3), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNumNeaConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNumNeaConn.setDescription(' The current number of NEA connections using this route. ')
bcamRouteTabNumIsoConn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 4), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNumIsoConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNumIsoConn.setDescription(' The current number of ISO and TCP connections using this route. ')
bcamRouteTabMaxNeaConn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 5), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMaxNeaConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMaxNeaConn.setDescription(' The maximum number of NEA connections allowed for this route. ')
bcamRouteTabMaxIsoConn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 6), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMaxIsoConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMaxIsoConn.setDescription(' The maximum number of ISO and TCP connections allowed for this route. ')
bcamRouteTabBadNeaElems = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabBadNeaElems.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabBadNeaElems.setDescription(' The number of erroneous NEA fragments received on this route. ')
bcamRouteTabBadIsoElems = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabBadIsoElems.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabBadIsoElems.setDescription(' The number of erroneous ISO and TCP fragments received on this route. ')
bcamRouteTabMaxL4Conn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMaxL4Conn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMaxL4Conn.setDescription(' The maximum number of layer 4 connections per layer 3 connection for this route. ')
bcamRouteTabMaxUnackTpdu = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMaxUnackTpdu.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMaxUnackTpdu.setDescription(' The maximum number of unacknowledged TPDUs per layer 3 connection that may be sent over this route. ')
bcamRouteTabRouteNetTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("gatewayRouter", 1), ("neaRouter", 2), ("intfIpRouter", 4), ("int0Router", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabRouteNetTyp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabRouteNetTyp.setDescription(' Describes whether there are other intermediate routes necessary to be known by BCAM to reach the system described by this route. gatewayRouter (1) : the system is reached via a gateway route. neaRouter (2) : the system is reached via a NEA router route. intfIpRouter (4) : the system is reached via an INTF or IP router route. int0Router (8) : the system is reached via an INT0 router route. Several bits may be set simultaneous.')
bcamRouteTabNumberIsoIpRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNumberIsoIpRouter.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNumberIsoIpRouter.setDescription(' The number of the route which describes the INT0, INTF or IP router used to reach the system described by this route. ')
bcamRouteTabNumberNeaRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNumberNeaRouter.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNumberNeaRouter.setDescription(' The number of the route which describes the NEA router used to reach the system described by this route. ')
bcamRouteTabNumberGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNumberGateway.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNumberGateway.setDescription(' The number of the route which describes the gateway used to reach the system described by this route. ')
bcamRouteTabFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("onlyServerAccess", 1), ("transportRoute", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabFunction.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabFunction.setDescription(' Describes the function of the route: onlyServerAccess (1) : the route is used for access to a specified server port only. transportRoute (2) : the route leads to an endsystem Several bits may be set simultaneous.')
bcamRouteTabProcNetTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("gatewayProc", 1), ("neaProc", 2), ("isoIpProc", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabProcNetTyp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabProcNetTyp.setDescription(' Describes whether there are other intermediate systems necessary to be known by BCAM to reach the system described by this route. gatewayProc (1) : an intermediate gateway system is used. neaProc (2) : an intermediate NEA system is used. isoIpProc (4) : an intermediate ISO or IP system is used. Several bits may be set simultaneous.')
bcamRouteTabMaxTsduLen = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 17), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMaxTsduLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMaxTsduLen.setDescription(' The maximum length of packets that can be sent over this route. ')
bcamRouteTabNameEndsystem = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 18), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNameEndsystem.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNameEndsystem.setDescription(' The name of the remote system described by this route. ')
bcamRouteTabIso4WindowTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 19), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabIso4WindowTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabIso4WindowTimer.setDescription(' The current value of the window timer for this route in seconds. ')
bcamRouteTabIso4RetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabIso4RetransTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabIso4RetransTimer.setDescription(' The current value of the retransmit timer for this route in seconds. ')
bcamRouteTabAckTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 21), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabAckTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabAckTimer.setDescription(' The current value of the acknowledgement timer for this route in seconds. ')
bcamRouteTabErrorRecovTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 22), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabErrorRecovTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabErrorRecovTimer.setDescription(' The current value of the error recovery timer for this route in seconds. ')
bcamRouteTabRejectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 23), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabRejectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabRejectTimer.setDescription(' The current value of the reject timer for this route in seconds. ')
bcamRouteTabExpedRetransTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 24), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabExpedRetransTimer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabExpedRetransTimer.setDescription(' The current value of the expedited retransmit timer for this route in seconds. ')
bcamRouteTabNameGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 25), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNameGateway.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNameGateway.setDescription(' The name of the intermediate system where protocol transitions, if necessary for this route, are done. ')
bcamRouteTabNameX25Station = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 26), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNameX25Station.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNameX25Station.setDescription(' The name of the station which performs the X25 net access. ')
bcamRouteTabL3InputProfil = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("nea", 1), ("int0", 2), ("intf", 3), ("gateway", 4), ("ip", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabL3InputProfil.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabL3InputProfil.setDescription(' The input profile used on the network layer. nea (1) : proprietary NEAN protocol. int0 (2) : protocol according ISO 8473 (inactive network layer). intf (3) : protocol according ISO 8473. gateway (4) : no network layer protocol used. ip (5) : proctocol according RFC 791.')
bcamRouteTabTransState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("waitForTransferInit", 1), ("waitForReadyToTransfer", 2), ("ready", 3), ("notReady", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabTransState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabTransState.setDescription(' The current transfer state of this route as viewed by transport layer. notReady (4) : no packets can be sent. waitForTransferInit (1) : route may be initialised. waitForReadyToTransfer (2) : address resolution running ready (3) : packets may be sent ')
bcamRouteTabOption = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("delayedAckAllowed", 1), ("optimalSegmentSizeOn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabOption.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabOption.setDescription(' The currently valid options for this route (only valid for TCP). delayedAckAllowed (1) : do not try do minimize the number of outgoing acknowledgements optimalSegmentSizeOn (2) : do not try do minimize the number of incoming acknowledgements Several bits may be set simultaneous.')
bcamRouteTabTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("direct", 1), ("remote", 2), ("node", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabTyp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabTyp.setDescription(' Describes how the remote system described by this route is reached. direct (1) : the remote system is connected directly to the local system (e.g via DAST). remote (2) : the remote system is reached via at least one router. node (3) : the remote system is connected directly to ethernet or fddi node. ')
bcamRouteTabUsage = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("gatewayRoute", 1), ("intfIpRouter", 2), ("neaRouter", 4), ("int0Router", 8), ("noIntermediate", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabUsage.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabUsage.setDescription(' Describes whether this route describes an intermediate system. noIntermediate (16) : no intermediate route gatewayRouter (1) : route describes an intermediate system used as gateway intfIpRouter (2) : route describes an INTF or an IP router neaRouter (4) : route describes a NEA router int0Router (8) : route describes an INT0 router Several bits may be set simultaneous.')
bcamRouteTabL3Subprofile = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("rfc1042", 1), ("netConnLess", 2), ("neaNetConn", 4), ("neattNetConn", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabL3Subprofile.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabL3Subprofile.setDescription(' rfc1042 (1) : a layer 3 subprotocol according RFC1042 is used on this route. netConnLess (2) : a connectionless layer 3 protocol is used on this route. neaNetConn (4) : a NEA net connection is used on this route. neattNetConn (8) : a NEATT net connection is used on this route. Several bits may be set simultaneous.')
bcamRouteTabCommandState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("included", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabCommandState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabCommandState.setDescription(' The current state of this route caused by route specific commands. included (1) : a BCIN command was given successfully for this route. active (2) : a BCACT command was given successfully for this route. Several bits may be set simultaneous.')
bcamRouteTabChangeState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("dynamic", 1), ("defByProtocol", 2), ("switchByProtocol", 4), ("changed", 8), ("generated", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabChangeState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabChangeState.setDescription(' Describes how the route was defined or modified. generated (16) : the route has been defined by KOGS and not been modified. dynamic (1) : the route was created dynamically by a BCIN command. defByProtocol (2) : the route was defined by routing protocol. switchByProtocol (4) : the route has been switched by routing protocol. changed (8) : the route has been modified. Several bits may be set simultaneous.')
bcamRouteTabIso9542 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("eshReceived", 1), ("ishReceived", 2), ("iso8473QueryReceived", 4), ("refreshRequired", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabIso9542.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabIso9542.setDescription(' Describes the ISO9542 processing, if this route is an INTF route eshReceived (1) : endsystem hello received ishReceived (2) : intermediate system hello received. iso8473QueryReceived (4) : ISO 8473 query configuration request received. refreshRequired (8) : refreshing of routing information is required. Several bits may be set simultaneous.')
bcamRouteTabMaxNetLength = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ethernet", 1), ("fddi", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMaxNetLength.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMaxNetLength.setDescription(' The maximum length of a packet used on layer 3 (only valid for FDDI routes). ethernet (1) : the length will be limited to the maximum length for ethernet. fddi (2) : the length will be limited to the maximum length for FDDI. ')
bcamRouteTabState2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("testing", 1), ("working", 2), ("waitAddrResolution", 4), ("lifeSupervisionFailed", 8), ("silent", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabState2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabState2.setDescription(' Describes the state of the route viewed by routing protocols. silent (16) : route not yet or no more used. testing (1) : delivery problems on route detected. working (2) : route working. waitAddressResolution (4) : waiting for address resolution. lifetimeSupervsionFailed (8) : lifetime supervision failed. Several bits may be set simultaneous.')
bcamRouteTabDeactReason = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 38), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("flush", 1), ("supposedDown", 2), ("noArpReply", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabDeactReason.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabDeactReason.setDescription(' The reason for the deactivation of the route. flush (1) : an ISO9542 protocol element that requests the invalidation of the routing information has been received. supposedDown (2) : the route is supposed to be down (derived from state of TCP protocol machine or ICMP message received). noArpReply (4) : no arp reply has been received. Several bits may be set simultaneous.')
bcamRouteTabSwitchType = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16))).clone(namedValues=NamedValues(("localRemote", 1), ("remoteLocal", 2), ("remoteRemote", 4), ("lsapChanged", 8), ("lanAddrChanged", 16)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabSwitchType.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabSwitchType.setDescription(' The type of the last performed route switching. localRemote (1) : the route has been changed from local to remote route. remoteLocal (2) : the route has been changed from remote to local route. remoteRemote (4) : the route has been changed from remote to remote route. lsapChanged (8) : the route has been switched to another LSAPCB. lanAddrChanged (16) : the lan address of the route has been changed. Several bits may be set simultaneous.')
bcamRouteTabReasonCreation = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 40), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("incomingData", 1), ("outgoingData", 2), ("routingProtocol", 4), ("routingData", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabReasonCreation.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabReasonCreation.setDescription(' Describes the reason for the automatic creation of the route. incomingData (1) : the route has been created because of incoming data. outgoingData (2) : the route has been created because of outgoing data. routingProtocol (4) : the route has been created because of incoming routing protocol. routingData (8) : the route has been created because of data to be routed. Several bits may be set simultaneous.')
bcamRouteTabOrigLanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 41), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabOrigLanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabOrigLanAddress.setDescription(' The MAC address (if known) of the remote endsystem or the first intermediate system of this route as used when the route has been created. ')
bcamRouteTabLanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 42), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabLanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabLanAddress.setDescription(' The current MAC address (if known) of the remote endsystem or the first intermediate system of this route. ')
bcamRouteTabTypAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("nea", 1), ("intf", 2), ("streams", 3), ("int0", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabTypAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabTypAddress.setDescription('The type of address used for this route. nea (1) : 2 byte (processor number and region number) intf (2) : up to 20 byte full internet address streams (3) : 4 byte IP address int0 (4) : 6 byte MAC address')
bcamRouteTabLocalAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 44), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabLocalAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabLocalAddr.setDescription('The layer 3 address of the local system described by this route according to bcamRouteTabTypAddress.')
bcamRouteTabRemoteAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 45), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabRemoteAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabRemoteAddr.setDescription('The layer 3 address of the remote system described by this route according to bcamRouteTabTypAddress.')
bcamRouteTabOutPacketsDatas = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabOutPacketsDatas.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabOutPacketsDatas.setDescription(' The number of packets sent over this route that contained at least one byte of user data. ')
bcamRouteTabOutPacketsFlowControls = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabOutPacketsFlowControls.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabOutPacketsFlowControls.setDescription(' The number of packets sent over this route that contained only flow control information. ')
bcamRouteTabInPacketsDatas = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabInPacketsDatas.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabInPacketsDatas.setDescription(' The number of packets received on this route that contained at least one byte of user data. ')
bcamRouteTabInPacketsFlowControls = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabInPacketsFlowControls.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabInPacketsFlowControls.setDescription(' The number of packets received on this route that contained only flow control information. ')
bcamRouteTabOutRetransPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 50), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabOutRetransPackets.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabOutRetransPackets.setDescription(' The number of packets sent over this route that contained at least one byte of user data that were already sent. ')
bcamRouteTabInDetectedGaps = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabInDetectedGaps.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabInDetectedGaps.setDescription(' The number of packets received where there was a gap between the highest already received byte and the lowest byte in the packet. ')
bcamRouteTabInDuplicatedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 52), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabInDuplicatedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabInDuplicatedPackets.setDescription(' The number of packets received that contained at least one byte of user data that has already been received ')
bcamRouteTabInIncorrectPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 53), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabInIncorrectPackets.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabInIncorrectPackets.setDescription(' The number of erroneous packets received on this route. ')
bcamRouteTabRoundTripTimeClosed = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 54), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabRoundTripTimeClosed.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabRoundTripTimeClosed.setDescription(' The average round trip time on this route for meanwhile closed connections. ')
bcamRouteTabRoundTripTimeCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabRoundTripTimeCurrent.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabRoundTripTimeCurrent.setDescription(' The average round trip time on this route for currently open connections. ')
bcamRouteTabArpReqSend = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 56), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabArpReqSend.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabArpReqSend.setDescription('The number of ARP requests sent for this route.')
bcamRouteTabArpRepSend = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 57), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabArpRepSend.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabArpRepSend.setDescription('The number of ARP replies sent for this route.')
bcamRouteTabArpReqRec = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 58), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabArpReqRec.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabArpReqRec.setDescription('The number of ARP requests received for this route.')
bcamRouteTabArpRepRec = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 59), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabArpRepRec.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabArpRepRec.setDescription('The number of ARP replies received for this route.')
bcamRouteTabIcmpReq = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 60), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabIcmpReq.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabIcmpReq.setDescription('The number of ICMP ECHO requests sent for this route.')
bcamRouteTabIcmpReply = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 61), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabIcmpReply.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabIcmpReply.setDescription('The number of ICMP ECHO replies received for this route.')
bcamRouteTabIcmpRedirect = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 62), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabIcmpRedirect.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabIcmpRedirect.setDescription('The number of ICMP redirects received for this route.')
bcamRouteTabSwitched = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 63), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabSwitched.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabSwitched.setDescription('The number of route switchings performed for this route.')
bcamRouteTabDown = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 64), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabDown.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabDown.setDescription('The number of times the state of the route has changed to not working.')
bcamRouteTabOspfHello = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 65), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabOspfHello.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabOspfHello.setDescription('The number of OSPF HELLOs received for this route.')
bcamRouteTabPacketNoConn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 66), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabPacketNoConn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabPacketNoConn.setDescription('The number of packets received on this route that could not be assigned to a connection.')
bcamRouteTabPacketInternDiscon = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 67), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabPacketInternDiscon.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabPacketInternDiscon.setDescription('The number of packets received on this route that resulted in an abortion of a connection.')
bcamRouteTabPacketBadProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 68), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabPacketBadProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabPacketBadProtocol.setDescription('The number of packets received on this route that were invalid.')
bcamRouteTabConnReqOut = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 69), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabConnReqOut.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabConnReqOut.setDescription('The number of connection requests sent on this route.')
bcamRouteTabConnReqOutAck = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabConnReqOutAck.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabConnReqOutAck.setDescription('The number of connection requests sent on this route that have been acknowledeged by the remote transport system.')
bcamRouteTabConnReqOutRej = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabConnReqOutRej.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabConnReqOutRej.setDescription('The number of connection requests sent on this route that have been rejected by the remote transport system.')
bcamRouteTabConnReqIn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 72), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabConnReqIn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabConnReqIn.setDescription('The number of connection requests received on this route.')
bcamRouteTabConnReqInAck = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 73), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabConnReqInAck.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabConnReqInAck.setDescription('The number of connection requests received on this route that have been acknowledged by the local transport system.')
bcamRouteTabConnReqInRej = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 74), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabConnReqInRej.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabConnReqInRej.setDescription('The number of connection requests received on this route that have been rejected by the local transport system.')
bcamRouteTabDisconnOut = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 75), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabDisconnOut.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabDisconnOut.setDescription('The number of disconnect requests sent.')
bcamRouteTabDisconnOutAck = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 76), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabDisconnOutAck.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabDisconnOutAck.setDescription('The number of disconnect requests sent that have been acknowledged by the remote transport system.')
bcamRouteTabDisconnIn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 77), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabDisconnIn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabDisconnIn.setDescription('The number of disconnect requests received.')
bcamRouteTabDisconnInAck = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 78), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabDisconnInAck.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabDisconnInAck.setDescription('The number of disconnect requests received that have been acknowledged by the local transport system.')
bcamRouteTabNumberLink = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 79), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNumberLink.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNumberLink.setDescription(' The number of the interface that is used for this route. ')
bcamRouteTabArpFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("quiet", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabArpFlag.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabArpFlag.setDescription(' The ARP state of the route. off (1) : no usage of ARP. on (2) : periodic usage of ARP. quiet (4) : ARP will only be used if no connection oriented data were transferred during the last ARP period. Several bits may be set simultaneous.')
bcamRouteTabNsduLen = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 81), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabNsduLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabNsduLen.setDescription(' The length of a network service data unit used on this route ')
bcamRouteTabMinNsduLen = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 82), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMinNsduLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMinNsduLen.setDescription(' The minimum maximal length of a network service data unit used on this route ')
bcamRouteTabMaxNsduLen = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 7, 10, 1, 83), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouteTabMaxNsduLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouteTabMaxNsduLen.setDescription(' The maximum maximal length of a network service data unit used on this route ')
bcamIfNumTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfNumTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfNumTable.setDescription(' ')
bcamIfTab = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2), )
if mibBuilder.loadTexts: bcamIfTab.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTab.setDescription('Table of all interfaces')
bcamIfTabEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1), ).setIndexNames((0, "BCAM-MIB", "bcamIfTabNumbers"))
if mibBuilder.loadTexts: bcamIfTabEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabEntry.setDescription('Information about an interface')
bcamIfTabNumbers = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNumbers.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNumbers.setDescription('A definite identifier for the interface. Serves for references from other tables')
bcamIfTabName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabName.setDescription(' The name of this interface ')
bcamIfTabProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("nealkp", 1), ("nealke", 2), ("nealkeS", 3), ("nealkh", 4), ("llc1", 5), ("sinix", 6), ("fddi", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabProfile.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabProfile.setDescription(' The layer 2 profile of this interface nealkp (1) : proprietary link protocol with permanent dialog. nealke (2) : proprietary event driven link protocol to BS2000 system. nealkeS (3) : proprietary event driven link protocol to System 6000. nealkh (4) : a HDLC balanced link protocol (duplex mode). llc1 (5) : CSMA/CD link protocol. sinix (6) : proprietary link protocol to SINIX port. fddi (7) : FDDI link protocol. ')
bcamIfTabMnemonicWrite = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMnemonicWrite.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMnemonicWrite.setDescription(' The device mnemonic for write operations ')
bcamIfTabMnemonicRead = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMnemonicRead.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMnemonicRead.setDescription(' The device mnemonic for read operations ')
bcamIfTabLanAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 6), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabLanAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabLanAddress.setDescription(' The MAC address (if supported) ')
bcamIfTabConfigUpdate = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("updateForbidden", 1), ("primaryRequested", 2), ("updateAllowed", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabConfigUpdate.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabConfigUpdate.setDescription('Describes whether assigned routes are allowed to be switched from this to an alternative interface. updateAllowed (4) : switching allowed updateForbidden (1) : switching forbidden primaryRequested (2) : switch back of all routes original assigned to this interface requested Several bits may be set simultaneous.')
bcamIfTabMaxLpdu = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1514, 4494, 65535, 65549, 4113, 16392))).clone(namedValues=NamedValues(("ethernet", 1514), ("fddi", 4494), ("atm", 65535), ("nealkh", 65549), ("nealkp", 4113), ("maxReass", 16392)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMaxLpdu.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMaxLpdu.setDescription(' The maximum length of a link protocol data unit depending on bcamIfTabProfile. ethernet (1514) : 1514 bytes fddi (4494) : 4494 bytes atm (65535) : 65535 bytes nealkh (65549) : 65549 bytes nealkp (4113) : 4113 bytes maxReass (16392) : 16392 bytes ')
bcamIfTabL2Monitoring = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabL2Monitoring.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabL2Monitoring.setDescription(' The state of the layer 2 monitoring. on (1) : layer 2 monitoring is running. off (2) : layer 2 monitoring is not running.')
bcamIfTabDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("esconCtc", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabDevice.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabDevice.setDescription(' Describes whether the interface is an ESCON channel to channel adapter. esconCtc (1) : the interface is an ESCON channel to channel adapter. ')
bcamIfTabAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("included", 1), ("active", 2), ("excluded", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabAdminState.setDescription(' The administrative state of this interface requested by commands. excluded (4) : no BCIN command given included (1) : BCIN command given active (2) : BCACT command given ')
bcamIfTabCurrentState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("waitForAct", 1), ("working", 2), ("waitForDeact", 4), ("none", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabCurrentState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabCurrentState.setDescription(' The actual working state of this interface none (8) : interface not working waitForAct (1) : activation in progress working (2) : interface working waitForDeact (4) : deactivation in progress Several bits may be set simultaneous.')
bcamIfTabMode = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 8, 4, 2, 1))).clone(namedValues=NamedValues(("stopModeOn", 16), ("slowPollOn", 8), ("shortWaitOn", 4), ("multicastOn", 2), ("broadcastOn", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMode.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMode.setDescription('Describes the operational parameters of this interface stopModeOn (16) : stop PDN in case of abnormal deactivation slowPollOn (8) : automatic reactivation shall be tried shortWaitOn (4) : stop activation after timeout multicastOn (2) : evaluate multicasts broadcastOn (1) : evaluate broadcasts Several bits may be set simultaneous.')
bcamIfTabPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabPortName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabPortName.setDescription('The port name of this interface ')
bcamIfTabLenTraceOut = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabLenTraceOut.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabLenTraceOut.setDescription(' The maximum length of layer 2 data to be traced in a trace entry for output. ')
bcamIfTabLenTraceIn = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabLenTraceIn.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabLenTraceIn.setDescription(' The maximum length of layer 2 data to be traced in a trace entry for input. ')
bcamIfTabNumRouteSwitchings = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNumRouteSwitchings.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNumRouteSwitchings.setDescription(' The number of route switchings performed for this interface ')
bcamIfTabTimeLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabTimeLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabTimeLastChange.setDescription(' The time interval (in seconds) since the last change of the working state of this interface ')
bcamIfTabMnemonicDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 19), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMnemonicDiag.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMnemonicDiag.setDescription(' The device mnemonic for diagnosis. ')
bcamIfTabNumMulticastAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNumMulticastAddr.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNumMulticastAddr.setDescription(' The number of multicast addresses enabled for this interface. ')
bcamIfTabMulticastAddr1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 21), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr1.setDescription(' multicast address 1 or zero ')
bcamIfTabMulticastAddr2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 22), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr2.setDescription(' multicast address 2 ')
bcamIfTabMulticastAddr3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 23), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr3.setDescription(' multicast address 3 ')
bcamIfTabMulticastAddr4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 24), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr4.setDescription(' multicast address 4 ')
bcamIfTabMulticastAddr5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 25), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr5.setDescription(' multicast address 5 ')
bcamIfTabMulticastAddr6 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 26), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr6.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr6.setDescription(' multicast address 6 ')
bcamIfTabMulticastAddr7 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 27), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr7.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr7.setDescription(' multicast address 7 ')
bcamIfTabMulticastAddr8 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 28), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr8.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr8.setDescription(' multicast address 8 ')
bcamIfTabMulticastAddr9 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 29), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr9.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr9.setDescription(' multicast address 9 ')
bcamIfTabMulticastAddr10 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 30), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastAddr10.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastAddr10.setDescription(' multicast address 10 ')
bcamIfTabNumNeaAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNumNeaAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNumNeaAddress.setDescription(' The number of NEA addresses enabled for this interface. ')
bcamIfTabNeaAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 32), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNeaAddress1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNeaAddress1.setDescription(' NEA address 1 ')
bcamIfTabNeaAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 33), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNeaAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNeaAddress2.setDescription(' NEA address 2 ')
bcamIfTabNeaAddress3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 34), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNeaAddress3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNeaAddress3.setDescription(' NEA address 3 ')
bcamIfTabNeaAddress4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 35), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNeaAddress4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNeaAddress4.setDescription(' NEA address 4 ')
bcamIfTabNeaAddress5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 36), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNeaAddress5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNeaAddress5.setDescription(' NEA address 5 ')
bcamIfTabNeaAddress6 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 37), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNeaAddress6.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNeaAddress6.setDescription(' NEA address 6 ')
bcamIfTabNumIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNumIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNumIpAddress.setDescription(' The number of IP addresses enabled for this interface. ')
bcamIfTabIpAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 39), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIpAddress1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIpAddress1.setDescription(' IP address 1 or zero')
bcamIfTabIpAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 40), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIpAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIpAddress2.setDescription(' IP address 2 ')
bcamIfTabIpAddress3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 41), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIpAddress3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIpAddress3.setDescription(' IP address 3 ')
bcamIfTabIpAddress4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 42), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIpAddress4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIpAddress4.setDescription(' IP address 4 ')
bcamIfTabIpAddress5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 43), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIpAddress5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIpAddress5.setDescription(' IP address 5 ')
bcamIfTabIpAddress6 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 44), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIpAddress6.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIpAddress6.setDescription(' IP address 6 ')
bcamIfTabNumInt0Address = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNumInt0Address.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNumInt0Address.setDescription(' The number of INT0 addresses enabled for this interface. ')
bcamIfTabInt0Address1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 46), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInt0Address1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInt0Address1.setDescription(' INT0 address 1 or zero')
bcamIfTabInt0Address2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 47), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInt0Address2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInt0Address2.setDescription(' INT0 address 2 ')
bcamIfTabInt0Address3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 48), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInt0Address3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInt0Address3.setDescription(' INT0 address 3 ')
bcamIfTabInt0Address4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 49), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInt0Address4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInt0Address4.setDescription(' INT0 address 4 ')
bcamIfTabInt0Address5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 50), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInt0Address5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInt0Address5.setDescription(' INT0 address 5 ')
bcamIfTabInt0Address6 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 51), PhysAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInt0Address6.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInt0Address6.setDescription(' INT0 address 6 ')
bcamIfTabNumIntfAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabNumIntfAddress.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabNumIntfAddress.setDescription(' The number of INTF addresses enabled for this interface. ')
bcamIfTabIntfAddress1 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 53), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIntfAddress1.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIntfAddress1.setDescription(' INTF address 1 ')
bcamIfTabIntfAddress2 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 54), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIntfAddress2.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIntfAddress2.setDescription(' INTF address 2 ')
bcamIfTabIntfAddress3 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 55), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIntfAddress3.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIntfAddress3.setDescription(' INTF address 3 ')
bcamIfTabIntfAddress4 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 56), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIntfAddress4.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIntfAddress4.setDescription(' INTF address 4 ')
bcamIfTabIntfAddress5 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 57), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIntfAddress5.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIntfAddress5.setDescription(' INTF address 5 ')
bcamIfTabIntfAddress6 = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 58), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIntfAddress6.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIntfAddress6.setDescription(' INTF address 6 ')
bcamIfTabBytesOutHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabBytesOutHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabBytesOutHighs.setDescription(' The number of bytes sent (high word, multiply by 4294967296) ')
bcamIfTabBytesOutLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabBytesOutLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabBytesOutLows.setDescription(' The number of bytes sent (low word, add to high word) ')
bcamIfTabBytesInHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 61), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabBytesInHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabBytesInHighs.setDescription(' The number of bytes received (high word, multiply by 4294967296) ')
bcamIfTabBytesInLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 62), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabBytesInLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabBytesInLows.setDescription(' The number of bytes received (low word, add to high word) ')
bcamIfTabIOsOutHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 63), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIOsOutHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIOsOutHighs.setDescription(' The number of IO operations for output (high word, multiply by 4294967296) ')
bcamIfTabIOsOutLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIOsOutLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIOsOutLows.setDescription(' The number of IO operations for output (low word, add to high word) ')
bcamIfTabIOsInHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIOsInHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIOsInHighs.setDescription(' The number of IO operations for input (high word, multiply by 4294967296) ')
bcamIfTabIOsInLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIOsInLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIOsInLows.setDescription(' The number of IO operations for input (low word, add to high word) ')
bcamIfTabOutputStops = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabOutputStops.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabOutputStops.setDescription(' The number of times BCAM sent a RNR (Receive Not Ready) HDLC frame. ')
bcamIfTabInputStops = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 68), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInputStops.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInputStops.setDescription(' The number of times BCAM received a RNR (Receive Not Ready) HDLC frame. ')
bcamIfTabIOErrorOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 69), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIOErrorOuts.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIOErrorOuts.setDescription(' The number of IO errors for output operations ')
bcamIfTabIOErrorIns = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 70), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabIOErrorIns.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabIOErrorIns.setDescription(' The number of IO errors for input operations ')
bcamIfTabPacketsNotReceiveds = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 71), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabPacketsNotReceiveds.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabPacketsNotReceiveds.setDescription(' The number of packets not received due to receive not ready ')
bcamIfTabInPacketsLanHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 72), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInPacketsLanHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInPacketsLanHighs.setDescription(' The number of input packets (only valid for ethernet or FDDI) (high word, multiply by 4294967296) ')
bcamIfTabInPacketsLanLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 73), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabInPacketsLanLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabInPacketsLanLows.setDescription(' The number of input packets (only valid for ethernet or FDDI) (low word, add to high word)')
bcamIfTabOutPacketsLanHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 74), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabOutPacketsLanHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabOutPacketsLanHighs.setDescription(' The number of output packets (only valid for ethernet or FDDI) (high word, multiply by 4294967296) ')
bcamIfTabOutPacketsLanLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 75), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabOutPacketsLanLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabOutPacketsLanLows.setDescription(' The number of output packets (only valid for ethernet or FDDI) (low word, add to high word)')
bcamIfTabUnicastInHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 76), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabUnicastInHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabUnicastInHighs.setDescription(' The number of unicasts received (high word, multiply by 4294967296) ')
bcamIfTabUnicastInLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 77), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabUnicastInLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabUnicastInLows.setDescription(' The number of unicasts received (low word, add to high word) ')
bcamIfTabUnicastOutHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 78), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabUnicastOutHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabUnicastOutHighs.setDescription(' The number of unicasts sent (high word, multiply by 4294967296) ')
bcamIfTabUnicastOutLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 79), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabUnicastOutLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabUnicastOutLows.setDescription(' The number of unicasts sent (low word, add to high word) ')
bcamIfTabMulticastInHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 80), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastInHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastInHighs.setDescription(' The number of multicasts received (high word, multiply by 4294967296) ')
bcamIfTabMulticastInLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 81), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastInLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastInLows.setDescription(' The number of multicasts received (low word, add to high word) ')
bcamIfTabMulticastOutHighs = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 82), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastOutHighs.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastOutHighs.setDescription(' The number of multicasts sent (high word, multiply by 4294967296) ')
bcamIfTabMulticastOutLows = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 83), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabMulticastOutLows.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabMulticastOutLows.setDescription(' The number of multicasts sent (low word, add to high word) ')
bcamIfTabErrorPacketIns = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 84), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabErrorPacketIns.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabErrorPacketIns.setDescription(' The number of erroneous packets received.')
bcamIfTabErrorPacketOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 85), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabErrorPacketOuts.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabErrorPacketOuts.setDescription(' The number of erroneous packets sent.')
bcamIfTabDiscardIns = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 86), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabDiscardIns.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabDiscardIns.setDescription(' The number of packets received that were discarded. ')
bcamIfTabDiscardOuts = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 87), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabDiscardOuts.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabDiscardOuts.setDescription(' The number of packets that were discarded before sending. ')
bcamIfTabUnknownProtoIns = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 88), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabUnknownProtoIns.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabUnknownProtoIns.setDescription(' The number of packets received that were discarded because of unknown protocol. ')
bcamIfTabTraceState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 89), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8))).clone(namedValues=NamedValues(("running", 1), ("save", 2), ("hold", 4), ("stopped", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabTraceState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabTraceState.setDescription(' The current state of the trace. stopped (8) : the trace is not running. running (1) : the trace is running. save (2) : the trace is running and saved to a file. hold (4) : the trace data will be kept in case of an error. Several bits may be set simultaneous.')
bcamIfTabTraceNumberBuffer = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 90), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabTraceNumberBuffer.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabTraceNumberBuffer.setDescription(' The number of buffers used for the trace')
bcamIfTabTraceBufferLen = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 8, 2, 1, 91), Integer32().subtype(subtypeSpec=ValueRangeConstraint(512, 16384))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamIfTabTraceBufferLen.setStatus('mandatory')
if mibBuilder.loadTexts: bcamIfTabTraceBufferLen.setDescription(' The length of one trace buffer in bytes (rounded up to multiples of 256). ')
bcamRouterNumTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouterNumTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterNumTable.setDescription(' The number of table entries in the router table ')
bcamRouterTab = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 2), )
if mibBuilder.loadTexts: bcamRouterTab.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterTab.setDescription('Table of all routers')
bcamRouterTabEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 2, 1), ).setIndexNames((0, "BCAM-MIB", "bcamRouterTabIpLow"), (0, "BCAM-MIB", "bcamRouterTabIpHigh"), (0, "BCAM-MIB", "bcamRouterTabIpLocal"))
if mibBuilder.loadTexts: bcamRouterTabEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterTabEntry.setDescription('Information about a router')
bcamRouterTabIpLow = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouterTabIpLow.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterTabIpLow.setDescription(' The lower IP address limit of the IP address range reachable via this router. ')
bcamRouterTabIpHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouterTabIpHigh.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterTabIpHigh.setDescription(' The upper IP address limit of the IP address range reachable via this router. ')
bcamRouterTabIpLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouterTabIpLocal.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterTabIpLocal.setDescription(' The local IP address used for this endsystem. ')
bcamRouterTabIpRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouterTabIpRouter.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterTabIpRouter.setDescription(' The IP address of the router ')
bcamRouterTabNumRouter = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 9, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamRouterTabNumRouter.setStatus('mandatory')
if mibBuilder.loadTexts: bcamRouterTabNumRouter.setDescription(' The route number of the router. ')
bcamHostNumTable = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamHostNumTable.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostNumTable.setDescription(' The number of table entries in the host table ')
bcamHostTab = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 2), )
if mibBuilder.loadTexts: bcamHostTab.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostTab.setDescription('Table of all Hosts')
bcamHostTabEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 2, 1), ).setIndexNames((0, "BCAM-MIB", "bcamHostTabNumber"))
if mibBuilder.loadTexts: bcamHostTabEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostTabEntry.setDescription('Information about a Host')
bcamHostTabNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamHostTabNumber.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostTabNumber.setDescription(' The definite identifier for this host. ')
bcamHostTabName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamHostTabName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostTabName.setDescription(' The NEA name of the host. ')
bcamHostTabSocketName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamHostTabSocketName.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostTabSocketName.setDescription(' The socket name of the host. ')
bcamHostTabTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("virtual", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamHostTabTyp.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostTabTyp.setDescription(' The type of the host. normal (1) : the host is the BCAM standard host. virtual (2) : the host is a virtual host. ')
bcamHostTabState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 17, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("included", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: bcamHostTabState.setStatus('mandatory')
if mibBuilder.loadTexts: bcamHostTabState.setDescription(' The current state of the host: active (1) : the host is working. included (2) : the host is known by BCAM. Several bits may be set simultaneous.')
mibBuilder.exportSymbols("BCAM-MIB", bcamIfTabNeaAddress1=bcamIfTabNeaAddress1, bcamCepTabMaxIndLen=bcamCepTabMaxIndLen, bcamRouteTabChangeState=bcamRouteTabChangeState, bcamRouteTabMaxNsduLen=bcamRouteTabMaxNsduLen, bcamCepTabInbufTsdu=bcamCepTabInbufTsdu, bcamIfTabMulticastAddr4=bcamIfTabMulticastAddr4, bcamGlobalOutProcLimit1=bcamGlobalOutProcLimit1, bcamCepTabInProcBuck2=bcamCepTabInProcBuck2, bcamRouteTabEntry=bcamRouteTabEntry, bcamTsapTabReactBuck3=bcamTsapTabReactBuck3, bcamCepTabConnectionState=bcamCepTabConnectionState, bcamCepTabPartnerName=bcamCepTabPartnerName, bcamTsapTabInWaitBuck4=bcamTsapTabInWaitBuck4, bcamMemoryPoolPageableCurrent=bcamMemoryPoolPageableCurrent, bcamMemoryPoolMaxCells=bcamMemoryPoolMaxCells, bcamCepTabReactBuck2=bcamCepTabReactBuck2, bcamRouterTabEntry=bcamRouterTabEntry, bcamHostTabEntry=bcamHostTabEntry, bcamIfTabIOsInLows=bcamIfTabIOsInLows, bcamTsapTabReactBuck2Hist=bcamTsapTabReactBuck2Hist, bcamCepTabLetterTimeouts=bcamCepTabLetterTimeouts, bcamTraceMappingState=bcamTraceMappingState, bcamRouteTabErrorRecovTimer=bcamRouteTabErrorRecovTimer, bcamIfTabMode=bcamIfTabMode, bcamRouteTabNameGateway=bcamRouteTabNameGateway, bcamTsapTabClessRecvBytes=bcamTsapTabClessRecvBytes, bcamRouteTabTypAddress=bcamRouteTabTypAddress, bcamIfTabAdminState=bcamIfTabAdminState, bcamRouteTabBadNeaElems=bcamRouteTabBadNeaElems, bcamTsapTabInbufTsdu=bcamTsapTabInbufTsdu, bcamGlobalInWaitLimit3=bcamGlobalInWaitLimit3, bcamIfTabMulticastAddr5=bcamIfTabMulticastAddr5, bcamGlobalReactLimit4=bcamGlobalReactLimit4, bcamTraceAdmNumberBuffer=bcamTraceAdmNumberBuffer, bcamTsapRejTsapTask=bcamTsapRejTsapTask, bcamMemoryLenTransParamSlot=bcamMemoryLenTransParamSlot, bcamCepTabEntry=bcamCepTabEntry, bcamMemoryCellReqTempExceed=bcamMemoryCellReqTempExceed, bcamRouterTabNumRouter=bcamRouterTabNumRouter, bcamRouteTabRoundTripTimeClosed=bcamRouteTabRoundTripTimeClosed, bcamGlobalNumBitmap=bcamGlobalNumBitmap, bcamHostTabSocketName=bcamHostTabSocketName, bcamRouteTabInDuplicatedPackets=bcamRouteTabInDuplicatedPackets, bcamMemoryLenEnaCb=bcamMemoryLenEnaCb, bcamRouteTabIso4WindowTimer=bcamRouteTabIso4WindowTimer, bcamTsapTabClessTimeout=bcamTsapTabClessTimeout, bcamIfTabErrorPacketOuts=bcamIfTabErrorPacketOuts, bcamRouteTabNumberGateway=bcamRouteTabNumberGateway, bcamRouteRoutingReqNea=bcamRouteRoutingReqNea, bcamTraceBasicBufferLen=bcamTraceBasicBufferLen, bcamMemoryPoolMaxPageable=bcamMemoryPoolMaxPageable, bcamIfTabIOErrorIns=bcamIfTabIOErrorIns, bcamRoute=bcamRoute, bcamRouteTabInIncorrectPackets=bcamRouteTabInIncorrectPackets, bcamIfTabNeaAddress2=bcamIfTabNeaAddress2, bcamTsapTabTsduSends=bcamTsapTabTsduSends, bcamTsapTabInWaitBuck1Hist=bcamTsapTabInWaitBuck1Hist, bcamMemoryOccLongEventSlot=bcamMemoryOccLongEventSlot, bcamTsapTab=bcamTsapTab, bcamTsapTabReactBuck3Hist=bcamTsapTabReactBuck3Hist, bcamIfTabName=bcamIfTabName, bcamIfTabOutPacketsLanLows=bcamIfTabOutPacketsLanLows, bcamRouteTabNameX25Station=bcamRouteTabNameX25Station, bcamGlobalReactChange=bcamGlobalReactChange, sniProductMibs=sniProductMibs, bcamRouteTabDisconnIn=bcamRouteTabDisconnIn, bcamCepTabErrorPacketsReceiveds=bcamCepTabErrorPacketsReceiveds, bcamTraceSavingState=bcamTraceSavingState, bcamRouteTabNameEndsystem=bcamRouteTabNameEndsystem, bcamIfTabIpAddress6=bcamIfTabIpAddress6, bcamRouteTabOutPacketsDatas=bcamRouteTabOutPacketsDatas, bcamTraceNetBufferLen=bcamTraceNetBufferLen, bcamIfTabProfile=bcamIfTabProfile, bcamMemoryLenShortResConn2=bcamMemoryLenShortResConn2, bcamGlobalBcamVersion=bcamGlobalBcamVersion, bcamMemoryPoolOutputLimitTrap=bcamMemoryPoolOutputLimitTrap, bcamGlobalPortNonpriv=bcamGlobalPortNonpriv, bcamRouteTabIcmpReq=bcamRouteTabIcmpReq, bcamTsapMaxTsap=bcamTsapMaxTsap, bcamTraceConnBufferLen=bcamTraceConnBufferLen, bcamIfTabIOsInHighs=bcamIfTabIOsInHighs, bcamTraceNetState=bcamTraceNetState, bcamRouteTabArpFlag=bcamRouteTabArpFlag, bcamTsapRecvByteHigh=bcamTsapRecvByteHigh, bcamIfTabMulticastInLows=bcamIfTabMulticastInLows, bcamIfTabL2Monitoring=bcamIfTabL2Monitoring, bcamCepTabDisconInfoWord=bcamCepTabDisconInfoWord, bcamRouteTabProcNetTyp=bcamRouteTabProcNetTyp, bcamIfTabDiscardIns=bcamIfTabDiscardIns, bcamIfTabLenTraceIn=bcamIfTabLenTraceIn, bcamTrapOutPoolOverCurrent=bcamTrapOutPoolOverCurrent, bcamCepTab=bcamCepTab, bcamRouteTabOutRetransPackets=bcamRouteTabOutRetransPackets, bcamRouteTabSwitched=bcamRouteTabSwitched, bcamRouteTabL3Subprofile=bcamRouteTabL3Subprofile, bcamTsapTabTsduSendHists=bcamTsapTabTsduSendHists, bcamCepTabDuplicatePacketsReceiveds=bcamCepTabDuplicatePacketsReceiveds, bcamRouteTabPacketNoConn=bcamRouteTabPacketNoConn, bcamRouteTabName=bcamRouteTabName, bcamMemoryOccSnmpConn=bcamMemoryOccSnmpConn, bcamCepTabReactBuck3=bcamCepTabReactBuck3, bcamTsapTabInbufByte=bcamTsapTabInbufByte, bcamRouteTabNumIsoConn=bcamRouteTabNumIsoConn, bcamMemoryOccApplCb=bcamMemoryOccApplCb, bcamHostNumTable=bcamHostNumTable, bcamGlobalReactLimit1=bcamGlobalReactLimit1, bcamTsapSendByteHigh=bcamTsapSendByteHigh, bcamCepTabPartnerEndsystem=bcamCepTabPartnerEndsystem, bcamTsapTabNumbers=bcamTsapTabNumbers, bcamIfTabInt0Address1=bcamIfTabInt0Address1, bcamIfTabIOErrorOuts=bcamIfTabIOErrorOuts, bcamRouteTabConnReqInAck=bcamRouteTabConnReqInAck, bcamIfTabMnemonicRead=bcamIfTabMnemonicRead, bcamTsapTabTimeApplEnable=bcamTsapTabTimeApplEnable, bcamTraceConnState=bcamTraceConnState, bcamTraceInfoNumberBuffer=bcamTraceInfoNumberBuffer, bcamTsapTabByteSends=bcamTsapTabByteSends, bcamRouteTabDisconnOut=bcamRouteTabDisconnOut, bcamCepCurrent=bcamCepCurrent, bcamIfTabIpAddress2=bcamIfTabIpAddress2, bcamRouter=bcamRouter, bcamTsapTabCloseConns=bcamTsapTabCloseConns, bcamTsapTabInWaitBuck1=bcamTsapTabInWaitBuck1, bcamTsapTabSendCallOverMaxs=bcamTsapTabSendCallOverMaxs, bcamTsapTabReactBuck1Hist=bcamTsapTabReactBuck1Hist, bcamRouteTabOutPacketsFlowControls=bcamRouteTabOutPacketsFlowControls, bcamTsapMaxTsapTask=bcamTsapMaxTsapTask, bcamTsapTabInbufByteCless=bcamTsapTabInbufByteCless, bcamGlobalBroadcast=bcamGlobalBroadcast, sni=sni, bcamIfTabNeaAddress6=bcamIfTabNeaAddress6, bcamTsapTabClessSendCalls=bcamTsapTabClessSendCalls, bcamCepTabTsduReceiveds=bcamCepTabTsduReceiveds, bcamMemoryPoolRoutingLimit=bcamMemoryPoolRoutingLimit, bcamCepTabConnectionNumbers=bcamCepTabConnectionNumbers, bcamIfTabMulticastAddr1=bcamIfTabMulticastAddr1, bcamIfTabMnemonicWrite=bcamIfTabMnemonicWrite, bcamTraceMgmtNumberBuffer=bcamTraceMgmtNumberBuffer, bcamTraceNumberFiles=bcamTraceNumberFiles, bcamGlobalEsCreationIp=bcamGlobalEsCreationIp, bcamTsapTabLetterTimeoutHists=bcamTsapTabLetterTimeoutHists, bcamCepNumTable=bcamCepNumTable, bcamTsap=bcamTsap, bcamTsapTabEntry=bcamTsapTabEntry, bcamGlobal=bcamGlobal, bcamRouteTabAckTimer=bcamRouteTabAckTimer, bcamTsapTabName=bcamTsapTabName, bcamRouteTabIso9542=bcamRouteTabIso9542, bcamIfTabMulticastAddr10=bcamIfTabMulticastAddr10, bcamTraceLocalNumberBuffer=bcamTraceLocalNumberBuffer, bcamIfTabIpAddress1=bcamIfTabIpAddress1, bcamCepTabDisconCommand=bcamCepTabDisconCommand, bcamGlobalFileProcTable=bcamGlobalFileProcTable, bcamIfTabInt0Address3=bcamIfTabInt0Address3, bcamIfTabNumIpAddress=bcamIfTabNumIpAddress, bcamIfTabIntfAddress3=bcamIfTabIntfAddress3, bcamIfTabMulticastOutLows=bcamIfTabMulticastOutLows, bcamRouteTabOspfHello=bcamRouteTabOspfHello, bcamCepTabSendCallOverMaxs=bcamCepTabSendCallOverMaxs, bcamRouterTabIpRouter=bcamRouterTabIpRouter, bcamMemoryClass3=bcamMemoryClass3, bcamGlobalInProcSet=bcamGlobalInProcSet, bcamCepTabInWaitBuck2=bcamCepTabInWaitBuck2, bcamRouteTabLanAddress=bcamRouteTabLanAddress, bcamCepTabTimeConnectionEstablishment=bcamCepTabTimeConnectionEstablishment, bcamTsapTabInWaitBuck5=bcamTsapTabInWaitBuck5, bcamCepTabInProcBuck4=bcamCepTabInProcBuck4, bcamMemoryPoolInputMaxPageable=bcamMemoryPoolInputMaxPageable, bcamTraceBasicNumberBuffer=bcamTraceBasicNumberBuffer, bcamTsapTabOutbufTsdu=bcamTsapTabOutbufTsdu, bcamIfTabIpAddress3=bcamIfTabIpAddress3, bcamIfTabNeaAddress5=bcamIfTabNeaAddress5, bcamCepTabInWaitBuck5=bcamCepTabInWaitBuck5, bcamGlobalInProcLimit3=bcamGlobalInProcLimit3, bcamRouteTabOption=bcamRouteTabOption, bcamTsapTabInbufTsduCless=bcamTsapTabInbufTsduCless, bcamTsapCurrOpen=bcamTsapCurrOpen, bcamMemoryPoolOutputResume=bcamMemoryPoolOutputResume, bcamTsapTabInWaitBuck3Hist=bcamTsapTabInWaitBuck3Hist, bcamGlobalInWaitChange=bcamGlobalInWaitChange, bcamMemoryPoolInputMonMin=bcamMemoryPoolInputMonMin, bcamCepTabTypPartnerName=bcamCepTabTypPartnerName, bcamIfTabIOsOutHighs=bcamIfTabIOsOutHighs, bcamGlobalEsCreationIso=bcamGlobalEsCreationIso, bcamTsapTabReactBuck4=bcamTsapTabReactBuck4, bcamRouteTabDown=bcamRouteTabDown, bcamRouteTabMinNsduLen=bcamRouteTabMinNsduLen, bcamMemoryOccEnaCb=bcamMemoryOccEnaCb, bcamCepTabOutProcBuck1=bcamCepTabOutProcBuck1, bcamHost=bcamHost, bcamTsapTotOpen=bcamTsapTotOpen, bcamGlobalInWaitSet=bcamGlobalInWaitSet, bcamTsapSendByteLow=bcamTsapSendByteLow, bcamRouteTabFunction=bcamRouteTabFunction, bcamRouteTabIcmpReply=bcamRouteTabIcmpReply, bcamCepTabLocalEndsystem=bcamCepTabLocalEndsystem, bcamMemoryPoolInputMonMax=bcamMemoryPoolInputMonMax, bcamRouteTabNumNeaConn=bcamRouteTabNumNeaConn, bcamCepTabOutProcBuck5=bcamCepTabOutProcBuck5, bcamMemoryLenShortPagConn1=bcamMemoryLenShortPagConn1, bcamCepTabDuration=bcamCepTabDuration, bcamIfTabLenTraceOut=bcamIfTabLenTraceOut, bcamIfTabMulticastAddr2=bcamIfTabMulticastAddr2, bcamTsapTabInWaitBuck3=bcamTsapTabInWaitBuck3, bcamTsapTabReactBuck5Hist=bcamTsapTabReactBuck5Hist, bcamIfTabInt0Address4=bcamIfTabInt0Address4, bcamMemoryCellReqBitmapFull=bcamMemoryCellReqBitmapFull, bcamTsapTabInWaitBuck2Hist=bcamTsapTabInWaitBuck2Hist, bcamTraceTransNumberBuffer=bcamTraceTransNumberBuffer, bcamCepTabZeroWindowReceiveds=bcamCepTabZeroWindowReceiveds, bcamCepTabOutbufMaxByteSend=bcamCepTabOutbufMaxByteSend, bcamCepTabOutbufTsduSend=bcamCepTabOutbufTsduSend, bcamTrapLinkDown=bcamTrapLinkDown, bcamGlobalTrapPollInterval=bcamGlobalTrapPollInterval, bcamMemoryCellReqResInExceed=bcamMemoryCellReqResInExceed, bcamTsapTabDiagnostic=bcamTsapTabDiagnostic, bcamTsapRecvCallCless=bcamTsapRecvCallCless, bcamCepTabApplicationNumber=bcamCepTabApplicationNumber, bcamRouteTabConnReqIn=bcamRouteTabConnReqIn, bcamGlobalInProcLimit1=bcamGlobalInProcLimit1, bcamRouteTabArpReqRec=bcamRouteTabArpReqRec, bcamTraceBasicState=bcamTraceBasicState, bcamRouteTabPacketInternDiscon=bcamRouteTabPacketInternDiscon, bcamCepTabL4AddrLocal=bcamCepTabL4AddrLocal, bcamGlobalOutProcSet=bcamGlobalOutProcSet, bcamMemoryClass4=bcamMemoryClass4, bcamMemoryOccShortEventSlot=bcamMemoryOccShortEventSlot, bcamTsapTabClessRecvCalls=bcamTsapTabClessRecvCalls, bcamCepTabReactBuck4=bcamCepTabReactBuck4, bcamTsapTabSendCallOverMaxHists=bcamTsapTabSendCallOverMaxHists, bcamTrapSystemUp=bcamTrapSystemUp, bcamIfTabBytesInHighs=bcamIfTabBytesInHighs, bcamRouteTabConnReqOut=bcamRouteTabConnReqOut, bcamTsapRejCepTsap=bcamTsapRejCepTsap, bcamTsapRejTsap=bcamTsapRejTsap, bcamTsapTabDateApplEnable=bcamTsapTabDateApplEnable, bcamRouteTabInPacketsDatas=bcamRouteTabInPacketsDatas, bcamTrapInPoolUnder=bcamTrapInPoolUnder, bcamCepTabOutbufMaxTsduSend=bcamCepTabOutbufMaxTsduSend, bcamCepTabPacketsDataReceiveds=bcamCepTabPacketsDataReceiveds, bcamRouteTabMaxTsduLen=bcamRouteTabMaxTsduLen, bcamRouteTabNumberLink=bcamRouteTabNumberLink, bcamCepTabInbufMaxTsduReceived=bcamCepTabInbufMaxTsduReceived, bcamTsapTabByteReceiveds=bcamTsapTabByteReceiveds, bcamTraceSnmpNumberBuffer=bcamTraceSnmpNumberBuffer, bcamRouteTabConnReqOutRej=bcamRouteTabConnReqOutRej, bcamIfTabUnknownProtoIns=bcamIfTabUnknownProtoIns, bcamIfTabIOsOutLows=bcamIfTabIOsOutLows, bcamTsapSendByteClessHigh=bcamTsapSendByteClessHigh, bcamGlobalOutProcChange=bcamGlobalOutProcChange, bcamRouteTabConnReqInRej=bcamRouteTabConnReqInRej, bcamTsapTabPortnumber=bcamTsapTabPortnumber, bcamGlobalOutProcLimit2=bcamGlobalOutProcLimit2, bcamIfTabPacketsNotReceiveds=bcamIfTabPacketsNotReceiveds)
mibBuilder.exportSymbols("BCAM-MIB", bcamTraceAdmState=bcamTraceAdmState, bcamRouteTabTransState=bcamRouteTabTransState, bcamRouteTabRemoteAddr=bcamRouteTabRemoteAddr, bcamCepTabTypeL4Addr=bcamCepTabTypeL4Addr, bcamTrapString=bcamTrapString, bcamMemoryLenSnmpConn=bcamMemoryLenSnmpConn, bcamTraceNetNumberBuffer=bcamTraceNetNumberBuffer, bcamCepNotClosed=bcamCepNotClosed, bcamTrapOutPoolOver=bcamTrapOutPoolOver, bcamMemoryPoolPageableFixed=bcamMemoryPoolPageableFixed, bcamHostTabName=bcamHostTabName, bcamTsapSendCall=bcamTsapSendCall, bcamIfTabCurrentState=bcamIfTabCurrentState, bcamIfTabMulticastOutHighs=bcamIfTabMulticastOutHighs, bcamRouteTabNumberIsoIpRouter=bcamRouteTabNumberIsoIpRouter, bcamIfNumTable=bcamIfNumTable, bcamIfTabMulticastInHighs=bcamIfTabMulticastInHighs, bcamRouteTabMaxIsoConn=bcamRouteTabMaxIsoConn, bcamCepActiveTrials=bcamCepActiveTrials, bcamGlobalArp=bcamGlobalArp, bcamIfTabOutputStops=bcamIfTabOutputStops, bcamMemoryLenShortEventSlot=bcamMemoryLenShortEventSlot, bcamTraceAdmBufferLen=bcamTraceAdmBufferLen, bcamMemoryPoolInputLimit=bcamMemoryPoolInputLimit, bcamIfTabTraceBufferLen=bcamIfTabTraceBufferLen, bcamRouteSuccRoutingReqIso=bcamRouteSuccRoutingReqIso, bcamTraceMaxFilesize=bcamTraceMaxFilesize, bcamMemoryOccShortResConn2=bcamMemoryOccShortResConn2, bcamRouteTabConnReqOutAck=bcamRouteTabConnReqOutAck, bcamTsapTabReactBuck1=bcamTsapTabReactBuck1, bcamMemoryLenLongResConn2=bcamMemoryLenLongResConn2, bcamIfTabInt0Address5=bcamIfTabInt0Address5, bcamIfTabLanAddress=bcamIfTabLanAddress, bcamRouteNumTable=bcamRouteNumTable, bcamCep=bcamCep, bcamRouteTabArpReqSend=bcamRouteTabArpReqSend, bcamRouteRoutingReqIp=bcamRouteRoutingReqIp, bcamIfTabTraceState=bcamIfTabTraceState, bcamRouteTabIso4RetransTimer=bcamRouteTabIso4RetransTimer, bcamHostTabState=bcamHostTabState, bcamMemoryCellReqResOutExceed=bcamMemoryCellReqResOutExceed, bcamIfTabTimeLastChange=bcamIfTabTimeLastChange, bcamIfTabUnicastOutLows=bcamIfTabUnicastOutLows, bcamCepTabPacketsDataSends=bcamCepTabPacketsDataSends, bcamTsapTabTypName=bcamTsapTabTypName, bcamTsapNumTable=bcamTsapNumTable, bcamRouteSuccRoutingReqNea=bcamRouteSuccRoutingReqNea, bcamIfTabMulticastAddr9=bcamIfTabMulticastAddr9, bcamIfTabTraceNumberBuffer=bcamIfTabTraceNumberBuffer, bcamTsapMaxCepTsap=bcamTsapMaxCepTsap, bcamTsapTabInWaitBuck4Hist=bcamTsapTabInWaitBuck4Hist, bcamTsapTabByteReceivedHists=bcamTsapTabByteReceivedHists, bcamGlobalInWaitLimit4=bcamGlobalInWaitLimit4, bcamIfTabUnicastOutHighs=bcamIfTabUnicastOutHighs, bcamMemoryOccLongPagConn1=bcamMemoryOccLongPagConn1, bcamIfTabInPacketsLanLows=bcamIfTabInPacketsLanLows, bcamRouterNumTable=bcamRouterNumTable, bcamTsapTabHost=bcamTsapTabHost, bcamRouteTabMaxL4Conn=bcamRouteTabMaxL4Conn, bcamRouteSuccRoutingReqIp=bcamRouteSuccRoutingReqIp, bcamRouteTabCommandState=bcamRouteTabCommandState, bcamRouteTabState2=bcamRouteTabState2, bcamTraceInfoBufferLen=bcamTraceInfoBufferLen, bcamRouteTabRejectTimer=bcamRouteTabRejectTimer, bcamRouteTab=bcamRouteTab, bcamRouteTabBadIsoElems=bcamRouteTabBadIsoElems, bcamCepTabRouteNumber=bcamCepTabRouteNumber, bcamMemory=bcamMemory, bcamIfTabNumbers=bcamIfTabNumbers, bcamRouteTabNumberNeaRouter=bcamRouteTabNumberNeaRouter, bcamCepTabPacketsWindowReceiveds=bcamCepTabPacketsWindowReceiveds, bcamCepTabRoundTripTime=bcamCepTabRoundTripTime, bcamCepTabInProcBuck1=bcamCepTabInProcBuck1, bcamIfTabPortName=bcamIfTabPortName, bcamRouteTabArpRepRec=bcamRouteTabArpRepRec, bcamMemoryPoolMaxResident=bcamMemoryPoolMaxResident, bcamRouteTabExpedRetransTimer=bcamRouteTabExpedRetransTimer, bcamCepTabDetectedGapsReceiveds=bcamCepTabDetectedGapsReceiveds, bcamRouteTabL3InputProfil=bcamRouteTabL3InputProfil, bcamIf=bcamIf, bcamGlobalSnmpRelease=bcamGlobalSnmpRelease, bcamIfTabEntry=bcamIfTabEntry, bcamIfTabBytesInLows=bcamIfTabBytesInLows, bcamTsapTabFunction=bcamTsapTabFunction, bcamHostTabNumber=bcamHostTabNumber, bcamTraceMgmtState=bcamTraceMgmtState, bcamRouterTabIpLocal=bcamRouterTabIpLocal, bcamMemoryOccShortPagConn1=bcamMemoryOccShortPagConn1, bcamCepTabOutProcBuck4=bcamCepTabOutProcBuck4, bcamIfTabIntfAddress6=bcamIfTabIntfAddress6, bcamCepTabOutProcBuck2=bcamCepTabOutProcBuck2, bcamCepTabMaxSendLen=bcamCepTabMaxSendLen, bcamMemoryCellReqPagInExceed=bcamMemoryCellReqPagInExceed, bcamRouteArpDefault=bcamRouteArpDefault, bcamTrapInPoolOverCurrent=bcamTrapInPoolOverCurrent, bcamIfTabNumNeaAddress=bcamIfTabNumNeaAddress, bcamRouteTabMaxNetLength=bcamRouteTabMaxNetLength, bcamTsapRecvByteClessHigh=bcamTsapRecvByteClessHigh, bcamCepTabByteSends=bcamCepTabByteSends, bcamIfTabInPacketsLanHighs=bcamIfTabInPacketsLanHighs, bcamCepTabInProcBuck3=bcamCepTabInProcBuck3, bcamIfTabUnicastInLows=bcamIfTabUnicastInLows, bcamTsapTabNeaTsel=bcamTsapTabNeaTsel, bcamCepTabInProcBuck5=bcamCepTabInProcBuck5, bcamMemoryLenSnmpParamSlot=bcamMemoryLenSnmpParamSlot, bcamIfTabMaxLpdu=bcamIfTabMaxLpdu, bcamTrapInPoolOver=bcamTrapInPoolOver, bcamTsapTabOutbufByteCless=bcamTsapTabOutbufByteCless, bcamIfTabMulticastAddr6=bcamIfTabMulticastAddr6, bcamIfTabIntfAddress5=bcamIfTabIntfAddress5, bcamCepTabInWaitBuck3=bcamCepTabInWaitBuck3, bcamTsapTabInWaitBuck2=bcamTsapTabInWaitBuck2, bcamCepPassiveTrialFailures=bcamCepPassiveTrialFailures, bcamIfTabMulticastAddr7=bcamIfTabMulticastAddr7, bcamMemoryPoolOutputLimit=bcamMemoryPoolOutputLimit, bcamMemoryPoolInputCurrent=bcamMemoryPoolInputCurrent, bcamMemoryLenLongEventSlot=bcamMemoryLenLongEventSlot, sniBcam=sniBcam, bcamCepTabLocalName=bcamCepTabLocalName, bcamMemoryPoolOutputMaxPageable=bcamMemoryPoolOutputMaxPageable, bcamRouteTabArpRepSend=bcamRouteTabArpRepSend, bcamRouterTabIpHigh=bcamRouterTabIpHigh, bcamTsapTabOutbufByte=bcamTsapTabOutbufByte, bcamTsapRecvByteLow=bcamTsapRecvByteLow, bcamTsapTabReactBuck2=bcamTsapTabReactBuck2, bcamRouteTabRouteNetTyp=bcamRouteTabRouteNetTyp, bcamIfTab=bcamIfTab, bcamRouteTabDisconnOutAck=bcamRouteTabDisconnOutAck, bcamTsapTabOutbufTsduCless=bcamTsapTabOutbufTsduCless, bcamCepTabReactBuck1=bcamCepTabReactBuck1, bcamTraceLocalState=bcamTraceLocalState, bcamMemoryCellReqSucc=bcamMemoryCellReqSucc, bcamMemoryPoolInputLimitTrap=bcamMemoryPoolInputLimitTrap, bcamIfTabNumRouteSwitchings=bcamIfTabNumRouteSwitchings, bcamTsapTabState=bcamTsapTabState, bcamIfTabNumInt0Address=bcamIfTabNumInt0Address, bcamMemoryOccSnmpParamSlot=bcamMemoryOccSnmpParamSlot, bcamRouteTabDeactReason=bcamRouteTabDeactReason, bcamIfTabConfigUpdate=bcamIfTabConfigUpdate, bcamIfTabIntfAddress1=bcamIfTabIntfAddress1, bcamTrapLinkUp=bcamTrapLinkUp, bcamMemoryPoolOutputCurrent=bcamMemoryPoolOutputCurrent, bcamGlobalFileSocketHostTable=bcamGlobalFileSocketHostTable, bcamRouteTabTyp=bcamRouteTabTyp, bcamTsapTabReactBuck5=bcamTsapTabReactBuck5, bcamCepTabTsduSends=bcamCepTabTsduSends, bcamGlobalOutProcLimit3=bcamGlobalOutProcLimit3, bcamGlobalOutProcLimit4=bcamGlobalOutProcLimit4, bcamRouteTabNsduLen=bcamRouteTabNsduLen, bcamCepTabInWaitBuck1=bcamCepTabInWaitBuck1, bcamCepTabGlobalZeroWindowSends=bcamCepTabGlobalZeroWindowSends, bcamRouteTabReasonCreation=bcamRouteTabReasonCreation, bcamIfTabBytesOutLows=bcamIfTabBytesOutLows, bcamRouteTabInDetectedGaps=bcamRouteTabInDetectedGaps, bcamCepTabDateConnectionEstablishment=bcamCepTabDateConnectionEstablishment, bcamRouteTabSwitchType=bcamRouteTabSwitchType, bcamRouteTabLocalAddr=bcamRouteTabLocalAddr, bcamHostTabTyp=bcamHostTabTyp, bcamGlobalReactLimit2=bcamGlobalReactLimit2, bcamCepTabOutProcBuck3=bcamCepTabOutProcBuck3, bcamIfTabNeaAddress4=bcamIfTabNeaAddress4, bcamMemoryPoolOutputMonMin=bcamMemoryPoolOutputMonMin, bcamTsapTabCurrConn=bcamTsapTabCurrConn, bcamIfTabNumIntfAddress=bcamIfTabNumIntfAddress, bcamRouterTabIpLow=bcamRouterTabIpLow, bcamTraceSnmpBufferLen=bcamTraceSnmpBufferLen, bcamCepTabPacketsWindowSends=bcamCepTabPacketsWindowSends, bcamRouteTabMaxNeaConn=bcamRouteTabMaxNeaConn, bcamIfTabMulticastAddr3=bcamIfTabMulticastAddr3, bcamCepTabInbufByte=bcamCepTabInbufByte, bcamRouteTabOrigLanAddress=bcamRouteTabOrigLanAddress, bcamTraceFilename=bcamTraceFilename, bcamTraceMappingBufferLen=bcamTraceMappingBufferLen, bcamIfTabErrorPacketIns=bcamIfTabErrorPacketIns, bcamIfTabInt0Address6=bcamIfTabInt0Address6, bcamMemoryPoolInputResume=bcamMemoryPoolInputResume, PhysAddress=PhysAddress, bcamTraceConnNumberBuffer=bcamTraceConnNumberBuffer, bcamGlobalInWaitLimit1=bcamGlobalInWaitLimit1, bcamRouteTabInPacketsFlowControls=bcamRouteTabInPacketsFlowControls, bcamGlobalRarp=bcamGlobalRarp, bcamHostTab=bcamHostTab, bcamMemoryPoolRoutingCurrent=bcamMemoryPoolRoutingCurrent, bcamTrapOutPoolUnder=bcamTrapOutPoolUnder, bcamMemoryCellReqPagOutExceed=bcamMemoryCellReqPagOutExceed, bcamIfTabIntfAddress4=bcamIfTabIntfAddress4, bcamTsapTabOsiTsel=bcamTsapTabOsiTsel, bcamTrapInPoolUnderCurrent=bcamTrapInPoolUnderCurrent, bcamTsapRecvCall=bcamTsapRecvCall, bcamTraceLocalBufferLen=bcamTraceLocalBufferLen, bcamGlobalInProcLimit4=bcamGlobalInProcLimit4, bcamMemoryOccExtApplCb=bcamMemoryOccExtApplCb, bcamTsapTabInWaitBuck5Hist=bcamTsapTabInWaitBuck5Hist, bcamTsapTabReactBuck4Hist=bcamTsapTabReactBuck4Hist, bcamMemoryLenApplCb=bcamMemoryLenApplCb, bcamCepTabL4AddrPartner=bcamCepTabL4AddrPartner, bcamRouteTabDisconnInAck=bcamRouteTabDisconnInAck, bcamGlobalMibVersion=bcamGlobalMibVersion, bcamMemoryLenLongPagConn1=bcamMemoryLenLongPagConn1, bcamMemoryOccLongResConn2=bcamMemoryOccLongResConn2, bcamTsapSendCallCless=bcamTsapSendCallCless, bcamCepTabInbufMaxByteReceived=bcamCepTabInbufMaxByteReceived, bcamMemoryPoolOutputMonMax=bcamMemoryPoolOutputMonMax, bcamIfTabIpAddress4=bcamIfTabIpAddress4, bcamCepTabProtocolClass=bcamCepTabProtocolClass, bcamIfTabInt0Address2=bcamIfTabInt0Address2, bcamTraceTransBufferLen=bcamTraceTransBufferLen, bcamMemoryOccShortPagConn2=bcamMemoryOccShortPagConn2, bcamIfTabDiscardOuts=bcamIfTabDiscardOuts, bcamIfTabInputStops=bcamIfTabInputStops, bcamRouterTab=bcamRouterTab, bcamRouteTabNumbers=bcamRouteTabNumbers, bcamMemoryOccTransParamSlot=bcamMemoryOccTransParamSlot, bcamTsapTabLetterTimeouts=bcamTsapTabLetterTimeouts, bcamIfTabNumMulticastAddr=bcamIfTabNumMulticastAddr, bcamTsapTabTsduReceiveds=bcamTsapTabTsduReceiveds, bcamCepClosed=bcamCepClosed, bcamTsapTabByteSendHists=bcamTsapTabByteSendHists, bcamGlobalReactSet=bcamGlobalReactSet, bcamGlobalInProcLimit2=bcamGlobalInProcLimit2, bcamGlobalInWaitLimit2=bcamGlobalInWaitLimit2, bcamRouteTabMaxUnackTpdu=bcamRouteTabMaxUnackTpdu, bcamTrap=bcamTrap, bcamGlobalAccessProcTable=bcamGlobalAccessProcTable, bcamTrapOutPoolUnderCurrent=bcamTrapOutPoolUnderCurrent, bcamRouteRoutingReqIso=bcamRouteRoutingReqIso, bcamIfTabDevice=bcamIfTabDevice, bcamTraceMappingNumberBuffer=bcamTraceMappingNumberBuffer, bcamGlobalPortFree=bcamGlobalPortFree, bcamMemoryLenExtApplCb=bcamMemoryLenExtApplCb, bcamIfTabMulticastAddr8=bcamIfTabMulticastAddr8, bcamIfTabBytesOutHighs=bcamIfTabBytesOutHighs, bcamRouteTabUsage=bcamRouteTabUsage, bcamTraceTransState=bcamTraceTransState, bcamIfTabOutPacketsLanHighs=bcamIfTabOutPacketsLanHighs, bcamTraceInfoState=bcamTraceInfoState, bcamCepTabRetransmitPacketsSends=bcamCepTabRetransmitPacketsSends, bcamTsapRecvByteClessLow=bcamTsapRecvByteClessLow, bcamCepRerouting=bcamCepRerouting, bcamIfTabIntfAddress2=bcamIfTabIntfAddress2, bcamCepTabOutbufByteSend=bcamCepTabOutbufByteSend, bcamIfTabMnemonicDiag=bcamIfTabMnemonicDiag, bcamIfTabNeaAddress3=bcamIfTabNeaAddress3, bcamGlobalMaxRemoteIp=bcamGlobalMaxRemoteIp, bcamGlobalReactLimit3=bcamGlobalReactLimit3, bcamGlobalInProcChange=bcamGlobalInProcChange, bcamGlobalHostName=bcamGlobalHostName, bcamGlobalFileApplTable=bcamGlobalFileApplTable, bcamCepTabConnectionZeroWindowSends=bcamCepTabConnectionZeroWindowSends, bcamTrace=bcamTrace, bcamMemoryLenShortPagConn2=bcamMemoryLenShortPagConn2, bcamTsapTabTsduReceivedHists=bcamTsapTabTsduReceivedHists, bcamCepActiveTrialFailures=bcamCepActiveTrialFailures, bcamMemoryCellReqNoMemory=bcamMemoryCellReqNoMemory)
mibBuilder.exportSymbols("BCAM-MIB", bcamRouteTabIcmpRedirect=bcamRouteTabIcmpRedirect, bcamRouteTabRoundTripTimeCurrent=bcamRouteTabRoundTripTimeCurrent, bcamIfTabIpAddress5=bcamIfTabIpAddress5, bcamGlobalUpTime=bcamGlobalUpTime, bcamCepPassiveTrials=bcamCepPassiveTrials, bcamCepTabByteReceiveds=bcamCepTabByteReceiveds, bcamTraceSnmpState=bcamTraceSnmpState, bcamTraceMgmtBufferLen=bcamTraceMgmtBufferLen, bcamTsapTabClessSendBytes=bcamTsapTabClessSendBytes, bcamTsapTabDuration=bcamTsapTabDuration, bcamTsapSendByteClessLow=bcamTsapSendByteClessLow, bcamIfTabUnicastInHighs=bcamIfTabUnicastInHighs, bcamCepTabReactBuck5=bcamCepTabReactBuck5, bcamRouteActive=bcamRouteActive, bcamRouteTabPacketBadProtocol=bcamRouteTabPacketBadProtocol, bcamCepTabInWaitBuck4=bcamCepTabInWaitBuck4)

#
# PySNMP MIB module MALLOC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MALLOC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:09:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueSizeConstraint")
IANAmallocRangeSource, IANAscopeSource = mibBuilder.importSymbols("IANA-MALLOC-MIB", "IANAmallocRangeSource", "IANAscopeSource")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
LanguageTag, = mibBuilder.importSymbols("IPMROUTE-STD-MIB", "LanguageTag")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Bits, Integer32, iso, TimeTicks, mib_2, NotificationType, ObjectIdentity, ModuleIdentity, Gauge32, MibIdentifier, Counter64, Counter32, IpAddress, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "Integer32", "iso", "TimeTicks", "mib-2", "NotificationType", "ObjectIdentity", "ModuleIdentity", "Gauge32", "MibIdentifier", "Counter64", "Counter32", "IpAddress", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, TruthValue, DisplayString, RowStatus, StorageType = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString", "RowStatus", "StorageType")
mallocMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 101))
mallocMIB.setRevisions(('2003-06-09 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: mallocMIB.setRevisionsDescriptions(('Initial version, published as RFC 3559.',))
if mibBuilder.loadTexts: mallocMIB.setLastUpdated('200306090000Z')
if mibBuilder.loadTexts: mallocMIB.setOrganization('IETF MALLOC Working Group')
if mibBuilder.loadTexts: mallocMIB.setContactInfo(' WG-EMail: malloc@catarina.usc.edu Subscribe: malloc-request@catarina.usc.edu Archive: catarina.usc.edu/pub/multicast/malloc/ Co-chair/editor: Dave Thaler Microsoft Corporation One Microsoft Way Redmond, WA 98052 EMail: dthaler@microsoft.com Co-chair: Steve Hanna Sun Microsystems, Inc. One Network Drive Burlington, MA 01803 EMail: steve.hanna@sun.com')
if mibBuilder.loadTexts: mallocMIB.setDescription('The MIB module for management of multicast address allocation. Copyright (C) The Internet Society (2003). This version of this MIB module is part of RFC 3559; see the RFC itself for full legal notices.')
mallocMIBObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 101, 1))
malloc = MibIdentifier((1, 3, 6, 1, 2, 1, 101, 1, 1))
madcap = MibIdentifier((1, 3, 6, 1, 2, 1, 101, 1, 2))
mallocCapabilities = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 1, 1), Bits().clone(namedValues=NamedValues(("startTime", 0), ("serverMobility", 1), ("retryAfter", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocCapabilities.setStatus('current')
if mibBuilder.loadTexts: mallocCapabilities.setDescription('This object describes the capabilities which a client or server supports. The startTime bit indicates that allocations with a future start time are supported. The serverMobility bit indicates that allocations can be renewed or released from a server other than the one granting the original allocation. The retryAfter bit indicates support for a waiting state where the client may check back at a later time to get the status of its request.')
mallocScopeTable = MibTable((1, 3, 6, 1, 2, 1, 101, 1, 1, 2), )
if mibBuilder.loadTexts: mallocScopeTable.setStatus('current')
if mibBuilder.loadTexts: mallocScopeTable.setDescription('The (conceptual) table containing information on multicast scopes from which addresses may be allocated. Entries in this table may be dynamically discovered via some other protocol, such as MZAP, or may be statically configured, such as in an isolated network environment. Each scope is associated with a range of multicast addresses, and ranges for different rows must be disjoint.')
mallocScopeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1), ).setIndexNames((0, "MALLOC-MIB", "mallocScopeAddressType"), (0, "MALLOC-MIB", "mallocScopeFirstAddress"))
if mibBuilder.loadTexts: mallocScopeEntry.setStatus('current')
if mibBuilder.loadTexts: mallocScopeEntry.setDescription('An entry (conceptual row) containing the information on a particular multicast scope.')
mallocScopeAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: mallocScopeAddressType.setStatus('current')
if mibBuilder.loadTexts: mallocScopeAddressType.setDescription('The type of the addresses in the multicast scope range. Legal values correspond to the subset of address families for which multicast address allocation is supported.')
mallocScopeFirstAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20)))
if mibBuilder.loadTexts: mallocScopeFirstAddress.setStatus('current')
if mibBuilder.loadTexts: mallocScopeFirstAddress.setDescription('The first address in the multicast scope range. The type of this address is determined by the value of the mallocScopeAddressType object.')
mallocScopeLastAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 3), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeLastAddress.setStatus('current')
if mibBuilder.loadTexts: mallocScopeLastAddress.setDescription('The last address in the multicast scope range. The type of this address is determined by the value of the mallocScopeAddressType object.')
mallocScopeHopLimit = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(255)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeHopLimit.setStatus('current')
if mibBuilder.loadTexts: mallocScopeHopLimit.setDescription('The default IPv4 TTL or IPv6 hop limit which applications should use for groups within the scope.')
mallocScopeStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeStatus.setStatus('current')
if mibBuilder.loadTexts: mallocScopeStatus.setDescription("The status of this row, by which new entries may be created, or old entries deleted from this table. If write access is supported, the other writable objects in this table may be modified even while the status is `active'.")
mallocScopeSource = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 6), IANAscopeSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocScopeSource.setStatus('current')
if mibBuilder.loadTexts: mallocScopeSource.setDescription('The method by which this entry was learned.')
mallocScopeDivisible = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 7), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeDivisible.setStatus('current')
if mibBuilder.loadTexts: mallocScopeDivisible.setDescription('If false, the server may allocate addresses out of the entire range. If true, the server must not allocate addresses out of the entire range, but may only allocate addresses out of a subrange learned via another method. Creating or deleting a scope which is not divisible has the side effect of creating or deleting the corresponding entry in the mallocAllocRangeTable. Deleting a scope which is divisible has the side effect of deleting any corresponding entries in the mallocAllocRangeTable, and the mallocRequestTable.')
mallocScopeServerAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 8), InetAddressType().clone('unknown')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeServerAddressType.setStatus('current')
if mibBuilder.loadTexts: mallocScopeServerAddressType.setDescription('The type of the address of a multicast address allocation server to which a request may be sent.')
mallocScopeServerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 9), InetAddress().clone(hexValue="")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeServerAddress.setStatus('current')
if mibBuilder.loadTexts: mallocScopeServerAddress.setDescription('The address of a multicast address allocation server to which a request may be sent. The default value is an zero- length address, indicating that no server is known. The type of this address is determined by the value of the mallocScopeServerAddressType object.')
mallocScopeSSM = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 10), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeSSM.setStatus('current')
if mibBuilder.loadTexts: mallocScopeSSM.setDescription('Indicates whether the scope is a Source-Specific Multicast (SSM) range.')
mallocScopeStorage = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 2, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeStorage.setStatus('current')
if mibBuilder.loadTexts: mallocScopeStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
mallocScopeNameTable = MibTable((1, 3, 6, 1, 2, 1, 101, 1, 1, 3), )
if mibBuilder.loadTexts: mallocScopeNameTable.setStatus('current')
if mibBuilder.loadTexts: mallocScopeNameTable.setDescription('The (conceptual) table containing information on multicast scope names. Entries in this table may be dynamically discovered via some other protocol, such as MZAP, or may be statically configured, such as in an isolated network environment.')
mallocScopeNameEntry = MibTableRow((1, 3, 6, 1, 2, 1, 101, 1, 1, 3, 1), ).setIndexNames((0, "MALLOC-MIB", "mallocScopeAddressType"), (0, "MALLOC-MIB", "mallocScopeFirstAddress"), (1, "MALLOC-MIB", "mallocScopeNameLangName"))
if mibBuilder.loadTexts: mallocScopeNameEntry.setStatus('current')
if mibBuilder.loadTexts: mallocScopeNameEntry.setDescription('An entry (conceptual row) containing the information on a particular multicast scope name.')
mallocScopeNameLangName = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 3, 1, 1), LanguageTag().subtype(subtypeSpec=ValueSizeConstraint(1, 94)))
if mibBuilder.loadTexts: mallocScopeNameLangName.setStatus('current')
if mibBuilder.loadTexts: mallocScopeNameLangName.setDescription('The RFC 3066 language tag for the language of the scope name.')
mallocScopeNameScopeName = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 3, 1, 2), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeNameScopeName.setStatus('current')
if mibBuilder.loadTexts: mallocScopeNameScopeName.setDescription('The textual name associated with the multicast scope. The value of this object should be suitable for displaying to end-users, such as when allocating a multicast address in this scope. If the scope is an IPv4 scope, and no name is specified, the default value of this object should be the string 239.x.x.x/y with x and y replaced appropriately to describe the address and mask length associated with the scope. If the scope is an IPv6 scope, and no name is specified, the default value of this object should generically describe the scope level (e.g., site).')
mallocScopeNameDefault = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 3, 1, 3), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeNameDefault.setStatus('current')
if mibBuilder.loadTexts: mallocScopeNameDefault.setDescription('If true, indicates a preference that the name in the associated language should be used by applications if no name is available in a desired language.')
mallocScopeNameStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 3, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeNameStatus.setStatus('current')
if mibBuilder.loadTexts: mallocScopeNameStatus.setDescription("The status of this row, by which new entries may be created, or old entries deleted from this table. If write access is supported, the other writable objects in this table may be modified even while the status is `active'.")
mallocScopeNameStorage = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 3, 1, 5), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocScopeNameStorage.setStatus('current')
if mibBuilder.loadTexts: mallocScopeNameStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
mallocAllocRangeTable = MibTable((1, 3, 6, 1, 2, 1, 101, 1, 1, 4), )
if mibBuilder.loadTexts: mallocAllocRangeTable.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeTable.setDescription("The (conceptual) table containing information on subranges of addresses from which the device may allocate addresses, if it is a MAAS. If the device is a Prefix Coordinator, any ranges which the device is advertising to MAAS's will be in this table. Note that the device may be both a MAAS and a Prefix Coordinator. Address ranges for different rows must be disjoint, and must be contained with the address range of the corresponding row of the mallocScopeTable. Deleting an allocation range has the side effect of deleting any entries within that range from the mallocAddressTable.")
mallocAllocRangeEntry = MibTableRow((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1), ).setIndexNames((0, "MALLOC-MIB", "mallocScopeAddressType"), (0, "MALLOC-MIB", "mallocScopeFirstAddress"), (0, "MALLOC-MIB", "mallocAllocRangeFirstAddress"))
if mibBuilder.loadTexts: mallocAllocRangeEntry.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeEntry.setDescription('An entry (conceptual row) containing the information on a particular allocation range.')
mallocAllocRangeFirstAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 1), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20)))
if mibBuilder.loadTexts: mallocAllocRangeFirstAddress.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeFirstAddress.setDescription('The first address in the allocation range. The type of this address is determined by the value of the mallocScopeAddressType object.')
mallocAllocRangeLastAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocAllocRangeLastAddress.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeLastAddress.setDescription('The last address in the allocation range. The type of this address is determined by the value of the mallocScopeAddressType object.')
mallocAllocRangeStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocAllocRangeStatus.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeStatus.setDescription("The status of this row, by which new entries may be created, or old entries deleted from this table. If write access is supported, the other writable objects in this table may be modified even while the status is `active'.")
mallocAllocRangeSource = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 4), IANAmallocRangeSource()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAllocRangeSource.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeSource.setDescription('The means by which this entry was learned.')
mallocAllocRangeLifetime = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 5), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocAllocRangeLifetime.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeLifetime.setDescription('The number of seconds remaining in the lifetime of the (sub)range out of which addresses are being allocated. A value of 0 indicates that the range is not subject to aging.')
mallocAllocRangeMaxLeaseAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocAllocRangeMaxLeaseAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeMaxLeaseAddrs.setDescription('The maximum number of addresses which the server is willing to grant for each future request in this range. A value of 0 means that no specific limit is enforced, as long as the server has valid addresses to allocate.')
mallocAllocRangeMaxLeaseTime = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 7), Unsigned32()).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocAllocRangeMaxLeaseTime.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeMaxLeaseTime.setDescription('The maximum lifetime which the server will grant for future requests in this range. A value of 0 means that no additional limit is enforced beyond that of mallocAllocRangeLifetime.')
mallocAllocRangeNumAllocatedAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 8), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAllocRangeNumAllocatedAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeNumAllocatedAddrs.setDescription('The number of addresses in the range which have been allocated. This value can be used to determine the current address space utilization within the scoped range. This should match the total number of addresses for this scope covered by entries in the mallocAddressTable.')
mallocAllocRangeNumOfferedAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 9), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAllocRangeNumOfferedAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeNumOfferedAddrs.setDescription('The number of addresses in the range which have been offered. This number should match the sum of mallocRequestNumAddrs for all entries in the mallocRequestTable in the offered state. Together with mallocAllocRangeNumAllocatedAddrs and mallocAllocRangeNumTryingAddrs, this can be used to determine the address space utilization within the scoped range in the immediate future.')
mallocAllocRangeNumWaitingAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 10), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAllocRangeNumWaitingAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeNumWaitingAddrs.setDescription('The number of addresses in the range which have been requested, but whose state is waiting, while the server attempts to acquire more address space.')
mallocAllocRangeNumTryingAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 11), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAllocRangeNumTryingAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeNumTryingAddrs.setDescription('The number of addresses in the scope covered by entries in the mallocRequestTable in the trying state.')
mallocAllocRangeAdvertisable = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 12), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocAllocRangeAdvertisable.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeAdvertisable.setDescription('The value of this object is true if the range is eligible to be advertised to other MAASs. When the row is first created, the default value of this object is true if the scope is divisible, and is false otherwise.')
mallocAllocRangeTotalAllocatedAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAllocRangeTotalAllocatedAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeTotalAllocatedAddrs.setDescription('The approximate number of addresses in the range which have been allocated by any MAAS, as determined by a Prefix Coordinator. This object need only be present if mallocAllocRangeAdvertisable is true. If the number is unknown, a value of 0 may be reported.')
mallocAllocRangeTotalRequestedAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 14), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAllocRangeTotalRequestedAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeTotalRequestedAddrs.setDescription('The approximate number of addresses in the range for which there is potential demand among MAASs, as determined by a Prefix Coordinator. This object need only be present if mallocAllocRangeAdvertisable is true. If the number is unknown, a value of 0 may be reported.')
mallocAllocRangeStorage = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 4, 1, 15), StorageType().clone('nonVolatile')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mallocAllocRangeStorage.setStatus('current')
if mibBuilder.loadTexts: mallocAllocRangeStorage.setDescription("The storage type for this conceptual row. Conceptual rows having the value 'permanent' need not allow write-access to any columnar objects in the row.")
mallocRequestTable = MibTable((1, 3, 6, 1, 2, 1, 101, 1, 1, 5), )
if mibBuilder.loadTexts: mallocRequestTable.setStatus('current')
if mibBuilder.loadTexts: mallocRequestTable.setDescription('The (conceptual) table containing information on allocation requests, whether allocated or in progress. This table may also be used to determine which clients are responsible for high address space utilization within a given scope. Entries in this table reflect requests dynamically received by an address allocation protocol.')
mallocRequestEntry = MibTableRow((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1), ).setIndexNames((0, "MALLOC-MIB", "mallocRequestId"))
if mibBuilder.loadTexts: mallocRequestEntry.setStatus('current')
if mibBuilder.loadTexts: mallocRequestEntry.setDescription('An entry (conceptual row) containing the information on a particular allocation request.')
mallocRequestId = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: mallocRequestId.setStatus('current')
if mibBuilder.loadTexts: mallocRequestId.setDescription('An arbitrary value identifying this row.')
mallocRequestScopeAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestScopeAddressType.setStatus('current')
if mibBuilder.loadTexts: mallocRequestScopeAddressType.setDescription('The type of the first address of the scope to which the request applies. Legal values correspond to the subset of address families for which multicast address allocation is supported.')
mallocRequestScopeFirstAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestScopeFirstAddress.setStatus('current')
if mibBuilder.loadTexts: mallocRequestScopeFirstAddress.setDescription('The first address of the scope to which the request applies. This must match mallocScopeFirstAddress for some row in the mallocScopeTable. The type of this address is determined by the value of the mallocRequestScopeAddressType object.')
mallocRequestStartTime = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 4), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestStartTime.setStatus('current')
if mibBuilder.loadTexts: mallocRequestStartTime.setDescription('The number of seconds remaining before the start time of the request. A value of 0 means that the allocation is currently in effect.')
mallocRequestEndTime = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 5), Unsigned32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestEndTime.setStatus('current')
if mibBuilder.loadTexts: mallocRequestEndTime.setDescription('The number of seconds remaining before the end time of the request.')
mallocRequestNumAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 6), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestNumAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocRequestNumAddrs.setDescription('The number of addresses requested. If the addresses have been allocated, this number should match the total number of addresses for this request covered by entries in the mallocAddressTable.')
mallocRequestState = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("allocated", 1), ("offered", 2), ("waiting", 3), ("trying", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestState.setStatus('current')
if mibBuilder.loadTexts: mallocRequestState.setDescription('The state of the request. A value of allocated(1) indicates that one or more entries for this request are present in the mallocAddressTable. A value of offered(2) indicates that addresses have been offered to the client (e.g. via a MADCAP OFFER message), but the allocation has not been committed. A value of waiting(3) indicates that the allocation is blocked while the server attempts to acquire more space from which it can allocate addresses. A value of trying(4) means that no addresses have been offered to the client, but that an attempt to allocate is in progress.')
mallocRequestClientAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 8), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestClientAddressType.setStatus('current')
if mibBuilder.loadTexts: mallocRequestClientAddressType.setDescription('The type of the address of the client that (last) requested this allocation.')
mallocRequestClientAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 9), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestClientAddress.setStatus('current')
if mibBuilder.loadTexts: mallocRequestClientAddress.setDescription('The address of the client that (last) requested this allocation. The type of this address is determined by the value of the mallocRequestClientAddressType object.')
mallocRequestServerAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 10), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestServerAddressType.setStatus('current')
if mibBuilder.loadTexts: mallocRequestServerAddressType.setDescription('The type of the address of the server to which the request was (last) sent.')
mallocRequestServerAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 11), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestServerAddress.setStatus('current')
if mibBuilder.loadTexts: mallocRequestServerAddress.setDescription('The address of the server to which the request was (last) sent. The type of this address is determined by the value of the mallocRequestServerAddressType object.')
mallocRequestLeaseIdentifier = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 5, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocRequestLeaseIdentifier.setStatus('current')
if mibBuilder.loadTexts: mallocRequestLeaseIdentifier.setDescription('The Lease Identifier of this request. If the allocation mechanism in use does not use Lease Identifiers, then the value is a 0-length string.')
mallocAddressTable = MibTable((1, 3, 6, 1, 2, 1, 101, 1, 1, 6), )
if mibBuilder.loadTexts: mallocAddressTable.setStatus('current')
if mibBuilder.loadTexts: mallocAddressTable.setDescription('The (conceptual) table containing information on blocks of allocated addresses. This table may be used to map a given multicast group address to the associated request.')
mallocAddressEntry = MibTableRow((1, 3, 6, 1, 2, 1, 101, 1, 1, 6, 1), ).setIndexNames((0, "MALLOC-MIB", "mallocAddressAddressType"), (0, "MALLOC-MIB", "mallocAddressFirstAddress"))
if mibBuilder.loadTexts: mallocAddressEntry.setStatus('current')
if mibBuilder.loadTexts: mallocAddressEntry.setDescription('An entry (conceptual row) containing the information on a particular block of allocated addresses. The block of addresses covered by each entry in this table must fall within a range corresponding to an entry in the mallocAllocRangeTable.')
mallocAddressAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 6, 1, 1), InetAddressType())
if mibBuilder.loadTexts: mallocAddressAddressType.setStatus('current')
if mibBuilder.loadTexts: mallocAddressAddressType.setDescription('The type of the first address in the allocated block. Legal values correspond to the subset of address families for which multicast address allocation is supported.')
mallocAddressFirstAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 6, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(0, 20)))
if mibBuilder.loadTexts: mallocAddressFirstAddress.setStatus('current')
if mibBuilder.loadTexts: mallocAddressFirstAddress.setDescription('The first address in the allocated block. The type of this address is determined by the value of the mallocAddressAddressType object.')
mallocAddressNumAddrs = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 6, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAddressNumAddrs.setStatus('current')
if mibBuilder.loadTexts: mallocAddressNumAddrs.setDescription('The number of addresses in the allocated block.')
mallocAddressRequestId = MibTableColumn((1, 3, 6, 1, 2, 1, 101, 1, 1, 6, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mallocAddressRequestId.setStatus('current')
if mibBuilder.loadTexts: mallocAddressRequestId.setDescription('The index of the request which caused this block of addresses to be allocated. This value must match the value of mallocRequestId for some entry in the mallocRequestTable.')
madcapConfig = ObjectIdentity((1, 3, 6, 1, 2, 1, 101, 1, 2, 1))
if mibBuilder.loadTexts: madcapConfig.setStatus('current')
if mibBuilder.loadTexts: madcapConfig.setDescription('Group of objects that count various MADCAP events.')
madcapConfigExtraAllocationTime = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 1, 1), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: madcapConfigExtraAllocationTime.setStatus('current')
if mibBuilder.loadTexts: madcapConfigExtraAllocationTime.setDescription('The amount of extra time on either side of a lease which the MADCAP server allocates to allow for clock skew among clients.')
madcapConfigNoResponseDelay = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 1, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: madcapConfigNoResponseDelay.setStatus('current')
if mibBuilder.loadTexts: madcapConfigNoResponseDelay.setDescription('The amount of time the MADCAP client allows for receiving a response from a MADCAP server.')
madcapConfigOfferHold = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 1, 3), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: madcapConfigOfferHold.setStatus('current')
if mibBuilder.loadTexts: madcapConfigOfferHold.setDescription('The amount of time the MADCAP server will reserve an address for after sending an OFFER message in anticipation of receiving a REQUEST message.')
madcapConfigResponseCacheInterval = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 300))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: madcapConfigResponseCacheInterval.setStatus('current')
if mibBuilder.loadTexts: madcapConfigResponseCacheInterval.setDescription('The amount of time the MADCAP server uses to detect duplicate messages.')
madcapConfigClockSkewAllowance = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 1, 5), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: madcapConfigClockSkewAllowance.setStatus('current')
if mibBuilder.loadTexts: madcapConfigClockSkewAllowance.setDescription('The clock skew threshold used by the MADCAP server to generate Excessive Clock Skew errors.')
madcapCounters = ObjectIdentity((1, 3, 6, 1, 2, 1, 101, 1, 2, 2))
if mibBuilder.loadTexts: madcapCounters.setStatus('current')
if mibBuilder.loadTexts: madcapCounters.setDescription('A group of objects that count various MADCAP events.')
madcapTotalErrors = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapTotalErrors.setStatus('current')
if mibBuilder.loadTexts: madcapTotalErrors.setDescription('The total number of transactions for which the MADCAP server has detected an error of any type, regardless of whether the server ignored the request or generated a NAK.')
madcapRequestsDenied = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapRequestsDenied.setStatus('current')
if mibBuilder.loadTexts: madcapRequestsDenied.setDescription('The number of valid requests for which the MADCAP server could not complete an allocation, regardless of whether NAKs were sent. This corresponds to the Valid Request Could Not Be Completed error code in MADCAP.')
madcapInvalidRequests = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapInvalidRequests.setStatus('current')
if mibBuilder.loadTexts: madcapInvalidRequests.setDescription('The number of invalid requests received by the MADCAP server, regardless of whether NAKs were sent. This corresponds to the Invalid Request error code in MADCAP.')
madcapExcessiveClockSkews = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapExcessiveClockSkews.setStatus('current')
if mibBuilder.loadTexts: madcapExcessiveClockSkews.setDescription('The number of requests received by the MADCAP server with an excessive clock skew, regardless of whether NAKs were sent. This corresponds to the Excessive Clock Skew error code in MADCAP.')
madcapBadLeaseIds = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapBadLeaseIds.setStatus('current')
if mibBuilder.loadTexts: madcapBadLeaseIds.setDescription('The number of requests received by the MADCAP server with an unrecognized Lease Identifier, regardless of whether NAKs were sent. This corresponds to the Lease Identifier Not Recognized error code in MADCAP.')
madcapDiscovers = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapDiscovers.setStatus('current')
if mibBuilder.loadTexts: madcapDiscovers.setDescription('The number of DISCOVER messages received by the MADCAP server.')
madcapInforms = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapInforms.setStatus('current')
if mibBuilder.loadTexts: madcapInforms.setDescription('The number of INFORM messages received by the MADCAP server.')
madcapRequests = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapRequests.setStatus('current')
if mibBuilder.loadTexts: madcapRequests.setDescription('The number of REQUEST messages received by the MADCAP server.')
madcapRenews = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapRenews.setStatus('current')
if mibBuilder.loadTexts: madcapRenews.setDescription('The number of RENEW messages received by the MADCAP server.')
madcapReleases = MibScalar((1, 3, 6, 1, 2, 1, 101, 1, 2, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: madcapReleases.setStatus('current')
if mibBuilder.loadTexts: madcapReleases.setDescription('The number of RELEASE messages received by the MADCAP server.')
mallocConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 101, 2))
mallocCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 101, 2, 1))
mallocGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 101, 2, 2))
mallocServerReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 101, 2, 1, 1)).setObjects(("MALLOC-MIB", "mallocBasicGroup"), ("MALLOC-MIB", "mallocServerGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocServerReadOnlyCompliance = mallocServerReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mallocServerReadOnlyCompliance.setDescription('The compliance statement for multicast address allocation servers implementing the MALLOC MIB without support for read-create (i.e., in read-only mode). Such a server can then be monitored but can not be configured with this MIB.')
mallocClientReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 101, 2, 1, 2)).setObjects(("MALLOC-MIB", "mallocBasicGroup"), ("MALLOC-MIB", "mallocClientGroup"), ("MALLOC-MIB", "mallocClientScopeGroup"), ("MALLOC-MIB", "madcapClientGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocClientReadOnlyCompliance = mallocClientReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mallocClientReadOnlyCompliance.setDescription('The compliance statement for clients implementing the MALLOC MIB without support for read-create (i.e., in read- only mode). Such clients can then be monitored but can not be configured with this MIB.')
mallocPrefixCoordinatorReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 101, 2, 1, 3)).setObjects(("MALLOC-MIB", "mallocBasicGroup"), ("MALLOC-MIB", "mallocPrefixCoordinatorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocPrefixCoordinatorReadOnlyCompliance = mallocPrefixCoordinatorReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: mallocPrefixCoordinatorReadOnlyCompliance.setDescription('The compliance statement for prefix coordinators implementing the MALLOC MIB without support for read-create (i.e., in read-only mode). Such devices can then be monitored but can not be configured with this MIB.')
mallocServerFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 101, 2, 1, 4)).setObjects(("MALLOC-MIB", "mallocBasicGroup"), ("MALLOC-MIB", "mallocServerGroup"), ("MALLOC-MIB", "madcapServerGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocServerFullCompliance = mallocServerFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mallocServerFullCompliance.setDescription('The compliance statement for multicast address allocation servers implementing the MALLOC MIB with support for read- create. Such servers can then be both monitored and configured with this MIB.')
mallocClientFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 101, 2, 1, 5)).setObjects(("MALLOC-MIB", "mallocBasicGroup"), ("MALLOC-MIB", "mallocClientGroup"), ("MALLOC-MIB", "mallocClientScopeGroup"), ("MALLOC-MIB", "madcapClientGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocClientFullCompliance = mallocClientFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mallocClientFullCompliance.setDescription('The compliance statement for hosts implementing the MALLOC MIB with support for read-create. Such clients can then be both monitored and configured with this MIB.')
mallocPrefixCoordinatorFullCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 101, 2, 1, 6)).setObjects(("MALLOC-MIB", "mallocBasicGroup"), ("MALLOC-MIB", "mallocPrefixCoordinatorGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocPrefixCoordinatorFullCompliance = mallocPrefixCoordinatorFullCompliance.setStatus('current')
if mibBuilder.loadTexts: mallocPrefixCoordinatorFullCompliance.setDescription('The compliance statement for prefix coordinators implementing the MALLOC MIB with support for read-create. Such devices can then be both monitored and configured with this MIB.')
mallocBasicGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 101, 2, 2, 1)).setObjects(("MALLOC-MIB", "mallocCapabilities"), ("MALLOC-MIB", "mallocRequestScopeAddressType"), ("MALLOC-MIB", "mallocRequestScopeFirstAddress"), ("MALLOC-MIB", "mallocRequestStartTime"), ("MALLOC-MIB", "mallocRequestEndTime"), ("MALLOC-MIB", "mallocRequestNumAddrs"), ("MALLOC-MIB", "mallocRequestState"), ("MALLOC-MIB", "mallocAddressNumAddrs"), ("MALLOC-MIB", "mallocAddressRequestId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocBasicGroup = mallocBasicGroup.setStatus('current')
if mibBuilder.loadTexts: mallocBasicGroup.setDescription('The basic collection of objects providing management of IP multicast address allocation.')
mallocServerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 101, 2, 2, 2)).setObjects(("MALLOC-MIB", "mallocScopeLastAddress"), ("MALLOC-MIB", "mallocScopeHopLimit"), ("MALLOC-MIB", "mallocScopeSSM"), ("MALLOC-MIB", "mallocScopeStatus"), ("MALLOC-MIB", "mallocScopeStorage"), ("MALLOC-MIB", "mallocAllocRangeLastAddress"), ("MALLOC-MIB", "mallocAllocRangeLifetime"), ("MALLOC-MIB", "mallocAllocRangeNumAllocatedAddrs"), ("MALLOC-MIB", "mallocAllocRangeNumOfferedAddrs"), ("MALLOC-MIB", "mallocAllocRangeNumWaitingAddrs"), ("MALLOC-MIB", "mallocAllocRangeNumTryingAddrs"), ("MALLOC-MIB", "mallocAllocRangeMaxLeaseAddrs"), ("MALLOC-MIB", "mallocAllocRangeMaxLeaseTime"), ("MALLOC-MIB", "mallocAllocRangeSource"), ("MALLOC-MIB", "mallocAllocRangeStatus"), ("MALLOC-MIB", "mallocAllocRangeStorage"), ("MALLOC-MIB", "mallocScopeDivisible"), ("MALLOC-MIB", "mallocScopeSource"), ("MALLOC-MIB", "mallocScopeNameScopeName"), ("MALLOC-MIB", "mallocScopeNameDefault"), ("MALLOC-MIB", "mallocScopeNameStatus"), ("MALLOC-MIB", "mallocScopeNameStorage"), ("MALLOC-MIB", "mallocRequestClientAddressType"), ("MALLOC-MIB", "mallocRequestClientAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocServerGroup = mallocServerGroup.setStatus('current')
if mibBuilder.loadTexts: mallocServerGroup.setDescription('A collection of objects providing management of multicast address allocation in servers.')
mallocClientGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 101, 2, 2, 3)).setObjects(("MALLOC-MIB", "mallocRequestServerAddressType"), ("MALLOC-MIB", "mallocRequestServerAddress"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocClientGroup = mallocClientGroup.setStatus('current')
if mibBuilder.loadTexts: mallocClientGroup.setDescription('A collection of objects providing management of multicast address allocation in clients.')
madcapServerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 101, 2, 2, 4)).setObjects(("MALLOC-MIB", "madcapConfigClockSkewAllowance"), ("MALLOC-MIB", "madcapConfigExtraAllocationTime"), ("MALLOC-MIB", "madcapConfigOfferHold"), ("MALLOC-MIB", "madcapConfigResponseCacheInterval"), ("MALLOC-MIB", "madcapTotalErrors"), ("MALLOC-MIB", "madcapRequestsDenied"), ("MALLOC-MIB", "madcapInvalidRequests"), ("MALLOC-MIB", "madcapBadLeaseIds"), ("MALLOC-MIB", "madcapExcessiveClockSkews"), ("MALLOC-MIB", "madcapDiscovers"), ("MALLOC-MIB", "madcapInforms"), ("MALLOC-MIB", "madcapRequests"), ("MALLOC-MIB", "madcapRenews"), ("MALLOC-MIB", "madcapReleases"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    madcapServerGroup = madcapServerGroup.setStatus('current')
if mibBuilder.loadTexts: madcapServerGroup.setDescription('A collection of objects providing management of MADCAP servers.')
madcapClientGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 101, 2, 2, 5)).setObjects(("MALLOC-MIB", "mallocRequestLeaseIdentifier"), ("MALLOC-MIB", "madcapConfigNoResponseDelay"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    madcapClientGroup = madcapClientGroup.setStatus('current')
if mibBuilder.loadTexts: madcapClientGroup.setDescription('A collection of objects providing management of MADCAP clients.')
mallocClientScopeGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 101, 2, 2, 6)).setObjects(("MALLOC-MIB", "mallocScopeLastAddress"), ("MALLOC-MIB", "mallocScopeHopLimit"), ("MALLOC-MIB", "mallocScopeStatus"), ("MALLOC-MIB", "mallocScopeStorage"), ("MALLOC-MIB", "mallocScopeSource"), ("MALLOC-MIB", "mallocScopeServerAddressType"), ("MALLOC-MIB", "mallocScopeServerAddress"), ("MALLOC-MIB", "mallocScopeSSM"), ("MALLOC-MIB", "mallocScopeNameScopeName"), ("MALLOC-MIB", "mallocScopeNameDefault"), ("MALLOC-MIB", "mallocScopeNameStatus"), ("MALLOC-MIB", "mallocScopeNameStorage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocClientScopeGroup = mallocClientScopeGroup.setStatus('current')
if mibBuilder.loadTexts: mallocClientScopeGroup.setDescription('A collection of objects providing management of multicast scope information in clients.')
mallocPrefixCoordinatorGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 101, 2, 2, 7)).setObjects(("MALLOC-MIB", "mallocAllocRangeLastAddress"), ("MALLOC-MIB", "mallocAllocRangeLifetime"), ("MALLOC-MIB", "mallocAllocRangeStatus"), ("MALLOC-MIB", "mallocAllocRangeStorage"), ("MALLOC-MIB", "mallocAllocRangeSource"), ("MALLOC-MIB", "mallocAllocRangeTotalAllocatedAddrs"), ("MALLOC-MIB", "mallocAllocRangeTotalRequestedAddrs"), ("MALLOC-MIB", "mallocAllocRangeAdvertisable"), ("MALLOC-MIB", "mallocScopeLastAddress"), ("MALLOC-MIB", "mallocScopeDivisible"), ("MALLOC-MIB", "mallocScopeSource"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mallocPrefixCoordinatorGroup = mallocPrefixCoordinatorGroup.setStatus('current')
if mibBuilder.loadTexts: mallocPrefixCoordinatorGroup.setDescription('A collection of objects for managing Prefix Coordinators.')
mibBuilder.exportSymbols("MALLOC-MIB", mallocScopeNameLangName=mallocScopeNameLangName, mallocScopeDivisible=mallocScopeDivisible, malloc=malloc, mallocScopeTable=mallocScopeTable, mallocAllocRangeAdvertisable=mallocAllocRangeAdvertisable, mallocRequestState=mallocRequestState, mallocClientReadOnlyCompliance=mallocClientReadOnlyCompliance, mallocRequestClientAddress=mallocRequestClientAddress, mallocAllocRangeTable=mallocAllocRangeTable, mallocAllocRangeNumAllocatedAddrs=mallocAllocRangeNumAllocatedAddrs, mallocRequestScopeFirstAddress=mallocRequestScopeFirstAddress, madcapConfigExtraAllocationTime=madcapConfigExtraAllocationTime, mallocAddressNumAddrs=mallocAddressNumAddrs, mallocAllocRangeNumTryingAddrs=mallocAllocRangeNumTryingAddrs, madcapInforms=madcapInforms, mallocRequestLeaseIdentifier=mallocRequestLeaseIdentifier, mallocRequestScopeAddressType=mallocRequestScopeAddressType, mallocGroups=mallocGroups, mallocRequestServerAddress=mallocRequestServerAddress, mallocServerReadOnlyCompliance=mallocServerReadOnlyCompliance, mallocScopeServerAddress=mallocScopeServerAddress, mallocAllocRangeFirstAddress=mallocAllocRangeFirstAddress, mallocAllocRangeSource=mallocAllocRangeSource, mallocPrefixCoordinatorGroup=mallocPrefixCoordinatorGroup, madcapBadLeaseIds=madcapBadLeaseIds, mallocScopeHopLimit=mallocScopeHopLimit, mallocAllocRangeLastAddress=mallocAllocRangeLastAddress, mallocRequestEndTime=mallocRequestEndTime, mallocAllocRangeEntry=mallocAllocRangeEntry, mallocPrefixCoordinatorFullCompliance=mallocPrefixCoordinatorFullCompliance, mallocAllocRangeMaxLeaseAddrs=mallocAllocRangeMaxLeaseAddrs, mallocAddressTable=mallocAddressTable, mallocClientFullCompliance=mallocClientFullCompliance, mallocPrefixCoordinatorReadOnlyCompliance=mallocPrefixCoordinatorReadOnlyCompliance, madcapConfigNoResponseDelay=madcapConfigNoResponseDelay, mallocScopeEntry=mallocScopeEntry, mallocAllocRangeStatus=mallocAllocRangeStatus, mallocRequestTable=mallocRequestTable, mallocAllocRangeTotalAllocatedAddrs=mallocAllocRangeTotalAllocatedAddrs, PYSNMP_MODULE_ID=mallocMIB, madcapReleases=madcapReleases, mallocScopeStorage=mallocScopeStorage, madcapConfigClockSkewAllowance=madcapConfigClockSkewAllowance, mallocAllocRangeNumOfferedAddrs=mallocAllocRangeNumOfferedAddrs, mallocCompliances=mallocCompliances, madcapCounters=madcapCounters, mallocMIBObjects=mallocMIBObjects, mallocAllocRangeTotalRequestedAddrs=mallocAllocRangeTotalRequestedAddrs, mallocRequestId=mallocRequestId, mallocClientGroup=mallocClientGroup, mallocAddressRequestId=mallocAddressRequestId, mallocMIB=mallocMIB, madcapDiscovers=madcapDiscovers, madcapRenews=madcapRenews, mallocBasicGroup=mallocBasicGroup, madcapTotalErrors=madcapTotalErrors, mallocScopeServerAddressType=mallocScopeServerAddressType, mallocScopeSSM=mallocScopeSSM, mallocScopeNameDefault=mallocScopeNameDefault, madcapServerGroup=madcapServerGroup, madcapClientGroup=madcapClientGroup, mallocScopeNameStatus=mallocScopeNameStatus, mallocAddressEntry=mallocAddressEntry, mallocAllocRangeMaxLeaseTime=mallocAllocRangeMaxLeaseTime, mallocAddressFirstAddress=mallocAddressFirstAddress, mallocAllocRangeNumWaitingAddrs=mallocAllocRangeNumWaitingAddrs, mallocScopeNameScopeName=mallocScopeNameScopeName, mallocRequestStartTime=mallocRequestStartTime, mallocServerFullCompliance=mallocServerFullCompliance, mallocAllocRangeLifetime=mallocAllocRangeLifetime, madcapConfig=madcapConfig, mallocScopeNameEntry=mallocScopeNameEntry, mallocScopeStatus=mallocScopeStatus, mallocRequestServerAddressType=mallocRequestServerAddressType, madcapConfigOfferHold=madcapConfigOfferHold, mallocScopeNameTable=mallocScopeNameTable, madcapConfigResponseCacheInterval=madcapConfigResponseCacheInterval, madcapInvalidRequests=madcapInvalidRequests, mallocCapabilities=mallocCapabilities, mallocRequestClientAddressType=mallocRequestClientAddressType, mallocScopeSource=mallocScopeSource, mallocAllocRangeStorage=mallocAllocRangeStorage, mallocServerGroup=mallocServerGroup, madcapExcessiveClockSkews=madcapExcessiveClockSkews, mallocRequestNumAddrs=mallocRequestNumAddrs, mallocScopeLastAddress=mallocScopeLastAddress, mallocScopeFirstAddress=mallocScopeFirstAddress, mallocAddressAddressType=mallocAddressAddressType, mallocScopeNameStorage=mallocScopeNameStorage, mallocScopeAddressType=mallocScopeAddressType, mallocRequestEntry=mallocRequestEntry, mallocConformance=mallocConformance, madcapRequests=madcapRequests, madcap=madcap, madcapRequestsDenied=madcapRequestsDenied, mallocClientScopeGroup=mallocClientScopeGroup)

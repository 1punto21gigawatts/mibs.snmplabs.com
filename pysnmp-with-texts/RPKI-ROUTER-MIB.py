#
# PySNMP MIB module RPKI-ROUTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/RPKI-ROUTER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:58:29 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
InetAutonomousSystemNumber, InetAddress, InetPortNumber, InetAddressPrefixLength, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAutonomousSystemNumber", "InetAddress", "InetPortNumber", "InetAddressPrefixLength", "InetAddressType")
ObjectGroup, NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "NotificationGroup", "ModuleCompliance")
Counter32, NotificationType, Counter64, Bits, IpAddress, TimeTicks, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Gauge32, Integer32, ObjectIdentity, Unsigned32, MibIdentifier, mib_2 = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "NotificationType", "Counter64", "Bits", "IpAddress", "TimeTicks", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Gauge32", "Integer32", "ObjectIdentity", "Unsigned32", "MibIdentifier", "mib-2")
TextualConvention, DisplayString, TimeStamp = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "TimeStamp")
LongUtf8String, = mibBuilder.importSymbols("SYSAPPL-MIB", "LongUtf8String")
rpkiRtrMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 218))
rpkiRtrMIB.setRevisions(('2013-05-01 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rpkiRtrMIB.setRevisionsDescriptions(('Initial version, published as RFC 6945.',))
if mibBuilder.loadTexts: rpkiRtrMIB.setLastUpdated('201305010000Z')
if mibBuilder.loadTexts: rpkiRtrMIB.setOrganization('IETF Secure Inter-Domain Routing (SIDR) Working Group ')
if mibBuilder.loadTexts: rpkiRtrMIB.setContactInfo('Working Group Email: sidr@ietf.org Randy Bush Internet Initiative Japan 5147 Crystal Springs Bainbridge Island, WA 98110 USA Email: randy@psg.com Bert Wijnen RIPE NCC Schagen 33 3461 GL Linschoten Netherlands Email: bertietf@bwijnen.net Keyur Patel Cisco Systems 170 W. Tasman Drive San Jose, CA 95134 USA Email: keyupate@cisco.com Michael Baer SPARTA P.O. Box 72682 Davis, CA 95617 USA Email: baerm@tislabs.com ')
if mibBuilder.loadTexts: rpkiRtrMIB.setDescription("This MIB module contains management objects to support monitoring of the Resource Public Key Infrastructure (RPKI) protocol on routers. Copyright (c) 2013 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info). This version of this MIB module is part of RFC 6945; see the RFC itself for full legal notices.")
rpkiRtrNotifications = MibIdentifier((1, 3, 6, 1, 2, 1, 218, 0))
rpkiRtrObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 218, 1))
rpkiRtrConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 218, 2))
class RpkiRtrConnectionType(TextualConvention, Integer32):
    reference = 'The RPKI-Router Protocol, RFC 6810, Section 7'
    description = 'The connection type used between a router (as a client) and a cache server. The following types have been defined in RFC 6810: ssh(1) - Section 7.1; see also RFC 4252. tls(2) - Section 7.2; see also RFC 5246. tcpMD5(3) - Section 7.3; see also RFC 2385. tcpAO(4) - Section 7.4; see also RFC 5925. tcp(5) - Section 7. ipsec(6) - Section 7; see also RFC 4301. other(7) - none of the above.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))
    namedValues = NamedValues(("ssh", 1), ("tls", 2), ("tcpMD5", 3), ("tcpAO", 4), ("tcp", 5), ("ipsec", 6), ("other", 7))

rpkiRtrDiscontinuityTimer = MibScalar((1, 3, 6, 1, 2, 1, 218, 1, 1), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrDiscontinuityTimer.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrDiscontinuityTimer.setDescription('This timer represents the timestamp (value of sysUpTime) at which time any of the Counter32 objects in this MIB module encountered a discontinuity. For objects that use rpkiRtrDiscontinuityTimer to indicate discontinuity, only values received since the time indicated by rpkiRtrDiscontinuityTimer are comparable to each other. A manager should take the possibility of rollover into account when calculating difference values. In principle, that should only happen if the SNMP agent or the instrumentation for this MIB module starts or restarts.')
rpkiRtrCacheServerTable = MibTable((1, 3, 6, 1, 2, 1, 218, 1, 2), )
if mibBuilder.loadTexts: rpkiRtrCacheServerTable.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerTable.setDescription('This table lists the RPKI cache servers known to this router/system.')
rpkiRtrCacheServerTableEntry = MibTableRow((1, 3, 6, 1, 2, 1, 218, 1, 2, 1), ).setIndexNames((0, "RPKI-ROUTER-MIB", "rpkiRtrCacheServerRemoteAddressType"), (0, "RPKI-ROUTER-MIB", "rpkiRtrCacheServerRemoteAddress"), (0, "RPKI-ROUTER-MIB", "rpkiRtrCacheServerRemotePort"))
if mibBuilder.loadTexts: rpkiRtrCacheServerTableEntry.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerTableEntry.setDescription('An entry in the rpkiRtrCacheServerTable. It holds management attributes associated with one connection to a RPKI cache server. Implementers should be aware that if the rpkiRtrCacheServerRemoteAddress object exceeds 114 octets, the index values will exceed the 128 sub-identifier limit and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
rpkiRtrCacheServerRemoteAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rpkiRtrCacheServerRemoteAddressType.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerRemoteAddressType.setDescription('The network address type of the connection to this RPKI cache server. Note: Only IPv4, IPv6, and DNS support are required for read-only compliance with RFC 6945.')
rpkiRtrCacheServerRemoteAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 2), InetAddress())
if mibBuilder.loadTexts: rpkiRtrCacheServerRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerRemoteAddress.setDescription('The remote network address for this connection to this RPKI cache server. The format of the address is defined by the value of the corresponding instance of rpkiRtrCacheServerRemoteAddressType. This object matches the address type used within the local router configuration. If the address is of type dns (fqdn), then the router will resolve it at the time it connects to the cache server.')
rpkiRtrCacheServerRemotePort = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 3), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: rpkiRtrCacheServerRemotePort.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerRemotePort.setDescription('The remote port number for this connection to this RPKI cache server.')
rpkiRtrCacheServerLocalAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 4), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerLocalAddressType.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerLocalAddressType.setDescription('The network address type of the connection to this RPKI cache server. Note: Only IPv4, IPv6, and DNS support are required for read-only compliance with RFC 6945.')
rpkiRtrCacheServerLocalAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 5), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerLocalAddress.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerLocalAddress.setDescription('The local network address for this connection to this RPKI cache server. The format of the address is defined by the value of the corresponding instance of rpkiRtrCacheServerLocalAddressType. This object matches the address type used within the local router configuration. If the address is of type dns (fqdn), then the router will resolve it at the time it connects to the cache server.')
rpkiRtrCacheServerLocalPort = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 6), InetPortNumber().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerLocalPort.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerLocalPort.setDescription('The local port number for this connection to this RPKI cache server.')
rpkiRtrCacheServerPreference = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 7), Unsigned32().clone(4294967295)).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerPreference.setReference('The RPKI-Router Protocol, RFC 6810, Section 8.')
if mibBuilder.loadTexts: rpkiRtrCacheServerPreference.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerPreference.setDescription("The routers' preference for this RPKI cache server. A lower value means more preferred. If two entries have the same preference, then the order is arbitrary. In two cases, the maximum value for an Unsigned32 object should be returned for this object: - If no order is specified in the RPKI-Router configuration. - If a preference value is configured that is larger than the max value for an Unsigned32 object.")
rpkiRtrCacheServerConnectionType = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 8), RpkiRtrConnectionType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionType.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionType.setDescription('The connection type or transport security suite in use for this RPKI cache server.')
rpkiRtrCacheServerConnectionStatus = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionStatus.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionStatus.setDescription('The connection status for this entry (connection to this RPKI cache server).')
rpkiRtrCacheServerDescription = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 10), LongUtf8String()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerDescription.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerDescription.setDescription('Free form description/information for this connection to this RPKI cache server.')
rpkiRtrCacheServerMsgsReceived = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerMsgsReceived.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerMsgsReceived.setDescription('Number of messages received from this RPKI cache server via this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.')
rpkiRtrCacheServerMsgsSent = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerMsgsSent.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerMsgsSent.setDescription('Number of messages sent to this RPKI cache server via this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.')
rpkiRtrCacheServerV4ActiveRecords = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 13), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerV4ActiveRecords.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerV4ActiveRecords.setDescription('Number of active IPv4 records received from this RPKI cache server via this connection.')
rpkiRtrCacheServerV4Announcements = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerV4Announcements.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerV4Announcements.setDescription('The number of IPv4 records announced by the RPKI cache server via this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.')
rpkiRtrCacheServerV4Withdrawals = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerV4Withdrawals.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerV4Withdrawals.setDescription('The number of IPv4 records withdrawn by the RPKI cache server via this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.')
rpkiRtrCacheServerV6ActiveRecords = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 16), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerV6ActiveRecords.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerV6ActiveRecords.setDescription('Number of active IPv6 records received from this RPKI cache server via this connection.')
rpkiRtrCacheServerV6Announcements = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerV6Announcements.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerV6Announcements.setDescription('The number of IPv6 records announced by the RPKI cache server via this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.')
rpkiRtrCacheServerV6Withdrawals = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerV6Withdrawals.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerV6Withdrawals.setDescription('The number of IPv6 records withdrawn by the RPKI cache server via this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.')
rpkiRtrCacheServerLatestSerial = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerLatestSerial.setReference('RFC 1982 and RFC 6810, Section 2')
if mibBuilder.loadTexts: rpkiRtrCacheServerLatestSerial.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerLatestSerial.setDescription('The latest serial number of data received from this RPKI server on this connection. Note: this value wraps back to zero when it reaches its maximum value.')
rpkiRtrCacheServerSessionID = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerSessionID.setReference('RFC 6810, Section 2')
if mibBuilder.loadTexts: rpkiRtrCacheServerSessionID.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerSessionID.setDescription('The Session ID associated with the RPKI cache server at the other end of this connection.')
rpkiRtrCacheServerRefreshTimer = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(60, 7200))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerRefreshTimer.setReference('RFC 6810, Sections 6.1 and 8')
if mibBuilder.loadTexts: rpkiRtrCacheServerRefreshTimer.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerRefreshTimer.setDescription('The number of seconds configured for the refresh timer for this connection to this RPKI cache server.')
rpkiRtrCacheServerTimeToRefresh = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 22), Integer32()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerTimeToRefresh.setReference('RFC 6810, Section 8')
if mibBuilder.loadTexts: rpkiRtrCacheServerTimeToRefresh.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerTimeToRefresh.setDescription('The number of seconds remaining before a new refresh is performed via a Serial Query to this cache server over this connection. A negative value means that the refresh time has passed this many seconds and the refresh has not yet been completed. It will stop decrementing at the maximum negative value. Upon a completed refresh (i.e., a successful and complete response to a Serial Query) the value of this attribute will be reinitialized with the value of the corresponding rpkiRtrCacheServerRefreshTimer attribute.')
rpkiRtrCacheServerId = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 2, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerId.setReference('RFC 6810, Section 4')
if mibBuilder.loadTexts: rpkiRtrCacheServerId.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerId.setDescription('The unique ID for this connection. An implementation must make sure this ID is unique within this table. It is this ID that can be used to find entries in the rpkiRtrPrefixOriginTable that were created by announcements received on this connection from this cache server.')
rpkiRtrCacheServerErrorsTable = MibTable((1, 3, 6, 1, 2, 1, 218, 1, 3), )
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsTable.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsTable.setDescription('This table provides statistics on errors per RPKI peer connection. These can be used for debugging.')
rpkiRtrCacheServerErrorsTableEntry = MibTableRow((1, 3, 6, 1, 2, 1, 218, 1, 3, 1), )
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsTableEntry.setReference('RFC 6810, Section 10')
rpkiRtrCacheServerTableEntry.registerAugmentions(("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsTableEntry"))
rpkiRtrCacheServerErrorsTableEntry.setIndexNames(*rpkiRtrCacheServerTableEntry.getIndexNames())
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsTableEntry.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsTableEntry.setDescription('An entry in the rpkiCacheServerErrorTable. It holds management objects associated with errors codes that were received on the specified connection to a specific cache server.')
rpkiRtrCacheServerErrorsCorruptData = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsCorruptData.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsCorruptData.setDescription("The number of 'Corrupt Data' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrCacheServerErrorsInternalError = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsInternalError.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsInternalError.setDescription("The number of 'Internal Error' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrCacheServerErrorsNoData = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsNoData.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsNoData.setDescription("The number of 'No Data Available' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrCacheServerErrorsInvalidRequest = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsInvalidRequest.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsInvalidRequest.setDescription("The number of 'Invalid Request' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrCacheServerErrorsUnsupportedVersion = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsUnsupportedVersion.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsUnsupportedVersion.setDescription("The number of 'Unsupported Protocol Version' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrCacheServerErrorsUnsupportedPdu = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsUnsupportedPdu.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsUnsupportedPdu.setDescription("The number of 'Unsupported PDU Type' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrCacheServerErrorsWithdrawalUnknown = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsWithdrawalUnknown.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsWithdrawalUnknown.setDescription("The number of 'Withdrawal of Unknown Record' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrCacheServerErrorsDuplicateAnnounce = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsDuplicateAnnounce.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsDuplicateAnnounce.setDescription("The number of 'Duplicate Announcement Received' errors received from the RPKI cache server at the other end of this connection. Discontinuities are indicated by the value of rpkiRtrDiscontinuityTimer.")
rpkiRtrPrefixOriginTable = MibTable((1, 3, 6, 1, 2, 1, 218, 1, 4), )
if mibBuilder.loadTexts: rpkiRtrPrefixOriginTable.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginTable.setDescription('This table lists the prefixes that were announced by RPKI cache servers to this system. That is the prefixes and their Origin Autonomous System Number (ASN) as received by announcements via the RPKI-Router Protocol.')
rpkiRtrPrefixOriginTableEntry = MibTableRow((1, 3, 6, 1, 2, 1, 218, 1, 4, 1), ).setIndexNames((0, "RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginAddressType"), (0, "RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginAddress"), (0, "RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginMinLength"), (0, "RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginMaxLength"), (0, "RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginASN"), (0, "RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginCacheServerId"))
if mibBuilder.loadTexts: rpkiRtrPrefixOriginTableEntry.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginTableEntry.setDescription('An entry in the rpkiRtrPrefixOriginTable. This represents one announced prefix. If a cache server is removed from the local configuration, any table rows associated with that server (indicated by rpkiRtrPrefixOriginCacheServerId) are also removed from this table. Implementers should be aware that if the rpkiRtrPrefixOriginAddress object exceeds 111 octets, the index values will exceed the 128 sub-identifier limit and cannot be accessed using SNMPv1, SNMPv2c, or SNMPv3.')
rpkiRtrPrefixOriginAddressType = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 4, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rpkiRtrPrefixOriginAddressType.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginAddressType.setDescription('The network address type for this prefix. Note: Only IPv4 and IPv6 support are required for read-only compliance with RFC 6945.')
rpkiRtrPrefixOriginAddress = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 4, 1, 2), InetAddress())
if mibBuilder.loadTexts: rpkiRtrPrefixOriginAddress.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginAddress.setDescription('The network address for this prefix. The format of the address is defined by the value of the corresponding instance of rpkiRtrPrefixOriginAddressType.')
rpkiRtrPrefixOriginMinLength = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 4, 1, 3), InetAddressPrefixLength())
if mibBuilder.loadTexts: rpkiRtrPrefixOriginMinLength.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginMinLength.setDescription('The minimum prefix length allowed for this prefix.')
rpkiRtrPrefixOriginMaxLength = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 4, 1, 4), InetAddressPrefixLength())
if mibBuilder.loadTexts: rpkiRtrPrefixOriginMaxLength.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginMaxLength.setDescription('The maximum prefix length allowed for this prefix. Note, this value must be greater or equal to the value of rpkiRtrPrefixOriginMinLength.')
rpkiRtrPrefixOriginASN = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 4, 1, 5), InetAutonomousSystemNumber().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295)))
if mibBuilder.loadTexts: rpkiRtrPrefixOriginASN.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginASN.setDescription('The ASN that is authorized to announce the prefix or sub-prefixes covered by this entry.')
rpkiRtrPrefixOriginCacheServerId = MibTableColumn((1, 3, 6, 1, 2, 1, 218, 1, 4, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpkiRtrPrefixOriginCacheServerId.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginCacheServerId.setDescription('The unique ID of the connection to the cache server from which this announcement was received. That connection is identified/found by a matching value in attribute rpkiRtrCacheServerId.')
rpkiRtrCacheServerConnectionStateChange = NotificationType((1, 3, 6, 1, 2, 1, 218, 0, 1)).setObjects(("RPKI-ROUTER-MIB", "rpkiRtrCacheServerConnectionStatus"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerLatestSerial"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerSessionID"))
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionStateChange.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionStateChange.setDescription('This notification signals a change in the status of an rpkiRtrCacheServerConnection. The management agent MUST throttle the generation of consecutive rpkiRtrCacheServerConnectionStateChange notifications such that there is at least a 5 second gap between them. If more than one notification has occurred locally during that time, the most recent notification is sent at the end of the 5 second gap and the others are discarded.')
rpkiRtrCacheServerConnectionToGoStale = NotificationType((1, 3, 6, 1, 2, 1, 218, 0, 2)).setObjects(("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV4ActiveRecords"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV6ActiveRecords"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerLatestSerial"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerSessionID"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerRefreshTimer"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerTimeToRefresh"))
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionToGoStale.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerConnectionToGoStale.setDescription('This notification signals that an RPKI cache server connection is about to go stale. It is suggested that this notification is generated when the value of the rpkiRtrCacheServerTimeToRefresh attribute goes below 60 seconds. The SNMP agent MUST throttle the generation of consecutive rpkiRtrCacheServerConnectionToGoStale notifications such that there is at least a 5 second gap between them. ')
rpkiRtrCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 218, 2, 1))
rpkiRtrGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 218, 2, 2))
rpkiRtrRFC6945ReadOnlyCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 218, 2, 1, 1)).setObjects(("RPKI-ROUTER-MIB", "rpkiRtrCacheServerGroup"), ("RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginGroup"), ("RPKI-ROUTER-MIB", "rpkiRtrNotificationsGroup"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rpkiRtrRFC6945ReadOnlyCompliance = rpkiRtrRFC6945ReadOnlyCompliance.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrRFC6945ReadOnlyCompliance.setDescription("The compliance statement for the rpkiRtrMIB module. There are only read-only objects in this MIB module, so the 'ReadOnly' in the name of this compliance statement is there only for clarity and truth in advertising. There are a number of INDEX objects that cannot be represented in the form of OBJECT clauses in SMIv2, but for which there are compliance requirements. Those requirements and similar requirements for related objects are expressed below, in pseudo-OBJECT clause form, in this description: -- OBJECT rpkiRtrCacheServerRemoteAddressType -- SYNTAX InetAddressType { ipv4(1), ipv6(2), dns(16) } -- DESCRIPTION -- The MIB requires support for the IPv4, IPv6, and DNS -- InetAddressTypes for this object. -- OBJECT rpkiRtrCacheServerLocalAddressType -- SYNTAX InetAddressType { ipv4(1), ipv6(2), dns(16) } -- DESCRIPTION -- The MIB requires support for the IPv4, IPv6, and DNS -- InetAddressTypes for this object. -- OBJECT rpkiRtrPrefixOriginAddressType -- SYNTAX InetAddressType { ipv4(1), ipv6(2) } -- DESCRIPTION -- The MIB requires support for the IPv4, and IPv6 -- InetAddressTypes for this object. ")
rpkiRtrCacheServerGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 218, 2, 2, 1)).setObjects(("RPKI-ROUTER-MIB", "rpkiRtrDiscontinuityTimer"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerLocalAddressType"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerLocalAddress"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerLocalPort"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerPreference"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerConnectionType"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerConnectionStatus"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerDescription"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerMsgsReceived"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerMsgsSent"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV4ActiveRecords"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV4Announcements"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV4Withdrawals"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV6ActiveRecords"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV6Announcements"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerV6Withdrawals"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerLatestSerial"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerSessionID"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerRefreshTimer"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerTimeToRefresh"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rpkiRtrCacheServerGroup = rpkiRtrCacheServerGroup.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerGroup.setDescription('The collection of objects to monitor the RPKI peer connections.')
rpkiRtrCacheServerErrorsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 218, 2, 2, 2)).setObjects(("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsCorruptData"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsInternalError"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsNoData"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsInvalidRequest"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsUnsupportedVersion"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsUnsupportedPdu"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsWithdrawalUnknown"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerErrorsDuplicateAnnounce"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rpkiRtrCacheServerErrorsGroup = rpkiRtrCacheServerErrorsGroup.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrCacheServerErrorsGroup.setDescription('The collection of objects that may help in debugging the communication between RPKI clients and cache servers.')
rpkiRtrPrefixOriginGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 218, 2, 2, 3)).setObjects(("RPKI-ROUTER-MIB", "rpkiRtrPrefixOriginCacheServerId"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rpkiRtrPrefixOriginGroup = rpkiRtrPrefixOriginGroup.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrPrefixOriginGroup.setDescription('The collection of objects that represent the prefix(es) and their validated Origin ASes.')
rpkiRtrNotificationsGroup = NotificationGroup((1, 3, 6, 1, 2, 1, 218, 2, 2, 4)).setObjects(("RPKI-ROUTER-MIB", "rpkiRtrCacheServerConnectionStateChange"), ("RPKI-ROUTER-MIB", "rpkiRtrCacheServerConnectionToGoStale"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    rpkiRtrNotificationsGroup = rpkiRtrNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: rpkiRtrNotificationsGroup.setDescription('The set of notifications to alert an NMS of change in connections to RPKI cache servers.')
mibBuilder.exportSymbols("RPKI-ROUTER-MIB", rpkiRtrCacheServerLocalAddress=rpkiRtrCacheServerLocalAddress, rpkiRtrPrefixOriginTable=rpkiRtrPrefixOriginTable, rpkiRtrCacheServerRefreshTimer=rpkiRtrCacheServerRefreshTimer, rpkiRtrCacheServerMsgsReceived=rpkiRtrCacheServerMsgsReceived, rpkiRtrCacheServerTimeToRefresh=rpkiRtrCacheServerTimeToRefresh, PYSNMP_MODULE_ID=rpkiRtrMIB, rpkiRtrCacheServerErrorsCorruptData=rpkiRtrCacheServerErrorsCorruptData, rpkiRtrCacheServerErrorsInternalError=rpkiRtrCacheServerErrorsInternalError, rpkiRtrCacheServerTableEntry=rpkiRtrCacheServerTableEntry, rpkiRtrCacheServerRemoteAddress=rpkiRtrCacheServerRemoteAddress, rpkiRtrCacheServerMsgsSent=rpkiRtrCacheServerMsgsSent, rpkiRtrCacheServerErrorsTableEntry=rpkiRtrCacheServerErrorsTableEntry, rpkiRtrCacheServerPreference=rpkiRtrCacheServerPreference, rpkiRtrPrefixOriginAddress=rpkiRtrPrefixOriginAddress, rpkiRtrPrefixOriginGroup=rpkiRtrPrefixOriginGroup, rpkiRtrNotificationsGroup=rpkiRtrNotificationsGroup, rpkiRtrPrefixOriginCacheServerId=rpkiRtrPrefixOriginCacheServerId, rpkiRtrMIB=rpkiRtrMIB, rpkiRtrCacheServerErrorsUnsupportedPdu=rpkiRtrCacheServerErrorsUnsupportedPdu, rpkiRtrCacheServerErrorsDuplicateAnnounce=rpkiRtrCacheServerErrorsDuplicateAnnounce, rpkiRtrCacheServerV6Withdrawals=rpkiRtrCacheServerV6Withdrawals, rpkiRtrPrefixOriginTableEntry=rpkiRtrPrefixOriginTableEntry, rpkiRtrCacheServerRemoteAddressType=rpkiRtrCacheServerRemoteAddressType, rpkiRtrPrefixOriginMinLength=rpkiRtrPrefixOriginMinLength, rpkiRtrPrefixOriginASN=rpkiRtrPrefixOriginASN, rpkiRtrCacheServerV4Announcements=rpkiRtrCacheServerV4Announcements, rpkiRtrCacheServerTable=rpkiRtrCacheServerTable, rpkiRtrCacheServerSessionID=rpkiRtrCacheServerSessionID, rpkiRtrCacheServerLocalAddressType=rpkiRtrCacheServerLocalAddressType, rpkiRtrCacheServerErrorsGroup=rpkiRtrCacheServerErrorsGroup, rpkiRtrCacheServerV6ActiveRecords=rpkiRtrCacheServerV6ActiveRecords, rpkiRtrCacheServerV4Withdrawals=rpkiRtrCacheServerV4Withdrawals, rpkiRtrCacheServerRemotePort=rpkiRtrCacheServerRemotePort, rpkiRtrCacheServerId=rpkiRtrCacheServerId, rpkiRtrCacheServerErrorsTable=rpkiRtrCacheServerErrorsTable, rpkiRtrDiscontinuityTimer=rpkiRtrDiscontinuityTimer, rpkiRtrCacheServerLatestSerial=rpkiRtrCacheServerLatestSerial, rpkiRtrCacheServerErrorsInvalidRequest=rpkiRtrCacheServerErrorsInvalidRequest, rpkiRtrCacheServerConnectionToGoStale=rpkiRtrCacheServerConnectionToGoStale, rpkiRtrConformance=rpkiRtrConformance, rpkiRtrCacheServerLocalPort=rpkiRtrCacheServerLocalPort, rpkiRtrCacheServerConnectionStateChange=rpkiRtrCacheServerConnectionStateChange, rpkiRtrCacheServerErrorsWithdrawalUnknown=rpkiRtrCacheServerErrorsWithdrawalUnknown, rpkiRtrObjects=rpkiRtrObjects, rpkiRtrCompliances=rpkiRtrCompliances, rpkiRtrCacheServerV4ActiveRecords=rpkiRtrCacheServerV4ActiveRecords, rpkiRtrCacheServerErrorsNoData=rpkiRtrCacheServerErrorsNoData, rpkiRtrRFC6945ReadOnlyCompliance=rpkiRtrRFC6945ReadOnlyCompliance, rpkiRtrCacheServerConnectionStatus=rpkiRtrCacheServerConnectionStatus, rpkiRtrCacheServerV6Announcements=rpkiRtrCacheServerV6Announcements, rpkiRtrNotifications=rpkiRtrNotifications, RpkiRtrConnectionType=RpkiRtrConnectionType, rpkiRtrCacheServerGroup=rpkiRtrCacheServerGroup, rpkiRtrGroups=rpkiRtrGroups, rpkiRtrCacheServerDescription=rpkiRtrCacheServerDescription, rpkiRtrCacheServerConnectionType=rpkiRtrCacheServerConnectionType, rpkiRtrPrefixOriginAddressType=rpkiRtrPrefixOriginAddressType, rpkiRtrPrefixOriginMaxLength=rpkiRtrPrefixOriginMaxLength, rpkiRtrCacheServerErrorsUnsupportedVersion=rpkiRtrCacheServerErrorsUnsupportedVersion)

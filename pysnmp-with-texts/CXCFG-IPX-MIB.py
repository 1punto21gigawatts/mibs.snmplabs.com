#
# PySNMP MIB module CXCFG-IPX-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CXCFG-IPX-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:32:22 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ValueSizeConstraint")
cxIpx, Alias = mibBuilder.importSymbols("CXProduct-SMI", "cxIpx", "Alias")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
iso, MibIdentifier, Counter64, ModuleIdentity, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Bits, NotificationType, TimeTicks, Gauge32, Integer32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "MibIdentifier", "Counter64", "ModuleIdentity", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Bits", "NotificationType", "TimeTicks", "Gauge32", "Integer32", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
cxCfgIpx = MibIdentifier((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1))
class NetNumber(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(4, 4)
    fixedLength = 4

cxCfgIpxNumClockTicksPerSecond = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxNumClockTicksPerSecond.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxNumClockTicksPerSecond.setDescription('Identifies the number of clock ticks per second. Range of Values: None Default Value: The value is always 1 ')
cxCfgIpxPortTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2), )
if mibBuilder.loadTexts: cxCfgIpxPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortTable.setDescription('Provides configuration information for each IPX port. The table contains three default entries (rows); each row corresponds to a particular IPX port. Some of the values in a row can be modified. If more than three IPX ports are required, additional entries can be added.')
cxCfgIpxPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1), ).setIndexNames((0, "CXCFG-IPX-MIB", "cxCfgIpxPort"))
if mibBuilder.loadTexts: cxCfgIpxPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortEntry.setDescription('Provides configuration information for a particular IPX port. Some of the parameters can be modified.')
cxCfgIpxPort = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxCfgIpxPort.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPort.setDescription('Identifies the number of the IPX Port. The number is used as local index for this and the ipxStatsTable. Range of Values: From 1 to 32 Default Value: None Note: The system defines three default entries; their respective values are 1, 2, and 3.')
cxCfgIpxPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxCfgIpxPortIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortIfIndex.setDescription('Identifies the table row that contains configuration or monitoring objects for a specific type of physical interface. Range of Values: From 1 to the number of entries in the interface table. Default value: None ')
cxCfgIpxPortSubnetworkSAPAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 3), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortSubnetworkSAPAlias.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortSubnetworkSAPAlias.setDescription('Determines the name which uniquely defines the cxCfgIpxPortSubnetworkSap. Range of Values: 0 to 16 alphanumeric characters. The first character must be a letter, spaces are not allowed. Default Values: None Note: The system defines three default entries; their respective values are LAN-PORT1, CNV-PORT1, and CNV-PORT2. Related Parameter: The object must be the same as cxLanIoPortAlias of the cxLanIoPortTable, and cxFwkDestAlias in cxFwkCircuitTable. Configuration Changed: Administrative')
cxCfgIpxPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortState.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortState.setDescription('Determines the initialization state of the IPX port. Options: on (1): The port is active, transmission is possible. off (2): The port is inactive, transmission is not possible. Default Values: (1) On. For LAN ports (2) Off. For convergence ports Configuration Changed: Administrative')
cxCfgIpxPortRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2))).clone('valid')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortRowStatus.setDescription('Determines the status of the objects in a table row. Options: valid (1): Values are enabled. invalid (2): Row is flagged, after next reset the values will be disabled and the row will be deleted from the table. Default Value: (1) Valid. Values are enabled Configuration Changed: Administrative ')
cxCfgIpxPortTransportTime = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortTransportTime.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortTransportTime.setDescription('Determines the transport time, in clock ticks, for LAN or WAN links. This value is set to 1 for LAN links. WAN links may have a value of 1 or higher. One clock tick is 55 ms. Range of Values: From 1 to 30 Default Value: 1 Configuration Changed: Administrative')
cxCfgIpxPortMaxHops = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortMaxHops.setDescription('Determines the maximum number of hops a packet may take before it is discarded. Range of Values: From 1 to 16 Default Value: 16 Configuration Changed: Administrative ')
cxCfgIpxPortIntNetNum = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 8), NetNumber()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortIntNetNum.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortIntNetNum.setDescription('Determines the IPX internal network number associated with the port. The number must be entered as 8 hexadecimal characters, for example 0xAB12CD34. The x must be lowercase; the others are not case sensitive. Range of Values: 4 octets, each character ranging from 00 to FF Default Value: None Note: The system defines three default entries; their respective values are 00 00 00 0xa2, 00 00 00 0xf1, and 00 00 00 0xf2. Configuration Changed: Administrative ')
cxCfgIpxPortPerSapBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortPerSapBcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortPerSapBcast.setDescription('Determines whether periodic SAP broadcasting is active. Options: On (1): SAP broadcasting is active, and the router sends periodic SAP broadcasts to advertise its services to other locally attached networks. Off (2): SAP broadcasting is inactive. Default Value: (1) Related parameter: The frequency of the broadcast is determined by cxCfgIpxPortPerSAPTxTimer. Configuration Changed: Administrative')
cxCfgIpxPortPerRipBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortPerRipBcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortPerRipBcast.setDescription('Determines whether periodic RIP broadcasting is active. Options: on (1): RIP broadcasting is active, and the router sends periodic RIP broadcasts to advertise its services to other locally attached networks. off (2): RIP broadcasting is inactive. Default Value: on (1) Related Parameter: The frequency of the broadcast is determined by cxCfgIpxPortPerRipTxTimer. Configuration Changed: Administrative')
cxCfgIpxPortSapBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortSapBcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortSapBcast.setDescription('Determines whether the port sends a SAP broadcast in response to a SAP query sent by another router. Options: on (1): The port will respond to SAP queries. off (2): The port will not respond to SAP queries. Default Value: on (1) Configuration Changed: Administrative')
cxCfgIpxPortRipBcast = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortRipBcast.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortRipBcast.setDescription('Determines whether the port sends a RIP broadcast in response to a RIP query sent by another router. When the value is set to on, the port responds to RIP queries. Options: On (1): The port will respond to RIP queries. Off (2): The port will not respond to RIP queries. Default Value: on (1) Configuration Changed: Administrative')
cxCfgIpxPortDiagPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortDiagPackets.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortDiagPackets.setDescription('Determines whether the IPX port will respond to diagnostic packets. Options: On (1): The port will respond, and will transmit a diagnostic response packet. Off (2): The port will not respond. Default Value: off (2) Configuration Changed: Administrative. ')
cxCfgIpxPortPerRipTxTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortPerRipTxTimer.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortPerRipTxTimer.setDescription('Determines the length of time, in seconds, between periodic RIP broadcasts. Range of Values: From 1 to 3600 Default Value: 60 Configuration Changed: Administrative ')
cxCfgIpxPortPerSapTxTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortPerSapTxTimer.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortPerSapTxTimer.setDescription('Determines the length of time, in seconds, between periodic SAP broadcasts. Range of Values: From 1 to 3600 Default Value: 60 Configuration Changed: Administrative')
cxCfgIpxPortRipAgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortRipAgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortRipAgeTimer.setDescription("Determines the length of time, in seconds, that an entry can remain in the IPX port's RIP table without being updated. When the value (number of seconds) expires the entry in the RIP table is deleted. A value of 0 means aging is not used. Range of Values: From 1 to 3600 Default Value: 180 Configuration Changed: Administrative ")
cxCfgIpxPortSapAgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3600)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortSapAgeTimer.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortSapAgeTimer.setDescription("Determines the length of time (aging), in seconds, that an entry can remain in the IPX port's SAP table without being updated. When the value (number of seconds) expires the entry in the SAP table is deleted. A value of 0 means aging is not used. Range of Values: From 1 to 3600 Default Value: 180 Configuration Changed: Administrative ")
cxCfgIpxPortFrameType = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("raw-802-3", 1), ("ethernet-II", 2), ("llc-802-2", 3), ("snap", 4))).clone('raw-802-3')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortFrameType.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortFrameType.setDescription('Determines which type of framing is used for IPX header information. Framing refers to the way the header information is formatted. The format is determined by the destination IPX number. Upon receipt of data, the IPX router checks its address tables to determine which header format is used by the destination address. The first three options are used for LAN data; the fourth option is used for WAN (frame relay) destinations. Options: raw- 802-3 (1): Used for LAN data. ethernet-II (2): Used for LAN data. LLC-802-3 (3): Used for LAN data. snap (4): Used for WAN (frame relay). Default Value: raw- 802-3 (1) Configuration Changed: Administrative')
cxCfgIpxPortWatchSpoof = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortWatchSpoof.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortWatchSpoof.setDescription('Determines whether IPX Watchdog Spoofing is enabled (on). IPX Watchdog Spoofing is a software technique that limits the number of IPX Watchdog frames that are sent over a WAN; the technique is intended to decrease the use of expensive WAN lines without disturbing overall network use. If IPX Watchdog Spoofing is desired, the remote peer must also have this parameter enabled. Options: on (1): IPX Watchdog Spoofing is enabled. off (2): IPX Watchdog Spoofing is disabled. Default Value: off (2) Configuration Changed: Administrative ')
cxCfgIpxPortSpxWatchSpoof = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortSpxWatchSpoof.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortSpxWatchSpoof.setDescription('Determines whether SPX Watchdog Spoofing is enabled (on). SPX Watchdog Spoofing is a software technique that limits the number of SPX Watchdog frames that are sent over a WAN; the technique is intended to decrease the use of expensive WAN lines without disturbing overall network use. If SPX Watchdog Spoofing is desired, the remote peer must also have this parameter on. Options: On (1): SPX Watchdog Spoofing is enabled. Off (2): SPX Watchdog Spoofing is disabled. Default Value: off (2) Configuration Changed: Administrative')
cxCfgIpxPortSerialSpoof = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortSerialSpoof.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortSerialSpoof.setDescription('Determines whether Serialization Spoofing is (enabled) on. Serialization Spoofing is a software technique that limits the number of Serialization frames (they test the legal version of Novell software) that are sent over a WAN; the technique is intended to decrease the use of expensive WAN lines without disturbing overall network use. Options: on (1): Serialization Spoofing is enabled. off (2): Serialization Spoofing is disabled. Default Value: off (2) Configuration Changed: Administrative ')
cxCfgIpxPortSRSupport = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cxCfgIpxPortSRSupport.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxPortSRSupport.setDescription('Determines whether the port should support Source Routing packet. If it is enabled, the physical infterface of the port must be Token-Ring. If it is disabled, any Source Routing packet will be discarded. Default Value: disabled (2) Configuration Changed: administrative')
cxCfgIpxMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 13, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cxCfgIpxMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cxCfgIpxMibLevel.setDescription('Used to determine current MIB module release supported by the agent. Object is in decimal.')
mibBuilder.exportSymbols("CXCFG-IPX-MIB", cxCfgIpxPortFrameType=cxCfgIpxPortFrameType, cxCfgIpxPortRowStatus=cxCfgIpxPortRowStatus, cxCfgIpxPortIfIndex=cxCfgIpxPortIfIndex, cxCfgIpxPortSubnetworkSAPAlias=cxCfgIpxPortSubnetworkSAPAlias, cxCfgIpxPortSpxWatchSpoof=cxCfgIpxPortSpxWatchSpoof, cxCfgIpxPortPerSapTxTimer=cxCfgIpxPortPerSapTxTimer, cxCfgIpxNumClockTicksPerSecond=cxCfgIpxNumClockTicksPerSecond, cxCfgIpxPortRipAgeTimer=cxCfgIpxPortRipAgeTimer, cxCfgIpxPortTransportTime=cxCfgIpxPortTransportTime, cxCfgIpxPortRipBcast=cxCfgIpxPortRipBcast, cxCfgIpxPortMaxHops=cxCfgIpxPortMaxHops, cxCfgIpxPortState=cxCfgIpxPortState, cxCfgIpxPortEntry=cxCfgIpxPortEntry, NetNumber=NetNumber, cxCfgIpxMibLevel=cxCfgIpxMibLevel, cxCfgIpxPortSerialSpoof=cxCfgIpxPortSerialSpoof, cxCfgIpxPortSapBcast=cxCfgIpxPortSapBcast, cxCfgIpxPortSapAgeTimer=cxCfgIpxPortSapAgeTimer, cxCfgIpxPortIntNetNum=cxCfgIpxPortIntNetNum, cxCfgIpxPortSRSupport=cxCfgIpxPortSRSupport, cxCfgIpxPortPerRipTxTimer=cxCfgIpxPortPerRipTxTimer, cxCfgIpx=cxCfgIpx, cxCfgIpxPortWatchSpoof=cxCfgIpxPortWatchSpoof, cxCfgIpxPortPerSapBcast=cxCfgIpxPortPerSapBcast, cxCfgIpxPortTable=cxCfgIpxPortTable, cxCfgIpxPortPerRipBcast=cxCfgIpxPortPerRipBcast, cxCfgIpxPortDiagPackets=cxCfgIpxPortDiagPackets, cxCfgIpxPort=cxCfgIpxPort)

#
# PySNMP MIB module ZhoneGR303-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZhoneGR303-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:52:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
PerfCurrentCount, = mibBuilder.importSymbols("PerfHist-TC-MIB", "PerfCurrentCount")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, Counter64, MibIdentifier, ModuleIdentity, NotificationType, ObjectIdentity, Counter32, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, Gauge32, Bits, Integer32, iso = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Counter64", "MibIdentifier", "ModuleIdentity", "NotificationType", "ObjectIdentity", "Counter32", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "Gauge32", "Bits", "Integer32", "iso")
DisplayString, TextualConvention, TruthValue = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue")
zhoneSystemConfigurationDateAndTime, = mibBuilder.importSymbols("ZHONE-SYSTEM-MIB", "zhoneSystemConfigurationDateAndTime")
zhoneVoice, = mibBuilder.importSymbols("Zhone", "zhoneVoice")
ZhoneAdminString, ZhoneSlotValueOrZero, ZhoneShelfValueOrZero, ZhoneRowStatus = mibBuilder.importSymbols("Zhone-TC", "ZhoneAdminString", "ZhoneSlotValueOrZero", "ZhoneShelfValueOrZero", "ZhoneRowStatus")
zhoneGR303 = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1))
zhoneGR303.setRevisions(('2003-12-23 11:09', '2003-11-14 13:10', '2001-11-15 10:45', '2001-08-31 12:30', '2001-08-14 14:47', '2001-06-26 15:00', '2001-03-28 10:55', '2001-02-15 18:47', '2001-02-01 13:01', '2001-01-26 11:48', '2000-12-12 11:57', '2000-09-12 12:12',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: zhoneGR303.setRevisionsDescriptions(('V01.02.03 -- Add new switch type in ig table ', 'V01.02.02 -- Add new sigType in CRV table ', "V01.02.01 - Change MAX-ACCESS of ds1LogicalId to 'read-create'.", "V01.02.00 - Add ds1LogicalId to ds1LineMappingTable. - Remove 'unknown' from igCrvSignalType.", 'V01.01.06 Remove default values for igAdminStatus, igWorkingMode, igAdminStatus, ds1Role, igCrvSignalType, igCrvLocalAdminStatus', 'V01.01.05 Add notification traps to the MIB.', 'V01.01.04 - Allow to change igSwitchType and igWorkingMode after setting the IG outOfService', 'V01.01.03 - Add DEFVAL for TruthValue types.', 'V01.01.02 - change Zhone keywording for profile split', 'V01.01.01 - add the igWorkingMode to the interfaceGroupTable', 'V01.01.00 - change the igControlChannel table to add TMC and EOC primary and secondary service state.Plus add provisioning instructions as comments. ', 'V01.00.00 - Initial Release',))
if mibBuilder.loadTexts: zhoneGR303.setLastUpdated('200312231109Z')
if mibBuilder.loadTexts: zhoneGR303.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: zhoneGR303.setContactInfo(' Postal: Zhone Technologies, Inc. @ Zhone Way 7001 Oakport Street Oakland, CA 94621 USA Toll-Free: +1 877-ZHONE20 (+1 877-946-6320) Tel: +1-510-777-7000 Fax: +1-510-777-7001 E-mail: support@zhone.com')
if mibBuilder.loadTexts: zhoneGR303.setDescription("The MIB module to describe objects for GR-303. It is based on the Generic Requirements document for GR-303, referred to as GR-303-CORE. The Generic Requirements (GR) document describes Bellcore's view of the overall system functions and performance levels required when a Digital Loop Carrier System (DLC) is integrated into a Local Digital Switch (LDS). It further describes a generic interface, one particular means of interfacing a DLC Remote Digital Terminal (RDT) with the LDS. The proposed overall system requirements for Integrated Digital Loop Carrier (IDLC) systems are expressed in terms of functions, i.e., what the combination of RDT and LDS must do when connected together. These end-to-end system requirements are grouped into functional categories dealing with (1) Customer services, (2) Digital network interfaces, (3) Operations Systems interfaces, (4) Craft interfaces, and (5) Overall system capabilities. These proposed requirements do not specify or imply any specific supplier implementation. They are, therefore, termed generic system requirements.")
interfaceGroupTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1), )
if mibBuilder.loadTexts: interfaceGroupTable.setStatus('current')
if mibBuilder.loadTexts: interfaceGroupTable.setDescription("The GR-303 Interface Group Table. Minimum granularity for GR-303 provisioning is the Interface Group (IG) abstraction aka Internal Group. The Interface Group Table describes attributes for each provisioned GR-303 Interface Group and is also the base table for the augmenting Interface Group Control Channel Table. Each IG is configured manually by an administrator. Each IG entry (row) is indexed by a unique IG name. Where both active and standby Interface Groups exist, the same IG name refers to both the active and standby Interface Group. For all IG entries, the (shelf, slot) is unique. The IG name is an externally visible global name that refers to both the active and standby IGs. IG names are used for call routing and does not change during the IG lifetime. The maximum number of entries or Interface Groups is 'system-wide' and not bounded by a slot or card, but can span multiple cards and shelves. Each Interface Group is associated with the following tables: * augmenting Interface Group Control Channel row * DS1 Line Mapping Table * Line Circuit CRV Table * augmenting IG Statistics Current row * IG Statistics Interval Table * augmenting IG Statistics Total row After creating an IG entry an associated primary DS1 must be created. Without the primary DS1 an SNMP-SET operation is not allowed on any 303 tables except the deletion of the IG entry. ")
interfaceGroupEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1), ).setIndexNames((0, "ZhoneGR303-MIB", "igNameId"))
if mibBuilder.loadTexts: interfaceGroupEntry.setStatus('current')
if mibBuilder.loadTexts: interfaceGroupEntry.setDescription("An entry in the interfaceGroupTable. Indexed by igNameId. Interface Groups can span multiple cards and shelves. A row in this table is created by setting the value of igRowStatus to 'CreateAndGo', and setting the appropriate values for the columns. Since this is the base table for the following augmenting tables: * Interface Group Control Channel Table (igControlChannelTable), * Interface Group Statistics Current Table (igStatsCurrentTable), * Interface Group Statistics Total Table (igStatsTotalTable) the corresponding row in the augmenting tables must also be simultaneously created when a row in interfaceGroupTable is created. Likewise, when a row expires by setting the value of igRowStatus to 'destroy' in the interfaceGroupTable base table, the same row also expires in all augmenting tables.")
igNameId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 1), ZhoneAdminString())
if mibBuilder.loadTexts: igNameId.setStatus('current')
if mibBuilder.loadTexts: igNameId.setDescription('The Interface Group name is a unique symbolic name that is used for call routing. The maximum length for this name is 32 characters. Its value cannot be modified during the Interface Group lifetime. The igNameId is used, in conjunction with other indices, to index into other GR-303 related tables.')
igShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 2), ZhoneShelfValueOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igShelf.setReference('GR-303-CORE 12.5.10')
if mibBuilder.loadTexts: igShelf.setStatus('current')
if mibBuilder.loadTexts: igShelf.setDescription('The shelf where this Interface Group and GR-303 stack resides. Range of valid values is 0-255. A value of 0 indicates the Interface Group is not currently installed on a specific card by the GR-303 protocol stack.')
igSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 3), ZhoneSlotValueOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igSlot.setStatus('current')
if mibBuilder.loadTexts: igSlot.setDescription('The slot where this Interface Group and GR-303 stack resides. Range of valid values is 0-17. A value of 0 indicates the Interface Group is not currently installed on a specific card by the GR-303 protocol stack.')
igPeerShelf = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 4), ZhoneShelfValueOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igPeerShelf.setReference('GR-303-CORE 12.5.10')
if mibBuilder.loadTexts: igPeerShelf.setStatus('current')
if mibBuilder.loadTexts: igPeerShelf.setDescription("The shelf where this Redundancy Group's peer (or standby) resides. Peer shelf and peer slot define where this peer Interface Group and GR-303 stack resides. Range of valid values is 0-255. A peer shelf value of 0 represents a no backup configuration.")
igPeerSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 5), ZhoneSlotValueOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igPeerSlot.setStatus('current')
if mibBuilder.loadTexts: igPeerSlot.setDescription("The slot where this Interface Group's peer (or standby) resides. Peer shelf and peer slot define where this Interface Group peer and GR-303 stack resides. Range of valid values is 0-17. A peer slot value of 0 represents a no backup configuration.")
igSwitchType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lucent5Ess", 2), ("nortelDms100", 3), ("lucentGtd5", 4), ("santeraSanteraOne", 5), ("telicaPlexus9000", 6), ("taquaIx7000", 7)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSwitchType.setStatus('current')
if mibBuilder.loadTexts: igSwitchType.setDescription("The switch vendor for the Interface Group. The following switch types are defined: unknown, lucent_5ess, nortel_dms-100, lucent_gtd5, santera_santeraOne, telica_plexus9000 and taqua_ix7000 This field can only be modified after setting the igAdminStatus of the IG record to outOfService. Note: 'unknown(1)' value is no longer supported for this variable. This variable is mandatory for IG row creation.")
igPrimaryEocTmcDs1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 7), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igPrimaryEocTmcDs1IfIndex.setReference('GR-303-CORE R5-263 [1835], R5-264 [505], R5-266 [507]')
if mibBuilder.loadTexts: igPrimaryEocTmcDs1IfIndex.setStatus('current')
if mibBuilder.loadTexts: igPrimaryEocTmcDs1IfIndex.setDescription('For systems that support more than one DS1, protection switching for the Embedded Operations Channel (EOC) and a Time-slot Management Channel (TMC) is mandatory. This object refers to the ifIndex for the DS1 line supporting the active EOC and TMC path protection switching. The value for this object is equal to the value of ifIndex from the Interfaces table of MIB II (RFC 1213). Per-call time-slot assignment is accomplished over a 64 kb/s TMC that carries mesages between the LDS and RDT. These messages are used to make and break time-slot assignments between line units and DS0s on a per-call basis. A separate DS0 data link, called the Embedded Operations Channel (EOC), is used to transmit operations messages between RDT and LDS/OSs. The initial protection channel for the EOC is channel number 12 of a DS1 and channel number 24 on the same DS1 is reserved for TMC protection. Note that GR-303-CORE states that protection switching for DS1 lines is optional. GR-303-CORE R5-263 [1835] An RDT and an IDT shall support EOC and TMC/CSC path protection switching on systems supporting more than one DS1. R5-264 [505] An RDT and an IDT shall receive from a remote managing system and process retrieval of time slots for the second EOC (i.e., the initial standby) and the second TMC or CSC. R5-266 [507] An RDT and an IDT shall receive from a remote managing system and process requests to assign and to retrieve the DS1 line for the standby EOC and the standby TMC/CSC. The value will be zero if the Interface Group is not installed on a specific card.')
igSecondaryEocTmcDs1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 8), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: igSecondaryEocTmcDs1IfIndex.setReference('GR-303-CORE R5-263 [1835], R5-264 [505], R5-266 [507]')
if mibBuilder.loadTexts: igSecondaryEocTmcDs1IfIndex.setStatus('current')
if mibBuilder.loadTexts: igSecondaryEocTmcDs1IfIndex.setDescription('Refer to the description for igPrimaryEocTmcDs1IfIndex. This object refers to the ifIndex for the DS1 line supporting the standy EOC and TMC path protection switching. The value for this object is equal to the value of ifIndex from the Interfaces table of MIB II (RFC 1213). The value will be zero if the Interface Group is not installed on a specific card or no secondary DS1 is provisioned.')
igAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igAdminStatus.setReference('GR-303-CORE R5-20 [272], R5-21 [273]')
if mibBuilder.loadTexts: igAdminStatus.setStatus('current')
if mibBuilder.loadTexts: igAdminStatus.setDescription('GR-303-CORE The following requirements on status and control of the overall RDT and IDT may also be used during service assurance (e.g., placing out-of-service for maintenance purposes). Placing an RDT out-of-service means stopping it from providing access services to the customers. It does not mean cutting off communication with a managing system (eg, ZMS) that controls the RDT. R5-20 [272] An RDT shall receive from a remote managing system (eg, ZMS) and process requests to place the RDT out-of-service or in-service. An RDT shall confirm with the managing system before executing the request to place the system out-of-service. R5-21 [273] An RDT shall receive from a remote managing system (eg, ZMS) and process requests to retrieve the servic status of the RDT (in or out of service). Valid values are InService and OutOfService. When an Interface Group is in outOfService state, it is removed from the GR303 protocol stack and is no longer installed on a specific card. This field is mandatory for IG row creation.')
igOperationalStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("operable", 1), ("inoperable", 2), ("standby", 3), ("inoperableIsInProgress", 4), ("inoperableOosInProgress", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igOperationalStatus.setReference('GR-303-CORE R5-22 [274]')
if mibBuilder.loadTexts: igOperationalStatus.setStatus('current')
if mibBuilder.loadTexts: igOperationalStatus.setDescription('GR-303-CORE R5-22 [274] Upon request by a remote managing system (eg, ZMS), an RDT shall provide a managing system with the RDT operational status indicating whether it is fully inoperable and unable to provide service to the user, or it is fully operable and available for use. Valid values are operable, inoperable, standby, inoperableIsInProgress and inoperableOosInProgress. Clarification table of igAdminStatus and igOperationalStatus: igAdminStatus igOperationalStatus Description ------------- ------------------- ----------- outOfService operable not valid outOfService inoperable admin of service outOfService standby not valid inService operable normal operations inService inOperable fault inService standby normal operations')
igPeerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noStandbyConfigured", 1), ("configuredAndAvailable", 2), ("configuredAndUnavailable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igPeerStatus.setStatus('current')
if mibBuilder.loadTexts: igPeerStatus.setDescription('The status of the peer (or standby) Interface Group Valid peer status values are * noStandbyConfigured * configuredAndAvailable * configuredAndUnavailable')
igMaxConfigCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 12), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(22, 670))).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igMaxConfigCalls.setReference('GR-303-CORE 1.3.2, 4.4.2')
if mibBuilder.loadTexts: igMaxConfigCalls.setStatus('current')
if mibBuilder.loadTexts: igMaxConfigCalls.setDescription("GR-303-CORE 1.3.2 Generic IDLC Interface Requirements Summary. The Generic IDLC Interface uses a separate 64-kb/s data link (DS0-channel) to perform per-call time-slot assignments. igMaxActiveCalls refers to the maximum number of calls available to this Interface Group. This is used in conjunction with igCurrActiveCalls, the current number of calls, to provide a metric for describing utilization. Does not imply that a call has completed, but rather that the DS0 time-slot has been allocated for a call by the GR-303 interface. The DS1 frame is composed of 24 consecutively numbered (1-24) time-slots (channels or DS0s). Maximum number of active calls is the maximum number of DS1s assigned to the IG times the maximum number of channels or DS0s per DS1 less 2 or 4 channels for primary only EOC/TCM and primary/secondary EOC/TCM = ({1..28} * 24 - {2,4}) = {22..670} 28*24 equals maximum number of DS0's on a DS3, with 0 signaling channels. If you have one 28-T1 IG with no redundancy you can have 672 - 2 signaling DS0's , or 670, or 670 DS0's available for active calls. If you have a single-T1 IG, you have only 24 - 2 signaling DS0's, or 22, DS0's available for active calls.")
igCurrActiveCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 13), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 670))).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrActiveCalls.setReference('GR-303-CORE')
if mibBuilder.loadTexts: igCurrActiveCalls.setStatus('current')
if mibBuilder.loadTexts: igCurrActiveCalls.setDescription("The number of calls currently in use. igCurrActiveCalls is used in conjunction with igMaxActiveCalls, the maximum number of calls available, to provide a metric for describing current utilization. Does not imply that a call has completed, but rather that the DS0 time-slot has been allocated for a call by the GR-303 interface. The DS1 frame is composed of 24 consecutively numbered (1-24) time-slots (channels or DS0s). Maximum number of currently active calls is the maximum number of DS1s assigned to the IG times the maximum number of channels or DS0s per DS1 less 2 or 4 channels for primary only EOC/TCM and primary/secondary EOC/TCM = ({1..28} * 24 - {2,4}) = {22..670} 28*24 equals maximum number of DS0's on a DS3, with 0 signaling channels. If you have one 28-T1 IG with no redundancy you can have 672 - 2 signaling DS0's , or 670, or 670 DS0's available for active calls. If you have a single-T1 IG, you have only 24 - 2 signaling DS0's, or 22, DS0's available for active calls.")
igStatsTimeElapsed = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 899))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: igStatsTimeElapsed.setStatus('current')
if mibBuilder.loadTexts: igStatsTimeElapsed.setDescription("The number of seconds that have elapsed since the beginning of the current collection period. If, for some reason, such as an adjustment in the system's time-of-day clock, the current interval exceeds the maximum value, the agent will return the maximum value.")
igStatsValidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setUnits('intervals').setMaxAccess("readonly")
if mibBuilder.loadTexts: igStatsValidIntervals.setStatus('current')
if mibBuilder.loadTexts: igStatsValidIntervals.setDescription('The number of previous intervals for which data was collected. The value will typically be 24, 48, 72, or 96 unless the interface group was brought online within the last 6, 12, 18, or 24 hours, in which case the value will be the number of complete 15 minute intervals since the interface has been online. In the case where the agent is an SNMP transport bridging proxy or SNMP translating proxy, it is possible that some intervals are unavailable. In this case, this interval is the maximum interval number for which data is available.')
igStatsInvalidIntervals = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 96))).setUnits('intervals').setMaxAccess("readonly")
if mibBuilder.loadTexts: igStatsInvalidIntervals.setStatus('current')
if mibBuilder.loadTexts: igStatsInvalidIntervals.setDescription('The number of intervals in the range from 0 to igStatsValidIntervals for which no data is available. This object will typically be zero except in cases where the data for some intervals are not available (e.g., in proxy situations).')
igRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 17), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igRowStatus.setStatus('current')
if mibBuilder.loadTexts: igRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) igRowStatus set to'CreateAndGo', b) the following READ-CREATE object(s) without a default value (DEFVAL): * igNameId c) the following READ-CREATE objects with a DEFVAL but whose defined default value is inappropriate: * igSwitchType * igAdminStatus * igStatsPeriod. From augmented igControlChannelEntry: * igControlChannelT303 * igControlChannelT396 * igSapi0MaxOutstandingFrames, igSapi1MaxOutstandingFrames * igSapi0N200, igSapi1N200 * igSapi0T200, igSapi1T200 * igSapi0T203, igSapi1T203 * igSapiPpsMode If 'createAndGo' successfully created a new row, the RowStatus will be 'active'. Subsequent to successful row creation, the RowStatus can be retrieved via an SNMP GET and the returned RowStatus value is active. If the 'createAndGo' was unsuccessful an SNMP error will be returned and a subsequent GET on the non-existent row will also return an SNMP error of noSuchInstance. An SNMP SET with the RowStatus value of 'destroy' indicates that the agent should remove the row from service and then delete it. The same rows must also be simultaneously created or deleted in all augmenting tables: * igControlChannelTable * igStatsCurrentTable * igStatsTotalTable")
igWorkingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("passive", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igWorkingMode.setStatus('current')
if mibBuilder.loadTexts: igWorkingMode.setDescription('Working mode indicates whether the selected switch can configure the RDT using common management information service (CMIS) over the Embedded Operations Channel (EOC) channel. There are two working mode states, active and passive. In the active mode, the seleted switch can configure the RDT for Call Reference Values (CRVs) over the EOC channel. In the passive state, CRVs can only be configured locally. Even with the switch in the active state, however, RDT is required to configure CRVs. This field can only be modified after setting the igAdminStatus of the IG record to outOfService. This field is mandatory when provisioning an interfaceGroupEntry.')
igControlChannelTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2), )
if mibBuilder.loadTexts: igControlChannelTable.setStatus('current')
if mibBuilder.loadTexts: igControlChannelTable.setDescription('The GR-303 Interface Group Control Channel Table. The maximum number of entries is identical to that of the Interface Group Table. the interfaceGroupTable is the base table for this augmented table.')
igControlChannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1), )
interfaceGroupEntry.registerAugmentions(("ZhoneGR303-MIB", "igControlChannelEntry"))
igControlChannelEntry.setIndexNames(*interfaceGroupEntry.getIndexNames())
if mibBuilder.loadTexts: igControlChannelEntry.setStatus('current')
if mibBuilder.loadTexts: igControlChannelEntry.setDescription("An entry in the igControlChannelTable which AUGMENTs the base table interfaceGroupTable. There is a 1-to-1 correspondence between rows in interfaceGroupTable and rows in this table. When a row is created in the base table interfaceGroupTable, the corresponding row in the augmenting table igControlChannelTable must also be simultaneously created. A row in this table is created by setting the value of igRowStatus to 'CreateAndGo' and setting the appropriate values for the columns. Likewise, when a row expires by setting the value of igRowStatus to 'destroy' in the interfaceGroupTable base table, the same row also expires in this augmenting table.")
igControlChannelTmcPrimarySvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("outOfService", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igControlChannelTmcPrimarySvcState.setStatus('current')
if mibBuilder.loadTexts: igControlChannelTmcPrimarySvcState.setDescription('Represents conditions that are currently present at the given entity and can affect the service state. Valid values are active, standby, outOfService.')
igControlChannelTmcSecondarySvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("outOfService", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igControlChannelTmcSecondarySvcState.setStatus('current')
if mibBuilder.loadTexts: igControlChannelTmcSecondarySvcState.setDescription('Represents conditions that are currently present at the given entity and can affect the service state. Valid values are active, standby, outOfService.')
igControlChannelT303 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(700, 700), ValueRangeConstraint(1200, 1200), ValueRangeConstraint(1700, 1700), ValueRangeConstraint(2200, 2200), ValueRangeConstraint(2700, 2700), ValueRangeConstraint(3200, 3200), ValueRangeConstraint(3700, 3700), ValueRangeConstraint(4200, 4200), ValueRangeConstraint(4700, 4700), )).clone(700)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igControlChannelT303.setReference('GR-303-CORE 12.5.5.17.1')
if mibBuilder.loadTexts: igControlChannelT303.setStatus('current')
if mibBuilder.loadTexts: igControlChannelT303.setDescription('Value of the T303 timer for the Q931 protocol 12.5.5.17.1 T303 T303 is the length of time that the IDT and RDT will wait for a reply to a SETUP message. R12-446 [1315] At the IDT, the value of T303 is not user settable, its value depends on specific vendor implementations, but shall be within the range of 700 ms to 4 seconds. R12-447 [1316] The above range is not intended to define acceptable response-time performance at the RDT, where the low-load (i.e., no other external stimuli requiring call processing activity) mean response time to a SETUP message shall be no greater than 200 ms. R12-448 [1317] At the RDT, the value of T303 shall be provisionable from 700 ms through 4.7 seconds in steps of 500 ms; the default shall be 700 ms. R12-449 [1318] The above range is not intended to define acceptable response-time performance at the IDT, where the low-load (i.e., no other external stimuli requiring call processing activity) mean response time to a SETUP message shall be no greater than 500 ms. Units in milliseconds.')
igControlChannelT396 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(700, 700), ValueRangeConstraint(1700, 1700), ValueRangeConstraint(2700, 2700), ValueRangeConstraint(3700, 3700), ValueRangeConstraint(4700, 4700), ValueRangeConstraint(5700, 5700), ValueRangeConstraint(6700, 6700), ValueRangeConstraint(7700, 7700), ValueRangeConstraint(8700, 8700), ValueRangeConstraint(9700, 9700), ValueRangeConstraint(10700, 10700), ValueRangeConstraint(11700, 11700), ValueRangeConstraint(12700, 12700), ValueRangeConstraint(13700, 13700), ValueRangeConstraint(14700, 14700), )).clone(14700)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igControlChannelT396.setReference('GR-303-CORE 12.5.5.17.9')
if mibBuilder.loadTexts: igControlChannelT396.setStatus('current')
if mibBuilder.loadTexts: igControlChannelT396.setDescription('Value of the T396 timer for the Q931 protocol. 12.5.5.17.9 T396 T396 is the length of time that the RDT will wait for a reply to a SETUP message following the initial expiration of timer T303. R12-459 [1328] The value of T396 shall be provisionable from 700 ms through 14.7 seconds in steps of 1 second; the default shall be 14.7 seconds. R12-460 [1329] The above range is not intended to define acceptable response-time performance at the IDT, where the low-load (i.e., no other external stimuli requiring call processing activity) mean response time to a SETUP message shall be no greater than 500 ms. Units in milliseconds.')
igSapi0MaxOutstandingFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setUnits('frames').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi0MaxOutstandingFrames.setReference('GR-303-CORE 97a.')
if mibBuilder.loadTexts: igSapi0MaxOutstandingFrames.setStatus('current')
if mibBuilder.loadTexts: igSapi0MaxOutstandingFrames.setDescription('R5-97 [339] For each data link service access point (i.e., each SAPI=0 and SAPI=1, for both the active and standby data links, per IG), an RDT and an IDT shall receive from a remote managing system and process assignment and retrieval of the following LAPD parameters for the purpose of remote provisioning the layer 2 connection: a. Maximum number of outstanding information frames at layer 2 Range of valid values is 1-7. Default value is 7. Units in frames.')
igSapi0N200 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi0N200.setReference('GR-303-CORE 97b.')
if mibBuilder.loadTexts: igSapi0N200.setStatus('current')
if mibBuilder.loadTexts: igSapi0N200.setDescription('R5-97 [339] For each data link service access point (i.e., each SAPI=0 and SAPI=1, for both the active and standby data links, per IG), an RDT and an IDT shall receive from a remote managing system and process assignment and retrieval of the following LAPD parameters for the purpose of remote provisioning the layer 2 connection: b. Maximum number of retransmission for a frame at layer 2 (N200) 12.4.3.5.3 Maximum Number of Retransmissions (N200) R12-15 [887] The maximum number of retransmission of a frame allowed, N200 shall be user selectable within the range of 1 to 10, inclusive, with a step size of 1 and a default value of 3.')
igSapi0T200 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(100, 100), ValueRangeConstraint(150, 150), ValueRangeConstraint(200, 200), ValueRangeConstraint(250, 250), ValueRangeConstraint(300, 300), ValueRangeConstraint(350, 350), )).clone(150)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi0T200.setReference('GR-303-CORE 97c.')
if mibBuilder.loadTexts: igSapi0T200.setStatus('current')
if mibBuilder.loadTexts: igSapi0T200.setDescription('R5-97 [339] For each data link service access point (i.e., each SAPI=0 and SAPI=1, for both the active and standby data links, per IG), an RDT and an IDT shall receive from a remote managing system and process assignment and retrieval of the following LAPD parameters for the purpose of remote provisioning the layer 2 connection: c. Maximum layer 2 wait time for an acknowledgment of a transmitted frame (T200) 12.4.3.5.6 Timer T200 Timer T200 specifies the waiting period for receipt of an acknowledgment of a transmitted frame. A study of LAPD suggests that T200 should be at least as great as the time required to transmit three information frames. (See IEEE Publication CH2175-8/85/0000-0121.) Therefore, to protect against timeouts in an error-free condition, the default value of T200 for each SAP is sufficient to allow for the transmission of at least three frames. R12-18 [890] For all SAPs, the value of T200 shall be user selectable within the range of 100 ms to 350 ms, inclusive, the step size shall be 50 ms, and the default value of T200 shall be 150 ms. Units in milliseconds.')
igSapi0T203 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(20, 20), ValueRangeConstraint(30, 30), ValueRangeConstraint(40, 40), ValueRangeConstraint(50, 50), ValueRangeConstraint(60, 60), ValueRangeConstraint(70, 70), ValueRangeConstraint(80, 80), ValueRangeConstraint(90, 90), ValueRangeConstraint(100, 100), ValueRangeConstraint(110, 110), ValueRangeConstraint(120, 120), ValueRangeConstraint(130, 130), ValueRangeConstraint(140, 140), ValueRangeConstraint(150, 150), ValueRangeConstraint(160, 160), ValueRangeConstraint(170, 170), ValueRangeConstraint(180, 180), ValueRangeConstraint(190, 190), ValueRangeConstraint(200, 200), ValueRangeConstraint(210, 210), ValueRangeConstraint(220, 220), ValueRangeConstraint(230, 230), ValueRangeConstraint(240, 240), ValueRangeConstraint(250, 250), ValueRangeConstraint(260, 260), ValueRangeConstraint(270, 270), ValueRangeConstraint(280, 280), ValueRangeConstraint(290, 290), ValueRangeConstraint(300, 300), )).clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi0T203.setReference('GR-303-CORE 97d. ')
if mibBuilder.loadTexts: igSapi0T203.setStatus('current')
if mibBuilder.loadTexts: igSapi0T203.setDescription('R5-97 [339] For each data link service access point (i.e., each SAPI=0 and SAPI=1, for both the active and standby data links, per IG), an RDT and an IDT shall receive from a remote managing system and process assignment and retrieval of the following LAPD parameters for the purpose of remote provisioning the layer 2 connection: d. Maximum layer 2 idle time before connection verification is necessary (T203). 12.4.3.5.9 Timer T203 Timer T203 is used to time periods of inactivity on a data link. When T203 expires, a supervisory frame with the poll bit set to 1 is sent to determine if the other side of the interface is capable of sending and receiving frames. The use of T203 is discussed in greater detail in Section 12.6.3.3. R12-19 [891] For all SAPS, the value of T203 shall be user selectable within the range of 10 to 300 seconds, inclusive, the step size shall be 10 seconds, and the default value shall be 30 seconds. Units in seconds.')
igSapi0PpsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inhibit", 1), ("notInhibited", 2), ("notApplicable", 3))).clone('notInhibited')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi0PpsMode.setReference('GR-303-CORE 6.2.1, 12.6.2')
if mibBuilder.loadTexts: igSapi0PpsMode.setStatus('current')
if mibBuilder.loadTexts: igSapi0PpsMode.setDescription('DS1 protection switching option. Valid values are inhibit, notInhibited and notApplicable. Note that SAPI 0 and SAPI 1 (EOC-TMC) are not switched together. 6.2.1 Facility Protection Switching - Option 6.2.1.1 General The facility protection switching feature enables traffic on a failed DS1 facility to be moved to one or more alternate DS1 facilities. The procedures for implementing DS1 facility protection switching across the Generic IDLC Interface are described in Section 12.6.2. R6-75 [685] IDLC systems shall perform a facility protection switch if and only if that action will restore service. 12.6.2 DS1 Facility Protection Switch - Option DS1 facility protection is an option for IDLC systems. The procedures to be followed when facility protection switching is implemented for the Generic IDLC Interface are presented in this section (see Section 6.2.1 for general facility protection switching requirements). A facility protection switching feature enables traffic on a failed or degraded DS1 facility to be moved to one or more alternate DS1 facilities. R12-609 [1475] When an IDLC system includes the facility protection switching option, a dedicated protection facility with a 1:n arrangement shall be used for the Generic IDLC Interface. R12-625 [1491] The default for facility protection switching shall be notInhibited.')
igSapi1MaxOutstandingFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setUnits('frames').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi1MaxOutstandingFrames.setReference('GR-303-CORE 97a.')
if mibBuilder.loadTexts: igSapi1MaxOutstandingFrames.setStatus('current')
if mibBuilder.loadTexts: igSapi1MaxOutstandingFrames.setDescription('Refer to igSapi0MaxOutstandingFrames Not supported.')
igSapi1N200 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 10)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi1N200.setReference('GR-303-CORE 97b.')
if mibBuilder.loadTexts: igSapi1N200.setStatus('current')
if mibBuilder.loadTexts: igSapi1N200.setDescription('Refer to igSapi0N200 Not supported.')
igSapi1T200 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(100, 100), ValueRangeConstraint(150, 150), ValueRangeConstraint(200, 200), ValueRangeConstraint(250, 250), ValueRangeConstraint(300, 300), ValueRangeConstraint(350, 350), )).clone(150)).setUnits('milliseconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi1T200.setReference('GR-303-CORE 97c.')
if mibBuilder.loadTexts: igSapi1T200.setStatus('current')
if mibBuilder.loadTexts: igSapi1T200.setDescription('Refer to igSapi0T200')
igSapi1T203 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(10, 10), ValueRangeConstraint(20, 20), ValueRangeConstraint(30, 30), ValueRangeConstraint(40, 40), ValueRangeConstraint(50, 50), ValueRangeConstraint(60, 60), ValueRangeConstraint(70, 70), ValueRangeConstraint(80, 80), ValueRangeConstraint(90, 90), ValueRangeConstraint(100, 100), ValueRangeConstraint(110, 110), ValueRangeConstraint(120, 120), ValueRangeConstraint(130, 130), ValueRangeConstraint(140, 140), ValueRangeConstraint(150, 150), ValueRangeConstraint(160, 160), ValueRangeConstraint(170, 170), ValueRangeConstraint(180, 180), ValueRangeConstraint(190, 190), ValueRangeConstraint(200, 200), ValueRangeConstraint(210, 210), ValueRangeConstraint(220, 220), ValueRangeConstraint(230, 230), ValueRangeConstraint(240, 240), ValueRangeConstraint(250, 250), ValueRangeConstraint(260, 260), ValueRangeConstraint(270, 270), ValueRangeConstraint(280, 280), ValueRangeConstraint(290, 290), ValueRangeConstraint(300, 300), )).clone(30)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi1T203.setReference('GR-303-CORE 97d.')
if mibBuilder.loadTexts: igSapi1T203.setStatus('current')
if mibBuilder.loadTexts: igSapi1T203.setDescription('Refer to igSapi0T203')
igSapi1PpsMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inhibit", 1), ("notInhibited", 2), ("notApplicable", 3))).clone('notInhibited')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igSapi1PpsMode.setReference('GR-303-CORE 6.2.1, 12.6.2')
if mibBuilder.loadTexts: igSapi1PpsMode.setStatus('current')
if mibBuilder.loadTexts: igSapi1PpsMode.setDescription('Refer to igSapi0PpsMode')
igControlChannelEocPrimarySvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("outOfService", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igControlChannelEocPrimarySvcState.setStatus('current')
if mibBuilder.loadTexts: igControlChannelEocPrimarySvcState.setDescription('Represents conditions that are currently present at the given entity and can affect the service state. Valid values are active, standby, outOfService.')
igControlChannelEocSecondarySvcState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("standby", 2), ("outOfService", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igControlChannelEocSecondarySvcState.setStatus('current')
if mibBuilder.loadTexts: igControlChannelEocSecondarySvcState.setDescription('Represents conditions that are currently present at the given entity and can affect the service state. Valid values are active, standby, outOfService.')
igStatsCurrentTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3), )
if mibBuilder.loadTexts: igStatsCurrentTable.setStatus('current')
if mibBuilder.loadTexts: igStatsCurrentTable.setDescription('The GR-303 Interface Group Statistics Current Table. The GR-303 Interface Group Statistics current table contains various statistics being collected for the current 15 minute interval. The maximum number of entries is identical to that of the Interface Group Table. the interfaceGroupTable is the base table for this augmented table.')
igStatsCurrentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1), )
interfaceGroupEntry.registerAugmentions(("ZhoneGR303-MIB", "igStatsCurrentEntry"))
igStatsCurrentEntry.setIndexNames(*interfaceGroupEntry.getIndexNames())
if mibBuilder.loadTexts: igStatsCurrentEntry.setStatus('current')
if mibBuilder.loadTexts: igStatsCurrentEntry.setDescription("An entry in the igStatsCurrentTable which AUGMENTs the base table interfaceGroupTable. There is a 1-to-1 correspondence between rows in interfaceGroupTable and rows in this table. When a row is created in the base table interfaceGroupTable, the corresponding row in the augmenting table igStatsCurrentTable must also be simultaneously created. A row in this table is created by setting the value of igRowStatus to 'CreateAndGo' and setting the appropriate values for the columns. Likewise, when a row expires by setting the value of igRowStatus to 'destroy' in the interfaceGroupTable base table, the same row also expires in this augmenting table.")
igCurrentOutboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 1), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentOutboundCalls.setStatus('current')
if mibBuilder.loadTexts: igCurrentOutboundCalls.setDescription('The number of outbound calls completed.')
igCurrentInboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 2), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentInboundCalls.setStatus('current')
if mibBuilder.loadTexts: igCurrentInboundCalls.setDescription('The number of inbound calls completed.')
igCurrentOutboundCallsBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 3), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentOutboundCallsBlocked.setStatus('current')
if mibBuilder.loadTexts: igCurrentOutboundCallsBlocked.setDescription('The number of outbound calls that were blocked due to no available time-slot.')
igCurrentGR303ProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 4), PerfCurrentCount()).setUnits('errors').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentGR303ProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: igCurrentGR303ProtocolErrors.setDescription('The number of GR-303 Protocol errors.')
igCurrentTMCLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 5), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentTMCLapdSent.setStatus('current')
if mibBuilder.loadTexts: igCurrentTMCLapdSent.setDescription('The number of LAPD frames sent on the Time-slot Management Channel (TMC).')
igCurrentTMCLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 6), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentTMCLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: igCurrentTMCLapdRcvd.setDescription('The number LAPD frames received on the Time-slot Management Channel (TMC).')
igCurrentTMCLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 7), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentTMCLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: igCurrentTMCLapdRcvdErrs.setDescription('The number LAPD frames received in error on the Time-slot Management Channel (TMC).')
igCurrentEOCLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 8), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentEOCLapdSent.setStatus('current')
if mibBuilder.loadTexts: igCurrentEOCLapdSent.setDescription('The number of LAPD frames sent on the Embedded Operations Channel (EOC).')
igCurrentEOCLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 9), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentEOCLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: igCurrentEOCLapdRcvd.setDescription('The number of LAPD frames received on the Embedded Operations Channel (EOC).')
igCurrentEOCLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 3, 1, 10), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igCurrentEOCLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: igCurrentEOCLapdRcvdErrs.setDescription('The number of LAPD frames received in error on the Embedded Operations Channel (EOC).')
igStatsIntervalTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4), )
if mibBuilder.loadTexts: igStatsIntervalTable.setStatus('current')
if mibBuilder.loadTexts: igStatsIntervalTable.setDescription('GR-303 Interface Group Statistics Interval Table. The GR-303 Interface Group Statistics Interval Table contains various statistics collected by each Interface Group over the previous 6. 12. 18, or 24 hours of operation. The past 6, 12, 18, or 24 hours are broken into 24, 48, 72, or 96 completed 15 minute intervals. Each row in this table represents one such interval (identified by igIntervalNumber) for one specific instance (identified by igIntervalIndex).')
igStatsIntervalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1), ).setIndexNames((0, "ZhoneGR303-MIB", "igNameId"), (0, "ZhoneGR303-MIB", "igIntervalNumber"))
if mibBuilder.loadTexts: igStatsIntervalEntry.setStatus('current')
if mibBuilder.loadTexts: igStatsIntervalEntry.setDescription('An entry in the igStatsIntervalTable. Indexed by (igNameId, igIntervalNumber).')
igIntervalNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 96)))
if mibBuilder.loadTexts: igIntervalNumber.setStatus('current')
if mibBuilder.loadTexts: igIntervalNumber.setDescription('A number between 1 and 96, where 1 is the most recently completed 15 minute interval and 96 is the 15 minutes interval completed 23 hours and 45 minutes prior to interval 1. If a 6, 12, or 18 hour period is selected, the max interval number will be 24, 48, or 72.')
igIntervalOutboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 2), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalOutboundCalls.setStatus('current')
if mibBuilder.loadTexts: igIntervalOutboundCalls.setDescription('The number of outbound calls completed.')
igIntervalInboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 3), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalInboundCalls.setStatus('current')
if mibBuilder.loadTexts: igIntervalInboundCalls.setDescription('The number of inbound calls completed.')
igIntervalOutboundCallsBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 4), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalOutboundCallsBlocked.setStatus('current')
if mibBuilder.loadTexts: igIntervalOutboundCallsBlocked.setDescription('The number of outbound calls that were blocked due to no available time-slot.')
igIntervalGR303ProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 5), PerfCurrentCount()).setUnits('errors').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalGR303ProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: igIntervalGR303ProtocolErrors.setDescription('The number of GR-303 Protocol errors.')
igIntervalTMCLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 6), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalTMCLapdSent.setStatus('current')
if mibBuilder.loadTexts: igIntervalTMCLapdSent.setDescription('The number of LAPD frames sent on the Time-slot Management Channel (TMC).')
igIntervalTMCLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 7), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalTMCLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: igIntervalTMCLapdRcvd.setDescription('The number LAPD frames received on the Time-slot Management Channel (TMC).')
igintervalTMCLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 8), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igintervalTMCLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: igintervalTMCLapdRcvdErrs.setDescription('The number LAPD frames received in error on the Time-slot Management Channel (TMC).')
igIntervalEOCLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 9), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalEOCLapdSent.setStatus('current')
if mibBuilder.loadTexts: igIntervalEOCLapdSent.setDescription('The number of LAPD frames sent on the Embedded Operations Channel (EOC).')
igIntervalEOCLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 10), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalEOCLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: igIntervalEOCLapdRcvd.setDescription('The number of LAPD frames received on the Embedded Operations Channel (EOC).')
igIntervalEOCLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 11), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalEOCLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: igIntervalEOCLapdRcvdErrs.setDescription('The number of LAPD frames received in error on the Embedded Operations Channel (EOC).')
igIntervalValidData = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 4, 1, 12), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: igIntervalValidData.setStatus('current')
if mibBuilder.loadTexts: igIntervalValidData.setDescription('This variable indicates if the data for this interval is valid.')
igStatsTotalTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5), )
if mibBuilder.loadTexts: igStatsTotalTable.setStatus('current')
if mibBuilder.loadTexts: igStatsTotalTable.setDescription('GR-303 Interface Group Statistics Total Table. The GR-303 Interface Group Statistics Total Table contains the cumulative sum of the various statistics for the 24 hour period preceding the current interval. The maximum number of entries is identical to that of the Interface Group Table. The interfaceGroupTable is the base table for this augmented table.')
igStatsTotalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1), )
interfaceGroupEntry.registerAugmentions(("ZhoneGR303-MIB", "igStatsTotalEntry"))
igStatsTotalEntry.setIndexNames(*interfaceGroupEntry.getIndexNames())
if mibBuilder.loadTexts: igStatsTotalEntry.setStatus('current')
if mibBuilder.loadTexts: igStatsTotalEntry.setDescription("An entry in the igStatsTotalTable which AUGMENTs the base table interfaceGroupTable. There is a 1-to-1 correspondence between rows in interfaceGroupTable and rows in this table. When a row is created in the base table interfaceGroupTable, the corresponding row in the augmenting table igStatsTotalTable must also be simultaneously created. A row in this table is created by setting the value of igRowStatus to 'CreateAndGo' and setting the appropriate values for the columns. Likewise, when a row expires by setting the value of igRowStatus to 'destroy' in the interfaceGroupTable base table, the same row also expires in this augmenting table.")
igTotalOutboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 1), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalOutboundCalls.setStatus('current')
if mibBuilder.loadTexts: igTotalOutboundCalls.setDescription('The number of outbound calls completed.')
igTotalInboundCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 2), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalInboundCalls.setStatus('current')
if mibBuilder.loadTexts: igTotalInboundCalls.setDescription('The number of inbound calls completed.')
igTotalOutboundCallsBlocked = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 3), PerfCurrentCount()).setUnits('calls').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalOutboundCallsBlocked.setStatus('current')
if mibBuilder.loadTexts: igTotalOutboundCallsBlocked.setDescription('The number of outbound calls that were blocked due to no available time-slot.')
igTotalGR303ProtocolErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 4), PerfCurrentCount()).setUnits('errors').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalGR303ProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: igTotalGR303ProtocolErrors.setDescription('The number of GR-303 Protocol errors.')
igTotalTMCLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 5), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalTMCLapdSent.setStatus('current')
if mibBuilder.loadTexts: igTotalTMCLapdSent.setDescription('The number of LAPD frames sent on the Time-slot Management Channel (TMC).')
igTotalTMCLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 6), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalTMCLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: igTotalTMCLapdRcvd.setDescription('The number LAPD frames received on the Time-slot Management Channel (TMC).')
igTotalTMCLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 7), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalTMCLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: igTotalTMCLapdRcvdErrs.setDescription('The number LAPD frames received in error on the Time-slot Management Channel (TMC).')
igTotalEOCLapdSent = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 8), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalEOCLapdSent.setStatus('current')
if mibBuilder.loadTexts: igTotalEOCLapdSent.setDescription('The number of LAPD frames sent on the Embedded Operations Channel (EOC).')
igTotalEOCLapdRcvd = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 9), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalEOCLapdRcvd.setStatus('current')
if mibBuilder.loadTexts: igTotalEOCLapdRcvd.setDescription('The number of LAPD frames received on the Embedded Operations Channel (EOC).')
igTotalEOCLapdRcvdErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 5, 1, 10), PerfCurrentCount()).setUnits('frames').setMaxAccess("readonly")
if mibBuilder.loadTexts: igTotalEOCLapdRcvdErrs.setStatus('current')
if mibBuilder.loadTexts: igTotalEOCLapdRcvdErrs.setDescription('The number of LAPD frames received in error on the Embedded Operations Channel (EOC).')
ds1LineMappingTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6), )
if mibBuilder.loadTexts: ds1LineMappingTable.setReference('GR-303-CORE R12-508 [1377]')
if mibBuilder.loadTexts: ds1LineMappingTable.setStatus('current')
if mibBuilder.loadTexts: ds1LineMappingTable.setDescription("The GR-303 DS1 Line Mapping Table. The DS1 Line Mapping Table describes attributes for DS1 Line Termination and the mapping between the Interface Group and DS1 standard MIB (rfc2495). The maximum number of entries is determined by the maximum number of DS1 lines for the Interface Group, which is 28. Each Interface Group is associated with a ds1LineMapping Table indexed by (IG name, line group ID, ds1 channel number), where line group ID is either a physical T1 line group ID (eg, Dibrizzi) or a channelized DS3. DS1 channel number is one of 28 DS1s associated with a channelized DS3, that is being provisioned to the Interface Group. If line group ID is a T1, the associated DS1 channel number is 1. GR-303-CORE R12-508 [1377] The RDT is limited to a maximum of 28 DS1s per IG and each IG can support up to a maximum of 2048 two-wire terminations toward the customer's premises. Once a primary or secondary DS1 is provisioned for an IG it cannot be modified or deleted.")
ds1LineMappingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6, 1), ).setIndexNames((0, "ZhoneGR303-MIB", "igNameId"), (0, "ZhoneGR303-MIB", "dsnLgId"), (0, "ZhoneGR303-MIB", "ds1ChannelNumber"))
if mibBuilder.loadTexts: ds1LineMappingEntry.setStatus('current')
if mibBuilder.loadTexts: ds1LineMappingEntry.setDescription("An entry in the ds1LineMappingTable. Indexed by (igNameId, dsnLgId, ds1ChannelNumber). A row in this table is created by setting the value of ds1LineMappingRowStatus to 'CreateAndGo', and setting the appropriate values for the columns.")
dsnLgId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: dsnLgId.setStatus('current')
if mibBuilder.loadTexts: dsnLgId.setDescription('The dsnLgId object identifies the line group entry id of either a physical T1 line group ID (eg, Dibrizzi) or a channelized DS3. If LgId represents a physical T1, the DS1 channel number is 1. Else, the DS1 channel number is one of 28 DS1s associated with a channelized DS3, that is being provisioned to the Interface Group. The range for dsnLgId is 1..2147483647 that is obtained by the nextLineGroupId field.')
ds1ChannelNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 28)))
if mibBuilder.loadTexts: ds1ChannelNumber.setStatus('current')
if mibBuilder.loadTexts: ds1ChannelNumber.setDescription('Identifies the DS1 for the channelized DS3 or physical T1. The ds1ChannelNumber for a T1 is 1, otherwise it refers to the channel number of the DS3 port which contains the DS1.')
ds1Role = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("payload", 1), ("secondary", 2), ("primary", 3)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ds1Role.setStatus('current')
if mibBuilder.loadTexts: ds1Role.setDescription('The role the DS1 line assumes. Valid values are payload, secondary, primary. This field is mandatory for ds1LineMapping row creation.')
ds1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds1IfIndex.setStatus('current')
if mibBuilder.loadTexts: ds1IfIndex.setDescription('The ifIndex for the DS1 line. The value for this object is equal to the value of ifIndex from the Interfaces table of MIB II (RFC 1213). The value will be zero when the Interface Group is not installed on a specific card by the GR-303 protocol stack.')
ds1LineMappingRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6, 1, 5), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ds1LineMappingRowStatus.setStatus('current')
if mibBuilder.loadTexts: ds1LineMappingRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) ds1LineMappingRowStatus set to'CreateAndGo', b) READ-CREATE objects with a DEFVAL but whose defined default value is inappropriate: * ds1Role See igRowStatus description for RowStatus semantics.")
ds1LogicalId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 6, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 28))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: ds1LogicalId.setStatus('current')
if mibBuilder.loadTexts: ds1LogicalId.setDescription('This is an unique number to identify each physical DS1 within an Interface Group between RDT and IDT. The DS1 Logical ID must have a value in the range of 1..28. The value 1 is reserved for the primary DS1 and cannot be used by any other DS1s. This field is mandatory for ds1LineMappingEntry row creation.')
igCrvTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7), )
if mibBuilder.loadTexts: igCrvTable.setReference('GR-303-CORE R12-508 [1377]')
if mibBuilder.loadTexts: igCrvTable.setStatus('current')
if mibBuilder.loadTexts: igCrvTable.setDescription("The GR-303 CRV Table. The GR-303-CORE interface uses the Call Reference Value (CRV) in its Timeslot Management Channel (TMC) to dynamically assign DS0s to access circuits on a call-by-call basis; i.e., if an access circuit is not assigned a CRV, it will never be assigned a DS0 between the IDT and IG. The maximum number of entries is specified by the maximum number of subscribers or CRVs for the Interface Group, which is 2048. Each Interface Group is associated with an igCrvTable indexed by (shelf, slot, IG name, CRV). GR-303-CORE R12-508 [1377] The RDT is limited to a maximum of 28 DS1s per IG and each IG can support up to a maximum of 2048 two-wire terminations toward the customer's premises.")
igCrvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1), ).setIndexNames((0, "ZhoneGR303-MIB", "igNameId"), (0, "ZhoneGR303-MIB", "igCrv"))
if mibBuilder.loadTexts: igCrvEntry.setStatus('current')
if mibBuilder.loadTexts: igCrvEntry.setDescription("An entry in the igCrvTable. Indexed by (igNameId, igCrv). A row in this table is created by setting the value of igCrvRowStatus to 'CreateAndGo', and setting the appropriate values for the columns.")
igCrv = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2048)))
if mibBuilder.loadTexts: igCrv.setStatus('current')
if mibBuilder.loadTexts: igCrv.setDescription('The Call Reference Value (CRV) for the line. Indexes into the igCrvTable. Valid range is 1-2048.')
igCrvLocalAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igCrvLocalAdminState.setStatus('current')
if mibBuilder.loadTexts: igCrvLocalAdminState.setDescription('The admin state on the local (RDT) side. Valid values are inService and OutOfService. This field is mandatory for IG CRV row creation.')
igCrvRemoteAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("outOfService", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igCrvRemoteAdminState.setStatus('current')
if mibBuilder.loadTexts: igCrvRemoteAdminState.setDescription('The admin state on the remote (IDT) side. Valid values are inService and OutOfService. For CRVs assocated with an IG with igWorkingMode set to passive, the remote-admin-state of a crv is set to inservice. For igWorkingMode of active, the default value for remote-admin-state of a crv is set to outofservice. It will then be changed to inservice when the switch provisions this crv. ')
igCrvOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1, 4), Bits().clone(namedValues=NamedValues(("up", 0), ("fault", 1), ("manualOos", 2), ("removedFromServiceBySwitch", 3), ("unEquipped", 4), ("notConnected", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igCrvOperStatus.setStatus('current')
if mibBuilder.loadTexts: igCrvOperStatus.setDescription("The line operational status is the composition (ie, logical OR'ing) of definitions from GR-303-CORE. Some of them are service affecting, some of them don't affect the ability of service. Valid states are: * up, line is operational * fault (FLT), a fault condition * manualOos (MTCE), object is manually taken OOS for maintenance purpose * removedFromServiceBySwitch (SWTCH), entity removed from service by switch * UnEquipped - default state when new CRV entry is added * notConnected, line is not connected")
igCrvTmcState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inService", 1), ("permanentSignal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: igCrvTmcState.setStatus('current')
if mibBuilder.loadTexts: igCrvTmcState.setDescription('Time-slot Management Channel (TMC) state indicates when the line is off-hook. Valid states are inService and permanentSignal. The default value is inService. A line in a permanent signal condition initiates call clearing, during which time the RDT disconnects the RDT line unit from the DS0 (time-slot) assigned to the call, and continues to monitor the line. The RDT will report the return to on-hook status.')
igCrvSignalType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4, 5))).clone(namedValues=NamedValues(("loopstart", 2), ("groundstart", 3), ("loopreversebattery", 4), ("electronicbusinessset", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igCrvSignalType.setStatus('current')
if mibBuilder.loadTexts: igCrvSignalType.setDescription("Signaling type specifies the signaling method currently used by this crv. Valid types are loop start,ground start or loop reverse battery for analog line and electronic business set. This value is set by the voice switch via the EOC or in the subscriber record. Note that 'unknown(1)' is no longer a supported option. This field is mandatory for IG CRV row creation.")
igCrvRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 7, 1, 7), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: igCrvRowStatus.setStatus('current')
if mibBuilder.loadTexts: igCrvRowStatus.setDescription("Used to control row creation and deletion. A row in this table is created using a single SNMP SET request with varbinds for: a) igCrvRowStatus set to'CreateAndGo', b) the following READ-CREATE object(s) without a default value (DEFVAL): igCrvLineState c) READ-CREATE objects with a DEFVAL but whose defined default value is inappropriate: * igCrvSignalType See igRowStatus description for RowStatus semantics.")
gr303Traps = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8))
if mibBuilder.loadTexts: gr303Traps.setStatus('current')
if mibBuilder.loadTexts: gr303Traps.setDescription('All the Zhone trap notifications for GR303 managed objectes will be defined under gr303Traps.')
gr303TrapsPrefix = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0))
if mibBuilder.loadTexts: gr303TrapsPrefix.setStatus('current')
if mibBuilder.loadTexts: gr303TrapsPrefix.setDescription('This is the 0 prefix which is required for all GR303 traps defined in SNMPv2.')
igOperStatusChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 1)).setObjects(("ZhoneGR303-MIB", "igAdminStatus"), ("ZhoneGR303-MIB", "igOperationalStatus"))
if mibBuilder.loadTexts: igOperStatusChange.setStatus('current')
if mibBuilder.loadTexts: igOperStatusChange.setDescription('A notification is sent when the operating status of the IG changes.')
igTmcPrimaryStateChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 2)).setObjects(("ZhoneGR303-MIB", "igControlChannelTmcPrimarySvcState"))
if mibBuilder.loadTexts: igTmcPrimaryStateChange.setStatus('current')
if mibBuilder.loadTexts: igTmcPrimaryStateChange.setDescription('A notification is sent when the status of the TMC channel on the primary DS1 changes. ')
igTmcSecondaryStateChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 3)).setObjects(("ZhoneGR303-MIB", "igControlChannelTmcSecondarySvcState"))
if mibBuilder.loadTexts: igTmcSecondaryStateChange.setStatus('current')
if mibBuilder.loadTexts: igTmcSecondaryStateChange.setDescription('A notification is sent when the status of the TMC channel on the sedondary DS1 changes. ')
igEocPrimaryStateChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 4)).setObjects(("ZhoneGR303-MIB", "igControlChannelEocPrimarySvcState"))
if mibBuilder.loadTexts: igEocPrimaryStateChange.setStatus('current')
if mibBuilder.loadTexts: igEocPrimaryStateChange.setDescription('A notification is sent when the status of the EOC channel on the primary DS1 changes. ')
igEocSecondaryStateChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 5)).setObjects(("ZhoneGR303-MIB", "igControlChannelEocSecondarySvcState"))
if mibBuilder.loadTexts: igEocSecondaryStateChange.setStatus('current')
if mibBuilder.loadTexts: igEocSecondaryStateChange.setDescription('A notification is sent when the status of the EOC channel on the secondary DS1 changes.')
igCrvRemoteStateChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 6)).setObjects(("ZhoneGR303-MIB", "igCrvLocalAdminState"), ("ZhoneGR303-MIB", "igCrvRemoteAdminState"), ("ZhoneGR303-MIB", "igCrvOperStatus"))
if mibBuilder.loadTexts: igCrvRemoteStateChange.setStatus('current')
if mibBuilder.loadTexts: igCrvRemoteStateChange.setDescription('A notification is sent when switch removes a CRV from operation or restores the CRV to opearation.')
igCrvTmcStateChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 7)).setObjects(("ZhoneGR303-MIB", "igCrvTmcState"))
if mibBuilder.loadTexts: igCrvTmcStateChange.setStatus('current')
if mibBuilder.loadTexts: igCrvTmcStateChange.setDescription('A notification is sent when igCrvTmcState changes.')
igSystemTimeChange = NotificationType((1, 3, 6, 1, 4, 1, 5504, 4, 3, 1, 8, 0, 8)).setObjects(("ZHONE-SYSTEM-MIB", "zhoneSystemConfigurationDateAndTime"), ("ZhoneGR303-MIB", "igRowStatus"))
if mibBuilder.loadTexts: igSystemTimeChange.setStatus('current')
if mibBuilder.loadTexts: igSystemTimeChange.setDescription('When an IG is connected to a 5ESS switch, the switch will synchronize system time with the RDT.')
mibBuilder.exportSymbols("ZhoneGR303-MIB", igSapi0T200=igSapi0T200, igStatsTotalEntry=igStatsTotalEntry, igSwitchType=igSwitchType, igIntervalOutboundCallsBlocked=igIntervalOutboundCallsBlocked, igStatsTotalTable=igStatsTotalTable, ds1LineMappingTable=ds1LineMappingTable, igCrvRowStatus=igCrvRowStatus, igCurrentTMCLapdRcvd=igCurrentTMCLapdRcvd, igCrvTmcState=igCrvTmcState, igCurrentGR303ProtocolErrors=igCurrentGR303ProtocolErrors, igStatsCurrentTable=igStatsCurrentTable, igCrvTable=igCrvTable, dsnLgId=dsnLgId, ds1LineMappingRowStatus=ds1LineMappingRowStatus, igIntervalOutboundCalls=igIntervalOutboundCalls, igMaxConfigCalls=igMaxConfigCalls, igTotalGR303ProtocolErrors=igTotalGR303ProtocolErrors, igPeerStatus=igPeerStatus, igIntervalEOCLapdRcvd=igIntervalEOCLapdRcvd, igPrimaryEocTmcDs1IfIndex=igPrimaryEocTmcDs1IfIndex, igCrv=igCrv, igSapi1MaxOutstandingFrames=igSapi1MaxOutstandingFrames, igCurrentInboundCalls=igCurrentInboundCalls, igTotalTMCLapdRcvdErrs=igTotalTMCLapdRcvdErrs, igTotalInboundCalls=igTotalInboundCalls, igCurrentOutboundCallsBlocked=igCurrentOutboundCallsBlocked, igCrvSignalType=igCrvSignalType, interfaceGroupTable=interfaceGroupTable, igStatsIntervalTable=igStatsIntervalTable, igIntervalValidData=igIntervalValidData, igCurrentEOCLapdRcvdErrs=igCurrentEOCLapdRcvdErrs, igCrvOperStatus=igCrvOperStatus, ds1LineMappingEntry=ds1LineMappingEntry, igCrvRemoteStateChange=igCrvRemoteStateChange, igCurrentTMCLapdSent=igCurrentTMCLapdSent, igTotalEOCLapdRcvd=igTotalEOCLapdRcvd, igTotalEOCLapdSent=igTotalEOCLapdSent, igControlChannelTmcPrimarySvcState=igControlChannelTmcPrimarySvcState, interfaceGroupEntry=interfaceGroupEntry, igCurrentEOCLapdSent=igCurrentEOCLapdSent, igStatsIntervalEntry=igStatsIntervalEntry, igTotalTMCLapdSent=igTotalTMCLapdSent, igCurrActiveCalls=igCurrActiveCalls, igStatsTimeElapsed=igStatsTimeElapsed, igSystemTimeChange=igSystemTimeChange, igStatsValidIntervals=igStatsValidIntervals, igControlChannelT303=igControlChannelT303, igCurrentTMCLapdRcvdErrs=igCurrentTMCLapdRcvdErrs, zhoneGR303=zhoneGR303, gr303Traps=gr303Traps, igSapi0T203=igSapi0T203, igSlot=igSlot, igIntervalEOCLapdSent=igIntervalEOCLapdSent, igSapi0MaxOutstandingFrames=igSapi0MaxOutstandingFrames, igTotalOutboundCalls=igTotalOutboundCalls, ds1LogicalId=ds1LogicalId, igWorkingMode=igWorkingMode, igControlChannelT396=igControlChannelT396, PYSNMP_MODULE_ID=zhoneGR303, igStatsCurrentEntry=igStatsCurrentEntry, igSapi0N200=igSapi0N200, igAdminStatus=igAdminStatus, igStatsInvalidIntervals=igStatsInvalidIntervals, igNameId=igNameId, igPeerShelf=igPeerShelf, igIntervalInboundCalls=igIntervalInboundCalls, igTotalEOCLapdRcvdErrs=igTotalEOCLapdRcvdErrs, igRowStatus=igRowStatus, igSapi1T200=igSapi1T200, igPeerSlot=igPeerSlot, igSapi0PpsMode=igSapi0PpsMode, igSecondaryEocTmcDs1IfIndex=igSecondaryEocTmcDs1IfIndex, igCrvLocalAdminState=igCrvLocalAdminState, ds1ChannelNumber=ds1ChannelNumber, igOperStatusChange=igOperStatusChange, igTmcPrimaryStateChange=igTmcPrimaryStateChange, igSapi1T203=igSapi1T203, igCurrentOutboundCalls=igCurrentOutboundCalls, igEocSecondaryStateChange=igEocSecondaryStateChange, igTotalOutboundCallsBlocked=igTotalOutboundCallsBlocked, gr303TrapsPrefix=gr303TrapsPrefix, igIntervalNumber=igIntervalNumber, igIntervalTMCLapdSent=igIntervalTMCLapdSent, ds1IfIndex=ds1IfIndex, igControlChannelTable=igControlChannelTable, igCurrentEOCLapdRcvd=igCurrentEOCLapdRcvd, igTmcSecondaryStateChange=igTmcSecondaryStateChange, igEocPrimaryStateChange=igEocPrimaryStateChange, igCrvEntry=igCrvEntry, igOperationalStatus=igOperationalStatus, igIntervalGR303ProtocolErrors=igIntervalGR303ProtocolErrors, ds1Role=ds1Role, igControlChannelEocPrimarySvcState=igControlChannelEocPrimarySvcState, igControlChannelEntry=igControlChannelEntry, igCrvTmcStateChange=igCrvTmcStateChange, igShelf=igShelf, igControlChannelEocSecondarySvcState=igControlChannelEocSecondarySvcState, igSapi1PpsMode=igSapi1PpsMode, igIntervalTMCLapdRcvd=igIntervalTMCLapdRcvd, igSapi1N200=igSapi1N200, igControlChannelTmcSecondarySvcState=igControlChannelTmcSecondarySvcState, igCrvRemoteAdminState=igCrvRemoteAdminState, igTotalTMCLapdRcvd=igTotalTMCLapdRcvd, igintervalTMCLapdRcvdErrs=igintervalTMCLapdRcvdErrs, igIntervalEOCLapdRcvdErrs=igIntervalEOCLapdRcvdErrs)

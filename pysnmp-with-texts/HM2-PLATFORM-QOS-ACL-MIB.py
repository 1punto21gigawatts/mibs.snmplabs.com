#
# PySNMP MIB module HM2-PLATFORM-QOS-ACL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-PLATFORM-QOS-ACL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:32:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ConstraintsIntersection")
hm2PlatformQoS, = mibBuilder.importSymbols("HM2-PLATFORM-QOS-MIB", "hm2PlatformQoS")
HmEnabledStatus, = mibBuilder.importSymbols("HM2-TC-MIB", "HmEnabledStatus")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Counter64, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Integer32, iso, Bits, Counter32, NotificationType, Gauge32, Unsigned32, ModuleIdentity, TimeTicks, MibIdentifier = mibBuilder.importSymbols("SNMPv2-SMI", "Counter64", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Integer32", "iso", "Bits", "Counter32", "NotificationType", "Gauge32", "Unsigned32", "ModuleIdentity", "TimeTicks", "MibIdentifier")
MacAddress, TimeStamp, DisplayString, RowStatus, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "TimeStamp", "DisplayString", "RowStatus", "TruthValue", "TextualConvention")
hm2PlatformQosAcl = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 12, 3, 2))
hm2PlatformQosAcl.setRevisions(('2012-12-20 00:00', '2012-05-02 00:00', '2011-06-12 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2PlatformQosAcl.setRevisionsDescriptions(('Added new rule hit trap to allow sending of SNMPv1 traps.', 'Updated with new prefix. Updated value ranges to work with configmgr.', 'Initial version.',))
if mibBuilder.loadTexts: hm2PlatformQosAcl.setLastUpdated('201212200000Z')
if mibBuilder.loadTexts: hm2PlatformQosAcl.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2PlatformQosAcl.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2PlatformQosAcl.setDescription('The Hirschmann Platform2 MIB for Access Control Lists (ACL). Copyright (C) 2012. All Rights Reserved.')
class EtypeValue(TextualConvention, Unsigned32):
    description = 'Ethertype value of a packet. The allowed value is 0x0600 to 0xFFFF. A value of 0 indicates, that this field is not used.'
    status = 'current'
    displayHint = 'x'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class Ipv6AddressPrefix(TextualConvention, OctetString):
    description = 'This data type is used to model IPv6 address prefixes. This is a binary string of up to 16 octets in network byte order.'
    status = 'current'
    displayHint = '2x:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 16)

class AclBurstSize(TextualConvention, Unsigned32):
    description = 'The number of kilobytes (Kbytes) in a packet that may be sent in a traffic stream without regard for other traffic streams.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 128), )
class Hm2PortOperator(TextualConvention, Integer32):
    description = 'The operator of a source/destination tcp/udp port for ip acl classes.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("eq", 0), ("neq", 1), ("lt", 2), ("gt", 3))

hm2AgentAclNamedIpv4IndexNextFree = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclNamedIpv4IndexNextFree.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclNamedIpv4IndexNextFree.setDescription('This object contains an unused value for the hm2AgentAclIndex to be used when creating a new named IPv4 ACL. A value of zero indicates the ACL table is full. For MSP devices the IPv4 ACL indexes start with 1000.')
hm2AgentAclTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 1), )
if mibBuilder.loadTexts: hm2AgentAclTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTable.setDescription('A table of ACL instances.')
hm2AgentAclEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 1, 1), ).setIndexNames((0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIndex"))
if mibBuilder.loadTexts: hm2AgentAclEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclEntry.setDescription('An ACL instance table entry.')
hm2AgentAclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentAclIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIndex.setDescription('The IP ACL table index this instance is associated with. For MSP devices the IPv4 ACL indexes start with 1000.')
hm2AgentAclStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 1, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclStatus.setDescription('Status of this instance. Entries can not be deleted until all rows in the hm2AgentAclIfTable and hm2AgentAclRuleTable with corresponding values of hm2AgentAclIndex have been deleted. active(1) - this ACL instance is active createAndGo(4) - set to this value to create an instance destroy(6) - set to this value to delete an instance')
hm2AgentAclName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclName.setDescription('The name of this IPv4 ACL entry, which must consist of 1 to 31 alphanumeric characters and uniquely identify this IPv4 ACL. An existing IPv4 ACL can be renamed by setting this object to a new name. This object must be set to complete a new IPv4 ACL row instance.')
hm2AgentAclStatsAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 1, 1, 248), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushAclHitCount", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclStatsAction.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclStatsAction.setDescription("Setting the object to 'flushAclHitCount(2)' will reset hit counter statistics for all rules in this ACL. Reading the object always returns 'other'.")
hm2AgentAclIfTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8), )
if mibBuilder.loadTexts: hm2AgentAclIfTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfTable.setDescription('A table of ACL interface instances per direction.')
hm2AgentAclIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8, 1), ).setIndexNames((0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfIndex"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfDirection"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfSequence"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclType"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclId"))
if mibBuilder.loadTexts: hm2AgentAclIfEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfEntry.setDescription('An ACL interface instance entry.')
hm2AgentAclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentAclIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfIndex.setDescription('The interface index to which this ACL instance applies.')
hm2AgentAclIfDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2))))
if mibBuilder.loadTexts: hm2AgentAclIfDirection.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfDirection.setDescription('The interface direction to which this ACL instance applies.')
hm2AgentAclIfSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: hm2AgentAclIfSequence.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfSequence.setDescription('The relative evaluation sequence of this ACL for this interface and direction. When multiple ACLs are allowed for a given interface and direction, the sequence number determines the order in which the list of ACLs are evaluated, with lower sequence numbers given higher precedence. The sequence number value is arbitrary, but must be a unique non-zero value for a given interface and direction. Setting this object to an existing sequence number value for a given interface and direction causes the ACL corresponding to that value to be replaced with this ACL.')
hm2AgentAclIfAclType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("mac", 2), ("ipv6", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclIfAclType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfAclType.setDescription('The type of this ACL, which is used to interpret the hm2AgentAclIfId object value. Each type of ACL uses its own numbering scheme for identification (see hm2AgentAclIfAclId object for details). The hm2AgentAclIfAclId object must be specified along with this object.')
hm2AgentAclIfAclId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclIfAclId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfAclId.setDescription('The ACL identifier value, which is interpreted based on the hm2AgentAclIfType object. For the IP ACLs, the actual ACL number is its identifier as follows: IP standard ranges from 1-99, while IP extended ranges from 100-199. Here, hm2AgentAclIfAclId represents hm2AgentAclIndex. The MAC ACLs use an internally generated index value that is assigned when the ACL is created. Here, hm2AgentAclIfAclId represents hm2AgentAclMacIndex. The IPv6 ACLs use an internally generated index value that is assigned when the ACL is created. Here, hm2AgentAclVlanAclId represents hm2AgentAclIpv6Index. The hm2AgentAclIfType object must be specified along with this object.')
hm2AgentAclIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 8, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclIfStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclIfStatus.setDescription('Status of this instance. active(1) - this ACL interface instance is active createAndGo(4) - set to this value to assign an ACL to an interface and direction destroy(6) - set to this value to remove an ACL from an interface and direction')
hm2AgentAclRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4), )
if mibBuilder.loadTexts: hm2AgentAclRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleTable.setDescription('A table of IP ACL rule instances.')
hm2AgentAclRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1), ).setIndexNames((0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIndex"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclRuleIndex"))
if mibBuilder.loadTexts: hm2AgentAclRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleEntry.setDescription('A table of IP ACL Classification Rules')
hm2AgentAclRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentAclRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIndex.setDescription('The index of this rule instance within an IP ACL.')
hm2AgentAclRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2))).clone('deny')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleAction.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleAction.setDescription('The type of action this rule should perform.')
hm2AgentAclRuleProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleProtocol.setDescription('icmp - 1 igmp - 2 ip-in-ip - 4 tcp - 6 udp - 17 ip - 255 (ip all) All values from 1 to 255 are valid. 0 disables this match criteria.')
hm2AgentAclRuleSrcIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleSrcIpAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleSrcIpAddress.setDescription('The source IP address used in the ACL classification.')
hm2AgentAclRuleSrcIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleSrcIpMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleSrcIpMask.setDescription("The Source IP mask used in the ACL classification. This mask is expressed using wild-card notation, which is the 1's compliment of traditional subnet masks. Here, the 'don't care bits' are represented by binary 1's and 'do care bits' are represented by binary 0's.")
hm2AgentAclRuleSrcL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4Port.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4Port.setDescription('The source port number (Layer 4) used in the ACL classification. A value of -1 disables this criteria.')
hm2AgentAclRuleSrcL4PortRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4PortRangeStart.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4PortRangeStart.setDescription('The source port number(Layer 4) range start.')
hm2AgentAclRuleSrcL4PortRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 8), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4PortRangeEnd.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4PortRangeEnd.setDescription('The source port number(Layer 4) range end.')
hm2AgentAclRuleDestIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 9), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleDestIpAddress.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleDestIpAddress.setDescription('The destination IP address used in the ACL classification.')
hm2AgentAclRuleDestIpMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 10), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleDestIpMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleDestIpMask.setDescription("The destination IP mask used in the ACL classification. This mask is expressed using wild-card notation, which is the 1's compliment of traditional subnet masks. Here, the 'don't care bits' are represented by binary 1's and 'do care bits' are represented by binary 0's. ")
hm2AgentAclRuleDestL4Port = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 11), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleDestL4Port.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleDestL4Port.setDescription('The destination port number(Layer 4) used in ACl classification.')
hm2AgentAclRuleDestL4PortRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 12), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleDestL4PortRangeStart.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleDestL4PortRangeStart.setDescription('The destination port number(Layer 4) starting range used in ACL classification.')
hm2AgentAclRuleDestL4PortRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleDestL4PortRangeEnd.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleDestL4PortRangeEnd.setDescription('The destination port number(Layer 4) ending range used in ACL classification.')
hm2AgentAclRuleIPDSCP = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 14), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleIPDSCP.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIPDSCP.setDescription('The Differentiated Services Code Point value. A value of -1 indicates that this field is not used.')
hm2AgentAclRuleIpPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 15), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleIpPrecedence.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIpPrecedence.setDescription('The type of service (TOS) IP precedence value. A value of -1 indicates that this field is not used.')
hm2AgentAclRuleIpTosBits = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 16), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleIpTosBits.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIpTosBits.setDescription('The type of service (TOS) bits value.')
hm2AgentAclRuleIpTosMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 17), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleIpTosMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIpTosMask.setDescription('The type of service (TOS) mask value.')
hm2AgentAclRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 18), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleStatus.setDescription('Status of this instance. active(1) - this ACL rule is active createAndGo(4) - set to this value to create an instance destroy(6) - set to this value to delete an instance')
hm2AgentAclRuleAssignQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 19), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(4294967295, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleAssignQueueId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleAssignQueueId.setDescription('Queue identifier to which all inbound packets matching this ACL rule are directed. This object defaults to the standard queue assignment for user priority 0 traffic per the IEEE 802.1D specification based on the number of assignable queues in the system: 1-3 queues: 0 4-7 queues: 1 8 queues: 2 This default assignment is static and is not influenced by other system configuration changes. A value of 4294967295 indicates that this field is not used')
hm2AgentAclRuleRedirectIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 20), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleRedirectIntf.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleRedirectIntf.setDescription('A non-zero value indicates the external ifIndex to which all inbound packets matching this ACL rule are directed. A value of zero means packet redirection is not in effect, which is the default value of this object. Note that packet redirection and mirroring (hm2AgentAclRuleMirrorIntf object) are mutually exclusive rule attributes.')
hm2AgentAclRuleMatchEvery = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 21), TruthValue().clone('false')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleMatchEvery.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleMatchEvery.setDescription('Flag to indicate that the ACL rule is defined to match on every IP packet, regardless of content.')
hm2AgentAclRuleMirrorIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 22), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleMirrorIntf.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleMirrorIntf.setDescription('A non-zero value indicates the external ifIndex to which all inbound packets matching this ACL rule are copied. A value of zero means packet mirroring is not in effect, which is the default value of this object. Note that packet mirroring and redirection (hm2AgentAclRuleRedirectIntf object) are mutually exclusive rule attributes.')
hm2AgentAclRuleLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 23), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleLogging.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleLogging.setDescription('Flag to indicate that the ACL rule is being logged. A hardware count of the number of packets that match this rule is reported via the hm2AgentAclTrapRuleLogEvent notification. This object may be supported for a hm2AgentAclRuleAction setting of permit(1) and/or deny(2), depending on the ACL feature capabilities of the device.')
hm2AgentAclRuleTimeRangeName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 24), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleTimeRangeName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleTimeRangeName.setDescription('Name of the time range, that the ACL rule has referenced. It has to start with a character and shall consist of 0 to 31 alphanumeric characters.')
hm2AgentAclRuleTimeRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclRuleTimeRangeStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleTimeRangeStatus.setDescription('Flag that indicates the ACL rule status. If the status is active, it implies that the ACL rule is in effect. If the status is inactive, it implies that the ACL rule is not in effect.')
hm2AgentAclRuleRedirectExtAgentId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 28), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 100), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleRedirectExtAgentId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleRedirectExtAgentId.setDescription('A non-zero value indicates the external control plane application agentId to which all inbound packets matching this ACL rule are directed. A value of zero means redirection is not in effect, which is the default value of this object. Note that this action is mutually exclusive with redirect to interface(aclRuleRedirectIntf object) and mirroring (aclRuleMirrorIntf object) rule attributes.')
hm2AgentAclRuleIcmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleIcmpType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIcmpType.setDescription('ACL rule matches on the specified ICMP type. All values from 0 to 255 are valid. A value of -1 indicates that this field is not used.')
hm2AgentAclRuleIcmpCode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleIcmpCode.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIcmpCode.setDescription('ACL rule matches on the specified ICMP code. All values from 0 to 255 are valid. A value of -1 indicates that this field is not used.')
hm2AgentAclRuleIgmpType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 255), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleIgmpType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIgmpType.setDescription('ACL rule matches on the specified IGMP type. All values from 1 to 255 are valid.')
hm2AgentAclRuleEstablished = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 32), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleEstablished.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleEstablished.setDescription('Flag to indicate the ACL rule to match on TCP packets that has either RST or ACK bits set in the TCP header')
hm2AgentAclRuleFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 33), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleFragments.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleFragments.setDescription('Flag to indicate the ACL rule to match if the packet is fragmented')
hm2AgentAclRuleIndexNextFree = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 248), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclRuleIndexNextFree.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleIndexNextFree.setDescription('This object contains an unused value for the hm2AgentAclRuleIndex to be used when creating a new named IPv4 ACL. A value of zero indicates the ACL rule table is full.')
hm2AgentAclRuleRateLimitCrateUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 249), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pps", 1), ("kbps", 2))).clone('kbps')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleRateLimitCrateUnit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleRateLimitCrateUnit.setDescription('The unit of the aclRuleRateLimitCrate. Can be either packets per second (pps) or kilobits per second (kbps).')
hm2AgentAclRuleRateLimitCrate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 250), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleRateLimitCrate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleRateLimitCrate.setDescription('Committed rate attribute statement value, specified in kbps. Value 0 disables this match criteria.')
hm2AgentAclRuleRateLimitCburst = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 251), AclBurstSize()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleRateLimitCburst.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleRateLimitCburst.setDescription('Committed burst size attribute statement value, specified in kbytes. Value 0 disables this match criteria.')
hm2AgentAclRuleStatsAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 252), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushRuleHitCount", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleStatsAction.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleStatsAction.setDescription("Setting the object to 'flushRuleHitCount(2)' will reset hit counter statistics. Reading the object always returns 'other'.")
hm2AgentAclRuleHitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 253), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclRuleHitCount.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleHitCount.setDescription('Number of packets that matched the ACL rule.')
hm2AgentAclRuleHitCountDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 254), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclRuleHitCountDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleHitCountDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this rule's counters suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
hm2AgentAclRuleTcpFlagBits = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 255), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleTcpFlagBits.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleTcpFlagBits.setDescription('The TCP flag value.')
hm2AgentAclRuleTcpFlagMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 256), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleTcpFlagMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleTcpFlagMask.setDescription('The TCP flag mask value.')
hm2AgentAclRuleSrcL4PortOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 257), Hm2PortOperator().clone('eq')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4PortOperator.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleSrcL4PortOperator.setDescription('The operator for the source port.')
hm2AgentAclRuleDstL4PortOperator = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 4, 1, 258), Hm2PortOperator().clone('eq')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclRuleDstL4PortOperator.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclRuleDstL4PortOperator.setDescription('The operator for the destination port.')
hm2AgentAclMacIndexNextFree = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclMacIndexNextFree.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacIndexNextFree.setDescription('This object contains an unused value for the hm2AgentAclMacIndex to be used when creating a new MAC ACL. A value of zero indicates the ACL table is full. For MSP devices the MAC ACL indexes start with 10000.')
hm2AgentAclMacTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 6), )
if mibBuilder.loadTexts: hm2AgentAclMacTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacTable.setDescription('A table of MAC ACL instances.')
hm2AgentAclMacEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 6, 1), ).setIndexNames((0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclMacIndex"))
if mibBuilder.loadTexts: hm2AgentAclMacEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacEntry.setDescription('An ACL MAC instance table entry.')
hm2AgentAclMacIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 6, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentAclMacIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacIndex.setDescription('The MAC ACL table index this instance is associated with. When creating a new MAC ACL, refer to the hm2AgentAclMacIndexNextFree object to determine the next available hm2AgentAclMacIndex to use. For MSP devices the MAC ACL indexes start with 10000.')
hm2AgentAclMacName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacName.setDescription('The name of this MAC ACL entry, which must consist of 1 to 31 alphanumeric characters and uniquely identify this MAC ACL. An existing MAC ACL can be renamed by setting this object to a new name. This object must be set to complete a new MAC ACL row instance.')
hm2AgentAclMacStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 6, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacStatus.setDescription('Status of this instance. ACL MAC entries can not be deleted until all rows in the hm2AgentAclIfTable and hm2AgentAclRuleTable with corresponding values of hm2AgentAclMacIndex have been deleted. active(1) - this ACL instance is active createAndGo(4) - set to this value to create an instance destroy(6) - set to this value to delete an instance The hm2AgentAclMacName object must be set to complete this row instance.')
hm2AgentAclMacStatsAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 6, 1, 248), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushAclHitCount", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacStatsAction.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacStatsAction.setDescription("Setting the object to 'flushAclHitCount(2)' will reset hit counter statistics for the rules in this ACL. Reading the object always returns 'other'.")
hm2AgentAclMacRuleTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7), )
if mibBuilder.loadTexts: hm2AgentAclMacRuleTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleTable.setDescription('A table of layer 2 MAC ACL rule instances.')
hm2AgentAclMacRuleEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1), ).setIndexNames((0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclMacIndex"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclMacRuleIndex"))
if mibBuilder.loadTexts: hm2AgentAclMacRuleEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleEntry.setDescription('A table of layer 2 MAC ACL classification rules.')
hm2AgentAclMacRuleIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentAclMacRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleIndex.setDescription('The index of this rule instance within an MAC ACL.')
hm2AgentAclMacRuleAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2))).clone('deny')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleAction.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleAction.setDescription('The type of action this MAC ACL rule should perform.')
hm2AgentAclMacRuleCos = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(4294967295, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleCos.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleCos.setDescription('The class of service (COS) used in the MAC ACL classification. This is the three-bit user priority field in the 802.1Q tag header of a tagged Ethernet frame. For frames containing a double VLAN tag, this field is located in the first/outer tag. A value of 4294967295 indicates that this field is not used.')
hm2AgentAclMacRuleCos2 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(4294967295, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleCos2.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleCos2.setDescription('The secondary class of service (COS2) used in the MAC ACL classification. This is the three-bit user priority field in the second/inner 802.1Q tag header of a double VLAN tagged Ethernet frame. A value of 4294967295 indicates that this field is not used.')
hm2AgentAclMacRuleDestMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 5), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleDestMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleDestMacAddr.setDescription('The destination MAC address used in the MAC ACL classification.')
hm2AgentAclMacRuleDestMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 6), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleDestMacMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleDestMacMask.setDescription("The destination MAC address mask used in the MAC ACL classification. This mask value identifies the portion of the hm2AgentAclMacRuleDestMacAddr that is compared against a packet. The 'don't care bits' are represented by binary 0's and 'do care bits' are represented by binary 1's. A non-contiguous mask value is permitted.")
hm2AgentAclMacRuleEtypeKey = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 248))).clone(namedValues=NamedValues(("custom", 1), ("appletalk", 2), ("arp", 3), ("ibmsna", 4), ("ipv4", 5), ("ipv6", 6), ("ipxold", 7), ("mplsmcast", 8), ("mplsucast", 9), ("netbios", 10), ("novell", 11), ("pppoedisc", 12), ("rarp", 13), ("pppoesess", 14), ("ipxnew", 15), ("profinet", 16), ("powerlink", 17), ("ethercat", 18), ("pppoe", 248)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleEtypeKey.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleEtypeKey.setDescription('The Ethertype keyword used in the MAC ACL classification. A keyword of custom(1) requires that the hm2AgentAclMacRuleEtypeValue object also be set.')
hm2AgentAclMacRuleEtypeValue = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 8), EtypeValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleEtypeValue.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleEtypeValue.setDescription('The Ethertype custom value used in the MAC ACL classification. This object is only valid if the hm2AgentAclMacRuleEtypeKey is set to custom(1). Values ranging from 0x0600 to 0xFFFF (1536 to 65535) are interpreted as the Ethertype. Lower values are interpreted as frame size. A value of 0 indicates that this field is not used.')
hm2AgentAclMacRuleSrcMacAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 9), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleSrcMacAddr.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleSrcMacAddr.setDescription('The source MAC address used in the MAC ACL classification.')
hm2AgentAclMacRuleSrcMacMask = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 10), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleSrcMacMask.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleSrcMacMask.setDescription("The source MAC address mask used in the MAC ACL classification. This mask value identifies the portion of the hm2AgentAclMacRuleSrcMacAddr that is compared against a packet. The 'don't care bits' are represented by binary 0's and 'do care bits' are represented by binary 1's. A non-contiguous mask value is permitted.")
hm2AgentAclMacRuleVlanId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId.setDescription('The VLAN ID value used in the MAC ACL classification. The VLAN ID field is defined as the 12-bit VLAN identifier in the 802.1Q tag header of a tagged Ethernet frame which is contained in the first/outer tag of a double VLAN tagged frame.')
hm2AgentAclMacRuleVlanIdRangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanIdRangeStart.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanIdRangeStart.setDescription('The VLAN ID range start value used in the MAC ACL classification. Setting this value greater than the current hm2AgentAclMacRuleVlanIdRangeEnd changes the VLAN ID range end to the same value as the range start. The VLAN ID field is defined as the 12-bit VLAN identifier in the 802.1Q tag header of a tagged Ethernet frame which is contained in the first/outer tag of a double VLAN tagged frame.')
hm2AgentAclMacRuleVlanIdRangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanIdRangeEnd.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanIdRangeEnd.setDescription('The VLAN ID range end value used in the MAC ACL classification. Setting this value less than the current hm2AgentAclMacRuleVlanIdRangeStart changes the VLAN ID range start to the same value as the range end. The VLAN ID field is defined as the 12-bit VLAN identifier in the 802.1Q tag header of a tagged Ethernet frame which is contained in the first/outer tag of a double VLAN tagged frame.')
hm2AgentAclMacRuleVlanId2 = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId2.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId2.setDescription('The secondary VLAN ID value used in the MAC ACL classification. The secondary VLAN ID field is defined as the 12-bit VLAN identifier in the second/inner 802.1Q tag header of a double VLAN tagged Ethernet frame.')
hm2AgentAclMacRuleVlanId2RangeStart = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId2RangeStart.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId2RangeStart.setDescription('The secondary VLAN ID range start value used in the MAC ACL classification. Setting this value greater than the current hm2AgentAclMacRuleVlanId2RangeEnd changes the Secondary VLAN ID range end to the same value as the range start. The secondary VLAN ID field is defined as the 12-bit VLAN identifier in the second/inner 802.1Q tag header of a double VLAN tagged Ethernet frame.')
hm2AgentAclMacRuleVlanId2RangeEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4042))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId2RangeEnd.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleVlanId2RangeEnd.setDescription('The secondary VLAN ID range end value used in the MAC ACL classification. Setting this value less than the current hm2AgentAclMacRuleVlanId2RangeStart changes the Secondary VLAN ID range start to the same value as the range end. The secondary VLAN ID field is defined as the 12-bit VLAN identifier in the second/inner 802.1Q tag header of a double VLAN tagged Ethernet frame.')
hm2AgentAclMacRuleStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 17), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleStatus.setDescription('Status of this instance. active(1) - this ACL Rule is active createAndGo(4) - set to this value to create an instance destroy(6) - set to this value to delete an instance')
hm2AgentAclMacRuleAssignQueueId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 18), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 7), ValueRangeConstraint(4294967295, 4294967295), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleAssignQueueId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleAssignQueueId.setDescription('Queue identifier to which all inbound packets matching this MAC ACL rule are directed. This object defaults to the standard queue assignment for user priority 0 traffic per the IEEE 802.1D specification based on the number of assignable queues in the system: 1-3 queues: 0 4-7 queues: 1 8 queues: 2 This default assignment is static and is not influenced by other system configuration changes. A value of 4294967295 indicates that this field is not used')
hm2AgentAclMacRuleRedirectIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 19), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleRedirectIntf.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleRedirectIntf.setDescription('A non-zero value indicates the external ifIndex to which all inbound packets matching this MAC ACL rule are directed. A value of zero means packet redirection is not in effect, which is the default value of this object. Note that packet redirection and mirroring (hm2AgentAclMacRuleMirrorIntf object) are mutually exclusive rule attributes.')
hm2AgentAclMacRuleMatchEvery = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 20), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleMatchEvery.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleMatchEvery.setDescription('Flag to indicate that the MAC ACL rule is defined to match all packets, regardless of Ethertype.')
hm2AgentAclMacRuleMirrorIntf = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 21), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleMirrorIntf.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleMirrorIntf.setDescription('A non-zero value indicates the external ifIndex to which all inbound packets matching this MAC ACL rule are copied. A value of zero means packet mirroring is not in effect, which is the default value of this object. Note that packet mirroring and redirection (hm2AgentAclMacRuleRedirectIntf object) are mutually exclusive rule attributes.')
hm2AgentAclMacRuleLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 22), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleLogging.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleLogging.setDescription('Flag to indicate that the ACL rule is being logged. A hardware count of the number of packets that match this rule is reported via the hm2AgentAclTrapRuleLogEvent notification. This object may be supported for an hm2AgentAclMacRuleAction setting of permit(1) and/or deny(2), depending on the ACL feature capabilities of the device.')
hm2AgentAclMacRuleTimeRangeName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleTimeRangeName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleTimeRangeName.setDescription('Name of the time range, that the ACL rule has referenced. It has to start with a character and shall consist of 0 to 31 alphanumeric characters.')
hm2AgentAclMacRuleTimeRangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclMacRuleTimeRangeStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleTimeRangeStatus.setDescription('Flag that indicates the ACL rule status. If the status is active, it implies that the ACL rule is in effect. If the status is inactive, it implies that the ACL rule is not in effect.')
hm2AgentAclMacRuleIndexNextFree = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 248), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclMacRuleIndexNextFree.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleIndexNextFree.setDescription('This object contains an unused value for the hm2AgentAclMacRuleIndex to be used when creating a new MAC ACL. A value of zero indicates the ACL rule table is full.')
hm2AgentAclMacRuleRateLimitCrateUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 249), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pps", 1), ("kbps", 2))).clone('kbps')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleRateLimitCrateUnit.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleRateLimitCrateUnit.setDescription('The unit of the aclMacRuleRateLimitCrate. Can be either packets per second (pps) or kilobits per second (kbps).')
hm2AgentAclMacRuleRateLimitCrate = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 250), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 10000000))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleRateLimitCrate.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleRateLimitCrate.setDescription('Committed rate attribute statement value, specified in kbps. Value 0 disables this match criteria.')
hm2AgentAclMacRuleRateLimitCburst = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 251), AclBurstSize()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleRateLimitCburst.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleRateLimitCburst.setDescription('Committed burst size attribute statement value, specified in kbytes. Value 0 disables this match criteria.')
hm2AgentAclMacRuleStatsAction = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 252), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("flushRuleHitCount", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclMacRuleStatsAction.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleStatsAction.setDescription("Setting the object to 'flushRuleHitCount(2)' will reset hit counter statistics. Reading the object always returns 'other'.")
hm2AgentAclMacRuleHitCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 253), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclMacRuleHitCount.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleHitCount.setDescription('Number of packets that matched the ACL rule.')
hm2AgentAclMacRuleHitCountDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 7, 1, 254), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2AgentAclMacRuleHitCountDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclMacRuleHitCountDiscontinuityTime.setDescription("The value of sysUpTime on the most recent occasion at which any one or more of this rule's counters suffered a discontinuity. If no such discontinuities have occurred since the last re- initialization of the local management subsystem, then this object contains a zero value.")
hm2AgentAclLoggingGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9))
hm2AgentAclTrapRuleIndex = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleIndex.setDescription('The index of an ACL rule instance. Used by hm2AgentAclTrapRuleLogEvent trap.')
hm2AgentAclTrapRuleAction = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permit", 1), ("deny", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleAction.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleAction.setDescription('The type of action this rule should perform, either permit(1) or deny(2). Used by hm2AgentAclTrapRuleLogEvent trap.')
hm2AgentAclTrapRuleHitCount = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 4), Counter64()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleHitCount.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleHitCount.setDescription('Number of packets that matched the ACL rule during the most recent logging interval. Used by hm2AgentAclTrapRuleLogEvent trap.')
hm2AgentAclTrapFlag = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 5), HmEnabledStatus().clone('enable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2AgentAclTrapFlag.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapFlag.setDescription('ACL Trap Flag - Enables or disables ACL trap generation. When this value is set to enable(1), ACL traps are sent from the switch when they occur.')
hm2AgentAclTrapRuleTimeRangeName = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 31))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleTimeRangeName.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleTimeRangeName.setDescription('Name of the time range on which there is a notification received. Used by hm2AgentAclTrapRuleTimeRangeEvent trap.')
hm2AgentAclTrapRuleTimeRangeNotification = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("activate", 1), ("deactivate", 2), ("delete", 3)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleTimeRangeNotification.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleTimeRangeNotification.setDescription('Flag to indicate the type of time range notification received. Used by hm2AgentAclTrapRuleTimeRangeEvent trap.')
hm2AgentAclTrapRuleInstallationStatus = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("failure", 1), ("success", 2)))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleInstallationStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleInstallationStatus.setDescription('Value specifies the status of the ACL Rule installed in hardware as activated/deactivated. Used by hm2AgentAclTrapRuleTimeRangeEvent trap.')
hm2AgentAclTrapRuleHitCountHigh = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 248), Gauge32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleHitCountHigh.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleHitCountHigh.setDescription('Upper 32bit of number of packets that matched the ACL rule during the most recent logging interval. Used by hm2AgentAclTrapRuleLogEventV1 trap.')
hm2AgentAclTrapRuleHitCountLow = MibScalar((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 9, 249), Gauge32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2AgentAclTrapRuleHitCountLow.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleHitCountLow.setDescription('Lower 32bit of number of packets that matched the ACL rule during the most recent logging interval. Used by hm2AgentAclTrapRuleLogEventV1 trap.')
hm2AgentAclNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 0))
hm2AgentAclTrapRuleLogEvent = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 0, 1)).setObjects(("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclType"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclId"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleIndex"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleAction"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleHitCount"))
if mibBuilder.loadTexts: hm2AgentAclTrapRuleLogEvent.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleLogEvent.setDescription('This trap is generated on a periodic basis to indicate that an ACL rule configured for logging was actively used by hardware to take action on one or more packets. The hm2AgentAclTrapRuleHitCount denotes the number of packets that matched this rule during the most recent logging interval. ACL trap generation requires that the hm2AgentAclTrapFlag object is set to enable(1).')
hm2AgentAclTrapRuleTimeRangeEvent = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 0, 2)).setObjects(("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclType"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclId"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleIndex"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleTimeRangeName"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleTimeRangeNotification"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleInstallationStatus"))
if mibBuilder.loadTexts: hm2AgentAclTrapRuleTimeRangeEvent.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleTimeRangeEvent.setDescription('This trap is generated when there is a time range notification received on any Time based ACL rule. The hm2AgentAclTrapRuleTimeRangeName denotes the time range name associated with the ACL rule, hm2AgentAclTrapRuleTimeRangeNotification indicates the type of notification received and hm2AgentAclTrapRuleInstallationStatus indicates the installation status of ACL rule in the hardware. When activate notification is received, ACL rule is activated in the hardware. When deactivate notifcation is received, ACL rule is deactivated in the hardware. When delete notification is received, ACL rule is activated in the hardware, if it is not already activated. ACL trap generation requires the hm2AgentAclTrapFlag object to be set to enable(1).')
hm2AgentAclTrapRuleLogEventV1 = NotificationType((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 0, 248)).setObjects(("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclType"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclIfAclId"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleIndex"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleAction"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleHitCountHigh"), ("HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclTrapRuleHitCountLow"))
if mibBuilder.loadTexts: hm2AgentAclTrapRuleLogEventV1.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclTrapRuleLogEventV1.setDescription('This trap is generated on a periodic basis to indicate that an ACL rule configured for logging was actively used by hardware to take action on one or more packets. The hm2AgentAclTrapRuleHitCount denotes the number of packets that matched this rule during the most recent logging interval. ACL trap generation requires that the hm2AgentAclTrapFlag object is set to enable(1). This version of the trap is only sent when device uses SNMPv1 style traps. Devices using SNMPv2 and above send hm2AgentAclTrapRuleLogeEvent instead. ')
hm2AgentAclVlanTable = MibTable((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13), )
if mibBuilder.loadTexts: hm2AgentAclVlanTable.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanTable.setDescription('A table of ACL VLAN instances per direction.')
hm2AgentAclVlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13, 1), ).setIndexNames((0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclVlanIndex"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclVlanDirection"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclVlanSequence"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclVlanAclType"), (0, "HM2-PLATFORM-QOS-ACL-MIB", "hm2AgentAclVlanAclId"))
if mibBuilder.loadTexts: hm2AgentAclVlanEntry.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanEntry.setDescription('An ACL VLAN table entry.')
hm2AgentAclVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentAclVlanIndex.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanIndex.setDescription('The VLAN to which this ACL instance applies.')
hm2AgentAclVlanDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inbound", 1), ("outbound", 2))))
if mibBuilder.loadTexts: hm2AgentAclVlanDirection.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanDirection.setDescription('The VLAN direction to which this ACL instance applies.')
hm2AgentAclVlanSequence = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: hm2AgentAclVlanSequence.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanSequence.setDescription('The relative evaluation sequence of this ACL for this VLAN and direction. When multiple ACLs are allowed for a given VLAN and direction, the sequence number determines the order in which the list of ACLs are evaluated, with lower sequence numbers given higher precedence. The sequence number value is arbitrary, but must be an unique non-zero value for a given VLAN and direction. Setting this object to an existing sequence number value for a given VLAN and direction causes the ACL corresponding to that value to be replaced with this ACL.')
hm2AgentAclVlanAclType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ip", 1), ("mac", 2), ("ipv6", 3))))
if mibBuilder.loadTexts: hm2AgentAclVlanAclType.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanAclType.setDescription('The type of this ACL, which is used to interpret the hm2AgentAclVlanId object value. Each type of ACL uses its own numbering scheme for identification (see hm2AgentAclVlanAclId object for details). The hm2AgentAclVlanAclId object must be specified along with this object.')
hm2AgentAclVlanAclId = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647)))
if mibBuilder.loadTexts: hm2AgentAclVlanAclId.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanAclId.setDescription('The ACL identifier value, which is interpreted based on the hm2AgentAclVlanType object. For the IP ACLs, the actual ACL number is its identifier as follows: IP standard ranges from 1-99, while IP extended ranges from 100-199. Here, hm2AgentAclVlanAclId represents hm2AgentAclIndex. The MAC ACLs use an internally generated index value that is assigned when the ACL is created. Here, hm2AgentAclVlanAclId represents hm2AgentAclMacIndex. The IPv6 ACLs use an internally generated index value that is assigned when the ACL is created. Here, hm2AgentAclVlanAclId represents hm2AgentAclIpv6Index. The hm2AgentAclVlanType object must be specified along with this object.')
hm2AgentAclVlanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 13, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2AgentAclVlanStatus.setStatus('current')
if mibBuilder.loadTexts: hm2AgentAclVlanStatus.setDescription('Status of this instance. active(1) - this ACL VLAN instance is active createAndGo(4) - set to this value to assign an ACL to a VLAN and direction destroy(6) - set to this value to remove an ACL from a VLAN and direction')
hm2AgentOperatorRuleAssignOutboundInvalid = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 12, 3, 2, 248))
if mibBuilder.loadTexts: hm2AgentOperatorRuleAssignOutboundInvalid.setStatus('current')
if mibBuilder.loadTexts: hm2AgentOperatorRuleAssignOutboundInvalid.setDescription("IP ACL rule with 'greater than', 'lower than', 'not equal' operators cannot be assigned to an interface in outbound direction.")
mibBuilder.exportSymbols("HM2-PLATFORM-QOS-ACL-MIB", hm2AgentAclRuleDestL4PortRangeEnd=hm2AgentAclRuleDestL4PortRangeEnd, hm2AgentAclRuleMatchEvery=hm2AgentAclRuleMatchEvery, hm2AgentAclRuleTable=hm2AgentAclRuleTable, hm2AgentAclRuleTcpFlagMask=hm2AgentAclRuleTcpFlagMask, hm2AgentAclTrapRuleInstallationStatus=hm2AgentAclTrapRuleInstallationStatus, hm2AgentAclMacRuleTimeRangeStatus=hm2AgentAclMacRuleTimeRangeStatus, hm2AgentAclVlanIndex=hm2AgentAclVlanIndex, hm2AgentAclMacIndexNextFree=hm2AgentAclMacIndexNextFree, hm2AgentAclRuleDstL4PortOperator=hm2AgentAclRuleDstL4PortOperator, hm2AgentAclVlanDirection=hm2AgentAclVlanDirection, hm2AgentAclMacRuleVlanId=hm2AgentAclMacRuleVlanId, hm2AgentAclRuleStatsAction=hm2AgentAclRuleStatsAction, hm2AgentAclMacRuleHitCountDiscontinuityTime=hm2AgentAclMacRuleHitCountDiscontinuityTime, hm2AgentAclIfTable=hm2AgentAclIfTable, hm2AgentAclMacRuleEtypeKey=hm2AgentAclMacRuleEtypeKey, hm2AgentAclRuleTcpFlagBits=hm2AgentAclRuleTcpFlagBits, hm2AgentAclRuleIcmpCode=hm2AgentAclRuleIcmpCode, hm2AgentAclIfStatus=hm2AgentAclIfStatus, hm2AgentAclTable=hm2AgentAclTable, hm2AgentAclRuleSrcL4PortRangeStart=hm2AgentAclRuleSrcL4PortRangeStart, hm2AgentAclRuleDestL4PortRangeStart=hm2AgentAclRuleDestL4PortRangeStart, hm2AgentAclRuleRedirectExtAgentId=hm2AgentAclRuleRedirectExtAgentId, hm2AgentAclRuleLogging=hm2AgentAclRuleLogging, hm2AgentAclRuleRedirectIntf=hm2AgentAclRuleRedirectIntf, hm2AgentAclName=hm2AgentAclName, hm2AgentAclRuleStatus=hm2AgentAclRuleStatus, hm2AgentAclIfSequence=hm2AgentAclIfSequence, hm2AgentAclRuleIpTosBits=hm2AgentAclRuleIpTosBits, hm2AgentAclRuleSrcL4PortRangeEnd=hm2AgentAclRuleSrcL4PortRangeEnd, hm2AgentAclTrapRuleLogEvent=hm2AgentAclTrapRuleLogEvent, hm2AgentAclIfIndex=hm2AgentAclIfIndex, hm2AgentAclIfDirection=hm2AgentAclIfDirection, hm2AgentAclStatsAction=hm2AgentAclStatsAction, hm2AgentAclStatus=hm2AgentAclStatus, hm2AgentAclRuleDestL4Port=hm2AgentAclRuleDestL4Port, hm2AgentAclVlanEntry=hm2AgentAclVlanEntry, Hm2PortOperator=Hm2PortOperator, hm2AgentAclTrapRuleIndex=hm2AgentAclTrapRuleIndex, hm2AgentAclRuleEntry=hm2AgentAclRuleEntry, hm2AgentAclRuleFragments=hm2AgentAclRuleFragments, hm2AgentAclMacRuleDestMacAddr=hm2AgentAclMacRuleDestMacAddr, hm2AgentAclMacRuleIndexNextFree=hm2AgentAclMacRuleIndexNextFree, hm2AgentAclMacTable=hm2AgentAclMacTable, hm2AgentAclRuleHitCountDiscontinuityTime=hm2AgentAclRuleHitCountDiscontinuityTime, hm2AgentOperatorRuleAssignOutboundInvalid=hm2AgentOperatorRuleAssignOutboundInvalid, hm2AgentAclVlanSequence=hm2AgentAclVlanSequence, hm2AgentAclIndex=hm2AgentAclIndex, hm2AgentAclNamedIpv4IndexNextFree=hm2AgentAclNamedIpv4IndexNextFree, hm2AgentAclMacRuleEntry=hm2AgentAclMacRuleEntry, Ipv6AddressPrefix=Ipv6AddressPrefix, PYSNMP_MODULE_ID=hm2PlatformQosAcl, hm2AgentAclVlanTable=hm2AgentAclVlanTable, hm2AgentAclMacRuleVlanId2=hm2AgentAclMacRuleVlanId2, hm2AgentAclMacRuleRateLimitCburst=hm2AgentAclMacRuleRateLimitCburst, hm2AgentAclRuleSrcIpMask=hm2AgentAclRuleSrcIpMask, hm2AgentAclMacRuleMirrorIntf=hm2AgentAclMacRuleMirrorIntf, hm2AgentAclRuleIndex=hm2AgentAclRuleIndex, hm2AgentAclMacRuleRateLimitCrate=hm2AgentAclMacRuleRateLimitCrate, hm2AgentAclRuleSrcL4PortOperator=hm2AgentAclRuleSrcL4PortOperator, hm2AgentAclMacRuleSrcMacMask=hm2AgentAclMacRuleSrcMacMask, hm2AgentAclRuleIPDSCP=hm2AgentAclRuleIPDSCP, hm2AgentAclMacRuleStatsAction=hm2AgentAclMacRuleStatsAction, hm2AgentAclRuleHitCount=hm2AgentAclRuleHitCount, hm2AgentAclRuleEstablished=hm2AgentAclRuleEstablished, hm2AgentAclMacStatsAction=hm2AgentAclMacStatsAction, hm2AgentAclMacRuleTimeRangeName=hm2AgentAclMacRuleTimeRangeName, hm2AgentAclMacRuleSrcMacAddr=hm2AgentAclMacRuleSrcMacAddr, hm2AgentAclRuleAssignQueueId=hm2AgentAclRuleAssignQueueId, hm2AgentAclTrapRuleTimeRangeName=hm2AgentAclTrapRuleTimeRangeName, hm2AgentAclRuleTimeRangeStatus=hm2AgentAclRuleTimeRangeStatus, hm2AgentAclMacRuleVlanId2RangeEnd=hm2AgentAclMacRuleVlanId2RangeEnd, hm2AgentAclMacEntry=hm2AgentAclMacEntry, hm2AgentAclTrapRuleHitCountHigh=hm2AgentAclTrapRuleHitCountHigh, hm2AgentAclRuleRateLimitCrateUnit=hm2AgentAclRuleRateLimitCrateUnit, hm2AgentAclIfEntry=hm2AgentAclIfEntry, EtypeValue=EtypeValue, hm2AgentAclTrapRuleHitCount=hm2AgentAclTrapRuleHitCount, hm2AgentAclRuleTimeRangeName=hm2AgentAclRuleTimeRangeName, hm2AgentAclMacRuleHitCount=hm2AgentAclMacRuleHitCount, hm2AgentAclMacRuleIndex=hm2AgentAclMacRuleIndex, hm2AgentAclIfAclType=hm2AgentAclIfAclType, hm2AgentAclRuleRateLimitCrate=hm2AgentAclRuleRateLimitCrate, hm2AgentAclRuleMirrorIntf=hm2AgentAclRuleMirrorIntf, hm2AgentAclEntry=hm2AgentAclEntry, hm2AgentAclRuleAction=hm2AgentAclRuleAction, hm2AgentAclRuleSrcIpAddress=hm2AgentAclRuleSrcIpAddress, hm2PlatformQosAcl=hm2PlatformQosAcl, hm2AgentAclRuleIgmpType=hm2AgentAclRuleIgmpType, hm2AgentAclMacRuleMatchEvery=hm2AgentAclMacRuleMatchEvery, hm2AgentAclTrapFlag=hm2AgentAclTrapFlag, hm2AgentAclRuleRateLimitCburst=hm2AgentAclRuleRateLimitCburst, hm2AgentAclMacRuleCos2=hm2AgentAclMacRuleCos2, hm2AgentAclRuleIpPrecedence=hm2AgentAclRuleIpPrecedence, hm2AgentAclRuleDestIpMask=hm2AgentAclRuleDestIpMask, hm2AgentAclRuleIndexNextFree=hm2AgentAclRuleIndexNextFree, hm2AgentAclRuleIcmpType=hm2AgentAclRuleIcmpType, hm2AgentAclTrapRuleHitCountLow=hm2AgentAclTrapRuleHitCountLow, hm2AgentAclVlanAclType=hm2AgentAclVlanAclType, hm2AgentAclVlanAclId=hm2AgentAclVlanAclId, hm2AgentAclMacRuleAssignQueueId=hm2AgentAclMacRuleAssignQueueId, hm2AgentAclMacRuleVlanIdRangeStart=hm2AgentAclMacRuleVlanIdRangeStart, hm2AgentAclMacRuleStatus=hm2AgentAclMacRuleStatus, hm2AgentAclMacIndex=hm2AgentAclMacIndex, hm2AgentAclMacRuleRateLimitCrateUnit=hm2AgentAclMacRuleRateLimitCrateUnit, hm2AgentAclMacRuleEtypeValue=hm2AgentAclMacRuleEtypeValue, hm2AgentAclMacRuleRedirectIntf=hm2AgentAclMacRuleRedirectIntf, hm2AgentAclVlanStatus=hm2AgentAclVlanStatus, hm2AgentAclMacStatus=hm2AgentAclMacStatus, hm2AgentAclNotifications=hm2AgentAclNotifications, hm2AgentAclMacRuleLogging=hm2AgentAclMacRuleLogging, hm2AgentAclRuleProtocol=hm2AgentAclRuleProtocol, hm2AgentAclRuleDestIpAddress=hm2AgentAclRuleDestIpAddress, hm2AgentAclMacRuleDestMacMask=hm2AgentAclMacRuleDestMacMask, hm2AgentAclLoggingGroup=hm2AgentAclLoggingGroup, hm2AgentAclIfAclId=hm2AgentAclIfAclId, AclBurstSize=AclBurstSize, hm2AgentAclMacRuleCos=hm2AgentAclMacRuleCos, hm2AgentAclTrapRuleAction=hm2AgentAclTrapRuleAction, hm2AgentAclMacRuleVlanIdRangeEnd=hm2AgentAclMacRuleVlanIdRangeEnd, hm2AgentAclTrapRuleLogEventV1=hm2AgentAclTrapRuleLogEventV1, hm2AgentAclTrapRuleTimeRangeEvent=hm2AgentAclTrapRuleTimeRangeEvent, hm2AgentAclMacRuleAction=hm2AgentAclMacRuleAction, hm2AgentAclMacRuleVlanId2RangeStart=hm2AgentAclMacRuleVlanId2RangeStart, hm2AgentAclTrapRuleTimeRangeNotification=hm2AgentAclTrapRuleTimeRangeNotification, hm2AgentAclMacName=hm2AgentAclMacName, hm2AgentAclRuleIpTosMask=hm2AgentAclRuleIpTosMask, hm2AgentAclRuleSrcL4Port=hm2AgentAclRuleSrcL4Port, hm2AgentAclMacRuleTable=hm2AgentAclMacRuleTable)

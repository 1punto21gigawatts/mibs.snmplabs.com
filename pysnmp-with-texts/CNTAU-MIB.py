#
# PySNMP MIB module CNTAU-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CNTAU-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:25:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
MibIdentifier, Counter32, Gauge32, enterprises, IpAddress, iso, Integer32, Counter64, ModuleIdentity, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Unsigned32, NotificationType, TimeTicks, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "MibIdentifier", "Counter32", "Gauge32", "enterprises", "IpAddress", "iso", "Integer32", "Counter64", "ModuleIdentity", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Unsigned32", "NotificationType", "TimeTicks", "Bits")
TextualConvention, DisplayString, PhysAddress = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "PhysAddress")
cnt = MibIdentifier((1, 3, 6, 1, 4, 1, 333))
cntau = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1))
cntsystem = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 1))
cntSysNodeAddress = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSysNodeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cntSysNodeAddress.setDescription('Node address of this CNT platform. This value contains the region (1 byte), the bus (1 byte), and the node (2 bytes).')
cntSysTimeofDay = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSysTimeofDay.setStatus('mandatory')
if mibBuilder.loadTexts: cntSysTimeofDay.setDescription('The date and time from Battery-Backed-up RAM (BBRAM).')
cntSysMsgTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 3), )
if mibBuilder.loadTexts: cntSysMsgTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntSysMsgTable.setDescription('List of entries in the global mail box. This mail box contains any message that have been entered by any software residing in the node.')
cntMsgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1), ).setIndexNames((0, "CNTAU-MIB", "cntMsgIndex"))
if mibBuilder.loadTexts: cntMsgEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgEntry.setDescription('A mail box entry.')
cntMsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgIndex.setDescription('The relative index of this mail box message.')
cntMsgSeverity = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("information-msg", 1), ("possible-error", 2), ("recoverable-error", 3), ("fatal-error", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgSeverity.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgSeverity.setDescription('The severity of this mail box message.')
cntMsgTaskName = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgTaskName.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgTaskName.setDescription('The name of the module that sent this message to the mail box.')
cntMsgNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgNumber.setDescription('The number of this message. Each module numbers its message type as another way of describing it. This message can then be cross-referenced in the CNT system messages reference manual.')
cntMsgCpuNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgCpuNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgCpuNumber.setDescription('The CPU of the module that sent this message to the mail box.')
cntMsgNodeNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgNodeNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgNodeNumber.setDescription('The node number of the module that sent this message to the mail box.')
cntMsgDateTime = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgDateTime.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgDateTime.setDescription('The date and time that this message was sent to the mail box.')
cntMsgContent = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgContent.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgContent.setDescription('The textual contents of the message sent to the mail box.')
cntMsgSeqNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 3, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMsgSeqNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntMsgSeqNumber.setDescription('The sequence number for this message.')
cntSysHardware = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 1, 4))
cntHwBBramType = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("bbram-6500", 1), ("bbram-6704", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwBBramType.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwBBramType.setDescription('The type of battery backed up memory.')
cntHwBBramStatus = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("good", 1), ("failing", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwBBramStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwBBramStatus.setDescription('The status of the batteries used in the BBRAM. A failing status indicates that one or more of the batteries are failing.')
cntHwFailedCpu = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("no-failure", 1), ("lcp-1", 2), ("lcp-2", 3), ("lcp-3", 4), ("lcp-4", 5), ("lcp-5", 6), ("lcp-6", 7), ("lcp-7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwFailedCpu.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwFailedCpu.setDescription('The CPU number where a failure occurred. If this value is zero then there are no failures.')
cntHwMonCpu = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("no-failure", 1), ("lcp-1", 2), ("lcp-2", 3), ("lcp-3", 4), ("lcp-4", 5), ("lcp-5", 6), ("lcp-6", 7), ("lcp-7", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwMonCpu.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwMonCpu.setDescription('The CPU number of the monitor that noticed the CPU failure.')
cntHwFailStatus = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("not-up", 1), ("ok", 2), ("abort-switch", 3), ("abort-remote", 4), ("parity-error", 5), ("ac-failure", 6), ("system-failure", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwFailStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwFailStatus.setDescription('Status that the failing CPU recorded at the time of the failure.')
cntHwMonFailStatus = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-up", 1), ("ok", 2), ("failed", 3), ("mdm-error", 4), ("poll-error", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwMonFailStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwMonFailStatus.setDescription('Status that the monitoring CPU recorded at the time of the failure.')
cntHwFailDate = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwFailDate.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwFailDate.setDescription('Time and date when the processor failed.')
cntHwReset1Why = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwReset1Why.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwReset1Why.setDescription('The reason for the last reset.')
cntHwReset1Date = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 9), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwReset1Date.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwReset1Date.setDescription('The time and date of the last reset.')
cntHwReset2Why = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 10), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwReset2Why.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwReset2Why.setDescription('The reason for the second-to-last reset.')
cntHwReset2Date = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 11), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwReset2Date.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwReset2Date.setDescription('The time and date of the second-to-last reset.')
cntHwReset3Why = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 12), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwReset3Why.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwReset3Why.setDescription('The reason for the third-to-last reset.')
cntHwReset3Date = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 13), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwReset3Date.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwReset3Date.setDescription('The time and date of the third-to-last reset.')
cntHwPowerSupply = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("good", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwPowerSupply.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwPowerSupply.setDescription('The status of the power supply or power supplies. This value will indicate good only if all power supplies in the node are working. If any fan or power supply is failing, this object will indicate a failure even if enough power is supplied to keep the node operating.')
cntHwCpuTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15), )
if mibBuilder.loadTexts: cntHwCpuTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwCpuTable.setDescription('A list of CPU statistics entries. All possible CPUs for a box are accessible whether or not they even exist.')
cntHwCpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1), ).setIndexNames((0, "CNTAU-MIB", "cntCpuNum"))
if mibBuilder.loadTexts: cntHwCpuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwCpuEntry.setDescription('A CPU statistics entry.')
cntCpuNum = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuNum.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuNum.setDescription('The cpu index.')
cntCpuType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("no-cpu", 1), ("lcp-type1", 2), ("lcp-type2", 3), ("lcp-type3", 4), ("lcp-type4", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuType.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuType.setDescription('The type of the CPU requested.')
cntCpuSemCount = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuSemCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuSemCount.setDescription('The number of semaphores for this CPU.')
cntCpuSemLost = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuSemLost.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuSemLost.setDescription('The number of semaphores lost for this CPU.')
cntCpuStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("not-up", 1), ("ok", 2), ("abort-switch", 3), ("abort-remote", 4), ("parity-error", 5), ("ac-failure", 6), ("system-failure", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuStatus.setDescription('The current known status of this CPU.')
cntCpuMonStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("not-up", 1), ("ok", 2), ("failed", 3), ("mdm-error", 4), ("poll-error", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuMonStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuMonStatus.setDescription('The current status of this CPU as known by the monitoring CPU.')
cntCpuPollStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("normal", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuPollStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuPollStatus.setDescription('The status of the current polling request for this CPU.')
cntCpuPolls = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuPolls.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuPolls.setDescription('The number of polls sent for this CPU.')
cntCpuResetDelayTime = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuResetDelayTime.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuResetDelayTime.setDescription('The reset delay time, in seconds.')
cntCpuMonBy = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuMonBy.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuMonBy.setDescription('The system number for the CPU monitoring this CPU.')
cntCpuPort = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuPort.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuPort.setDescription('The port number for this CPU.')
cntCpuUnclaims = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuUnclaims.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuUnclaims.setDescription('The number of unclaimed grant interrupts on the system controller CPU.')
cntCpuXtraInts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuXtraInts.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuXtraInts.setDescription('The number of spurious interrupts.')
cntCpuLevel7s = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuLevel7s.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuLevel7s.setDescription('The number of unidentified level seven interrupts.')
cntCpuMsgRets = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuMsgRets.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuMsgRets.setDescription('The number of undeliverable MDM interprocessor messages.')
cntCpuMsgHolds = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuMsgHolds.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuMsgHolds.setDescription('The number of messages held which were being returned to the failed processor.')
cntCpuResetFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("off", 1), ("on", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuResetFlag.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuResetFlag.setDescription('The value of the reset flag.')
cntCpuUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuUtil.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuUtil.setDescription('The CPU utilization, in percent utilized.')
cntCpuLastFailDate = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 19), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuLastFailDate.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuLastFailDate.setDescription('The date and time of the last failure.')
cntCpuLastChgDate = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 15, 1, 20), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuLastChgDate.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuLastChgDate.setDescription('The date and time of the last change.')
cntHwStatusLED = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 4, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntHwStatusLED.setStatus('mandatory')
if mibBuilder.loadTexts: cntHwStatusLED.setDescription("Two digit, LCD display. During system initialization it indicates the processor that is being initialized. Successful initialization is indicated by a display of '00'.")
cntSysBuild = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 1, 5))
cntRevDate = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntRevDate.setStatus('mandatory')
if mibBuilder.loadTexts: cntRevDate.setDescription('The BBRAM revision date of the system description (!RV2) file.')
cntCustomer = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCustomer.setStatus('mandatory')
if mibBuilder.loadTexts: cntCustomer.setDescription('Customer name and other identifying information.')
cntMachineType = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMachineType.setStatus('mandatory')
if mibBuilder.loadTexts: cntMachineType.setDescription('The machine type of this node.')
cntSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntSerialNumber.setDescription('The machine serial number of this node.')
cntWorkOrderNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntWorkOrderNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntWorkOrderNumber.setDescription('The original manufacturing build work order number of this node.')
cntChassisNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntChassisNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntChassisNumber.setDescription('The machine chassis number of this node.')
cntModelNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntModelNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntModelNumber.setDescription('The machine model number of this node.')
cntReleaseLevel = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntReleaseLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cntReleaseLevel.setDescription('The original software release level installed in this node.')
cntRevEditDate = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntRevEditDate.setStatus('mandatory')
if mibBuilder.loadTexts: cntRevEditDate.setDescription('The date that this version of the system description (!RV2) file was edited dynamically.')
cntRevEditTime = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 10), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntRevEditTime.setStatus('mandatory')
if mibBuilder.loadTexts: cntRevEditTime.setDescription('The time that this version of the system description (!RV2) file was edited dynamically.')
cntFeatureTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 11), )
if mibBuilder.loadTexts: cntFeatureTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntFeatureTable.setDescription('The list of manufacturing features originally installed in this node.')
cntFeatureEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 11, 1), ).setIndexNames((0, "CNTAU-MIB", "cntFeatureIndex"))
if mibBuilder.loadTexts: cntFeatureEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntFeatureEntry.setDescription('A node feature entry.')
cntFeatureIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFeatureIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFeatureIndex.setDescription('The feature index.')
cntFeatureName = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 11, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFeatureName.setStatus('mandatory')
if mibBuilder.loadTexts: cntFeatureName.setDescription('The name of this feature.')
cntFeatureQuantity = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFeatureQuantity.setStatus('mandatory')
if mibBuilder.loadTexts: cntFeatureQuantity.setDescription('The quantity of this feature.')
cntFeatureDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 11, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFeatureDescr.setStatus('mandatory')
if mibBuilder.loadTexts: cntFeatureDescr.setDescription('A description of this feature.')
cntSlotTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12), )
if mibBuilder.loadTexts: cntSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotTable.setDescription('The list of VME slots in this node.')
cntSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1), ).setIndexNames((0, "CNTAU-MIB", "cntSlotIndex"))
if mibBuilder.loadTexts: cntSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotEntry.setDescription('A node slot entry.')
cntSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotIndex.setDescription('The slot index.')
cntSlotName = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotName.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotName.setDescription('The board name in this slot.')
cntSlotPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotPartNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotPartNumber.setDescription('The part number for the board in this slot.')
cntSlotSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotSerialNumber.setDescription('The serial number for the board in this slot.')
cntSlotRevLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotRevLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotRevLevel.setDescription('The revision number of the board in this slot.')
cntSlotInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotInterface.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotInterface.setDescription('The interface name of the board in this slot.')
cntSlotCpuNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotCpuNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotCpuNumber.setDescription('The cpu number of the board in this slot.')
cntSlotVMEbusGrant = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 12, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSlotVMEbusGrant.setStatus('mandatory')
if mibBuilder.loadTexts: cntSlotVMEbusGrant.setDescription('The VME bus grant priority of the board in this slot.')
cntIOTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13), )
if mibBuilder.loadTexts: cntIOTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOTable.setDescription('The list of VME I/O boards in this node.')
cntIOEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1), ).setIndexNames((0, "CNTAU-MIB", "cntIOIndex"))
if mibBuilder.loadTexts: cntIOEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOEntry.setDescription('A node board entry.')
cntIOIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIOIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOIndex.setDescription('The I/O board index.')
cntIOName = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIOName.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOName.setDescription('The I/O board name.')
cntIOPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIOPartNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOPartNumber.setDescription('The part number for this I/O board.')
cntIOSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIOSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOSerialNumber.setDescription('The serial number for this I/O board.')
cntIORevLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIORevLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cntIORevLevel.setDescription('The revision number of this I/O board.')
cntIOInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIOInterface.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOInterface.setDescription('The interface name of this I/O board.')
cntIOCpuNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 13, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIOCpuNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntIOCpuNumber.setDescription('The cpu number of this I/O board.')
cntPowerTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 14), )
if mibBuilder.loadTexts: cntPowerTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntPowerTable.setDescription('The list of power supplies in this node.')
cntPowerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 14, 1), ).setIndexNames((0, "CNTAU-MIB", "cntPowerIndex"))
if mibBuilder.loadTexts: cntPowerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntPowerEntry.setDescription('A node power supply entry.')
cntPowerIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntPowerIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntPowerIndex.setDescription('The power supply index.')
cntPowerName = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 14, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntPowerName.setStatus('mandatory')
if mibBuilder.loadTexts: cntPowerName.setDescription('The power supply name.')
cntPowerPartNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 14, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntPowerPartNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntPowerPartNumber.setDescription('The part number for this power supply.')
cntPowerSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 14, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntPowerSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntPowerSerialNumber.setDescription('The serial number for this power supply.')
cntPowerRevLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 14, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntPowerRevLevel.setStatus('mandatory')
if mibBuilder.loadTexts: cntPowerRevLevel.setDescription('The revision number of this power supply.')
cntSCRTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 15), )
if mibBuilder.loadTexts: cntSCRTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntSCRTable.setDescription('The list of SCRs in this node.')
cntSCREntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 15, 1), ).setIndexNames((0, "CNTAU-MIB", "cntSCRIndex"))
if mibBuilder.loadTexts: cntSCREntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntSCREntry.setDescription('A node SCR entry.')
cntSCRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 15, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSCRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntSCRIndex.setDescription('The SCR index.')
cntSCRNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 15, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSCRNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntSCRNumber.setDescription('A SCR number installed in this node.')
cntSerialAlfaNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 5, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSerialAlfaNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntSerialAlfaNumber.setDescription('The machine serial number of this node.')
cntSysMemory = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 1, 6))
cntMemBBramAddress = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 6, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMemBBramAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cntMemBBramAddress.setDescription('The starting address of battery-backed-up RAM. BBRAM is used to store the software and configuration files.')
cntMemBBramSpace = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 6, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMemBBramSpace.setStatus('mandatory')
if mibBuilder.loadTexts: cntMemBBramSpace.setDescription('The amount of BBRAM memory in bytes installed in this node.')
cntMemBBramFree = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 6, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMemBBramFree.setStatus('mandatory')
if mibBuilder.loadTexts: cntMemBBramFree.setDescription('The amount of BBRAM memory in bytes available in this node.')
cntMemSramAddress = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 6, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMemSramAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cntMemSramAddress.setDescription('The starting address of static ram. SRAM is used as buffer space.')
cntMemSramSpace = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 6, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMemSramSpace.setStatus('mandatory')
if mibBuilder.loadTexts: cntMemSramSpace.setDescription('The amount of SRAM memory in bytes installed in this node.')
cntMemSramFree = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 1, 6, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMemSramFree.setStatus('mandatory')
if mibBuilder.loadTexts: cntMemSramFree.setDescription('The amount of SRAM memory in bytes available in this node.')
cntSysCpuTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 7), )
if mibBuilder.loadTexts: cntSysCpuTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntSysCpuTable.setDescription('List of cpu entries.')
cntSysCpuEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1), ).setIndexNames((0, "CNTAU-MIB", "cntCpuIndex"))
if mibBuilder.loadTexts: cntSysCpuEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntSysCpuEntry.setDescription('A cpu entry.')
cntCpuIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuIndex.setDescription('The cpu index.')
cntCpuMemSpace = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuMemSpace.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuMemSpace.setDescription('The amount of memory in bytes installed in this cpu.')
cntCpuMemFree = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuMemFree.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuMemFree.setDescription('The amount of memory in bytes available in this cpu.')
cntCpuTaskTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1, 4), )
if mibBuilder.loadTexts: cntCpuTaskTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuTaskTable.setDescription('List of cpu task entries.')
cntCpuTaskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1, 4, 1), ).setIndexNames((0, "CNTAU-MIB", "cntCpuTaskIndex"))
if mibBuilder.loadTexts: cntCpuTaskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuTaskEntry.setDescription('A cpu task list entry.')
cntCpuTaskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuTaskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuTaskIndex.setDescription('The relative index of the task on this cpu.')
cntCpuTaskName = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 1, 7, 1, 4, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCpuTaskName.setStatus('mandatory')
if mibBuilder.loadTexts: cntCpuTaskName.setDescription('The operating system name for a loaded and possibly executing task on this cpu.')
cntinterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 2))
cntifTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 2, 1), )
if mibBuilder.loadTexts: cntifTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntifTable.setDescription('A list of CNT interface entries.')
cntifEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 2, 1, 1), ).setIndexNames((0, "CNTAU-MIB", "cntifIndex"))
if mibBuilder.loadTexts: cntifEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntifEntry.setDescription('An CNT interface entry.')
cntifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntifIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntifIndex.setDescription('An index value that uniquely identifies an interface on a CNT node. The interface identified by a particular value of this index is the same interface as identified by the same value of IfIndex.')
cntifType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63))).clone(namedValues=NamedValues(("other", 1), ("regular1822", 2), ("hdh1822", 3), ("ddn-x25", 4), ("rfc877-x25", 5), ("ethernet", 6), ("ethernet88023", 7), ("tokenBus", 8), ("tokenRing", 9), ("smds", 10), ("starLan", 11), ("proteon-10MBit", 12), ("proteon-80MBit", 13), ("hyperchannel", 14), ("fddi", 15), ("lapb", 16), ("sdlc", 17), ("t1", 18), ("cept", 19), ("basicIsdn", 20), ("primaryIsdn", 21), ("maintenance", 22), ("ppp", 23), ("sofwareLoopback", 24), ("eon", 25), ("ethernet-3Mbit", 26), ("nsip", 27), ("slip", 28), ("ultra", 29), ("ds3", 30), ("sip", 31), ("frame-relay", 32), ("hssi-dte", 33), ("fibre-trunk", 34), ("hippi", 35), ("crayfullduplex", 36), ("pt-to-pt-fiber", 37), ("channel-to-channel", 38), ("peripheral-gateway", 39), ("tape-pipelining", 40), ("tape-dasd", 41), ("hssi-dce", 42), ("ibm-channel", 43), ("dual-trunk", 44), ("teradata", 45), ("cray-hyperchannel", 46), ("scsi-target", 47), ("snmp-gateway", 48), ("ppp-async", 49), ("escon-host", 50), ("escon-peripheral", 51), ("tapecontrol-rs232", 52), ("ultra-dte", 53), ("ultra-dce", 54), ("fddi-ss", 55), ("hssi-ss", 56), ("tunneling", 57), ("stackstarter", 58), ("ethernet-geni", 59), ("tokenring-geni", 60), ("atm", 61), ("scsi-initiator", 62), ("escon-srdf", 63)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntifType.setStatus('mandatory')
if mibBuilder.loadTexts: cntifType.setDescription('The type of interface. For standardized interface types in mib-2, this number is redundant. CNT specific interface types are appended to the end of the standardized list.')
cntifCpu = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntifCpu.setStatus('mandatory')
if mibBuilder.loadTexts: cntifCpu.setDescription('The cpu number where the device driver for this interface resides.')
cntifSubIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntifSubIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntifSubIndex.setDescription('A value that uniquely indexes an interface in a multiply-interfaced device driver.')
cntIfsState = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIfsState.setStatus('mandatory')
if mibBuilder.loadTexts: cntIfsState.setDescription('A 32 bit-map of the interface states. The bits are ordered from 1 to 32 with the most significant bit on the left. if the bit is set, the corresponding interface is up. if the bit is clear, the interface is not up - down or in test mode.')
cnticmp = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 5))
cnticmpInDuNets = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInDuNets.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInDuNets.setDescription('The number of times a destination unreachable message was received for an unreachable network.')
cnticmpInDuHosts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInDuHosts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInDuHosts.setDescription('The number of times a destination unreachable message was received for an unreachable host.')
cnticmpInDuProtos = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInDuProtos.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInDuProtos.setDescription('The number of times a destination unreachable message was received due to an unreachable protocol.')
cnticmpInDuPorts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInDuPorts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInDuPorts.setDescription('The number of times a destination unreachable message was received due to an unreachable port.')
cnticmpInDuFrags = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInDuFrags.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInDuFrags.setDescription("The number of times a destination unreachable message was received due to a fragmentation requirement but the Don't Fragment flag is set.")
cnticmpInDuSources = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInDuSources.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInDuSources.setDescription('The number of times a destination unreachable message was received due to a source route that is not usable.')
cnticmpInTmXceeds = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInTmXceeds.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInTmXceeds.setDescription('The number of times a time exceeded message was received for an expired datagram.')
cnticmpInTmFrags = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInTmFrags.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInTmFrags.setDescription('The number of times a time exceeded message was received for a datagram that could not be reassembled before its lifetime expired.')
cnticmpInReNets = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInReNets.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInReNets.setDescription('The number of times a redirect message was received due to a shorter path to a destination network having been found.')
cnticmpInReHosts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInReHosts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInReHosts.setDescription('The number of times a redirect message was received due to a shorter path to a destination host having been found.')
cnticmpInReServnets = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInReServnets.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInReServnets.setDescription('The number of times a redirect message was received due to a shorter path to a destination network with the requested type of service having been found.')
cnticmpInReServhosts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpInReServhosts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpInReServhosts.setDescription('The number of times a redirect message was received due to a shorter path to a destination host with the requested type of service having been found.')
cnticmpOutDuNets = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutDuNets.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutDuNets.setDescription('The number of times a destination unreachable message was sent to a requester when it attempted to send a datagram to an unreachable network.')
cnticmpOutDuHosts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutDuHosts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutDuHosts.setDescription('The number of times a destination unreachable message was sent to a requester when it attempted to send a datagram to an unreachable host.')
cnticmpOutDuProtos = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutDuProtos.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutDuProtos.setDescription('The number of times a destination unreachable message was sent to a requester when it attempted to send a datagram to an unreachable protocol.')
cnticmpOutDuPorts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutDuPorts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutDuPorts.setDescription('The number of times a destination unreachable message was sent to a requester when it attempted to send a datagram to an unreachable port.')
cnticmpOutDuFrags = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutDuFrags.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutDuFrags.setDescription("The number of times a destination unreachable message was sent to a requester when it attempted to send a datagram requiring fragmentation but the Don't Fragment flag is set.")
cnticmpOutDuSources = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutDuSources.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutDuSources.setDescription('The number of times a destination unreachable message was sent due to a source route that is not usable.')
cnticmpOutTmXceeds = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutTmXceeds.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutTmXceeds.setDescription('The number of times a time exceeded message was sent for an expired datagram.')
cnticmpOutTmFrags = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutTmFrags.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutTmFrags.setDescription('The number of times a time exceeded message was sent for a datagram that could not be reassembled before its lifetime expired.')
cnticmpOutReNets = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutReNets.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutReNets.setDescription('The number of times a redirect message was sent due to a shorter path to a destination network having been found.')
cnticmpOutReHosts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutReHosts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutReHosts.setDescription('The number of times a redirect message was sent due to a shorter path to a destination host having been found.')
cnticmpOutReServnets = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutReServnets.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutReServnets.setDescription('The number of times a redirect message was sent due to a shorter path to a destination network with the requested type of service having been found.')
cnticmpOutReServhosts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 5, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnticmpOutReServhosts.setStatus('mandatory')
if mibBuilder.loadTexts: cnticmpOutReServhosts.setDescription('The number of times a redirect message was sent due to a shorter path to a destination host with the requested type of service having been found.')
cnttransmission = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 10))
cntdot3 = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 10, 1))
cntdot3Table = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1), )
if mibBuilder.loadTexts: cntdot3Table.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3Table.setDescription('Status information and control variables for a collection of ethernet software device drivers in a particular CNT system.')
cntdot3Entry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1), ).setIndexNames((0, "CNTAU-MIB", "cntdot3Index"))
if mibBuilder.loadTexts: cntdot3Entry.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3Entry.setDescription('Status information and control variables for a particular CNT ethernet software device driver.')
cntdot3Index = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3Index.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3Index.setDescription('An index value that uniquely identifies an interface to a CNT ethernet-like medium. The interface identified by a particular value of this index is the same interface as identified by the same value of IfIndex.')
cntdot3SoftwareID = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3SoftwareID.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3SoftwareID.setDescription('The binary software revision number in the header of the ethernet driver.')
cntdot3BufsAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3BufsAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3BufsAllocated.setDescription('The number of CNT buffers allocated by the ethernet device driver at initialization.')
cntdot3BufTooManys = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3BufTooManys.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3BufTooManys.setDescription('The number of buffers sent by a higher layer that were returned to that layer without transmission due to a full queue of waiting outbound buffers.')
cntdot3BufNotAvails = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3BufNotAvails.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3BufNotAvails.setDescription('The number of requests made to the free pool of ethernet buffers that failed due to a lack buffers in that pool.')
cntdot3BufPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3BufPriority.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3BufPriority.setDescription('The priority value assigned to inbound ethernet buffers.')
cntdot3PICBusErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3PICBusErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3PICBusErrs.setDescription('The number of times a failure was detected when attempting to access the VME bus.')
cntdot3PICDMAErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3PICDMAErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3PICDMAErrs.setDescription('The number of times ethernet local memory had a parity error during a DMA memory cycle. These errors would normally indicate a hardware problem.')
cntdot3PICMemSeqErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3PICMemSeqErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3PICMemSeqErrs.setDescription('The number of times the hardware could not successfully arbitrate multiple requests to access ethernet local memory. These errors would normally indicate a hardware problem.')
cntdot3PICMemParityErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3PICMemParityErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3PICMemParityErrs.setDescription('The number of ethernet local memory parity errors. These errors would normally indicate a hardware problem.')
cntdot3PICSpuriousInts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3PICSpuriousInts.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3PICSpuriousInts.setDescription('The number of interrupts generated by the PIC that were not mapped to any particular hardware event.')
cntdot3LanceInts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LanceInts.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LanceInts.setDescription('The number of LANCE hardware interrupts detected by the controlling CPU.')
cntdot3LanceParityErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LanceParityErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LanceParityErrs.setDescription('The number of parity errors detected when the LANCE was accessing local memory. These errors would normally indicate a hardware problem.')
cntdot3LanceMemErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LanceMemErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LanceMemErrs.setDescription('The number of times the LANCE detected a local memory access failure.')
cntdot3LanceMissedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LanceMissedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LanceMissedPkts.setDescription('The number of packets on the ethernet medium that were detected by the LANCE but failed to be captured in the inbound queue.')
cntdot3LanceUnderFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LanceUnderFlows.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LanceUnderFlows.setDescription('The number of message truncated by the LANCE transmitter due to data late from memory. An underflow indication by the LANCE indicates that the silo was emptied before the end of the packet was reached.')
cntdot3LanceOverFlows = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LanceOverFlows.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LanceOverFlows.setDescription('The number of times the LANCE receiver lost all or part of the incoming packet due to an inability to store the packet in a memory buffer before the internal silo overflowed.')
cntdot3LanceTxWaitQ = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LanceTxWaitQ.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LanceTxWaitQ.setDescription("The number of buffers in local memory and on the ethernet device driver's software queue awaiting transmission by the LANCE.")
cntdot3DMAChan1RxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 5, 6, 7, 9, 10, 11, 13, 15, 16, 17))).clone(namedValues=NamedValues(("no-error", 0), ("config", 1), ("operation-timing", 2), ("address-mar", 5), ("address-dar", 6), ("address-bar", 7), ("buserr-mar", 9), ("buserr-dar", 10), ("buserr-bar", 11), ("count-mtc", 13), ("count-btc", 15), ("external-abort", 16), ("external-software-abort", 17)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan1RxErr.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan1RxErr.setDescription('The error code reported by the DMA controller channel 1. This channel is used to write inbound ethernet messages.')
cntdot3DMAChan3RxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 6, 7, 8, 10, 11, 12, 14, 16, 17, 18))).clone(namedValues=NamedValues(("no-error", 1), ("config", 2), ("operation-timing", 3), ("address-mar", 6), ("address-dar", 7), ("address-bar", 8), ("buserr-mar", 10), ("buserr-dar", 11), ("buserr-bar", 12), ("count-mtc", 14), ("count-btc", 16), ("external-abort", 17), ("external-software-abort", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan3RxErr.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan3RxErr.setDescription('The error code reported by the DMA controller channel 3. This channel is used to write inbound ethernet messages.')
cntdot3DMAChan0TxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 6, 7, 8, 10, 11, 12, 14, 16, 17, 18))).clone(namedValues=NamedValues(("no-error", 1), ("config", 2), ("operation-timing", 3), ("address-mar", 6), ("address-dar", 7), ("address-bar", 8), ("buserr-mar", 10), ("buserr-dar", 11), ("buserr-bar", 12), ("count-mtc", 14), ("count-btc", 16), ("external-abort", 17), ("external-software-abort", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan0TxErr.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan0TxErr.setDescription('The error code reported by the DMA controller channel 0. This channel is used to write outbound ethernet messages.')
cntdot3DMAChan2TxErr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 6, 7, 8, 10, 11, 12, 14, 16, 17, 18))).clone(namedValues=NamedValues(("no-error", 1), ("config", 2), ("operation-timing", 3), ("address-mar", 6), ("address-dar", 7), ("address-bar", 8), ("buserr-mar", 10), ("buserr-dar", 11), ("buserr-bar", 12), ("count-mtc", 14), ("count-btc", 16), ("external-abort", 17), ("external-software-abort", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan2TxErr.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan2TxErr.setDescription('The error code reported by the DMA controller channel 2. This channel is used to write outbound ethernet messages.')
cntdot3DMAChan1RxErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan1RxErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan1RxErrs.setDescription('The number of errors reported by the DMA controller channel 1. This channel is used to write inbound ethernet messages.')
cntdot3DMAChan3RxErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan3RxErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan3RxErrs.setDescription('The number of errors reported by the DMA controller channel 1. This channel is used to write inbound ethernet messages.')
cntdot3DMAChan0TxErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan0TxErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan0TxErrs.setDescription('The number of errors reported by the DMA controller channel 1. This channel is used to write outbound ethernet messages.')
cntdot3DMAChan2TxErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMAChan2TxErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMAChan2TxErrs.setDescription('The number of errors reported by the DMA controller channel 1. This channel is used to write outbound ethernet messages.')
cntdot3DMARxWaitQ = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMARxWaitQ.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMARxWaitQ.setDescription('The number of successfully received ethernet messages awaiting transmission by the DMA to global memory buffers.')
cntdot3DMATxWaitQ = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 28), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3DMATxWaitQ.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3DMATxWaitQ.setDescription('The number of buffers waiting in an outbound queue ready to transmitted to local memory from global memory. Buffers must be moved from global memory to local memory in order to be transmitted by the LANCE.')
cntdot3LPXParityErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3LPXParityErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3LPXParityErrs.setDescription('The number of local memory parity errors during an LPX memory cycle.')
cntdot3Chan1Misreads = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 1, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdot3Chan1Misreads.setStatus('mandatory')
if mibBuilder.loadTexts: cntdot3Chan1Misreads.setDescription('The number of times a mismatch was detected between the DMA channel 1 table and the DMA Memory Access Register.')
cntfddi = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 10, 2))
cntFddiSMT = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1))
cntFddiMAC = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2))
cntFddiPATH = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3))
cntFddiPORT = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4))
cntFddiSMTNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiSMTNumber.setDescription('The number of SMT implementations on this network management application entity.')
cntFddiSMTTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2), )
if mibBuilder.loadTexts: cntFddiSMTTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiSMTTable.setDescription('A list of SMT entries. The number of entries is given by the value of snmpFddiSMTNumber.')
cntFddiSMTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1), ).setIndexNames((0, "CNTAU-MIB", "cntFddiSMTIndex"))
if mibBuilder.loadTexts: cntFddiSMTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiSMTEntry.setDescription('An SMT entry containing information common to a given SMT.')
cntFddiSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiSMTIndex.setDescription('A unique value for each SMT. Its value ranges between 1 and the value of snmpFddiSMTNumber.')
cntFddiSMTManufacturerData = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTManufacturerData.setStatus('optional')
if mibBuilder.loadTexts: cntFddiSMTManufacturerData.setDescription("32 octets of manufacturer data. The first component is the three octet Organizationally Unique Identifier (OUI) assigned by IEEE. The second component is the FDDI manufacturer's data (29 octets).")
cntFddiSMTUserData = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTUserData.setStatus('optional')
if mibBuilder.loadTexts: cntFddiSMTUserData.setDescription('32 octets of user defined information.')
cntFddiSMTReportLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTReportLimit.setStatus('optional')
if mibBuilder.loadTexts: cntFddiSMTReportLimit.setDescription('Gives the limit on the number of Status Report Frames that shall be queued for transmission after supported Condition becomes inactive or after any supported Event has been detected.')
cntFddiSMTMsgTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTMsgTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiSMTMsgTimeStamp.setDescription("This timestamp is used in some SMT frames as an indication of the time the message was created at the sending station. When read, the accessed value shall be greater than or equal to the value used in the station's last message. The timestamp may be reset whenever there is a discontinuity in the accumulation of a statistical counter.")
cntFddiSMTTransitionTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 6), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTTransitionTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiSMTTransitionTimeStamp.setDescription('This timestamp holds the time of occurrence of the last condition or event in the station. It is used in the SMT Status Report Frame (SRF). It is set to a new value on each event to capture the time of the latest event occurrence. On power-up, the value of the attribute is zero.')
cntFddiSMTSetCount = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 7), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTSetCount.setStatus('optional')
if mibBuilder.loadTexts: cntFddiSMTSetCount.setDescription('This count is updated each time a parameter is changed on behalf of a request from either the local management interface or the remote interface via SMT Parameter Management Frames. It is used to provide consistency control for MIB updates.')
cntFddiSMTLastSetStationID = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 1, 2, 1, 8), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiSMTLastSetStationID.setStatus('optional')
if mibBuilder.loadTexts: cntFddiSMTLastSetStationID.setDescription('This object identifies the last station to set MIB information in the FDDI MIB.')
cntFddiMACNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiMACNumber.setDescription('The total number of MAC implementations across all SMTs on this network management application entity.')
cntFddiMACTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2), )
if mibBuilder.loadTexts: cntFddiMACTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiMACTable.setDescription('A list of MAC entries. The number of entries is given by the value of snmpFddiMACNumber.')
cntFddiMACEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1), ).setIndexNames((0, "CNTAU-MIB", "cntFddiMACSMTIndex"))
if mibBuilder.loadTexts: cntFddiMACEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiMACEntry.setDescription('A MAC entry containing information common to a given MAC.')
cntFddiMACSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiMACSMTIndex.setDescription('The value of the SMT index associated with this MAC.')
cntFddiMACIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiMACIndex.setDescription('A unique value for each MAC on the managed entity. The MAC identified by a particular value of this index is that identified by the same value of an ifIndex object instance.')
cntFddiMACBridgeFunction = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBridgeFunction.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBridgeFunction.setDescription('Gives the bridge type for a MAC that has a bridge capability.')
cntFddiMACDownstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACDownstreamNbr.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACDownstreamNbr.setDescription("The MAC's downstream neighbor's long individual MAC address. It may be determined by the Neighbor Information Frame Request/ Response protocol. It is optional an reported as zero in SMT frames if unknown or unsupported.")
cntFddiMACOldDownstreamNbr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACOldDownstreamNbr.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACOldDownstreamNbr.setDescription("This object identifies this MAC's previous downstream neighbor.")
cntFddiMACRootConcentratorMac = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACRootConcentratorMac.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACRootConcentratorMac.setDescription("A MAC in a concentrator is a root concentrator MAC if its transmit path exits the concentrator via a Port in a peer node; or if the MAC exits via a Port in a tree node and there is no A, B, or S Ports that are active on that MAC's current Path.")
cntFddiMACLongAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACLongAlias.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACLongAlias.setDescription('A possibly null set of 48 bit addresses (aliases) for this MAC.')
cntFddiMACShortAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACShortAlias.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACShortAlias.setDescription('A possibly null set of 16 bit addresses (aliases) for this MAC.')
cntFddiMACLongGrpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACLongGrpAddr.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACLongGrpAddr.setDescription('A possibly null set of 48 bit group addresses (aliases) for this MAC.')
cntFddiMACShortGrpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACShortGrpAddr.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACShortGrpAddr.setDescription('A possibly null set of 16 bit group addresses (aliases) for this MAC.')
cntFddiMACTPri0 = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTPri0.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTPri0.setDescription('Reference: Mac 2.2.1. It is reported as the unsigned twos-complement of the number (as described in the MAC specification; ref. MAC 7.3.5.2).')
cntFddiMACTPri1 = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTPri1.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTPri1.setDescription('Reference: Mac 2.2.1. It is reported as the unsigned twos-complement of the number (as described in the MAC specification; ref. MAC 7.3.5.2).')
cntFddiMACTPri2 = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTPri2.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTPri2.setDescription('Reference: Mac 2.2.1. It is reported as the unsigned twos-complement of the number (as described in the MAC specification; ref. MAC 7.3.5.2).')
cntFddiMACTPri3 = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTPri3.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTPri3.setDescription('Reference: Mac 2.2.1. It is reported as the unsigned twos-complement of the number (as described in the MAC specification; ref. MAC 7.3.5.2).')
cntFddiMACTPri4 = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTPri4.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTPri4.setDescription('Reference: Mac 2.2.1. It is reported as the unsigned twos-complement of the number (as described in the MAC specification; ref. MAC 7.3.5.2).')
cntFddiMACTPri5 = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTPri5.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTPri5.setDescription('Reference: Mac 2.2.1. It is reported as the unsigned twos-complement of the number (as described in the MAC specification; ref. MAC 7.3.5.2).')
cntFddiMACTPri6 = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTPri6.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTPri6.setDescription('Reference: Mac 2.2.1. It is reported as the unsigned twos-complement of the number (as described in the MAC specification; ref. MAC 7.3.5.2).')
cntFddiMACCopies = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACCopies.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACCopies.setDescription("The count of frames successfully received into the station's receive buffers by this MAC. Note that this count does not include the frames that are not copied. This counter is optional.")
cntFddiMACTransmits = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTransmits.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTransmits.setDescription('The count of frames transmitted by the MAC.')
cntFddiMACTokens = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTokens.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTokens.setDescription('The total count of the number of times the station has received a token (total of non-restricted and restricted) on this MAC. This count is used for determination of network load.')
cntFddiMACTvxExpires = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACTvxExpires.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACTvxExpires.setDescription('A count of the times that TVX expired.')
cntFddiMACNotCopies = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACNotCopies.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACNotCopies.setDescription('The count of frames that should have been copied but were not. This might occur due to local buffer congestion. Because of implementation considerations, this count may be less than the actual number of frames not copied. It is not a requirement that this count be exact.')
cntFddiMACLates = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACLates.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACLates.setDescription('Reference: MAC 2.2.1, LateCt.')
cntFddiMACRingOps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACRingOps.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACRingOps.setDescription("The count of the number of times the ring has entered the 'Ring Operational' state from 'Ring Not Operational' state. Because of implementation considerations, this count may not be exact.")
cntFddiMACBaseFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBaseFrames.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBaseFrames.setDescription('The value of FddiMACFrameCt at the sample time prior to the sample time when the FrameErrorThreshold was reached. It is used in reporting the condition to give the manager the necessary data to reconstruct the condition at the station. Reset when the associated condition becomes active.')
cntFddiMACBaseErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBaseErrs.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBaseErrs.setDescription("The value of FddiMACErrorCt at the sample time prior to the sample time when the FrameErrorThreshold was reached. It is used in reporting the condition to give the manager the necessary data to reconstruct the condition at the station. Reset to the current value of the corresponding 'real' counter when the associated condition becomes active.")
cntFddiMACBaseLosts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBaseLosts.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBaseLosts.setDescription("The value of FddiMACLostCt at the sample time prior to the sample time when the FrameErrorThreshold was reached. It is used in reporting the condition to give the manager the necessary data to reconstruct the condition at the station. Reset to the current value of the corresponding 'real' counter when the associated condition becomes active.")
cntFddiMACBaseTimeFrameError = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 28), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBaseTimeFrameError.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBaseTimeFrameError.setDescription('The value of the station timer at the sample time prior to the sample time when the FrameErrorThreshold was reached. It is used in reporting the condition to give the manager the necessary data to reconstruct the condition at the station. Reset when the new condition becomes active.')
cntFddiMACBaseNotCopies = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBaseNotCopies.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBaseNotCopies.setDescription('The value of FddiMACNotCopiedCt at the sample time prior to the sample time when the NotCopiedThreshold was reached. It is used in reporting the condition to give the manager the necessary data to reconstruct the condition at the station. Reset when the new condition becomes active.')
cntFddiMACBaseTimeNotCopied = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 30), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBaseTimeNotCopied.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBaseTimeNotCopied.setDescription('The value of the station timer at the sample time prior to the sample time when the NotCopiedThreshold was reached. It is used in reporting the condition to give the manager the necessary data to reconstruct the condition at the station. Reset when the new condition becomes active.')
cntFddiMACNotCopiedThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACNotCopiedThreshold.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACNotCopiedThreshold.setDescription("A threshold for determining when a MAC Condition report should be generated. It is used to determine when a station has an unacceptable count of frames 'not-copied'. It could be used as an indication of buffer congestion on this MAC.")
cntFddiMACBaseCopies = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACBaseCopies.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACBaseCopies.setDescription('The value of FddiMACCopiedCt at the sample time prior to the sample time when the NotCopiedThreshold was reached. It is used in reporting the condition to give the manager the necessary data to reconstruct the condition at the station. Reset when the new condition becomes active.')
cntFddiMACNotCopiedRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 33), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACNotCopiedRatio.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACNotCopiedRatio.setDescription('This attribute is the value of the ratio: FddiMACNotCopiedCt ----------------------------------- * (2 ** 16) FddiMACCopiedCt + FddiMACNotCopiedCt')
cntFddiMACNotCopiedCondition = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 34), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACNotCopiedCondition.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACNotCopiedCondition.setDescription('Indicates the NotCopiedCondition is active when set. Cleared when the condition clears and on power up.')
cntFddiMACLLCServiceAvailable = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACLLCServiceAvailable.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACLLCServiceAvailable.setDescription('Indicates whether the LLC Service is enabled.')
cntFddiMACMasterSlaveLoopStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACMasterSlaveLoopStatus.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACMasterSlaveLoopStatus.setDescription("Indicates this MAC's Master/Slave Loop Status. This status would be obtained with the Root MAC Information Protocol.")
cntFddiMACRootMACDownStreamPORTType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACRootMACDownStreamPORTType.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACRootMACDownStreamPORTType.setDescription('Indicates the PC-Type of the first PORT that is downstream of the Root MAC associated with this MAC. The Root MAC information would be determined in the Root MAC Information Protocol.')
cntFddiMACRootMACCurrentPath = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 2, 2, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiMACRootMACCurrentPath.setStatus('optional')
if mibBuilder.loadTexts: cntFddiMACRootMACCurrentPath.setDescription('Indicates the current path of the Root MAC on the same logical ring as this MAC. This Root MAC information would be determined in the Root MAC Information Protocol.')
cntFddiPATHNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHNumber.setDescription('The total number of PATH implementations across all SMTs on this network management application entity.')
cntFddiPATHTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2), )
if mibBuilder.loadTexts: cntFddiPATHTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHTable.setDescription('A list of PATH entries. The number of entries is given by the value of snmpFddiPATHNumber.')
cntFddiPATHEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1), ).setIndexNames((0, "CNTAU-MIB", "cntFddiPATHSMTIndex"))
if mibBuilder.loadTexts: cntFddiPATHEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHEntry.setDescription('A PATH entry containing information common to a given PATH.')
cntFddiPATHSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHSMTIndex.setDescription('The value of the SMT index associated with this PATH.')
cntFddiPATHIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHIndex.setDescription('A unique value for each PATH within a given SMT. Its value ranges between 1 and the sum of the values of snmpFddiSMTNonMasterCt and snmpFddiSMTMasterCt on the given SMT.')
cntFddiPATHTraceMaxExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHTraceMaxExpiration.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHTraceMaxExpiration.setDescription('Reference: SMT 9.4.4.2.2 TraceMax.')
cntFddiPATHTVXLowerBound = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHTVXLowerBound.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPATHTVXLowerBound.setDescription('The lower bound of TVX supported for this PATH.')
cntFddiPATHTMaxLowerBound = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHTMaxLowerBound.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPATHTMaxLowerBound.setDescription('The lower bound of TMax supported for this PATH class.')
cntFddiPATHType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHType.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHType.setDescription('This object describes the type of PATH: 1 = Primary, 2 = Secondary, 3 = Local.')
cntFddiPATHPORTOrder = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHPORTOrder.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHPORTOrder.setDescription('Tells whether the PORTs on this path are numbered in ascending of descending order.')
cntFddiPATHRingLatency = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHRingLatency.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPATHRingLatency.setDescription('Gives the total accumulated latency of the ring associated with this PATH. May be measured directly by the station or may be calculated by a management station.')
cntFddiPATHTraceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHTraceStatus.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPATHTraceStatus.setDescription('Gives the current trace status of the PATH.')
cntFddiPATHSba = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHSba.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHSba.setDescription("The Synchronous Bandwidth Allocation for this PATH within the station in octet units. In stations that don't support synchronous service, this attribute is read only and has the value of 0.")
cntFddiPATHSbaOverhead = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHSbaOverhead.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHSbaOverhead.setDescription("The Synchronous Bandwidth Allocation overhead for this PATH (bytes/frame). In stations that don't support synchronous service, this attribute is read only and has the value of 0.")
cntFddiPATHStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPATHStatus.setDescription('The current status of the PATH.')
cntFddiPATHTRmode = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 3, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPATHTRmode.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPATHTRmode.setDescription('Used by RMT to limit the duration of restricted dialogs on a PATH.')
cntFddiPORTNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTNumber.setDescription('The total number of PORT implementations across all SMTs on this network management application entity.')
cntFddiPORTTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2), )
if mibBuilder.loadTexts: cntFddiPORTTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTTable.setDescription('A list of PORT entries. The number of entries is given by the value of snmpFddiPORTNumber.')
cntFddiPORTEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1), ).setIndexNames((0, "CNTAU-MIB", "cntFddiPORTSMTIndex"))
if mibBuilder.loadTexts: cntFddiPORTEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTEntry.setDescription('A PORT entry containing information common to a given PORT.')
cntFddiPORTSMTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTSMTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTSMTIndex.setDescription('The value of the SMT index associated with this PORT.')
cntFddiPORTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTIndex.setDescription('A unique value for each PORT within a given SMT. Its value ranges between 1 and the sum of the values of snmpFddiSMTNonMasterCt and snmpFddiSMTMasterCt on the given SMT.')
cntFddiPORTFotxClass = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTFotxClass.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPORTFotxClass.setDescription('The Fiber Optic Transmitter Class.')
cntFddiPORTMaintLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTMaintLineState.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPORTMaintLineState.setDescription('The current maintenance line status of this PORT.')
cntFddiPORTEBErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTEBErrs.setStatus('optional')
if mibBuilder.loadTexts: cntFddiPORTEBErrs.setDescription('The count of the times an Elasticity Buffer Error has occurred.')
cntFddiPORTBaseLerEstimate = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTBaseLerEstimate.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTBaseLerEstimate.setDescription('The value of FddiPORTLerEstimate at the sample time prior to when the sample time that the PORT LER Event was generated (the condition became active).')
cntFddiPORTBaseLemRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTBaseLemRejects.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTBaseLemRejects.setDescription('The value of FddiPORTLerRejectCt at the sample time prior to when the sample time that the PORT LER Event was generated (the condition became active).')
cntFddiPORTBaseLems = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTBaseLems.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTBaseLems.setDescription('The value of FddiPORTLerCt at the sample time prior to when the sample time that the PORT LER Event was generated (the condition became active).')
cntFddiPORTBaseLerTimeStamp = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 10, 2, 4, 2, 1, 9), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPORTBaseLerTimeStamp.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPORTBaseLerTimeStamp.setDescription('The value of FddiSMTMsgTimestamp at the sample time prior to when the sample time that the PORT LER Event was generated (the condition became active).')
cntsnmp = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 11))
cntsnmpconfig = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 11, 1))
cntMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMibVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cntMibVersion.setDescription('The version identifier of the mib file that the agent has loaded from BBRAM.')
cntMibObjectCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMibObjectCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntMibObjectCount.setDescription("Number of objects in the MIB description file, !MIB, in this CNT platform. This file contains objects from RFC 1213, RFC 1284, RFC 1285, and CNT's enterprise. Depending upon the configuration of this node, the node may or may not support all of these objects.")
cntConfigVersion = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntConfigVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cntConfigVersion.setDescription('Version number of this SNMP agent from the configuration record.')
cntProxyStatus = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("no-proxy", 1), ("proxy-agent", 2), ("proxied-node", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntProxyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntProxyStatus.setDescription('This flag indicates whether this SNMP agent is acting as a proxy, is being proxied, or is a normally behaving SNMP agent.')
cntProxyCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntProxyCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntProxyCount.setDescription('If this node is configured to operate as a proxy agent, this number reflects the number of proxied nodes that this node is configured to manage in !NDE.')
cntSnmpBufferCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSnmpBufferCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntSnmpBufferCount.setDescription('Number of buffers reserved for this SNMP agent for outgoing message from the configuration record.')
cntIfPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIfPollInterval.setStatus('mandatory')
if mibBuilder.loadTexts: cntIfPollInterval.setDescription("Number of seconds for the SNMP agent to wait between checks of the CNT platform's interfaces for operation status. These interface checks result in the link down and link up traps. This value is from the configuration record.")
cntIfNextPoll = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntIfNextPoll.setStatus('mandatory')
if mibBuilder.loadTexts: cntIfNextPoll.setDescription('Number of seconds for the next internal SNMP agent interface poll. These interface checks result in the link down and link up traps. This value is from the configuration record.')
cntDoDIPCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntDoDIPCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntDoDIPCount.setDescription('The number of DoD IP addresses (internet records in !CFG) configured in this node that the agent detected upon startup. This will not equal the number of interfaces on this node.')
cntDot3Count = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntDot3Count.setStatus('mandatory')
if mibBuilder.loadTexts: cntDot3Count.setDescription('The number of ethernet interfaces that are manageable by this agent on this node.')
cntFddiCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiCount.setDescription('The number of FDDI interfaces that are manageable by this agent on this node.')
cntFddiPortCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiPortCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiPortCount.setDescription('The number of FDDI ports that are manageable by this agent on this node.')
cntDataLinkCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntDataLinkCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntDataLinkCount.setDescription('The number of Data Link Layers Instances that are manageable by this agent on this node.')
cntLLC1Count = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntLLC1Count.setStatus('mandatory')
if mibBuilder.loadTexts: cntLLC1Count.setDescription('The number of Data Link Layers Instances of type Logical Link Control 1 (ISO 8802/2) that are manageable by this agent on this node.')
cntCofiVersion = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 1, 15), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCofiVersion.setStatus('mandatory')
if mibBuilder.loadTexts: cntCofiVersion.setDescription('The version of the the COmmon File Interface (COFI) module that is loaded into this node. COFI is required by the snmp agent for access to some CNT system objects. The version is in the format: version.day.month.year.')
cntsnmpstat = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 11, 2))
cntMib2Requests = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMib2Requests.setStatus('mandatory')
if mibBuilder.loadTexts: cntMib2Requests.setDescription('The number of requests received by the agent for mib-2 objects.')
cntFddiRequests = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntFddiRequests.setStatus('mandatory')
if mibBuilder.loadTexts: cntFddiRequests.setDescription('The number of requests received by the agent for FDDI objects in the experimental or transmission subtree.')
cntDot3Requests = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntDot3Requests.setStatus('mandatory')
if mibBuilder.loadTexts: cntDot3Requests.setDescription('The number of requests received by the agent for 802.3 objects in the experimental or transmission subtree.')
cntCntRequests = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCntRequests.setStatus('mandatory')
if mibBuilder.loadTexts: cntCntRequests.setDescription('The number of requests received by the agent for objects in the Computer Network Technology Corp. private enterprise subtree.')
cntRowAdditions = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntRowAdditions.setStatus('mandatory')
if mibBuilder.loadTexts: cntRowAdditions.setDescription('The number of table row additions that have been successful through SNMP requests from a network management station.')
cntRowModifies = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntRowModifies.setStatus('mandatory')
if mibBuilder.loadTexts: cntRowModifies.setDescription('The number of table row modifications that have been successful through SNMP requests from a network management station.')
cntRowDeletions = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntRowDeletions.setStatus('mandatory')
if mibBuilder.loadTexts: cntRowDeletions.setDescription('The number of table row deletions that have been successful through SNMP requests from a network management station.')
cntRowErrors = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntRowErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cntRowErrors.setDescription('The number of table row additions that were attempted through SNMP requests from a network management station, but were not complete in a single request. These requests were not successfully completed.')
cntBadVersions = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntBadVersions.setStatus('mandatory')
if mibBuilder.loadTexts: cntBadVersions.setDescription('The number of table row additions that were attempted through SNMP requests from a network management station, but were not complete in a single request. These requests were not successfully completed.')
cntNoBuffers = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntNoBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: cntNoBuffers.setDescription('The number of times the agent needed a buffer and did not have one. The agent uses buffers when making requests to the MEs.')
cntMailTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntMailTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: cntMailTimeouts.setDescription('The number of timeouts received from the MEs when a mib request was given.')
cntCachedResponses = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntCachedResponses.setStatus('mandatory')
if mibBuilder.loadTexts: cntCachedResponses.setDescription('The number of requests to the MEs that were cached. Each cached message contains as many mib objects as the request to the ME.')
cntUsedCaches = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntUsedCaches.setStatus('mandatory')
if mibBuilder.loadTexts: cntUsedCaches.setDescription('The number of objects for which the cached mib objects were used.')
cntsnmptrap = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 11, 3))
cntTrapDestCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntTrapDestCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntTrapDestCount.setDescription('The number of trap destinations that the agent will forward the configured traps to.')
cntLastTrapMsg = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntLastTrapMsg.setStatus('mandatory')
if mibBuilder.loadTexts: cntLastTrapMsg.setDescription('Textual description of the last trap message sent from this SNMP agent. The object identifier for cntSysLastTrapMsg is sent along with each trap.')
cntTrapTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 3), )
if mibBuilder.loadTexts: cntTrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntTrapTable.setDescription('A list of trap entries. There is a maximum of six trap entries. These values, except TrapIf, are set in the configuration record.')
cnttrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 3, 1), ).setIndexNames((0, "CNTAU-MIB", "cnttrapIndex"))
if mibBuilder.loadTexts: cnttrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cnttrapEntry.setDescription('A trap entry containing the information needed to send out a trap.')
cnttrapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnttrapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cnttrapIndex.setDescription('Trap table index.')
cnttrapAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 3, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnttrapAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cnttrapAddress.setDescription('Trap destination address.')
cntsnmpTrapFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsnmpTrapFlags.setStatus('mandatory')
if mibBuilder.loadTexts: cntsnmpTrapFlags.setDescription("Flag setting specifying which types of traps to send to this destination. This value is derived from 'or'ing the following values: cold start(0x01), link down(0x04), link up(0x08), and authentication failure(0x10).")
cntTrapFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 3, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntTrapFlags.setStatus('mandatory')
if mibBuilder.loadTexts: cntTrapFlags.setDescription('Flag settings reserved for future enterprise specific trap enabling.')
cnttrapIf = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 3, 3, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnttrapIf.setStatus('mandatory')
if mibBuilder.loadTexts: cnttrapIf.setDescription('Trap source address.')
cntsnmpproxy = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 11, 4))
cntProxyTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 11, 4, 1), )
if mibBuilder.loadTexts: cntProxyTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntProxyTable.setDescription('A list of proxy entries. This table contains an entry for each proxied node from this proxy agent. If this node is not configured as a proxy agent then this table is empty.')
cntproxyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 11, 4, 1, 1), ).setIndexNames((0, "CNTAU-MIB", "cntproxyIndex"))
if mibBuilder.loadTexts: cntproxyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntproxyEntry.setDescription('A proxy entry containing the information needed to carry an SNMP request to a proxied node.')
cntproxyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntproxyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntproxyIndex.setDescription('Proxy table index.')
cntproxyAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 4, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntproxyAddress.setStatus('mandatory')
if mibBuilder.loadTexts: cntproxyAddress.setDescription('Proxied node destination DoD IP address that is used by the NMS.')
cntproxyNode = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 11, 4, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntproxyNode.setStatus('mandatory')
if mibBuilder.loadTexts: cntproxyNode.setDescription('Proxied node destination CNT node address that is used by the local CNT router to access the destination.')
cntdiagnostics = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 12))
cntTraceTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 12, 1), )
if mibBuilder.loadTexts: cntTraceTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntTraceTable.setDescription('List of entries in the global trace area.')
cnttraceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 12, 1, 1), ).setIndexNames((0, "CNTAU-MIB", "cnttraceIndex"))
if mibBuilder.loadTexts: cnttraceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cnttraceEntry.setDescription('A trace entry.')
cnttraceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnttraceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cnttraceIndex.setDescription('The index which uniquely identifies the trace row instance in a CNT node.')
cnttraceType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnttraceType.setStatus('mandatory')
if mibBuilder.loadTexts: cnttraceType.setDescription('The type of trace entry.')
cnttraceCpu = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnttraceCpu.setStatus('mandatory')
if mibBuilder.loadTexts: cnttraceCpu.setDescription('The CPU number of the module that entered this trace entry.')
cnttraceData = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 1, 1, 4), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cnttraceData.setStatus('mandatory')
if mibBuilder.loadTexts: cnttraceData.setDescription('The remaining 14 octets of trace information.')
cntMailQueue = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 12, 2))
cntMDMTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 12, 2, 1), )
if mibBuilder.loadTexts: cntMDMTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntMDMTable.setDescription('A list of Message Distribution Manager (MDM) interprocessor queue global table entries.')
cntMDMEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 12, 2, 1, 1), ).setIndexNames((0, "CNTAU-MIB", "cntmdmQIndex"))
if mibBuilder.loadTexts: cntMDMEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntMDMEntry.setDescription('A Message Distribution Manager (MDM) queue global table entry.')
cntmdmQIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntmdmQIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntmdmQIndex.setDescription("The relative index of the MDM entry in the system's global table.")
cntmdmQName = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntmdmQName.setStatus('mandatory')
if mibBuilder.loadTexts: cntmdmQName.setDescription('The MDM queue name for this entry in the system global table.')
cntmdmQProcessId = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 2, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntmdmQProcessId.setStatus('mandatory')
if mibBuilder.loadTexts: cntmdmQProcessId.setDescription('The MDM processor number for this entry in the system global table.')
cntmdmQTaskId = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 12, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntmdmQTaskId.setStatus('mandatory')
if mibBuilder.loadTexts: cntmdmQTaskId.setDescription('The MDM task identifier for this entry in the system global table.')
cntmdmQList = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 12, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntmdmQList.setStatus('mandatory')
if mibBuilder.loadTexts: cntmdmQList.setDescription('The MDM queue name list in one long string.')
cntdatalink = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 13))
cntdlNumber = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 13, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlNumber.setDescription('The number of network data link layers present on this system.')
cntdlTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 13, 2), )
if mibBuilder.loadTexts: cntdlTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlTable.setDescription('A list of data link layer entries. The number of entries is given by the value of cntdlNumber.')
cntdlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1), ).setIndexNames((0, "CNTAU-MIB", "cntdlIndex"))
if mibBuilder.loadTexts: cntdlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlEntry.setDescription('A data link layer entry containing objects for a particular data link layer.')
cntdlIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlIndex.setDescription("A unique value for each data link layer. It's value ranges between one and the value of dlNumber. The value for each data link layer must remain constant at least from one reinitialization of the entity's network management system to the next reinitialization.")
cntdlDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlDescr.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlDescr.setDescription('A textual string containing information about the data link layer. This string should include the name of the manufacturer, the product name and the version of the data link layer.')
cntdlType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("llc1", 1), ("llc2", 2), ("llc3", 3), ("snap", 4), ("cnet", 5), ("dnls", 6), ("strp", 7), ("ppp", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlType.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlType.setDescription('The type of this data link layer.')
cntdlTypeofService = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unacked-connectionless", 1), ("connection-oriented", 2), ("acked-connectionless", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlTypeofService.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlTypeofService.setDescription('The type of this data link layer service.')
cntdlMtu = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlMtu.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlMtu.setDescription('The size of the largest datagram which can be sent/received on this data link layer, specified in octets.')
cntdlPortAddrLen = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlPortAddrLen.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlPortAddrLen.setDescription('The length of all port addresses used by this data link layer service.')
cntdlMaxPort = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlMaxPort.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlMaxPort.setDescription('The maximum number of ports supported by this data link layer service.')
cntdlActivePort = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlActivePort.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlActivePort.setDescription('The current number of active ports.')
cntdlInOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlInOctets.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlInOctets.setDescription('The total number of octets received on this data link layer.')
cntdlInUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlInUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlInUcastPkts.setDescription('The number of unicast packets delivered to a higher layer protocol.')
cntdlInNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlInNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlInNUcastPkts.setDescription('The number of non-unicast packets delivered to a higher layer protocol.')
cntdlInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlInDiscards.setDescription('The number of inbound packets which were chosen to be discarded even though no errors had been detected to prevent their being deliverable to a higher layer protocol.')
cntdlInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlInErrors.setDescription('The number of inbound packets that contained errors preventing them from being deliverable to a higher-layer protocol.')
cntdlInUnknownProtos = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlInUnknownProtos.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlInUnknownProtos.setDescription('The number of packets received via the data link layer which were discareded because of an unknown or unsupported protocol.')
cntdlOutOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlOutOctets.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlOutOctets.setDescription('The total number of octets transmitted by this this data link layer service.')
cntdlOutUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlOutUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlOutUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a unicast address, including those that were discarded or not sent.')
cntdlOutNUcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlOutNUcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlOutNUcastPkts.setDescription('The total number of packets that higher-level protocols requested be transmitted to a non-unicast address, including those that were discarded or not sent.')
cntdlOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlOutDiscards.setDescription('The number of outbound packets which were chose to be discarded even though no errors had been detected to prevent their being transmitted.')
cntdlOutErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlOutErrors.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlOutErrors.setDescription('The number of outbound packets that could not be transmitted because of errors.')
cntdlOutQLen = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 20), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlOutQLen.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlOutQLen.setDescription('The length of the output packet queue, in packets.')
cntdlPortTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 21), )
if mibBuilder.loadTexts: cntdlPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlPortTable.setDescription('A list of data link layer entries. The number of entries is given by the value of dlActivePorts.')
cntdlPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 21, 1), ).setIndexNames((0, "CNTAU-MIB", "cntdlPortIndex"))
if mibBuilder.loadTexts: cntdlPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlPortEntry.setDescription('A data link layer entry containing objects for a particular port.')
cntdlPortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 21, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlPortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlPortIndex.setDescription("The port entry's index.")
cntdlState = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 21, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("connected", 1), ("data-transfer", 2), ("disconnected", 3), ("waiting-for-ack", 4), ("down", 5), ("closed", 6), ("listen", 7), ("ack-sent", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlState.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlState.setDescription('The state of this port.')
cntdlSourcePort = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 21, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlSourcePort.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlSourcePort.setDescription('The source port number.')
cntdlDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 21, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlDestPort.setDescription('The destination port number.')
cntdlPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 2, 1, 21, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dod-ip", 1), ("arp", 2), ("snmp", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntdlPortType.setStatus('mandatory')
if mibBuilder.loadTexts: cntdlPortType.setDescription('The port type. This value is not redundant to dlType since a link layer service may support multiple port types. For example, LLC1 has both llc1 and snap ports.')
cntllc1 = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 13, 3))
cntllc1ConfigTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1), )
if mibBuilder.loadTexts: cntllc1ConfigTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1ConfigTable.setDescription('A list of the LLC1 configuration entries.')
cntllc1ConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1), ).setIndexNames((0, "CNTAU-MIB", "cntllc1ConfigIndex"))
if mibBuilder.loadTexts: cntllc1ConfigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1ConfigEntry.setDescription('A LLC1 configuration entry.')
cntllc1ConfigIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1ConfigIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1ConfigIndex.setDescription('The index that uniquely identifies an instance of a LLC1 process in a CNT node.')
cntllc1DriverType = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("cnt-node", 1), ("fddi", 2), ("fibre-trunk", 3), ("native", 4), ("ethernet", 5), ("hippi", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1DriverType.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1DriverType.setDescription('The physical layer device driver type that has identified to this llc1 service.')
cntllc1Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1Addr.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1Addr.setDescription('The MAC address for the physical layer over which this link layer is operating.')
cntllc1InitFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("uninitialized", 1), ("initialized", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InitFlag.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InitFlag.setDescription('The initialization flag indicating whether or not this module has finished initializing the data link layer stack.')
cntllc1TraceFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1TraceFlag.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1TraceFlag.setDescription('The trace flags in bit-oriented form. The values are as follows: .... ...1 - phase 2 entry point .... ..1. - phase 3 entry point .... .1.. - messages in .... 1... - transmit completions ...1 .... - messages received ..1. .... - message to a ULP.')
cntllc1BufCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1BufCnt.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1BufCnt.setDescription('The number of free buffers in the free pool.')
cntllc1BusId = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1BusId.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1BusId.setDescription('The bus number for this network interface.')
cntllc1CpuNum = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("lcp-1", 1), ("lcp-2", 2), ("lcp-3", 3), ("lcp-4", 4), ("lcp-5", 5), ("lcp-6", 6), ("lcp-7", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1CpuNum.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1CpuNum.setDescription('The CPU number where this data link layer is running, 1 through 8.')
cntllc1BufPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1BufPriority.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1BufPriority.setDescription('The assigned buffer priority for messages received from the physical layer.')
cntllc1WaitTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 1, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1WaitTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1WaitTimeOut.setDescription('The wait timeout in seconds for XID/TEST frames sent to a peer llc1 data link layer.')
cntllc1StatsTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2), )
if mibBuilder.loadTexts: cntllc1StatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1StatsTable.setDescription('A list of LLC1 statistics entries.')
cntllc1StatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1), ).setIndexNames((0, "CNTAU-MIB", "cntllc1StatIndex"))
if mibBuilder.loadTexts: cntllc1StatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1StatsEntry.setDescription('A LLC1 statistics entry.')
cntllc1StatIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1StatIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1StatIndex.setDescription('The index that uniquely identifies an instance of a LLC1 process in a CNT node.')
cntllc1InXids = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InXids.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InXids.setDescription('The number of LLC XID frames received from a peer data link layer.')
cntllc1InTests = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InTests.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InTests.setDescription('The number of LLC TEST frames received from a peer data link layer.')
cntllc1InUIs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InUIs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InUIs.setDescription('The number of LLC UI frames received from a peer data link layer.')
cntllc1InNoDsaps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InNoDsaps.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InNoDsaps.setDescription('The number of unknown DSAPs received from a peer data link layer.')
cntllc1InXidOks = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InXidOks.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InXidOks.setDescription('The number of successful LLC XID frames from a peer data link layer.')
cntllc1InTestOks = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InTestOks.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InTestOks.setDescription('The number of successful LLC TEST frames from a peer data link layer.')
cntllc1InSnapIps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InSnapIps.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InSnapIps.setDescription('The number of SNAP IP packets received from a peer SNAP.')
cntllc1InSnapArps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InSnapArps.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InSnapArps.setDescription('The number of SNAP ARP packets received from a peer SNAP.')
cntllc1InSnapNoProts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InSnapNoProts.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InSnapNoProts.setDescription('The number of unknown SNAP protocols received from a peer SNAP.')
cntllc1InSnapNoTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InSnapNoTypes.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InSnapNoTypes.setDescription('The number of unknown SNAP ethertypes received from a peer SNAP.')
cntllc1OutSnapIps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutSnapIps.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutSnapIps.setDescription('The number of SNAP IP packets sent to a peer SNAP.')
cntllc1OutSnapArps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutSnapArps.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutSnapArps.setDescription('The number of SNAP ARP packets sent to a peer SNAP.')
cntllc1OutXids = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutXids.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutXids.setDescription('The number of LLC XID requests sent to a peer data link layer.')
cntllc1OutXidResps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutXidResps.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutXidResps.setDescription('The number of LLC XID responses received from a peer data link layer.')
cntllc1OutTests = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutTests.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutTests.setDescription('The number of LLC TEST requests sent to a peer data link layer.')
cntllc1OutTestResps = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutTestResps.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutTestResps.setDescription('The number of LLC TEST responses sent to a peer data link layer.')
cntllc1OutRetOks = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutRetOks.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutRetOks.setDescription('The number of packets passed successfully to the physical layer.')
cntllc1OutFragPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutFragPkts.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutFragPkts.setDescription('The number of packet sent with fragments.')
cntllc1ErrorTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3), )
if mibBuilder.loadTexts: cntllc1ErrorTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1ErrorTable.setDescription('A list of LLC1 error entries.')
cntllc1ErrorEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1), ).setIndexNames((0, "CNTAU-MIB", "cntllc1ErrorIndex"))
if mibBuilder.loadTexts: cntllc1ErrorEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1ErrorEntry.setDescription('A LLC1 error entry.')
cntllc1ErrorIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1ErrorIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1ErrorIndex.setDescription('The index that uniquely identifies an instance of a LLC1 process in a CNT node.')
cntllc1ArpMailErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1ArpMailErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1ArpMailErrs.setDescription('The number of errors encountered when mailing to ARP.')
cntllc1IpMailErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1IpMailErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1IpMailErrs.setDescription('The number of errors encountered when mailing to IP.')
cntllc1OutXmitErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutXmitErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutXmitErrs.setDescription('The number of times and error was received from the physical layer when a transmission was attempted by this data link layer.')
cntllc1OutMcastErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutMcastErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutMcastErrs.setDescription('The number of times and error was received from the physical layer when a multicast message was attempted by this data link layer.')
cntllc1XidErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1XidErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1XidErrs.setDescription('The number of times and error was received from the physical layer when an LLC XID message was attempted by this data link layer.')
cntllc1TestErrs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1TestErrs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1TestErrs.setDescription('The number of times and error was received from the physical layer when an LLC TEST message was attempted by this data link layer.')
cntllc1InBadTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InBadTypes.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InBadTypes.setDescription('The number of messages received from a peer data link layer with invalid or unsupported LLC type fields.')
cntllc1OutMismIpSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutMismIpSizes.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutMismIpSizes.setDescription('The number of messages received from a ULP that has an included IP header that indicates the message size is smaller than the actual size of the message.')
cntllc1OutBadIpSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutBadIpSizes.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutBadIpSizes.setDescription('The number of messages received from a ULP that has an included IP header that indicates the message size is larger than the actual size of the message.')
cntllc1InMismIpSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InMismIpSizes.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InMismIpSizes.setDescription('The number of messages received from a physical layer that has an included IP header that indicates the message size is smaller than the actual size of the message.')
cntllc1InBadIpSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InBadIpSizes.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InBadIpSizes.setDescription('The number of messages received from a physical layer that has an included IP header that indicates the message size is larger than the actual size of the message.')
cntllc1InLateXids = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InLateXids.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InLateXids.setDescription('The number of times an LLC XID request was sent to a peer data link layer and the return reponse was late or invalid.')
cntllc1InLateTests = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1InLateTests.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1InLateTests.setDescription('The number of times an LLC TEST request was sent to a peer data link layer and the return reponse was late or invalid.')
cntllc1OutTooBigs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutTooBigs.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutTooBigs.setDescription('The number of times this link layer service could not build the outgoing message due to a Maximum Transmission Unit (MTU) limitation.')
cntllc1OutNoRooms = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutNoRooms.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutNoRooms.setDescription('The number of times this data link layer service could not build the outgoing message due to lack of space in the s_message area of the buffer.')
cntllc1OutRetBads = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 13, 3, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntllc1OutRetBads.setStatus('mandatory')
if mibBuilder.loadTexts: cntllc1OutRetBads.setDescription('The number of times the physical layer returned an error upon return of the message to this data link layer service.')
cntlua = MibIdentifier((1, 3, 6, 1, 4, 1, 333, 1, 14))
cntLuaCount = MibScalar((1, 3, 6, 1, 4, 1, 333, 1, 14, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntLuaCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntLuaCount.setDescription('The number of Logical Unit Adaptors (LUAs) present on this system.')
cntLuaTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 14, 2), )
if mibBuilder.loadTexts: cntLuaTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntLuaTable.setDescription('A list of entries describing an individual Logical Unit Adaptor (LUA). A specific lua object is terminated with the channel number.')
cntluaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1), ).setIndexNames((0, "CNTAU-MIB", "cntluaIf"))
if mibBuilder.loadTexts: cntluaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntluaEntry.setDescription('An individual LUA entry.')
cntluaIf = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntluaIf.setStatus('mandatory')
if mibBuilder.loadTexts: cntluaIf.setDescription('The corresponding SNMP interface index for this LUA.')
cntluaNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntluaNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntluaNumber.setDescription('The LUA number (0-255).')
cntSubChanCount = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntSubChanCount.setStatus('mandatory')
if mibBuilder.loadTexts: cntSubChanCount.setDescription('The number of subchannels on the LUA (0-255).')
cntSubChanTable = MibTable((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4), )
if mibBuilder.loadTexts: cntSubChanTable.setStatus('mandatory')
if mibBuilder.loadTexts: cntSubChanTable.setDescription('A list of entries describing an individual subchannel. A specific subchannel object is referenced from the LUA table with instance object identifiers .lua.subchannel.')
cntsubchanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1), ).setIndexNames((0, "CNTAU-MIB", "cntsctIndex"))
if mibBuilder.loadTexts: cntsubchanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: cntsubchanEntry.setDescription('An individual subchannel entry.')
cntsctIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctIndex.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctIndex.setDescription('The relative subchannel index for this lua.')
cntsctNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctNumber.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctNumber.setDescription('The sub-channel number (0-255).')
cntsctTxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctTxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctTxStatus.setDescription('Bit value for the transmit status. Bit Definition 0 Transmit to be cancelled 4 Transmit in operation 8 Buffer available to subchannel 9 Subchannel ready to accept POST_XMITs')
cntsctRxStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctRxStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctRxStatus.setDescription('Bit value for the receive status. Bit Definition 0 Receive operation begun from host 1 Receive enabled/disabled 2 Cancel current receive message sequence 3 Pending associated data sequence 4 Request transport error notification')
cntsctSubChanStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctSubChanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctSubChanStatus.setDescription('Bit value for the device subchannel status. Bit Definition 0 Subchannel is allocated 1 Subchannel is established 2 Subchannel is sharable 3 Subchannel has dedicated buffers 4 Subchannel has pending completion 5 Subchannel has xmit multiple from user 6 Subchannel has receive multiple from user 7 Subchannel has buffer not available condition 8 Subchannel reason for no buffer (0=no credit; 1=no buffers) 9 Subchannel has network level doing flow control 10 Subchannel has pending connect 11 Subchannel has transmitted disconnect 12 Subchannel ignores buffer not available condition 13 Subchannel support Bus0 if not set, Bus1 if set 14 Subchannel has possible error during data transfer 15 Subchannel is allocated')
cntsctState = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctState.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctState.setDescription('Bit value for the subchannel state. Bit Definition 0 Wait flag 1 Subchannel busy 2 Pending command retry 3 Pending completion status 4 Pending unsolicited status 6 Status stacked 7 Damage control active flag')
cntsctRxCredit = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctRxCredit.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctRxCredit.setDescription('Current receive buffer credit.')
cntsctRxMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctRxMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctRxMsgs.setDescription('Receive message count.')
cntsctRxMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctRxMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctRxMsgBytes.setDescription('Receive message byte count.')
cntsctRxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctRxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctRxDataBytes.setDescription('Receive data byte count.')
cntsctTxMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctTxMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctTxMsgs.setDescription('Transmit message count.')
cntsctTxMsgBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctTxMsgBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctTxMsgBytes.setDescription('Transmit message byte count.')
cntsctTxDataBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctTxDataBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctTxDataBytes.setDescription('Transmit data byte count.')
cntsctTxErrMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctTxErrMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctTxErrMsgs.setDescription('Transmit error message count.')
cntsctTotalBytes = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctTotalBytes.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctTotalBytes.setDescription('Total number of bytes transmitted and received for this subchannel.')
cntsctDrecPid = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 16), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctDrecPid.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctDrecPid.setDescription('Channel PID name.')
cntsctDrecTask = MibTableColumn((1, 3, 6, 1, 4, 1, 333, 1, 14, 2, 1, 4, 1, 17), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cntsctDrecTask.setStatus('mandatory')
if mibBuilder.loadTexts: cntsctDrecTask.setDescription('Device specific driver task name.')
cntInformationalMsg = NotificationType((1, 3, 6, 1, 4, 1, 333, 1) + (0,1)).setObjects(("CNTAU-MIB", "cntMsgTaskName"), ("CNTAU-MIB", "cntMsgNumber"), ("CNTAU-MIB", "cntMsgCpuNumber"), ("CNTAU-MIB", "cntMsgNodeNumber"), ("CNTAU-MIB", "cntMsgDateTime"), ("CNTAU-MIB", "cntMsgContent"))
if mibBuilder.loadTexts: cntInformationalMsg.setDescription('A cnt level one trap signifies that an event has occured that is informational in severity. The network will not be affected by this error.')
cntPossibleErrMsg = NotificationType((1, 3, 6, 1, 4, 1, 333, 1) + (0,2)).setObjects(("CNTAU-MIB", "cntMsgTaskName"), ("CNTAU-MIB", "cntMsgNumber"), ("CNTAU-MIB", "cntMsgCpuNumber"), ("CNTAU-MIB", "cntMsgNodeNumber"), ("CNTAU-MIB", "cntMsgDateTime"), ("CNTAU-MIB", "cntMsgContent"))
if mibBuilder.loadTexts: cntPossibleErrMsg.setDescription('A cnt level two trap signifies that an event has occured that is possibly severe in nature. The scope of this failure is dependent on the network design.')
cntSevereErrMsg = NotificationType((1, 3, 6, 1, 4, 1, 333, 1) + (0,3)).setObjects(("CNTAU-MIB", "cntMsgTaskName"), ("CNTAU-MIB", "cntMsgNumber"), ("CNTAU-MIB", "cntMsgCpuNumber"), ("CNTAU-MIB", "cntMsgNodeNumber"), ("CNTAU-MIB", "cntMsgDateTime"), ("CNTAU-MIB", "cntMsgContent"))
if mibBuilder.loadTexts: cntSevereErrMsg.setDescription('A cnt level three trap signifies that an event has occured that is unrecoverable. Some aspect of the CNT network will not function as expected. Related aspects may also be affected.')
cntCriticalErrMsg = NotificationType((1, 3, 6, 1, 4, 1, 333, 1) + (0,4)).setObjects(("CNTAU-MIB", "cntMsgTaskName"), ("CNTAU-MIB", "cntMsgNumber"), ("CNTAU-MIB", "cntMsgCpuNumber"), ("CNTAU-MIB", "cntMsgNodeNumber"), ("CNTAU-MIB", "cntMsgDateTime"), ("CNTAU-MIB", "cntMsgContent"))
if mibBuilder.loadTexts: cntCriticalErrMsg.setDescription('A cnt level four trap signifies that an event has occured that is critical and possibly fatal. Some aspect of the cnt network will not function or is seriously impaired. This failure will likely affect related functions as well.')
mibBuilder.exportSymbols("CNTAU-MIB", cntdot3PICMemSeqErrs=cntdot3PICMemSeqErrs, cntdiagnostics=cntdiagnostics, cntSerialAlfaNumber=cntSerialAlfaNumber, cntLastTrapMsg=cntLastTrapMsg, cntDot3Requests=cntDot3Requests, cntifEntry=cntifEntry, cntllc1OutBadIpSizes=cntllc1OutBadIpSizes, cntHwBBramStatus=cntHwBBramStatus, cntSlotCpuNumber=cntSlotCpuNumber, cntIOIndex=cntIOIndex, cntdlSourcePort=cntdlSourcePort, cntMDMTable=cntMDMTable, cnticmpOutDuProtos=cnticmpOutDuProtos, cntHwFailStatus=cntHwFailStatus, cntFddiPORTSMTIndex=cntFddiPORTSMTIndex, cntmdmQTaskId=cntmdmQTaskId, cntMsgDateTime=cntMsgDateTime, cntsctRxStatus=cntsctRxStatus, cnticmpOutTmFrags=cnticmpOutTmFrags, cnticmpOutReNets=cnticmpOutReNets, cntFddiMACNotCopiedCondition=cntFddiMACNotCopiedCondition, cntllc1StatsEntry=cntllc1StatsEntry, cntllc1BufCnt=cntllc1BufCnt, cntsctTotalBytes=cntsctTotalBytes, cnticmpInDuHosts=cnticmpInDuHosts, cntFddiMACLLCServiceAvailable=cntFddiMACLLCServiceAvailable, cntsctIndex=cntsctIndex, cntModelNumber=cntModelNumber, cntdot3PICSpuriousInts=cntdot3PICSpuriousInts, cntllc1IpMailErrs=cntllc1IpMailErrs, cntFddiSMTReportLimit=cntFddiSMTReportLimit, cntllc1InNoDsaps=cntllc1InNoDsaps, cntllc1OutXmitErrs=cntllc1OutXmitErrs, cntCpuTaskEntry=cntCpuTaskEntry, cntFddiMACTPri5=cntFddiMACTPri5, cntdlActivePort=cntdlActivePort, cntFeatureDescr=cntFeatureDescr, cntSlotInterface=cntSlotInterface, cntFddiRequests=cntFddiRequests, cntMemSramFree=cntMemSramFree, cntllc1OutXids=cntllc1OutXids, cntdlPortTable=cntdlPortTable, cntFddiPATHEntry=cntFddiPATHEntry, cntBadVersions=cntBadVersions, cntIOEntry=cntIOEntry, cntFddiPATHTMaxLowerBound=cntFddiPATHTMaxLowerBound, cntFddiSMTEntry=cntFddiSMTEntry, cntdot3PICDMAErrs=cntdot3PICDMAErrs, cntFddiPortCount=cntFddiPortCount, cntMib2Requests=cntMib2Requests, cntFddiPATHPORTOrder=cntFddiPATHPORTOrder, cntHwCpuTable=cntHwCpuTable, cntSerialNumber=cntSerialNumber, cntFddiMAC=cntFddiMAC, cntMemSramSpace=cntMemSramSpace, cntIfsState=cntIfsState, cntPowerName=cntPowerName, cntFddiMACRootMACDownStreamPORTType=cntFddiMACRootMACDownStreamPORTType, cntFddiMACTPri4=cntFddiMACTPri4, cntsctTxMsgBytes=cntsctTxMsgBytes, cntPowerSerialNumber=cntPowerSerialNumber, cntFddiSMTMsgTimeStamp=cntFddiSMTMsgTimeStamp, cntllc1TestErrs=cntllc1TestErrs, cntCpuPort=cntCpuPort, cntFddiCount=cntFddiCount, cntSlotVMEbusGrant=cntSlotVMEbusGrant, cntIOPartNumber=cntIOPartNumber, cntFddiMACRootConcentratorMac=cntFddiMACRootConcentratorMac, cntsctState=cntsctState, cntFddiMACBaseTimeFrameError=cntFddiMACBaseTimeFrameError, cnttraceType=cnttraceType, cntFddiMACRootMACCurrentPath=cntFddiMACRootMACCurrentPath, cnticmpOutReHosts=cnticmpOutReHosts, cntFddiPORTBaseLemRejects=cntFddiPORTBaseLemRejects, cntFddiPATHType=cntFddiPATHType, cntllc1OutMcastErrs=cntllc1OutMcastErrs, cntRevEditDate=cntRevEditDate, cntdot3DMAChan3RxErr=cntdot3DMAChan3RxErr, cntTraceTable=cntTraceTable, cntFeatureQuantity=cntFeatureQuantity, cntFddiPATHTable=cntFddiPATHTable, cntproxyIndex=cntproxyIndex, cntdot3LanceMemErrs=cntdot3LanceMemErrs, cntCpuPollStatus=cntCpuPollStatus, cntllc1InTestOks=cntllc1InTestOks, cntCpuResetDelayTime=cntCpuResetDelayTime, cntCpuTaskTable=cntCpuTaskTable, cntFddiMACOldDownstreamNbr=cntFddiMACOldDownstreamNbr, cntFddiMACBaseCopies=cntFddiMACBaseCopies, cntFeatureEntry=cntFeatureEntry, cntdlMaxPort=cntdlMaxPort, cntCpuPolls=cntCpuPolls, cntReleaseLevel=cntReleaseLevel, cntHwMonCpu=cntHwMonCpu, cntmdmQProcessId=cntmdmQProcessId, cntFddiPATHStatus=cntFddiPATHStatus, cntConfigVersion=cntConfigVersion, cntPowerPartNumber=cntPowerPartNumber, cnticmpInReServhosts=cnticmpInReServhosts, cntSubChanTable=cntSubChanTable, cntCpuUnclaims=cntCpuUnclaims, cntllc1InBadIpSizes=cntllc1InBadIpSizes, cntSysTimeofDay=cntSysTimeofDay, cntifCpu=cntifCpu, cntdlInDiscards=cntdlInDiscards, cntMsgSeqNumber=cntMsgSeqNumber, cntCpuTaskIndex=cntCpuTaskIndex, cntHwFailDate=cntHwFailDate, cntllc1StatsTable=cntllc1StatsTable, cntllc1InLateXids=cntllc1InLateXids, cntllc1InXids=cntllc1InXids, cntllc1ErrorTable=cntllc1ErrorTable, cnt=cnt, cnticmpOutDuFrags=cnticmpOutDuFrags, cntFddiPORT=cntFddiPORT, cntdot3SoftwareID=cntdot3SoftwareID, cntllc1ErrorEntry=cntllc1ErrorEntry, cntFddiMACTPri6=cntFddiMACTPri6, cntau=cntau, cntCpuLevel7s=cntCpuLevel7s, cntFddiMACShortAlias=cntFddiMACShortAlias, cntTrapFlags=cntTrapFlags, cntWorkOrderNumber=cntWorkOrderNumber, cnticmpOutDuPorts=cnticmpOutDuPorts, cntProxyTable=cntProxyTable, cntPowerRevLevel=cntPowerRevLevel, cntllc1BufPriority=cntllc1BufPriority, cntCpuLastFailDate=cntCpuLastFailDate, cntdot3Entry=cntdot3Entry, cntllc1InSnapNoTypes=cntllc1InSnapNoTypes, cntsubchanEntry=cntsubchanEntry, cntsctTxMsgs=cntsctTxMsgs, cntCpuSemCount=cntCpuSemCount, cntCntRequests=cntCntRequests, cntifIndex=cntifIndex, cntCpuMonStatus=cntCpuMonStatus, cntdot3DMAChan2TxErr=cntdot3DMAChan2TxErr, cnttransmission=cnttransmission, cntSlotSerialNumber=cntSlotSerialNumber, cntFddiPORTIndex=cntFddiPORTIndex, cnticmpInTmXceeds=cnticmpInTmXceeds, cntlua=cntlua, cntFddiSMTIndex=cntFddiSMTIndex, cntllc1OutSnapArps=cntllc1OutSnapArps, cntTrapTable=cntTrapTable, cnttrapAddress=cnttrapAddress, cntproxyEntry=cntproxyEntry, cntFddiPATHTraceMaxExpiration=cntFddiPATHTraceMaxExpiration, cntSysBuild=cntSysBuild, cntllc1OutMismIpSizes=cntllc1OutMismIpSizes, cnticmpInDuSources=cnticmpInDuSources, cntLLC1Count=cntLLC1Count, cntMachineType=cntMachineType, cntdlIndex=cntdlIndex, cnticmpInDuPorts=cnticmpInDuPorts, cntRowModifies=cntRowModifies, cntdot3DMATxWaitQ=cntdot3DMATxWaitQ, cntllc1ConfigEntry=cntllc1ConfigEntry, cntsnmpconfig=cntsnmpconfig, cntSCRNumber=cntSCRNumber, cntsnmpstat=cntsnmpstat, cntllc1ConfigIndex=cntllc1ConfigIndex, cntsctDrecPid=cntsctDrecPid, cntdot3BufsAllocated=cntdot3BufsAllocated, cntdot3Index=cntdot3Index, cntsctRxMsgBytes=cntsctRxMsgBytes, cntFddiSMTLastSetStationID=cntFddiSMTLastSetStationID, cntFddiSMTNumber=cntFddiSMTNumber, cntHwPowerSupply=cntHwPowerSupply, cntdot3LanceMissedPkts=cntdot3LanceMissedPkts, cntPowerIndex=cntPowerIndex, cntFddiSMT=cntFddiSMT, cnticmp=cnticmp, cntIfPollInterval=cntIfPollInterval, cntmdmQList=cntmdmQList, cntllc1=cntllc1, cntllc1WaitTimeOut=cntllc1WaitTimeOut, cntMsgEntry=cntMsgEntry, cnticmpInDuProtos=cnticmpInDuProtos, cntMibVersion=cntMibVersion, cntllc1Addr=cntllc1Addr, cntFddiMACTokens=cntFddiMACTokens, cntdlPortIndex=cntdlPortIndex, cntFddiMACBaseNotCopies=cntFddiMACBaseNotCopies, cntCpuIndex=cntCpuIndex, cnticmpOutTmXceeds=cnticmpOutTmXceeds, cntCpuStatus=cntCpuStatus, cntFddiPORTBaseLems=cntFddiPORTBaseLems, cntllc1BusId=cntllc1BusId, cntMailTimeouts=cntMailTimeouts, cntdot3PICMemParityErrs=cntdot3PICMemParityErrs, cntCofiVersion=cntCofiVersion, cntCpuXtraInts=cntCpuXtraInts, cntRevEditTime=cntRevEditTime, cntsctRxMsgs=cntsctRxMsgs, cntHwFailedCpu=cntHwFailedCpu, cntFddiPATHSMTIndex=cntFddiPATHSMTIndex, cntsctNumber=cntsctNumber, cntSysMsgTable=cntSysMsgTable, cntllc1InLateTests=cntllc1InLateTests, cntSubChanCount=cntSubChanCount, cntPowerEntry=cntPowerEntry, cntllc1InUIs=cntllc1InUIs, cntTrapDestCount=cntTrapDestCount, cntCpuMsgHolds=cntCpuMsgHolds, cntSCREntry=cntSCREntry, cntdlOutDiscards=cntdlOutDiscards, cntsctDrecTask=cntsctDrecTask, cntFddiPATHTVXLowerBound=cntFddiPATHTVXLowerBound, cntSysCpuEntry=cntSysCpuEntry, cntFddiMACBridgeFunction=cntFddiMACBridgeFunction, cntIfNextPoll=cntIfNextPoll, cntMsgNumber=cntMsgNumber, cntdot3PICBusErrs=cntdot3PICBusErrs, cntFddiPATHTraceStatus=cntFddiPATHTraceStatus, cntFddiMACLongAlias=cntFddiMACLongAlias, cntdot3LanceInts=cntdot3LanceInts, cntCpuType=cntCpuType, cntIOInterface=cntIOInterface, cntNoBuffers=cntNoBuffers, cntProxyCount=cntProxyCount, cntCpuTaskName=cntCpuTaskName, cntFddiMACMasterSlaveLoopStatus=cntFddiMACMasterSlaveLoopStatus, cntFddiMACNumber=cntFddiMACNumber, cntsnmpproxy=cntsnmpproxy, cntHwBBramType=cntHwBBramType, cnttrapIf=cnttrapIf, cntPowerTable=cntPowerTable, cntMemBBramFree=cntMemBBramFree, cntFddiMACTPri2=cntFddiMACTPri2, cntdot3Chan1Misreads=cntdot3Chan1Misreads, cntdot3DMAChan0TxErrs=cntdot3DMAChan0TxErrs, cntFddiMACTvxExpires=cntFddiMACTvxExpires, cntllc1CpuNum=cntllc1CpuNum, cntdlEntry=cntdlEntry, cntCriticalErrMsg=cntCriticalErrMsg, cntdot3DMAChan0TxErr=cntdot3DMAChan0TxErr, cntsystem=cntsystem, cnticmpInTmFrags=cnticmpInTmFrags, cntdot3Table=cntdot3Table, cntIOSerialNumber=cntIOSerialNumber, cntFddiPATHRingLatency=cntFddiPATHRingLatency, cntFddiMACIndex=cntFddiMACIndex, cntFddiSMTManufacturerData=cntFddiSMTManufacturerData, cntFddiPATHSba=cntFddiPATHSba, cntHwReset2Why=cntHwReset2Why, cntRevDate=cntRevDate, cntluaEntry=cntluaEntry, cntCustomer=cntCustomer, cntsctTxErrMsgs=cntsctTxErrMsgs, cntFddiPORTBaseLerEstimate=cntFddiPORTBaseLerEstimate, cntCpuSemLost=cntCpuSemLost, cntsctTxStatus=cntsctTxStatus, cntllc1OutNoRooms=cntllc1OutNoRooms)
mibBuilder.exportSymbols("CNTAU-MIB", cntCpuResetFlag=cntCpuResetFlag, cntMemBBramSpace=cntMemBBramSpace, cnttraceData=cnttraceData, cntllc1OutTests=cntllc1OutTests, cntFddiMACShortGrpAddr=cntFddiMACShortGrpAddr, cntLuaCount=cntLuaCount, cntllc1InSnapArps=cntllc1InSnapArps, cnttraceCpu=cnttraceCpu, cntproxyAddress=cntproxyAddress, cntdlType=cntdlType, cntdot3LanceUnderFlows=cntdot3LanceUnderFlows, cntdot3BufTooManys=cntdot3BufTooManys, cntHwReset3Why=cntHwReset3Why, cntFddiPATH=cntFddiPATH, cntllc1OutXidResps=cntllc1OutXidResps, cntdot3LPXParityErrs=cntdot3LPXParityErrs, cntMailQueue=cntMailQueue, cntdlOutQLen=cntdlOutQLen, cntFddiPORTTable=cntFddiPORTTable, cntFddiPORTBaseLerTimeStamp=cntFddiPORTBaseLerTimeStamp, cntSlotPartNumber=cntSlotPartNumber, cntMsgCpuNumber=cntMsgCpuNumber, cntLuaTable=cntLuaTable, cntdot3BufNotAvails=cntdot3BufNotAvails, cntFddiMACSMTIndex=cntFddiMACSMTIndex, cntHwMonFailStatus=cntHwMonFailStatus, cntSysMemory=cntSysMemory, cntFddiSMTSetCount=cntFddiSMTSetCount, cntDoDIPCount=cntDoDIPCount, cntDataLinkCount=cntDataLinkCount, cntdlOutOctets=cntdlOutOctets, cntllc1InSnapNoProts=cntllc1InSnapNoProts, cntCpuMemFree=cntCpuMemFree, cntdlTypeofService=cntdlTypeofService, cntMemBBramAddress=cntMemBBramAddress, cntMsgIndex=cntMsgIndex, cnticmpOutReServhosts=cnticmpOutReServhosts, cntRowDeletions=cntRowDeletions, cntMsgNodeNumber=cntMsgNodeNumber, cntSlotRevLevel=cntSlotRevLevel, cntFddiMACTable=cntFddiMACTable, cntmdmQIndex=cntmdmQIndex, cntsctRxCredit=cntsctRxCredit, cntCpuMemSpace=cntCpuMemSpace, cntdatalink=cntdatalink, cnticmpInDuFrags=cnticmpInDuFrags, cntIOName=cntIOName, cntInformationalMsg=cntInformationalMsg, cntsctRxDataBytes=cntsctRxDataBytes, cntSysHardware=cntSysHardware, cntmdmQName=cntmdmQName, cntCpuLastChgDate=cntCpuLastChgDate, cnttraceEntry=cnttraceEntry, cntdot3LanceOverFlows=cntdot3LanceOverFlows, cntllc1OutRetOks=cntllc1OutRetOks, cnticmpOutDuSources=cnticmpOutDuSources, cntIOTable=cntIOTable, cntMsgContent=cntMsgContent, cntllc1OutSnapIps=cntllc1OutSnapIps, cntFddiMACNotCopiedThreshold=cntFddiMACNotCopiedThreshold, cntCpuUtil=cntCpuUtil, cntdot3DMAChan3RxErrs=cntdot3DMAChan3RxErrs, cntHwReset3Date=cntHwReset3Date, cntdot3LanceTxWaitQ=cntdot3LanceTxWaitQ, cntFddiSMTTransitionTimeStamp=cntFddiSMTTransitionTimeStamp, cntdot3DMAChan2TxErrs=cntdot3DMAChan2TxErrs, cntsctTxDataBytes=cntsctTxDataBytes, cntinterfaces=cntinterfaces, cntllc1InMismIpSizes=cntllc1InMismIpSizes, cntCpuNum=cntCpuNum, cntFddiSMTUserData=cntFddiSMTUserData, cntSysNodeAddress=cntSysNodeAddress, cntRowAdditions=cntRowAdditions, cntllc1ConfigTable=cntllc1ConfigTable, cntFeatureIndex=cntFeatureIndex, cntdlInOctets=cntdlInOctets, cntFddiMACBaseLosts=cntFddiMACBaseLosts, cntllc1InitFlag=cntllc1InitFlag, cntllc1XidErrs=cntllc1XidErrs, cntifSubIndex=cntifSubIndex, cntFddiMACRingOps=cntFddiMACRingOps, cntDot3Count=cntDot3Count, cnticmpInReHosts=cnticmpInReHosts, cntMibObjectCount=cntMibObjectCount, cntSlotIndex=cntSlotIndex, cntCpuMonBy=cntCpuMonBy, cntHwReset1Why=cntHwReset1Why, cnticmpInDuNets=cnticmpInDuNets, cnticmpInReNets=cnticmpInReNets, cntdlMtu=cntdlMtu, cntHwReset1Date=cntHwReset1Date, cntdlDescr=cntdlDescr, cntsnmp=cntsnmp, cntRowErrors=cntRowErrors, cnttrapEntry=cnttrapEntry, cntllc1InBadTypes=cntllc1InBadTypes, cntdlInErrors=cntdlInErrors, cntsnmptrap=cntsnmptrap, cntllc1OutTooBigs=cntllc1OutTooBigs, cntFddiMACTPri0=cntFddiMACTPri0, cntllc1StatIndex=cntllc1StatIndex, cnticmpOutDuHosts=cnticmpOutDuHosts, cntMsgSeverity=cntMsgSeverity, cntluaNumber=cntluaNumber, cntFeatureTable=cntFeatureTable, cntifTable=cntifTable, cntdlTable=cntdlTable, cntFddiPATHTRmode=cntFddiPATHTRmode, cntMsgTaskName=cntMsgTaskName, cntllc1InSnapIps=cntllc1InSnapIps, cntFddiMACTPri1=cntFddiMACTPri1, cntSCRTable=cntSCRTable, cntllc1OutTestResps=cntllc1OutTestResps, cntfddi=cntfddi, cntdot3BufPriority=cntdot3BufPriority, cntllc1InXidOks=cntllc1InXidOks, cntFddiPORTEntry=cntFddiPORTEntry, cnticmpOutDuNets=cnticmpOutDuNets, cntSlotTable=cntSlotTable, cntFddiMACLates=cntFddiMACLates, cntdlNumber=cntdlNumber, cntdot3DMAChan1RxErr=cntdot3DMAChan1RxErr, cntFddiMACNotCopiedRatio=cntFddiMACNotCopiedRatio, cntIORevLevel=cntIORevLevel, cntdlInNUcastPkts=cntdlInNUcastPkts, cntdlState=cntdlState, cntFddiSMTTable=cntFddiSMTTable, cntdlPortEntry=cntdlPortEntry, cntFddiMACTransmits=cntFddiMACTransmits, cntHwCpuEntry=cntHwCpuEntry, cntFddiPATHNumber=cntFddiPATHNumber, cntSlotEntry=cntSlotEntry, cntPossibleErrMsg=cntPossibleErrMsg, cntdot3LanceParityErrs=cntdot3LanceParityErrs, cnttrapIndex=cnttrapIndex, cntllc1InTests=cntllc1InTests, cntIOCpuNumber=cntIOCpuNumber, cntFddiPORTMaintLineState=cntFddiPORTMaintLineState, cntllc1ErrorIndex=cntllc1ErrorIndex, cntFddiMACBaseTimeNotCopied=cntFddiMACBaseTimeNotCopied, cntluaIf=cntluaIf, cntFddiMACCopies=cntFddiMACCopies, cntSlotName=cntSlotName, cntFddiPORTNumber=cntFddiPORTNumber, cntdlInUnknownProtos=cntdlInUnknownProtos, cntCpuMsgRets=cntCpuMsgRets, cntHwStatusLED=cntHwStatusLED, cntMDMEntry=cntMDMEntry, cntllc1OutFragPkts=cntllc1OutFragPkts, cntFddiPATHIndex=cntFddiPATHIndex, cnticmpInReServnets=cnticmpInReServnets, cntFeatureName=cntFeatureName, cntdlInUcastPkts=cntdlInUcastPkts, cntdlOutUcastPkts=cntdlOutUcastPkts, cntsnmpTrapFlags=cntsnmpTrapFlags, cntllc1ArpMailErrs=cntllc1ArpMailErrs, cntSCRIndex=cntSCRIndex, cntFddiMACLongGrpAddr=cntFddiMACLongGrpAddr, cntllc1TraceFlag=cntllc1TraceFlag, cntSysCpuTable=cntSysCpuTable, cntdot3DMARxWaitQ=cntdot3DMARxWaitQ, cntUsedCaches=cntUsedCaches, cntCachedResponses=cntCachedResponses, cntllc1OutRetBads=cntllc1OutRetBads, cntMemSramAddress=cntMemSramAddress, cntHwReset2Date=cntHwReset2Date, cnticmpOutReServnets=cnticmpOutReServnets, cntChassisNumber=cntChassisNumber, cntdlDestPort=cntdlDestPort, cntFddiMACEntry=cntFddiMACEntry, cntllc1DriverType=cntllc1DriverType, cntsctSubChanStatus=cntsctSubChanStatus, cntdlPortType=cntdlPortType, cntFddiMACTPri3=cntFddiMACTPri3, cntdot3=cntdot3, cntProxyStatus=cntProxyStatus, cntdlOutNUcastPkts=cntdlOutNUcastPkts, cntFddiMACBaseErrs=cntFddiMACBaseErrs, cntFddiPATHSbaOverhead=cntFddiPATHSbaOverhead, cntdot3DMAChan1RxErrs=cntdot3DMAChan1RxErrs, cnttraceIndex=cnttraceIndex, cntFddiPORTEBErrs=cntFddiPORTEBErrs, cntFddiMACBaseFrames=cntFddiMACBaseFrames, cntFddiMACNotCopies=cntFddiMACNotCopies, cntifType=cntifType, cntproxyNode=cntproxyNode, cntSnmpBufferCount=cntSnmpBufferCount, cntFddiMACDownstreamNbr=cntFddiMACDownstreamNbr, cntdlPortAddrLen=cntdlPortAddrLen, cntFddiPORTFotxClass=cntFddiPORTFotxClass, cntSevereErrMsg=cntSevereErrMsg, cntdlOutErrors=cntdlOutErrors)

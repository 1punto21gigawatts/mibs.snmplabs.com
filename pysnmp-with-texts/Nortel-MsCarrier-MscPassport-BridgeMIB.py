#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-BridgeMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-BridgeMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:29:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection")
Counter32, RowStatus, DisplayString, Integer32, InterfaceIndex, StorageType, Gauge32, BridgeId, Unsigned32, MacAddress = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "Counter32", "RowStatus", "DisplayString", "Integer32", "InterfaceIndex", "StorageType", "Gauge32", "BridgeId", "Unsigned32", "MacAddress")
DashedHexString, AsciiString, Link, AsciiStringIndex, HexString, Hex, NonReplicated = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "DashedHexString", "AsciiString", "Link", "AsciiStringIndex", "HexString", "Hex", "NonReplicated")
mscPassportMIBs, mscComponents = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs", "mscComponents")
mscVrIndex, mscVrPpIndex, mscVrPp, mscVr = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex", "mscVrPpIndex", "mscVrPp", "mscVr")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, Unsigned32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, TimeTicks, MibIdentifier, Bits, Integer32, ModuleIdentity, IpAddress, Gauge32, NotificationType, Counter64, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "Unsigned32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "TimeTicks", "MibIdentifier", "Bits", "Integer32", "ModuleIdentity", "IpAddress", "Gauge32", "NotificationType", "Counter64", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
bridgeMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25))
mscVrPpTbcl = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2))
mscVrPpTbclRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 1), )
if mibBuilder.loadTexts: mscVrPpTbclRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpTbcl components.')
mscVrPpTbclRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpTbcl component.')
mscVrPpTbclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpTbcl components. These components can be added and deleted.')
mscVrPpTbclComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpTbclStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStorageType.setDescription('This variable represents the storage type value for the mscVrPpTbcl tables.')
mscVrPpTbclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpTbclIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclIndex.setDescription('This variable represents the index for the mscVrPpTbcl tables.')
mscVrPpTbclProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 10), )
if mibBuilder.loadTexts: mscVrPpTbclProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpTbclProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclProvEntry.setDescription('An entry in the mscVrPpTbclProvTable.')
mscVrPpTbclTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpTbclFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpTbclServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpTbclConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpTbclPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpTbclTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 11), )
if mibBuilder.loadTexts: mscVrPpTbclTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
mscVrPpTbclTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclTbProvEntry.setDescription('An entry in the mscVrPpTbclTbProvTable.')
mscVrPpTbclSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
mscVrPpTbclStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12), )
if mibBuilder.loadTexts: mscVrPpTbclStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpTbclStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStpProvEntry.setDescription('An entry in the mscVrPpTbclStpProvTable.')
mscVrPpTbclAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpTbclPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpTbclStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpTbclPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpTbclPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpTbclPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpTbclDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 13), )
if mibBuilder.loadTexts: mscVrPpTbclDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpTbclDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDIProvEntry.setDescription('An entry in the mscVrPpTbclDIProvTable.')
mscVrPpTbclDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpTbclPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpTbclStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 14), )
if mibBuilder.loadTexts: mscVrPpTbclStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpTbclStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStateEntry.setDescription('An entry in the mscVrPpTbclStateTable.')
mscVrPpTbclAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpTbclOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpTbclUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpTbclOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 15), )
if mibBuilder.loadTexts: mscVrPpTbclOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpTbclOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclOperStatusEntry.setDescription('An entry in the mscVrPpTbclOperStatusTable.')
mscVrPpTbclSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpTbclOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16), )
if mibBuilder.loadTexts: mscVrPpTbclOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpTbclOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclOperEntry.setDescription('An entry in the mscVrPpTbclOperTable.')
mscVrPpTbclPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpTbclUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpTbclDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpTbclBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpTbclBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpTbclBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpTbclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpTbclDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpTbclMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpTbclTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17), )
if mibBuilder.loadTexts: mscVrPpTbclTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
mscVrPpTbclTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclTbOperEntry.setDescription('An entry in the mscVrPpTbclTbOperTable.')
mscVrPpTbclMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
mscVrPpTbclBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
mscVrPpTbclDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
mscVrPpTbclInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18), )
if mibBuilder.loadTexts: mscVrPpTbclStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpTbclStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStpOperEntry.setDescription('An entry in the mscVrPpTbclStpOperTable.')
mscVrPpTbclStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpTbclStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpTbclDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpTbclPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpTbclDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpTbclDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpTbclForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpTbclBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpTbclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 19), )
if mibBuilder.loadTexts: mscVrPpTbclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpTbclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"))
if mibBuilder.loadTexts: mscVrPpTbclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclStatsEntry.setDescription('An entry in the mscVrPpTbclStatsTable.')
mscVrPpTbclBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpTbclTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpTbclInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbclNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2))
mscVrPpTbclNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 1), )
if mibBuilder.loadTexts: mscVrPpTbclNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpTbclNs components.')
mscVrPpTbclNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclNsIndex"))
if mibBuilder.loadTexts: mscVrPpTbclNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpTbclNs component.')
mscVrPpTbclNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpTbclNs components. These components can be added and deleted.')
mscVrPpTbclNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpTbclNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbclNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsStorageType.setDescription('This variable represents the storage type value for the mscVrPpTbclNs tables.')
mscVrPpTbclNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpTbclNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsIndex.setDescription('This variable represents the index for the mscVrPpTbclNs tables.')
mscVrPpTbclNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 10), )
if mibBuilder.loadTexts: mscVrPpTbclNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
mscVrPpTbclNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbclNsIndex"))
if mibBuilder.loadTexts: mscVrPpTbclNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsProvEntry.setDescription('An entry in the mscVrPpTbclNsProvTable.')
mscVrPpTbclNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
mscVrPpTbclNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 2, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbclNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbclNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
mscVrPpFddiETB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3))
mscVrPpFddiETBRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 1), )
if mibBuilder.loadTexts: mscVrPpFddiETBRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpFddiETB components.')
mscVrPpFddiETBRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpFddiETB component.')
mscVrPpFddiETBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpFddiETB components. These components can be added and deleted.')
mscVrPpFddiETBComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpFddiETBStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStorageType.setDescription('This variable represents the storage type value for the mscVrPpFddiETB tables.')
mscVrPpFddiETBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpFddiETBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBIndex.setDescription('This variable represents the index for the mscVrPpFddiETB tables.')
mscVrPpFddiETBProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 10), )
if mibBuilder.loadTexts: mscVrPpFddiETBProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpFddiETBProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBProvEntry.setDescription('An entry in the mscVrPpFddiETBProvTable.')
mscVrPpFddiETBTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpFddiETBFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpFddiETBServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpFddiETBConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpFddiETBPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpFddiETBTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 11), )
if mibBuilder.loadTexts: mscVrPpFddiETBTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
mscVrPpFddiETBTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBTbProvEntry.setDescription('An entry in the mscVrPpFddiETBTbProvTable.')
mscVrPpFddiETBSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
mscVrPpFddiETBStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12), )
if mibBuilder.loadTexts: mscVrPpFddiETBStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpFddiETBStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStpProvEntry.setDescription('An entry in the mscVrPpFddiETBStpProvTable.')
mscVrPpFddiETBAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpFddiETBPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpFddiETBStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpFddiETBPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpFddiETBPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpFddiETBPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpFddiETBDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 13), )
if mibBuilder.loadTexts: mscVrPpFddiETBDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpFddiETBDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDIProvEntry.setDescription('An entry in the mscVrPpFddiETBDIProvTable.')
mscVrPpFddiETBDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpFddiETBPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpFddiETBStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 14), )
if mibBuilder.loadTexts: mscVrPpFddiETBStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpFddiETBStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStateEntry.setDescription('An entry in the mscVrPpFddiETBStateTable.')
mscVrPpFddiETBAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpFddiETBOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpFddiETBUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpFddiETBOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 15), )
if mibBuilder.loadTexts: mscVrPpFddiETBOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpFddiETBOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBOperStatusEntry.setDescription('An entry in the mscVrPpFddiETBOperStatusTable.')
mscVrPpFddiETBSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpFddiETBOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16), )
if mibBuilder.loadTexts: mscVrPpFddiETBOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpFddiETBOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBOperEntry.setDescription('An entry in the mscVrPpFddiETBOperTable.')
mscVrPpFddiETBPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpFddiETBUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpFddiETBDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpFddiETBBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpFddiETBBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpFddiETBBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpFddiETBIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpFddiETBDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpFddiETBMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpFddiETBTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17), )
if mibBuilder.loadTexts: mscVrPpFddiETBTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
mscVrPpFddiETBTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBTbOperEntry.setDescription('An entry in the mscVrPpFddiETBTbOperTable.')
mscVrPpFddiETBMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
mscVrPpFddiETBBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
mscVrPpFddiETBDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
mscVrPpFddiETBInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18), )
if mibBuilder.loadTexts: mscVrPpFddiETBStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpFddiETBStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStpOperEntry.setDescription('An entry in the mscVrPpFddiETBStpOperTable.')
mscVrPpFddiETBStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpFddiETBStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpFddiETBDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpFddiETBPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpFddiETBDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpFddiETBDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpFddiETBForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpFddiETBBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpFddiETBStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 19), )
if mibBuilder.loadTexts: mscVrPpFddiETBStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpFddiETBStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBStatsEntry.setDescription('An entry in the mscVrPpFddiETBStatsTable.')
mscVrPpFddiETBBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpFddiETBTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpFddiETBInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpFddiETBNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2))
mscVrPpFddiETBNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 1), )
if mibBuilder.loadTexts: mscVrPpFddiETBNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpFddiETBNs components.')
mscVrPpFddiETBNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBNsIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpFddiETBNs component.')
mscVrPpFddiETBNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpFddiETBNs components. These components can be added and deleted.')
mscVrPpFddiETBNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpFddiETBNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpFddiETBNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsStorageType.setDescription('This variable represents the storage type value for the mscVrPpFddiETBNs tables.')
mscVrPpFddiETBNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpFddiETBNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsIndex.setDescription('This variable represents the index for the mscVrPpFddiETBNs tables.')
mscVrPpFddiETBNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 10), )
if mibBuilder.loadTexts: mscVrPpFddiETBNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
mscVrPpFddiETBNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpFddiETBNsIndex"))
if mibBuilder.loadTexts: mscVrPpFddiETBNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsProvEntry.setDescription('An entry in the mscVrPpFddiETBNsProvTable.')
mscVrPpFddiETBNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
mscVrPpFddiETBNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 3, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpFddiETBNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpFddiETBNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
mscVrPpTbp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4))
mscVrPpTbpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 1), )
if mibBuilder.loadTexts: mscVrPpTbpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpTbp components.')
mscVrPpTbpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpTbp component.')
mscVrPpTbpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpTbp components. These components can be added and deleted.')
mscVrPpTbpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpTbpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStorageType.setDescription('This variable represents the storage type value for the mscVrPpTbp tables.')
mscVrPpTbpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpTbpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpIndex.setDescription('This variable represents the index for the mscVrPpTbp tables.')
mscVrPpTbpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 10), )
if mibBuilder.loadTexts: mscVrPpTbpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpTbpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpProvEntry.setDescription('An entry in the mscVrPpTbpProvTable.')
mscVrPpTbpTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpTbpFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpTbpServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpTbpConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpTbpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpTbpTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 11), )
if mibBuilder.loadTexts: mscVrPpTbpTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
mscVrPpTbpTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpTbProvEntry.setDescription('An entry in the mscVrPpTbpTbProvTable.')
mscVrPpTbpSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
mscVrPpTbpStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12), )
if mibBuilder.loadTexts: mscVrPpTbpStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpTbpStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStpProvEntry.setDescription('An entry in the mscVrPpTbpStpProvTable.')
mscVrPpTbpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpTbpPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpTbpStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpTbpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpTbpPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpTbpPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpTbpDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 13), )
if mibBuilder.loadTexts: mscVrPpTbpDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpTbpDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDIProvEntry.setDescription('An entry in the mscVrPpTbpDIProvTable.')
mscVrPpTbpDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpTbpPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpTbpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 14), )
if mibBuilder.loadTexts: mscVrPpTbpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpTbpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStateEntry.setDescription('An entry in the mscVrPpTbpStateTable.')
mscVrPpTbpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpTbpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpTbpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpTbpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 15), )
if mibBuilder.loadTexts: mscVrPpTbpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpTbpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpOperStatusEntry.setDescription('An entry in the mscVrPpTbpOperStatusTable.')
mscVrPpTbpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpTbpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16), )
if mibBuilder.loadTexts: mscVrPpTbpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpTbpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpOperEntry.setDescription('An entry in the mscVrPpTbpOperTable.')
mscVrPpTbpPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpTbpUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpTbpDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpTbpBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpTbpBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpTbpBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpTbpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpTbpDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpTbpMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpTbpTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17), )
if mibBuilder.loadTexts: mscVrPpTbpTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
mscVrPpTbpTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpTbOperEntry.setDescription('An entry in the mscVrPpTbpTbOperTable.')
mscVrPpTbpMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
mscVrPpTbpBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
mscVrPpTbpDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
mscVrPpTbpInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18), )
if mibBuilder.loadTexts: mscVrPpTbpStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpTbpStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStpOperEntry.setDescription('An entry in the mscVrPpTbpStpOperTable.')
mscVrPpTbpStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpTbpStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpTbpDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpTbpPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpTbpDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpTbpDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpTbpForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpTbpBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpTbpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 19), )
if mibBuilder.loadTexts: mscVrPpTbpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpTbpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"))
if mibBuilder.loadTexts: mscVrPpTbpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpStatsEntry.setDescription('An entry in the mscVrPpTbpStatsTable.')
mscVrPpTbpBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpTbpTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpTbpInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2))
mscVrPpTbpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 1), )
if mibBuilder.loadTexts: mscVrPpTbpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpTbpNs components.')
mscVrPpTbpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpNsIndex"))
if mibBuilder.loadTexts: mscVrPpTbpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpTbpNs component.')
mscVrPpTbpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpTbpNs components. These components can be added and deleted.')
mscVrPpTbpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpTbpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsStorageType.setDescription('This variable represents the storage type value for the mscVrPpTbpNs tables.')
mscVrPpTbpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpTbpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsIndex.setDescription('This variable represents the index for the mscVrPpTbpNs tables.')
mscVrPpTbpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 10), )
if mibBuilder.loadTexts: mscVrPpTbpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
mscVrPpTbpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbpNsIndex"))
if mibBuilder.loadTexts: mscVrPpTbpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsProvEntry.setDescription('An entry in the mscVrPpTbpNsProvTable.')
mscVrPpTbpNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
mscVrPpTbpNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 4, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbpNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbpNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
mscVrPpSrBp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8))
mscVrPpSrBpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 1), )
if mibBuilder.loadTexts: mscVrPpSrBpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrBp components.')
mscVrPpSrBpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrBp component.')
mscVrPpSrBpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrBp components. These components can be added and deleted.')
mscVrPpSrBpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrBpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrBp tables.')
mscVrPpSrBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpIndex.setDescription('This variable represents the index for the mscVrPpSrBp tables.')
mscVrPpSrBpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 10), )
if mibBuilder.loadTexts: mscVrPpSrBpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpSrBpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpProvEntry.setDescription('An entry in the mscVrPpSrBpProvTable.')
mscVrPpSrBpTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpSrBpFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpSrBpServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpSrBpConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpSrBpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpSrBpStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12), )
if mibBuilder.loadTexts: mscVrPpSrBpStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpSrBpStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStpProvEntry.setDescription('An entry in the mscVrPpSrBpStpProvTable.')
mscVrPpSrBpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpSrBpPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpSrBpStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpSrBpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpSrBpPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpSrBpPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpSrBpDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 13), )
if mibBuilder.loadTexts: mscVrPpSrBpDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpSrBpDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDIProvEntry.setDescription('An entry in the mscVrPpSrBpDIProvTable.')
mscVrPpSrBpDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpSrBpPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpSrBpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 14), )
if mibBuilder.loadTexts: mscVrPpSrBpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpSrBpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStateEntry.setDescription('An entry in the mscVrPpSrBpStateTable.')
mscVrPpSrBpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpSrBpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpSrBpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpSrBpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 15), )
if mibBuilder.loadTexts: mscVrPpSrBpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpSrBpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpOperStatusEntry.setDescription('An entry in the mscVrPpSrBpOperStatusTable.')
mscVrPpSrBpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpSrBpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16), )
if mibBuilder.loadTexts: mscVrPpSrBpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpSrBpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpOperEntry.setDescription('An entry in the mscVrPpSrBpOperTable.')
mscVrPpSrBpPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpSrBpUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpSrBpDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpSrBpBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpSrBpBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpSrBpBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpSrBpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpSrBpDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpSrBpMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpSrBpStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18), )
if mibBuilder.loadTexts: mscVrPpSrBpStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpSrBpStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStpOperEntry.setDescription('An entry in the mscVrPpSrBpStpOperTable.')
mscVrPpSrBpStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpSrBpStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpSrBpDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpSrBpPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpSrBpDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpSrBpDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpSrBpForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpSrBpBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrBpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpSrBpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 19), )
if mibBuilder.loadTexts: mscVrPpSrBpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpSrBpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStatsEntry.setDescription('An entry in the mscVrPpSrBpStatsTable.')
mscVrPpSrBpBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpSrBpTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpSrBpTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpSrBpInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrBpOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrBpSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20), )
if mibBuilder.loadTexts: mscVrPpSrBpSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
mscVrPpSrBpSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSrProvEntry.setDescription('An entry in the mscVrPpSrBpSrProvTable.')
mscVrPpSrBpHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
mscVrPpSrBpExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
mscVrPpSrBpLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrBpInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrBpBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
mscVrPpSrBpLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
mscVrPpSrBpSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
mscVrPpSrBpAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
mscVrPpSrBpSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
mscVrPpSrBpSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21), )
if mibBuilder.loadTexts: mscVrPpSrBpSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
mscVrPpSrBpSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSrStatsEntry.setDescription('An entry in the mscVrPpSrBpSrStatsTable.')
mscVrPpSrBpSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrBpApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrBpSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrBpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2))
mscVrPpSrBpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 1), )
if mibBuilder.loadTexts: mscVrPpSrBpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrBpNs components.')
mscVrPpSrBpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpNsIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrBpNs component.')
mscVrPpSrBpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrBpNs components. These components can be added and deleted.')
mscVrPpSrBpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrBpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrBpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrBpNs tables.')
mscVrPpSrBpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrBpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsIndex.setDescription('This variable represents the index for the mscVrPpSrBpNs tables.')
mscVrPpSrBpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 10), )
if mibBuilder.loadTexts: mscVrPpSrBpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
mscVrPpSrBpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrBpNsIndex"))
if mibBuilder.loadTexts: mscVrPpSrBpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsProvEntry.setDescription('An entry in the mscVrPpSrBpNsProvTable.')
mscVrPpSrBpNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
mscVrPpSrBpNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 8, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrBpNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrBpNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
mscVrPpSrtBp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9))
mscVrPpSrtBpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 1), )
if mibBuilder.loadTexts: mscVrPpSrtBpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrtBp components.')
mscVrPpSrtBpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrtBp component.')
mscVrPpSrtBpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrtBp components. These components can be added and deleted.')
mscVrPpSrtBpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrtBpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrtBp tables.')
mscVrPpSrtBpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrtBpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpIndex.setDescription('This variable represents the index for the mscVrPpSrtBp tables.')
mscVrPpSrtBpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 10), )
if mibBuilder.loadTexts: mscVrPpSrtBpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpSrtBpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpProvEntry.setDescription('An entry in the mscVrPpSrtBpProvTable.')
mscVrPpSrtBpTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpSrtBpFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpSrtBpServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpSrtBpConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpSrtBpPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpSrtBpTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 11), )
if mibBuilder.loadTexts: mscVrPpSrtBpTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
mscVrPpSrtBpTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpTbProvEntry.setDescription('An entry in the mscVrPpSrtBpTbProvTable.')
mscVrPpSrtBpSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
mscVrPpSrtBpStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12), )
if mibBuilder.loadTexts: mscVrPpSrtBpStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpSrtBpStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStpProvEntry.setDescription('An entry in the mscVrPpSrtBpStpProvTable.')
mscVrPpSrtBpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpSrtBpPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpSrtBpStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpSrtBpPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpSrtBpPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpSrtBpPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpSrtBpDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 13), )
if mibBuilder.loadTexts: mscVrPpSrtBpDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpSrtBpDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDIProvEntry.setDescription('An entry in the mscVrPpSrtBpDIProvTable.')
mscVrPpSrtBpDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpSrtBpPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpSrtBpStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 14), )
if mibBuilder.loadTexts: mscVrPpSrtBpStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpSrtBpStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStateEntry.setDescription('An entry in the mscVrPpSrtBpStateTable.')
mscVrPpSrtBpAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpSrtBpOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpSrtBpUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpSrtBpOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 15), )
if mibBuilder.loadTexts: mscVrPpSrtBpOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpSrtBpOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpOperStatusEntry.setDescription('An entry in the mscVrPpSrtBpOperStatusTable.')
mscVrPpSrtBpSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpSrtBpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16), )
if mibBuilder.loadTexts: mscVrPpSrtBpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpSrtBpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpOperEntry.setDescription('An entry in the mscVrPpSrtBpOperTable.')
mscVrPpSrtBpPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpSrtBpUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpSrtBpDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpSrtBpBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpSrtBpBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpSrtBpBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpSrtBpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpSrtBpDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpSrtBpMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpSrtBpTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17), )
if mibBuilder.loadTexts: mscVrPpSrtBpTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
mscVrPpSrtBpTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpTbOperEntry.setDescription('An entry in the mscVrPpSrtBpTbOperTable.')
mscVrPpSrtBpMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
mscVrPpSrtBpBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
mscVrPpSrtBpDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
mscVrPpSrtBpInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18), )
if mibBuilder.loadTexts: mscVrPpSrtBpStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpSrtBpStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStpOperEntry.setDescription('An entry in the mscVrPpSrtBpStpOperTable.')
mscVrPpSrtBpStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpSrtBpStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpSrtBpDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpSrtBpPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpSrtBpDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpSrtBpDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpSrtBpForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpSrtBpBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpSrtBpStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 19), )
if mibBuilder.loadTexts: mscVrPpSrtBpStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpSrtBpStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStatsEntry.setDescription('An entry in the mscVrPpSrtBpStatsTable.')
mscVrPpSrtBpBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpSrtBpTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpSrtBpInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrtBpSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20), )
if mibBuilder.loadTexts: mscVrPpSrtBpSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
mscVrPpSrtBpSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSrProvEntry.setDescription('An entry in the mscVrPpSrtBpSrProvTable.')
mscVrPpSrtBpHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
mscVrPpSrtBpExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
mscVrPpSrtBpLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrtBpInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrtBpBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
mscVrPpSrtBpLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
mscVrPpSrtBpSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
mscVrPpSrtBpAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
mscVrPpSrtBpSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
mscVrPpSrtBpSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21), )
if mibBuilder.loadTexts: mscVrPpSrtBpSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
mscVrPpSrtBpSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSrStatsEntry.setDescription('An entry in the mscVrPpSrtBpSrStatsTable.')
mscVrPpSrtBpSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrtBpApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrtBpSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrtBpNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2))
mscVrPpSrtBpNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 1), )
if mibBuilder.loadTexts: mscVrPpSrtBpNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrtBpNs components.')
mscVrPpSrtBpNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpNsIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrtBpNs component.')
mscVrPpSrtBpNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrtBpNs components. These components can be added and deleted.')
mscVrPpSrtBpNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrtBpNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrtBpNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrtBpNs tables.')
mscVrPpSrtBpNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrtBpNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsIndex.setDescription('This variable represents the index for the mscVrPpSrtBpNs tables.')
mscVrPpSrtBpNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 10), )
if mibBuilder.loadTexts: mscVrPpSrtBpNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
mscVrPpSrtBpNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrtBpNsIndex"))
if mibBuilder.loadTexts: mscVrPpSrtBpNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsProvEntry.setDescription('An entry in the mscVrPpSrtBpNsProvTable.')
mscVrPpSrtBpNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
mscVrPpSrtBpNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 9, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrtBpNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrtBpNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
mscVrPpSrse = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10))
mscVrPpSrseRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 1), )
if mibBuilder.loadTexts: mscVrPpSrseRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrse components.')
mscVrPpSrseRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrse component.')
mscVrPpSrseRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrse components. These components can be added and deleted.')
mscVrPpSrseComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrseStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrse tables.')
mscVrPpSrseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrseIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseIndex.setDescription('This variable represents the index for the mscVrPpSrse tables.')
mscVrPpSrseProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 10), )
if mibBuilder.loadTexts: mscVrPpSrseProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpSrseProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseProvEntry.setDescription('An entry in the mscVrPpSrseProvTable.')
mscVrPpSrseTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpSrseFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpSrseServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpSrseConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpSrsePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpSrseStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12), )
if mibBuilder.loadTexts: mscVrPpSrseStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpSrseStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStpProvEntry.setDescription('An entry in the mscVrPpSrseStpProvTable.')
mscVrPpSrseAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpSrsePortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsePortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpSrseStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpSrsePortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsePortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpSrsePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsePathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpSrsePathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsePathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpSrseDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 13), )
if mibBuilder.loadTexts: mscVrPpSrseDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpSrseDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDIProvEntry.setDescription('An entry in the mscVrPpSrseDIProvTable.')
mscVrPpSrseDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpSrsePreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsePreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpSrseStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 14), )
if mibBuilder.loadTexts: mscVrPpSrseStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpSrseStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStateEntry.setDescription('An entry in the mscVrPpSrseStateTable.')
mscVrPpSrseAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpSrseOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpSrseUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpSrseOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 15), )
if mibBuilder.loadTexts: mscVrPpSrseOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpSrseOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseOperStatusEntry.setDescription('An entry in the mscVrPpSrseOperStatusTable.')
mscVrPpSrseSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpSrseOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16), )
if mibBuilder.loadTexts: mscVrPpSrseOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpSrseOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseOperEntry.setDescription('An entry in the mscVrPpSrseOperTable.')
mscVrPpSrsePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsePortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpSrseUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpSrseDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpSrseBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpSrseBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpSrseBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpSrseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpSrseDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpSrseMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpSrseStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18), )
if mibBuilder.loadTexts: mscVrPpSrseStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpSrseStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStpOperEntry.setDescription('An entry in the mscVrPpSrseStpOperTable.')
mscVrPpSrseStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpSrseStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpSrseDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpSrsePathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsePathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsePathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpSrseDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpSrseDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpSrseForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpSrseBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrseDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpSrseStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 19), )
if mibBuilder.loadTexts: mscVrPpSrseStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpSrseStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStatsEntry.setDescription('An entry in the mscVrPpSrseStatsTable.')
mscVrPpSrseBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpSrseTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpSrseTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpSrseInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrseOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrseSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20), )
if mibBuilder.loadTexts: mscVrPpSrseSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
mscVrPpSrseSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSrProvEntry.setDescription('An entry in the mscVrPpSrseSrProvTable.')
mscVrPpSrseHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
mscVrPpSrseExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
mscVrPpSrseLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrseInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrseBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
mscVrPpSrseLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
mscVrPpSrseSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
mscVrPpSrseAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
mscVrPpSrseSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrseSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
mscVrPpSrseSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21), )
if mibBuilder.loadTexts: mscVrPpSrseSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
mscVrPpSrseSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrseIndex"))
if mibBuilder.loadTexts: mscVrPpSrseSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSrStatsEntry.setDescription('An entry in the mscVrPpSrseSrStatsTable.')
mscVrPpSrseSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrseApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrseSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrseDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 10, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrseDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrseDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpTbse = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11))
mscVrPpTbseRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 1), )
if mibBuilder.loadTexts: mscVrPpTbseRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpTbse components.')
mscVrPpTbseRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpTbse component.')
mscVrPpTbseRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpTbse components. These components can be added and deleted.')
mscVrPpTbseComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpTbseStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStorageType.setDescription('This variable represents the storage type value for the mscVrPpTbse tables.')
mscVrPpTbseIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpTbseIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseIndex.setDescription('This variable represents the index for the mscVrPpTbse tables.')
mscVrPpTbseProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 10), )
if mibBuilder.loadTexts: mscVrPpTbseProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpTbseProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseProvEntry.setDescription('An entry in the mscVrPpTbseProvTable.')
mscVrPpTbseTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpTbseFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpTbseServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpTbseConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpTbsePortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsePortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpTbseTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 11), )
if mibBuilder.loadTexts: mscVrPpTbseTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
mscVrPpTbseTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseTbProvEntry.setDescription('An entry in the mscVrPpTbseTbProvTable.')
mscVrPpTbseSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
mscVrPpTbseStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12), )
if mibBuilder.loadTexts: mscVrPpTbseStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpTbseStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStpProvEntry.setDescription('An entry in the mscVrPpTbseStpProvTable.')
mscVrPpTbseAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpTbsePortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsePortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpTbseStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpTbsePortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsePortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpTbsePathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsePathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpTbsePathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsePathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpTbseDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 13), )
if mibBuilder.loadTexts: mscVrPpTbseDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpTbseDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDIProvEntry.setDescription('An entry in the mscVrPpTbseDIProvTable.')
mscVrPpTbseDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbseDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpTbsePreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsePreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpTbseStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 14), )
if mibBuilder.loadTexts: mscVrPpTbseStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpTbseStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStateEntry.setDescription('An entry in the mscVrPpTbseStateTable.')
mscVrPpTbseAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpTbseOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpTbseUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpTbseOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 15), )
if mibBuilder.loadTexts: mscVrPpTbseOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpTbseOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseOperStatusEntry.setDescription('An entry in the mscVrPpTbseOperStatusTable.')
mscVrPpTbseSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpTbseOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16), )
if mibBuilder.loadTexts: mscVrPpTbseOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpTbseOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseOperEntry.setDescription('An entry in the mscVrPpTbseOperTable.')
mscVrPpTbsePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsePortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpTbseUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpTbseDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpTbseBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpTbseBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpTbseBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpTbseIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpTbseDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpTbseMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpTbseTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17), )
if mibBuilder.loadTexts: mscVrPpTbseTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
mscVrPpTbseTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseTbOperEntry.setDescription('An entry in the mscVrPpTbseTbOperTable.')
mscVrPpTbseMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
mscVrPpTbseBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
mscVrPpTbseDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
mscVrPpTbseInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18), )
if mibBuilder.loadTexts: mscVrPpTbseStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpTbseStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStpOperEntry.setDescription('An entry in the mscVrPpTbseStpOperTable.')
mscVrPpTbseStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpTbseStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpTbseDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpTbsePathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsePathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsePathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpTbseDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpTbseDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpTbseForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpTbseBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpTbseStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 19), )
if mibBuilder.loadTexts: mscVrPpTbseStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpTbseStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbseIndex"))
if mibBuilder.loadTexts: mscVrPpTbseStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseStatsEntry.setDescription('An entry in the mscVrPpTbseStatsTable.')
mscVrPpTbseBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpTbseTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpTbseInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbseOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 11, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbseOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbseOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrsg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12))
mscVrPpSrsgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 1), )
if mibBuilder.loadTexts: mscVrPpSrsgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrsg components.')
mscVrPpSrsgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrsg component.')
mscVrPpSrsgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrsg components. These components can be added and deleted.')
mscVrPpSrsgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrsgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrsg tables.')
mscVrPpSrsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgIndex.setDescription('This variable represents the index for the mscVrPpSrsg tables.')
mscVrPpSrsgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 10), )
if mibBuilder.loadTexts: mscVrPpSrsgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpSrsgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgProvEntry.setDescription('An entry in the mscVrPpSrsgProvTable.')
mscVrPpSrsgTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpSrsgFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpSrsgServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpSrsgConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpSrsgPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpSrsgStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12), )
if mibBuilder.loadTexts: mscVrPpSrsgStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpSrsgStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStpProvEntry.setDescription('An entry in the mscVrPpSrsgStpProvTable.')
mscVrPpSrsgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpSrsgPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpSrsgStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpSrsgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpSrsgPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpSrsgPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpSrsgDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 13), )
if mibBuilder.loadTexts: mscVrPpSrsgDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpSrsgDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDIProvEntry.setDescription('An entry in the mscVrPpSrsgDIProvTable.')
mscVrPpSrsgDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpSrsgPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpSrsgStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 14), )
if mibBuilder.loadTexts: mscVrPpSrsgStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpSrsgStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStateEntry.setDescription('An entry in the mscVrPpSrsgStateTable.')
mscVrPpSrsgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpSrsgOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpSrsgUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpSrsgOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 15), )
if mibBuilder.loadTexts: mscVrPpSrsgOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpSrsgOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgOperStatusEntry.setDescription('An entry in the mscVrPpSrsgOperStatusTable.')
mscVrPpSrsgSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpSrsgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16), )
if mibBuilder.loadTexts: mscVrPpSrsgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpSrsgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgOperEntry.setDescription('An entry in the mscVrPpSrsgOperTable.')
mscVrPpSrsgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpSrsgUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpSrsgDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpSrsgBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpSrsgBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpSrsgBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpSrsgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpSrsgDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpSrsgMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpSrsgStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18), )
if mibBuilder.loadTexts: mscVrPpSrsgStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpSrsgStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStpOperEntry.setDescription('An entry in the mscVrPpSrsgStpOperTable.')
mscVrPpSrsgStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpSrsgStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpSrsgDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpSrsgPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpSrsgDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpSrsgDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpSrsgForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpSrsgBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrsgDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpSrsgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 19), )
if mibBuilder.loadTexts: mscVrPpSrsgStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpSrsgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStatsEntry.setDescription('An entry in the mscVrPpSrsgStatsTable.')
mscVrPpSrsgBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpSrsgTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpSrsgTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpSrsgInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrsgOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrsgSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20), )
if mibBuilder.loadTexts: mscVrPpSrsgSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
mscVrPpSrsgSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSrProvEntry.setDescription('An entry in the mscVrPpSrsgSrProvTable.')
mscVrPpSrsgHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
mscVrPpSrsgExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
mscVrPpSrsgLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrsgInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrsgBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
mscVrPpSrsgLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
mscVrPpSrsgSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
mscVrPpSrsgAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
mscVrPpSrsgSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrsgSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
mscVrPpSrsgSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21), )
if mibBuilder.loadTexts: mscVrPpSrsgSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
mscVrPpSrsgSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrsgIndex"))
if mibBuilder.loadTexts: mscVrPpSrsgSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSrStatsEntry.setDescription('An entry in the mscVrPpSrsgSrStatsTable.')
mscVrPpSrsgSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrsgApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrsgSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrsgDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 12, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrsgDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrsgDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpTbsg = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13))
mscVrPpTbsgRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 1), )
if mibBuilder.loadTexts: mscVrPpTbsgRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpTbsg components.')
mscVrPpTbsgRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpTbsg component.')
mscVrPpTbsgRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpTbsg components. These components can be added and deleted.')
mscVrPpTbsgComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpTbsgStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStorageType.setDescription('This variable represents the storage type value for the mscVrPpTbsg tables.')
mscVrPpTbsgIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpTbsgIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgIndex.setDescription('This variable represents the index for the mscVrPpTbsg tables.')
mscVrPpTbsgProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 10), )
if mibBuilder.loadTexts: mscVrPpTbsgProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpTbsgProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgProvEntry.setDescription('An entry in the mscVrPpTbsgProvTable.')
mscVrPpTbsgTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpTbsgFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpTbsgServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpTbsgConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpTbsgPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpTbsgTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 11), )
if mibBuilder.loadTexts: mscVrPpTbsgTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgTbProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes in part influence the working of a bridge port operating in the TB mode.')
mscVrPpTbsgTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgTbProvEntry.setDescription('An entry in the mscVrPpTbsgTbProvTable.')
mscVrPpTbsgSecureOption = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgSecureOption.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgSecureOption.setDescription('This attribute specifies whether the port secure feature is enabled. The secure feature, if enabled causes the following things to happen: a) disallows dynamic learning, b) disallows frames to be forwarded that do not satisfy the following condition: the mac address of the source should be found in the forwarding table and the destination mac address of the frame should also be found in the forwarding table. In addition to this, the port the frame was received on should figure as the in port, given the destination mac address found in the frame. c) disallows frames to be forwarded if the allowed to go port map for the destination mac address is empty. This feature in effect allows the user to choose the hosts that can generate traffic and the hosts that can receive traffic through this bridge unit.')
mscVrPpTbsgStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12), )
if mibBuilder.loadTexts: mscVrPpTbsgStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpTbsgStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStpProvEntry.setDescription('An entry in the mscVrPpTbsgStpProvTable.')
mscVrPpTbsgAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpTbsgPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpTbsgStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpTbsgPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpTbsgPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpTbsgPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpTbsgDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 13), )
if mibBuilder.loadTexts: mscVrPpTbsgDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpTbsgDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDIProvEntry.setDescription('An entry in the mscVrPpTbsgDIProvTable.')
mscVrPpTbsgDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpTbsgPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpTbsgPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpTbsgStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 14), )
if mibBuilder.loadTexts: mscVrPpTbsgStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpTbsgStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStateEntry.setDescription('An entry in the mscVrPpTbsgStateTable.')
mscVrPpTbsgAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpTbsgOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpTbsgUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpTbsgOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 15), )
if mibBuilder.loadTexts: mscVrPpTbsgOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpTbsgOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgOperStatusEntry.setDescription('An entry in the mscVrPpTbsgOperStatusTable.')
mscVrPpTbsgSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpTbsgOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16), )
if mibBuilder.loadTexts: mscVrPpTbsgOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpTbsgOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgOperEntry.setDescription('An entry in the mscVrPpTbsgOperTable.')
mscVrPpTbsgPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpTbsgUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpTbsgDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpTbsgBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpTbsgBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpTbsgBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpTbsgIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpTbsgDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpTbsgMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpTbsgTbOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17), )
if mibBuilder.loadTexts: mscVrPpTbsgTbOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgTbOperTable.setDescription('This group houses all the port specific operational attributes that belong to the Tb group. This group also houses all the port specific statistical attributes that belong to the Tb group. The Tb group is only applicable bridge port types that operate in the TB mode. These attributes reflect the state of a bridge port operating in the TB mode')
mscVrPpTbsgTbOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgTbOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgTbOperEntry.setDescription('An entry in the mscVrPpTbsgTbOperTable.')
mscVrPpTbsgMaxInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgMaxInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgMaxInfo.setDescription('This attribute specifies the maximum size of the information field in a TB frame. This excludes the header field.')
mscVrPpTbsgBadVerifyDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgBadVerifyDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgBadVerifyDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because: a) the value of the secureOption attribute was set to on and b) it is not allowed to receive frames originating from the mac address found in the source address field of the frame (source mac address look up in the forwarding table failed.) on this bridge port. c) for the destination mac address found in the frame, the port the frame was received on does not appear as in port in the corresponding static table entry. Permission to receive frames from a mac address is granted via the static table entries. This attribute, badVerifyDiscards, is directly influenced by: 1. secureOption and 2. the static table entries. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgUnicastNoMatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgUnicastNoMatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgUnicastNoMatches.setDescription('This attribute is indicative of the number frames discarded because the MAC address found in the destination field did not match the local MAC address of the bridge port. This counter is only applicable for the protocols that are being routed currently.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgStaticEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgStaticEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStaticEntryDiscards.setDescription("This attribute is indicative of the number of frames that were discarded because of the following two reasons: a) there was no entry for the 'allowed to go' field in the static table entry, where the input port is this bridge port. b) for spanning tree bpdus that are locally processed. This counter wraps around its maximum value of 4294967295. It might prove useful to check the static table entry corresponding to the bridge port in question, if this counter consistently displays a high value. Ideally this counter should be as low as possible.")
mscVrPpTbsgDynamicEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgDynamicEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDynamicEntryDiscards.setDescription('This attribute is indicative of the number of incoming frames that a) were discarded because of the fact that the bridge port, the frame is to go out of matches the bridge port it came in from or b) if the stp port state of the out port is not forwarding. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgLearningDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgLearningDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgLearningDiscards.setDescription('This attribute is indicative of the number of frames that were discarded while this bridge port was in a state other than the forwarding state. While in learning state the frame is discarded after the information from its header is learnt. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgInDiscards.setDescription("This attribute is indicative of the number of frames that were received by this bridge port and were discarded by the forwarding process. This includes frames that could have been discarded due to filtering. A repidly increasing value for this attribute could indicate a shrtage of resource in terms of memory needed to process the incoming frames. More memory can be provisioned through the VirtualRouter's memory manager.")
mscVrPpTbsgInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgInFrames.setDescription('This attribute is indicative of the number of frames that have been received by this port from its segment. Note that a frame received on this bridge port is counted if and only if it can be processed by the bridge logic contained in this bridge unit, a protocol that can be processed by the bridge logic. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 17, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgOutFrames.setDescription('This attribute is indicative of the number of frames that have been transmitted out this bridge port. Note that frame transmitted out this bridge port is counted if and only if it is for a protocol being processed by the bridge unit. This also includes management frames.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18), )
if mibBuilder.loadTexts: mscVrPpTbsgStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpTbsgStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStpOperEntry.setDescription('An entry in the mscVrPpTbsgStpOperTable.')
mscVrPpTbsgStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpTbsgStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpTbsgDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpTbsgPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpTbsgDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpTbsgDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpTbsgForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpTbsgBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpTbsgStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 19), )
if mibBuilder.loadTexts: mscVrPpTbsgStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpTbsgStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpTbsgIndex"))
if mibBuilder.loadTexts: mscVrPpTbsgStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgStatsEntry.setDescription('An entry in the mscVrPpTbsgStatsTable.')
mscVrPpTbsgBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpTbsgTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpTbsgInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpTbsgOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 13, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpTbsgOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpTbsgOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrcl = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14))
mscVrPpSrclRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 1), )
if mibBuilder.loadTexts: mscVrPpSrclRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrcl components.')
mscVrPpSrclRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrcl component.')
mscVrPpSrclRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrcl components. These components can be added and deleted.')
mscVrPpSrclComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrclStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrcl tables.')
mscVrPpSrclIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrclIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclIndex.setDescription('This variable represents the index for the mscVrPpSrcl tables.')
mscVrPpSrclProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 10), )
if mibBuilder.loadTexts: mscVrPpSrclProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclProvTable.setDescription('This group houses all the provisionable attributes that belong to the this group. This group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes influence the working of a bridge port.')
mscVrPpSrclProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclProvEntry.setDescription('An entry in the mscVrPpSrclProvTable.')
mscVrPpSrclTranslateIpx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 0), ("ieee8023", 1), ("ethernet", 2), ("snap", 3), ("sap", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclTranslateIpx.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclTranslateIpx.setDescription('This attribute specifies the type of translation to be performed on frames carrying IPX packets. Ethernet frames carrying IPX payload could be translated to IEEE 802.3 frames (with the same IPX payload) or vice- versa. The main reason to do so is to allow the bridge unit to consistently forward one type of frames carrying IPX packets. Translations can be turned off altogether in which case the IPX frames will pass through the bridge unit unchanged.')
mscVrPpSrclFragmentIp = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclFragmentIp.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclFragmentIp.setDescription('This attribute specifies if or not outbound frames carrying IP datagrams should be fragmented to conform to message transfer unit (mtu) sizes dictated by the media.')
mscVrPpSrclServiceClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("ordered", 0), ("notOrdered", 1))).clone('notOrdered')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclServiceClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclServiceClass.setDescription('This attribute specifies if the frames should be ordered or not before they are transmitted through a bridge port. If this attribute has a value of ordered the received frames are ordered as in the original message, before they are transmitted out through a bridge port. If it has a value of notOrdered, received then frames pass through the bridge unit in the order they are received. This feature can be used over multiple telecommunication links to increase data flow. Please note that this attribute only affects link protocols and is ineffective with lan media.')
mscVrPpSrclConvertArpMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclConvertArpMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclConvertArpMacAddress.setDescription('This attribute is indicative of the state of the MAC address format conversion process for ARP/RARP frames. The MAC addresses may be translated if need be from a canonical format to a non-canonical format, based on the needs of the associated media. If this attribute is set to a value of on then all Mac addresses will converted if need be to suit the format of mac address, the outgoing media will support. If this attribute is set to a value of off no such conversion takes place.')
mscVrPpSrclPortNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclPortNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPortNum.setDescription('This attribute is indicative of the unique number assigned to the bridge port. It is used for SNMP management of this bridge port and in spanning tree as an identifier this bridge port. Notes regarding portNum: Escape routines exist for initializing, copying, and deleting port numbers. This is necessary because SNMP requires a unique port instance identifier. The initPortNum escape routine sets the port number to a value in the range 1-255 for this purpose. The setCopiedPortNum escape routine exists to maintain the uniqueness of the port number in cases when one port is copied to another. When a bridge port is deleted, the releasePortNum escape routine places the port number being released into a pending deletion state. This is because the port number cannot be re-allocated until the port is truely deleted in the current view. This is necessary since there is no guarantee of order when processing changes to multiple protocol ports so without the pending deletion state, the same port number could be temporarily assigned to two ports for a short period of time. The portNum is set as component critical since bridging also uses the port number as a key for indexing into its data structures. If a port is deleted then re-added under the same protocol port, CAS treats the change as a SET to the portNum attribute.')
mscVrPpSrclStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12), )
if mibBuilder.loadTexts: mscVrPpSrclStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStpProvTable.setDescription('This group houses all the port specific provisionable attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes influence the participation of the bridge port in the spanning tree protocol.')
mscVrPpSrclStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStpProvEntry.setDescription('An entry in the mscVrPpSrclStpProvTable.')
mscVrPpSrclAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclAdminStatus.setDescription('This attribute defines the current administrative state for this component. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation.')
mscVrPpSrclPortStateStpControl = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclPortStateStpControl.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPortStateStpControl.setDescription("This attribute specifies whether or not spanning tree protocol state for this bridge port is controlled by the spanning tree protocol. In essence it indicates the participation of this bridge port in the spanning tree protocol, by accepting and acting on received bridge protocol data units and by sending out the same. on signifies that this bridge port's spanning tree port state is controlled by the spanning tree protocol. A value of off signifies that the spanning tree port state of this bridge port is unaffected by the spanning tree protocol. This in effect puts the bridge port out of reach of the spanning tree protocol and in the forwarding state. Care should be taken while assigning a value of off to this attribute, as this might cause network loops. Please do not set this attribute to off unless you are absolutely sure about the effect of such an action on your network topology.")
mscVrPpSrclStpTypeProv = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3))).clone(namedValues=NamedValues(("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclStpTypeProv.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStpTypeProv.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol. If the value of the attribute protocolSpec in the SpanningTreeProtocol component, provisioned under the TransparentBridge component is in conflict with the value of this attribute, the value of the protocolSpec attribute will prevail. Prevailing stp type is reflected in the value of the attribute stpTypeOper.')
mscVrPpSrclPortPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclPortPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPortPriority.setDescription('This attribute specifies the value for port priority, which is contained in the first octet of the port identifier. Valid values are as follows: 1) 0..255 for stp type DEC and 2) 0..65535 for stp type IEEE.')
mscVrPpSrclPathCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPathCost.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. Please note that the value of the attribute pathCostMethod is applied only when the value of the attribute pathCostMethod is set to on and is ignored if otherwise.')
mscVrPpSrclPathCostMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 12, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclPathCostMethod.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPathCostMethod.setDescription('This attribute specifies the method used by the bridging logic, to calculate the path cost to the bridge considered to be the root bridge in the spanning tree topology. This attribute should be set to off before attempting to provision a value for pathCostProv.')
mscVrPpSrclDIProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 13), )
if mibBuilder.loadTexts: mscVrPpSrclDIProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDIProvTable.setDescription('This group houses all the provisionable, domain specific attributes for a non-encapsulating bridge port.')
mscVrPpSrclDIProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclDIProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDIProvEntry.setDescription('An entry in the mscVrPpSrclDIProvTable.')
mscVrPpSrclDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 13, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967293)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDomainNum.setDescription('This attribute specifies the domain number associated with this bridge port. Domain numbers are used for confining frames to a domain. Domain based filtering provides a complete segregation of traffic based on domain number associated with frames. There can exist only sixteen domains when a spanning tree is desired specific to each domain. When there is only a single spanning tree spanning all the domains the maximum number of domains possible are 4294967293. This attribute is of no relevance when associated with backbone bridge port. Its value is ignored in such a situation.')
mscVrPpSrclPreserveDomain = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("off", 0), ("on", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclPreserveDomain.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPreserveDomain.setDescription('This attribute specifies if the domain information should be preserved or embedded in the frame header. This attribute applies only to backbone ports and does not affect the access bridge ports. By setting this attribute to a value of on, domain information could be preserved in frames being tunnelled across the a backbone, so that this information can be deciphered at the other end of the backbone tunnel. This preserves the integrity of the domains thus preventing domain breaches while tunnelling frames across backbone network. If the value of this attribute is set to off then domain information is not preserved in the header of the frames tunnelling through the backbone. This eliminates the overhead incurred to preserve domain information across the backbone while tunnelling frames across it. Preserve domain is relevant when used in conjunction with the following media: FDDI, ATM MPE, Frame Relay and PPP. It is ignored when used with other types of media.')
mscVrPpSrclStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 14), )
if mibBuilder.loadTexts: mscVrPpSrclStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrPpSrclStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStateEntry.setDescription('An entry in the mscVrPpSrclStateTable.')
mscVrPpSrclAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrPpSrclOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrPpSrclUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrPpSrclOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 15), )
if mibBuilder.loadTexts: mscVrPpSrclOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrPpSrclOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclOperStatusEntry.setDescription('An entry in the mscVrPpSrclOperStatusTable.')
mscVrPpSrclSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrPpSrclOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16), )
if mibBuilder.loadTexts: mscVrPpSrclOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclOperTable.setDescription('This group houses all the operational attributes belonging to the base group. The base group of attributes is applicable to all types of bridge ports and represent the common factor between them. These attributes in part, reflect the state of a bridge port.')
mscVrPpSrclOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclOperEntry.setDescription('An entry in the mscVrPpSrclOperTable.')
mscVrPpSrclPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPortName.setDescription("The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrPpSrclUpTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclUpTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclUpTime.setDescription('This attribute specifies the accumulated up time of this bridge port since the last reset occurred.')
mscVrPpSrclDownTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDownTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDownTime.setDescription('This attribute specifies the accumulated down time of this bridge port since the last reset occurred.')
mscVrPpSrclBridgingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("tb", 2), ("sr", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclBridgingMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclBridgingMode.setDescription('This attribute specifies the mode of bridging this port can support. It in turn implies the format of frames, this bridge port can process and forward.')
mscVrPpSrclBridgePortConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclBridgePortConfig.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclBridgePortConfig.setDescription("This attribute specifies the bridge port's configuration. It indicates if the bridge port is operating as an access port or as a backbone port. An access bridge port does not encapsulate a MAC frame and does not preserve domain information in the encapsulation, whereas a backbone bridge port encapsulates the MAC frame and optionally preserves domain information in the encapsulated frame.A backbone bridge port is typically used to transport frames across a high bandwidth backbone network to another bridge unit for further processing/forwarding of the frame.")
mscVrPpSrclBridgePortType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernetBridgePort", 0), ("tokenRingBridgePort", 1), ("fddiBridgePort", 2), ("tokenBusBridgePort", 3), ("fddiEncapsulatingBridgePort", 4), ("vnsBridgePort", 5), ("frameRelayBridgePort", 6), ("pppBridgePort", 7), ("smdsBridgePort", 8), ("vcpBridgePort", 9), ("x25BridgePort", 10), ("srEncapSrBridgePort", 11), ("srEncapTbBridgePort", 12), ("sourceGateSrBridgePort", 13), ("sourceGateTbBridgePort", 14), ("srtbBridgePort", 15), ("tbsrBridgePort", 16), ("clusterSrBridgePort", 17), ("clusterTbBridgePort", 18), ("unknown", 19), ("atmMpeBridgePort", 20), ("snaDlrBridgePort", 21), ("lanEmulationClientEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclBridgePortType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclBridgePortType.setDescription('This attribute specifies the type of bridge port that was provisioned. It takes into consideration the bridgingMode, bridgePortConfig and the media the bridge port is linked to before branding a bridge port.')
mscVrPpSrclIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 8), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclIfIndex.setDescription('This attribute specifies the index into the Interface Table where in information about the media interface corresponding to the bridge port is maintained.')
mscVrPpSrclDelayExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDelayExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDelayExceededDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the time taken to process these frames exceeded the transit delay allowed for this bridge unit. This attribute is not supported by bridging and will always have a value of 0.')
mscVrPpSrclMtuExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 16, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclMtuExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclMtuExceededDiscards.setDescription('This attribute is indicative of the number of frames discarded because the size of the out bound frame exceeded the message transfer unit (mtu) allowed for the bridge port. Note that this counter only refers to the outbound frames for this bridge port. This counter wraps around its maximum value of 4294967295. This counter is influenced by the attribute fragmentIp. This counter is incremented when the a frame larger than the mtu allowed is encountered and cannot be fragmented. If this counter is increasing steadily, it might be useful to set the value of the attribute fragmentIp to a value of on.')
mscVrPpSrclStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18), )
if mibBuilder.loadTexts: mscVrPpSrclStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStpOperTable.setDescription("This group houses all the port specific operational attributes that belong to the Stp group. The Stp group is applicable to all the bridge ports that participate in the spanning tree protocol. These attributes reflect the state of the bridge port's participation in the spanning tree protocol.")
mscVrPpSrclStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStpOperEntry.setDescription('An entry in the mscVrPpSrclStpOperTable.')
mscVrPpSrclStpPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclStpPortState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStpPortState.setDescription('This attribute specifies the spanning tree protocol state of the bridge port.')
mscVrPpSrclStpTypeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 2, 3))).clone(namedValues=NamedValues(("none", 0), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclStpTypeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStpTypeOper.setDescription('This attribute specifies the type of spanning tree protocol the port is participating in. A bridge port could participate in either the ieee8021 spanning tree protocol or the dec spanning tree protocol.')
mscVrPpSrclDesignatedCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDesignatedCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDesignatedCost.setDescription('This attribute specifies the path cost of the designated port of the lan segment connected to the port.')
mscVrPpSrclPathCostOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclPathCostOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclPathCostOper.setDescription('This attribute specifies the contribution of this port, to all the paths to the root bridge that include this port. This attribute pathCostOper will track the value of the attribute pathCostProv when the value of the attribute pathCostMethod is set of off.')
mscVrPpSrclDesignatedBridge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDesignatedBridge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDesignatedBridge.setDescription('This attribute specifies the identifier of the bridge that this port considers to be the designated bridge.')
mscVrPpSrclDesignatedPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 7), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDesignatedPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDesignatedPort.setDescription('This attribute specifies the port identifier of the port on the designated bridge, attached to the same lan as this port is attached to.')
mscVrPpSrclForwardTransitions = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclForwardTransitions.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclForwardTransitions.setDescription('This attribute is indicative of the number of times this bridge port transitioned from the learning state to the forwarding state. This counter wraps around its maximum value of 4294967295. A rapidly increasing value might be indicative of an unstable spanning tree topology.')
mscVrPpSrclBlockingDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclBlockingDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclBlockingDiscards.setDescription('This attribute is indicative of the number of incoming frames that were discarded because the bridge port was in the blocking state. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrclDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 18, 1, 10), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDesignatedRoot.setDescription('This attribute specifies the bridge identifier of the bridge recorded as the root bridge, in the configuration BPDUs sent out by the designated bridge on the segment to which the port is attached.')
mscVrPpSrclStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 19), )
if mibBuilder.loadTexts: mscVrPpSrclStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStatsTable.setDescription('This group houses all the statistical attributes applicable to all types of bridge ports and represents the common factor between them. These attributes in part reflect the state of the bridge port.')
mscVrPpSrclStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 19, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStatsEntry.setDescription('An entry in the mscVrPpSrclStatsTable.')
mscVrPpSrclBadAbstractDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 19, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclBadAbstractDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclBadAbstractDiscards.setDescription('This attribute is indicative of the number of frames that were discarded because the data that was abstracted, from frames coming in through this bridge port, did not conform to the format expected by the bridge logic.This counter wraps around its maximum value of 4294967295.')
mscVrPpSrclTinygramFramesIn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 19, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclTinygramFramesIn.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclTinygramFramesIn.setDescription('This attribute is indicative of the number of frames received on this bridge port that used the tinygram compression scheme.')
mscVrPpSrclTinygramFramesOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 19, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclTinygramFramesOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclTinygramFramesOut.setDescription('This attribute is indicative of the number of frames transmitted out this bridge port that used the tinygram compression scheme.')
mscVrPpSrclInFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 19, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclInFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclInFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the in filter point. This includes a) frames discarded due to application of the filter defined with PCF for the in filter point and b) the frames discarded due to domain based filtering at the in filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrclOutFilterDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 19, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclOutFilterDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclOutFilterDiscards.setDescription('This attribute is indicative of the number of frames discarded at the out filter point. This includes: a) frames discarded due to application of the filter defined with PCF for the out filter point and b) the frames discarded due to domain based filtering at the out filter point. This counter wraps around its maximum value of 4294967295.')
mscVrPpSrclSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20), )
if mibBuilder.loadTexts: mscVrPpSrclSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSrProvTable.setDescription('This group contains all port specific, provisionable attributes associated with SourceRouteBridge ports.')
mscVrPpSrclSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSrProvEntry.setDescription('An entry in the mscVrPpSrclSrProvTable.')
mscVrPpSrclHopCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 7)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclHopCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclHopCount.setDescription('This attribute specifies the maximum number of hops allowed in Spanning Tree Explore and All Routes Explore frames. This value is one less than the maximum number of route descriptors allowed in a source route frame')
mscVrPpSrclExploreFrameTreatment = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("encap", 0), ("xlate", 1))).clone('encap')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclExploreFrameTreatment.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclExploreFrameTreatment.setDescription('This attribute specifies whether or not explore frames received from SourceRouteBridge ports will be sent to the SRTB-8209 translation or the encapsulated SourceRouteBridge logic. This option is used only when both the TbsrBridgePort and the SrtbBridgePort are provisioned and enabled. A value of Xlate implies that the explore frames will be sent to the Srtb translation logic and a value of Encap implies that the frames will be sent to the Encapsulated source route bridging logic.')
mscVrPpSrclLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclLanId.setDescription('This attribute specifies the identifier for the physical LAN that this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrclInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclInternalLanId.setDescription('This attribute specifies the identifier for the internal logical LAN this port is attached. All SourceRouteBridge ports are assigned to a physical LAN and a logical internal LAN. Current source route bridge implementations limit the lanId to a value in the range 0 to 4095.')
mscVrPpSrclBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclBridgeNum.setDescription('This attribute specifies the value that is used to identify this bridge when more than one bridge is used to span the same two LAN segments.')
mscVrPpSrclLargestFrame = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 6), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(516, 516), ValueRangeConstraint(1470, 1470), ValueRangeConstraint(2052, 2052), ValueRangeConstraint(4399, 4399), ValueRangeConstraint(8130, 8130), ValueRangeConstraint(11407, 11407), ValueRangeConstraint(17749, 17749), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclLargestFrame.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclLargestFrame.setDescription('This attribute specifies the maximum frame size (LLC and above) in octets, allowed by this SourceRouteBridge port. This field is used to determine whether a modification of the largest frame field of the routing control field of the routing information field is warranted.')
mscVrPpSrclSteSpanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("autoSpan", 1), ("disabled", 2), ("forced", 3))).clone('autoSpan')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclSteSpanMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSteSpanMode.setDescription('This attribute determines how this bridge port will react when presented with a Spanning Tree Explore frame. If disabled, the Spanning Tree Explore frame is discarded regardless of the value of stpPortState. If the value of this attribute is forced, the Spanning Tree Explore frame is forwarded regardless of the value of stpPortState. autoSpan uses the stpPortState value to decide whether or not Spanning Tree Explore frames should be forwarded out this bridge port. If the port is in the forwarding state, the frame is received and transmitted otherwise the frame is discarded.')
mscVrPpSrclAreRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclAreRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclAreRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in an All Routes Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the areRdLimit to a value in the range 0 to 8.')
mscVrPpSrclSteRdLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 20, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 8)).clone(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclSteRdLimit.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSteRdLimit.setDescription('This attribute specifies the number of route descriptors allowed in a Spanning Tree Explore frame received on a SourceRouteBridgePort or SourceRouteTransparentBridgePort. Current source route bridge implementations limit the steRdLimit to a value in the range 0 to 8.')
mscVrPpSrclSrStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21), )
if mibBuilder.loadTexts: mscVrPpSrclSrStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSrStatsTable.setDescription('This group contains all port specific statistical attributes associated with SourceRouteBridge ports.')
mscVrPpSrclSrStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"))
if mibBuilder.loadTexts: mscVrPpSrclSrStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSrStatsEntry.setDescription('An entry in the mscVrPpSrclSrStatsTable.')
mscVrPpSrclSpecInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclSpecInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSpecInFrames.setDescription('This attribute specifies the number of specifically routed frames that were received by this bridge port. A specifically routed frame has a route descriptor, constructed by the originating host which details an explicit route to the destination host. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclSpecOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclSpecOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSpecOutFrames.setDescription('This attribute specifies the number of specifically routed frames that were transmitted from this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclApeInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclApeInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclApeInFrames.setDescription("This attribute specifies the number of All Path Explore frames received on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpStates. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrclApeOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclApeOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclApeOutFrames.setDescription("This attribute specifies the number of All Path Explore frames transmitted on this bridge port. The All Path Explore frames are forwarded to all SourceRouteBridge ports assigned to this bridge regardless of the port's portStpState state. This counter will wrap to zero when it exceeds its maximum.")
mscVrPpSrclSteInFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclSteInFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSteInFrames.setDescription('This attribute specifies the number of Spanning Tree Explore frames received on this bridge port. The Spanning Tree Explore frames are only forwarded through bridge ports whose portStpState has a value of forwarding. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclSteOutFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclSteOutFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSteOutFrames.setDescription('This attribute specifies the number of Spanning Tree Frames transmitted on this bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclSegmentMismatchDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclSegmentMismatchDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclSegmentMismatchDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames that were discarded due to an invalid next segment value in the routing information field. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclDupSegmentDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDupSegmentDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDupSegmentDiscards.setDescription('This attribute specifies the number of frames discarded due to the presence of a duplicate segment identifier in the route descriptor field which may indicate a loop in the network topology. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclHopCountExceededDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclHopCountExceededDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclHopCountExceededDiscards.setDescription('This attribute specifies the number of All Routes Explore and Spanning Tree Explore frames discarded by this bridge port due to a frame exceeding the maximum size allowed for a route descriptor length. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclDupLanIdOrTreeErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDupLanIdOrTreeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDupLanIdOrTreeErrors.setDescription('This attribute specifies the number frames received which contain duplicate LAN IDs or Tree errors. This attribute is helpful in debugging problems in networks which contain older IBM-SR bridges. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclLanIdMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclLanIdMismatches.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclLanIdMismatches.setDescription('This attributes counts the number of All Routes Explore or Spanning Tree Explore frames that were discarded because the last LAN ID in the routing information field did not equal the LAN ID. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclStaticDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclStaticDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclStaticDiscards.setDescription('This attribute is indicative of the number of explorer frames discarded due to fact that the outbound SourceRouteBridge port was disabled or deleted. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclDynamicDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 21, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclDynamicDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclDynamicDiscards.setDescription('This attribute specifies the number of frames discarded due to receiving a frame with a target LAN ID which did not match the internal LAN ID of the receiving bridge port. This counter will wrap to zero when it exceeds its maximum.')
mscVrPpSrclNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2))
mscVrPpSrclNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 1), )
if mibBuilder.loadTexts: mscVrPpSrclNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrPpSrclNs components.')
mscVrPpSrclNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclNsIndex"))
if mibBuilder.loadTexts: mscVrPpSrclNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrPpSrclNs component.')
mscVrPpSrclNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrPpSrclNs components. These components can be added and deleted.')
mscVrPpSrclNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrPpSrclNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrPpSrclNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsStorageType.setDescription('This variable represents the storage type value for the mscVrPpSrclNs tables.')
mscVrPpSrclNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrPpSrclNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsIndex.setDescription('This variable represents the index for the mscVrPpSrclNs tables.')
mscVrPpSrclNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 10), )
if mibBuilder.loadTexts: mscVrPpSrclNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsProvTable.setDescription('This group houses all the port specific provisionable attributes associated with Ns. These attributes influence the application of filters to incoming and outgoing frames.')
mscVrPpSrclNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrPpIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrPpSrclNsIndex"))
if mibBuilder.loadTexts: mscVrPpSrclNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsProvEntry.setDescription('An entry in the mscVrPpSrclNsProvTable.')
mscVrPpSrclNsIncomingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclNsIncomingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsIncomingFilter.setDescription('This attribute specifies the name of the filter to be applied at the incoming filter point.')
mscVrPpSrclNsOutgoingFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 3, 14, 2, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrPpSrclNsOutgoingFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrPpSrclNsOutgoingFilter.setDescription('This attribute specifies the name of the filter to be applied at the out going filter point.')
mscVrBr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5))
mscVrBrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 1), )
if mibBuilder.loadTexts: mscVrBrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBr components.')
mscVrBrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"))
if mibBuilder.loadTexts: mscVrBrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBr component.')
mscVrBrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBr components. These components can be added and deleted.')
mscVrBrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrStorageType.setDescription('This variable represents the storage type value for the mscVrBr tables.')
mscVrBrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrBrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrIndex.setDescription('This variable represents the index for the mscVrBr tables.')
mscVrBrAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 10), )
if mibBuilder.loadTexts: mscVrBrAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscVrBrAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"))
if mibBuilder.loadTexts: mscVrBrAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrAdminControlEntry.setDescription('An entry in the mscVrBrAdminControlTable.')
mscVrBrAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrAdminStatus.setDescription('This attribute defines the current administrative status for thiscomponent. enabled indicates that the component is available for operation. disabled indicates the component is unavailable for operation. The application preserves all previously received provisioning data, all writable operational data and all counters. Please note that all learnt data are lost. The bridge application is not available for operation while in this state.')
mscVrBrStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 12), )
if mibBuilder.loadTexts: mscVrBrStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscVrBrStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"))
if mibBuilder.loadTexts: mscVrBrStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrStateEntry.setDescription('An entry in the mscVrBrStateTable.')
mscVrBrAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscVrBrOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscVrBrUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscVrBrOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 13), )
if mibBuilder.loadTexts: mscVrBrOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscVrBrOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"))
if mibBuilder.loadTexts: mscVrBrOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrOperStatusEntry.setDescription('An entry in the mscVrBrOperStatusTable.')
mscVrBrSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscVrBrOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 14), )
if mibBuilder.loadTexts: mscVrBrOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrOperTable.setDescription('This group houses all the operational attributes applicable to bridging, those components that are global in nature and are not port specific.')
mscVrBrOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"))
if mibBuilder.loadTexts: mscVrBrOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrOperEntry.setDescription('An entry in the mscVrBrOperTable.')
mscVrBrBridgeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 14, 1, 1), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrBridgeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrBridgeAddress.setDescription('This attribute represents the Mac address for the bridge. This address is used when this bridge must be referred to in a unique manner. It is used to form the bridge identifier, used by the spanning tree protocol, by concatenating it with the attribute bridgePriority under the component SpanningTreeProtocol.')
mscVrBrNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 14, 1, 2), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrNumPorts.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNumPorts.setDescription('This attribute is indicative of the number of ports this bridge controls. In other words, it is a count of the number of bridge ports provisioned.')
mscVrBrType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("unknown", 1), ("transparentOnly", 2), ("sourceRouteOnly", 3), ("srt", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrType.setDescription('This attribute is indicative of the capability of this bridge unit in terms of types of bridging it can handle.')
mscVrBrPte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2))
mscVrBrPteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1), )
if mibBuilder.loadTexts: mscVrBrPteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrBrPte components.')
mscVrBrPteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPteDomainNumIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPtePortNameIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPteModeIndex"))
if mibBuilder.loadTexts: mscVrBrPteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrPte component.')
mscVrBrPteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrPte components. These components cannot be added nor deleted.')
mscVrBrPteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrPteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteStorageType.setDescription('This variable represents the storage type value for the mscVrBrPte tables.')
mscVrBrPteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: mscVrBrPteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteDomainNumIndex.setDescription('This variable represents an index for the mscVrBrPte tables.')
mscVrBrPtePortNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1, 1, 11), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(0, 29)))
if mibBuilder.loadTexts: mscVrBrPtePortNameIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPtePortNameIndex.setDescription('This variable represents an index for the mscVrBrPte tables.')
mscVrBrPteModeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 3, 4))).clone(namedValues=NamedValues(("tb", 2), ("sr", 3), ("srt", 4))))
if mibBuilder.loadTexts: mscVrBrPteModeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteModeIndex.setDescription('This variable represents an index for the mscVrBrPte tables.')
mscVrBrPteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 10), )
if mibBuilder.loadTexts: mscVrBrPteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the operational attributes belonging to the PortTableEntry component.')
mscVrBrPteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPteDomainNumIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPtePortNameIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPteModeIndex"))
if mibBuilder.loadTexts: mscVrBrPteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteOperEntry.setDescription('An entry in the mscVrBrPteOperTable.')
mscVrBrPteMacType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))).clone(namedValues=NamedValues(("ethernet", 0), ("tokenRing", 1), ("fddiBridgePort", 2), ("tokenBus", 3), ("fddiEncapsulating", 4), ("vns", 5), ("frameRelay", 6), ("ppp", 7), ("smds", 8), ("vcp", 9), ("x25", 10), ("srEncapSr", 11), ("srEncapTb", 12), ("sourceGateSr", 13), ("sourceGateTb", 14), ("srtb", 15), ("tbsr", 16), ("clusterSr", 17), ("clusterTb", 18), ("unknown", 19), ("atmMpe", 20), ("snaDlr", 21), ("lecEthernet", 22)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteMacType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteMacType.setDescription('This attribute is indicative of the Mac type of the bridge port is associated with.')
mscVrBrPteStpState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("disabled", 1), ("blocking", 2), ("listening", 3), ("learning", 4), ("forwarding", 5), ("broken", 6))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteStpState.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteStpState.setDescription('This attribute is indicative of the stp state of the bridge port.')
mscVrBrPteStpType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("unknown", 1), ("dec", 2), ("ieee8021", 3))).clone('ieee8021')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteStpType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteStpType.setDescription('This attribute specifies the type of the spanning tree protocol this bridge port is participating in.')
mscVrBrPteFilterPoints = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("inOut", 3), ("none", 4))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteFilterPoints.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteFilterPoints.setDescription('This attribute in indicative of the points where filtering is active currently.')
mscVrBrPtePortPointsTo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("rootBridge", 2), ("designatedBridge", 3))).clone('none')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPtePortPointsTo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPtePortPointsTo.setDescription('This attribute in indicative of the fact if this bridge port leads to the root bridge of the spanning tree topology or if leads to the designated bridge of the lan segment the bridge port is attached to.')
mscVrBrPteSpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 11), )
if mibBuilder.loadTexts: mscVrBrPteSpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteSpOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all the attributes associated with the source route portion of the port table.')
mscVrBrPteSpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPteDomainNumIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPtePortNameIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrPteModeIndex"))
if mibBuilder.loadTexts: mscVrBrPteSpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteSpOperEntry.setDescription('An entry in the mscVrBrPteSpOperTable.')
mscVrBrPteLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 11, 1, 1), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4095), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteLanId.setDescription('This attribute identifies the lan identifier the bridge port is attached to. LAN ID is a part of the route descriptor used when source route bridging. Note that the value 0 is used by some applications for special test cases and the value 65535 signifies that no lanId is assigned to this port.')
mscVrBrPteInternalLanId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4095), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteInternalLanId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteInternalLanId.setDescription('This attribute contains the internal or logical LAN to which a port is attached. All source bridge ports have an associated physical LAN segment and logical internal LAN segment. Note that the value 0 is used by some applications for special test cases and the value 65535 signifies that no internalLanId is assigned to this port.')
mscVrBrPteBridgeNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 15), ValueRangeConstraint(65535, 65535), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrPteBridgeNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrPteBridgeNum.setDescription('This attribute specifies the number assigned to the bridge associated with this LAN ID table entry. The bridge number is a part of the route descriptor of a source routed frame. Note that the value 0 is used by some applications for special test cases and the value 65535 signifies that no bridgeNum is assigned to this port.')
mscVrBrNs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3))
mscVrBrNsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 1), )
if mibBuilder.loadTexts: mscVrBrNsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBrNs components.')
mscVrBrNsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrNsIndex"))
if mibBuilder.loadTexts: mscVrBrNsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrNs component.')
mscVrBrNsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrNs components. These components can be added and deleted.')
mscVrBrNsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrNsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrNsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrNsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsStorageType.setDescription('This variable represents the storage type value for the mscVrBrNs tables.')
mscVrBrNsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrBrNsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsIndex.setDescription('This variable represents the index for the mscVrBrNs tables.')
mscVrBrNsProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 10), )
if mibBuilder.loadTexts: mscVrBrNsProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsProvTable.setDescription('This group houses all the provisionable attributes applicable to the packet control facility. These attributes are global attributes and are not port specific.')
mscVrBrNsProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrNsIndex"))
if mibBuilder.loadTexts: mscVrBrNsProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsProvEntry.setDescription('An entry in the mscVrBrNsProvTable.')
mscVrBrNsFirstFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsFirstFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsFirstFilter.setDescription('This attribute specifies the name of the filter to be applied at the first filter point.')
mscVrBrNsLastFilter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 10, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsLastFilter.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsLastFilter.setDescription('This attribute specifies the name of the filter that is to be applied at the last filter point.')
mscVrBrNsAte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2))
mscVrBrNsAteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 1), )
if mibBuilder.loadTexts: mscVrBrNsAteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBrNsAte components.')
mscVrBrNsAteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrNsIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrNsAteEntryNumberIndex"))
if mibBuilder.loadTexts: mscVrBrNsAteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrNsAte component.')
mscVrBrNsAteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrNsAte components. These components can be added and deleted.')
mscVrBrNsAteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrNsAteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrNsAteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrNsAteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteStorageType.setDescription('This variable represents the storage type value for the mscVrBrNsAte tables.')
mscVrBrNsAteEntryNumberIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: mscVrBrNsAteEntryNumberIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteEntryNumberIndex.setDescription('This variable represents the index for the mscVrBrNsAte tables.')
mscVrBrNsAteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10), )
if mibBuilder.loadTexts: mscVrBrNsAteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteProvTable.setDescription('This group houses all the attributes that together form an apply table entry. These fields of an apply table entry are used as match criteria, which when satisfied results in the application of the named filter to the frame.')
mscVrBrNsAteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrNsIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrNsAteEntryNumberIndex"))
if mibBuilder.loadTexts: mscVrBrNsAteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteProvEntry.setDescription('An entry in the mscVrBrNsAteProvTable.')
mscVrBrNsAteDomainNum = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967293))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteDomainNum.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteDomainNum.setDescription('This attribute specifies the domain number associated with a frame, that would qualify it partly, for a match in the apply table. The domain number provisioned will form a part of the match criteria only if it is not provisioned with a wild card value of 0. If the wild card character is specified, any domain number will satisfy the match criteria, in effect loosing domain number as a qualifier in the match criteria.')
mscVrBrNsAteFirstMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1, 2), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteFirstMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteFirstMacAddress.setDescription('This attribute specifies the MAC address to be anded with the firstMACAddressMask, and the result compared with- a) The source MAC address in a frame when the attribute direction has a value of to, b) The destination MAC address in a frame when the attribute direction has a value of from, c) Source / Destination address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
mscVrBrNsAteFirstMacAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1, 3), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="ffffffffffff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteFirstMacAddressMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteFirstMacAddressMask.setDescription('This attribute specifies the mask which is anded with the attribute firstMACAddress. The result is then compared with- a) The source MAC address in a frame when the attribute direction has a value of to, b) The destination MAC address in a frame when the attribute direction has a value of from, c) Source / Destination address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
mscVrBrNsAteSecondMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1, 4), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteSecondMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteSecondMacAddress.setDescription('This attribute specifies the MAC address to be anded with the secondMACAddressMask, and the result compared with- a) The destination MAC address in a frame when the attribute direction has a value of to, b) The source MAC address in a frame when the attribute direction has a value of from, c) Destination/Source address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
mscVrBrNsAteSecondMacAddressMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1, 5), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6).clone(hexValue="ffffffffffff")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteSecondMacAddressMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteSecondMacAddressMask.setDescription('This attribute specifies the mask which is anded with the attribute secondMACAddress. The result is then compared with- a) The destination MAC address in a frame when the attribute direction has a value of to, b) The source MAC address in a frame when the attribute direction has a value of from, c) Destination/Source address in a frame when the attribute direction has a value of toFrom, as a part of finding a match in the bridge filter apply table.')
mscVrBrNsAteDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("to", 0), ("from", 1), ("toFrom", 2))).clone('toFrom')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteDirection.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteDirection.setDescription('This attribute specifies the direction of frame flow. It is used to appropriately compare the result of logically anding MAC address, MACAddressMask pairs, with the source /destination MAC address fields in a frame, as a part of the match finding process. When this attribute has value of to, the firstMACAddress is logically anded with the firstMACAddressMask and the result compared with the source MAC address in a frame and the secondMACAddress logically anded with the secondMACAddressMask and compared with the destination MAC address. When this attribute has a value of from, the firstMACAddress is logically anded with the firstMACAddressMask and the result compared with the destinationMAC address in a frame and the secondMACAddress logically anded with the secondMACAddressMask and compared with the sourceMAC addressin the frame, as a part of finding a match in the bridge filter apply table entry.')
mscVrBrNsAteFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 3, 2, 10, 1, 7), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrNsAteFilterName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrNsAteFilterName.setDescription('This attribute specifies the name of the filter to be applied to the frame, if it satisfies the match criteria mentioned in the bridge filter apply table entry.')
mscVrBrTb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4))
mscVrBrTbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 1), )
if mibBuilder.loadTexts: mscVrBrTbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBrTb components.')
mscVrBrTbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"))
if mibBuilder.loadTexts: mscVrBrTbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrTb component.')
mscVrBrTbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrTb components. These components can be added and deleted.')
mscVrBrTbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrTbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStorageType.setDescription('This variable represents the storage type value for the mscVrBrTb tables.')
mscVrBrTbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrBrTbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbIndex.setDescription('This variable represents the index for the mscVrBrTb tables.')
mscVrBrTbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 10), )
if mibBuilder.loadTexts: mscVrBrTbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbProvTable.setDescription('This group houses all the provisionable attributes applicable to a transparent bridge, those attributes that are global and are not port specific.')
mscVrBrTbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"))
if mibBuilder.loadTexts: mscVrBrTbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbProvEntry.setDescription('An entry in the mscVrBrTbProvTable.')
mscVrBrTbFwdTableNumEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbFwdTableNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFwdTableNumEntries.setDescription('This attribute specifies the number of entries that can exist in the transparent bridge forwarding table. This attribute provides a way to control the resources allocated to forwarding table. This attribute will prove to be very useful while attempting to fine tune the resource allocated to the various types of tables to suit the network configuration. Please understand that this attribute tbFwdTableNumEntries is influenced by the memory management scheme provided by the VirtualRouter and is by no means independent of the same. It is important to understand the network configuration in terms of number and types of bridge ports provisioned before attempting to fine tune this attribute.The following attributes can be used as feedback to fine tune this attribute: a) attribute totalForwardingTableEntries under the TransparentBridge component, b) attribute numFtEntriesFree under the TransparentBridge component, c) attribute numFtEntriesDenied under the TransparentBridge component')
mscVrBrTbAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbAgingTime.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time can change, triggered by a spanning tree topology change. The operational value of the aging time is reflected in the attribute agingTimeOper under the SpanningTreeProtocol component.')
mscVrBrTbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 11), )
if mibBuilder.loadTexts: mscVrBrTbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStatsTable.setDescription('This group houses all the statistical attributes for a transparent bridge, those attributes that are global in nature and are not port specific.')
mscVrBrTbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"))
if mibBuilder.loadTexts: mscVrBrTbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStatsEntry.setDescription('An entry in the mscVrBrTbStatsTable.')
mscVrBrTbLearnedEntryDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbLearnedEntryDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbLearnedEntryDiscards.setDescription('This attribute represents the number of entries that might have been learned but have been discarded due to lack of space to store them in the forwarding table. This counter is not supported currently by the bridging platform and will always return a value of 0 in response to any queries.')
mscVrBrTbTotalForwardingTableEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbTotalForwardingTableEntries.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbTotalForwardingTableEntries.setDescription('This attribute specifies the total number of TB forwarding table entries. This includes static forwarding table entries and dynamic forwarding table entries. This attribute is influenced by the attribute tbFwdTableNumEntries, which is a provisionable attribute. If the value is consistently approaching the value of the attribute tbFwdTableNumEntries, it is advisable to increase the value provisioned for tbFwdTableNumEntries. It indicates a potential shortage of forwarding table entries in the future. This attribute is inversely proportional in value to the attribute numFtEntriesFree. This counter wraps around its maximum value of 4294967295.')
mscVrBrTbNumFtEntriesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 11, 1, 3), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNumFtEntriesFree.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNumFtEntriesFree.setDescription('This attribute is indicative of the number of TB forwarding table entries free. These entries could be used by static entries or by dynamic entries. This counter wraps around its maximum value of 4294967295. A consistently high value for this attribute indicates that there is a resource surplus here, in terms of the memory requirements of the forwarding table. This surplus could be utilized elsewhere if need be. The value of this attributes directly influenced by the value of the attribute tbFwdTableNumEntries.')
mscVrBrTbNumFtEntriesDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNumFtEntriesDenied.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNumFtEntriesDenied.setDescription('This attribute is indicative of the number of instances wherein TB table entry was unavailable. These entries could have been denied for static entries or for dynamic entries. This counter wraps around its maximum value of 4294967295. If this counter consistently shows a high value, it is indicative of a resource shortage in terms of memory required to support the increase in the number of forwarding table entries. To rectify this resource shortage, increase the number of forwarding table entries through the provisioned attribute tbFwdTableEntries under the Bridge component. This counter should ideally be as low as possible.')
mscVrBrTbStp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2))
mscVrBrTbStpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 1), )
if mibBuilder.loadTexts: mscVrBrTbStpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBrTbStp components.')
mscVrBrTbStpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbStpIndex"))
if mibBuilder.loadTexts: mscVrBrTbStpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrTbStp component.')
mscVrBrTbStpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbStpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrTbStp components. These components can be added and deleted.')
mscVrBrTbStpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrTbStpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpStorageType.setDescription('This variable represents the storage type value for the mscVrBrTbStp tables.')
mscVrBrTbStpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: mscVrBrTbStpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpIndex.setDescription('This variable represents the index for the mscVrBrTbStp tables.')
mscVrBrTbStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10), )
if mibBuilder.loadTexts: mscVrBrTbStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpProvTable.setDescription('This group houses all the provisionable attributes that are applicable to the spanning tree protocol. These are global attributes and not port specific attributes. These attributes have a direct impact on the way this bridge participates in the spanning tree protocol.')
mscVrBrTbStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbStpIndex"))
if mibBuilder.loadTexts: mscVrBrTbStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpProvEntry.setDescription('An entry in the mscVrBrTbStpProvTable.')
mscVrBrTbStpStpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2))).clone('access')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbStpStpMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpStpMode.setDescription('This attribute determines if this stp instance is to act as the stp instance for the backbone or an stp instance for a non-backbone media configuration. There can exist only one Backbone stp instance per virtual router. If the attribute domainStpTbState is set to a value on and Backbone bridge ports have been provisioned, there should exist a Backbone stp instance. Please note that it is not permissible to assign the instance identifier of this stp instance as domain number of any access bridge port. In case of stp instances that are non-Backbone, the instance identifier is indicative of the domain number the stp is operational in.')
mscVrBrTbStpProtocolSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("dec", 2), ("ieee8021d", 3))).clone('ieee8021d')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbStpProtocolSpec.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpProtocolSpec.setDescription('This attribute specifies the type of spanning tree protocols that are in operation in the bridge. This means that this bridge participates in the types spanning tree protocol indicated by this attribute.')
mscVrBrTbStpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbStpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpPriority.setDescription('This attribute is used to construct the bridgeId. It forms the first two octets of the bridgeId and the remaining 6 octets are made up of the bridgeMACAddress. The priority also determines the root bridge of the spanning tree topology. Manipulating this attribute might lead to a change in the spanning tree topology.')
mscVrBrTbStpBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbStpBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpBridgeMaxAge.setDescription('The maximum age of spanning tree protocol information learned from the network on any bridge port before it is discarded. This value is used by this bridge and all the other bridges, when this bridge is the root bridge of the spanning tree topology. The following relationships are enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0seconds) >= bridgeMaxAge, bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds. DESCRIPTION')
mscVrBrTbStpBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbStpBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpBridgeHelloTime.setDescription('This attribute specifies the time interval between the transmission of configuration BPDUs on any bridge port when this bridge becomes the root bridge. This attribute value is also used by all the other bridges in the Spanning Tree while this bridge is the root. The following relationship is enforced as required by the IEEE 802.1d standards document. bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds.')
mscVrBrTbStpBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbStpBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpBridgeForwardDelay.setDescription('This attribute specifies how fast a bridge port changes its STP state while progressing towards the forwarding state. It is also used as agingTime to age dynamic entries in the forwarding table once a topology change is detected. This attribute is used by all the bridges participating in the spanning tree protocol, when this bridge is the root bridge. The following relationship is enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0sconds) >= bridgeMaxAge.')
mscVrBrTbStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11), )
if mibBuilder.loadTexts: mscVrBrTbStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpOperTable.setDescription('This group houses all the operational, spanning tree protocol attributes. These attributes are applicable in a global manner and are not specific to a bridge port.')
mscVrBrTbStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbStpIndex"))
if mibBuilder.loadTexts: mscVrBrTbStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpOperEntry.setDescription('An entry in the mscVrBrTbStpOperTable.')
mscVrBrTbStpBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 1), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpBridgeId.setDescription('This attribute specifies the identifier value of this bridge, which serves to uniquely represent this bridge in the spanning tree topology. Thus, a bridgeId is unique only in the spanning tree instance the bridge in participating in. If multiple domain spanning trees exist then the same bridgeId can be re-used across these spanning tree instances.')
mscVrBrTbStpRootPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpRootPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpRootPortName.setDescription("This attribute specifies the name of the bridge port that offers the lowest cost route to the root bridge of the spanning tree topology.The attribute rootPortName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport. If multiple instances of spanning tree are operational, then there will exist a rootPortName value for each instance of the spanning tree running, and is applicable to that instance alone.")
mscVrBrTbStpTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpTimeSinceTopologyChange.setDescription('This attribute specifies the time since a spanning tree topology change was detected by this bridge.')
mscVrBrTbStpTopologyChangeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpTopologyChangeDetect.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpTopologyChangeDetect.setDescription('This attribute specifies whether or not a topology change was detected. This flag is set when a bpdu with the topology detect flag set is received from the root bridge. If this bridge is the root bridge this flag is set on receipt of a topology change notification bpdu. It is reset after a fixed length of time.')
mscVrBrTbStpTopologyChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpTopologyChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpTopologyChanges.setDescription('This attribute is indicative of the number of topology changes detected by this bridge since the last bridge reset. This counter wraps around its maximum value of 4294967295.')
mscVrBrTbStpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpDesignatedRoot.setDescription('This attribute specifies the identifier of the bridge that this bridge treats as the root of the spanning tree topology. The root of the spanning tree topology is chosen through exchange.')
mscVrBrTbStpRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpRootCost.setDescription('This attribute specifies the cost of the path to the root as seen by this bridge.')
mscVrBrTbStpMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpMaxAge.setDescription('This attribute specifies the maximum age of the spanning tree protocol info learnt from a port, before it is discarded.')
mscVrBrTbStpAgingTimeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpAgingTimeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpAgingTimeOper.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time is specific to a spanning tree protocol instance running. A value for the aging time of the current instance of the spanning tree protocol can be provisioned through the attribute agingTime under the InwBrTb component. The agingTimeOper attribute assumes the value of the bridgeForwardDelay while a topology change is in progress. This is done to facilitate quick aging out of the learned entries that might have become obsolete due to a spanning tree topology change.')
mscVrBrTbStpHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpHelloTime.setDescription('This attribute specifies the time interval between the transmission of the configuration BPDUs. This value is obtained from the root bridge of the spanning tree topology, through bridge protocol data units. This value should be the value assigned to the attribute bridgeHelloTime of the root bridge.')
mscVrBrTbStpHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 100)).clone(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpHoldTime.setDescription('This attribute specifies the interval of time which no more than two BPDUs should be sent.')
mscVrBrTbStpFwdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 2, 11, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbStpFwdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbStpFwdDelay.setDescription('This attribute specifies how much time a port spends in any state while progressing towards the forwarding state. It is also used to age out learned entries while a topology change is in progress.This value should be the value assigned to the attribute bridgefwdDelay of the root bridge.')
mscVrBrTbSte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3))
mscVrBrTbSteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 1), )
if mibBuilder.loadTexts: mscVrBrTbSteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBrTbSte components.')
mscVrBrTbSteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbSteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbSteReceivePortIndex"))
if mibBuilder.loadTexts: mscVrBrTbSteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrTbSte component.')
mscVrBrTbSteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbSteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrTbSte components. These components can be added and deleted.')
mscVrBrTbSteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbSteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrTbSteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbSteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteStorageType.setDescription('This variable represents the storage type value for the mscVrBrTbSte tables.')
mscVrBrTbSteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: mscVrBrTbSteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteAddressIndex.setDescription('This variable represents an index for the mscVrBrTbSte tables.')
mscVrBrTbSteReceivePortIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 1, 1, 11), AsciiStringIndex().subtype(subtypeSpec=ValueSizeConstraint(1, 29)))
if mibBuilder.loadTexts: mscVrBrTbSteReceivePortIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteReceivePortIndex.setDescription('This variable represents an index for the mscVrBrTbSte tables.')
mscVrBrTbSteProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 10), )
if mibBuilder.loadTexts: mscVrBrTbSteProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteProvTable.setDescription('This group houses all the fields of a static table entry. All these attributes can be provisioned by the user. Multiple such static table entries together form the static forwarding table.')
mscVrBrTbSteProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbSteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbSteReceivePortIndex"))
if mibBuilder.loadTexts: mscVrBrTbSteProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteProvEntry.setDescription('An entry in the mscVrBrTbSteProvTable.')
mscVrBrTbSteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("permanent", 3))).clone('permanent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbSteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteStatus.setDescription('This attribute specifies the longevity of an entry in the static table. Please note that currently only a value of permanent is supported.')
mscVrBrTbSteAtgtTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 271), )
if mibBuilder.loadTexts: mscVrBrTbSteAtgtTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteAtgtTable.setDescription("This port map specifies the out bridge ports a MAC frame with address in its destination MAC address field, originating from receivePort, can go out of. The allowedToGoTo attribute is a set of strings where in each string is of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding TB or SRT bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. Multiple strings can be specified on the same set command. Each string in the list is space separated. An '*' in place of the i indicates that regardless of the protocol port instance, all bridge ports with name BridgePortName should be included in the allowedToGoTo. In cases where there are multiple bridge ports provisioned under a protocol port, (e.g. pseudo bridge ports) each bridge port name must be specified in the form of strings, as indicated above. Please note that this attribute allowedToGoTo cannot contain any of the following bridge ports in part: SrBP, Srtb, Srsg, Tbsg, Srse, Srcl, FddiESr.")
mscVrBrTbSteAtgtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 271, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbSteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbSteReceivePortIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbSteAtgtValue"))
if mibBuilder.loadTexts: mscVrBrTbSteAtgtEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteAtgtEntry.setDescription('An entry in the mscVrBrTbSteAtgtTable.')
mscVrBrTbSteAtgtValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 271, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrTbSteAtgtValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteAtgtValue.setDescription('This variable represents both the value and the index for the mscVrBrTbSteAtgtTable.')
mscVrBrTbSteAtgtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 3, 271, 1, 2), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscVrBrTbSteAtgtRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbSteAtgtRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscVrBrTbSteAtgtTable.')
mscVrBrTbFte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4))
mscVrBrTbFteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 1), )
if mibBuilder.loadTexts: mscVrBrTbFteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrBrTbFte components.')
mscVrBrTbFteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbFteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbFteDomainNumIndex"))
if mibBuilder.loadTexts: mscVrBrTbFteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrTbFte component.')
mscVrBrTbFteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbFteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrTbFte components. These components cannot be added nor deleted.')
mscVrBrTbFteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbFteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrTbFteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbFteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteStorageType.setDescription('This variable represents the storage type value for the mscVrBrTbFte tables.')
mscVrBrTbFteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: mscVrBrTbFteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteAddressIndex.setDescription('This variable represents an index for the mscVrBrTbFte tables.')
mscVrBrTbFteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: mscVrBrTbFteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteDomainNumIndex.setDescription('This variable represents an index for the mscVrBrTbFte tables.')
mscVrBrTbFteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 10), )
if mibBuilder.loadTexts: mscVrBrTbFteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the attributes that form the fields of a forwarding table entry. Multiple such forwarding table entries put together form the forwarding table. These attributes reflect the state of the transparent bridge forwarding table.')
mscVrBrTbFteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbFteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbFteDomainNumIndex"))
if mibBuilder.loadTexts: mscVrBrTbFteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteOperEntry.setDescription('An entry in the mscVrBrTbFteOperTable.')
mscVrBrTbFtePort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbFtePort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFtePort.setDescription("This attribute is the port name through which the address was learnt. This implies that the frames that are destined for a station whose MAC address is the same as the address, will be forwarded through the bridge port indicated by the attribute port. The attribute port is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrBrTbFteAgeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 10, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbFteAgeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteAgeOfEntry.setDescription('This attribute specifies the age of the forwarding table entry. This is used to purge entries that have not been used for a certain period of time. This feature is to ensure that only the recently used entries are kept in the forwarding table. The time period for aging entries can be provisioned through the attribute agingTime under the component TransparentBridge.')
mscVrBrTbFtePeerAddressInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 10, 1, 5), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbFtePeerAddressInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFtePeerAddressInfo.setDescription('This attribute represents the learned peer address information. This address is used to essentially tunnel frames to a peer bridge unit across a network or a backbone. The tunneled frame is then appropriately processed by the peer bridge unit. Fddi encapsulated bridging using FddiETb bridge port and Source route encapsulated bridging using SrseBridgePort & TbseBridgePort are examples of instances where this attribute peerAddressInfo is used.')
mscVrBrTbFteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 4, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("learned", 3))).clone('learned')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbFteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbFteStatus.setDescription('This attribute represents the status of the forwarding table entry. A value of learned indicates that the entry was learned and cached from the network. Please note that a only a value of learned is currently supported.')
mscVrBrTbNcFte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5))
mscVrBrTbNcFteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 1), )
if mibBuilder.loadTexts: mscVrBrTbNcFteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrBrTbNcFte components.')
mscVrBrTbNcFteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbNcFteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbNcFteDomainNumIndex"))
if mibBuilder.loadTexts: mscVrBrTbNcFteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrTbNcFte component.')
mscVrBrTbNcFteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNcFteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrTbNcFte components. These components cannot be added nor deleted.')
mscVrBrTbNcFteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNcFteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrTbNcFteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNcFteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteStorageType.setDescription('This variable represents the storage type value for the mscVrBrTbNcFte tables.')
mscVrBrTbNcFteAddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 1, 1, 10), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6))
if mibBuilder.loadTexts: mscVrBrTbNcFteAddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteAddressIndex.setDescription('This variable represents an index for the mscVrBrTbNcFte tables.')
mscVrBrTbNcFteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: mscVrBrTbNcFteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteDomainNumIndex.setDescription('This variable represents an index for the mscVrBrTbNcFte tables.')
mscVrBrTbNcFteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 10), )
if mibBuilder.loadTexts: mscVrBrTbNcFteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group houses all the attributes that form the fields of a forwarding table entry. Multiple such forwarding table entries put together form the forwarding table. These attributes reflect the state of the transparent bridge forwarding table.')
mscVrBrTbNcFteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbNcFteAddressIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrTbNcFteDomainNumIndex"))
if mibBuilder.loadTexts: mscVrBrTbNcFteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteOperEntry.setDescription('An entry in the mscVrBrTbNcFteOperTable.')
mscVrBrTbNcFtePort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 10, 1, 3), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNcFtePort.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFtePort.setDescription("This attribute is the port name through which the address was learnt. This implies that the frames that are destined for a station whose MAC address is the same as the address, will be forwarded through the bridge port indicated by the attribute port. The attribute port is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport.")
mscVrBrTbNcFteAgeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 10, 1, 4), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 1000000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNcFteAgeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteAgeOfEntry.setDescription('This attribute specifies the age of the forwarding table entry. This is used to purge entries that have not been used for a certain period of time. This feature is to ensure that only the recently used entries are kept in the forwarding table. The time period for aging entries can be provisioned through the attribute agingTime under the component TransparentBridge.')
mscVrBrTbNcFtePeerAddressInfo = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 10, 1, 5), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNcFtePeerAddressInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFtePeerAddressInfo.setDescription('This attribute represents the learned peer address information. This address is used to essentially tunnel frames to a peer bridge unit across a network or a backbone. The tunneled frame is then appropriately processed by the peer bridge unit. Fddi encapsulated bridging using FddiETb bridge port and Source route encapsulated bridging using SrseBridgePort & TbseBridgePort are examples of instances where this attribute peerAddressInfo is used.')
mscVrBrTbNcFteStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 4, 5, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3))).clone(namedValues=NamedValues(("learned", 3))).clone('learned')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrTbNcFteStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrTbNcFteStatus.setDescription('This attribute represents the status of the forwarding table entry. A value of learned indicates that the entry was learned and cached from the network. Please note that a only a value of learned is currently supported.')
mscVrBrSrb = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5))
mscVrBrSrbRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 1), )
if mibBuilder.loadTexts: mscVrBrSrbRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBrSrb components.')
mscVrBrSrbRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"))
if mibBuilder.loadTexts: mscVrBrSrbRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrSrb component.')
mscVrBrSrbRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrSrb components. These components can be added and deleted.')
mscVrBrSrbComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrSrbStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStorageType.setDescription('This variable represents the storage type value for the mscVrBrSrb tables.')
mscVrBrSrbIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscVrBrSrbIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbIndex.setDescription('This variable represents the index for the mscVrBrSrb tables.')
mscVrBrSrbProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 10), )
if mibBuilder.loadTexts: mscVrBrSrbProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbProvTable.setDescription('This group contains all provisionable attributes associated with source route bridging. These attributes are global in nature as opposed to port specific.')
mscVrBrSrbProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"))
if mibBuilder.loadTexts: mscVrBrSrbProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbProvEntry.setDescription('An entry in the mscVrBrSrbProvTable.')
mscVrBrSrbLanIdTableNumEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(500, 65535)).clone(500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbLanIdTableNumEntries.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLanIdTableNumEntries.setDescription('This attribute specifies the maximum number of entries in the LAN ID table. This attribute provides a way to control the resources allocated to the LAN ID table. The lanIdTableNumEntries value depends upon the VirtualRouter attribute bridgingMaxHeapSpace and the number of source route bridge ports provisioned for this SourceRouteBridge. Consider the following attributes of the SourceRouteBridge component when adjusting this number: - totalLanIdTableEntries - numLanIdTEntriesFree - numLanIdTEntriesDenied')
mscVrBrSrbAgingTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbAgingTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbAgingTime.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time can change, triggered by a spanning tree topology change. The operational value of the aging time is reflected in the attribute agingTimeOper under the SpanningTreeProtocol component.')
mscVrBrSrbBridgeLfMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mode3", 1), ("mode6", 2))).clone('mode3')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbBridgeLfMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbBridgeLfMode.setDescription('This attribute indicates whether the bridge operates using the older 3-bit length negotiation field or the newer 6-bit length field in the routing information field. Only the 3-bit field is supported at this time.')
mscVrBrSrbStatsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 11), )
if mibBuilder.loadTexts: mscVrBrSrbStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStatsTable.setDescription('This group contains all statistical attributes associated with the SourceRouteBridge. These attributes are global in nature as opposed to port specific.')
mscVrBrSrbStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"))
if mibBuilder.loadTexts: mscVrBrSrbStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStatsEntry.setDescription('An entry in the mscVrBrSrbStatsTable.')
mscVrBrSrbTotalLanIdTableEntries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 11, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbTotalLanIdTableEntries.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbTotalLanIdTableEntries.setDescription('This attribute specifies the total number of LAN ID Table entries. The total includes both static and dynamic entries. The value is limited by the attribute lanIdTableNumEntries, a provisionable attribute. If the value is consistently approaching the value of lanIdTableNumEntries it is advisable to increase the value provisioned for lanIdTableNumEntries.')
mscVrBrSrbNumLanIdtEntriesFree = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 11, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbNumLanIdtEntriesFree.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbNumLanIdtEntriesFree.setDescription('This attribute specifies the number of LanIdTable entries that are available for use. A consistently high value indicates a resource surplus in terms of memory requirements for the bridge. This surplus could be utilized elsewhere if need be. The value of this attribute is directly influenced by the value of the lanIdTableNumEntries.')
mscVrBrSrbNumLanIdtEntriesDenied = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbNumLanIdtEntriesDenied.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbNumLanIdtEntriesDenied.setDescription('This attribute indicates the number of instances where an entry was not placed in the LanIdTable due to the lack of free entries. A rapid increase indicates a shortage of free entries. To reduce the shortage increase the provisioned lanIdTableNumEntries value.')
mscVrBrSrbStp = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2))
mscVrBrSrbStpRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 1), )
if mibBuilder.loadTexts: mscVrBrSrbStpRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpRowStatusTable.setDescription('This entry controls the addition and deletion of mscVrBrSrbStp components.')
mscVrBrSrbStpRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbStpIndex"))
if mibBuilder.loadTexts: mscVrBrSrbStpRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrSrbStp component.')
mscVrBrSrbStpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbStpRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrSrbStp components. These components can be added and deleted.')
mscVrBrSrbStpComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrSrbStpStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpStorageType.setDescription('This variable represents the storage type value for the mscVrBrSrbStp tables.')
mscVrBrSrbStpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: mscVrBrSrbStpIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpIndex.setDescription('This variable represents the index for the mscVrBrSrbStp tables.')
mscVrBrSrbStpProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10), )
if mibBuilder.loadTexts: mscVrBrSrbStpProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpProvTable.setDescription('This group houses all the provisionable attributes that are applicable to the spanning tree protocol. These are global attributes and not port specific attributes. These attributes have a direct impact on the way this bridge participates in the spanning tree protocol.')
mscVrBrSrbStpProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbStpIndex"))
if mibBuilder.loadTexts: mscVrBrSrbStpProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpProvEntry.setDescription('An entry in the mscVrBrSrbStpProvTable.')
mscVrBrSrbStpStpMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("access", 1), ("backbone", 2))).clone('access')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbStpStpMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpStpMode.setDescription('This attribute determines if this stp instance is to act as the stp instance for the backbone or an stp instance for a non-backbone media configuration. There can exist only one Backbone stp instance per virtual router. If the attribute domainStpTbState is set to a value on and Backbone bridge ports have been provisioned, there should exist a Backbone stp instance. Please note that it is not permissible to assign the instance identifier of this stp instance as domain number of any access bridge port. In case of stp instances that are non-Backbone, the instance identifier is indicative of the domain number the stp is operational in.')
mscVrBrSrbStpProtocolSpec = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("both", 1), ("dec", 2), ("ieee8021d", 3))).clone('ieee8021d')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbStpProtocolSpec.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpProtocolSpec.setDescription('This attribute specifies the type of spanning tree protocols that are in operation in the bridge. This means that this bridge participates in the types spanning tree protocol indicated by this attribute.')
mscVrBrSrbStpPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbStpPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpPriority.setDescription('This attribute is used to construct the bridgeId. It forms the first two octets of the bridgeId and the remaining 6 octets are made up of the bridgeMACAddress. The priority also determines the root bridge of the spanning tree topology. Manipulating this attribute might lead to a change in the spanning tree topology.')
mscVrBrSrbStpBridgeMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeMaxAge.setDescription('The maximum age of spanning tree protocol information learned from the network on any bridge port before it is discarded. This value is used by this bridge and all the other bridges, when this bridge is the root bridge of the spanning tree topology. The following relationships are enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0seconds) >= bridgeMaxAge, bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds. DESCRIPTION')
mscVrBrSrbStpBridgeHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeHelloTime.setDescription('This attribute specifies the time interval between the transmission of configuration BPDUs on any bridge port when this bridge becomes the root bridge. This attribute value is also used by all the other bridges in the Spanning Tree while this bridge is the root. The following relationship is enforced as required by the IEEE 802.1d standards document. bridgeMaxAge >= 2 * bridgeHelloTime + 1.0 seconds.')
mscVrBrSrbStpBridgeForwardDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeForwardDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeForwardDelay.setDescription('This attribute specifies how fast a bridge port changes its STP state while progressing towards the forwarding state. It is also used as agingTime to age dynamic entries in the forwarding table once a topology change is detected. This attribute is used by all the bridges participating in the spanning tree protocol, when this bridge is the root bridge. The following relationship is enforced as required by the IEEE 802.1d standards document. 2 *(bridgeForwardDelay -1.0sconds) >= bridgeMaxAge.')
mscVrBrSrbStpOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11), )
if mibBuilder.loadTexts: mscVrBrSrbStpOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpOperTable.setDescription('This group houses all the operational, spanning tree protocol attributes. These attributes are applicable in a global manner and are not specific to a bridge port.')
mscVrBrSrbStpOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbStpIndex"))
if mibBuilder.loadTexts: mscVrBrSrbStpOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpOperEntry.setDescription('An entry in the mscVrBrSrbStpOperTable.')
mscVrBrSrbStpBridgeId = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 1), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeId.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpBridgeId.setDescription('This attribute specifies the identifier value of this bridge, which serves to uniquely represent this bridge in the spanning tree topology. Thus, a bridgeId is unique only in the spanning tree instance the bridge in participating in. If multiple domain spanning trees exist then the same bridgeId can be re-used across these spanning tree instances.')
mscVrBrSrbStpRootPortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 2), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpRootPortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpRootPortName.setDescription("This attribute specifies the name of the bridge port that offers the lowest cost route to the root bridge of the spanning tree topology.The attribute rootPortName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort, the bridge port is provisioned under. For example a TransparentBridgePort provisioned under ProtocolPort/myport would have a name TBP-myport. If multiple instances of spanning tree are operational, then there will exist a rootPortName value for each instance of the spanning tree running, and is applicable to that instance alone.")
mscVrBrSrbStpTimeSinceTopologyChange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpTimeSinceTopologyChange.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpTimeSinceTopologyChange.setDescription('This attribute specifies the time since a spanning tree topology change was detected by this bridge.')
mscVrBrSrbStpTopologyChangeDetect = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpTopologyChangeDetect.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpTopologyChangeDetect.setDescription('This attribute specifies whether or not a topology change was detected. This flag is set when a bpdu with the topology detect flag set is received from the root bridge. If this bridge is the root bridge this flag is set on receipt of a topology change notification bpdu. It is reset after a fixed length of time.')
mscVrBrSrbStpTopologyChanges = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpTopologyChanges.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpTopologyChanges.setDescription('This attribute is indicative of the number of topology changes detected by this bridge since the last bridge reset. This counter wraps around its maximum value of 4294967295.')
mscVrBrSrbStpDesignatedRoot = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 6), BridgeId().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpDesignatedRoot.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpDesignatedRoot.setDescription('This attribute specifies the identifier of the bridge that this bridge treats as the root of the spanning tree topology. The root of the spanning tree topology is chosen through exchange.')
mscVrBrSrbStpRootCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpRootCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpRootCost.setDescription('This attribute specifies the cost of the path to the root as seen by this bridge.')
mscVrBrSrbStpMaxAge = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(600, 4000)).clone(2000)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpMaxAge.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpMaxAge.setDescription('This attribute specifies the maximum age of the spanning tree protocol info learnt from a port, before it is discarded.')
mscVrBrSrbStpAgingTimeOper = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpAgingTimeOper.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpAgingTimeOper.setDescription('This attribute specifies the time period used in seconds, to age out dynamically learned entries in the forwarding table. The aging time is specific to a spanning tree protocol instance running. A value for the aging time of the current instance of the spanning tree protocol can be provisioned through the attribute agingTime under the InwBrTb component. The agingTimeOper attribute assumes the value of the bridgeForwardDelay while a topology change is in progress. This is done to facilitate quick aging out of the learned entries that might have become obsolete due to a spanning tree topology change.')
mscVrBrSrbStpHelloTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 1000)).clone(200)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpHelloTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpHelloTime.setDescription('This attribute specifies the time interval between the transmission of the configuration BPDUs. This value is obtained from the root bridge of the spanning tree topology, through bridge protocol data units. This value should be the value assigned to the attribute bridgeHelloTime of the root bridge.')
mscVrBrSrbStpHoldTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(100, 100)).clone(100)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpHoldTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpHoldTime.setDescription('This attribute specifies the interval of time which no more than two BPDUs should be sent.')
mscVrBrSrbStpFwdDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 2, 11, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(400, 3000)).clone(1500)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbStpFwdDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbStpFwdDelay.setDescription('This attribute specifies how much time a port spends in any state while progressing towards the forwarding state. It is also used to age out learned entries while a topology change is in progress.This value should be the value assigned to the attribute bridgefwdDelay of the root bridge.')
mscVrBrSrbLte = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3))
mscVrBrSrbLteRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 1), )
if mibBuilder.loadTexts: mscVrBrSrbLteRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscVrBrSrbLte components.')
mscVrBrSrbLteRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbLteLanIdIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbLteDomainNumIndex"))
if mibBuilder.loadTexts: mscVrBrSrbLteRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteRowStatusEntry.setDescription('A single entry in the table represents a single mscVrBrSrbLte component.')
mscVrBrSrbLteRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbLteRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscVrBrSrbLte components. These components cannot be added nor deleted.')
mscVrBrSrbLteComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbLteComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscVrBrSrbLteStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbLteStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteStorageType.setDescription('This variable represents the storage type value for the mscVrBrSrbLte tables.')
mscVrBrSrbLteLanIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 4095), ValueRangeConstraint(65535, 65535), )))
if mibBuilder.loadTexts: mscVrBrSrbLteLanIdIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteLanIdIndex.setDescription('This variable represents an index for the mscVrBrSrbLte tables.')
mscVrBrSrbLteDomainNumIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 268435455)))
if mibBuilder.loadTexts: mscVrBrSrbLteDomainNumIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteDomainNumIndex.setDescription('This variable represents an index for the mscVrBrSrbLte tables.')
mscVrBrSrbLteOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 10), )
if mibBuilder.loadTexts: mscVrBrSrbLteOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all the fields of a LAN ID Table entry.')
mscVrBrSrbLteOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-VirtualRouterMIB", "mscVrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbLteLanIdIndex"), (0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscVrBrSrbLteDomainNumIndex"))
if mibBuilder.loadTexts: mscVrBrSrbLteOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteOperEntry.setDescription('An entry in the mscVrBrSrbLteOperTable.')
mscVrBrSrbLtePortName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 10, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(4, 29))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbLtePortName.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLtePortName.setDescription("This attribute specifies the name of the bridge port the frame should be forwarded through to reach the desired Lan. In the case where the desired Lan is across a TB/SRT cloud, this entry would have the name of the SrSeBridgePort. The attribute portName is a string of the form 'BridgePortName-i', where BridgePortName is the abbreviation of the corresponding bridge port and i is the instance identifier of the ProtocolPort the bridge port is provisioned under. For example a SourceRouteBridgePort provisioned under ProtocolPort/MyPort would have a name SrBP-MyPort. Please note that the attribute portName cannot have a value of TBP, FddiETb, Tbse, Tbcl, Tbsr, Srsg, Tbsg. DESCRIPTION")
mscVrBrSrbLteAgeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbLteAgeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteAgeOfEntry.setDescription('This attribute specifies the age of this entry in seconds.')
mscVrBrSrbLtePeerMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 10, 1, 3), DashedHexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbLtePeerMACAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLtePeerMACAddress.setDescription('This attribute specifies the MAC address of a bridge unit found across an transparent bridge/source route transparent network whose LAN ID is referenced by the attribute lanId. The peerMACAddress for static entries will be all zeroes.')
mscVrBrSrbLteTypeOfEntry = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 100, 5, 5, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("static", 0), ("dynamic", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscVrBrSrbLteTypeOfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscVrBrSrbLteTypeOfEntry.setDescription('This attribute specifies the type of the LAN ID table entry. LAN ID table entries may be either static or dynamic. Dynamic entries imply that to reach the desired LAN source route frames need to be tunneled through a TB/SRT network, to another bridge unit which is attached to the LAN. These entries have a peerMACAddress associated with them and may be removed through the aging mechanism of the LAN ID table. Static entries on the other hand contain information about LANs that may be reached directly through bridge ports attached to the bridge. They are not aged and do not have a peerMACAddress associated with them.')
mscCB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103))
mscCBRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 1), )
if mibBuilder.loadTexts: mscCBRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBRowStatusTable.setDescription('This entry controls the addition and deletion of mscCB components.')
mscCBRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscCBIndex"))
if mibBuilder.loadTexts: mscCBRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBRowStatusEntry.setDescription('A single entry in the table represents a single mscCB component.')
mscCBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscCBRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscCB components. These components can be added and deleted.')
mscCBComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscCBStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBStorageType.setDescription('This variable represents the storage type value for the mscCB tables.')
mscCBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscCBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBIndex.setDescription('This variable represents the index for the mscCB tables.')
mscCBAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 10), )
if mibBuilder.loadTexts: mscCBAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscCBAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscCBIndex"))
if mibBuilder.loadTexts: mscCBAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBAdminControlEntry.setDescription('An entry in the mscCBAdminControlTable.')
mscCBSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscCBSnmpAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscCBSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscCBIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 11), )
if mibBuilder.loadTexts: mscCBIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscCBIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscCBIndex"))
if mibBuilder.loadTexts: mscCBIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBIfEntryEntry.setDescription('An entry in the mscCBIfEntryTable.')
mscCBIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscCBIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscCBIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscCBMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 12), )
if mibBuilder.loadTexts: mscCBMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBMpTable.setDescription('This group contains the base provisioning data for the media base component.')
mscCBMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscCBIndex"))
if mibBuilder.loadTexts: mscCBMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBMpEntry.setDescription('An entry in the mscCBMpTable.')
mscCBLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 12, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscCBLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBLinkToProtocolPort.setDescription('This attribute specifies the ProtocolPort to which this interface is linked to. The protocol port is the logical interface to the network. The protocol port component describes the logical characteristics of this interface.')
mscCBOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 13), )
if mibBuilder.loadTexts: mscCBOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBOperTable.setDescription('This group includes the operational attibutes which are specific to the ClusterBridge component.')
mscCBOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscCBIndex"))
if mibBuilder.loadTexts: mscCBOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBOperEntry.setDescription('An entry in the mscCBOperTable.')
mscCBMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 13, 1, 1), MacAddress().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBMacAddress.setDescription('The medium access controller (MAC) address is an address that is only recognized by one station on the attached bus. This address is automatically assigned by the system.')
mscCBStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 14), )
if mibBuilder.loadTexts: mscCBStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscCBStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscCBIndex"))
if mibBuilder.loadTexts: mscCBStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBStateEntry.setDescription('An entry in the mscCBStateTable.')
mscCBAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscCBOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscCBUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscCBOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 15), )
if mibBuilder.loadTexts: mscCBOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscCBOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscCBIndex"))
if mibBuilder.loadTexts: mscCBOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBOperStatusEntry.setDescription('An entry in the mscCBOperStatusTable.')
mscCBSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 103, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscCBSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscCBSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
mscPB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104))
mscPBRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 1), )
if mibBuilder.loadTexts: mscPBRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBRowStatusTable.setDescription('This entry controls the addition and deletion of mscPB components.')
mscPBRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscPBIndex"))
if mibBuilder.loadTexts: mscPBRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBRowStatusEntry.setDescription('A single entry in the table represents a single mscPB component.')
mscPBRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscPBRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscPB components. These components can be added and deleted.')
mscPBComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscPBStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBStorageType.setDescription('This variable represents the storage type value for the mscPB tables.')
mscPBIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscPBIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBIndex.setDescription('This variable represents the index for the mscPB tables.')
mscPBAdminControlTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 10), )
if mibBuilder.loadTexts: mscPBAdminControlTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBAdminControlTable.setDescription('This group includes the Administrative Control attribute. This attribute defines the current administrative state of this component.')
mscPBAdminControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscPBIndex"))
if mibBuilder.loadTexts: mscPBAdminControlEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBAdminControlEntry.setDescription('An entry in the mscPBAdminControlTable.')
mscPBSnmpAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscPBSnmpAdminStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscPBSnmpAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational and packet forwarding is allowed. The down state indicates the interface is not operational and packet forwarding is unavailable. The testing state indicates that no operational packets can be passed.')
mscPBIfEntryTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 11), )
if mibBuilder.loadTexts: mscPBIfEntryTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBIfEntryTable.setDescription('This group contains the provisionable attributes for the ifEntry.')
mscPBIfEntryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscPBIndex"))
if mibBuilder.loadTexts: mscPBIfEntryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBIfEntryEntry.setDescription('An entry in the mscPBIfEntryTable.')
mscPBIfAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscPBIfAdminStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBIfAdminStatus.setDescription('The desired state of the interface. The up state indicates the interface is operational. The down state indicates the interface is not operational. The testing state indicates that no operational packets can be passed.')
mscPBIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 11, 1, 2), InterfaceIndex().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBIfIndex.setDescription('This is the index for the IfEntry. Its value is automatically initialized during the provisioning process.')
mscPBMpTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 12), )
if mibBuilder.loadTexts: mscPBMpTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBMpTable.setDescription('This group contains the base provisioning data for the media base component.')
mscPBMpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscPBIndex"))
if mibBuilder.loadTexts: mscPBMpEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBMpEntry.setDescription('An entry in the mscPBMpTable.')
mscPBLinkToProtocolPort = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 12, 1, 1), Link()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscPBLinkToProtocolPort.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBLinkToProtocolPort.setDescription('This attribute specifies the ProtocolPort to which this interface is linked to. The protocol port is the logical interface to the network. The protocol port component describes the logical characteristics of this interface.')
mscPBOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 13), )
if mibBuilder.loadTexts: mscPBOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBOperTable.setDescription('This group includes the operational attibutes which are specific to the PseudoBridge component.')
mscPBOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscPBIndex"))
if mibBuilder.loadTexts: mscPBOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBOperEntry.setDescription('An entry in the mscPBOperTable.')
mscPBMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 13, 1, 1), HexString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBMacAddress.setDescription('The medium access controller (MAC) address is an address that is only recognized by one station on the attached bus. This address is automatically assigned by the system.')
mscPBStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 14), )
if mibBuilder.loadTexts: mscPBStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBStateTable.setDescription('This group contains the three OSI State attributes. The descriptions generically indicate what each state attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241-7001-150, Passport Operations and Maintenance Guide.')
mscPBStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 14, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscPBIndex"))
if mibBuilder.loadTexts: mscPBStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBStateEntry.setDescription('An entry in the mscPBStateTable.')
mscPBAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 14, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component.')
mscPBOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle.')
mscPBUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 14, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time.')
mscPBOperStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 15), )
if mibBuilder.loadTexts: mscPBOperStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBOperStatusTable.setDescription('This group includes the Operational Status attribute. This attribute defines the current operational state of this component.')
mscPBOperStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 15, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-BridgeMIB", "mscPBIndex"))
if mibBuilder.loadTexts: mscPBOperStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBOperStatusEntry.setDescription('An entry in the mscPBOperStatusTable.')
mscPBSnmpOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 104, 15, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("testing", 3))).clone('up')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscPBSnmpOperStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscPBSnmpOperStatus.setDescription('The current state of the interface. The up state indicates the interface is operational and capable of forwarding packets. The down state indicates the interface is not operational, thus unable to forward packets. testing state indicates that no operational packets can be passed.')
bridgeGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 1))
bridgeGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 1, 1))
bridgeGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 1, 1, 3))
bridgeGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 1, 1, 3, 2))
bridgeCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 3))
bridgeCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 3, 1))
bridgeCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 3, 1, 3))
bridgeCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 25, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-BridgeMIB", mscVrBrPteRowStatus=mscVrBrPteRowStatus, mscVrBrSrbStpComponentName=mscVrBrSrbStpComponentName, mscPBOperStatusTable=mscPBOperStatusTable, mscVrPpSrseInFilterDiscards=mscVrPpSrseInFilterDiscards, mscVrPpSrBpAdminState=mscVrPpSrBpAdminState, mscVrPpSrBpSegmentMismatchDiscards=mscVrPpSrBpSegmentMismatchDiscards, mscVrPpTbpNsIncomingFilter=mscVrPpTbpNsIncomingFilter, mscVrPpSrBpMtuExceededDiscards=mscVrPpSrBpMtuExceededDiscards, mscVrPpTbsgPathCostMethod=mscVrPpTbsgPathCostMethod, mscVrBrSrbLteDomainNumIndex=mscVrBrSrbLteDomainNumIndex, mscVrBrSrbLtePeerMACAddress=mscVrBrSrbLtePeerMACAddress, mscVrPpSrsgComponentName=mscVrPpSrsgComponentName, mscVrPpSrseRowStatusTable=mscVrPpSrseRowStatusTable, mscVrPpSrseDomainNum=mscVrPpSrseDomainNum, mscVrPpSrsgBridgeNum=mscVrPpSrsgBridgeNum, mscVrPpSrsgAdminStatus=mscVrPpSrsgAdminStatus, mscVrPpFddiETBSecureOption=mscVrPpFddiETBSecureOption, mscVrPpFddiETBBadAbstractDiscards=mscVrPpFddiETBBadAbstractDiscards, mscVrPpSrsgSrStatsEntry=mscVrPpSrsgSrStatsEntry, mscVrBrPteStorageType=mscVrBrPteStorageType, mscVrBrPteInternalLanId=mscVrBrPteInternalLanId, mscVrPpTbseStpTypeOper=mscVrPpTbseStpTypeOper, mscVrPpSrBpUsageState=mscVrPpSrBpUsageState, mscVrPpSrsgLargestFrame=mscVrPpSrsgLargestFrame, mscVrPpSrclNsIndex=mscVrPpSrclNsIndex, mscPBStateTable=mscPBStateTable, mscVrPpFddiETBDelayExceededDiscards=mscVrPpFddiETBDelayExceededDiscards, mscVrPpSrBpStateEntry=mscVrPpSrBpStateEntry, mscVrPpTbseBridgePortConfig=mscVrPpTbseBridgePortConfig, mscVrPpSrtBpIndex=mscVrPpSrtBpIndex, mscVrPpSrsgStatsTable=mscVrPpSrsgStatsTable, mscVrBrSrbStp=mscVrBrSrbStp, mscVrPpSrsgStateTable=mscVrPpSrsgStateTable, mscVrPpSrseStaticDiscards=mscVrPpSrseStaticDiscards, mscVrPpFddiETBLearningDiscards=mscVrPpFddiETBLearningDiscards, mscVrPpSrseSpecInFrames=mscVrPpSrseSpecInFrames, mscVrPpTbclDelayExceededDiscards=mscVrPpTbclDelayExceededDiscards, mscVrPpSrtBpRowStatusEntry=mscVrPpSrtBpRowStatusEntry, mscVrPpSrsgStpPortState=mscVrPpSrsgStpPortState, mscVrPpTbseStpOperEntry=mscVrPpTbseStpOperEntry, mscVrBrTbStpIndex=mscVrBrTbStpIndex, bridgeCapabilitiesCA02=bridgeCapabilitiesCA02, mscVrPpFddiETBTbOperTable=mscVrPpFddiETBTbOperTable, mscVrBrTbStpRootPortName=mscVrBrTbStpRootPortName, mscVrPpSrtBpSegmentMismatchDiscards=mscVrPpSrtBpSegmentMismatchDiscards, mscCBIfAdminStatus=mscCBIfAdminStatus, mscVrPpSrsgRowStatus=mscVrPpSrsgRowStatus, mscVrPpSrBpSrStatsTable=mscVrPpSrBpSrStatsTable, mscVrPpTbclStatsEntry=mscVrPpTbclStatsEntry, mscVrPpSrtBpIfIndex=mscVrPpSrtBpIfIndex, mscVrPpTbseProvEntry=mscVrPpTbseProvEntry, mscCBMpEntry=mscCBMpEntry, mscVrBrTbStatsEntry=mscVrBrTbStatsEntry, mscVrBrPteRowStatusEntry=mscVrBrPteRowStatusEntry, mscVrPpFddiETBBridgePortConfig=mscVrPpFddiETBBridgePortConfig, mscVrPpTbsgComponentName=mscVrPpTbsgComponentName, mscVrPpTbpStpTypeOper=mscVrPpTbpStpTypeOper, mscVrBrRowStatusEntry=mscVrBrRowStatusEntry, mscVrPpSrtBpTranslateIpx=mscVrPpSrtBpTranslateIpx, mscVrPpSrseBridgePortType=mscVrPpSrseBridgePortType, mscVrPpTbpIfIndex=mscVrPpTbpIfIndex, mscVrBrTbNcFte=mscVrBrTbNcFte, mscVrPpSrseSteInFrames=mscVrPpSrseSteInFrames, mscCBAdminControlEntry=mscCBAdminControlEntry, mscVrBrSrbRowStatusTable=mscVrBrSrbRowStatusTable, mscVrPpTbpBlockingDiscards=mscVrPpTbpBlockingDiscards, mscVrPpTbclUnicastNoMatches=mscVrPpTbclUnicastNoMatches, mscVrPpTbpRowStatusTable=mscVrPpTbpRowStatusTable, mscVrPpSrtBpStpTypeProv=mscVrPpSrtBpStpTypeProv, mscVrPpSrtBpStateTable=mscVrPpSrtBpStateTable, mscVrPpTbseSecureOption=mscVrPpTbseSecureOption, mscPB=mscPB, mscVrPpTbpComponentName=mscVrPpTbpComponentName, mscVrPpTbpStatsTable=mscVrPpTbpStatsTable, mscPBIfEntryEntry=mscPBIfEntryEntry, mscVrBrNsAteFirstMacAddress=mscVrBrNsAteFirstMacAddress, mscVrPpSrclPathCost=mscVrPpSrclPathCost, mscVrPpTbseInFilterDiscards=mscVrPpTbseInFilterDiscards, mscVrPpTbsePortNum=mscVrPpTbsePortNum, mscCBStateTable=mscCBStateTable, mscVrPpTbpAdminState=mscVrPpTbpAdminState, mscVrPpSrclDesignatedBridge=mscVrPpSrclDesignatedBridge, mscVrBrNsAteProvTable=mscVrBrNsAteProvTable, mscVrBrTbNcFteRowStatus=mscVrBrTbNcFteRowStatus, mscVrBrSrbStpProvTable=mscVrBrSrbStpProvTable, mscVrPpTbpPortNum=mscVrPpTbpPortNum, mscVrPpSrtBpOperStatusEntry=mscVrPpSrtBpOperStatusEntry, mscVrPpSrsgBlockingDiscards=mscVrPpSrsgBlockingDiscards, mscVrPpSrsgApeOutFrames=mscVrPpSrsgApeOutFrames, mscVrPpSrsgDesignatedPort=mscVrPpSrsgDesignatedPort, mscVrPpFddiETBOutFilterDiscards=mscVrPpFddiETBOutFilterDiscards, mscVrPpSrclSrStatsTable=mscVrPpSrclSrStatsTable, mscVrPpFddiETBOperationalState=mscVrPpFddiETBOperationalState, mscVrPpSrsgStpOperTable=mscVrPpSrsgStpOperTable, mscVrPpTbsgTbOperTable=mscVrPpTbsgTbOperTable, mscVrPpSrBpOperEntry=mscVrPpSrBpOperEntry, mscVrPpTbsgMtuExceededDiscards=mscVrPpTbsgMtuExceededDiscards, mscVrPpSrseOperStatusEntry=mscVrPpSrseOperStatusEntry, mscVrBrNsAteSecondMacAddressMask=mscVrBrNsAteSecondMacAddressMask, mscVrPpFddiETBStpOperEntry=mscVrPpFddiETBStpOperEntry, mscCBOperStatusEntry=mscCBOperStatusEntry, mscVrBrTbFteComponentName=mscVrBrTbFteComponentName, mscVrBrTbStpStorageType=mscVrBrTbStpStorageType, mscVrBrPteDomainNumIndex=mscVrBrPteDomainNumIndex, mscVrPpTbclTbOperTable=mscVrPpTbclTbOperTable, mscVrBrSrbStpBridgeHelloTime=mscVrBrSrbStpBridgeHelloTime, mscVrBrSrbLteRowStatusEntry=mscVrBrSrbLteRowStatusEntry, mscVrPpFddiETBMaxInfo=mscVrPpFddiETBMaxInfo, mscVrPpFddiETBInFrames=mscVrPpFddiETBInFrames, mscVrBrTbFteStorageType=mscVrBrTbFteStorageType, bridgeGroup=bridgeGroup, mscPBOperStatusEntry=mscPBOperStatusEntry, mscVrBrNsAteProvEntry=mscVrBrNsAteProvEntry, mscVrBrTbNcFteOperEntry=mscVrBrTbNcFteOperEntry, mscVrPpSrclBridgePortType=mscVrPpSrclBridgePortType, mscVrPpSrtBpDupLanIdOrTreeErrors=mscVrPpSrtBpDupLanIdOrTreeErrors, mscVrPpTbpPortName=mscVrPpTbpPortName, mscVrPpFddiETBStpTypeProv=mscVrPpFddiETBStpTypeProv, mscVrPpSrseOperTable=mscVrPpSrseOperTable, mscVrPpSrtBpSnmpOperStatus=mscVrPpSrtBpSnmpOperStatus, mscVrPpTbseIfIndex=mscVrPpTbseIfIndex, mscPBIfEntryTable=mscPBIfEntryTable, mscVrBrSrbStpOperEntry=mscVrBrSrbStpOperEntry, mscVrPpSrclBridgePortConfig=mscVrPpSrclBridgePortConfig, mscVrPpSrtBpSpecOutFrames=mscVrPpSrtBpSpecOutFrames, mscVrPpSrtBpTinygramFramesOut=mscVrPpSrtBpTinygramFramesOut, mscVrPpSrclNsComponentName=mscVrPpSrclNsComponentName, mscVrPpTbpDesignatedRoot=mscVrPpTbpDesignatedRoot, mscVrBrTbStpStpMode=mscVrBrTbStpStpMode, mscVrPpSrtBpDIProvTable=mscVrPpSrtBpDIProvTable, mscVrBrSrb=mscVrBrSrb, mscVrPpSrtBpDupSegmentDiscards=mscVrPpSrtBpDupSegmentDiscards, mscVrBrOperTable=mscVrBrOperTable, mscVrBrSrbLte=mscVrBrSrbLte, mscVrPpTbclNsIncomingFilter=mscVrPpTbclNsIncomingFilter, mscVrPpSrsgForwardTransitions=mscVrPpSrsgForwardTransitions, bridgeMIB=bridgeMIB, mscVrPpTbclPortNum=mscVrPpTbclPortNum, mscVrPpSrclAdminState=mscVrPpSrclAdminState, mscVrPpTbsgOperationalState=mscVrPpTbsgOperationalState, mscVrBrTbNcFteRowStatusTable=mscVrBrTbNcFteRowStatusTable, mscVrPpSrBpAdminStatus=mscVrPpSrBpAdminStatus, mscVrPpTbsgLearningDiscards=mscVrPpTbsgLearningDiscards, mscVrPpSrclApeInFrames=mscVrPpSrclApeInFrames, mscPBAdminControlEntry=mscPBAdminControlEntry, mscVrPpTbseOperTable=mscVrPpTbseOperTable, mscVrPpSrclTinygramFramesIn=mscVrPpSrclTinygramFramesIn, mscVrBrSnmpOperStatus=mscVrBrSnmpOperStatus, mscPBIndex=mscPBIndex, mscVrPpTbclLearningDiscards=mscVrPpTbclLearningDiscards, mscVrPpSrBpPathCost=mscVrPpSrBpPathCost, mscVrPpSrtBpTbOperTable=mscVrPpSrtBpTbOperTable, mscVrPpSrsgDomainNum=mscVrPpSrsgDomainNum, mscVrPpTbsgStpPortState=mscVrPpTbsgStpPortState, mscVrPpSrBpStatsEntry=mscVrPpSrBpStatsEntry, mscVrPpTbseOutFilterDiscards=mscVrPpTbseOutFilterDiscards, mscVrPpSrsgSpecInFrames=mscVrPpSrsgSpecInFrames, mscCBOperationalState=mscCBOperationalState, mscVrPpTbpOperEntry=mscVrPpTbpOperEntry, mscVrBrSrbStpRootPortName=mscVrBrSrbStpRootPortName, mscVrPpFddiETBNs=mscVrPpFddiETBNs, mscVrPpTbpInFrames=mscVrPpTbpInFrames, mscVrPpTbpBridgingMode=mscVrPpTbpBridgingMode, mscVrPpTbpAdminStatus=mscVrPpTbpAdminStatus, mscVrPpFddiETBTbProvEntry=mscVrPpFddiETBTbProvEntry, mscVrPpSrtBpPortName=mscVrPpSrtBpPortName, mscVrPpTbseDomainNum=mscVrPpTbseDomainNum, mscVrBrTbFtePort=mscVrBrTbFtePort, mscVrPpSrtBpSrProvEntry=mscVrPpSrtBpSrProvEntry, mscVrPpSrtBpDynamicEntryDiscards=mscVrPpSrtBpDynamicEntryDiscards, mscVrPpTbsgDIProvEntry=mscVrPpTbsgDIProvEntry, mscVrBrType=mscVrBrType, mscVrPpTbclNsStorageType=mscVrPpTbclNsStorageType, mscVrPpTbseStateTable=mscVrPpTbseStateTable, mscVrPpSrseAdminState=mscVrPpSrseAdminState, mscVrBrOperationalState=mscVrBrOperationalState, mscVrPpSrseForwardTransitions=mscVrPpSrseForwardTransitions, mscVrPpSrclOutFilterDiscards=mscVrPpSrclOutFilterDiscards, mscVrPpSrBpNsIncomingFilter=mscVrPpSrBpNsIncomingFilter, mscVrPpTbpTinygramFramesIn=mscVrPpTbpTinygramFramesIn, mscVrPpFddiETBUpTime=mscVrPpFddiETBUpTime, mscVrPpTbseTbOperEntry=mscVrPpTbseTbOperEntry, mscVrBrNsAte=mscVrBrNsAte, mscVrPpSrBpSteOutFrames=mscVrPpSrBpSteOutFrames, mscVrPpSrsgProvEntry=mscVrPpSrsgProvEntry, mscVrPpTbpConvertArpMacAddress=mscVrPpTbpConvertArpMacAddress, mscVrPpTbsgDesignatedRoot=mscVrPpTbsgDesignatedRoot, mscVrPpSrtBpForwardTransitions=mscVrPpSrtBpForwardTransitions, mscVrPpTbclPortStateStpControl=mscVrPpTbclPortStateStpControl, mscVrPpTbsgRowStatusEntry=mscVrPpTbsgRowStatusEntry, mscCBMpTable=mscCBMpTable, mscVrBrSrbStpStorageType=mscVrBrSrbStpStorageType, mscVrPpSrtBpTbOperEntry=mscVrPpSrtBpTbOperEntry, mscVrPpSrsgStpOperEntry=mscVrPpSrsgStpOperEntry, mscVrBrNsAteRowStatus=mscVrBrNsAteRowStatus, mscVrBrTbRowStatus=mscVrBrTbRowStatus, mscVrPpTbclDynamicEntryDiscards=mscVrPpTbclDynamicEntryDiscards, mscVrPpSrclDesignatedCost=mscVrPpSrclDesignatedCost, mscVrPpTbsgInFrames=mscVrPpTbsgInFrames, mscVrPpFddiETBOperStatusTable=mscVrPpFddiETBOperStatusTable, mscVrPpSrtBpPortNum=mscVrPpSrtBpPortNum, mscVrPpSrclFragmentIp=mscVrPpSrclFragmentIp, mscVrBrSrbStpTopologyChanges=mscVrBrSrbStpTopologyChanges, bridgeCapabilitiesCA02A=bridgeCapabilitiesCA02A, mscVrBrSrbStorageType=mscVrBrSrbStorageType, mscVrBrTbStpMaxAge=mscVrBrTbStpMaxAge, mscVrPpTbseForwardTransitions=mscVrPpTbseForwardTransitions, mscVrPpSrseBridgingMode=mscVrPpSrseBridgingMode, mscVrPpFddiETBDIProvEntry=mscVrPpFddiETBDIProvEntry, mscVrPpFddiETBStpTypeOper=mscVrPpFddiETBStpTypeOper, mscPBRowStatus=mscPBRowStatus, mscVrPpTbseStaticEntryDiscards=mscVrPpTbseStaticEntryDiscards, mscVrBrTbStpPriority=mscVrBrTbStpPriority, mscVrPpTbpOperStatusTable=mscVrPpTbpOperStatusTable, mscVrPpSrBpNsStorageType=mscVrPpSrBpNsStorageType, mscVrPpSrclMtuExceededDiscards=mscVrPpSrclMtuExceededDiscards, mscVrPpTbclPathCostMethod=mscVrPpTbclPathCostMethod, mscVrPpTbpForwardTransitions=mscVrPpTbpForwardTransitions, mscVrPpSrsgPathCostOper=mscVrPpSrsgPathCostOper, mscVrPpFddiETBStaticEntryDiscards=mscVrPpFddiETBStaticEntryDiscards, mscVrPpFddiETBNsProvEntry=mscVrPpFddiETBNsProvEntry, mscVrPpSrBpStaticDiscards=mscVrPpSrBpStaticDiscards, mscVrPpSrtBpLanId=mscVrPpSrtBpLanId, mscVrPpTbsgBadAbstractDiscards=mscVrPpTbsgBadAbstractDiscards, mscVrPpTbclStateTable=mscVrPpTbclStateTable, mscVrBrIndex=mscVrBrIndex, mscVrBrTbNcFtePeerAddressInfo=mscVrBrTbNcFtePeerAddressInfo, mscVrPpTbpDesignatedCost=mscVrPpTbpDesignatedCost, mscVrPpTbsgBlockingDiscards=mscVrPpTbsgBlockingDiscards, mscVrPpTbclTbOperEntry=mscVrPpTbclTbOperEntry, mscVrPpFddiETBConvertArpMacAddress=mscVrPpFddiETBConvertArpMacAddress, mscVrPpTbclTinygramFramesIn=mscVrPpTbclTinygramFramesIn, mscVrPpFddiETBOperStatusEntry=mscVrPpFddiETBOperStatusEntry, mscVrPpSrseOperStatusTable=mscVrPpSrseOperStatusTable, mscVrPpSrsgPortStateStpControl=mscVrPpSrsgPortStateStpControl, mscVrPpTbsgRowStatusTable=mscVrPpTbsgRowStatusTable, mscVrPpTbsgStpOperEntry=mscVrPpTbsgStpOperEntry, mscPBOperationalState=mscPBOperationalState, mscVrPpSrBpTinygramFramesIn=mscVrPpSrBpTinygramFramesIn, mscVrPpTbsg=mscVrPpTbsg, mscVrBrNsAteEntryNumberIndex=mscVrBrNsAteEntryNumberIndex, mscVrPpFddiETBAdminState=mscVrPpFddiETBAdminState, mscVrPpTbclStpTypeOper=mscVrPpTbclStpTypeOper, mscVrPpSrBpPathCostMethod=mscVrPpSrBpPathCostMethod, mscVrPpSrtBpOperStatusTable=mscVrPpSrtBpOperStatusTable, mscVrPpSrseDupLanIdOrTreeErrors=mscVrPpSrseDupLanIdOrTreeErrors, mscVrPpSrseHopCount=mscVrPpSrseHopCount, mscVrPpSrclSteInFrames=mscVrPpSrclSteInFrames, mscVrPpTbclDIProvTable=mscVrPpTbclDIProvTable, mscVrPpSrBpOperationalState=mscVrPpSrBpOperationalState, mscVrPpSrseSteRdLimit=mscVrPpSrseSteRdLimit, mscVrPpSrBpPortNum=mscVrPpSrBpPortNum, mscCBSnmpAdminStatus=mscCBSnmpAdminStatus, mscCBIfEntryEntry=mscCBIfEntryEntry)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-BridgeMIB", mscVrBrAdminStatus=mscVrBrAdminStatus, mscVrPpSrBpProvTable=mscVrPpSrBpProvTable, mscVrPpSrBpDelayExceededDiscards=mscVrPpSrBpDelayExceededDiscards, mscVrPpTbsePathCost=mscVrPpTbsePathCost, mscVrPpTbpDIProvEntry=mscVrPpTbpDIProvEntry, mscVrPpSrclPortNum=mscVrPpSrclPortNum, mscVrPpFddiETBUsageState=mscVrPpFddiETBUsageState, mscVrPpSrsgDIProvEntry=mscVrPpSrsgDIProvEntry, mscVrPpSrsgPreserveDomain=mscVrPpSrsgPreserveDomain, mscVrPpTbsgDIProvTable=mscVrPpTbsgDIProvTable, mscVrPpTbclPathCost=mscVrPpTbclPathCost, mscVrPpSrtBpConvertArpMacAddress=mscVrPpSrtBpConvertArpMacAddress, mscVrBrTbSteProvTable=mscVrBrTbSteProvTable, mscVrPpSrtBpInFilterDiscards=mscVrPpSrtBpInFilterDiscards, mscVrPpTbsgAdminStatus=mscVrPpTbsgAdminStatus, mscVrPpSrBpStpProvEntry=mscVrPpSrBpStpProvEntry, mscVrPpSrtBpSrStatsTable=mscVrPpSrtBpSrStatsTable, mscVrPpSrsgPortName=mscVrPpSrsgPortName, mscVrPpTbsgStpTypeProv=mscVrPpTbsgStpTypeProv, mscVrPpFddiETBBridgePortType=mscVrPpFddiETBBridgePortType, mscVrPpSrtBpNsIncomingFilter=mscVrPpSrtBpNsIncomingFilter, mscVrPpSrclSpecOutFrames=mscVrPpSrclSpecOutFrames, mscVrPpFddiETBStateTable=mscVrPpFddiETBStateTable, mscVrBrOperStatusEntry=mscVrBrOperStatusEntry, mscVrPpSrBpSteSpanMode=mscVrPpSrBpSteSpanMode, mscVrPpSrtBpDynamicDiscards=mscVrPpSrtBpDynamicDiscards, mscVrPpTbsePathCostOper=mscVrPpTbsePathCostOper, mscVrBrSrbLteStorageType=mscVrBrSrbLteStorageType, mscVrPpSrBpStpTypeProv=mscVrPpSrBpStpTypeProv, mscVrPpFddiETBInFilterDiscards=mscVrPpFddiETBInFilterDiscards, mscVrPpSrsgSteRdLimit=mscVrPpSrsgSteRdLimit, mscVrBrSrbStpPriority=mscVrBrSrbStpPriority, mscVrPpSrtBpPortPriority=mscVrPpSrtBpPortPriority, mscVrPpSrtBpNsIndex=mscVrPpSrtBpNsIndex, mscVrPpSrclNsStorageType=mscVrPpSrclNsStorageType, mscVrPpFddiETBForwardTransitions=mscVrPpFddiETBForwardTransitions, mscVrPpSrtBpUnicastNoMatches=mscVrPpSrtBpUnicastNoMatches, mscVrPpTbsgDownTime=mscVrPpTbsgDownTime, mscVrBrTbRowStatusEntry=mscVrBrTbRowStatusEntry, mscVrPpTbseDesignatedCost=mscVrPpTbseDesignatedCost, mscVrPpSrseUpTime=mscVrPpSrseUpTime, mscVrPpTbsgSnmpOperStatus=mscVrPpTbsgSnmpOperStatus, mscVrPpTbclBridgePortConfig=mscVrPpTbclBridgePortConfig, mscVrPpTbclStpProvTable=mscVrPpTbclStpProvTable, mscVrPpFddiETBStateEntry=mscVrPpFddiETBStateEntry, mscVrBrSrbLteOperTable=mscVrBrSrbLteOperTable, mscVrPpSrseBlockingDiscards=mscVrPpSrseBlockingDiscards, mscVrPpSrBpBridgingMode=mscVrPpSrBpBridgingMode, mscVrPpSrsgDIProvTable=mscVrPpSrsgDIProvTable, mscVrPpSrseProvEntry=mscVrPpSrseProvEntry, mscVrPpFddiETBDomainNum=mscVrPpFddiETBDomainNum, mscVrPpTbpPortStateStpControl=mscVrPpTbpPortStateStpControl, mscVrPpSrsgSteSpanMode=mscVrPpSrsgSteSpanMode, mscVrPpTbsgTbProvTable=mscVrPpTbsgTbProvTable, mscVrBrSrbNumLanIdtEntriesDenied=mscVrBrSrbNumLanIdtEntriesDenied, mscCBAdminState=mscCBAdminState, mscVrPpSrBpServiceClass=mscVrPpSrBpServiceClass, mscVrPpTbsgDesignatedCost=mscVrPpTbsgDesignatedCost, mscVrPpFddiETBStpOperTable=mscVrPpFddiETBStpOperTable, mscVrPpSrtBpAdminStatus=mscVrPpSrtBpAdminStatus, mscVrPpTbsgTinygramFramesIn=mscVrPpTbsgTinygramFramesIn, mscVrPpFddiETBProvEntry=mscVrPpFddiETBProvEntry, mscVrBrTbSteAtgtEntry=mscVrBrTbSteAtgtEntry, mscVrPpSrclProvTable=mscVrPpSrclProvTable, mscVrBrTbIndex=mscVrBrTbIndex, mscVrBrTbNcFteRowStatusEntry=mscVrBrTbNcFteRowStatusEntry, mscVrPpSrBp=mscVrPpSrBp, mscVrBrSrbTotalLanIdTableEntries=mscVrBrSrbTotalLanIdTableEntries, mscVrBrTbStp=mscVrBrTbStp, mscVrPpTbsgSecureOption=mscVrPpTbsgSecureOption, mscCBIfEntryTable=mscCBIfEntryTable, mscVrPpTbclProvEntry=mscVrPpTbclProvEntry, mscVrBrSrbAgingTime=mscVrBrSrbAgingTime, mscVrPpSrseConvertArpMacAddress=mscVrPpSrseConvertArpMacAddress, mscVrPpTbseLearningDiscards=mscVrPpTbseLearningDiscards, mscVrBrNsAteRowStatusEntry=mscVrBrNsAteRowStatusEntry, mscVrPpTbseAdminState=mscVrPpTbseAdminState, mscVrPpTbclNsRowStatusTable=mscVrPpTbclNsRowStatusTable, mscVrPpSrtBpAreRdLimit=mscVrPpSrtBpAreRdLimit, mscVrBrTbSteAtgtValue=mscVrBrTbSteAtgtValue, mscVrPpSrBpRowStatusEntry=mscVrPpSrBpRowStatusEntry, mscVrPpTbpFragmentIp=mscVrPpTbpFragmentIp, mscVrPpTbclStpPortState=mscVrPpTbclStpPortState, mscVrBrRowStatusTable=mscVrBrRowStatusTable, mscVrBrNumPorts=mscVrBrNumPorts, mscVrBrSrbStpBridgeForwardDelay=mscVrBrSrbStpBridgeForwardDelay, mscVrPpSrclInFilterDiscards=mscVrPpSrclInFilterDiscards, mscVrBrComponentName=mscVrBrComponentName, mscVrBrOperEntry=mscVrBrOperEntry, mscVrPpSrseSrProvEntry=mscVrPpSrseSrProvEntry, mscVrPpSrclRowStatusTable=mscVrPpSrclRowStatusTable, mscVrBrAdminState=mscVrBrAdminState, mscVrBrSrbStpFwdDelay=mscVrBrSrbStpFwdDelay, mscVrPpSrsgStpTypeProv=mscVrPpSrsgStpTypeProv, mscVrBrTbNcFteComponentName=mscVrBrTbNcFteComponentName, mscVrPpSrclSteSpanMode=mscVrPpSrclSteSpanMode, mscVrPpTbsgMaxInfo=mscVrPpTbsgMaxInfo, mscVrPpSrBpPreserveDomain=mscVrPpSrBpPreserveDomain, mscVrPpTbsgPortPriority=mscVrPpTbsgPortPriority, mscVrPpTbclNsRowStatusEntry=mscVrPpTbclNsRowStatusEntry, mscVrPpTbsgIfIndex=mscVrPpTbsgIfIndex, mscVrPpSrclRowStatus=mscVrPpSrclRowStatus, mscVrPpSrBpDIProvEntry=mscVrPpSrBpDIProvEntry, mscVrPpSrBpHopCountExceededDiscards=mscVrPpSrBpHopCountExceededDiscards, mscVrPpTbpDelayExceededDiscards=mscVrPpTbpDelayExceededDiscards, mscVrPpSrseMtuExceededDiscards=mscVrPpSrseMtuExceededDiscards, mscVrPpTbseStpProvTable=mscVrPpTbseStpProvTable, mscVrPpTbseDesignatedRoot=mscVrPpTbseDesignatedRoot, mscVrBrTbFteRowStatus=mscVrBrTbFteRowStatus, mscVrBrSrbStpBridgeMaxAge=mscVrBrSrbStpBridgeMaxAge, mscVrPpSrseExploreFrameTreatment=mscVrPpSrseExploreFrameTreatment, mscPBOperEntry=mscPBOperEntry, mscVrPpSrtBpOutFilterDiscards=mscVrPpSrtBpOutFilterDiscards, mscVrPpSrtBpRowStatus=mscVrPpSrtBpRowStatus, mscVrPpFddiETBOperEntry=mscVrPpFddiETBOperEntry, mscVrPpSrBpNs=mscVrPpSrBpNs, mscVrPpTbsgBridgePortConfig=mscVrPpTbsgBridgePortConfig, mscVrBrBridgeAddress=mscVrBrBridgeAddress, mscVrPpSrBpBridgeNum=mscVrPpSrBpBridgeNum, mscVrPpSrclNs=mscVrPpSrclNs, mscVrPpSrsgPathCost=mscVrPpSrsgPathCost, mscVrPpSrseLargestFrame=mscVrPpSrseLargestFrame, mscVrPpSrBpConvertArpMacAddress=mscVrPpSrBpConvertArpMacAddress, mscVrPpSrtBpHopCountExceededDiscards=mscVrPpSrtBpHopCountExceededDiscards, mscVrPpSrclNsProvEntry=mscVrPpSrclNsProvEntry, mscVrBrTbFteStatus=mscVrBrTbFteStatus, mscCBUsageState=mscCBUsageState, mscVrBrNsRowStatus=mscVrBrNsRowStatus, mscVrPpTbclDesignatedCost=mscVrPpTbclDesignatedCost, mscVrPpSrsgRowStatusTable=mscVrPpSrsgRowStatusTable, mscVrPpSrsgApeInFrames=mscVrPpSrsgApeInFrames, mscVrBrTbStpBridgeHelloTime=mscVrBrTbStpBridgeHelloTime, mscVrPpTbpStatsEntry=mscVrPpTbpStatsEntry, mscVrPpFddiETBStatsEntry=mscVrPpFddiETBStatsEntry, mscVrPpSrseBridgeNum=mscVrPpSrseBridgeNum, mscVrPpFddiETBNsStorageType=mscVrPpFddiETBNsStorageType, mscVrPpSrclSnmpOperStatus=mscVrPpSrclSnmpOperStatus, mscVrPpSrclStaticDiscards=mscVrPpSrclStaticDiscards, mscVrPpSrseTinygramFramesIn=mscVrPpSrseTinygramFramesIn, mscVrBrNsAteFilterName=mscVrBrNsAteFilterName, mscVrBrSrbLteRowStatus=mscVrBrSrbLteRowStatus, mscVrPpSrseOperEntry=mscVrPpSrseOperEntry, mscVrPpSrsgDesignatedRoot=mscVrPpSrsgDesignatedRoot, mscVrPpTbsgIndex=mscVrPpTbsgIndex, mscVrPpSrtBpNsStorageType=mscVrPpSrtBpNsStorageType, mscVrPpSrclLanIdMismatches=mscVrPpSrclLanIdMismatches, mscVrBrTbStpRowStatusTable=mscVrBrTbStpRowStatusTable, mscPBIfAdminStatus=mscPBIfAdminStatus, mscVrPpTbseOperationalState=mscVrPpTbseOperationalState, mscVrPpTbclNsComponentName=mscVrPpTbclNsComponentName, mscVrPpSrseStpPortState=mscVrPpSrseStpPortState, mscVrPpTbsgPathCost=mscVrPpTbsgPathCost, mscVrPpTbseDownTime=mscVrPpTbseDownTime, mscVrPpFddiETBRowStatusTable=mscVrPpFddiETBRowStatusTable, mscVrPpTbclStpOperTable=mscVrPpTbclStpOperTable, mscVrPpSrtBpSecureOption=mscVrPpSrtBpSecureOption, mscVrPpSrBpOutFilterDiscards=mscVrPpSrBpOutFilterDiscards, mscVrPpTbsgStatsEntry=mscVrPpTbsgStatsEntry, mscVrPpSrtBpStatsTable=mscVrPpSrtBpStatsTable, mscVrPpSrtBpOperEntry=mscVrPpSrtBpOperEntry, mscVrPpFddiETBAdminStatus=mscVrPpFddiETBAdminStatus, mscVrPpTbclRowStatusEntry=mscVrPpTbclRowStatusEntry, mscVrBrTbNcFteDomainNumIndex=mscVrBrTbNcFteDomainNumIndex, mscVrPpSrsgBridgingMode=mscVrPpSrsgBridgingMode, mscVrBrRowStatus=mscVrBrRowStatus, mscVrBrSrbLtePortName=mscVrBrSrbLtePortName, mscVrPpSrtBpInFrames=mscVrPpSrtBpInFrames, mscPBComponentName=mscPBComponentName, mscVrPpSrsgHopCount=mscVrPpSrsgHopCount, mscVrPpSrBpStpOperEntry=mscVrPpSrBpStpOperEntry, mscVrBrTbSteAtgtTable=mscVrBrTbSteAtgtTable, mscVrBrSrbStatsEntry=mscVrBrSrbStatsEntry, mscVrPpTbseAdminStatus=mscVrPpTbseAdminStatus, mscVrPpSrseIndex=mscVrPpSrseIndex, mscVrPpSrsgIndex=mscVrPpSrsgIndex, mscVrPpTbclNs=mscVrPpTbclNs, mscVrPpSrtBp=mscVrPpSrtBp, mscVrPpFddiETBBridgingMode=mscVrPpFddiETBBridgingMode, mscVrPpTbsgTbProvEntry=mscVrPpTbsgTbProvEntry, mscVrBrTbNcFteStatus=mscVrBrTbNcFteStatus, mscVrPpTbclServiceClass=mscVrPpTbclServiceClass, mscVrPpSrtBpDesignatedCost=mscVrPpSrtBpDesignatedCost, mscVrBrSrbStpBridgeId=mscVrBrSrbStpBridgeId, mscVrBrPteFilterPoints=mscVrBrPteFilterPoints, mscVrPpTbpStateTable=mscVrPpTbpStateTable, mscVrPpTbpSnmpOperStatus=mscVrPpTbpSnmpOperStatus, mscVrPpSrclPathCostOper=mscVrPpSrclPathCostOper, mscVrBrPteOperTable=mscVrBrPteOperTable, mscVrPpFddiETBDesignatedRoot=mscVrPpFddiETBDesignatedRoot, mscVrPpSrBpNsComponentName=mscVrPpSrBpNsComponentName, mscVrBrTbStpBridgeId=mscVrBrTbStpBridgeId, mscVrPpFddiETBTranslateIpx=mscVrPpFddiETBTranslateIpx, mscVrBrSrbStpHelloTime=mscVrBrSrbStpHelloTime, mscVrPpTbseInFrames=mscVrPpTbseInFrames, mscVrPpSrtBpDelayExceededDiscards=mscVrPpSrtBpDelayExceededDiscards, mscVrPpTbclDIProvEntry=mscVrPpTbclDIProvEntry, mscVrPpTbclAdminState=mscVrPpTbclAdminState, mscVrPpSrBpStpProvTable=mscVrPpSrBpStpProvTable, mscVrBrSrbStpTimeSinceTopologyChange=mscVrBrSrbStpTimeSinceTopologyChange, mscVrBrSrbLteAgeOfEntry=mscVrBrSrbLteAgeOfEntry, mscVrPpSrclSegmentMismatchDiscards=mscVrPpSrclSegmentMismatchDiscards, mscVrPpSrBpRowStatus=mscVrPpSrBpRowStatus, mscVrPpSrclStpPortState=mscVrPpSrclStpPortState, mscVrPpFddiETBRowStatus=mscVrPpFddiETBRowStatus, mscVrPpTbseOperStatusTable=mscVrPpTbseOperStatusTable, mscVrPpTbpNsOutgoingFilter=mscVrPpTbpNsOutgoingFilter, mscVrPpTbp=mscVrPpTbp, mscPBMpEntry=mscPBMpEntry, mscVrBrSrbStpProtocolSpec=mscVrBrSrbStpProtocolSpec, mscVrPpTbclStpTypeProv=mscVrPpTbclStpTypeProv, mscVrPpFddiETBNsIndex=mscVrPpFddiETBNsIndex, mscVrPpSrcl=mscVrPpSrcl, mscVrPpSrclStateEntry=mscVrPpSrclStateEntry, mscVrPpSrseDesignatedRoot=mscVrPpSrseDesignatedRoot, mscVrPpSrseDesignatedBridge=mscVrPpSrseDesignatedBridge, mscVrPpSrseDesignatedPort=mscVrPpSrseDesignatedPort, mscVrBrPteStpType=mscVrBrPteStpType, mscVrBrPteMacType=mscVrBrPteMacType, mscVrBrTbNumFtEntriesFree=mscVrBrTbNumFtEntriesFree, mscVrPpTbclInDiscards=mscVrPpTbclInDiscards, mscVrBrStateTable=mscVrBrStateTable, mscVrPpTbclOperationalState=mscVrPpTbclOperationalState, mscVrBrTbFteDomainNumIndex=mscVrBrTbFteDomainNumIndex, mscVrPpTbpDownTime=mscVrPpTbpDownTime, mscVrBrSrbStpTopologyChangeDetect=mscVrBrSrbStpTopologyChangeDetect, bridgeCapabilities=bridgeCapabilities, mscVrPpTbpUpTime=mscVrPpTbpUpTime, mscVrPpTbsgStpOperTable=mscVrPpTbsgStpOperTable, mscVrPpTbclDownTime=mscVrPpTbclDownTime, mscVrPpSrBpDupSegmentDiscards=mscVrPpSrBpDupSegmentDiscards, mscVrPpTbpOutFilterDiscards=mscVrPpTbpOutFilterDiscards, mscVrBrTbStpTopologyChangeDetect=mscVrBrTbStpTopologyChangeDetect, mscVrPpFddiETBPortName=mscVrPpFddiETBPortName, mscVrBrNsFirstFilter=mscVrBrNsFirstFilter, mscVrBrPteModeIndex=mscVrBrPteModeIndex, mscVrPpFddiETBNsComponentName=mscVrPpFddiETBNsComponentName, mscVrPpSrBpSrProvEntry=mscVrPpSrBpSrProvEntry, mscVrPpFddiETBDesignatedPort=mscVrPpFddiETBDesignatedPort, mscVrPpSrtBpLearningDiscards=mscVrPpSrtBpLearningDiscards, mscVrPpTbseSnmpOperStatus=mscVrPpTbseSnmpOperStatus, mscVrBrSrbLteOperEntry=mscVrBrSrbLteOperEntry, mscVrPpSrBpStpPortState=mscVrPpSrBpStpPortState, mscVrPpSrtBpStpOperTable=mscVrPpSrtBpStpOperTable, mscVrPpTbpDynamicEntryDiscards=mscVrPpTbpDynamicEntryDiscards, mscVrPpSrtBpBadAbstractDiscards=mscVrPpSrtBpBadAbstractDiscards, mscVrPpTbclNsProvEntry=mscVrPpTbclNsProvEntry, mscVrPpSrsePortStateStpControl=mscVrPpSrsePortStateStpControl, mscVrBrNsAteDomainNum=mscVrBrNsAteDomainNum, mscVrPpSrseStatsTable=mscVrPpSrseStatsTable, mscCBAdminControlTable=mscCBAdminControlTable, mscVrPpSrsgTinygramFramesOut=mscVrPpSrsgTinygramFramesOut, mscVrPpTbclComponentName=mscVrPpTbclComponentName, mscVrPpSrtBpTbProvEntry=mscVrPpSrtBpTbProvEntry, mscVrPpTbsgOutFrames=mscVrPpTbsgOutFrames)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-BridgeMIB", mscVrPpSrclTranslateIpx=mscVrPpSrclTranslateIpx, mscVrBrNsStorageType=mscVrBrNsStorageType, mscVrPpSrseStorageType=mscVrPpSrseStorageType, mscVrPpSrtBpHopCount=mscVrPpSrtBpHopCount, mscVrPpFddiETBPortNum=mscVrPpFddiETBPortNum, mscVrPpTbclIfIndex=mscVrPpTbclIfIndex, mscVrBrTbFteAgeOfEntry=mscVrBrTbFteAgeOfEntry, mscVrPpTbsgPreserveDomain=mscVrPpTbsgPreserveDomain, mscVrPpSrtBpFragmentIp=mscVrPpSrtBpFragmentIp, mscVrPpSrsePathCost=mscVrPpSrsePathCost, mscVrPpTbclProvTable=mscVrPpTbclProvTable, mscVrPpSrBpSteRdLimit=mscVrPpSrBpSteRdLimit, mscVrPpSrtBpStpPortState=mscVrPpSrtBpStpPortState, mscVrPpFddiETBComponentName=mscVrPpFddiETBComponentName, mscVrPpSrseDelayExceededDiscards=mscVrPpSrseDelayExceededDiscards, mscVrPpFddiETBDesignatedCost=mscVrPpFddiETBDesignatedCost, mscVrPpTbpNsIndex=mscVrPpTbpNsIndex, mscVrPpTbpUsageState=mscVrPpTbpUsageState, mscVrPpSrseSegmentMismatchDiscards=mscVrPpSrseSegmentMismatchDiscards, mscVrPpTbsgStorageType=mscVrPpTbsgStorageType, mscVrBrPteSpOperEntry=mscVrBrPteSpOperEntry, mscVrPpSrBpTinygramFramesOut=mscVrPpSrBpTinygramFramesOut, mscVrPpTbpPathCostMethod=mscVrPpTbpPathCostMethod, mscVrPpSrclRowStatusEntry=mscVrPpSrclRowStatusEntry, mscVrBrTbStpFwdDelay=mscVrBrTbStpFwdDelay, mscVrPpTbsgPortStateStpControl=mscVrPpTbsgPortStateStpControl, mscVrPpSrclIfIndex=mscVrPpSrclIfIndex, mscVrPpTbclIndex=mscVrPpTbclIndex, mscVrPpFddiETBPortStateStpControl=mscVrPpFddiETBPortStateStpControl, mscVrPpTbpDIProvTable=mscVrPpTbpDIProvTable, mscVrPpSrBpNsProvEntry=mscVrPpSrBpNsProvEntry, mscVrPpSrtBpNsRowStatusEntry=mscVrPpSrtBpNsRowStatusEntry, mscVrPpTbpRowStatus=mscVrPpTbpRowStatus, mscVrPpSrclComponentName=mscVrPpSrclComponentName, mscVrBrNsAteDirection=mscVrBrNsAteDirection, mscPBOperTable=mscPBOperTable, mscVrBrPte=mscVrBrPte, bridgeCapabilitiesCA=bridgeCapabilitiesCA, mscVrPpSrtBpOperTable=mscVrPpSrtBpOperTable, mscVrBrPteBridgeNum=mscVrBrPteBridgeNum, mscVrPpTbclRowStatus=mscVrPpTbclRowStatus, mscVrPpSrtBpPreserveDomain=mscVrPpSrtBpPreserveDomain, mscVrPpTbpBadAbstractDiscards=mscVrPpTbpBadAbstractDiscards, mscVrPpTbpNsProvEntry=mscVrPpTbpNsProvEntry, mscVrPpTbclBlockingDiscards=mscVrPpTbclBlockingDiscards, mscVrPpSrsgDesignatedBridge=mscVrPpSrsgDesignatedBridge, mscVrPpTbsgDesignatedPort=mscVrPpTbsgDesignatedPort, mscVrPpTbsgProvEntry=mscVrPpTbsgProvEntry, mscVrBrTbSteRowStatusEntry=mscVrBrTbSteRowStatusEntry, mscVrBrTbFteOperEntry=mscVrBrTbFteOperEntry, mscVrPpTbseProvTable=mscVrPpTbseProvTable, mscVrBrTbStpBridgeMaxAge=mscVrBrTbStpBridgeMaxAge, mscVrBrTbStpProtocolSpec=mscVrBrTbStpProtocolSpec, mscVrBrTbSte=mscVrBrTbSte, mscVrPpTbpPreserveDomain=mscVrPpTbpPreserveDomain, mscCBRowStatus=mscCBRowStatus, mscVrPpSrseBridgePortConfig=mscVrPpSrseBridgePortConfig, mscVrPpTbpDomainNum=mscVrPpTbpDomainNum, mscVrPpTbseUpTime=mscVrPpTbseUpTime, mscCBComponentName=mscCBComponentName, mscVrBrTbFteRowStatusTable=mscVrBrTbFteRowStatusTable, mscVrPpSrseDynamicDiscards=mscVrPpSrseDynamicDiscards, mscVrPpSrBpProvEntry=mscVrPpSrBpProvEntry, mscVrPpSrclUsageState=mscVrPpSrclUsageState, mscVrBrNsComponentName=mscVrBrNsComponentName, mscVrPpTbseConvertArpMacAddress=mscVrPpTbseConvertArpMacAddress, mscVrPpSrtBpProvEntry=mscVrPpSrtBpProvEntry, mscVrBrSrbStpIndex=mscVrBrSrbStpIndex, mscVrPpSrBpOperStatusEntry=mscVrPpSrBpOperStatusEntry, mscVrPpSrclConvertArpMacAddress=mscVrPpSrclConvertArpMacAddress, mscVrPpSrclDownTime=mscVrPpSrclDownTime, mscVrPpSrclDupSegmentDiscards=mscVrPpSrclDupSegmentDiscards, mscPBSnmpOperStatus=mscPBSnmpOperStatus, mscVrBrTbStpOperTable=mscVrBrTbStpOperTable, mscCBStorageType=mscCBStorageType, mscVrPpTbsgUsageState=mscVrPpTbsgUsageState, mscVrPpTbclOutFrames=mscVrPpTbclOutFrames, mscVrBrTbSteStatus=mscVrBrTbSteStatus, mscVrPpSrseOperationalState=mscVrPpSrseOperationalState, mscVrPpSrsgAreRdLimit=mscVrPpSrsgAreRdLimit, mscVrPpTbseTbOperTable=mscVrPpTbseTbOperTable, mscVrPpSrclAreRdLimit=mscVrPpSrclAreRdLimit, mscVrBrTbStorageType=mscVrBrTbStorageType, mscVrPpTbsgDomainNum=mscVrPpTbsgDomainNum, mscVrPpSrclSrProvTable=mscVrPpSrclSrProvTable, mscPBStorageType=mscPBStorageType, mscVrPpTbclStateEntry=mscVrPpTbclStateEntry, mscVrBrNsProvTable=mscVrBrNsProvTable, mscVrPpSrtBpSteOutFrames=mscVrPpSrtBpSteOutFrames, mscVrPpTbseServiceClass=mscVrPpTbseServiceClass, mscVrPpSrBpDIProvTable=mscVrPpSrBpDIProvTable, mscVrPpSrseStpTypeProv=mscVrPpSrseStpTypeProv, mscVrBrPteComponentName=mscVrBrPteComponentName, mscVrPpTbseBadVerifyDiscards=mscVrPpTbseBadVerifyDiscards, mscVrPpTbseStateEntry=mscVrPpTbseStateEntry, mscVrPpTbseTinygramFramesIn=mscVrPpTbseTinygramFramesIn, mscVrPpTbsgBridgingMode=mscVrPpTbsgBridgingMode, mscPBIfIndex=mscPBIfIndex, mscVrPpTbsgOperTable=mscVrPpTbsgOperTable, mscVrPpTbpPathCost=mscVrPpTbpPathCost, mscVrBrNsIndex=mscVrBrNsIndex, mscVrPpTbclTbProvEntry=mscVrPpTbclTbProvEntry, mscVrPpTbclSnmpOperStatus=mscVrPpTbclSnmpOperStatus, mscVrPpTbseStpTypeProv=mscVrPpTbseStpTypeProv, mscVrPpTbsgStpProvEntry=mscVrPpTbsgStpProvEntry, mscVrPpSrsgOperStatusEntry=mscVrPpSrsgOperStatusEntry, mscVrBrPteSpOperTable=mscVrBrPteSpOperTable, mscVrPpSrBpOperTable=mscVrPpSrBpOperTable, mscVrPpSrBpBlockingDiscards=mscVrPpSrBpBlockingDiscards, mscVrPpTbpStorageType=mscVrPpTbpStorageType, mscVrPpTbclNsOutgoingFilter=mscVrPpTbclNsOutgoingFilter, mscVrBrTbStpRowStatus=mscVrBrTbStpRowStatus, mscVrPpSrtBpBridgePortConfig=mscVrPpSrtBpBridgePortConfig, mscVrBrTbFwdTableNumEntries=mscVrBrTbFwdTableNumEntries, mscVrBrTbNcFteStorageType=mscVrBrTbNcFteStorageType, mscVrPpSrBpDesignatedRoot=mscVrPpSrBpDesignatedRoot, mscVrPpSrclStpOperEntry=mscVrPpSrclStpOperEntry, mscVrPpSrseDIProvEntry=mscVrPpSrseDIProvEntry, mscVrPpSrseOutFilterDiscards=mscVrPpSrseOutFilterDiscards, mscVrPpTbsgBadVerifyDiscards=mscVrPpTbsgBadVerifyDiscards, mscVrPpTbsgStatsTable=mscVrPpTbsgStatsTable, mscPBLinkToProtocolPort=mscPBLinkToProtocolPort, mscVrPpFddiETBOutFrames=mscVrPpFddiETBOutFrames, mscVrBrNsAteStorageType=mscVrBrNsAteStorageType, mscVrPpSrsgConvertArpMacAddress=mscVrPpSrsgConvertArpMacAddress, mscVrPpSrtBpApeInFrames=mscVrPpSrtBpApeInFrames, mscVrPpTbseTinygramFramesOut=mscVrPpTbseTinygramFramesOut, mscVrPpSrBpIfIndex=mscVrPpSrBpIfIndex, mscVrPpFddiETBStpProvEntry=mscVrPpFddiETBStpProvEntry, mscCBSnmpOperStatus=mscCBSnmpOperStatus, mscVrPpSrBpDesignatedCost=mscVrPpSrBpDesignatedCost, mscVrPpSrsgAdminState=mscVrPpSrsgAdminState, mscVrPpSrBpInFilterDiscards=mscVrPpSrBpInFilterDiscards, mscVrPpSrtBpStpTypeOper=mscVrPpSrtBpStpTypeOper, mscVrPpTbpNsStorageType=mscVrPpTbpNsStorageType, mscVrPpTbclOperStatusTable=mscVrPpTbclOperStatusTable, mscVrPpTbseRowStatus=mscVrPpTbseRowStatus, mscVrPpTbpStaticEntryDiscards=mscVrPpTbpStaticEntryDiscards, mscVrPpSrsgMtuExceededDiscards=mscVrPpSrsgMtuExceededDiscards, mscVrPpSrtBpLanIdMismatches=mscVrPpSrtBpLanIdMismatches, mscVrPpTbsgDesignatedBridge=mscVrPpTbsgDesignatedBridge, mscVrPpSrclPortPriority=mscVrPpSrclPortPriority, mscVrPpTbsgTinygramFramesOut=mscVrPpTbsgTinygramFramesOut, mscVrPpSrtBpBridgePortType=mscVrPpSrtBpBridgePortType, mscVrBrSrbProvEntry=mscVrBrSrbProvEntry, mscVrBrTbFte=mscVrBrTbFte, mscVrPpSrseStpProvEntry=mscVrPpSrseStpProvEntry, mscVrPpFddiETBStpPortState=mscVrPpFddiETBStpPortState, mscVrPpTbseDesignatedBridge=mscVrPpTbseDesignatedBridge, mscVrPpSrBpStatsTable=mscVrPpSrBpStatsTable, mscVrPpSrsg=mscVrPpSrsg, mscVrPpSrsgSpecOutFrames=mscVrPpSrsgSpecOutFrames, mscVrPpSrBpLanIdMismatches=mscVrPpSrBpLanIdMismatches, mscVrPpSrclIndex=mscVrPpSrclIndex, mscCBLinkToProtocolPort=mscCBLinkToProtocolPort, mscVrPpSrtBpNsRowStatus=mscVrPpSrtBpNsRowStatus, mscVrPpSrsgPortPriority=mscVrPpSrsgPortPriority, mscVrPpSrsgStpTypeOper=mscVrPpSrsgStpTypeOper, mscCBRowStatusEntry=mscCBRowStatusEntry, mscVrPpTbsgStateEntry=mscVrPpTbsgStateEntry, mscVrPpSrclDIProvTable=mscVrPpSrclDIProvTable, mscVrPpSrtBpNsOutgoingFilter=mscVrPpSrtBpNsOutgoingFilter, mscVrPpSrsgTranslateIpx=mscVrPpSrsgTranslateIpx, mscVrBrTbNcFteAgeOfEntry=mscVrBrTbNcFteAgeOfEntry, mscVrPpSrBpNsIndex=mscVrPpSrBpNsIndex, mscVrPpSrclLargestFrame=mscVrPpSrclLargestFrame, mscVrPpTbclPortPriority=mscVrPpTbclPortPriority, mscVrPpFddiETBUnicastNoMatches=mscVrPpFddiETBUnicastNoMatches, mscVrPpSrBpDesignatedPort=mscVrPpSrBpDesignatedPort, mscVrPpSrBpNsProvTable=mscVrPpSrBpNsProvTable, mscVrPpFddiETBFragmentIp=mscVrPpFddiETBFragmentIp, mscVrPpSrseStpOperTable=mscVrPpSrseStpOperTable, mscVrPpFddiETBPortPriority=mscVrPpFddiETBPortPriority, mscVrBrNsAteRowStatusTable=mscVrBrNsAteRowStatusTable, mscVrBrPtePortPointsTo=mscVrBrPtePortPointsTo, mscVrPpTbclBridgingMode=mscVrPpTbclBridgingMode, mscVrPpFddiETBServiceClass=mscVrPpFddiETBServiceClass, mscVrPpTbsgProvTable=mscVrPpTbsgProvTable, mscVrPpSrtBpNsProvTable=mscVrPpSrtBpNsProvTable, mscPBUsageState=mscPBUsageState, mscVrPpSrtBpServiceClass=mscVrPpSrtBpServiceClass, mscVrBrTbStpTopologyChanges=mscVrBrTbStpTopologyChanges, mscVrBrTbStatsTable=mscVrBrTbStatsTable, mscVrPpSrtBpApeOutFrames=mscVrPpSrtBpApeOutFrames, mscVrBrTbFtePeerAddressInfo=mscVrBrTbFtePeerAddressInfo, mscVrPpFddiETBIfIndex=mscVrPpFddiETBIfIndex, mscVrPpSrseBadAbstractDiscards=mscVrPpSrseBadAbstractDiscards, mscVrPpTbpNsComponentName=mscVrPpTbpNsComponentName, mscVrPpTbclBadVerifyDiscards=mscVrPpTbclBadVerifyDiscards, mscPBSnmpAdminStatus=mscPBSnmpAdminStatus, mscVrPpSrtBpStaticEntryDiscards=mscVrPpSrtBpStaticEntryDiscards, mscVrPpSrseStateEntry=mscVrPpSrseStateEntry, mscVrPpSrsgStpProvTable=mscVrPpSrsgStpProvTable, mscVrBrTbSteStorageType=mscVrBrTbSteStorageType, mscVrPpSrtBpMaxInfo=mscVrPpSrtBpMaxInfo, mscVrPpTbpPortPriority=mscVrPpTbpPortPriority, mscPBAdminState=mscPBAdminState, mscVrPpTbseUsageState=mscVrPpTbseUsageState, mscVrPpTbpSecureOption=mscVrPpTbpSecureOption, mscVrPpTbpNsRowStatusEntry=mscVrPpTbpNsRowStatusEntry, mscVrPpSrBpStorageType=mscVrPpSrBpStorageType, mscVrPpSrseDesignatedCost=mscVrPpSrseDesignatedCost, mscVrPpSrtBpSteRdLimit=mscVrPpSrtBpSteRdLimit, mscVrBrNsLastFilter=mscVrBrNsLastFilter, mscVrBrSrbComponentName=mscVrBrSrbComponentName, mscCBRowStatusTable=mscCBRowStatusTable, mscVrPpTbsgInFilterDiscards=mscVrPpTbsgInFilterDiscards, mscVrPpSrclNsRowStatusTable=mscVrPpSrclNsRowStatusTable, mscVrPpTbseOperStatusEntry=mscVrPpTbseOperStatusEntry, mscVrPpSrclSpecInFrames=mscVrPpSrclSpecInFrames, mscVrPpFddiETBNsRowStatusEntry=mscVrPpFddiETBNsRowStatusEntry, mscVrPpTbclPortName=mscVrPpTbclPortName, mscVrBrSrbLanIdTableNumEntries=mscVrBrSrbLanIdTableNumEntries, mscVrPpTbclForwardTransitions=mscVrPpTbclForwardTransitions, mscVrPpFddiETBNsRowStatusTable=mscVrPpFddiETBNsRowStatusTable, mscVrBrTbStpHelloTime=mscVrBrTbStpHelloTime, mscVrPpSrsgInternalLanId=mscVrPpSrsgInternalLanId, mscVrBrTbStpHoldTime=mscVrBrTbStpHoldTime, mscVrPpTbseStpPortState=mscVrPpTbseStpPortState, mscVrPpSrtBpPathCostMethod=mscVrPpSrtBpPathCostMethod, mscVrPpTbpProvEntry=mscVrPpTbpProvEntry, mscVrPpSrseTranslateIpx=mscVrPpSrseTranslateIpx, mscVrPpSrseStpProvTable=mscVrPpSrseStpProvTable, mscVrPpSrseStpOperEntry=mscVrPpSrseStpOperEntry, mscVrPpTbsgServiceClass=mscVrPpTbsgServiceClass, mscVrBrPteLanId=mscVrBrPteLanId, bridgeGroupCA02=bridgeGroupCA02, mscVrPpTbclNsProvTable=mscVrPpTbclNsProvTable, mscVrPpSrclDomainNum=mscVrPpSrclDomainNum, mscVrPpSrclDesignatedPort=mscVrPpSrclDesignatedPort, mscVrBrSrbStpRootCost=mscVrBrSrbStpRootCost, mscVrPpTbpInDiscards=mscVrPpTbpInDiscards, mscVrPpSrclDynamicDiscards=mscVrPpSrclDynamicDiscards, mscVrPpSrseTinygramFramesOut=mscVrPpSrseTinygramFramesOut, mscVrPpFddiETBPathCostMethod=mscVrPpFddiETBPathCostMethod, mscVrPpTbclSecureOption=mscVrPpTbclSecureOption, mscVrPpTbclPathCostOper=mscVrPpTbclPathCostOper, mscVrPpSrBpPortPriority=mscVrPpSrBpPortPriority, mscVrPpTbpUnicastNoMatches=mscVrPpTbpUnicastNoMatches, mscVrPpTbclBadAbstractDiscards=mscVrPpTbclBadAbstractDiscards, mscVrPpSrBpBridgePortConfig=mscVrPpSrBpBridgePortConfig, mscVrPpSrtBpStateEntry=mscVrPpSrtBpStateEntry, mscVrPpTbpNsRowStatus=mscVrPpTbpNsRowStatus, mscVrPpFddiETBDownTime=mscVrPpFddiETBDownTime, mscVrPpSrBpForwardTransitions=mscVrPpSrBpForwardTransitions, mscVrPpSrtBpLargestFrame=mscVrPpSrtBpLargestFrame, mscVrPpTbsePortPriority=mscVrPpTbsePortPriority, mscVrPpTbseBridgePortType=mscVrPpTbseBridgePortType, mscVrBr=mscVrBr, mscVrPpSrtBpOperationalState=mscVrPpSrtBpOperationalState, mscVrPpSrsgOperStatusTable=mscVrPpSrsgOperStatusTable, mscVrPpTbpStpOperTable=mscVrPpTbpStpOperTable, mscVrPpSrclDIProvEntry=mscVrPpSrclDIProvEntry, mscVrPpFddiETBOperTable=mscVrPpFddiETBOperTable)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-BridgeMIB", mscVrPpSrclOperTable=mscVrPpSrclOperTable, mscVrPpSrtBpInDiscards=mscVrPpSrtBpInDiscards, mscVrPpFddiETBTinygramFramesOut=mscVrPpFddiETBTinygramFramesOut, mscVrPpTbpTinygramFramesOut=mscVrPpTbpTinygramFramesOut, mscVrPpSrsgExploreFrameTreatment=mscVrPpSrsgExploreFrameTreatment, mscVrPpTbclOperTable=mscVrPpTbclOperTable, mscVrPpTbclUsageState=mscVrPpTbclUsageState, mscVrPpFddiETBInDiscards=mscVrPpFddiETBInDiscards, mscVrPpTbpTbProvTable=mscVrPpTbpTbProvTable, mscVrPpSrsgBadAbstractDiscards=mscVrPpSrsgBadAbstractDiscards, mscVrBrTbProvEntry=mscVrBrTbProvEntry, mscVrPpTbpTranslateIpx=mscVrPpTbpTranslateIpx, mscVrPpSrBpNsRowStatus=mscVrPpSrBpNsRowStatus, mscVrPpSrsgDownTime=mscVrPpSrsgDownTime, mscVrPpSrtBpPathCostOper=mscVrPpSrtBpPathCostOper, mscVrPpSrBpPortStateStpControl=mscVrPpSrBpPortStateStpControl, mscVrPpSrclStpProvEntry=mscVrPpSrclStpProvEntry, mscVrPpTbpServiceClass=mscVrPpTbpServiceClass, mscVrPpSrclOperEntry=mscVrPpSrclOperEntry, mscVrBrPteRowStatusTable=mscVrBrPteRowStatusTable, mscVrPpSrse=mscVrPpSrse, mscVrPpSrsgDesignatedCost=mscVrPpSrsgDesignatedCost, mscVrPpSrclSrProvEntry=mscVrPpSrclSrProvEntry, mscVrBrTbSteAddressIndex=mscVrBrTbSteAddressIndex, mscVrPpSrclPortStateStpControl=mscVrPpSrclPortStateStpControl, mscVrBrTbLearnedEntryDiscards=mscVrBrTbLearnedEntryDiscards, mscVrPpTbpBridgePortConfig=mscVrPpTbpBridgePortConfig, mscVrPpSrBpBridgePortType=mscVrPpSrBpBridgePortType, mscVrPpTbseMaxInfo=mscVrPpTbseMaxInfo, mscVrPpTbsgStaticEntryDiscards=mscVrPpTbsgStaticEntryDiscards, mscVrPpSrseSnmpOperStatus=mscVrPpSrseSnmpOperStatus, mscVrBrTbTotalForwardingTableEntries=mscVrBrTbTotalForwardingTableEntries, mscVrPpSrclAdminStatus=mscVrPpSrclAdminStatus, mscVrPpTbseBlockingDiscards=mscVrPpTbseBlockingDiscards, mscVrBrSrbStpRowStatus=mscVrBrSrbStpRowStatus, mscVrPpTbseComponentName=mscVrPpTbseComponentName, mscVrPpSrsgRowStatusEntry=mscVrPpSrsgRowStatusEntry, mscVrPpSrsgDynamicDiscards=mscVrPpSrsgDynamicDiscards, mscVrPpSrclStpProvTable=mscVrPpSrclStpProvTable, mscVrBrNsAteSecondMacAddress=mscVrBrNsAteSecondMacAddress, mscVrPpSrclBridgingMode=mscVrPpSrclBridgingMode, mscVrPpTbpTbOperTable=mscVrPpTbpTbOperTable, mscVrPpSrtBpStaticDiscards=mscVrPpSrtBpStaticDiscards, mscVrPpSrseSrStatsTable=mscVrPpSrseSrStatsTable, mscVrPpTbseInDiscards=mscVrPpTbseInDiscards, mscVrPpSrclOperationalState=mscVrPpSrclOperationalState, mscVrPpSrBpIndex=mscVrPpSrBpIndex, mscVrPpSrclNsRowStatus=mscVrPpSrclNsRowStatus, mscVrPpTbseStorageType=mscVrPpTbseStorageType, mscVrPpTbclTranslateIpx=mscVrPpTbclTranslateIpx, mscVrBrTbSteAtgtRowStatus=mscVrBrTbSteAtgtRowStatus, mscVrPpSrseStateTable=mscVrPpSrseStateTable, mscVrPpSrBpNsRowStatusEntry=mscVrPpSrBpNsRowStatusEntry, mscPBRowStatusEntry=mscPBRowStatusEntry, mscVrPpTbclStatsTable=mscVrPpTbclStatsTable, mscVrPpSrtBpTbProvTable=mscVrPpSrtBpTbProvTable, mscVrPpSrtBpMtuExceededDiscards=mscVrPpSrtBpMtuExceededDiscards, mscVrPpTbpStpProvTable=mscVrPpTbpStpProvTable, mscVrPpSrBpDomainNum=mscVrPpSrBpDomainNum, mscVrPpTbclInFrames=mscVrPpTbclInFrames, mscVrPpSrtBpStpOperEntry=mscVrPpSrtBpStpOperEntry, mscVrPpTbseStatsTable=mscVrPpTbseStatsTable, mscVrPpSrclBlockingDiscards=mscVrPpSrclBlockingDiscards, mscVrPpSrtBpProvTable=mscVrPpSrtBpProvTable, mscVrPpSrsgTinygramFramesIn=mscVrPpSrsgTinygramFramesIn, mscVrPpTbpRowStatusEntry=mscVrPpTbpRowStatusEntry, mscVrPpSrseRowStatusEntry=mscVrPpSrseRowStatusEntry, mscVrPpTbclInFilterDiscards=mscVrPpTbclInFilterDiscards, mscVrBrSrbStpRowStatusTable=mscVrBrSrbStpRowStatusTable, mscVrPpSrsgDupLanIdOrTreeErrors=mscVrPpSrsgDupLanIdOrTreeErrors, mscVrPpFddiETBDynamicEntryDiscards=mscVrPpFddiETBDynamicEntryDiscards, mscVrPpSrseServiceClass=mscVrPpSrseServiceClass, mscVrPpFddiETBStorageType=mscVrPpFddiETBStorageType, mscVrPpFddiETBNsProvTable=mscVrPpFddiETBNsProvTable, mscVrBrTbAgingTime=mscVrBrTbAgingTime, mscVrPpTbseRowStatusEntry=mscVrPpTbseRowStatusEntry, mscVrPpTbclOperEntry=mscVrPpTbclOperEntry, mscVrPpTbpOperStatusEntry=mscVrPpTbpOperStatusEntry, mscVrPpSrseAdminStatus=mscVrPpSrseAdminStatus, mscVrBrNsRowStatusTable=mscVrBrNsRowStatusTable, mscVrBrTbNumFtEntriesDenied=mscVrBrTbNumFtEntriesDenied, mscVrPpSrBpStpOperTable=mscVrPpSrBpStpOperTable, mscVrPpSrtBpInternalLanId=mscVrPpSrtBpInternalLanId, mscVrBrSrbStpProvEntry=mscVrBrSrbStpProvEntry, mscVrPpSrseLanId=mscVrPpSrseLanId, mscVrPpSrclStatsEntry=mscVrPpSrclStatsEntry, mscVrPpSrtBpDIProvEntry=mscVrPpSrtBpDIProvEntry, mscVrPpFddiETBStpProvTable=mscVrPpFddiETBStpProvTable, mscVrPpSrsgSrStatsTable=mscVrPpSrsgSrStatsTable, mscVrPpSrBpHopCount=mscVrPpSrBpHopCount, mscVrPpTbseOperEntry=mscVrPpTbseOperEntry, mscVrBrSrbStpRowStatusEntry=mscVrBrSrbStpRowStatusEntry, mscVrPpFddiETBTbOperEntry=mscVrPpFddiETBTbOperEntry, mscVrPpSrsePortNum=mscVrPpSrsePortNum, mscVrPpSrBpPathCostOper=mscVrPpSrBpPathCostOper, mscVrPpSrtBpUsageState=mscVrPpSrtBpUsageState, mscVrPpSrtBpAdminState=mscVrPpSrtBpAdminState, mscVrPpFddiETBDIProvTable=mscVrPpFddiETBDIProvTable, mscVrPpSrtBpBridgeNum=mscVrPpSrtBpBridgeNum, mscVrPpSrBpInternalLanId=mscVrPpSrBpInternalLanId, mscVrPpTbseTbProvEntry=mscVrPpTbseTbProvEntry, mscVrPpSrBpSnmpOperStatus=mscVrPpSrBpSnmpOperStatus, mscVrPpTbseStatsEntry=mscVrPpTbseStatsEntry, mscVrPpSrsgProvTable=mscVrPpSrsgProvTable, mscVrPpSrBpLargestFrame=mscVrPpSrBpLargestFrame, mscVrPpSrclStpTypeOper=mscVrPpSrclStpTypeOper, mscVrBrOperStatusTable=mscVrBrOperStatusTable, mscVrPpSrsgUpTime=mscVrPpSrsgUpTime, mscVrBrStateEntry=mscVrBrStateEntry, mscVrPpSrsgLanIdMismatches=mscVrPpSrsgLanIdMismatches, mscVrPpFddiETBIndex=mscVrPpFddiETBIndex, mscVrPpTbpMtuExceededDiscards=mscVrPpTbpMtuExceededDiscards, mscVrPpTbse=mscVrPpTbse, mscVrPpTbpProvTable=mscVrPpTbpProvTable, mscVrPpTbpLearningDiscards=mscVrPpTbpLearningDiscards, mscVrPpTbsePreserveDomain=mscVrPpTbsePreserveDomain, mscVrPpFddiETBBlockingDiscards=mscVrPpFddiETBBlockingDiscards, mscVrPpSrseApeInFrames=mscVrPpSrseApeInFrames, mscVrPpSrBpRowStatusTable=mscVrPpSrBpRowStatusTable, mscVrPpSrclStpOperTable=mscVrPpSrclStpOperTable, mscVrPpSrsgFragmentIp=mscVrPpSrsgFragmentIp, mscVrPpTbsgPortName=mscVrPpTbsgPortName, mscVrPpSrclHopCount=mscVrPpSrclHopCount, mscVrPpSrseSrStatsEntry=mscVrPpSrseSrStatsEntry, mscVrPpTbpOperationalState=mscVrPpTbpOperationalState, mscVrPpTbseDynamicEntryDiscards=mscVrPpTbseDynamicEntryDiscards, mscVrPpTbseFragmentIp=mscVrPpTbseFragmentIp, mscVrBrNsRowStatusEntry=mscVrBrNsRowStatusEntry, mscCBOperTable=mscCBOperTable, mscVrPpSrsgPathCostMethod=mscVrPpSrsgPathCostMethod, mscVrBrSrbLteLanIdIndex=mscVrBrSrbLteLanIdIndex, mscCBOperStatusTable=mscCBOperStatusTable, mscVrPpTbpBridgePortType=mscVrPpTbpBridgePortType, mscVrPpSrBpComponentName=mscVrPpSrBpComponentName, mscVrPpSrtBpExploreFrameTreatment=mscVrPpSrtBpExploreFrameTreatment, mscVrPpTbclOperStatusEntry=mscVrPpTbclOperStatusEntry, mscVrBrNs=mscVrBrNs, mscVrPpFddiETBSnmpOperStatus=mscVrPpFddiETBSnmpOperStatus, mscVrPpSrtBpRowStatusTable=mscVrPpSrtBpRowStatusTable, mscVrPpTbclAdminStatus=mscVrPpTbclAdminStatus, mscVrPpTbpStpProvEntry=mscVrPpTbpStpProvEntry, mscVrPpSrseFragmentIp=mscVrPpSrseFragmentIp, mscVrPpTbseRowStatusTable=mscVrPpTbseRowStatusTable, mscVrBrTbSteProvEntry=mscVrBrTbSteProvEntry, mscVrPpTbsgTranslateIpx=mscVrPpTbsgTranslateIpx, mscVrPpSrseDownTime=mscVrPpSrseDownTime, mscVrPpTbclFragmentIp=mscVrPpTbclFragmentIp, mscVrBrAdminControlEntry=mscVrBrAdminControlEntry, mscVrBrNsAteFirstMacAddressMask=mscVrBrNsAteFirstMacAddressMask, mscVrPpSrtBpStpProvTable=mscVrPpSrtBpStpProvTable, mscVrPpSrtBpComponentName=mscVrPpSrtBpComponentName, mscVrBrSrbStpHoldTime=mscVrBrSrbStpHoldTime, mscVrPpSrseProvTable=mscVrPpSrseProvTable, mscVrBrTbStpProvEntry=mscVrBrTbStpProvEntry, mscVrPpTbpDesignatedPort=mscVrPpTbpDesignatedPort, mscVrPpTbsgOperEntry=mscVrPpTbsgOperEntry, mscVrPpTbseTranslateIpx=mscVrPpTbseTranslateIpx, mscVrPpSrclPathCostMethod=mscVrPpSrclPathCostMethod, mscVrPpSrsgOperTable=mscVrPpSrsgOperTable, mscVrBrSrbStpDesignatedRoot=mscVrBrSrbStpDesignatedRoot, bridgeGroupCA02A=bridgeGroupCA02A, mscVrPpSrsgDupSegmentDiscards=mscVrPpSrsgDupSegmentDiscards, mscVrPpFddiETBProvTable=mscVrPpFddiETBProvTable, mscVrPpTbpOutFrames=mscVrPpTbpOutFrames, mscVrPpSrtBpOutFrames=mscVrPpSrtBpOutFrames, mscVrPpSrsePortName=mscVrPpSrsePortName, mscVrBrTbFteRowStatusEntry=mscVrBrTbFteRowStatusEntry, mscVrPpSrBpNsOutgoingFilter=mscVrPpSrBpNsOutgoingFilter, mscVrPpSrsgStateEntry=mscVrPpSrsgStateEntry, mscVrPpFddiETBTbProvTable=mscVrPpFddiETBTbProvTable, mscVrPpTbsgFragmentIp=mscVrPpTbsgFragmentIp, mscVrBrTbNcFtePort=mscVrBrTbNcFtePort, mscVrPpTbclStpProvEntry=mscVrPpTbclStpProvEntry, mscVrPpSrclDesignatedRoot=mscVrPpSrclDesignatedRoot, mscVrBrSrbRowStatusEntry=mscVrBrSrbRowStatusEntry, mscVrPpSrseLanIdMismatches=mscVrPpSrseLanIdMismatches, mscCBStateEntry=mscCBStateEntry, mscVrPpTbsgBridgePortType=mscVrPpTbsgBridgePortType, mscVrPpSrsgStpProvEntry=mscVrPpSrsgStpProvEntry, mscVrPpSrBpBadAbstractDiscards=mscVrPpSrBpBadAbstractDiscards, mscVrPpSrclDupLanIdOrTreeErrors=mscVrPpSrclDupLanIdOrTreeErrors, mscVrPpSrsgBridgePortConfig=mscVrPpSrsgBridgePortConfig, mscVrPpSrseSrProvTable=mscVrPpSrseSrProvTable, mscVrPpSrclNsProvTable=mscVrPpSrclNsProvTable, mscVrPpTbpNsRowStatusTable=mscVrPpTbpNsRowStatusTable, mscVrPpSrclExploreFrameTreatment=mscVrPpSrclExploreFrameTreatment, mscVrPpTbseDIProvEntry=mscVrPpTbseDIProvEntry, mscVrPpTbclBridgePortType=mscVrPpTbclBridgePortType, mscVrBrTbStpOperEntry=mscVrBrTbStpOperEntry, mscVrPpSrBpLanId=mscVrPpSrBpLanId, mscVrPpSrsgSteOutFrames=mscVrPpSrsgSteOutFrames, mscVrPpTbsePathCostMethod=mscVrPpTbsePathCostMethod, mscVrPpSrtBpNsRowStatusTable=mscVrPpSrtBpNsRowStatusTable, mscVrPpTbseTbProvTable=mscVrPpTbseTbProvTable, mscVrPpTbseDIProvTable=mscVrPpTbseDIProvTable, mscVrPpSrsgIfIndex=mscVrPpSrsgIfIndex, mscVrPpTbpNs=mscVrPpTbpNs, mscVrBrTbSteRowStatus=mscVrBrTbSteRowStatus, mscVrPpTbseMtuExceededDiscards=mscVrPpTbseMtuExceededDiscards, mscVrPpTbcl=mscVrPpTbcl, mscVrPpSrseSteOutFrames=mscVrPpSrseSteOutFrames, mscVrPpSrBpDesignatedBridge=mscVrPpSrBpDesignatedBridge, mscVrPpSrseDupSegmentDiscards=mscVrPpSrseDupSegmentDiscards, mscVrPpSrseIfIndex=mscVrPpSrseIfIndex, mscVrPpTbseDelayExceededDiscards=mscVrPpTbseDelayExceededDiscards, mscVrPpTbclOutFilterDiscards=mscVrPpTbclOutFilterDiscards, mscVrPpSrsgSnmpOperStatus=mscVrPpSrsgSnmpOperStatus, mscVrPpFddiETBNsIncomingFilter=mscVrPpFddiETBNsIncomingFilter, mscVrPpSrsgStatsEntry=mscVrPpSrsgStatsEntry, mscVrBrPtePortNameIndex=mscVrBrPtePortNameIndex, mscVrBrTbNcFteAddressIndex=mscVrBrTbNcFteAddressIndex, mscVrPpTbsgUpTime=mscVrPpTbsgUpTime, mscVrBrSrbNumLanIdtEntriesFree=mscVrBrSrbNumLanIdtEntriesFree, mscVrPpTbseOutFrames=mscVrPpTbseOutFrames, mscCBOperEntry=mscCBOperEntry, mscVrPpSrsgOperationalState=mscVrPpSrsgOperationalState, mscVrPpSrclNsRowStatusEntry=mscVrPpSrclNsRowStatusEntry, mscVrPpTbsgPortNum=mscVrPpTbsgPortNum, mscVrPpSrsgInFilterDiscards=mscVrPpSrsgInFilterDiscards, mscVrPpSrBpStateTable=mscVrPpSrBpStateTable, mscVrPpTbsgOperStatusTable=mscVrPpTbsgOperStatusTable, mscVrBrSrbIndex=mscVrBrSrbIndex, mscVrBrSrbBridgeLfMode=mscVrBrSrbBridgeLfMode, mscCBIfIndex=mscCBIfIndex, mscVrPpTbclRowStatusTable=mscVrPpTbclRowStatusTable, mscPBRowStatusTable=mscPBRowStatusTable, mscVrPpFddiETBPathCost=mscVrPpFddiETBPathCost, mscVrPpTbseIndex=mscVrPpTbseIndex, mscVrPpTbpTbOperEntry=mscVrPpTbpTbOperEntry, mscVrPpTbpBadVerifyDiscards=mscVrPpTbpBadVerifyDiscards, mscVrPpSrsgOutFilterDiscards=mscVrPpSrsgOutFilterDiscards, mscVrPpSrsgLanId=mscVrPpSrsgLanId, mscVrPpSrclOperStatusTable=mscVrPpSrclOperStatusTable, mscVrPpSrBpApeInFrames=mscVrPpSrBpApeInFrames, mscVrPpTbsgUnicastNoMatches=mscVrPpTbsgUnicastNoMatches, mscVrBrSrbStpAgingTimeOper=mscVrBrSrbStpAgingTimeOper, mscVrBrSrbLteComponentName=mscVrBrSrbLteComponentName, mscVrPpSrseStatsEntry=mscVrPpSrseStatsEntry, mscVrPpTbpPathCostOper=mscVrPpTbpPathCostOper, mscVrPpFddiETBRowStatusEntry=mscVrPpFddiETBRowStatusEntry, mscVrPpSrtBpSpecInFrames=mscVrPpSrtBpSpecInFrames, mscVrBrSrbStpStpMode=mscVrBrSrbStpStpMode, mscVrBrTbComponentName=mscVrBrTbComponentName, mscVrPpSrtBpBridgingMode=mscVrPpSrtBpBridgingMode, mscVrPpTbpOperTable=mscVrPpTbpOperTable, mscVrPpSrclSrStatsEntry=mscVrPpSrclSrStatsEntry, mscCBMacAddress=mscCBMacAddress, mscVrPpTbsgOutFilterDiscards=mscVrPpTbsgOutFilterDiscards, mscVrBrTbProvTable=mscVrBrTbProvTable, mscVrPpTbpStateEntry=mscVrPpTbpStateEntry, mscVrBrTbStpComponentName=mscVrBrTbStpComponentName, mscVrPpSrBpDynamicDiscards=mscVrPpSrBpDynamicDiscards, mscVrBrSrbStpOperTable=mscVrBrSrbStpOperTable, mscVrPpSrclProvEntry=mscVrPpSrclProvEntry)
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-BridgeMIB", mscPBStateEntry=mscPBStateEntry, mscVrPpSrBpSpecOutFrames=mscVrPpSrBpSpecOutFrames, mscVrBrNsProvEntry=mscVrBrNsProvEntry, mscVrPpTbsgAdminState=mscVrPpTbsgAdminState, mscVrPpTbsgStpTypeOper=mscVrPpTbsgStpTypeOper, mscVrPpSrseRowStatus=mscVrPpSrseRowStatus, mscVrPpTbclStpOperEntry=mscVrPpTbclStpOperEntry, mscVrPpSrseSteSpanMode=mscVrPpSrseSteSpanMode, mscVrPpTbseUnicastNoMatches=mscVrPpTbseUnicastNoMatches, mscVrPpSrsgStaticDiscards=mscVrPpSrsgStaticDiscards, mscVrPpTbsePortName=mscVrPpTbsePortName, mscVrPpTbsgRowStatus=mscVrPpTbsgRowStatus, mscVrPpTbclDesignatedPort=mscVrPpTbclDesignatedPort, mscVrPpSrsePathCostMethod=mscVrPpSrsePathCostMethod, mscVrPpTbseBridgingMode=mscVrPpTbseBridgingMode, mscVrPpSrBpSteInFrames=mscVrPpSrBpSteInFrames, mscVrPpSrtBpPortStateStpControl=mscVrPpSrtBpPortStateStpControl, mscVrPpTbseBadAbstractDiscards=mscVrPpTbseBadAbstractDiscards, mscVrPpTbclUpTime=mscVrPpTbclUpTime, mscVrPpTbpIndex=mscVrPpTbpIndex, mscVrPpTbclConvertArpMacAddress=mscVrPpTbclConvertArpMacAddress, mscVrPpSrseComponentName=mscVrPpSrseComponentName, mscVrBrTbStpAgingTimeOper=mscVrBrTbStpAgingTimeOper, mscVrPpSrsgDelayExceededDiscards=mscVrPpSrsgDelayExceededDiscards, mscVrPpSrtBpSrStatsEntry=mscVrPpSrtBpSrStatsEntry, mscVrPpTbsgOperStatusEntry=mscVrPpTbsgOperStatusEntry, mscVrPpSrBpDupLanIdOrTreeErrors=mscVrPpSrBpDupLanIdOrTreeErrors, mscVrPpSrtBpStpProvEntry=mscVrPpSrtBpStpProvEntry, mscVrPpSrBpFragmentIp=mscVrPpSrBpFragmentIp, mscVrPpSrclPortName=mscVrPpSrclPortName, mscVrPpTbsgStpProvTable=mscVrPpTbsgStpProvTable, mscVrPpSrtBpStorageType=mscVrPpSrtBpStorageType, mscVrPpSrclBadAbstractDiscards=mscVrPpSrclBadAbstractDiscards, mscVrPpTbclNsRowStatus=mscVrPpTbclNsRowStatus, mscVrPpSrtBpDomainNum=mscVrPpSrtBpDomainNum, mscVrPpSrclLanId=mscVrPpSrclLanId, mscVrPpSrtBpBlockingDiscards=mscVrPpSrtBpBlockingDiscards, mscVrPpSrclForwardTransitions=mscVrPpSrclForwardTransitions, mscVrPpSrclNsOutgoingFilter=mscVrPpSrclNsOutgoingFilter, mscVrBrAdminControlTable=mscVrBrAdminControlTable, mscVrBrTbRowStatusTable=mscVrBrTbRowStatusTable, mscVrPpSrclDelayExceededDiscards=mscVrPpSrclDelayExceededDiscards, mscVrPpSrsgPortNum=mscVrPpSrsgPortNum, mscVrPpTbclTbProvTable=mscVrPpTbclTbProvTable, mscVrPpTbclNsIndex=mscVrPpTbclNsIndex, mscVrPpTbpStpOperEntry=mscVrPpTbpStpOperEntry, mscVrPpSrseAreRdLimit=mscVrPpSrseAreRdLimit, mscVrPpSrsgBridgePortType=mscVrPpSrsgBridgePortType, mscVrPpSrsePathCostOper=mscVrPpSrsePathCostOper, mscVrBrTbStpDesignatedRoot=mscVrBrTbStpDesignatedRoot, mscVrBrTbStpTimeSinceTopologyChange=mscVrBrTbStpTimeSinceTopologyChange, mscVrPpTbclDesignatedBridge=mscVrPpTbclDesignatedBridge, mscVrPpSrBpStpTypeOper=mscVrPpSrBpStpTypeOper, mscVrPpSrclApeOutFrames=mscVrPpSrclApeOutFrames, mscVrPpSrtBpDesignatedPort=mscVrPpSrtBpDesignatedPort, mscVrBrSrbStpMaxAge=mscVrBrSrbStpMaxAge, mscVrPpSrclOperStatusEntry=mscVrPpSrclOperStatusEntry, mscVrBrTb=mscVrBrTb, mscVrPpTbclTinygramFramesOut=mscVrPpTbclTinygramFramesOut, mscVrPpSrclSteOutFrames=mscVrPpSrclSteOutFrames, mscVrPpSrclStateTable=mscVrPpSrclStateTable, mscPBMacAddress=mscPBMacAddress, mscVrBrTbStpBridgeForwardDelay=mscVrBrTbStpBridgeForwardDelay, mscVrPpSrBpExploreFrameTreatment=mscVrPpSrBpExploreFrameTreatment, mscVrPpSrBpPortName=mscVrPpSrBpPortName, mscVrPpFddiETBNsOutgoingFilter=mscVrPpFddiETBNsOutgoingFilter, mscVrPpSrseSpecOutFrames=mscVrPpSrseSpecOutFrames, mscVrPpSrtBpSteInFrames=mscVrPpSrtBpSteInFrames, mscVrPpTbpStpPortState=mscVrPpTbpStpPortState, mscVrBrTbSteReceivePortIndex=mscVrBrTbSteReceivePortIndex, mscVrPpSrBpSrStatsEntry=mscVrPpSrBpSrStatsEntry, mscVrPpSrsgSegmentMismatchDiscards=mscVrPpSrsgSegmentMismatchDiscards, mscVrBrTbFteOperTable=mscVrBrTbFteOperTable, mscVrBrTbStpRowStatusEntry=mscVrBrTbStpRowStatusEntry, mscVrPpFddiETBDesignatedBridge=mscVrPpFddiETBDesignatedBridge, mscVrPpSrtBpDownTime=mscVrPpSrtBpDownTime, mscVrPpSrseStpTypeOper=mscVrPpSrseStpTypeOper, mscVrPpTbclMaxInfo=mscVrPpTbclMaxInfo, mscVrPpSrseUsageState=mscVrPpSrseUsageState, mscVrPpTbpStpTypeProv=mscVrPpTbpStpTypeProv, mscVrPpSrclServiceClass=mscVrPpSrclServiceClass, mscVrBrTbStpProvTable=mscVrBrTbStpProvTable, mscVrPpSrBpNsRowStatusTable=mscVrPpSrBpNsRowStatusTable, mscVrPpSrtBpDesignatedBridge=mscVrPpSrtBpDesignatedBridge, mscVrPpSrtBpBadVerifyDiscards=mscVrPpSrtBpBadVerifyDiscards, mscVrPpTbseStpProvEntry=mscVrPpTbseStpProvEntry, mscVrPpSrsgUsageState=mscVrPpSrsgUsageState, mscVrPpTbseDesignatedPort=mscVrPpTbseDesignatedPort, mscVrBrPteOperEntry=mscVrBrPteOperEntry, mscVrBrSrbLteRowStatusTable=mscVrBrSrbLteRowStatusTable, mscVrPpFddiETBBadVerifyDiscards=mscVrPpFddiETBBadVerifyDiscards, mscVrPpSrseInternalLanId=mscVrPpSrseInternalLanId, mscVrPpTbsgDelayExceededDiscards=mscVrPpTbsgDelayExceededDiscards, mscVrPpSrclPreserveDomain=mscVrPpSrclPreserveDomain, mscVrPpSrclTinygramFramesOut=mscVrPpSrclTinygramFramesOut, mscVrBrNsAteComponentName=mscVrBrNsAteComponentName, mscVrBrSrbRowStatus=mscVrBrSrbRowStatus, mscVrPpSrtBpSteSpanMode=mscVrPpSrtBpSteSpanMode, bridgeGroupCA=bridgeGroupCA, mscVrPpSrBpOperStatusTable=mscVrPpSrBpOperStatusTable, mscVrPpTbpInFilterDiscards=mscVrPpTbpInFilterDiscards, mscVrPpTbclDesignatedRoot=mscVrPpTbclDesignatedRoot, mscVrPpTbclMtuExceededDiscards=mscVrPpTbclMtuExceededDiscards, mscVrPpFddiETB=mscVrPpFddiETB, mscVrPpSrsgOperEntry=mscVrPpSrsgOperEntry, mscVrPpTbclDomainNum=mscVrPpTbclDomainNum, mscVrPpTbclPreserveDomain=mscVrPpTbclPreserveDomain, mscVrPpTbsgConvertArpMacAddress=mscVrPpTbsgConvertArpMacAddress, mscVrPpTbpTbProvEntry=mscVrPpTbpTbProvEntry, mscVrPpSrsgSteInFrames=mscVrPpSrsgSteInFrames, mscVrPpSrclHopCountExceededDiscards=mscVrPpSrclHopCountExceededDiscards, mscVrPpFddiETBTinygramFramesIn=mscVrPpFddiETBTinygramFramesIn, mscVrBrSrbStatsTable=mscVrBrSrbStatsTable, mscVrPpSrsgServiceClass=mscVrPpSrsgServiceClass, mscVrBrTbNcFteOperTable=mscVrBrTbNcFteOperTable, mscVrPpSrsePreserveDomain=mscVrPpSrsePreserveDomain, mscVrPpSrtBpNsProvEntry=mscVrPpSrtBpNsProvEntry, mscVrBrTbSteRowStatusTable=mscVrBrTbSteRowStatusTable, mscVrPpTbclStorageType=mscVrPpTbclStorageType, mscVrPpFddiETBPathCostOper=mscVrPpFddiETBPathCostOper, mscVrPpFddiETBStatsTable=mscVrPpFddiETBStatsTable, mscVrPpSrsgSrProvEntry=mscVrPpSrsgSrProvEntry, mscVrPpTbsgTbOperEntry=mscVrPpTbsgTbOperEntry, mscVrPpSrclStatsTable=mscVrPpSrclStatsTable, mscVrPpTbpDesignatedBridge=mscVrPpTbpDesignatedBridge, mscVrPpSrBpSrProvTable=mscVrPpSrBpSrProvTable, mscVrPpSrseApeOutFrames=mscVrPpSrseApeOutFrames, mscVrBrTbSteComponentName=mscVrBrTbSteComponentName, mscCBIndex=mscCBIndex, mscVrPpSrsgSrProvTable=mscVrPpSrsgSrProvTable, mscVrPpTbsgForwardTransitions=mscVrPpTbsgForwardTransitions, mscVrPpSrtBpNsComponentName=mscVrPpSrtBpNsComponentName, mscVrPpSrsePortPriority=mscVrPpSrsePortPriority, mscVrPpFddiETBNsRowStatus=mscVrPpFddiETBNsRowStatus, mscVrPpSrseDIProvTable=mscVrPpSrseDIProvTable, mscVrPpTbsgDynamicEntryDiscards=mscVrPpTbsgDynamicEntryDiscards, mscCB=mscCB, mscVrPpSrclNsIncomingFilter=mscVrPpSrclNsIncomingFilter, mscVrPpSrtBpPathCost=mscVrPpSrtBpPathCost, mscVrPpSrBpSpecInFrames=mscVrPpSrBpSpecInFrames, mscVrPpSrclStorageType=mscVrPpSrclStorageType, mscVrPpSrclStpTypeProv=mscVrPpSrclStpTypeProv, mscVrPpTbsgStateTable=mscVrPpTbsgStateTable, mscVrPpSrclUpTime=mscVrPpSrclUpTime, mscVrPpSrBpApeOutFrames=mscVrPpSrBpApeOutFrames, mscVrPpSrtBpUpTime=mscVrPpSrtBpUpTime, mscVrPpSrsgHopCountExceededDiscards=mscVrPpSrsgHopCountExceededDiscards, mscVrPpTbpMaxInfo=mscVrPpTbpMaxInfo, mscVrBrPteStpState=mscVrBrPteStpState, mscVrPpTbsgInDiscards=mscVrPpTbsgInDiscards, mscPBAdminControlTable=mscPBAdminControlTable, mscVrPpTbpNsProvTable=mscVrPpTbpNsProvTable, mscVrPpSrclBridgeNum=mscVrPpSrclBridgeNum, mscVrBrTbFteAddressIndex=mscVrBrTbFteAddressIndex, mscVrPpSrBpAreRdLimit=mscVrPpSrBpAreRdLimit, mscVrPpFddiETBMtuExceededDiscards=mscVrPpFddiETBMtuExceededDiscards, mscVrBrStorageType=mscVrBrStorageType, mscVrBrTbStpRootCost=mscVrBrTbStpRootCost, mscVrPpSrBpUpTime=mscVrPpSrBpUpTime, mscVrPpSrBpDownTime=mscVrPpSrBpDownTime, mscVrPpTbseStpOperTable=mscVrPpTbseStpOperTable, mscPBMpTable=mscPBMpTable, mscVrBrUsageState=mscVrBrUsageState, mscVrPpSrtBpSrProvTable=mscVrPpSrtBpSrProvTable, mscVrBrSrbLteTypeOfEntry=mscVrBrSrbLteTypeOfEntry, mscVrPpTbsgPathCostOper=mscVrPpTbsgPathCostOper, mscVrPpSrBpTranslateIpx=mscVrPpSrBpTranslateIpx, mscVrPpSrclInternalLanId=mscVrPpSrclInternalLanId, mscVrPpSrtBpStatsEntry=mscVrPpSrtBpStatsEntry, mscVrPpTbsePortStateStpControl=mscVrPpTbsePortStateStpControl, mscVrPpSrsgStorageType=mscVrPpSrsgStorageType, mscVrPpTbclStaticEntryDiscards=mscVrPpTbclStaticEntryDiscards, mscVrPpSrtBpNs=mscVrPpSrtBpNs, mscVrPpSrclSteRdLimit=mscVrPpSrclSteRdLimit, mscVrBrSrbProvTable=mscVrBrSrbProvTable, mscVrPpSrseHopCountExceededDiscards=mscVrPpSrseHopCountExceededDiscards, mscVrPpSrtBpTinygramFramesIn=mscVrPpSrtBpTinygramFramesIn, mscVrPpSrtBpDesignatedRoot=mscVrPpSrtBpDesignatedRoot, mscVrPpFddiETBPreserveDomain=mscVrPpFddiETBPreserveDomain)

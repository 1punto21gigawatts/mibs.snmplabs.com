#
# PySNMP MIB module CISCO-PACKET-CAPTURE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-PACKET-CAPTURE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:09:13 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
VlanIndex, = mibBuilder.importSymbols("CISCO-VTP-MIB", "VlanIndex")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
InetAddress, InetAddressType, InetAddressPrefixLength = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType", "InetAddressPrefixLength")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
iso, ObjectIdentity, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Gauge32, NotificationType, IpAddress, Bits, ModuleIdentity, MibIdentifier, Integer32, Counter64, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "iso", "ObjectIdentity", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Gauge32", "NotificationType", "IpAddress", "Bits", "ModuleIdentity", "MibIdentifier", "Integer32", "Counter64", "TimeTicks")
TextualConvention, MacAddress, DisplayString, DateAndTime, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "MacAddress", "DisplayString", "DateAndTime", "RowStatus")
ciscoPacketCaptureMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 602))
ciscoPacketCaptureMIB.setRevisions(('2008-07-07 00:00', '2007-01-03 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoPacketCaptureMIB.setRevisionsDescriptions(('Added cpcPacketLengthFilterConfigGroup, cpcEthertypeFilterConfigGroup, cpcVlanFilterConfigGroup, cpcAccessGroupFilterConfigGroup, cpcBufferConfigGroup, cpcScheduleConfigGroup, cpcSessionStatsGroup, cpcMaxMacFilterConfigGroup, cpcMaxIpFilterConfigGroup, cpcSessionDescrGroup, cpcSessionPacketRateLimitGroup.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoPacketCaptureMIB.setLastUpdated('200807070000Z')
if mibBuilder.loadTexts: ciscoPacketCaptureMIB.setOrganization('Cisco System, Inc.')
if mibBuilder.loadTexts: ciscoPacketCaptureMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-lan-switch-snmp@cisco.com')
if mibBuilder.loadTexts: ciscoPacketCaptureMIB.setDescription('The MIB module for the management of packet capture feature.')
cpcMIBNotification = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 0))
cpcMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 1))
cpcMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 2))
class CiscoPacketCaptureFilterCriteria(TextualConvention, Integer32):
    description = 'Filter criteria to specify if packets will be captured based on source or destination addresses. source: packets will be captured based on source address. dest : packets will be captured based on destination address.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("source", 1), ("dest", 2))

cpcGenericConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1))
cpcFilterConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2))
cpcBufferConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 3))
cpcScheduleConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 4))
cpcSessionStats = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 5))
cpcMaxSessionAllowed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcMaxSessionAllowed.setStatus('current')
if mibBuilder.loadTexts: cpcMaxSessionAllowed.setDescription('The maximum number of packet capture sessions allowed in cpcSessionConfigTable. A value of zero indicates no limitation on the number of configurable sessions.')
cpcSessionConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2), )
if mibBuilder.loadTexts: cpcSessionConfigTable.setStatus('current')
if mibBuilder.loadTexts: cpcSessionConfigTable.setDescription("A table of configuration to be used in the packet capture sessions. This entry may be modified if value of corresponding instance of cpcSessionConfigStatus is 'active'.")
cpcSessionConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"))
if mibBuilder.loadTexts: cpcSessionConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cpcSessionConfigEntry.setDescription('An entry containing management information of a packet capture session.')
cpcSessionId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295)))
if mibBuilder.loadTexts: cpcSessionId.setStatus('current')
if mibBuilder.loadTexts: cpcSessionId.setDescription('An unique number which represents a session.')
cpcSessionOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("other", 1), ("inProgress", 2), ("completed", 3), ("stopped", 4), ("storageFull", 5), ("bufferFull", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcSessionOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpcSessionOperStatus.setDescription('Operational status of a packet capture session. other : none of the following. inProgress : packet capture session is in progress. completed : number of captured frames has reached the value of corresponding instance of cpcSessionPacketLimits. stopped : packet capture session was administratively stopped. storageFull: storage device is full. bufferFull : storage buffer is full.')
cpcSessionDestFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcSessionDestFileName.setStatus('current')
if mibBuilder.loadTexts: cpcSessionDestFileName.setDescription("The destination file name used to store the captured frames. Value of this object must be specified in the format of <device>:<filename> for local location, or <protocol>://<server>/<filename> for network location. This object may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress' or the value of cpcBufferOperStatus of an instance entry with same cpcSessionId in cpcBufferConfigEntry is 'exporting'.")
cpcSessionPacketLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 4), Unsigned32()).setUnits('octets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcSessionPacketLength.setStatus('current')
if mibBuilder.loadTexts: cpcSessionPacketLength.setDescription("The length of packet to be captured by this session. If the length of an actual packet is greater than the value of this object, the session will only capture the first number of bytes specified by this object. A value zero for this object indicates that the entire packet will be captured. This object may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcSessionPacketLimits = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 5), Unsigned32()).setUnits('packets').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcSessionPacketLimits.setStatus('current')
if mibBuilder.loadTexts: cpcSessionPacketLimits.setDescription("The number of packets to be captured by this session. A value of zero for this object indicates that there is no limitation. When the value of this object is zero, the session remains 'inProgress' until it is administratively stopped or the storage is full. This object may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcSessionAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start", 1), ("stop", 2))).clone('stop')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcSessionAction.setStatus('current')
if mibBuilder.loadTexts: cpcSessionAction.setDescription("The action control for this capture session. Setting this object to 'start' causes the capture session to be started if it is not running. Setting this object to 'stop' terminates the capturing session if it is running. The value of this object will be changed to 'stop' when value of the corresponding instance of cpcSessionOperStatus leaves from 'inProgress' to other status. This object may only be set when the corresponding instance value of cpcSessionConfigStatus is 'active'.")
cpcSessionConfigStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcSessionConfigStatus.setStatus('current')
if mibBuilder.loadTexts: cpcSessionConfigStatus.setDescription('The status of this conceptual row.')
cpcSessionPacketRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 8), Unsigned32().clone(10000)).setUnits('packets per second').setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcSessionPacketRateLimit.setStatus('current')
if mibBuilder.loadTexts: cpcSessionPacketRateLimit.setDescription("Rate limit for this session. Only packets within the rate may be captured. A value of zero for this object indicates that there is no rate limitation. This object may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcSessionDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 2, 1, 9), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcSessionDescr.setStatus('current')
if mibBuilder.loadTexts: cpcSessionDescr.setDescription('Provides description of this session.')
cpcSessionMaxSources = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcSessionMaxSources.setStatus('current')
if mibBuilder.loadTexts: cpcSessionMaxSources.setDescription('The maximum number of entries allowed in cpcCaptureSourceIfTable for a packet capture session. A value of zero indicates no limitation on the number of configurable sources.')
cpcCaptureSourceIfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 4), )
if mibBuilder.loadTexts: cpcCaptureSourceIfTable.setStatus('current')
if mibBuilder.loadTexts: cpcCaptureSourceIfTable.setDescription('A table of interface information to be used in the packet capture session.')
cpcCaptureSourceIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 4, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"), (0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: cpcCaptureSourceIfEntry.setStatus('current')
if mibBuilder.loadTexts: cpcCaptureSourceIfEntry.setDescription("An entry containing interface related management information for a packet capture session. The entry is created and deleted by using cpcCaptureSourceIfStatus object. The entry may not be modified, added or deleted when the corresponding value of cpcSessionOperStatus is 'inProgress'.")
cpcCaptureSourceIfDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("rx", 1), ("tx", 2), ("both", 3))).clone('rx')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcCaptureSourceIfDirection.setStatus('current')
if mibBuilder.loadTexts: cpcCaptureSourceIfDirection.setDescription("The direction of traffic to be captured. rx : Only ingress traffic will be captured. tx : Only egress traffic will be captured. both: Traffic from both directions will be captured. This object may be modified if value of the corresponding instance of cpcCaptureSourceIfStatus is 'active'.")
cpcCaptureSourceIfStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 1, 4, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcCaptureSourceIfStatus.setStatus('current')
if mibBuilder.loadTexts: cpcCaptureSourceIfStatus.setDescription('The status of this conceptual row.')
cpcMaxFilterAllowed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcMaxFilterAllowed.setStatus('current')
if mibBuilder.loadTexts: cpcMaxFilterAllowed.setDescription('The maximum number of filters allowed in a packet capture session. Value of zero indicates that there is no limitation.')
cpcMacFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 2), )
if mibBuilder.loadTexts: cpcMacFilterTable.setStatus('current')
if mibBuilder.loadTexts: cpcMacFilterTable.setDescription('A table of MAC filter information to be used in the packet capture session.')
cpcMacFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcMacFilterMacAddress"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcMacFilterCriteria"))
if mibBuilder.loadTexts: cpcMacFilterEntry.setStatus('current')
if mibBuilder.loadTexts: cpcMacFilterEntry.setDescription("An entry containing management information about a packet capture filter based on MAC address. The entry is created or deleted by using cpcMacFilterRowStatus object. The entry may not be modified, created or deleted when the corresponding value of cpcSessionOperStatus is 'inProgress'.")
cpcMacFilterMacAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 2, 1, 1), MacAddress())
if mibBuilder.loadTexts: cpcMacFilterMacAddress.setStatus('current')
if mibBuilder.loadTexts: cpcMacFilterMacAddress.setDescription('The filtered MAC address. Incorporated with the corresponding instance value of crcMacFilterCriteria, packet capture will capture packets sending from or to the address specified by this object.')
cpcMacFilterCriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 2, 1, 2), CiscoPacketCaptureFilterCriteria())
if mibBuilder.loadTexts: cpcMacFilterCriteria.setStatus('current')
if mibBuilder.loadTexts: cpcMacFilterCriteria.setDescription('The filter criteria of the entry.')
cpcMacFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 2, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcMacFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpcMacFilterRowStatus.setDescription('The status of this conceptual row.')
cpcIpFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 3), )
if mibBuilder.loadTexts: cpcIpFilterTable.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterTable.setDescription('A table of IP filter information to be used in the packet capture session.')
cpcIpFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcIpFilterAddressType"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcIpFilterAddress"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcIpFilterCriteria"))
if mibBuilder.loadTexts: cpcIpFilterEntry.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterEntry.setDescription("An entry containing management information if IP based packet capture filter for the packet capture session. The entry can be created or deleted by using cpcIpFilterRowStatus object. The entry may not be modified, created or deleted when value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcIpFilterAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 3, 1, 1), InetAddressType())
if mibBuilder.loadTexts: cpcIpFilterAddressType.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterAddressType.setDescription('The type of Internet address is configured in this packet capture filter.')
cpcIpFilterAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 3, 1, 2), InetAddress().subtype(subtypeSpec=ValueSizeConstraint(1, 64)))
if mibBuilder.loadTexts: cpcIpFilterAddress.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterAddress.setDescription('The Internet address for the filter. The type of this address is determined by the value of the cpcIpFilterAddressType object. The cpcIpFilterAddress may not be empty due to the SIZE restriction. Incorporated with the corresponding instance value of cpcIpFilterCriteria, packet capture will capture packets sending to or from the address specified by this object.')
cpcIpFilterCriteria = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 3, 1, 3), CiscoPacketCaptureFilterCriteria())
if mibBuilder.loadTexts: cpcIpFilterCriteria.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterCriteria.setDescription('The filter criteria of the entry.')
cpcIpFilterMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 3, 1, 4), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcIpFilterMask.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterMask.setDescription("The prefix length value associated with the corresponding cpcIpFilterAddress. The value of zero indicates that no IP mask is associated with the corresponding cpcIpFilterAddress. This object may be modified while value of the corresponding instance of cpcIpFilterRowStatus is 'active'.")
cpcIpFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 3, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcIpFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterRowStatus.setDescription('The status of this conceptual row.')
cpcMaxMacFilterAllowed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcMaxMacFilterAllowed.setStatus('current')
if mibBuilder.loadTexts: cpcMaxMacFilterAllowed.setDescription('The maximum number of filters allowed in cpcMacFilterTable for each packet capture session. Once the number of entries in cpcMacFilterTable reaches the value of this object, if users need to create a new entry in cpcMacFilteTable, an existing entry must be removed first. Value of zero indicates that there is no limitation.')
cpcMaxIpFilterAllowed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 5), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcMaxIpFilterAllowed.setStatus('current')
if mibBuilder.loadTexts: cpcMaxIpFilterAllowed.setDescription('The maximum number of IP filter allowed in cpcIpFilterTable for each packet capture session. Once the number of entries in cpcIpFilterTable reaches the value of this object, if users need to create a new entry in cpcIpFilterTable, an existing entry must be removed first. Value of zero indicates that there is no limitation.')
cpcPacketLengthFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 6), )
if mibBuilder.loadTexts: cpcPacketLengthFilterTable.setStatus('current')
if mibBuilder.loadTexts: cpcPacketLengthFilterTable.setDescription('A table of packet length filter configuration to be used in the packet capture sessions.')
cpcPacketLengthFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 6, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"))
if mibBuilder.loadTexts: cpcPacketLengthFilterEntry.setStatus('current')
if mibBuilder.loadTexts: cpcPacketLengthFilterEntry.setDescription("An entry contains management information about a packet capture filter based on packet length. A row is created for each entry in cpcSessionConfigTable. This entry may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcPacketLengthFilterMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 6, 1, 1), Unsigned32()).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpcPacketLengthFilterMin.setStatus('current')
if mibBuilder.loadTexts: cpcPacketLengthFilterMin.setDescription('This object specifies the minimum length of the packet to be captured. Packets having length smaller than this value will not be captured. A zero value means there is no minimum length limit. The value of cpcPacketLengthFilterMax object should not be less than that of cpcPacketLengthFilterMin object in the same row when both values are non zero.')
cpcPacketLengthFilterMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 6, 1, 2), Unsigned32()).setUnits('bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpcPacketLengthFilterMax.setStatus('current')
if mibBuilder.loadTexts: cpcPacketLengthFilterMax.setDescription('This object specifies the maximum length of the packet to be captured. Packets having length bigger than this value will not be captured. A zero value means there is no maximum length limit. The value of cpcPacketLengthFilterMax object should not be less than that of cpcPacketLengthFilterMin object in the same row when both values are non zero.')
cpcMaxEthertypeFilterAllowed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 7), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcMaxEthertypeFilterAllowed.setStatus('current')
if mibBuilder.loadTexts: cpcMaxEthertypeFilterAllowed.setDescription('The maximum number of filters allowed in cpcEthertypeFilterTable for each packet capture session. Value of zero indicates that there is no limitation.')
cpcEthertypeFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 8), )
if mibBuilder.loadTexts: cpcEthertypeFilterTable.setStatus('current')
if mibBuilder.loadTexts: cpcEthertypeFilterTable.setDescription('This table lists Ethertype filter configuration to be used in the packet capture sessions.')
cpcEthertypeFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 8, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcEthertypeFilterValue"))
if mibBuilder.loadTexts: cpcEthertypeFilterEntry.setStatus('current')
if mibBuilder.loadTexts: cpcEthertypeFilterEntry.setDescription("An entry contains management information about a packet capture filter based on Ethertype. This entry may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcEthertypeFilterValue = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)))
if mibBuilder.loadTexts: cpcEthertypeFilterValue.setStatus('current')
if mibBuilder.loadTexts: cpcEthertypeFilterValue.setDescription('The ethertype value to indicate which packet to be captured.')
cpcEthertypeFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 8, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcEthertypeFilterStatus.setStatus('current')
if mibBuilder.loadTexts: cpcEthertypeFilterStatus.setDescription("This object specifies the status of this conceptual row and is used to manage creation, and deletion of entries in this table. Whenever the current number of rows is equal to the value of cpcMaxEthertypeFilterAllowed, setting RowStatus of a new row to 'createAndGo' or 'createAndWait' should fail with an 'inconsistentValue' error. That is, to create another row, an existing row must be deleted via either setting its RowStatus object to 'destroy' or alternatively via the CLI.")
cpcMaxVlanFilterAllowed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcMaxVlanFilterAllowed.setStatus('current')
if mibBuilder.loadTexts: cpcMaxVlanFilterAllowed.setDescription('The maximum number of filters allowed in cpcVlanFilterTable for each packet capture session. Value of zero indicates that there is no limitation.')
cpcVlanFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 10), )
if mibBuilder.loadTexts: cpcVlanFilterTable.setStatus('current')
if mibBuilder.loadTexts: cpcVlanFilterTable.setDescription('A table of VLAN filter information to be used in packet capture sessions.')
cpcVlanFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 10, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcVlanFilterVlanIndex"))
if mibBuilder.loadTexts: cpcVlanFilterEntry.setStatus('current')
if mibBuilder.loadTexts: cpcVlanFilterEntry.setDescription("An entry contains management information about a packet capture filter based on VLAN. The entry is created or deleted using cpcVlanFilterRowStatus object. This entry may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcVlanFilterVlanIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 10, 1, 1), VlanIndex())
if mibBuilder.loadTexts: cpcVlanFilterVlanIndex.setStatus('current')
if mibBuilder.loadTexts: cpcVlanFilterVlanIndex.setDescription('The VLAN index value of this filter.')
cpcVlanFilterRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 10, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcVlanFilterRowStatus.setStatus('current')
if mibBuilder.loadTexts: cpcVlanFilterRowStatus.setDescription("This object specifies the status of this conceptual row and is used to manage creation, and deletion of entries in this table. Whenever the current number of rows is equal to the value of cpcMaxVlanFilterAllowed, setting RowStatus of a new row to 'createAndGo' or 'createAndWait' should fail with an 'inconsistentValue' error. That is, to create another row, an existing row must be deleted via either setting its RowStatus object to 'destroy' or alternatively via the CLI.")
cpcMaxAccessGroupFilterAllowed = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcMaxAccessGroupFilterAllowed.setStatus('current')
if mibBuilder.loadTexts: cpcMaxAccessGroupFilterAllowed.setDescription('The maximum number of filters allowed in cpcAccessGroupFilterTable for each packet capture session. Value of zero indicates that there is no limitation.')
cpcAccessGroupFilterTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 12), )
if mibBuilder.loadTexts: cpcAccessGroupFilterTable.setStatus('current')
if mibBuilder.loadTexts: cpcAccessGroupFilterTable.setDescription('A table of Access-Group filter information to be used in packet capture sessions.')
cpcAccessGroupFilterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 12, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"), (0, "CISCO-PACKET-CAPTURE-MIB", "cpcAccessGroupFilterType"), (1, "CISCO-PACKET-CAPTURE-MIB", "cpcAccessGroupFilterName"))
if mibBuilder.loadTexts: cpcAccessGroupFilterEntry.setStatus('current')
if mibBuilder.loadTexts: cpcAccessGroupFilterEntry.setDescription("An entry contains management information about a packet capture filter based on Access-Group number or name. The entry is created or deleted using cpcAccessGroupFilterStatus object. This entry may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcAccessGroupFilterType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hardware", 1), ("software", 2))))
if mibBuilder.loadTexts: cpcAccessGroupFilterType.setStatus('current')
if mibBuilder.loadTexts: cpcAccessGroupFilterType.setDescription('The way the ACL denoted by cpcAccessGroupFilterName is applied to the packets. hardware: hardware based software: software based.')
cpcAccessGroupFilterName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 12, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 99)))
if mibBuilder.loadTexts: cpcAccessGroupFilterName.setStatus('current')
if mibBuilder.loadTexts: cpcAccessGroupFilterName.setDescription('The ACL name or ACL number used in this package capture filter.')
cpcAccessGroupFilterStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 2, 12, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cpcAccessGroupFilterStatus.setStatus('current')
if mibBuilder.loadTexts: cpcAccessGroupFilterStatus.setDescription("This object specifies the status of this conceptual row and is used to manage creation, and deletion of entries in this table. Whenever the current number of rows is equal to the value of cpcMaxAccessGroupFilterAllowed, setting RowStatus of a new row to 'createAndGo' or 'createAndWait' should fail with an 'inconsistentValue' error. That is, to create another row, an existing row must be deleted via either setting its RowStatus object to 'destroy' or alternatively via the CLI.")
cpcBufferConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 3, 1), )
if mibBuilder.loadTexts: cpcBufferConfigTable.setStatus('current')
if mibBuilder.loadTexts: cpcBufferConfigTable.setDescription('A table of buffer configuration and controls for packet capture sessions.')
cpcBufferConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"))
if mibBuilder.loadTexts: cpcBufferConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cpcBufferConfigEntry.setDescription("An entry contains management information for a packet capture session's buffer. An entry is created corresponding to each entry in cpcSessionConfigTable. This entry may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcBufferType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("linear", 1), ("circular", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpcBufferType.setStatus('current')
if mibBuilder.loadTexts: cpcBufferType.setDescription("Type of the buffer for a packet capture session. linear : captured packets will be kept in the buffer one after the other. If there is no available space in the buffer, packet capture session will stop and value of the corresponding instance of cpcSessionOperStatus is set to 'bufferFull'. circular: If there is no space to store a captured packet completely, the oldest packet in the buffer will be overwritten.")
cpcBufferSize = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 3, 1, 1, 2), Unsigned32()).setUnits('Kilo-bytes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpcBufferSize.setStatus('current')
if mibBuilder.loadTexts: cpcBufferSize.setDescription('Size of the buffer for a packet capture session. A value zero for this object indicates that there is no limitation.')
cpcBufferAction = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 3, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noAction", 1), ("clear", 2), ("export", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpcBufferAction.setStatus('current')
if mibBuilder.loadTexts: cpcBufferAction.setDescription("The action control for this packet capture session buffer. noAction: no action (do nothing). clear: clear this capture buffer. export: exporting the buffer contents to the storage specified by cpcSessionDestFileName of cpcSessionConfigEntry with the same cpcSessionId value. When the value is set to 'noAction', no operation is performed. When read, the value 'noAction' is always returned.")
cpcBufferOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 3, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("other", 1), ("exporting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcBufferOperStatus.setStatus('current')
if mibBuilder.loadTexts: cpcBufferOperStatus.setDescription('Operational status of a packet capture buffer. other : none of the following. exporting : buffer is being exported to the storage denoted by cpcSessionDestFileName from cpcSessionConfigEntry indexed by the same cpcSessionId.')
cpcScheduleConfigTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 4, 1), )
if mibBuilder.loadTexts: cpcScheduleConfigTable.setStatus('current')
if mibBuilder.loadTexts: cpcScheduleConfigTable.setDescription('A table of schedule configuration and information for packet capture sessions.')
cpcScheduleConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"))
if mibBuilder.loadTexts: cpcScheduleConfigEntry.setStatus('current')
if mibBuilder.loadTexts: cpcScheduleConfigEntry.setDescription("An entry containing schedule configuration and information for a packet capture session. An entry is created corresponding to each entry in cpcSessionConfigTable if scheduled operation is required for a packet capture session. This entry may not be modified if value of the corresponding instance of cpcSessionOperStatus is 'inProgress'.")
cpcScheduleStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 4, 1, 1, 1), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpcScheduleStartTime.setStatus('current')
if mibBuilder.loadTexts: cpcScheduleStartTime.setDescription('The date and time this packet capture session will be started. A value of all zero with length of eight indicates either the scheduled time has expired or none is scheduled.')
cpcScheduleCapturePeriod = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 4, 1, 1, 2), Unsigned32()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: cpcScheduleCapturePeriod.setStatus('current')
if mibBuilder.loadTexts: cpcScheduleCapturePeriod.setDescription('The length of time, in seconds, that this packet capture session will be running. Value of zero indicates that there is no restriction on the capture period.')
cpcSessionStatsTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 5, 1), )
if mibBuilder.loadTexts: cpcSessionStatsTable.setStatus('current')
if mibBuilder.loadTexts: cpcSessionStatsTable.setDescription('A table of statistic information for packet capture sessions.')
cpcSessionStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-PACKET-CAPTURE-MIB", "cpcSessionId"))
if mibBuilder.loadTexts: cpcSessionStatsEntry.setStatus('current')
if mibBuilder.loadTexts: cpcSessionStatsEntry.setDescription('An entry contains statistic information of a packet capture session.')
cpcSessionPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 5, 1, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcSessionPacketsReceived.setStatus('current')
if mibBuilder.loadTexts: cpcSessionPacketsReceived.setDescription('Indicates the number of packets received in this sessions.')
cpcSessionPacketsCaptured = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 5, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcSessionPacketsCaptured.setStatus('current')
if mibBuilder.loadTexts: cpcSessionPacketsCaptured.setDescription('Indicates the number of packets captured in this session.')
cpcSessionPacketsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 602, 1, 5, 1, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpcSessionPacketsDropped.setStatus('current')
if mibBuilder.loadTexts: cpcSessionPacketsDropped.setDescription('Indicates the number of packets dropped in this session.')
cpcMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 1))
cpcMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2))
cpcCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 1, 1)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcGenericConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcMacFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcIpFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcDestFileNameConfigGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcCompliance = cpcCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: cpcCompliance.setDescription('The compliance statement for devices that implement CISCO-PACKET-CAPTURE-MIB.')
cpcComplianceRev1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 1, 2)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcGenericConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcMacFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcIpFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcDestFileNameConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcPacketLengthFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcEthertypeFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcVlanFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcAccessGroupFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcBufferConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcScheduleConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionStatsGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcMaxMacFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcMaxIpFilterConfigGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionPacketRateLimitGroup"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionDescrGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcComplianceRev1 = cpcComplianceRev1.setStatus('current')
if mibBuilder.loadTexts: cpcComplianceRev1.setDescription('The compliance statement for devices that implement CISCO-PACKET-CAPTURE-MIB.')
cpcGenericConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 1)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMaxSessionAllowed"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionOperStatus"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionMaxSources"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionPacketLength"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionPacketLimits"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionAction"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionConfigStatus"), ("CISCO-PACKET-CAPTURE-MIB", "cpcCaptureSourceIfDirection"), ("CISCO-PACKET-CAPTURE-MIB", "cpcCaptureSourceIfStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcGenericConfigGroup = cpcGenericConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcGenericConfigGroup.setDescription('A collection of object(s) that provides the generic configuration for packet capture feature.')
cpcFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 2)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMaxFilterAllowed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcFilterConfigGroup = cpcFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcFilterConfigGroup.setDescription('A collection of object(s) that provides general filter configuration for packet capture feature.')
cpcMacFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 3)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMacFilterRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcMacFilterConfigGroup = cpcMacFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcMacFilterConfigGroup.setDescription('A collection of object(s) that provides the MAC address filter configuration for packet capture feature.')
cpcIpFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 4)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcIpFilterMask"), ("CISCO-PACKET-CAPTURE-MIB", "cpcIpFilterRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcIpFilterConfigGroup = cpcIpFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcIpFilterConfigGroup.setDescription('A collection of object(s) that provides the IP address filter configuration for packet capture feature.')
cpcDestFileNameConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 5)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcSessionDestFileName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcDestFileNameConfigGroup = cpcDestFileNameConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcDestFileNameConfigGroup.setDescription('A collection of object(s) that provides configuration for destination file for packet capture feature.')
cpcPacketLengthFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 6)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcPacketLengthFilterMin"), ("CISCO-PACKET-CAPTURE-MIB", "cpcPacketLengthFilterMax"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcPacketLengthFilterConfigGroup = cpcPacketLengthFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcPacketLengthFilterConfigGroup.setDescription('A collection of object(s) that provides packet length filter configuration for packet capture feature.')
cpcEthertypeFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 7)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMaxEthertypeFilterAllowed"), ("CISCO-PACKET-CAPTURE-MIB", "cpcEthertypeFilterStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcEthertypeFilterConfigGroup = cpcEthertypeFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcEthertypeFilterConfigGroup.setDescription('A collection of object(s) that provides Ethertype filter configuration for packet capture feature.')
cpcVlanFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 8)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMaxVlanFilterAllowed"), ("CISCO-PACKET-CAPTURE-MIB", "cpcVlanFilterRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcVlanFilterConfigGroup = cpcVlanFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcVlanFilterConfigGroup.setDescription('A collection of object(s) that provides VLAN filter configuration for packet capture feature.')
cpcAccessGroupFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 9)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMaxAccessGroupFilterAllowed"), ("CISCO-PACKET-CAPTURE-MIB", "cpcAccessGroupFilterStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcAccessGroupFilterConfigGroup = cpcAccessGroupFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcAccessGroupFilterConfigGroup.setDescription('A collection of object(s) that provides Access Group filter configuration for packet capture feature.')
cpcBufferConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 10)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcBufferType"), ("CISCO-PACKET-CAPTURE-MIB", "cpcBufferSize"), ("CISCO-PACKET-CAPTURE-MIB", "cpcBufferAction"), ("CISCO-PACKET-CAPTURE-MIB", "cpcBufferOperStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcBufferConfigGroup = cpcBufferConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcBufferConfigGroup.setDescription('A collection of object(s) that provides buffer configuration for packet capture feature.')
cpcScheduleConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 11)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcScheduleStartTime"), ("CISCO-PACKET-CAPTURE-MIB", "cpcScheduleCapturePeriod"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcScheduleConfigGroup = cpcScheduleConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcScheduleConfigGroup.setDescription('A collection of object(s) that provides schedule configuration for packet capture feature.')
cpcSessionStatsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 12)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcSessionPacketsReceived"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionPacketsCaptured"), ("CISCO-PACKET-CAPTURE-MIB", "cpcSessionPacketsDropped"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcSessionStatsGroup = cpcSessionStatsGroup.setStatus('current')
if mibBuilder.loadTexts: cpcSessionStatsGroup.setDescription('A collection of object(s) that provides statistic information for packet capture feature.')
cpcMaxMacFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 13)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMaxMacFilterAllowed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcMaxMacFilterConfigGroup = cpcMaxMacFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcMaxMacFilterConfigGroup.setDescription('A collection of object(s) that provides information on the maximum MAC address filter allowed for each packet capture session.')
cpcMaxIpFilterConfigGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 14)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcMaxIpFilterAllowed"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcMaxIpFilterConfigGroup = cpcMaxIpFilterConfigGroup.setStatus('current')
if mibBuilder.loadTexts: cpcMaxIpFilterConfigGroup.setDescription('A collection of object(s) that provides information on the maximum IP address filter allowed for each packet capture session.')
cpcSessionPacketRateLimitGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 15)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcSessionPacketRateLimit"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcSessionPacketRateLimitGroup = cpcSessionPacketRateLimitGroup.setStatus('current')
if mibBuilder.loadTexts: cpcSessionPacketRateLimitGroup.setDescription('A collection of object(s) that provides rate limit configuration for packet capture feature.')
cpcSessionDescrGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 602, 2, 2, 16)).setObjects(("CISCO-PACKET-CAPTURE-MIB", "cpcSessionDescr"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cpcSessionDescrGroup = cpcSessionDescrGroup.setStatus('current')
if mibBuilder.loadTexts: cpcSessionDescrGroup.setDescription('A collection of object(s) that provides session description configuration for packet capture feature.')
mibBuilder.exportSymbols("CISCO-PACKET-CAPTURE-MIB", cpcVlanFilterVlanIndex=cpcVlanFilterVlanIndex, cpcSessionPacketsCaptured=cpcSessionPacketsCaptured, cpcIpFilterRowStatus=cpcIpFilterRowStatus, cpcSessionAction=cpcSessionAction, cpcSessionStats=cpcSessionStats, cpcEthertypeFilterValue=cpcEthertypeFilterValue, cpcDestFileNameConfigGroup=cpcDestFileNameConfigGroup, cpcMaxIpFilterAllowed=cpcMaxIpFilterAllowed, cpcMIBNotification=cpcMIBNotification, cpcSessionMaxSources=cpcSessionMaxSources, cpcPacketLengthFilterTable=cpcPacketLengthFilterTable, cpcAccessGroupFilterName=cpcAccessGroupFilterName, cpcMIBConformance=cpcMIBConformance, cpcSessionDescr=cpcSessionDescr, cpcFilterConfigGroup=cpcFilterConfigGroup, cpcIpFilterMask=cpcIpFilterMask, cpcMIBObjects=cpcMIBObjects, cpcIpFilterTable=cpcIpFilterTable, cpcEthertypeFilterEntry=cpcEthertypeFilterEntry, cpcMaxSessionAllowed=cpcMaxSessionAllowed, ciscoPacketCaptureMIB=ciscoPacketCaptureMIB, cpcSessionPacketRateLimitGroup=cpcSessionPacketRateLimitGroup, cpcScheduleConfigGroup=cpcScheduleConfigGroup, cpcFilterConfig=cpcFilterConfig, cpcSessionStatsEntry=cpcSessionStatsEntry, cpcVlanFilterEntry=cpcVlanFilterEntry, cpcMacFilterTable=cpcMacFilterTable, cpcEthertypeFilterConfigGroup=cpcEthertypeFilterConfigGroup, cpcGenericConfig=cpcGenericConfig, cpcBufferSize=cpcBufferSize, cpcMacFilterCriteria=cpcMacFilterCriteria, cpcCaptureSourceIfDirection=cpcCaptureSourceIfDirection, cpcSessionDescrGroup=cpcSessionDescrGroup, cpcIpFilterEntry=cpcIpFilterEntry, cpcCompliance=cpcCompliance, cpcMacFilterConfigGroup=cpcMacFilterConfigGroup, cpcIpFilterCriteria=cpcIpFilterCriteria, cpcScheduleConfig=cpcScheduleConfig, PYSNMP_MODULE_ID=ciscoPacketCaptureMIB, cpcPacketLengthFilterMin=cpcPacketLengthFilterMin, cpcIpFilterAddress=cpcIpFilterAddress, cpcBufferType=cpcBufferType, cpcSessionPacketsDropped=cpcSessionPacketsDropped, cpcPacketLengthFilterMax=cpcPacketLengthFilterMax, cpcComplianceRev1=cpcComplianceRev1, cpcPacketLengthFilterEntry=cpcPacketLengthFilterEntry, cpcSessionPacketLength=cpcSessionPacketLength, cpcBufferOperStatus=cpcBufferOperStatus, cpcSessionConfigStatus=cpcSessionConfigStatus, cpcAccessGroupFilterType=cpcAccessGroupFilterType, cpcSessionConfigTable=cpcSessionConfigTable, cpcAccessGroupFilterStatus=cpcAccessGroupFilterStatus, cpcSessionStatsTable=cpcSessionStatsTable, cpcEthertypeFilterStatus=cpcEthertypeFilterStatus, cpcAccessGroupFilterTable=cpcAccessGroupFilterTable, cpcMIBCompliances=cpcMIBCompliances, cpcMaxEthertypeFilterAllowed=cpcMaxEthertypeFilterAllowed, cpcAccessGroupFilterConfigGroup=cpcAccessGroupFilterConfigGroup, cpcBufferConfig=cpcBufferConfig, cpcSessionPacketsReceived=cpcSessionPacketsReceived, cpcMIBGroups=cpcMIBGroups, cpcMaxIpFilterConfigGroup=cpcMaxIpFilterConfigGroup, cpcPacketLengthFilterConfigGroup=cpcPacketLengthFilterConfigGroup, cpcCaptureSourceIfEntry=cpcCaptureSourceIfEntry, cpcBufferConfigTable=cpcBufferConfigTable, cpcSessionOperStatus=cpcSessionOperStatus, cpcScheduleStartTime=cpcScheduleStartTime, cpcScheduleConfigEntry=cpcScheduleConfigEntry, cpcVlanFilterTable=cpcVlanFilterTable, cpcMaxFilterAllowed=cpcMaxFilterAllowed, cpcSessionStatsGroup=cpcSessionStatsGroup, cpcVlanFilterRowStatus=cpcVlanFilterRowStatus, cpcSessionPacketLimits=cpcSessionPacketLimits, cpcMaxMacFilterAllowed=cpcMaxMacFilterAllowed, cpcIpFilterConfigGroup=cpcIpFilterConfigGroup, cpcSessionConfigEntry=cpcSessionConfigEntry, cpcBufferConfigGroup=cpcBufferConfigGroup, cpcBufferAction=cpcBufferAction, cpcMacFilterRowStatus=cpcMacFilterRowStatus, cpcIpFilterAddressType=cpcIpFilterAddressType, cpcSessionPacketRateLimit=cpcSessionPacketRateLimit, cpcBufferConfigEntry=cpcBufferConfigEntry, cpcSessionId=cpcSessionId, cpcScheduleConfigTable=cpcScheduleConfigTable, cpcMaxAccessGroupFilterAllowed=cpcMaxAccessGroupFilterAllowed, cpcCaptureSourceIfTable=cpcCaptureSourceIfTable, cpcScheduleCapturePeriod=cpcScheduleCapturePeriod, cpcCaptureSourceIfStatus=cpcCaptureSourceIfStatus, cpcMaxMacFilterConfigGroup=cpcMaxMacFilterConfigGroup, cpcAccessGroupFilterEntry=cpcAccessGroupFilterEntry, cpcGenericConfigGroup=cpcGenericConfigGroup, cpcMaxVlanFilterAllowed=cpcMaxVlanFilterAllowed, CiscoPacketCaptureFilterCriteria=CiscoPacketCaptureFilterCriteria, cpcEthertypeFilterTable=cpcEthertypeFilterTable, cpcMacFilterEntry=cpcMacFilterEntry, cpcMacFilterMacAddress=cpcMacFilterMacAddress, cpcSessionDestFileName=cpcSessionDestFileName, cpcVlanFilterConfigGroup=cpcVlanFilterConfigGroup)

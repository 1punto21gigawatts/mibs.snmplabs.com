#
# PySNMP MIB module SMF-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SMF-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:07:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
IANAsmfRssaIdTC, IANAsmfOpModeIdTC = mibBuilder.importSymbols("IANA-SMF-MIB", "IANAsmfRssaIdTC", "IANAsmfOpModeIdTC")
ifName, InterfaceIndexOrZero = mibBuilder.importSymbols("IF-MIB", "ifName", "InterfaceIndexOrZero")
InetAddressType, InetAddressPrefixLength, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddressPrefixLength", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Unsigned32, Counter32, iso, Bits, ObjectIdentity, MibIdentifier, ModuleIdentity, IpAddress, Counter64, TimeTicks, Gauge32, experimental, Integer32, NotificationType, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter32", "iso", "Bits", "ObjectIdentity", "MibIdentifier", "ModuleIdentity", "IpAddress", "Counter64", "TimeTicks", "Gauge32", "experimental", "Integer32", "NotificationType", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TruthValue, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TruthValue", "RowStatus", "TextualConvention")
smfMIB = ModuleIdentity((1, 3, 6, 1, 3, 126))
smfMIB.setRevisions(('2014-10-10 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: smfMIB.setRevisionsDescriptions(('The first version of this MIB module, published as RFC 7367. ',))
if mibBuilder.loadTexts: smfMIB.setLastUpdated('201410100000Z')
if mibBuilder.loadTexts: smfMIB.setOrganization('IETF MANET Working Group')
if mibBuilder.loadTexts: smfMIB.setContactInfo('WG EMail: manet@ietf.org WG Chairs: sratliff@cisco.com jmacker@nrl.navy.mil Editors: Robert G. Cole US Army CERDEC 6010 Frankford Road Aberdeen Proving Ground, MD 21005 USA Phone: +1 443 395-8744 EMail: robert.g.cole@us.army.mil Joseph Macker Naval Research Laboratory Washington, D.C. 20375 USA EMail: macker@itd.nrl.navy.mil Brian Adamson Naval Research Laboratory Washington, D.C. 20375 USA EMail: adamson@itd.nrl.navy.mil')
if mibBuilder.loadTexts: smfMIB.setDescription("This MIB module contains managed object definitions for the MANET SMF RSSA process defined in: Macker, J., Ed., Simplified Multicast Forwarding, RFC 6621, May 2012. Copyright (c) 2014 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).")
class SmfStatus(TextualConvention, Integer32):
    description = "An indication of the operability of an SMF function or feature. For example, the status of an interface: 'enabled' indicates that this interface is performing SMF functions and 'disabled' indicates that it is not. Similarly, for the status of the device: 'enabled' indicates that the device has enabled the SMF functions on the device and 'disabled' means that the device and all interfaces have disabled all SMF functions."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

smfMIBNotifications = MibIdentifier((1, 3, 6, 1, 3, 126, 0))
smfMIBObjects = MibIdentifier((1, 3, 6, 1, 3, 126, 1))
smfMIBConformance = MibIdentifier((1, 3, 6, 1, 3, 126, 2))
smfCapabilitiesGroup = MibIdentifier((1, 3, 6, 1, 3, 126, 1, 1))
smfCapabilitiesTable = MibTable((1, 3, 6, 1, 3, 126, 1, 1, 1), )
if mibBuilder.loadTexts: smfCapabilitiesTable.setReference("See Section 7.2 'Reduced Relay Set Forwarding', Section 8.1.1 'SMF Message TLV Type', and the Appendices A, B, and C in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., May 2012.")
if mibBuilder.loadTexts: smfCapabilitiesTable.setStatus('current')
if mibBuilder.loadTexts: smfCapabilitiesTable.setDescription('The smfCapabilitiesTable identifies the resident set of SMF Operational Modes and RSSA combinations that can run on this forwarder.')
smfCapabilitiesEntry = MibTableRow((1, 3, 6, 1, 3, 126, 1, 1, 1, 1), ).setIndexNames((0, "SMF-MIB", "smfCapabilitiesIndex"))
if mibBuilder.loadTexts: smfCapabilitiesEntry.setStatus('current')
if mibBuilder.loadTexts: smfCapabilitiesEntry.setDescription('Information about a particular operational mode and RSSA combination. ')
smfCapabilitiesIndex = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: smfCapabilitiesIndex.setStatus('current')
if mibBuilder.loadTexts: smfCapabilitiesIndex.setDescription("The index for this entry; a unique value, greater than zero, for each combination of a particular operational mode and RSSA available on this device. It is recommended that values are assigned contiguously starting from 1. Rows in this table are automatically populated by the entity's management system on initialization. By default, the agent should support at least the Classical Flooding 'cF' algorithm. All compliant SMF forwarders must support Classical Flooding. Hence, the first entry in this table MUST exist and MUST be defined as: smfCapabilitiesIndex i '1' smfCapabilitiesOpModeID i 'cfOnly(1)' smfCapabilitiesRssaID i 'cF(1)' The value for each combination MUST remain constant at least from one re-initialization of the entity's management system to the next re-initialization.")
smfCapabilitiesOpModeID = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 1, 1, 1, 2), IANAsmfOpModeIdTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smfCapabilitiesOpModeID.setStatus('current')
if mibBuilder.loadTexts: smfCapabilitiesOpModeID.setDescription('This object identifies the particular operational mode for this device.')
smfCapabilitiesRssaID = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 1, 1, 1, 3), IANAsmfRssaIdTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smfCapabilitiesRssaID.setReference("For example, see Section 8.1.1 'SMF Message TLV Type', and the Appendices A, B, and C in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., May 2012.")
if mibBuilder.loadTexts: smfCapabilitiesRssaID.setStatus('current')
if mibBuilder.loadTexts: smfCapabilitiesRssaID.setDescription('This object identifies the particular RSSA algorithm in this MIB module. Example RSSAs are found in the appendix of RFC 6621.')
smfConfigurationGroup = MibIdentifier((1, 3, 6, 1, 3, 126, 1, 2))
smfCfgAdminStatus = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 1), SmfStatus().clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgAdminStatus.setStatus('current')
if mibBuilder.loadTexts: smfCfgAdminStatus.setDescription("The configured status of the SMF process on this device. 'enabled(1)' means that SMF is configured to run on this device. 'disabled(2)' means that the SMF process is configured off. Prior to SMF functions being performed over specific interfaces, this object must first be 'enabled'. If this object is 'disabled', then no SMF functions are being performed on the device and all smfCfgIfAdminStatus objects MUST also be set to 'disabled'. When this object is changed from 'enabled' to 'disabled' by the manager, then all smfCfgIfAdminStatus objects MUST also be automatically set to 'disabled' by the agent. The default value for this object SHOULD be 'enabled'. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgSmfSysUpTime = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smfCfgSmfSysUpTime.setStatus('current')
if mibBuilder.loadTexts: smfCfgSmfSysUpTime.setDescription("The time (in hundredths of a second) since the system SMF process was last re-initialized. The SMF process is re-initialized when the value of the 'smfCfgAdminStatus' object transitions to 'enabled' from either a prior value of 'disabled' or upon initialization of this device.")
smfCfgRouterIDAddrType = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 3), InetAddressType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))).clone('ipv4')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgRouterIDAddrType.setStatus('current')
if mibBuilder.loadTexts: smfCfgRouterIDAddrType.setDescription("The address type of the address used for the SMF ID of this router as specified in the 'smfCfgRouterID' next. Only the values ipv4(1) and ipv6(2) are supported. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgRouterID = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgRouterID.setReference("For example, see Appendix A.1 'E-CDS Relay Set Selection Overview' and Appendix C.1 'MPR-CDS Relay Set Selection Overview' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgRouterID.setStatus('current')
if mibBuilder.loadTexts: smfCfgRouterID.setDescription("The IP address used as the SMF router ID. This can be set by the management station. If not explicitly set, then the device SHOULD select a routable IP address assigned to this router for use as the 'smfCfgRouterID'. The smfCfgRouterID is a logical identification that MUST be consistent across interoperable SMF neighborhoods, and it is RECOMMENDED to be chosen as the numerically largest address contained in a node's 'Neighbor Address List' as defined in NHDP. An smfCfgRouterID MUST be unique within the scope of the operating MANET network regardless of the method used for selecting it. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgOperationalMode = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgOperationalMode.setReference("See Section 7.2 'Reduced Relay Set Forwarding', and the Appendices A, B, and C in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgOperationalMode.setStatus('current')
if mibBuilder.loadTexts: smfCfgOperationalMode.setDescription("The SMF RSS node operational mode and RSSA combination active on this local forwarder. This object is defined to be equal to the smfCapabilitiesIndex, which identifies the specific active operational mode and RSSA. The default value for this object is '1', which corresponds to: smfCapabilitiesOpModeID i 'cfOnly(1)' smfCapabilitiesRssaID i 'cF(1)' This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgRssaMember = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("potential", 1), ("always", 2), ("never", 3))).clone('potential')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgRssaMember.setReference("See Section 7 'Relay Set Selection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgRssaMember.setStatus('current')
if mibBuilder.loadTexts: smfCfgRssaMember.setDescription("The RSSA downselects a set of forwarders for multicast forwarding. Sometimes it is useful to force an agent to be included or excluded from the resulting RSS. This object is a switch to allow for this behavior. The value 'potential(1)' allows the selected RSSA to determine if this agent is included or excluded from the RSS. The value 'always(2)' forces the selected RSSA to include this agent in the RSS. The value 'never(3)' forces the selected RSSA to exclude this agent from the RSS. The default setting for this object is 'potential(1)'. Other settings could pose operational risks under certain conditions. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgIpv4Dpd = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hashBased", 1), ("identificationBased", 2))).clone('hashBased')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgIpv4Dpd.setReference("See Section 6.2 'IPv4 Duplicate Packet Detection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgIpv4Dpd.setStatus('current')
if mibBuilder.loadTexts: smfCfgIpv4Dpd.setDescription("The current method for IPv4 duplicate packet detection. The value 'hashBased(1)' indicates that the router's duplicate packet detection is based upon comparing a hash over the packet fields. This is the default setting for this object. The value 'identificationBased(2)' indicates that the duplicate packet detection relies upon header information in the multicast packets to identify previously received packets. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgIpv6Dpd = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("hashBased", 1), ("identificationBased", 2))).clone('hashBased')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgIpv6Dpd.setReference("See Section 6.1 'IPv6 Duplicate Packet Detection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgIpv6Dpd.setStatus('current')
if mibBuilder.loadTexts: smfCfgIpv6Dpd.setDescription("The current method for IPv6 duplicate packet detection. The values indicate the type of method used for duplicate packet detection as described the previous description for the object 'smfCfgIpv4Dpd'. The default value for this object is 'hashBased(1)'. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgMaxPktLifetime = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(60)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgMaxPktLifetime.setReference("See Section 6 'SMF Duplicate Packet Detection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgMaxPktLifetime.setStatus('current')
if mibBuilder.loadTexts: smfCfgMaxPktLifetime.setDescription('The estimate of the network packet traversal time. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.')
smfCfgDpdEntryMaxLifetime = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65525)).clone(600)).setUnits('Seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgDpdEntryMaxLifetime.setReference("See Section 6 'SMF Duplicate Packet Detection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgDpdEntryMaxLifetime.setStatus('current')
if mibBuilder.loadTexts: smfCfgDpdEntryMaxLifetime.setDescription('The maximum lifetime of a cached DPD record in the local device storage. If the memory is running low prior to the MaxLifetime being exceeded, the local SMF devices should purge the oldest records first. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.')
smfCfgNhdpRssaMesgTLVIncluded = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 11), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgNhdpRssaMesgTLVIncluded.setReference("See Section 8.1.1 'SMF Message TLV Type' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgNhdpRssaMesgTLVIncluded.setStatus('current')
if mibBuilder.loadTexts: smfCfgNhdpRssaMesgTLVIncluded.setDescription("Indicates whether or not the associated NHDP messages include the RSSA Message TLV. This is an optional SMF operational setting. The value 'true(1)' indicates that this TLV is included; the value 'false(2)' indicates that it is not included. It is RECOMMENDED that the RSSA Message TLV be included in the NHDP messages. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgNhdpRssaAddrBlockTLVIncluded = MibScalar((1, 3, 6, 1, 3, 126, 1, 2, 12), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfCfgNhdpRssaAddrBlockTLVIncluded.setReference("See Section 8.1.2 'SMF Address Block TLV Type' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgNhdpRssaAddrBlockTLVIncluded.setStatus('current')
if mibBuilder.loadTexts: smfCfgNhdpRssaAddrBlockTLVIncluded.setDescription("Indicates whether or not the associated NHDP messages include the RSSA Address Block TLV. This is an optional SMF operational setting. The value 'true(1)' indicates that this TLV is included; the value 'false(2)' indicates that it is not included. The smfCfgNhdpRssaAddrBlockTLVIncluded is optional in all cases as it depends on the existence of an address block that may not be present. If this SMF device is configured with NHDP, then this object SHOULD be set to 'true(1)'. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.")
smfCfgAddrForwardingTable = MibTable((1, 3, 6, 1, 3, 126, 1, 2, 13), )
if mibBuilder.loadTexts: smfCfgAddrForwardingTable.setReference("See Section 9.1 'Forwarded Multicast Groups' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfCfgAddrForwardingTable.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingTable.setDescription('The smfCfgAddrForwardingTable is essentially a filter table (if populated) that identifies addresses/packets to be forwarded via the local SMF flooding process. The IP Multicast MIB module in RFC 5132 manages objects related to standard IP multicast, which could be running in parallel to SMF on the device. RFC 5132 manages traditional IP-based multicast (based upon multicast routing mechanisms). The SMF-MIB module provides management for a MANET subnet-based flooding mechanism that may be used for multicast transport (through SMF broadcast) depending upon the MANET dynamics and other factors regarding the MANET subnet. Further, they may coexist in certain MANET deployments using the smfCfgAddrForwardingTable to hand certain IP multicast addresses to the SMF process and other IP multicast packets to be forwarded by other multicast mechanisms that are IP route based. SMF and the associated SMF-MIB module are experimental and these are some of the experiments to be had with SMF and the SMF-MIB module. This is the (conceptual) table containing information on multicast addresses that are to be forwarded by the SMF process. This table represents an IP filters table for forwarding (or not) packets based upon their IP multicast address. The SMF process can be configured to forward only those multicast addresses found within the smfCfgAddrForwardingTable. As such, addresses that are to be forwarded by the SMF process MUST be found within the address ranges configured within this table, unless this table is empty. Each row is associated with a range of multicast addresses, and ranges for different rows must be disjoint. Different rows MAY share a common smfCfgAddrForwardingGroupName to administratively associate different rows. The objects in this table are persistent and, when written, the entity SHOULD save the change to non-volatile storage.')
smfCfgAddrForwardingEntry = MibTableRow((1, 3, 6, 1, 3, 126, 1, 2, 13, 1), ).setIndexNames((0, "SMF-MIB", "smfCfgAddrForwardingIndex"))
if mibBuilder.loadTexts: smfCfgAddrForwardingEntry.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingEntry.setDescription('An entry (conceptual row) containing the information on a particular multicast scope.')
smfCfgAddrForwardingIndex = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: smfCfgAddrForwardingIndex.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingIndex.setDescription("This object identifies a unique entry for a forwarding group. The index for this entry is a unique value, greater than zero, for each row. It is recommended that values are assigned contiguously starting from 1. The value for each row index MUST remain constant from one re-initialization of the entity's management system to the next re-initialization.")
smfCfgAddrForwardingGroupName = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 13, 1, 2), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smfCfgAddrForwardingGroupName.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingGroupName.setDescription('This object identifies a group name for a set of row entries in order to administratively associate a set of address ranges. If there is no group name or this object is otherwise not applicable, then this object contains a zero-length string. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.')
smfCfgAddrForwardingAddrType = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 13, 1, 3), InetAddressType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smfCfgAddrForwardingAddrType.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingAddrType.setDescription('The type of the addresses in the multicast forwarding ranges identified by this table. Only the values ipv4(1) and ipv6(2) are supported. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.')
smfCfgAddrForwardingAddress = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 13, 1, 4), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smfCfgAddrForwardingAddress.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingAddress.setDescription('The multicast group address that, when combined with smfCfgAddrForwardingAddrPrefixLength, gives the group prefix for this forwarding range. The InetAddressType is given by smfCfgAddrForwardingAddrType. This address object is only significant up to smfCfgAddrForwardingAddrPrefixLength bits. The remaining address bits are set to zero. This is especially important for this index field. Any non-zero bits would signify an entirely different entry. Legal values correspond to the subset of address families for which multicast address allocation is supported. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.')
smfCfgAddrForwardingAddrPrefixLength = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 13, 1, 5), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smfCfgAddrForwardingAddrPrefixLength.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingAddrPrefixLength.setDescription('The length in bits of the mask that, when combined with smfCfgAddrForwardingAddress, gives the group prefix for this forwarding range. This object is persistent and, when written, the entity SHOULD save the change to non-volatile storage.')
smfCfgAddrForwardingStatus = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 13, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smfCfgAddrForwardingStatus.setStatus('current')
if mibBuilder.loadTexts: smfCfgAddrForwardingStatus.setDescription('The status of this row, by which new entries may be created, or old entries deleted from this table.')
smfCfgInterfaceTable = MibTable((1, 3, 6, 1, 3, 126, 1, 2, 14), )
if mibBuilder.loadTexts: smfCfgInterfaceTable.setReference("RFC 2863 - 'The Interfaces Group MIB', McCloghrie, K., and F. Kastenholtz, June 2000.")
if mibBuilder.loadTexts: smfCfgInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: smfCfgInterfaceTable.setDescription("The SMF Interface Table describes the SMF interfaces that are participating in the SMF packet forwarding process. The ifIndex is from the interfaces group defined in the Interfaces Group MIB module (RFC 2863). As such, this table 'sparse augments' the ifTable specifically when SMF is to be configured to operate over this interface. A conceptual row in this table exists if and only if either a manager has explicitly created the row or there is an interface on the managed device that automatically supports and runs SMF as part of the device's initialization process. The manager creates a row in this table by setting the rowStatus to 'createAndGo' or 'createAndWait'. Row objects having associated DEFVAL clauses are automatically defined by the agent with these values during row creation, unless the manager explicitly defines these object values during the row creation. As the smfCfgInterfaceTable sparsely augments the IfTable. Hence, + an entry cannot exist in smfCfgInterfaceTable without a corresponding entry in the ifTable. + if an entry in the ifTable is removed, the corresponding entry (if it exists) in the smfCfgInterfaceTable MUST be removed. + the smfCfgIfStatus can have a value of 'enabled' or 'disabled' independent of the current value of the ifAdminStatus of the corresponding entry in the ifTable. The values of the objects smfCfgAdminStatus and smfCfgIfAdminStatus reflect the up-down status of the SMF process running on the device and on the specific interfaces, respectively. Hence, + the value of the smfCfgAdminStatus can be 'enabled' or 'disabled' reflecting the current running status of the SMF process on the device. + the value of the smfCfgIfAdminStatus can be 'enabled' or 'disabled' if the value of the smfCfgAdminStatus is set to 'enabled'. + if the value of the smfCfgAdminStatus is 'disabled', then the corresponding smfCfgIfAdminStatus objects MUST be set to 'disabled' in the smfCfgInterfaceTable. + once the value of the smfCfgAdminStatus changes from 'disabled' to 'enabled', it is up to the management system to make the corresponding changes to the smfCfgIfAdminStatus values back to 'enabled'. ")
smfCfgInterfaceEntry = MibTableRow((1, 3, 6, 1, 3, 126, 1, 2, 14, 1), ).setIndexNames((0, "SMF-MIB", "smfCfgIfIndex"))
if mibBuilder.loadTexts: smfCfgInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: smfCfgInterfaceEntry.setDescription('The SMF interface entry describes one SMF interface as indexed by its ifIndex. The objects in this table are persistent and, when written, the device SHOULD save the change to non-volatile storage. For further information on the storage behavior for these objects, refer to the description for the smfCfgIfRowStatus object.')
smfCfgIfIndex = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 14, 1, 1), InterfaceIndexOrZero())
if mibBuilder.loadTexts: smfCfgIfIndex.setReference("RFC 2863 - 'The Interfaces Group MIB', McCloghrie, K., and F. Kastenholtz, June 2000.")
if mibBuilder.loadTexts: smfCfgIfIndex.setStatus('current')
if mibBuilder.loadTexts: smfCfgIfIndex.setDescription("The ifIndex for this SMF interface. This value MUST correspond to an ifIndex referring to a valid entry in the Interfaces Table. If the manager attempts to create a row for which the ifIndex does not exist on the local device, then the agent SHOULD issue a return value of 'inconsistentValue' and the operation SHOULD fail.")
smfCfgIfAdminStatus = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 14, 1, 2), SmfStatus().clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smfCfgIfAdminStatus.setStatus('current')
if mibBuilder.loadTexts: smfCfgIfAdminStatus.setDescription("The SMF interface's administrative status. The value 'enabled' denotes that the interface is running the SMF forwarding process. The value 'disabled' denotes that the interface is currently external to the SMF forwarding process. When the value of the smfCfgAdminStatus is 'disabled', then the corresponding smfCfgIfAdminStatus objects MUST be set to 'disabled' in the smfCfgInterfaceTable. If this object is not equal to 'enabled', all associated entries in the 'smfPerfIpv4InterfacePerfTable' and the 'smfPerfIpv6InterfacePerfTable' MUST be deleted. The default value for this object is 'enabled(1)'. This object SHOULD be persistent and when written the device SHOULD save the change to non-volatile storage.")
smfCfgIfSmfUpTime = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 14, 1, 3), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smfCfgIfSmfUpTime.setStatus('current')
if mibBuilder.loadTexts: smfCfgIfSmfUpTime.setDescription("The time (in hundredths of a second) since this interface SMF process was last re-initialized. The interface SMF process is re-initialized when the value of the 'smfCfgIfAdminStatus' object transitions to 'enabled' from either a prior value of 'disabled' or upon initialization of this interface or this device.")
smfCfgIfRowStatus = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 2, 14, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: smfCfgIfRowStatus.setStatus('current')
if mibBuilder.loadTexts: smfCfgIfRowStatus.setDescription("This object permits management of this table by facilitating actions such as row creation, construction, and destruction. The value of this object has no effect on whether other objects in this conceptual row can be modified. An entry may not exist in the 'active' state unless all objects in the entry have a defined appropriate value. For objects with DEFVAL clauses, the management station does not need to specify the value of these objects in order for the row to transit to the 'active' state; the default value for these objects is used. For objects that do not have DEFVAL clauses, the network manager MUST specify the value of these objects prior to this row transitioning to the 'active' state. When this object transitions to 'active', all objects in this row SHOULD be written to non-volatile (stable) storage. Read-create objects in this row MAY be modified. When an object in a row with smfCfgIfRowStatus of 'active' is changed, then the updated value MUST be reflected in SMF and this new object value MUST be written to non-volatile storage.")
smfStateGroup = MibIdentifier((1, 3, 6, 1, 3, 126, 1, 3))
smfStateNodeRsStatusIncluded = MibScalar((1, 3, 6, 1, 3, 126, 1, 3, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smfStateNodeRsStatusIncluded.setReference("See Section 7 'Relay Set Selection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfStateNodeRsStatusIncluded.setStatus('current')
if mibBuilder.loadTexts: smfStateNodeRsStatusIncluded.setDescription("The current status of the SMF node in the context of the MANETs relay set. A value of 'true(1)' indicates that the node is currently part of the MANET Relay Set. A value of 'false(2)' indicates that the node is currently not part of the MANET Relay Set.")
smfStateDpdMemoryOverflow = MibScalar((1, 3, 6, 1, 3, 126, 1, 3, 2), Counter32()).setUnits('DPD Records').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfStateDpdMemoryOverflow.setReference("See Section 6 'SMF Duplicate Packet Detection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfStateDpdMemoryOverflow.setStatus('current')
if mibBuilder.loadTexts: smfStateDpdMemoryOverflow.setDescription('The number of DPD records that had to be flushed to prevent memory overruns for caching of these records. The number of records to be flushed upon a buffer overflow is an implementation specific decision. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfStateNeighborTable = MibTable((1, 3, 6, 1, 3, 126, 1, 3, 3), )
if mibBuilder.loadTexts: smfStateNeighborTable.setReference("See Section 8 'SMF Neighborhood Discovery' and Section 8.1. 'SMF Relay Algorithm TLV Types' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfStateNeighborTable.setStatus('current')
if mibBuilder.loadTexts: smfStateNeighborTable.setDescription('The SMF StateNeighborTable describes the current one-hop neighbor nodes, their address and SMF RSSA, and the interface on which they can be reached.')
smfStateNeighborEntry = MibTableRow((1, 3, 6, 1, 3, 126, 1, 3, 3, 1), ).setIndexNames((0, "SMF-MIB", "smfStateNeighborIpAddrType"), (0, "SMF-MIB", "smfStateNeighborIpAddr"), (0, "SMF-MIB", "smfStateNeighborPrefixLen"))
if mibBuilder.loadTexts: smfStateNeighborEntry.setStatus('current')
if mibBuilder.loadTexts: smfStateNeighborEntry.setDescription('The SMF Neighbor Table contains the set of one-hop neighbors, the interface they are reachable on, and the SMF RSSA they are currently running.')
smfStateNeighborIpAddrType = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 3, 3, 1, 1), InetAddressType().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ipv4", 1), ("ipv6", 2))))
if mibBuilder.loadTexts: smfStateNeighborIpAddrType.setStatus('current')
if mibBuilder.loadTexts: smfStateNeighborIpAddrType.setDescription("The one-hop neighbor IP address type. Only the values 'ipv4(1)' and 'ipv6(2)' are supported.")
smfStateNeighborIpAddr = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 3, 3, 1, 2), InetAddress().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), )))
if mibBuilder.loadTexts: smfStateNeighborIpAddr.setStatus('current')
if mibBuilder.loadTexts: smfStateNeighborIpAddr.setDescription('The one-hop neighbor Inet IPv4 or IPv6 address. Only IPv4 and IPv6 addresses are supported.')
smfStateNeighborPrefixLen = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 3, 3, 1, 3), InetAddressPrefixLength()).setUnits('bits')
if mibBuilder.loadTexts: smfStateNeighborPrefixLen.setStatus('current')
if mibBuilder.loadTexts: smfStateNeighborPrefixLen.setDescription('The prefix length. This is a decimal value that indicates the number of contiguous, higher-order bits of the address that make up the network portion of the address.')
smfStateNeighborRSSA = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 3, 3, 1, 4), IANAsmfRssaIdTC()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smfStateNeighborRSSA.setStatus('current')
if mibBuilder.loadTexts: smfStateNeighborRSSA.setDescription('The current RSSA running on the neighbor.')
smfStateNeighborNextHopInterface = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 3, 3, 1, 6), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: smfStateNeighborNextHopInterface.setStatus('current')
if mibBuilder.loadTexts: smfStateNeighborNextHopInterface.setDescription('The interface ifIndex over which the neighbor is reachable in one-hop.')
smfPerformanceGroup = MibIdentifier((1, 3, 6, 1, 3, 126, 1, 4))
smfPerfGobalGroup = MibIdentifier((1, 3, 6, 1, 3, 126, 1, 4, 1))
smfPerfIpv4MultiPktsRecvTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 1), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsRecvTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsRecvTotal.setDescription('A counter of the total number of multicast IPv4 packets received by the device and delivered to the SMF process. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv4MultiPktsForwardedTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 2), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsForwardedTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsForwardedTotal.setDescription('A counter of the total number of multicast IPv4 packets forwarded by the device. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv4DuplMultiPktsDetectedTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 3), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4DuplMultiPktsDetectedTotal.setReference("See Section 6.2 'IPv4 Duplicate Packet Detection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv4DuplMultiPktsDetectedTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4DuplMultiPktsDetectedTotal.setDescription('A counter of the total number of duplicate multicast IPv4 packets detected by the device. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv4DroppedMultiPktsTTLExceededTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 4), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4DroppedMultiPktsTTLExceededTotal.setReference("See Section 5 'SMF Packet Processing and Forwarding' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv4DroppedMultiPktsTTLExceededTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4DroppedMultiPktsTTLExceededTotal.setDescription('A counter of the total number of dropped multicast IPv4 packets by the device due to Time to Live (TTL) exceeded. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv4TTLLargerThanPreviousTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 5), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4TTLLargerThanPreviousTotal.setReference("See Section 5 'SMF Packet Processing and Forwarding' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv4TTLLargerThanPreviousTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4TTLLargerThanPreviousTotal.setDescription('A counter of the total number of IPv4 packets received that have a TTL larger than that of a previously received identical packet. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv6MultiPktsRecvTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 6), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsRecvTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsRecvTotal.setDescription('A counter of the total number of multicast IPv6 packets received by the device and delivered to the SMF process. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv6MultiPktsForwardedTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 7), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsForwardedTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsForwardedTotal.setDescription('A counter of the total number of multicast IPv6 packets forwarded by the device. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv6DuplMultiPktsDetectedTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 8), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6DuplMultiPktsDetectedTotal.setReference("See Section 6.1 'IPv6 Duplicate Packet Detection' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv6DuplMultiPktsDetectedTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6DuplMultiPktsDetectedTotal.setDescription('A counter of the total number of duplicate multicast IPv6 packets detected by the device. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv6DroppedMultiPktsTTLExceededTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 9), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6DroppedMultiPktsTTLExceededTotal.setReference("See Section 5 'SMF Packet Processing and Forwarding' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv6DroppedMultiPktsTTLExceededTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6DroppedMultiPktsTTLExceededTotal.setDescription('A counter of the total number of dropped multicast IPv6 packets by the device due to TTL exceeded. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv6TTLLargerThanPreviousTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 10), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6TTLLargerThanPreviousTotal.setReference("See Section 5 'SMF Packet Processing and Forwarding' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv6TTLLargerThanPreviousTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6TTLLargerThanPreviousTotal.setDescription('A counter of the total number of IPv6 packets received that have a TTL larger than that of a previously received identical packet. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv6HAVAssistsReqdTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 11), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6HAVAssistsReqdTotal.setReference("See Section 6.1.1 'IPv6 SMF_DPD Option Header' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv6HAVAssistsReqdTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6HAVAssistsReqdTotal.setDescription('A counter of the total number of IPv6 packets received that required the Hash Assist Value (HAV) for DPD. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfIpv6DpdHeaderInsertionsTotal = MibScalar((1, 3, 6, 1, 3, 126, 1, 4, 1, 12), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6DpdHeaderInsertionsTotal.setReference("See Section 6.1.2 'IPv6 Identification-Based DPD' in RFC 6621 - 'Simplified Multicast Forwarding', Macker, J., Ed., May 2012.")
if mibBuilder.loadTexts: smfPerfIpv6DpdHeaderInsertionsTotal.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6DpdHeaderInsertionsTotal.setDescription('A counter of the total number of IPv6 packets received that the device inserted the DPD header option. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgSmfSysUpTime object also be monitored.')
smfPerfInterfaceGroup = MibIdentifier((1, 3, 6, 1, 3, 126, 1, 4, 2))
smfPerfIpv4InterfacePerfTable = MibTable((1, 3, 6, 1, 3, 126, 1, 4, 2, 1), )
if mibBuilder.loadTexts: smfPerfIpv4InterfacePerfTable.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4InterfacePerfTable.setDescription('The SMF Interface Performance Table describes the SMF counters per interface.')
smfPerfIpv4InterfacePerfEntry = MibTableRow((1, 3, 6, 1, 3, 126, 1, 4, 2, 1, 1), ).setIndexNames((0, "SMF-MIB", "smfCfgIfIndex"))
if mibBuilder.loadTexts: smfPerfIpv4InterfacePerfEntry.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4InterfacePerfEntry.setDescription('The SMF Interface Performance entry describes the statistics for a particular node interface.')
smfPerfIpv4MultiPktsRecvPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 1, 1, 1), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsRecvPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsRecvPerIf.setDescription('A counter of the number of multicast IP packets received by the SMF process on this device on this interface. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv4MultiPktsForwardedPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 1, 1, 2), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsForwardedPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4MultiPktsForwardedPerIf.setDescription('A counter of the number of multicast IP packets forwarded by the SMF process on this device on this interface. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv4DuplMultiPktsDetectedPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 1, 1, 3), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4DuplMultiPktsDetectedPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4DuplMultiPktsDetectedPerIf.setDescription('A counter of the number of duplicate multicast IP packets detected by the SMF process on this device on this interface. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv4DroppedMultiPktsTTLExceededPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 1, 1, 4), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4DroppedMultiPktsTTLExceededPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4DroppedMultiPktsTTLExceededPerIf.setDescription('A counter of the total number of dropped multicast IPv4 packets by the SMF process on this device on this interface due to TTL exceeded. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv4TTLLargerThanPreviousPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 1, 1, 5), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv4TTLLargerThanPreviousPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv4TTLLargerThanPreviousPerIf.setDescription('A counter of the total number of IPv4 packets received by the SMF process on this device on this interface that have a TTL larger than that of a previously received identical packet. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv6InterfacePerfTable = MibTable((1, 3, 6, 1, 3, 126, 1, 4, 2, 2), )
if mibBuilder.loadTexts: smfPerfIpv6InterfacePerfTable.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6InterfacePerfTable.setDescription('The SMF Interface Performance Table describes the SMF counters per interface.')
smfPerfIpv6InterfacePerfEntry = MibTableRow((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1), ).setIndexNames((0, "SMF-MIB", "smfCfgIfIndex"))
if mibBuilder.loadTexts: smfPerfIpv6InterfacePerfEntry.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6InterfacePerfEntry.setDescription('The SMF Interface Performance entry describes the counters for a particular node interface.')
smfPerfIpv6MultiPktsRecvPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1, 1), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsRecvPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsRecvPerIf.setDescription('A counter of the number of multicast IP packets received by the SMF process on this device on this interface. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv6MultiPktsForwardedPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1, 2), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsForwardedPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6MultiPktsForwardedPerIf.setDescription('A counter of the number of multicast IP packets forwarded by the SMF process on this device on this interface. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv6DuplMultiPktsDetectedPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1, 3), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6DuplMultiPktsDetectedPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6DuplMultiPktsDetectedPerIf.setDescription('A counter of the number of duplicate multicast IP packets detected by the SMF process on this device on this interface. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv6DroppedMultiPktsTTLExceededPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1, 4), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6DroppedMultiPktsTTLExceededPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6DroppedMultiPktsTTLExceededPerIf.setDescription('A counter of the number of dropped multicast IP packets by the SMF process on this device on this interface due to TTL exceeded. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv6TTLLargerThanPreviousPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1, 5), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6TTLLargerThanPreviousPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6TTLLargerThanPreviousPerIf.setDescription('A counter of the total number of IPv6 packets received that have a TTL larger than that of a previously received identical packet by the SMF process on this device on this interface. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv6HAVAssistsReqdPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1, 6), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6HAVAssistsReqdPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6HAVAssistsReqdPerIf.setDescription('A counter of the total number of IPv6 packets received by the SMF process on this device on this interface that required the HAV assist for DPD. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfPerfIpv6DpdHeaderInsertionsPerIf = MibTableColumn((1, 3, 6, 1, 3, 126, 1, 4, 2, 2, 1, 7), Counter32()).setUnits('Packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: smfPerfIpv6DpdHeaderInsertionsPerIf.setStatus('current')
if mibBuilder.loadTexts: smfPerfIpv6DpdHeaderInsertionsPerIf.setDescription('A counter of the total number of IPv6 packets received by the SMF process on this device on this interface that the device inserted the DPD header option. There is the potential for a counter discontinuity in this object if the system SMF process has been disabled and later enabled on this interface. In order to check for the occurrence of such a discontinuity when monitoring this counter object, it is recommended that the smfCfgIfSmfUpTime object also be monitored.')
smfMIBNotifObjects = MibIdentifier((1, 3, 6, 1, 3, 126, 0, 0))
smfMIBNotifControl = MibIdentifier((1, 3, 6, 1, 3, 126, 0, 1))
smfNotifAdminStatusChange = NotificationType((1, 3, 6, 1, 3, 126, 0, 0, 1)).setObjects(("SMF-MIB", "smfCfgRouterIDAddrType"), ("SMF-MIB", "smfCfgRouterID"), ("SMF-MIB", "smfCfgAdminStatus"))
if mibBuilder.loadTexts: smfNotifAdminStatusChange.setStatus('current')
if mibBuilder.loadTexts: smfNotifAdminStatusChange.setDescription("smfCfgAdminStatusChange is a notification sent when the 'smfCfgAdminStatus' object changes.")
smfNotifConfiguredOpModeChange = NotificationType((1, 3, 6, 1, 3, 126, 0, 0, 2)).setObjects(("SMF-MIB", "smfCfgRouterIDAddrType"), ("SMF-MIB", "smfCfgRouterID"), ("SMF-MIB", "smfCfgOperationalMode"))
if mibBuilder.loadTexts: smfNotifConfiguredOpModeChange.setStatus('current')
if mibBuilder.loadTexts: smfNotifConfiguredOpModeChange.setDescription("smfNotifConfiguredOpModeChange is a notification sent when the 'smfCfgOperationalMode' object changes.")
smfNotifIfAdminStatusChange = NotificationType((1, 3, 6, 1, 3, 126, 0, 0, 3)).setObjects(("SMF-MIB", "smfCfgRouterIDAddrType"), ("SMF-MIB", "smfCfgRouterID"), ("IF-MIB", "ifName"), ("SMF-MIB", "smfCfgIfAdminStatus"))
if mibBuilder.loadTexts: smfNotifIfAdminStatusChange.setStatus('current')
if mibBuilder.loadTexts: smfNotifIfAdminStatusChange.setDescription("smfCfgIfAdminStatusChange is a notification sent when the 'smfCfgIfAdminStatus' object changes.")
smfNotifDpdMemoryOverflowEvent = NotificationType((1, 3, 6, 1, 3, 126, 0, 0, 4)).setObjects(("SMF-MIB", "smfCfgRouterIDAddrType"), ("SMF-MIB", "smfCfgRouterID"), ("SMF-MIB", "smfStateDpdMemoryOverflow"))
if mibBuilder.loadTexts: smfNotifDpdMemoryOverflowEvent.setStatus('current')
if mibBuilder.loadTexts: smfNotifDpdMemoryOverflowEvent.setDescription("smfNotifDpdMemoryOverflowEvents is sent when the number of memory overflow events exceeds the 'smfNotifDpdMemoryOverflowThreshold' within the previous number of seconds defined by the 'smfNotifDpdMemoryOverflowWindow'.")
smfNotifDpdMemoryOverflowThreshold = MibScalar((1, 3, 6, 1, 3, 126, 0, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(1)).setUnits('Events').setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfNotifDpdMemoryOverflowThreshold.setStatus('current')
if mibBuilder.loadTexts: smfNotifDpdMemoryOverflowThreshold.setDescription("A threshold value for the 'smfNotifDpdmemoryOverflowEvents' object. If the number of occurrences exceeds this threshold within the previous number of seconds 'smfNotifDpdMemoryOverflowWindow', then the 'smfNotifDpdMemoryOverflowEvent' notification is sent. The default value for this object is '1'.")
smfNotifDpdMemoryOverflowWindow = MibScalar((1, 3, 6, 1, 3, 126, 0, 1, 2), TimeTicks().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: smfNotifDpdMemoryOverflowWindow.setStatus('current')
if mibBuilder.loadTexts: smfNotifDpdMemoryOverflowWindow.setDescription("A time window value for the 'smfNotifDpdmemoryOverflowEvents' object. If the number of occurrences exceeds the 'smfNotifDpdMemoryOverflowThreshold' within the previous number of seconds 'smfNotifDpdMemoryOverflowWindow', then the 'smfNotifDpdMemoryOverflowEvent' notification is sent. The default value for this object is '1'.")
smfCompliances = MibIdentifier((1, 3, 6, 1, 3, 126, 2, 1))
smfMIBGroups = MibIdentifier((1, 3, 6, 1, 3, 126, 2, 2))
smfBasicCompliance = ModuleCompliance((1, 3, 6, 1, 3, 126, 2, 1, 1)).setObjects(("SMF-MIB", "smfCapabObjectsGroup"), ("SMF-MIB", "smfConfigObjectsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfBasicCompliance = smfBasicCompliance.setStatus('current')
if mibBuilder.loadTexts: smfBasicCompliance.setDescription('The basic implementation requirements for managed network entities that implement the SMF RSSA process.')
smfFullCompliance = ModuleCompliance((1, 3, 6, 1, 3, 126, 2, 1, 2)).setObjects(("SMF-MIB", "smfCapabObjectsGroup"), ("SMF-MIB", "smfConfigObjectsGroup"), ("SMF-MIB", "smfStateObjectsGroup"), ("SMF-MIB", "smfPerfObjectsGroup"), ("SMF-MIB", "smfNotifObjectsGroup"), ("SMF-MIB", "smfNotificationsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfFullCompliance = smfFullCompliance.setStatus('current')
if mibBuilder.loadTexts: smfFullCompliance.setDescription('The full implementation requirements for managed network entities that implement the SMF RSSA process.')
smfCapabObjectsGroup = ObjectGroup((1, 3, 6, 1, 3, 126, 2, 2, 1)).setObjects(("SMF-MIB", "smfCapabilitiesOpModeID"), ("SMF-MIB", "smfCapabilitiesRssaID"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfCapabObjectsGroup = smfCapabObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: smfCapabObjectsGroup.setDescription('Set of SMF configuration objects implemented in this module.')
smfConfigObjectsGroup = ObjectGroup((1, 3, 6, 1, 3, 126, 2, 2, 2)).setObjects(("SMF-MIB", "smfCfgAdminStatus"), ("SMF-MIB", "smfCfgSmfSysUpTime"), ("SMF-MIB", "smfCfgRouterIDAddrType"), ("SMF-MIB", "smfCfgRouterID"), ("SMF-MIB", "smfCfgOperationalMode"), ("SMF-MIB", "smfCfgRssaMember"), ("SMF-MIB", "smfCfgIpv4Dpd"), ("SMF-MIB", "smfCfgIpv6Dpd"), ("SMF-MIB", "smfCfgMaxPktLifetime"), ("SMF-MIB", "smfCfgDpdEntryMaxLifetime"), ("SMF-MIB", "smfCfgNhdpRssaMesgTLVIncluded"), ("SMF-MIB", "smfCfgNhdpRssaAddrBlockTLVIncluded"), ("SMF-MIB", "smfCfgAddrForwardingGroupName"), ("SMF-MIB", "smfCfgAddrForwardingAddrType"), ("SMF-MIB", "smfCfgAddrForwardingAddress"), ("SMF-MIB", "smfCfgAddrForwardingAddrPrefixLength"), ("SMF-MIB", "smfCfgAddrForwardingStatus"), ("SMF-MIB", "smfCfgIfAdminStatus"), ("SMF-MIB", "smfCfgIfSmfUpTime"), ("SMF-MIB", "smfCfgIfRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfConfigObjectsGroup = smfConfigObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: smfConfigObjectsGroup.setDescription('Set of SMF configuration objects implemented in this module.')
smfStateObjectsGroup = ObjectGroup((1, 3, 6, 1, 3, 126, 2, 2, 3)).setObjects(("SMF-MIB", "smfStateNodeRsStatusIncluded"), ("SMF-MIB", "smfStateDpdMemoryOverflow"), ("SMF-MIB", "smfStateNeighborRSSA"), ("SMF-MIB", "smfStateNeighborNextHopInterface"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfStateObjectsGroup = smfStateObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: smfStateObjectsGroup.setDescription('Set of SMF state objects implemented in this module.')
smfPerfObjectsGroup = ObjectGroup((1, 3, 6, 1, 3, 126, 2, 2, 4)).setObjects(("SMF-MIB", "smfPerfIpv4MultiPktsRecvTotal"), ("SMF-MIB", "smfPerfIpv4MultiPktsForwardedTotal"), ("SMF-MIB", "smfPerfIpv4DuplMultiPktsDetectedTotal"), ("SMF-MIB", "smfPerfIpv4DroppedMultiPktsTTLExceededTotal"), ("SMF-MIB", "smfPerfIpv4TTLLargerThanPreviousTotal"), ("SMF-MIB", "smfPerfIpv6MultiPktsRecvTotal"), ("SMF-MIB", "smfPerfIpv6MultiPktsForwardedTotal"), ("SMF-MIB", "smfPerfIpv6DuplMultiPktsDetectedTotal"), ("SMF-MIB", "smfPerfIpv6DroppedMultiPktsTTLExceededTotal"), ("SMF-MIB", "smfPerfIpv6TTLLargerThanPreviousTotal"), ("SMF-MIB", "smfPerfIpv6HAVAssistsReqdTotal"), ("SMF-MIB", "smfPerfIpv6DpdHeaderInsertionsTotal"), ("SMF-MIB", "smfPerfIpv4MultiPktsRecvPerIf"), ("SMF-MIB", "smfPerfIpv4MultiPktsForwardedPerIf"), ("SMF-MIB", "smfPerfIpv4DuplMultiPktsDetectedPerIf"), ("SMF-MIB", "smfPerfIpv4DroppedMultiPktsTTLExceededPerIf"), ("SMF-MIB", "smfPerfIpv4TTLLargerThanPreviousPerIf"), ("SMF-MIB", "smfPerfIpv6MultiPktsRecvPerIf"), ("SMF-MIB", "smfPerfIpv6MultiPktsForwardedPerIf"), ("SMF-MIB", "smfPerfIpv6DuplMultiPktsDetectedPerIf"), ("SMF-MIB", "smfPerfIpv6DroppedMultiPktsTTLExceededPerIf"), ("SMF-MIB", "smfPerfIpv6TTLLargerThanPreviousPerIf"), ("SMF-MIB", "smfPerfIpv6HAVAssistsReqdPerIf"), ("SMF-MIB", "smfPerfIpv6DpdHeaderInsertionsPerIf"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfPerfObjectsGroup = smfPerfObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: smfPerfObjectsGroup.setDescription('Set of SMF performance objects implemented in this module by total and per interface.')
smfNotifObjectsGroup = ObjectGroup((1, 3, 6, 1, 3, 126, 2, 2, 5)).setObjects(("SMF-MIB", "smfNotifDpdMemoryOverflowThreshold"), ("SMF-MIB", "smfNotifDpdMemoryOverflowWindow"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfNotifObjectsGroup = smfNotifObjectsGroup.setStatus('current')
if mibBuilder.loadTexts: smfNotifObjectsGroup.setDescription('Set of SMF notification control objects implemented in this module.')
smfNotificationsGroup = NotificationGroup((1, 3, 6, 1, 3, 126, 2, 2, 6)).setObjects(("SMF-MIB", "smfNotifAdminStatusChange"), ("SMF-MIB", "smfNotifConfiguredOpModeChange"), ("SMF-MIB", "smfNotifIfAdminStatusChange"), ("SMF-MIB", "smfNotifDpdMemoryOverflowEvent"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    smfNotificationsGroup = smfNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: smfNotificationsGroup.setDescription('Set of SMF notifications implemented in this module.')
mibBuilder.exportSymbols("SMF-MIB", smfCompliances=smfCompliances, smfCfgAddrForwardingGroupName=smfCfgAddrForwardingGroupName, smfCfgAddrForwardingIndex=smfCfgAddrForwardingIndex, smfPerfIpv6DroppedMultiPktsTTLExceededTotal=smfPerfIpv6DroppedMultiPktsTTLExceededTotal, smfMIB=smfMIB, smfPerformanceGroup=smfPerformanceGroup, smfCapabilitiesEntry=smfCapabilitiesEntry, smfNotifDpdMemoryOverflowWindow=smfNotifDpdMemoryOverflowWindow, smfCfgMaxPktLifetime=smfCfgMaxPktLifetime, smfMIBNotifControl=smfMIBNotifControl, smfCfgIfRowStatus=smfCfgIfRowStatus, smfPerfIpv6MultiPktsForwardedTotal=smfPerfIpv6MultiPktsForwardedTotal, smfCapabilitiesGroup=smfCapabilitiesGroup, smfPerfIpv4InterfacePerfTable=smfPerfIpv4InterfacePerfTable, smfPerfIpv4MultiPktsRecvPerIf=smfPerfIpv4MultiPktsRecvPerIf, smfPerfIpv4TTLLargerThanPreviousPerIf=smfPerfIpv4TTLLargerThanPreviousPerIf, smfCapabilitiesOpModeID=smfCapabilitiesOpModeID, smfPerfObjectsGroup=smfPerfObjectsGroup, smfCfgInterfaceEntry=smfCfgInterfaceEntry, smfStateNeighborIpAddrType=smfStateNeighborIpAddrType, smfPerfIpv4DuplMultiPktsDetectedTotal=smfPerfIpv4DuplMultiPktsDetectedTotal, smfPerfIpv4TTLLargerThanPreviousTotal=smfPerfIpv4TTLLargerThanPreviousTotal, smfCfgIfIndex=smfCfgIfIndex, smfCfgAddrForwardingStatus=smfCfgAddrForwardingStatus, smfConfigurationGroup=smfConfigurationGroup, smfCfgAddrForwardingAddrPrefixLength=smfCfgAddrForwardingAddrPrefixLength, smfPerfIpv6DuplMultiPktsDetectedTotal=smfPerfIpv6DuplMultiPktsDetectedTotal, smfPerfGobalGroup=smfPerfGobalGroup, smfCfgAddrForwardingTable=smfCfgAddrForwardingTable, smfPerfIpv6MultiPktsForwardedPerIf=smfPerfIpv6MultiPktsForwardedPerIf, smfNotifIfAdminStatusChange=smfNotifIfAdminStatusChange, smfNotifDpdMemoryOverflowEvent=smfNotifDpdMemoryOverflowEvent, smfPerfIpv4DuplMultiPktsDetectedPerIf=smfPerfIpv4DuplMultiPktsDetectedPerIf, smfPerfIpv6HAVAssistsReqdPerIf=smfPerfIpv6HAVAssistsReqdPerIf, smfNotifConfiguredOpModeChange=smfNotifConfiguredOpModeChange, smfCfgIpv4Dpd=smfCfgIpv4Dpd, smfCfgNhdpRssaMesgTLVIncluded=smfCfgNhdpRssaMesgTLVIncluded, smfPerfIpv4MultiPktsForwardedPerIf=smfPerfIpv4MultiPktsForwardedPerIf, smfCfgNhdpRssaAddrBlockTLVIncluded=smfCfgNhdpRssaAddrBlockTLVIncluded, smfCfgAdminStatus=smfCfgAdminStatus, smfPerfIpv6DpdHeaderInsertionsTotal=smfPerfIpv6DpdHeaderInsertionsTotal, smfCfgRssaMember=smfCfgRssaMember, smfStateNeighborTable=smfStateNeighborTable, smfPerfIpv6InterfacePerfEntry=smfPerfIpv6InterfacePerfEntry, smfPerfIpv6DpdHeaderInsertionsPerIf=smfPerfIpv6DpdHeaderInsertionsPerIf, smfFullCompliance=smfFullCompliance, smfMIBNotifObjects=smfMIBNotifObjects, smfCfgRouterIDAddrType=smfCfgRouterIDAddrType, smfStateNeighborNextHopInterface=smfStateNeighborNextHopInterface, SmfStatus=SmfStatus, smfPerfIpv6TTLLargerThanPreviousPerIf=smfPerfIpv6TTLLargerThanPreviousPerIf, smfPerfIpv4MultiPktsForwardedTotal=smfPerfIpv4MultiPktsForwardedTotal, smfCfgInterfaceTable=smfCfgInterfaceTable, smfMIBNotifications=smfMIBNotifications, smfPerfIpv6DroppedMultiPktsTTLExceededPerIf=smfPerfIpv6DroppedMultiPktsTTLExceededPerIf, smfCapabilitiesIndex=smfCapabilitiesIndex, smfPerfIpv6MultiPktsRecvPerIf=smfPerfIpv6MultiPktsRecvPerIf, smfPerfIpv4DroppedMultiPktsTTLExceededTotal=smfPerfIpv4DroppedMultiPktsTTLExceededTotal, smfPerfIpv4DroppedMultiPktsTTLExceededPerIf=smfPerfIpv4DroppedMultiPktsTTLExceededPerIf, smfStateNeighborEntry=smfStateNeighborEntry, smfMIBGroups=smfMIBGroups, smfCfgSmfSysUpTime=smfCfgSmfSysUpTime, smfConfigObjectsGroup=smfConfigObjectsGroup, smfCfgRouterID=smfCfgRouterID, PYSNMP_MODULE_ID=smfMIB, smfBasicCompliance=smfBasicCompliance, smfPerfIpv4MultiPktsRecvTotal=smfPerfIpv4MultiPktsRecvTotal, smfPerfIpv4InterfacePerfEntry=smfPerfIpv4InterfacePerfEntry, smfNotifDpdMemoryOverflowThreshold=smfNotifDpdMemoryOverflowThreshold, smfPerfIpv6MultiPktsRecvTotal=smfPerfIpv6MultiPktsRecvTotal, smfPerfIpv6DuplMultiPktsDetectedPerIf=smfPerfIpv6DuplMultiPktsDetectedPerIf, smfMIBConformance=smfMIBConformance, smfStateNeighborPrefixLen=smfStateNeighborPrefixLen, smfStateObjectsGroup=smfStateObjectsGroup, smfCapabilitiesRssaID=smfCapabilitiesRssaID, smfCfgIpv6Dpd=smfCfgIpv6Dpd, smfStateNodeRsStatusIncluded=smfStateNodeRsStatusIncluded, smfCfgOperationalMode=smfCfgOperationalMode, smfCfgDpdEntryMaxLifetime=smfCfgDpdEntryMaxLifetime, smfCapabObjectsGroup=smfCapabObjectsGroup, smfStateDpdMemoryOverflow=smfStateDpdMemoryOverflow, smfCfgIfSmfUpTime=smfCfgIfSmfUpTime, smfPerfIpv6TTLLargerThanPreviousTotal=smfPerfIpv6TTLLargerThanPreviousTotal, smfNotifObjectsGroup=smfNotifObjectsGroup, smfCfgAddrForwardingAddress=smfCfgAddrForwardingAddress, smfNotificationsGroup=smfNotificationsGroup, smfStateGroup=smfStateGroup, smfCfgIfAdminStatus=smfCfgIfAdminStatus, smfStateNeighborRSSA=smfStateNeighborRSSA, smfPerfIpv6HAVAssistsReqdTotal=smfPerfIpv6HAVAssistsReqdTotal, smfNotifAdminStatusChange=smfNotifAdminStatusChange, smfCfgAddrForwardingEntry=smfCfgAddrForwardingEntry, smfCapabilitiesTable=smfCapabilitiesTable, smfPerfInterfaceGroup=smfPerfInterfaceGroup, smfCfgAddrForwardingAddrType=smfCfgAddrForwardingAddrType, smfPerfIpv6InterfacePerfTable=smfPerfIpv6InterfacePerfTable, smfStateNeighborIpAddr=smfStateNeighborIpAddr, smfMIBObjects=smfMIBObjects)

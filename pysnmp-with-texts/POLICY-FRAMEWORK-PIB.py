#
# PySNMP MIB module POLICY-FRAMEWORK-PIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/POLICY-FRAMEWORK-PIB
# Produced by pysmi-0.3.4 at Wed May  1 14:25:18 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
TimeTicks, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, IpAddress, Gauge32, iso, NotificationType, MibIdentifier, Bits, ModuleIdentity, Counter64, ObjectIdentity, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "IpAddress", "Gauge32", "iso", "NotificationType", "MibIdentifier", "Bits", "ModuleIdentity", "Counter64", "ObjectIdentity", "Integer32")
TextualConvention, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "DisplayString")
policy, = mibBuilder.importSymbols("SYNOPTICS-ROOT-MIB", "policy")
policyFrameworkPib = ModuleIdentity((1, 3, 6, 1, 4, 1, 45, 4, 1))
policyFrameworkPib.setRevisions(('2004-07-20 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: policyFrameworkPib.setRevisionsDescriptions(('Version 3: Added version info',))
if mibBuilder.loadTexts: policyFrameworkPib.setLastUpdated('200407200000Z')
if mibBuilder.loadTexts: policyFrameworkPib.setOrganization('IETF RAP WG')
if mibBuilder.loadTexts: policyFrameworkPib.setContactInfo(' Michael Fine Cisco Systems, Inc. 170 West Tasman Drive San Jose, CA 95134-1706 USA Phone: +1 408 527 8218 Email: mfine@cisco.com Keith McCloghrie Cisco Systems, Inc. 170 West Tasman Drive, San Jose, CA 95134-1706 USA Phone: +1 408 526 5260 Email: kzm@cisco.com John Seligson Nortel Networks, Inc. 4401 Great America Parkway Santa Clara, CA 95054 USA Phone: +1 408 495 2992 Email: jseligso@nortelnetworks.com')
if mibBuilder.loadTexts: policyFrameworkPib.setDescription('A PIB module containing the base set of policy rule classes that are required for support of all policies.')
policyBasePibClass = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 1, 1))
class Role(TextualConvention, OctetString):
    description = 'A role represents a functionality characteristic or capability of a resource to which policies are applied. The only valid character set is US-ASCII. Valid characters are a-z, A-Z, 0-9, period, hyphen and underscore. A role must always start with a letter (a-z or A-Z).'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 32)

class RoleCombination(TextualConvention, OctetString):
    description = "An octet string containing concatenated Roles. For the format specification of roles, refer to the 'Role' TEXTUAL- CONVENTION. A valid Role Combination must be formed by a set of valid Roles, concatenated by the US-ASCII character '+', where the roles are in lexicographic order from minimum to maximum. For example, 'a+b' and 'b+a' are NOT different role-combinations; rather, they are different formatting of the same (one) role-combination. Notice the roles within a role-combination are in Lexicographic order from minimum to maximum, hence, we declare: 'a+b' is the valid formatting of the role-combination, 'b+a' is an invalid formatting of the role-combination. Notice the need of zero-length role-combination as the role- combination of interfaces to which no roles have been assigned. This role-combination is also known as the 'null' role-combination. (Note the deliberate use of lower case letters to avoid confusion with the US-ASCII NULL character which has a value of zero but length of one)."
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(0, 255)

class PolicyInstanceId(TextualConvention, Unsigned32):
    description = 'The textual convention for use by an attribute which is used as the instance-identifying index of a PRC, i.e., an attribute named in an INDEX clause. The value of an attribute with this syntax is always greater than zero. PRIs of the same PRC need not have contiguous values for their instance-identifying attribute.'
    status = 'current'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 4294967295)

policyPrcSupportTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 1), )
if mibBuilder.loadTexts: policyPrcSupportTable.setStatus('current')
if mibBuilder.loadTexts: policyPrcSupportTable.setDescription('Each instance of this class specifies a PRC that the device supports and a bit string to indicate the attributes of the class that are supported. These PRIs are sent to the PDP to indicate to the PDP which PRCs, and which attributes of these PRCs, the device supports. This table can also be downloaded by a network manager when static configuration is used. All install and install-notify PRCs supported by the device must be represented in this table.')
policyPrcSupportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 1, 1), ).setIndexNames((0, "POLICY-FRAMEWORK-PIB", "policyPrcSupportPrid"))
if mibBuilder.loadTexts: policyPrcSupportEntry.setStatus('current')
if mibBuilder.loadTexts: policyPrcSupportEntry.setDescription('An instance of the policyPrcSupport class that identifies a specific policy class and associated attributes as supported by the device.')
policyPrcSupportPrid = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 1, 1, 1), PolicyInstanceId())
if mibBuilder.loadTexts: policyPrcSupportPrid.setStatus('current')
if mibBuilder.loadTexts: policyPrcSupportPrid.setDescription('An arbitrary integer index that uniquely identifies an instance of the policyPrcSupport class.')
policyPrcSupportSupportedPrc = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 1, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyPrcSupportSupportedPrc.setStatus('current')
if mibBuilder.loadTexts: policyPrcSupportSupportedPrc.setDescription('The object identifier of a supported PRC. There may not be more than one instance of the policyPrcSupport class with the same value of policyPrcSupportSupportedPrc.')
policyPrcSupportSupportedAttrs = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 1, 1, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyPrcSupportSupportedAttrs.setStatus('current')
if mibBuilder.loadTexts: policyPrcSupportSupportedAttrs.setDescription("A bit string representing the supported attributes of the class that is identified by the policyPrcSupportSupportedPrc object. Each bit of this bit mask corresponds to a class attribute, with the most significant bit of the i-th octet of this octet string corresponding to the (8*i - 7)-th attribute, and the least significant bit of the i-th octet corresponding to the (8*i)-th class attribute. Each bit of this bit mask specifies whether or not the corresponding class attribute is currently supported, with a '1' indicating support and a '0' indicating no support. If the value of this bit mask is N bits long and there are more than N class attributes then the bit mask is logically extended with 0's to the required length.")
policyPrcSupportMaxPris = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 1, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyPrcSupportMaxPris.setStatus('current')
if mibBuilder.loadTexts: policyPrcSupportMaxPris.setDescription('A non-negative value indicating the maximum numbers of policy rule instances that can be installed in the identified policy rule class. Note that actual number of PRIs that can be installed in a PRC at any given time may be less than this value based on the current operational state (e.g., resources currently consumed) of the device.')
policyPibIncarnationTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2), )
if mibBuilder.loadTexts: policyPibIncarnationTable.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationTable.setDescription('This class contains a single policy rule instance that identifies the current incarnation of the PIB and the PDP or network manager that installed this incarnation. The instance of this class is reported to the PDP at client connect time so that the PDP can (attempt to) ascertain the current state of the PIB. A network manager may use the instance to determine the state of the device with regard to existing NMS interactions.')
policyPibIncarnationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2, 1), ).setIndexNames((0, "POLICY-FRAMEWORK-PIB", "policyPibIncarnationPrid"))
if mibBuilder.loadTexts: policyPibIncarnationEntry.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationEntry.setDescription('An instance of the policyPibIncarnation class. Only one instance of this policy class is ever instantiated.')
policyPibIncarnationPrid = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2, 1, 1), PolicyInstanceId())
if mibBuilder.loadTexts: policyPibIncarnationPrid.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationPrid.setDescription('An index to uniquely identify an instance of this policy class.')
policyPibIncarnationName = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2, 1, 2), SnmpAdminString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPibIncarnationName.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationName.setDescription('The name of the entity that installed the current incarnation of the PIB into the device. The name may reference a PDP when dynamic configuration is being used or a network manager when static configuration is being used. By default, it is the zero length string.')
policyPibIncarnationId = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPibIncarnationId.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationId.setDescription('An ID to identify the current incarnation. It has meaning to the PDP/manager that installed the PIB and perhaps its standby PDPs/managers. By default, it is the zero-length string.')
policyPibIncarnationLongevity = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("expireNever", 1), ("expireImmediate", 2), ("expireOnTimeout", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPibIncarnationLongevity.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationLongevity.setDescription('This attribute controls what the PEP does with the downloaded policy on receipt of a Client Close message or a loss of connection to the PDP. If set to expireNever, the PEP continues to operate with the installed policy indefinitely. If set to expireImmediate, the PEP immediately expires the policy obtained from the PDP and installs policy from local configuration. If set to expireOnTimeout, the PEP continues to operate with the policy installed by the PDP for a period of time specified by policyPibIncarnationTtl. After this time (and it has not reconnected to the original or new PDP) the PEP expires this policy and reverts to local configuration. For all cases, it is the responsibility of the PDP to check the incarnation and download new policy, if necessary, on a reconnect. Policy enforcement timing only applies to policies that have been installed dynamically (e.g., by a PDP via COPS).')
policyPibIncarnationTtl = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2, 1, 5), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPibIncarnationTtl.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationTtl.setDescription('The number of seconds after a Client Close or TCP timeout for which the PEP continues to enforce the policy in the PIB. After this interval, the PIB is considered expired and the device no longer enforces the policy installed in the PIB. This attribute is only meaningful if policyPibIncarnationLongevity is set to expireOnTimeout.')
policyPibIncarnationActive = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 2, 1, 6), TruthValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: policyPibIncarnationActive.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationActive.setDescription('If this attribute is set to TRUE, then the PIB instance to which this PRI belongs becomes the active PIB instance. The previous active instance becomes inactive and the policyPibIncarnationActive attribute in that PIB instance is automatically set to false.')
policyDeviceIdentificationTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 3), )
if mibBuilder.loadTexts: policyDeviceIdentificationTable.setStatus('current')
if mibBuilder.loadTexts: policyDeviceIdentificationTable.setDescription('This class contains a single policy rule instance that contains device-specific information that is used to facilitate efficient policy installation by a PDP. The instance of this class is reported to the PDP at client connect time so that the PDP can take into account certain device characteristics during policy installation.')
policyDeviceIdentificationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 3, 1), ).setIndexNames((0, "POLICY-FRAMEWORK-PIB", "policyDeviceIdentificationPrid"))
if mibBuilder.loadTexts: policyDeviceIdentificationEntry.setStatus('current')
if mibBuilder.loadTexts: policyDeviceIdentificationEntry.setDescription('An instance of the policyDeviceIdentification class. Only one instance of this policy class is ever instantiated.')
policyDeviceIdentificationPrid = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 3, 1, 1), PolicyInstanceId())
if mibBuilder.loadTexts: policyDeviceIdentificationPrid.setStatus('current')
if mibBuilder.loadTexts: policyDeviceIdentificationPrid.setDescription('An index to uniquely identify an instance of this policy class.')
policyDeviceIdentificationDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 3, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyDeviceIdentificationDescr.setStatus('current')
if mibBuilder.loadTexts: policyDeviceIdentificationDescr.setDescription("A textual description of the PEP. This value should include the name and version identification of the PEP's hardware and software.")
policyDeviceIdentificationMaxMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 3, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyDeviceIdentificationMaxMsg.setStatus('current')
if mibBuilder.loadTexts: policyDeviceIdentificationMaxMsg.setDescription("The maximum message size, in octets, that the device is capable of processing. Received messages with a size in excess of this value must cause the PEP to return an error to the PDP containing the global error code 'maxMsgSizeExceeded'.")
policyCompLimitsTable = MibTable((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 4), )
if mibBuilder.loadTexts: policyCompLimitsTable.setStatus('current')
if mibBuilder.loadTexts: policyCompLimitsTable.setDescription('Each instance of this class identifies a policy class or attribute and a limitation related to the implementaion of the class/attribute in the device. Additional information providing guidance related to the limitation may also be present. These PRIs are sent to the PDP to indicate which PRCs or PRC attributes the device supports in a restricted manner.')
policyCompLimitsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 4, 1), ).setIndexNames((0, "POLICY-FRAMEWORK-PIB", "policyCompLimitsPrid"))
if mibBuilder.loadTexts: policyCompLimitsEntry.setStatus('current')
if mibBuilder.loadTexts: policyCompLimitsEntry.setDescription("An instance of the policyCompLimits class that identifies a PRC or PRC attribute and a limitation related to the PRC or PRC attribute implementation supported by the device. All PRIs of this class represent errors that would be returned in relation to the identified component for policy installation requests that don't abide by the restrictions indicated by the error code and, possibly, a provided guidance value.")
policyCompLimitsPrid = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 4, 1, 1), PolicyInstanceId())
if mibBuilder.loadTexts: policyCompLimitsPrid.setStatus('current')
if mibBuilder.loadTexts: policyCompLimitsPrid.setDescription('An arbitrary integer index that uniquely identifies an instance of the policyCompLimits class.')
policyCompLimitsComponent = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 4, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyCompLimitsComponent.setStatus('current')
if mibBuilder.loadTexts: policyCompLimitsComponent.setDescription("The object identifier of a PRC or PRC attribute that is supported in some limited fashion with regard to it's definition in the associated PIB module. The same PRC or PRC attribute identifier may appear in the table several times, once for each implementation limitation acknowledged by the device.")
policyCompLimitsType = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyCompLimitsType.setStatus('current')
if mibBuilder.loadTexts: policyCompLimitsType.setDescription("A value describing an implementation limitation for the device related to the PRC or PRC attribute identified by the policyCompLimitsComponent data in this class instance. Values for this object are derived from the defined error values associated with the PRC of the identified attribute or the PRC itself. All genericPrc and specificPrc (defined in a PRC INSTALL-ERRORS clause) error codes represent valid limitation type values. For example, an implementation of the qosIpAce class may be limited in several ways, such as address mask, protocol and Layer 4 port options. These limitations could be exported using this table with the following instances: Prid Component Type Guidance 1 'qosIpAceDstAddrMask' 'valueSupLimited' 0xFFFFFFFF 2 'qosIpAceSrcAddrMask' 'valueSupLimited' 0xFFFFFFFF 3 'qosIpAceProtocol' 'valueSupLimited' 0x06 -- TCP 4 'qosIpAceProtocol' 'valueSupLimited' 0x17 -- UDP 5 'qosIpAceDstL4PortMin' 'invalidDstL4PortData' 6 'qosIpAceDstL4PortMax' 'invalidDstL4PortData' 7 'qosIpAcePermit' 'enumSupLimited' 'true' The above entries describe a number of limitations that may be in effect for the qosIpAce class on a given device. The limitations include restrictions on acceptable values for certain attributes and indications of the relationship between related attributes.")
policyCompLimitsGuidance = MibTableColumn((1, 3, 6, 1, 4, 1, 45, 4, 1, 1, 4, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: policyCompLimitsGuidance.setStatus('current')
if mibBuilder.loadTexts: policyCompLimitsGuidance.setDescription("A value used to convey additional information related to the implementation limitation noted by the policyCompLimitsType attribute. The value of this attribute must interpreted in the context of the policyCompLimitsType value. Note that a guidance value will not necessarily be provided for all exported limitations. Well-known genericPrc error codes that are applicable to all PRCs, such as 'attrValueSupLimited' and 'attrEnumSupLimited', have guidance value semantics as follows: genericPrc Guidance Semantics attrValueSupLimited Integer32 (4 octets) with supported value attrEnumSupLimited Integer32 (4 octets) with supported enumeration attrMaxLengthExceeded Integer32 (4 octets) with maximum supported length for attribute The specificPrc error codes have the semantics of the associated guidance value specified where the installation error is defined if appropriate. Errors for which the semantics of the guidance value are not specified require this value to be treated in an implementation dependent manner.")
policyBasePibConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 1, 2))
policyBasePibCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 1, 2, 1))
policyBasePibGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 45, 4, 1, 2, 2))
policyBasePibCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 45, 4, 1, 2, 1, 1)).setObjects(("POLICY-FRAMEWORK-PIB", "policyPrcSupportGroup"), ("POLICY-FRAMEWORK-PIB", "policyPibIncarnationGroup"), ("POLICY-FRAMEWORK-PIB", "policyDeviceIdentificationGroup"), ("POLICY-FRAMEWORK-PIB", "policyCompLimitsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyBasePibCompliance = policyBasePibCompliance.setStatus('current')
if mibBuilder.loadTexts: policyBasePibCompliance.setDescription('Describes the requirements for conformance to the Policy Framework PIB.')
policyPrcSupportGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 1, 2, 2, 1)).setObjects(("POLICY-FRAMEWORK-PIB", "policyPrcSupportSupportedPrc"), ("POLICY-FRAMEWORK-PIB", "policyPrcSupportSupportedAttrs"), ("POLICY-FRAMEWORK-PIB", "policyPrcSupportMaxPris"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyPrcSupportGroup = policyPrcSupportGroup.setStatus('current')
if mibBuilder.loadTexts: policyPrcSupportGroup.setDescription('Objects from the policyPrcSupportTable.')
policyPibIncarnationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 1, 2, 2, 2)).setObjects(("POLICY-FRAMEWORK-PIB", "policyPibIncarnationName"), ("POLICY-FRAMEWORK-PIB", "policyPibIncarnationId"), ("POLICY-FRAMEWORK-PIB", "policyPibIncarnationLongevity"), ("POLICY-FRAMEWORK-PIB", "policyPibIncarnationTtl"), ("POLICY-FRAMEWORK-PIB", "policyPibIncarnationActive"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyPibIncarnationGroup = policyPibIncarnationGroup.setStatus('current')
if mibBuilder.loadTexts: policyPibIncarnationGroup.setDescription('Objects from the policyPibIncarnationTable.')
policyDeviceIdentificationGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 1, 2, 2, 3)).setObjects(("POLICY-FRAMEWORK-PIB", "policyDeviceIdentificationDescr"), ("POLICY-FRAMEWORK-PIB", "policyDeviceIdentificationMaxMsg"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyDeviceIdentificationGroup = policyDeviceIdentificationGroup.setStatus('current')
if mibBuilder.loadTexts: policyDeviceIdentificationGroup.setDescription('Objects from the policyDeviceIdentificationTable.')
policyCompLimitsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 45, 4, 1, 2, 2, 4)).setObjects(("POLICY-FRAMEWORK-PIB", "policyCompLimitsComponent"), ("POLICY-FRAMEWORK-PIB", "policyCompLimitsType"), ("POLICY-FRAMEWORK-PIB", "policyCompLimitsGuidance"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    policyCompLimitsGroup = policyCompLimitsGroup.setStatus('current')
if mibBuilder.loadTexts: policyCompLimitsGroup.setDescription('Objects from the policyCompLimitsTable.')
mibBuilder.exportSymbols("POLICY-FRAMEWORK-PIB", policyPrcSupportSupportedPrc=policyPrcSupportSupportedPrc, policyCompLimitsEntry=policyCompLimitsEntry, PYSNMP_MODULE_ID=policyFrameworkPib, policyPrcSupportMaxPris=policyPrcSupportMaxPris, policyPibIncarnationActive=policyPibIncarnationActive, policyFrameworkPib=policyFrameworkPib, policyDeviceIdentificationPrid=policyDeviceIdentificationPrid, policyPibIncarnationTable=policyPibIncarnationTable, policyPrcSupportSupportedAttrs=policyPrcSupportSupportedAttrs, RoleCombination=RoleCombination, policyPibIncarnationPrid=policyPibIncarnationPrid, policyCompLimitsPrid=policyCompLimitsPrid, policyCompLimitsGroup=policyCompLimitsGroup, policyDeviceIdentificationDescr=policyDeviceIdentificationDescr, policyPibIncarnationId=policyPibIncarnationId, policyBasePibConformance=policyBasePibConformance, policyPibIncarnationEntry=policyPibIncarnationEntry, policyPrcSupportPrid=policyPrcSupportPrid, policyBasePibCompliances=policyBasePibCompliances, policyDeviceIdentificationMaxMsg=policyDeviceIdentificationMaxMsg, policyCompLimitsTable=policyCompLimitsTable, policyPrcSupportEntry=policyPrcSupportEntry, Role=Role, policyDeviceIdentificationEntry=policyDeviceIdentificationEntry, policyCompLimitsComponent=policyCompLimitsComponent, policyPibIncarnationLongevity=policyPibIncarnationLongevity, policyBasePibClass=policyBasePibClass, policyBasePibGroups=policyBasePibGroups, policyPrcSupportTable=policyPrcSupportTable, PolicyInstanceId=PolicyInstanceId, policyPibIncarnationTtl=policyPibIncarnationTtl, policyCompLimitsType=policyCompLimitsType, policyPibIncarnationGroup=policyPibIncarnationGroup, policyDeviceIdentificationGroup=policyDeviceIdentificationGroup, policyDeviceIdentificationTable=policyDeviceIdentificationTable, policyBasePibCompliance=policyBasePibCompliance, policyPrcSupportGroup=policyPrcSupportGroup, policyCompLimitsGuidance=policyCompLimitsGuidance, policyPibIncarnationName=policyPibIncarnationName)

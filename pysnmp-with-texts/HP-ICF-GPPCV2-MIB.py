#
# PySNMP MIB module HP-ICF-GPPCV2-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HP-ICF-GPPCV2-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:34:11 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueRangeConstraint")
hpSwitch, = mibBuilder.importSymbols("HP-ICF-OID", "hpSwitch")
PortList, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "PortList")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, ObjectIdentity, IpAddress, Bits, Gauge32, Counter64, Unsigned32, NotificationType, ModuleIdentity, MibIdentifier, iso, TimeTicks, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "ObjectIdentity", "IpAddress", "Bits", "Gauge32", "Counter64", "Unsigned32", "NotificationType", "ModuleIdentity", "MibIdentifier", "iso", "TimeTicks", "Integer32")
DisplayString, TextualConvention, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "TruthValue", "RowStatus")
hpicfGppcv2MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61))
hpicfGppcv2MIB.setRevisions(('2016-01-15 00:00', '2015-06-23 00:00', '2015-01-21 00:00', '2014-09-09 00:00', '2014-04-24 00:00', '2010-11-12 00:00', '2010-09-28 00:00', '2010-03-01 22:01',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hpicfGppcv2MIB.setRevisionsDescriptions(('Added policyUser to hpicfGppcv2NpSubType', 'Added hpicfGppcv2AcSharedFlag to HpicfGppcv2AppControlEntry and hpicfGppcv2MIBCompliance/hpicfGppcv2Group', 'Added hpicfGppcv2AcVACLEgressVIDList to HpicfGppcv2AppControlEntry and hpicfGppcv2MIBCompliance/hpicfGppcv2Group', 'Added gppcv2InvalidEtherTypeError to HpicfGppcv2LastErrorCode', 'Added aclMac and classifierClassMac to HpicfGppcv2PolicyType gppcv2ClassNoMixMacAndIPError to HpicfGppcv2LastErrorCode aclMacStandard and aclMacExtended to hpicfGppcv2NpSubType', 'Added hpicfGppcv2AcIngressTunnelList and hpicfGppcv2AcEgressTunnelList to HpicfGppcv2AppControlEntry and hpicfGppcv2MIBCompliance/hpicfGppcv2Group', 'Added policyIpsec in hpicfGppcv2NpSubType.', 'Initial revision.',))
if mibBuilder.loadTexts: hpicfGppcv2MIB.setLastUpdated('201601150000Z')
if mibBuilder.loadTexts: hpicfGppcv2MIB.setOrganization('HP Networking')
if mibBuilder.loadTexts: hpicfGppcv2MIB.setContactInfo('Hewlett Packard Company 8000 Foothills Blvd. Roseville, CA 95747')
if mibBuilder.loadTexts: hpicfGppcv2MIB.setDescription('This MIB module is for HP proprietary General Purpose Packet Control Version 2 (Gppcv2)')
class HpicfGppcv2PolicyName(TextualConvention, OctetString):
    description = 'Type definition for the name of a policy. A policy name is a printable string consisting of up to 64 characters from the ASCII character set. The policy name is case sensitive'
    status = 'current'
    displayHint = '70a'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 70)

class HpicfGppcv2PolicyType(TextualConvention, Integer32):
    description = "Type of the policy. A policy of type 'aclIpv4' indicates that the policy is an IPv4 Access Control List, an ACL that filters packets based on source IPv4 address and subnet, destination IPv4 address and subnet, and protocol amongst other packet information. A policy of type 'aclIpv6' indicates that the policy is an IPv6 Access Control List, an ACL that filters packets based on source IPv6 address and subnet, destination IPv6 address and subnet, and protocol amongst other packet information. A policy of type 'classifierClassIpv4' indicates that the policy is an IPv4 Classifier class which specifies packets to be compared against the specified source IPv4 address and subnet, destination and subnet, protocol, etc. A policy of type 'classifierClassIpv6' indicates that the policy is an IPv6 Classifier class which specifies packets to be compared against the specified source IPv6 address and subnet, destination and subnet, protocol, etc. A policy type of 'classifierPolicy' indicates that the policy will perform Quality of Service/mirror actions on packets that match statements in the policy's classes. A policy type of 'connectionRateFilterIpv4' indicates that the policy is an IPv4 Connection Rate Filter, a list that specifies packets to be filtered or ignored based on source IPv4 address and subnet and protocol. A policy type of 'aclMac' indicates that the policy is a MAC Access Control List. This ACL filters the packets based on source MAC address, destination MAC address, CoS, ethertype and VLAN. A policy type of 'classifierClassMac' indicates that the policy is an MAC Classifer class which specifies packets to be compared against the specified source MAC address, destination MAC address, Ethernet type, etc."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("aclIpv4", 1), ("aclIpv6", 2), ("classifierClassIpv4", 3), ("classifierClassIpv6", 4), ("classifierPolicy", 5), ("connectionRateFilterIpv4", 6), ("aclMac", 7), ("classifierClassMac", 8))

class HpicfGppcv2LastErrorCode(TextualConvention, Integer32):
    description = 'Error code of the last error that occurred. A non-zero value indicates that the last operation performed by this instance of the application or on the named policy did not succeed.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 50, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111))
    namedValues = NamedValues(("noError", 0), ("gppcv2GenericError", 1), ("gppcv2LengthError", 2), ("gppcv2NameError", 3), ("gppcv2ParameterError", 4), ("gppcv2NotImplemented", 5), ("gppcv2MallocError", 6), ("gppcv2TooManyApps", 7), ("gppcv2TooManyPolicies", 8), ("gppcv2AlreadyReserved", 9), ("gppcv2EntryExists", 10), ("gppcv2PlatformError", 11), ("gppcv2AppUsingPolicy", 12), ("gppcv2InvalidPolicyType", 13), ("gppcv2NotReserved", 14), ("gppcv2NoPolicy", 15), ("gppcv2PolicyNotActive", 16), ("gppcv2PolicyHasRules", 17), ("gppcv2RuleExists", 18), ("gppcv2ReleaseRules", 19), ("gppcv2ReleaseAppCtrlEntry", 20), ("gppcv2CfgError", 50), ("gppcv2AceCreateError", 70), ("gppcv2AceConflictingRuleError", 71), ("gppcv2AceDuplicateError", 72), ("gppcv2AceDuplicateSequenceNumError", 73), ("gppcv2AceCfgLimitReachedError", 74), ("gppcv2AceNotFoundError", 75), ("gppcv2AclDuplcateNameError", 76), ("gppcv2AclMaxSequenceNumError", 77), ("gppcv2AclMgmtVlanConflictError", 78), ("gppcv2AclApplyError", 79), ("gppcv2AclCreateError", 80), ("gppcv2AclCfgLimitReachedError", 81), ("gppcv2AclNotFoundError", 82), ("gppcv2AclNotAppliedVlanError", 83), ("gppcv2AclNotAppliedPortError", 84), ("gppcv2InvalidTypeForCrfError", 85), ("gppcv2AclResequenceLimitError", 86), ("gppcv2ClassMaxSequenceNumError", 87), ("gppcv2ClassNotFoundError", 88), ("gppcv2ClassCreateError", 89), ("gppcv2ClassEntryCfgLimitReachedError", 90), ("gppcv2ClassListCfgLimitReachedError", 91), ("gppcv2ClassDuplicateNameError", 92), ("gppcv2ClassEntryAddError", 93), ("gppcv2ClassEntryNotFoundError", 94), ("gppcv2ClassConflictingRuleError", 95), ("gppcv2PolicyNotFoundError", 96), ("gppcv2PolicyNameConflictError", 97), ("gppcv2PolicyNotAppliedError", 98), ("gppcv2PolicyCreateError", 99), ("gppcv2PolicyAddClassError", 100), ("gppcv2PolicyDeleteClassError", 101), ("gppcv2PolicyClassNotFoundError", 102), ("gppcv2PolicyDeleteError", 103), ("gppcv2PolicyApplyError", 104), ("gppcv2PolicyIsAppliedCannotDeleteError", 105), ("gppcv2PolicyDuplicateClassError", 106), ("gppcv2PolicyClassifiedVlanOnVlanError", 107), ("gppcv2PolicyCfgLimitReachedError", 108), ("gppcv2PolicyApplyDetailedError", 109), ("gppcv2ClassNoMixMacAndIPError", 110), ("gppcv2InvalidEtherTypeError", 111))

hpicfGppcv2Conformance = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 1))
hpicfGppcv2AppControlTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2), )
if mibBuilder.loadTexts: hpicfGppcv2AppControlTable.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AppControlTable.setDescription('The application control table. This keeps track of the applications that use Gppcv2, the policies set by these applications, and information on where/when/how to apply these policies. This information includes the interfaces and VLANs where the policy should be applied, whether it should be applied at ingress or egress, and when it should expire. The following limitation is in place: there can be no more than one policy action per SNMP pdu.')
hpicfGppcv2AppControlEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1), ).setIndexNames((0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcAppName"), (0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcAppInstance"), (0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcPolicyType"), (0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcPolicyName"))
if mibBuilder.loadTexts: hpicfGppcv2AppControlEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AppControlEntry.setDescription('An entry in the application control table.')
hpicfGppcv2AcAppName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 16)))
if mibBuilder.loadTexts: hpicfGppcv2AcAppName.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcAppName.setDescription('Name of the application that last modified this row. All applications of the same type should use the same name and should use different instance identifiers to identify themselves uniquely. This is a printable string up to 16 bytes in size.')
hpicfGppcv2AcAppInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 16)))
if mibBuilder.loadTexts: hpicfGppcv2AcAppInstance.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcAppInstance.setDescription('Instance identifier of the application. This is used to distinguish between different instances of the same application. This is a printable string up to 16 bytes in size.')
hpicfGppcv2AcPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 3), HpicfGppcv2PolicyType())
if mibBuilder.loadTexts: hpicfGppcv2AcPolicyType.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcPolicyType.setDescription('Type of the policy, used to distinguish policies with the same name.')
hpicfGppcv2AcPolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 4), HpicfGppcv2PolicyName())
if mibBuilder.loadTexts: hpicfGppcv2AcPolicyName.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcPolicyName.setDescription('Name of the policy. Each policy is uniquely identified by its name. It is possible to apply the same policy in different manners to different interfaces and VLANs. This is a printable string up to 64 characters in size and case sensitive.')
hpicfGppcv2AcIngressIfList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 5), PortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcIngressIfList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcIngressIfList.setDescription('List of interfaces to which this policy applies at ingress.')
hpicfGppcv2AcIngressVIDList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcIngressVIDList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcIngressVIDList.setDescription("A string of octets containing one bit per Vlan-Id for VLANS with vlan index values of 0 through 4096. The first octet corresponds to VLANs with vlan index values of 0 through 7, the second octet to VLANs 8 through 15, etc. The most significant bit of each octet corresponds to the lowest vlan index value in that octet. For each VLAN that this policy should apply to at ingress, the corresponding bit is set to '1'.")
hpicfGppcv2AcEgressIfList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 7), PortList()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcEgressIfList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcEgressIfList.setDescription('List of interfaces to which this policy applies at egress.')
hpicfGppcv2AcEgressVIDList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 8), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcEgressVIDList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcEgressVIDList.setDescription("A string of octets containing one bit per Vlan-Id for VLANS with vlan index values of 0 through 4096. The first octet corresponds to VLANs with vlan index values of 0 through 7, the second octet to VLANs 8 through 15, etc. The most significant bit of each octet corresponds to the lowest vlan index value in that octet. For each VLAN that this policy should apply to at egress, the corresponding bit is set to '1'.")
hpicfGppcv2AcVIDList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcVIDList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcVIDList.setDescription("A string of octets containing one bit per Vlan-Id for VLANS with vlan index values of 0 through 4096. The first octet corresponds to VLANs with vlan index values of 0 through 7, the second octet to VLANs 8 through 15, etc. The most significant bit of each octet corresponds to the lowest vlan index value in that octet. For each VLAN that this policy should apply to as a VLAN ACL, the corresponding bit is set to '1'.")
hpicfGppcv2AcExpPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("permanent", 1)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcExpPolicy.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcExpPolicy.setDescription("Expiration policy. This indicates whether a policy should expire automatically. 'permanent' means a policy should never expire automatically.")
hpicfGppcv2AcExpString = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 24))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcExpString.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcExpString.setDescription("Expiration string. This is used in conjunction with hpicfGppcv2AcExpPolicy to indicate when a policy should expire automatically. The value stored in this object is interpreted differently for different expiration policies. When the expiration policy is 'permanent', this value is ignored.")
hpicfGppcv2AcLastErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 12), HpicfGppcv2LastErrorCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGppcv2AcLastErrorCode.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcLastErrorCode.setDescription('Error code of the last error that occurred. A non-zero value indicates that the last operation performed by this instance of the application on the named policy did not succeed. A detailed description of the error is available in hpicfGppcv2AcLastErrorString.')
hpicfGppcv2AcLastErrorString = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 13), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGppcv2AcLastErrorString.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcLastErrorString.setDescription('Description of the last error that occurred. This is a printable ASCII string that describes the error in some detail.')
hpicfGppcv2AcRowAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcRowAdminStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcRowAdminStatus.setDescription('Administrative status of this row. The named policy in this row is applied to the interfaces and/or VLANs by this instance of the application only when the administrative status is enabled. This is the main on/off switch for the row. The row status must be active for this switch to have an effect.')
hpicfGppcv2AcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 15), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcRowStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcRowStatus.setDescription('Status of this row. Row status must be active, and the admin status (see hpicfGppcv2AcRowAdminStatus) must be enabled for this row to be activated.')
hpicfGppcv2AcIngressTunnelList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcIngressTunnelList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcIngressTunnelList.setDescription("A string of octets containing one bit per tunnel-id for tunnels with tunnel values of 0 through 2047. The first octet corresponds to tunnel with values of 0 through 7, the second octet with values from 8 through 15, etc. The most significant bit of each octet corresponds to the lowest tunnel value in that octet. For each tunnel that this policy should apply to at ingress, the corresponding bit is set to '1'.")
hpicfGppcv2AcEgressTunnelList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 256))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcEgressTunnelList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcEgressTunnelList.setDescription("A string of octets containing one bit per tunnel-id for tunnels with tunnel values of 0 through 2047. The first octet corresponds to tunnel with values of 0 through 7, the second octet with values from 8 through 15, etc. The most significant bit of each octet corresponds to the lowest tunnel value in that octet. For each tunnel that this policy should apply to at egress, the corresponding bit is set to '1'.")
hpicfGppcv2AcVACLEgressVIDList = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcVACLEgressVIDList.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcVACLEgressVIDList.setDescription("A string of octets containing one bit per VLAN-ID for VLANs with VLAN index values of 0 through 4096. The first octet corresponds to VLANs with VLAN index values of 0 through 7, the second octet to VLANs 8 through 15, etc. The most significant bit of each octet corresponds to the lowest VLAN index value in that octet. For each VLAN that this policy should apply to as a VLAN ACL, the corresponding bit is set to '1'.")
hpicfGppcv2AcSharedFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 2, 1, 19), TruthValue()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2AcSharedFlag.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2AcSharedFlag.setDescription('The shared flag indicates whether to share the hardware resources for each application of this ACL on this type of interface where possible.')
hpicfGppcv2NamedPolicyTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3), )
if mibBuilder.loadTexts: hpicfGppcv2NamedPolicyTable.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NamedPolicyTable.setDescription('The named policy table. This table lists the name and type of all policies that are applied via Gppcv2. The following limitation is in place: there can be no more than one policy action per SNMP pdu.')
hpicfGppcv2NamedPolicyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1), ).setIndexNames((0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpPolicyName"), (0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpPolicyType"))
if mibBuilder.loadTexts: hpicfGppcv2NamedPolicyEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NamedPolicyEntry.setDescription('An entry in the named policy table.')
hpicfGppcv2NpPolicyName = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 1), HpicfGppcv2PolicyName())
if mibBuilder.loadTexts: hpicfGppcv2NpPolicyName.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpPolicyName.setDescription('Name of the policy. The name of a policy is its unique identification. It is a printable string in ASCII characters. It can be up to 64 characters in length and is case sensitive.')
hpicfGppcv2NpPolicyType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 2), HpicfGppcv2PolicyType())
if mibBuilder.loadTexts: hpicfGppcv2NpPolicyType.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpPolicyType.setDescription('Type of the policy as defined in the TEXTUAL-CONVENTION.')
hpicfGppcv2NpSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("subtypeNone", 1), ("aclStandard", 2), ("aclExtended", 3), ("aclConnectionRateFilter", 4), ("aclIdm", 5), ("aclExtendedIpv6", 6), ("policyQos", 7), ("policyMirror", 8), ("policyPbr", 9), ("policyIpsec", 10), ("aclMacStandard", 11), ("aclMacExtended", 12), ("policyUser", 13)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2NpSubType.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpSubType.setDescription("Subtype of the policy. A subtype of 'aclStandard' indicates that the policy is a standard Access Control List. The policy is used to permit or deny packets based on source IPv4 address and subnet only. A subtype of 'aclExtended' indicates that the policy is an extended Access Control List, an ACL that filters packets based on source IPv4 address and subnet, destination IPv4 address and subnet, and protocol amongst other packet information. A subtype of 'aclConnectionRateFilter' indicates that the policy is a connection-rate-filter Access Control List, similar to an ACL-extended. A subtype of 'aclIdm' indicates that the policy is a Identity Driven Management ACL used to filter traffic based on the source MAC address, protocol and destination IP information of a packet. A subtype of 'aclExtendedIpv6' indicates that the policy is an extended Access Control List, an ACL that filters packets based on source IPv6 address and subnet, destination IPv6 address and subnet, and protocol amongst other packet information. A subype of 'policyQos' indicates that the policy will perform Quality of Service actions on packets that match statements in the policy's classes. A subtype of 'policyMirror' indicates that the policy will perform mirror actions on packets that match statements in the policy's classes. A subtype of 'policyPbr' indicates that the policy will perform Policy Based Routing actions on packets that match statements in the policy's classes. A subtype of 'policyIpsec' indicates that the policy will perform IPsec actions on the packets that match statements in the policy's classes. A subtype of 'aclMacStandard' indicates that the policy is a standard MAC ACL. This ACL filters packets based on the source MAC address. A subtype of 'aclMacExtended' indicates that the policy is an extended MAC ACL. This ACL filters packets based on source MAC address, destination MAC address, ethertype, CoS and VLAN. A subtype of 'policyUser' indicates that the policy will perform per user actions on packets that match statements in the policy's classes.")
hpicfGppcv2NpReseqStart = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2NpReseqStart.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpReseqStart.setDescription('Specifies the starting sequence number for resequence.')
hpicfGppcv2NpReseqIncr = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2NpReseqIncr.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpReseqIncr.setDescription('Specifies the increment value for resequence.')
hpicfGppcv2NpLastSeqNo = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGppcv2NpLastSeqNo.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpLastSeqNo.setDescription('Contains the highest valid sequence number for this policy entry at any point of time.')
hpicfGppcv2NpLastErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 7), HpicfGppcv2LastErrorCode()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGppcv2NpLastErrorCode.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpLastErrorCode.setDescription('Error code of the last error that occurred. A non-zero value indicates that the last operation performed on the ruleEntry of this policy did not succeed. A detailed description of the error is available in hpicfGppcv2NpLastErrorString.')
hpicfGppcv2NpLastErrorString = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 8), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hpicfGppcv2NpLastErrorString.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpLastErrorString.setDescription('Description of the last error that occurred. This is a printable ASCII string that describes the error in some detail.')
hpicfGppcv2NpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 3, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2NpRowStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2NpRowStatus.setDescription('Status of this row. The named policy must be active before rules can be added to it or removed from it. A newly created policy will remain in notReady state until it is given a valid policy type (see hpicfGppcv2NpPolicyType). A row in the named policy table can not be deleted if the named policy is referenced by a row in the application control table. The application control entries that refer to this row must be deleted before this row can be deleted.')
hpicfGppcv2PolicyRulesTable = MibTable((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 4), )
if mibBuilder.loadTexts: hpicfGppcv2PolicyRulesTable.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2PolicyRulesTable.setDescription('The policy rules table. A policy can consist of multiple rules. All of the rules of a policy are listed in this table. Each rule consists of a string and a numeric identifier - the rule id. The following limitation is in place: there can be no more than one policy action per SNMP pdu.')
hpicfGppcv2PolicyRulesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 4, 1), ).setIndexNames((0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpPolicyName"), (0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpPolicyType"), (0, "HP-ICF-GPPCV2-MIB", "hpicfGppcv2PrRuleId"))
if mibBuilder.loadTexts: hpicfGppcv2PolicyRulesEntry.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2PolicyRulesEntry.setDescription('An entry in the policy rules table.')
hpicfGppcv2PrRuleId = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: hpicfGppcv2PrRuleId.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2PrRuleId.setDescription('Numeric identifier of the rule. The rules in a policy are processed sequentially in increasing order of their rule ids. These numeric ids are generated by the application that creates the policy. Rules within a policy have unique rule IDs.')
hpicfGppcv2PrPolicyRule = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 4, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2PrPolicyRule.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2PrPolicyRule.setDescription('Rule string. This is a string that represents one rule in the policy. A policy can consist of one or many rules. For details on the format of the rule string please see: http://h17007.www1.hp.com')
hpicfGppcv2PrRemark = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 4, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2PrRemark.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2PrRemark.setDescription('Remark string. This is a descriptive text string for a policy rule entry. For details on the format of the rule string please see: http://h17007.www1.hp.com')
hpicfGppcv2PrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 4, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hpicfGppcv2PrRowStatus.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2PrRowStatus.setDescription('Status of this row. A rule must have an active row status in order to take effect. Only active rules within the named policy are applied when an application applies the policy. It is possible to use this row status as an on/off switch for enabling or disabling selected rules within a policy. A newly created rule will remain in notReady state until it is given a valid rule string (see hpicfGppcv2PrPolicyRule).')
hpicfGppcv2MIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 1, 1))
hpicfGppcv2MIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 1, 2))
hpicfGppcv2MIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 1, 1, 1)).setObjects(("HP-ICF-GPPCV2-MIB", "hpicfGppcv2Group"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2Group"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGppcv2MIBCompliance = hpicfGppcv2MIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfGppcv2MIBCompliance.setDescription('The compliance statement for HP routers implementing the HP-ICF-Gppcv2-MIB.')
hpicfGppcv2MIBCompliance1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 1, 1, 2)).setObjects(("HP-ICF-GPPCV2-MIB", "hpicfGppcv2Group1"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2Group1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGppcv2MIBCompliance1 = hpicfGppcv2MIBCompliance1.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2MIBCompliance1.setDescription('The compliance statement for HP routers implementing the HP-ICF-Gppcv2-MIB.')
hpicfGppcv2Group = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 1, 2, 1)).setObjects(("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcIngressIfList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcIngressVIDList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcEgressIfList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcEgressVIDList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcVIDList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcExpPolicy"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcExpString"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcLastErrorCode"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcLastErrorString"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcRowAdminStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcRowStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpSubType"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpReseqStart"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpReseqIncr"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpLastSeqNo"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpLastErrorCode"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpLastErrorString"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpRowStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2PrPolicyRule"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2PrRemark"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2PrRowStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcIngressTunnelList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcEgressTunnelList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcVACLEgressVIDList"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGppcv2Group = hpicfGppcv2Group.setStatus('deprecated')
if mibBuilder.loadTexts: hpicfGppcv2Group.setDescription('A collection of HP proprietary objects to support Gppcv2.')
hpicfGppcv2Group1 = ObjectGroup((1, 3, 6, 1, 4, 1, 11, 2, 14, 11, 5, 1, 61, 1, 2, 2)).setObjects(("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcIngressIfList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcIngressVIDList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcEgressIfList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcEgressVIDList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcVIDList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcExpPolicy"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcExpString"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcLastErrorCode"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcLastErrorString"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcRowAdminStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcRowStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpSubType"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpReseqStart"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpReseqIncr"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpLastSeqNo"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpLastErrorCode"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpLastErrorString"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2NpRowStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2PrPolicyRule"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2PrRemark"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2PrRowStatus"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcIngressTunnelList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcEgressTunnelList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcVACLEgressVIDList"), ("HP-ICF-GPPCV2-MIB", "hpicfGppcv2AcSharedFlag"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hpicfGppcv2Group1 = hpicfGppcv2Group1.setStatus('current')
if mibBuilder.loadTexts: hpicfGppcv2Group1.setDescription('A collection of HP proprietary objects to support Gppcv2.')
mibBuilder.exportSymbols("HP-ICF-GPPCV2-MIB", hpicfGppcv2PolicyRulesEntry=hpicfGppcv2PolicyRulesEntry, hpicfGppcv2AcPolicyName=hpicfGppcv2AcPolicyName, hpicfGppcv2AcRowAdminStatus=hpicfGppcv2AcRowAdminStatus, hpicfGppcv2NpLastErrorString=hpicfGppcv2NpLastErrorString, hpicfGppcv2PolicyRulesTable=hpicfGppcv2PolicyRulesTable, hpicfGppcv2AcEgressVIDList=hpicfGppcv2AcEgressVIDList, hpicfGppcv2AcAppName=hpicfGppcv2AcAppName, hpicfGppcv2Group=hpicfGppcv2Group, hpicfGppcv2MIBCompliance1=hpicfGppcv2MIBCompliance1, hpicfGppcv2NpReseqIncr=hpicfGppcv2NpReseqIncr, hpicfGppcv2AcEgressTunnelList=hpicfGppcv2AcEgressTunnelList, hpicfGppcv2AcPolicyType=hpicfGppcv2AcPolicyType, hpicfGppcv2AcSharedFlag=hpicfGppcv2AcSharedFlag, hpicfGppcv2NpPolicyType=hpicfGppcv2NpPolicyType, HpicfGppcv2PolicyType=HpicfGppcv2PolicyType, hpicfGppcv2AcIngressVIDList=hpicfGppcv2AcIngressVIDList, hpicfGppcv2AcExpPolicy=hpicfGppcv2AcExpPolicy, hpicfGppcv2MIB=hpicfGppcv2MIB, hpicfGppcv2Conformance=hpicfGppcv2Conformance, hpicfGppcv2PrRemark=hpicfGppcv2PrRemark, hpicfGppcv2Group1=hpicfGppcv2Group1, hpicfGppcv2NpReseqStart=hpicfGppcv2NpReseqStart, hpicfGppcv2AcLastErrorString=hpicfGppcv2AcLastErrorString, hpicfGppcv2MIBCompliance=hpicfGppcv2MIBCompliance, hpicfGppcv2AcExpString=hpicfGppcv2AcExpString, HpicfGppcv2LastErrorCode=HpicfGppcv2LastErrorCode, HpicfGppcv2PolicyName=HpicfGppcv2PolicyName, hpicfGppcv2AppControlTable=hpicfGppcv2AppControlTable, hpicfGppcv2AppControlEntry=hpicfGppcv2AppControlEntry, hpicfGppcv2AcLastErrorCode=hpicfGppcv2AcLastErrorCode, hpicfGppcv2AcRowStatus=hpicfGppcv2AcRowStatus, hpicfGppcv2AcIngressTunnelList=hpicfGppcv2AcIngressTunnelList, hpicfGppcv2AcVACLEgressVIDList=hpicfGppcv2AcVACLEgressVIDList, hpicfGppcv2NpLastSeqNo=hpicfGppcv2NpLastSeqNo, hpicfGppcv2PrRowStatus=hpicfGppcv2PrRowStatus, hpicfGppcv2PrRuleId=hpicfGppcv2PrRuleId, hpicfGppcv2AcVIDList=hpicfGppcv2AcVIDList, hpicfGppcv2AcEgressIfList=hpicfGppcv2AcEgressIfList, hpicfGppcv2PrPolicyRule=hpicfGppcv2PrPolicyRule, hpicfGppcv2NamedPolicyTable=hpicfGppcv2NamedPolicyTable, hpicfGppcv2NpSubType=hpicfGppcv2NpSubType, hpicfGppcv2MIBGroups=hpicfGppcv2MIBGroups, PYSNMP_MODULE_ID=hpicfGppcv2MIB, hpicfGppcv2AcAppInstance=hpicfGppcv2AcAppInstance, hpicfGppcv2AcIngressIfList=hpicfGppcv2AcIngressIfList, hpicfGppcv2NpLastErrorCode=hpicfGppcv2NpLastErrorCode, hpicfGppcv2MIBCompliances=hpicfGppcv2MIBCompliances, hpicfGppcv2NpPolicyName=hpicfGppcv2NpPolicyName, hpicfGppcv2NpRowStatus=hpicfGppcv2NpRowStatus, hpicfGppcv2NamedPolicyEntry=hpicfGppcv2NamedPolicyEntry)

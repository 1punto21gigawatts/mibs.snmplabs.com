#
# PySNMP MIB module CISCO-MGX82XX-RPM-CONN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-MGX82XX-RPM-CONN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:07:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint")
rpmChanGrp, = mibBuilder.importSymbols("BASIS-MIB", "rpmChanGrp")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Bits, MibIdentifier, iso, Counter64, TimeTicks, Gauge32, ModuleIdentity, Counter32, ObjectIdentity, IpAddress, NotificationType, Unsigned32, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibIdentifier", "iso", "Counter64", "TimeTicks", "Gauge32", "ModuleIdentity", "Counter32", "ObjectIdentity", "IpAddress", "NotificationType", "Unsigned32", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ciscoMgx82xxRpmConnMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 62))
ciscoMgx82xxRpmConnMIB.setRevisions(('2002-09-08 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoMgx82xxRpmConnMIB.setRevisionsDescriptions(('Initial version of the MIB. The content of this MIB was originally available in CISCO-WAN-AXIPOP-MIB defined using SMIv1. The applicable objects from CISCO-WAN-AXIPOP-MIB are defined using SMIv2 in this MIB. Also the descriptions of some of the objects have been modified.',))
if mibBuilder.loadTexts: ciscoMgx82xxRpmConnMIB.setLastUpdated('200209080000Z')
if mibBuilder.loadTexts: ciscoMgx82xxRpmConnMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoMgx82xxRpmConnMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoMgx82xxRpmConnMIB.setDescription("The connection MIB module for RPM(Router Blade) service module in MGX8250/MGX8230 products. The 'channel' and 'connection' and 'connection endpoint' mean same in this MIB.")
class RpmNsapAddress(TextualConvention, OctetString):
    description = 'ATM address used by the networking entity. The only address type presently supported is NSAP (20 octets)'
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(20, 20)
    fixedLength = 20

rpmChanGrpTable = MibTable((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1), )
if mibBuilder.loadTexts: rpmChanGrpTable.setStatus('current')
if mibBuilder.loadTexts: rpmChanGrpTable.setDescription('This table contains endpoint configuration information for connections applicable to RPM service module.')
rpmChanGrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1), ).setIndexNames((0, "CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanSlotNum"), (0, "CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanNum"))
if mibBuilder.loadTexts: rpmChanGrpEntry.setStatus('current')
if mibBuilder.loadTexts: rpmChanGrpEntry.setDescription('An entry for logical channel. Each entry corresponds to a connection endpoint identified by Slot number and channel number.')
rpmChanSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 30))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanSlotNum.setStatus('current')
if mibBuilder.loadTexts: rpmChanSlotNum.setDescription('Specifies the slot number of the RPM card.')
rpmChanInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanInterface.setStatus('current')
if mibBuilder.loadTexts: rpmChanInterface.setDescription("This is the RPM's backplane interface. Currently there is only one interface.")
rpmChanNum = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanNum.setStatus('current')
if mibBuilder.loadTexts: rpmChanNum.setDescription('This object identifies the channel number. This is also called Logical Connection Number(LCN). This is a unique number which identifies a connection. The LCN maps VPI and VCI. For VCC, VCI range is 1..3825, and LCN range is 16..3840. LCN = VCI + 16. For VPC, VPI range is 1..255 and LCN range is 3841..4095. LCN = VPI + 3840.')
rpmChanRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("add", 1), ("del", 2), ("mod", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRowStatus.setStatus('current')
if mibBuilder.loadTexts: rpmChanRowStatus.setDescription('This indicates the status of this channel. add(1) : Channel is added. del(2) : channel is deleted. mod(3) : Set to this value before modifying objects related to connection endpoints.')
rpmChanVcd = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVcd.setStatus('current')
if mibBuilder.loadTexts: rpmChanVcd.setDescription('Virtual Circuit Descriptor. A unique number which identifies a connection.')
rpmChanVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVpi.setStatus('current')
if mibBuilder.loadTexts: rpmChanVpi.setDescription('The VPI value for this channel. For VPC, VPI range is 1..255 and LCN range is 3841..4095. LCN = VPI + 3840')
rpmChanVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVci.setStatus('current')
if mibBuilder.loadTexts: rpmChanVci.setDescription('The VCI value for this channel. For VCC, VCI range is 1..3825, and LCN range is 16..3840. LCN = VCI + 16.')
rpmChanSubInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanSubInterface.setStatus('current')
if mibBuilder.loadTexts: rpmChanSubInterface.setDescription("This is the RPM's backplane sub-interface.")
rpmChanLocalVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanLocalVpi.setStatus('current')
if mibBuilder.loadTexts: rpmChanLocalVpi.setDescription('This VPI together with the local VCI and NSAP represents the local end point in this connection. The VPI value is zero for rpmChanConnType value of vcc(2).')
rpmChanLocalVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanLocalVci.setStatus('current')
if mibBuilder.loadTexts: rpmChanLocalVci.setDescription('This VCI together with the local VPI and NSAP represents the local end point in this connection.')
rpmChanLocalNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 11), RpmNsapAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanLocalNsap.setStatus('current')
if mibBuilder.loadTexts: rpmChanLocalNsap.setDescription('This object identifies the local NSAP address. The bytes are mapped as follows: prefix : 13 bytes Cisco ID : 2 bytes Reserved : 2 bytes Slot/Port : 2 bytes[5 bit slot, 11 bits port] Selector : 1 byte. Of the 13 bytes for the node name, only the first 8 bytes are used. If the node name is n (0 < n < 8) bytes long, the node name must be left justified ( Bytes 1 to n contain the node name and bytes (n+1) to 8 must be 0 ). Bytes 9-13 must be always 0.')
rpmChanRemoteVpi = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteVpi.setStatus('current')
if mibBuilder.loadTexts: rpmChanRemoteVpi.setDescription('This VPI together with the remote VCI and NSAP represents the remote end point in this connection.')
rpmChanRemoteVci = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteVci.setStatus('current')
if mibBuilder.loadTexts: rpmChanRemoteVci.setDescription('This VCI together with the remote VPI and NSAP represents the remote end point in this connection.')
rpmChanRemoteNsap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 14), RpmNsapAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteNsap.setStatus('current')
if mibBuilder.loadTexts: rpmChanRemoteNsap.setDescription('This object identifies the remote NSAP address. The bytes are mapped as follows: prefix : 13 bytes Cisco ID : 2 bytes Reserved : 2 bytes Slot/Port : 2 bytes[5 bit slot, 11 bits port] Selector : 1 byte.')
rpmChanType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("svc", 1), ("pvc", 2), ("spvc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanType.setStatus('current')
if mibBuilder.loadTexts: rpmChanType.setDescription('This object identifies the channel type svc(1) : Switched Virtual Connection pvc(2) : Permanent Virtual Connection spvc(3) : Soft PVC.')
rpmChanConnType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("vpc", 1), ("vcc", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanConnType.setStatus('current')
if mibBuilder.loadTexts: rpmChanConnType.setDescription('This specifies the connection type vpc(1) : Virtual Path Connection vcc(1) : Virtual Channel Connection')
rpmChanServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 5, 6, 7))).clone(namedValues=NamedValues(("cbr", 1), ("vbr", 2), ("ubr", 4), ("atfr", 5), ("abrstd", 6), ("abrfst", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanServiceType.setStatus('current')
if mibBuilder.loadTexts: rpmChanServiceType.setDescription('This object identifies the connection service type. cbr (1) : Constant Bit Rate vbr (2) : Variable Bit Rate ubr (4) : Unspecified Bit Rate atfr (5) : ATM Frame Relay abrstd (6) : Standard ABR abrfst (7) : foresight ABR.')
rpmChanMastership = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMastership.setStatus('current')
if mibBuilder.loadTexts: rpmChanMastership.setDescription('This specifies which end of the connection is the master. This is used by PXM to determine if this end point is master or slave.')
rpmChanRtePriority = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRtePriority.setStatus('current')
if mibBuilder.loadTexts: rpmChanRtePriority.setDescription('This is also known as class of service, it is used by PXM to determine how important this connection is when selecting connections to route.')
rpmChanMaxCost = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMaxCost.setStatus('current')
if mibBuilder.loadTexts: rpmChanMaxCost.setDescription("Maximum allowed cost. It is related to Cost Based Routing. This is used by PXM so that it won't choose a path with a cost greater than this configured level.")
rpmChanRestrictTrkType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("noRestriction", 1), ("terrestrialTrunk", 2), ("satelliteTrunk", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRestrictTrkType.setStatus('current')
if mibBuilder.loadTexts: rpmChanRestrictTrkType.setDescription('Restricted trunk type for routing, used by PXM. It specifies that the connection either cannot be routed over satellite trunks or terrestrial trunks, or it can be on any type of trunk.')
rpmChanPCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanPCR.setStatus('current')
if mibBuilder.loadTexts: rpmChanPCR.setDescription('Peak cell rate.(in cells per sec.)')
rpmChanRemotePCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemotePCR.setStatus('current')
if mibBuilder.loadTexts: rpmChanRemotePCR.setDescription('Peak cell rate of the remote endpoint of the connection. If not set, its value will be same as the value of rpmChanPCR.')
rpmChanMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setUnits('cells-per-second').setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMCR.setStatus('current')
if mibBuilder.loadTexts: rpmChanMCR.setDescription('Minimum cell rate.(in cells per sec.).')
rpmChanRemoteMCR = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 353208))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemoteMCR.setStatus('current')
if mibBuilder.loadTexts: rpmChanRemoteMCR.setDescription('Minimum cell rate of the remote endpoint. If this is not set, its value will be same as value of rpmChanMCR.')
rpmChanPercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanPercentUtil.setStatus('current')
if mibBuilder.loadTexts: rpmChanPercentUtil.setDescription('This is the expected long-term utilization of the channel by this end-point.')
rpmChanRemotePercentUtil = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanRemotePercentUtil.setStatus('current')
if mibBuilder.loadTexts: rpmChanRemotePercentUtil.setDescription("This is the expected long-term utilization of the channel by the other end-point. If this is not specified in the connection setup request, it'll be set to be the same as the local end.")
rpmChanEncapType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("aal5snap", 1), ("aal34smds", 2), ("aal5nlpid", 3), ("qsaal", 4), ("ilmi", 5), ("aal5muxXNS", 6), ("aal5muxIP", 7), ("aal5muxVINES", 8), ("aal5muxDECNET", 9), ("aal5muxNOVELL1", 10), ("ppp", 11), ("unknown", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanEncapType.setStatus('current')
if mibBuilder.loadTexts: rpmChanEncapType.setDescription('This object identifies the ATM adaptation layer (AAL) and Encapsulation type. aal5snap - LLC/SNAP precedes the protocol datagram. aal34smds - Encapsulation for SMDS network. aal5nlpid - Encapsulation that allows ATM interfaces to interoperate with HSSI. qsaal - signaling type PVC used for setting up or tearing down SVCs. ilmi - used to set up communication with ILMI. aal5mux[protocol] - a MUX-type Virtual circuit. ppp - PPP over ATM. The Encapsulation types aal34smds, qsaal and ilmi are not supported.')
rpmChanMidLow = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMidLow.setStatus('current')
if mibBuilder.loadTexts: rpmChanMidLow.setDescription('Starting Message Identifier Number for this PVC.')
rpmChanMidHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1023))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanMidHigh.setStatus('current')
if mibBuilder.loadTexts: rpmChanMidHigh.setDescription('Ending Message Identifier Number for this PVC.')
rpmChanBurstSize = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanBurstSize.setStatus('current')
if mibBuilder.loadTexts: rpmChanBurstSize.setDescription('The Maximum number of ATM cells the virtual circuit can transmit.')
rpmChanInArpFreq = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60))).setUnits('minutes').setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanInArpFreq.setStatus('current')
if mibBuilder.loadTexts: rpmChanInArpFreq.setDescription('Specifies how often Inverse ARP datagrams will be sent on this virtual circuit. The value zero will disable the IN-ARP for this channel. This object is supported only for the value of rpmChanEncapType = aal5snap.')
rpmChanOAMloopback = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanOAMloopback.setStatus('current')
if mibBuilder.loadTexts: rpmChanOAMloopback.setDescription('This object specifies how often to generate an OAM F5 loopback cell from this virtual circuit. The value zero will disable generation of OAM F5 loopback cells.')
rpmChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("notConfigured", 1), ("active", 2), ("failed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanState.setStatus('current')
if mibBuilder.loadTexts: rpmChanState.setDescription("This indicates the status of this channel. 1 ==> notConfigured 2 ==> active 3 ==> failed. Currently 'failed' state is not supported. When the channel is not added, the state is notConfigured.")
rpmChanVirtualTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 35), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanVirtualTemplate.setStatus('current')
if mibBuilder.loadTexts: rpmChanVirtualTemplate.setDescription('Specifies the Virtual Template used for CISCO PPP. If it is not using Virtual Template then this value is zero.')
rpmChanAbrRDF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanAbrRDF.setReference('ATM Forum Traffic Management Specification Version 4.0 Section 5.10.2')
if mibBuilder.loadTexts: rpmChanAbrRDF.setStatus('current')
if mibBuilder.loadTexts: rpmChanAbrRDF.setDescription('This is valid only for ABR Service Type. Rate Decrease Factor: Controls the rate decrease which occurs when backward RM-cells with CI=1 are received. Larger values lead to faster rate decrease.')
rpmChanAbrRIF = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 110, 5, 2, 10, 1, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rpmChanAbrRIF.setReference('ATM Forum Traffic Management Specification Version 4.0 Section 5.10.2')
if mibBuilder.loadTexts: rpmChanAbrRIF.setStatus('current')
if mibBuilder.loadTexts: rpmChanAbrRIF.setDescription('This is valid only for ABR Service Type. Rate Increase Factor: Controls the rate increase which occurs when a backward RM-cell is received with CI=0 and NI=0. Larger values lead to faster rate increase.')
cmrConnMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 62, 2))
cmrConnMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 62, 2, 1))
cmrConnMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 62, 2, 2))
cmrConnMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 62, 2, 1, 1)).setObjects(("CISCO-MGX82XX-RPM-CONN-MIB", "cmrConnConfGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cmrConnMIBCompliance = cmrConnMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cmrConnMIBCompliance.setDescription('The compliance statement for the Cisco MGX RPM connection management group.')
cmrConnConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 62, 2, 2, 1)).setObjects(("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanSlotNum"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanInterface"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanNum"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRowStatus"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanVcd"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanVpi"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanVci"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanSubInterface"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanLocalVpi"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanLocalVci"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanLocalNsap"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRemoteVpi"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRemoteVci"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRemoteNsap"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanType"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanConnType"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanServiceType"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanMastership"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRtePriority"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanMaxCost"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRestrictTrkType"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanPCR"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRemotePCR"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanMCR"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRemoteMCR"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanPercentUtil"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanRemotePercentUtil"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanMidLow"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanMidHigh"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanBurstSize"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanEncapType"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanInArpFreq"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanOAMloopback"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanState"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanVirtualTemplate"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanAbrRDF"), ("CISCO-MGX82XX-RPM-CONN-MIB", "rpmChanAbrRIF"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cmrConnConfGroup = cmrConnConfGroup.setStatus('current')
if mibBuilder.loadTexts: cmrConnConfGroup.setDescription('The objects related to Connections on RPM card.')
mibBuilder.exportSymbols("CISCO-MGX82XX-RPM-CONN-MIB", rpmChanInterface=rpmChanInterface, rpmChanRemoteVci=rpmChanRemoteVci, rpmChanMaxCost=rpmChanMaxCost, rpmChanVpi=rpmChanVpi, rpmChanMidHigh=rpmChanMidHigh, rpmChanPCR=rpmChanPCR, RpmNsapAddress=RpmNsapAddress, cmrConnMIBGroups=cmrConnMIBGroups, rpmChanPercentUtil=rpmChanPercentUtil, rpmChanServiceType=rpmChanServiceType, rpmChanOAMloopback=rpmChanOAMloopback, rpmChanVcd=rpmChanVcd, rpmChanBurstSize=rpmChanBurstSize, rpmChanConnType=rpmChanConnType, rpmChanVci=rpmChanVci, cmrConnMIBCompliances=cmrConnMIBCompliances, rpmChanState=rpmChanState, rpmChanLocalVpi=rpmChanLocalVpi, rpmChanMidLow=rpmChanMidLow, rpmChanRemoteNsap=rpmChanRemoteNsap, rpmChanGrpEntry=rpmChanGrpEntry, rpmChanRemotePCR=rpmChanRemotePCR, rpmChanLocalNsap=rpmChanLocalNsap, rpmChanVirtualTemplate=rpmChanVirtualTemplate, rpmChanType=rpmChanType, cmrConnConfGroup=cmrConnConfGroup, rpmChanInArpFreq=rpmChanInArpFreq, ciscoMgx82xxRpmConnMIB=ciscoMgx82xxRpmConnMIB, rpmChanLocalVci=rpmChanLocalVci, rpmChanRowStatus=rpmChanRowStatus, rpmChanRemoteMCR=rpmChanRemoteMCR, rpmChanGrpTable=rpmChanGrpTable, rpmChanSlotNum=rpmChanSlotNum, rpmChanRtePriority=rpmChanRtePriority, rpmChanRestrictTrkType=rpmChanRestrictTrkType, rpmChanNum=rpmChanNum, rpmChanRemoteVpi=rpmChanRemoteVpi, rpmChanEncapType=rpmChanEncapType, rpmChanRemotePercentUtil=rpmChanRemotePercentUtil, rpmChanAbrRDF=rpmChanAbrRDF, rpmChanMastership=rpmChanMastership, rpmChanAbrRIF=rpmChanAbrRIF, rpmChanSubInterface=rpmChanSubInterface, rpmChanMCR=rpmChanMCR, PYSNMP_MODULE_ID=ciscoMgx82xxRpmConnMIB, cmrConnMIBConformance=cmrConnMIBConformance, cmrConnMIBCompliance=cmrConnMIBCompliance)

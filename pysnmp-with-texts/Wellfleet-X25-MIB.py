#
# PySNMP MIB module Wellfleet-X25-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Wellfleet-X25-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:42:20 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, IpAddress, TimeTicks, MibIdentifier, iso, Counter64, Integer32, Bits, Unsigned32, Counter32, ModuleIdentity, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "IpAddress", "TimeTicks", "MibIdentifier", "iso", "Counter64", "Integer32", "Bits", "Unsigned32", "Counter32", "ModuleIdentity", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
wfX25Group, = mibBuilder.importSymbols("Wellfleet-COMMON-MIB", "wfX25Group")
wfX25 = MibIdentifier((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 1))
wfX25Delete = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25Delete.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25Delete.setDescription('Create/Delete parameter. Default is created.')
wfX25Disable = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25Disable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25Disable.setDescription('Enable/Disable parameter. Default is enabled.')
wfX25State = MibScalar((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25State.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25State.setDescription('The current state of the entire X.25.')
wfX25ServiceTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2), )
if mibBuilder.loadTexts: wfX25ServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceTable.setDescription('This table describes the services of a circuit on an X.25 line.')
wfX25ServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1), ).setIndexNames((0, "Wellfleet-X25-MIB", "wfX25ServiceSlot"), (0, "Wellfleet-X25-MIB", "wfX25ServiceConnector"), (0, "Wellfleet-X25-MIB", "wfX25ServiceLineNumber"), (0, "Wellfleet-X25-MIB", "wfX25ServiceLLIndex"), (0, "Wellfleet-X25-MIB", "wfX25ServiceCct"), (0, "Wellfleet-X25-MIB", "wfX25ServiceIndex"))
if mibBuilder.loadTexts: wfX25ServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceEntry.setDescription('An entry in the X25 Service table.')
wfX25ServiceDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceDelete.setDescription('Create/Delete parameter, default = created.')
wfX25ServiceDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceDisable.setDescription('Enable/Disable parameter, default = enabled.')
wfX25ServiceSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceSlot.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceSlot.setDescription('Slot number and part of Instance Id.')
wfX25ServiceConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceConnector.setDescription('Connector number and instance ID member.')
wfX25ServiceLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceLineNumber.setDescription('Instance identifier member. This is the line number assigned to the driver X.25 is running over. No used in 7.60.')
wfX25ServiceLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceLLIndex.setDescription('Instance identifier member. This is the lower layer index presented to X25 by the layer immediately below it on the protocol stack. If the lower layer is a driver, the index will be 0. Not used in 7.60.')
wfX25ServiceCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceCct.setDescription('Circuit number and instance ID member.')
wfX25ServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceIndex.setDescription('X.25 service entry record ID for this instance.')
wfX25ServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32, 64))).clone(namedValues=NamedValues(("pdntype", 1), ("ddntype", 2), ("ptoptype", 4), ("npttype", 8), ("ipextype", 16), ("qllctype", 32), ("defaulttype", 64)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceType.setDescription('Type of Service.')
wfX25ServiceConnRef = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceConnRef.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceConnRef.setDescription('Use of Connection Reference Numbers in Call Request For PDN only, if ON then use wfX25ServiceConnId as starting reference number for PDN.')
wfX25ServiceConnId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceConnId.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceConnId.setDescription('Connection Id to be used in a PTOP Call request. For PDN this will be the starting number to be used as Connection Id in PDN.')
wfX25ServiceRemoteX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceRemoteX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceRemoteX121Addr.setDescription('Remote X.121 address for this table entry instance.')
wfX25ServiceRemoteIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 13), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceRemoteIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceRemoteIpAddr.setDescription('Remote IP address for PDN and DDN only.')
wfX25ServiceBCast = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceBCast.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceBCast.setDescription('Broadcast recipient status for this table entry instance.')
wfX25ServiceMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceMaxConn.setDescription('Maximum connections per destination for this table entry instance.')
wfX25ServicePrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("negot", 1), ("default", 2))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServicePrecedence.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServicePrecedence.setDescription('Precedence value for this table entry instance. DDN only.')
wfX25ServiceMaxIdle = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceMaxIdle.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceMaxIdle.setDescription('Maximum Idle Time in Minutes for this table entry instance. If 0 is entered the connection stays on forever.')
wfX25ServiceCallRetry = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(10, 999)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceCallRetry.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceCallRetry.setDescription('Interval in seconds between Call Request to same the destination. Must be at least 2 times T11/T21 Timer for Packet Level.')
wfX25ServiceFlowFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("negot", 1), ("default", 2))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceFlowFacility.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceFlowFacility.setDescription('Flow Control negotiation facility parameter for this instance.')
wfX25ServiceWinSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceWinSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceWinSize.setDescription('Packet window size parameter for this table entry instance.')
wfX25ServicePktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("size16", 4), ("size32", 5), ("size64", 6), ("size128", 7), ("size256", 8), ("size512", 9), ("size1024", 10), ("size2048", 11), ("size4096", 12))).clone('size128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServicePktSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServicePktSize.setDescription('Packet size parameter for this table entry instance.')
wfX25ServiceFastSelRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceFastSelRequest.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceFastSelRequest.setDescription('Fast Select Request Facility for this table entry instance.')
wfX25ServiceFastSelAccept = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceFastSelAccept.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceFastSelAccept.setDescription('Fast Select Accept Facility for this table entry instance.')
wfX25ServiceRevChRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceRevChRequest.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceRevChRequest.setDescription('Reverse Charge Request Facility for this table entry instance.')
wfX25ServiceRevChAccept = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceRevChAccept.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceRevChAccept.setDescription('Reverse charge Accept Facility for this table entry instance.')
wfX25ServiceCugFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("basic", 2), ("ext", 3))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceCugFormat.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceCugFormat.setDescription('Closed User Group Facility Format.')
wfX25ServiceCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("oa", 2), ("bilat", 3))).clone('normal')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceCugType.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceCugType.setDescription('Closed User Group Facility Type: Normal CUG, Bilateral CUG, or Outgoing Access CUG.')
wfX25ServiceCugNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceCugNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceCugNum.setDescription('Closed User Group (CUG) number.')
wfX25ServiceUserFacility = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 29), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceUserFacility.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceUserFacility.setDescription('Additional User Supplied Facilities. Must be in Hexadecimal form.')
wfX25ServiceValid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("valid", 1), ("invalid", 2))).clone('valid')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceValid.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceValid.setDescription('Validity of the record - updated by X.25.')
wfX25ServiceBFE = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceBFE.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceBFE.setDescription('Enabled if DDNX.25/BFE enabled.')
wfX25ServiceForceCugZero = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceForceCugZero.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceForceCugZero.setDescription('Force Closed User Group of Zero.')
wfX25ServiceWcpEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceWcpEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceWcpEnable.setDescription('Enable compression')
wfX25ServiceMUX = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceMUX.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceMUX.setDescription('Set to Enabled to perform 1356 Multiplexing of protocols in the same Vc')
wfX25ServicePtopCallRequest = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("default", 1), ("local", 2), ("remote", 3))).clone('default')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServicePtopCallRequest.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServicePtopCallRequest.setDescription('Select which side of PTOP circuit initiates the connection. (default = highest X.121 address initiates the call)')
wfX25ServiceVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("svc", 1), ("pvc", 2))).clone('svc')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceVcType.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcType.setDescription('Determines whether this service record represents a Switch Virtual Circuit (SVC) or Permanent Virtual Circuit (PVC). (default = svc)')
wfX25ServicePvcLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServicePvcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServicePvcLcn.setDescription('PVC Logical Channel Number for this service record')
wfX25ServiceMacPoolStart = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 38), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceMacPoolStart.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceMacPoolStart.setDescription('Starting address of MAC address pool')
wfX25ServiceMacPoolSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 39), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceMacPoolSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceMacPoolSize.setDescription('The size of MAC address pool')
wfX25ServiceWindowTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 40), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceWindowTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceWindowTimeout.setDescription('Window Timeout to detect a dysfunctional VC.')
wfX25ServiceVcBurstThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 41), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceVcBurstThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcBurstThroughput.setDescription('Maximum number of bits of data allowed to be transmitted for this service record in one second. This value is divided equally amongst the VCs active for this service record at any given point in time. A value of 0 indicates Burst control is not to be applied. The default value is 0.')
wfX25ServiceVcBurstQDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceVcBurstQDepth.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcBurstQDepth.setDescription('Maximum number of buffers that can be held in the Burst Queue while the VC gate pends.')
wfX25ServiceVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 9999)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcPriority.setDescription('Priority of the VCs associated with this service record. This value is used to specify whether packets being transmitted for this VC will be given preference over those on another VC or not. In the range for this value, 1..9999, 1 signifies highest priority.')
wfX25ServiceVcBurstQClippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceVcBurstQClippedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcBurstQClippedPkts.setDescription('Total Number of packets dropped for VCs of this service record due to lack of buffers in their respective Burst Queues.')
wfX25ServiceVcBurstQPktCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceVcBurstQPktCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcBurstQPktCnt.setDescription('Total Number of packets stored in the Burst Queues of VCs of this service record between successive attempts to forward to the PLP layer.')
wfX25ServiceVcBurstQHighWaterPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 46), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceVcBurstQHighWaterPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcBurstQHighWaterPkts.setDescription('The Highest Water Packet Mark of the Burst Queues of VCs of this service record.')
wfX25ServiceVcPktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceVcPktDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceVcPktDrops.setDescription('Total Number of Packets Dropped for VCs of this service record at the VC level.')
wfX25ServicePlpPktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServicePlpPktDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServicePlpPktDrops.setDescription('Total Number of Packets Dropped by PLP for VCs of this service record.')
wfX25ServiceBurstThrPerVc = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 49), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25ServiceBurstThrPerVc.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceBurstThrPerVc.setDescription('Burst Throughput per VC, dynamically computed as Burst Throughput confiogured for the service record divided by number of VCs for the service record in Data Transfer State.')
wfX25ServiceBackupRecoveryDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 50), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceBackupRecoveryDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceBackupRecoveryDelay.setDescription('Delay in reverting back to a restored PDN service')
wfX25ServiceSetupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 51), Integer32().clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceSetupTime.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceSetupTime.setDescription('Total time allowed for setting up a PDN SVC before attempting a backup')
wfX25ServiceRetryNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 52), Integer32().clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceRetryNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceRetryNumber.setDescription('The number of times a PDN SVC setup will be attempted if no response is received from the peer')
wfX25BackupInitiation = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("any", 1), ("last", 2))).clone('any')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25BackupInitiation.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25BackupInitiation.setDescription('Determines whether to initiate PDN backup on failure of any SVC or the last one')
wfX25ServiceEntryName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 2, 1, 54), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25ServiceEntryName.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25ServiceEntryName.setDescription('name of the sevice entry')
wfX25VcTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4), )
if mibBuilder.loadTexts: wfX25VcTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcTable.setDescription('This is a table of Statistic Entries is per Virtual Circuit.')
wfX25VcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1), ).setIndexNames((0, "Wellfleet-X25-MIB", "wfX25VcSlotNum"), (0, "Wellfleet-X25-MIB", "wfX25VcConnector"), (0, "Wellfleet-X25-MIB", "wfX25VcLineNumber"), (0, "Wellfleet-X25-MIB", "wfX25VcLLIndex"), (0, "Wellfleet-X25-MIB", "wfX25VcCct"), (0, "Wellfleet-X25-MIB", "wfX25VcNumber"))
if mibBuilder.loadTexts: wfX25VcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcEntry.setDescription('An entry in the X.25 VC table.')
wfX25VcSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcSlotNum.setDescription('Instance ID and Slot number this VC is on.')
wfX25VcConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("one", 1), ("two", 2), ("three", 3), ("four", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcConnector.setDescription('Instance ID and Connector number this VC is using')
wfX25VcLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcLineNumber.setDescription('Instance identifier member. This is the line number assigned to the driver X25 is running on top of and this VC is running on. No used in 7.60')
wfX25VcLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcLLIndex.setDescription('Instance identifier member. This is the lower layer index presented to X25 by the layer immediately below it on the protocol stack. If the lower layer is a driver, the index will be 0. Not used in 7.60.')
wfX25VcCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcCct.setDescription('Instance ID and CCT supporting these VCs. User determines this CCT via log.')
wfX25VcNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcNumber.setDescription('Instance ID and VC number for this VC. This number corresponds to the LCN.')
wfX25VcDataTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcDataTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcDataTxs.setDescription('Number of Data Packets sent.')
wfX25VcInterruptTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcInterruptTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcInterruptTxs.setDescription('Number of Interrupt Packets sent.')
wfX25VcResetTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcResetTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcResetTxs.setDescription('Number of Reset Packets sent.')
wfX25VcRrTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcRrTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcRrTxs.setDescription('Number of Receiver Ready Packets sent.')
wfX25VcRnrTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcRnrTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcRnrTxs.setDescription('Number of Receiver Not Ready Packets sent.')
wfX25VcRejectTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcRejectTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcRejectTxs.setDescription('Number of Reject Packets sent.')
wfX25VcSegmentTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcSegmentTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcSegmentTxs.setDescription('Number of Charge Units sent.')
wfX25VcBytesTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcBytesTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcBytesTxs.setDescription('Number of Data Bytes sent.')
wfX25VcIntBytesTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcIntBytesTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcIntBytesTxs.setDescription('Number of Interrupt Data Bytes sent.')
wfX25VcDataRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcDataRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcDataRxs.setDescription('Number of Data Packets received.')
wfX25VcInterruptRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcInterruptRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcInterruptRxs.setDescription('Number of Interrupt Packets received.')
wfX25VcResetRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcResetRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcResetRxs.setDescription('Number of Reset Packets received.')
wfX25VcRrRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcRrRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcRrRxs.setDescription('Number of Receiver Ready Packets received.')
wfX25VcRnrRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcRnrRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcRnrRxs.setDescription('Number of Receiver Not Ready Packets received.')
wfX25VcRejectRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcRejectRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcRejectRxs.setDescription('Number of Reject Packets received.')
wfX25VcSegmentRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcSegmentRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcSegmentRxs.setDescription('Number of Charge Units received.')
wfX25VcBytesRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcBytesRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcBytesRxs.setDescription('Number of Data Bytes received.')
wfX25VcIntBytesRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcIntBytesRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcIntBytesRxs.setDescription('Number of Interrupt Data Bytes received.')
wfX25VcApPktsDropped = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcApPktsDropped.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcApPktsDropped.setDescription('Number of Application/redirector Packets Droped')
wfX25VcRemoteX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 26), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcRemoteX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcRemoteX121Addr.setDescription('Remote DTE Address for this connection')
wfX25VcBurstQClippedPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcBurstQClippedPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcBurstQClippedPkts.setDescription('Number of packets dropped for this VC due to lack of buffers in the Burst Queue. Packets are only dropped when the value of the statistic wfX25VcBurstQPktCnt is equal to wfX25ServiceVcBurstQDepth.')
wfX25VcBurstQPktCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcBurstQPktCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcBurstQPktCnt.setDescription('Number of packets stored for this VC in the Burst Queue between successive attempts to forward to the PLP layer. This statistic is indicative of the transient loading of buffering mechanism between the PLP layer and the upper layers. The maximum value that this statistic can reach is determined by the setting of wfX25ServiceVcMaxBufCnt. When the value of this statistic is equal to wfX25ServiceVcBurstQDepth, all subsequently arriving packets are dropped.')
wfX25VcBurstQHighWaterPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 29), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcBurstQHighWaterPkts.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcBurstQHighWaterPkts.setDescription('High Water Packet Mark for the Burst Queue of this VC.')
wfX25VcPktsLargerThanBurstThrCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcPktsLargerThanBurstThrCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcPktsLargerThanBurstThrCnt.setDescription('Total Number of Packets serviced on this VC which are larger than the computed burst throughput per VC. The burst throughput per VC is computed as wfX25ServiceVcBurstThroughput / No. of Active VCs for the service record.')
wfX25VcPktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcPktDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcPktDrops.setDescription('Total Number of Packets Dropped on this VC. These drops are caused by insufficient resources being available to forward the packets to the PLP layer.')
wfX25VcPlpPktDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcPlpPktDrops.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcPlpPktDrops.setDescription('Total Number of Packets Dropped by PLP on this VC. These drops are due to either the line being disabled or the lack of buffering to store packets for transmission.')
wfX25VcMbsOutstanding = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcMbsOutstanding.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcMbsOutstanding.setDescription('Number of packets sent to the PLP layer from the upper layer that have not yet been added to the local assembly/deassembly queue at the PLP layer. These packets will require additional processing at a later time. This value is set after the PLP layer has completed processing of the maximum allowable number of packets received from the upper layer.')
wfX25VcMbsOutstandingPostTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcMbsOutstandingPostTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcMbsOutstandingPostTx.setDescription('Number of buffers sent to the PLP layer that have not yet been added to the local asembly/deassembly queue. This value is set after the PLP layer has completed transmission of the maximum allowable number of packets from the local assembly/ deassembly queue to the lower layer.')
wfX25VcMaxTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcMaxTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcMaxTx.setDescription('Maximum Number of buffers that can be sent from the upper layer to the PLP layer at any one time without overflowing the local assembly/desasembly queue.')
wfX25VcMbsQueueCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcMbsQueueCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcMbsQueueCnt.setDescription('Number of buffers sent to the PLP layer that are currently on the local assembly/deassembly queue at the PLP layer. This value is set after the PLP layer has completed processing of the maximum allowable number of packets received from the upper layer.')
wfX25VcMbsQueueCntPostTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcMbsQueueCntPostTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcMbsQueueCntPostTx.setDescription('Number of buffers sent to the PLP layer that have not yet been added to the local assembly/deassembly queue. This value is set after the PLP layer has completed transmission of the maximum allowable number of packets from the local assembly/ deassembly queue to the lower layer.')
wfX25VcTxQueueCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcTxQueueCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcTxQueueCnt.setDescription('Number of buffers sent to the PLP layer that are currently on the transmit queue at the PLP layer. This value is set after the PLP layer has completed processing of the maximum allowable number of packets received from upper layer.')
wfX25VcTxQueueCntPostTx = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 4, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25VcTxQueueCntPostTx.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25VcTxQueueCntPostTx.setDescription('Number of buffers sent to the PLP layer that are currently on thequeue to transmit at the PLP layer. This value is set after the PLP layer has completed transmission of the maximum allowable number of packets from the local assembly/deassembly queue to the lower layer.')
wfLapbPktTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5), )
if mibBuilder.loadTexts: wfLapbPktTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktTable.setDescription('The table of LAPB PKT Level Parameters')
wfLapbPktEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1), ).setIndexNames((0, "Wellfleet-X25-MIB", "wfLapbPktSlotNum"), (0, "Wellfleet-X25-MIB", "wfLapbPktConnector"), (0, "Wellfleet-X25-MIB", "wfLapbPktLineNumber"), (0, "Wellfleet-X25-MIB", "wfLapbPktLLIndex"))
if mibBuilder.loadTexts: wfLapbPktEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktEntry.setDescription('An entry in the LAPB PKT table')
wfLapbPktDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktDelete.setDescription('Create/Delete parameter. Default is created.')
wfLapbPktDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktDisable.setDescription('Enable/Disable parameter')
wfLapbPktSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktSlotNum.setDescription('Instance identifier. This is the slot number where this X.25 packet layer is running.')
wfLapbPktConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktConnector.setDescription('Instance identifier. This is the Physical connector number for the Physical layer associated with this X25 Packet layer.')
wfLapbPktLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktLineNumber.setDescription('Instance identifier. This is the line number assigned to the LAPB Driver associated with this X25 Packet Layer. Not used in 7.60')
wfLapbPktLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktLLIndex.setDescription('Instance identifier. This is the lower layer index presented to X25 by the layer immediately below it on the protocol stack. If the lower layer is a driver, the index will be 0. Not used in 7.60.')
wfLapbPktLapbCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktLapbCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktLapbCct.setDescription('Circuit number of Lapb (SYNC) driver associated with this X25 Packet Layer')
wfLapbPktLinkId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktLinkId.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktLinkId.setDescription('Access Link identifier - index into line information array.')
wfLapbPktLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("down", 2), ("init", 3), ("notpresent", 4))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktLineState.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktLineState.setDescription('Reflects the state of the X.25 packet layer that is associated with this network record. When the state of this parameter is set to Up, the router can transfer data between the line layer and the packet layer. Note that this parameter is used internally; it does NOT reflect the status of the underlying synchronous circuit.')
wfLapbPktSeqSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(8, 128))).clone(namedValues=NamedValues(("mod8", 8), ("mod128", 128))).clone('mod8')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktSeqSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktSeqSize.setDescription('Sequence numbering scheme for the data packets. Modulo 8 or Modulo 128')
wfLapbPktMaxWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktMaxWindow.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktMaxWindow.setDescription("Maximum window size that can be negotiated on a per call basis, if the flow control facility is subscribed too. Extended window size of 127 can be used if wfLapbPktSeqSize is 128. Otherwise the maximum is 7. This attribute is effective only if the attribute wfLapbPktFloCtl is set to 'ON'.")
wfLapbPktMaxLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("size16", 4), ("size32", 5), ("size64", 6), ("size128", 7), ("size256", 8), ("size512", 9), ("size1024", 10), ("size2048", 11), ("size4096", 12))).clone('size128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktMaxLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktMaxLength.setDescription("Maximum packet length that can be negotiated on a per call basis, if the flow control facility is subscribed too. This attribute is effective only if the attribute wfLapbPktFloCtl is set to 'ON'. This attribute should not be greater than the wfSYNCEntry attribute wfSyncMtu.")
wfLapbPktMaxThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("thrclass75", 3), ("thrclass150", 4), ("thrclass300", 5), ("thrclass600", 6), ("thrclass1200", 7), ("thrclass2400", 8), ("thrclass4800", 9), ("thrclass9600", 10), ("thrclass19200", 11), ("thrclass48k", 12), ("thrclass64k", 13))).clone('thrclass19200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktMaxThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktMaxThroughput.setDescription('Maximum throughput class value that can be negotiated on a per call basis, if the throughput class negotiation facility is subscribed too. For this to be effective the attribute wfLapbPktThroughput must be set to ON.')
wfLapbPktFlowCtl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktFlowCtl.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktFlowCtl.setDescription('Flow control parameter negotiation facility subscription')
wfLapbPktThroughput = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktThroughput.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktThroughput.setDescription('Throughput class negotiation facility subscription')
wfLapbPktUserIdentity = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktUserIdentity.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktUserIdentity.setDescription('Network user identification (NUI) related facility subscription')
wfLapbPktInCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktInCalls.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktInCalls.setDescription('Specifies whether or not (ON/OFF) incoming calls are permitted')
wfLapbPktOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktOutCalls.setDescription('Specifies whether or not (ON/OFF) outgoing calls are permitted')
wfLapbPktFastAccept = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktFastAccept.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktFastAccept.setDescription('Specifies whether or not (ON/OFF) fast select acceptance facility is subscribed too.')
wfLapbPktReverseAccept = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktReverseAccept.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktReverseAccept.setDescription('Specifies whether or not (ON/OFF) reverse charge aceptance facility is subscribed to. If this is set this packet layer will simply accept calls with reverse charge facility. But the packet layer (router) will not provide any charging information.')
wfLapbPktFastSelect = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktFastSelect.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktFastSelect.setDescription('Specifies whether or not (ON/OFF) fast select facility is allowed on a per call basis.')
wfLapbPktReverseCharging = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktReverseCharging.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktReverseCharging.setDescription('Specifies whether or not (ON/OFF) reverse charging facility is allowed on a per call basis.')
wfLapbPktCugSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 16, 32))).clone(namedValues=NamedValues(("off", 2), ("basic", 16), ("extended", 32))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktCugSelection.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktCugSelection.setDescription('Format of the Closed User Group (CUG) related facilities supported.')
wfLapbPktCugOA = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 64))).clone(namedValues=NamedValues(("off", 2), ("cugoa", 64))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktCugOA.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktCugOA.setDescription('Specifies whether or not CUG with Outgoing access selection facility is supported.')
wfLapbPktCugBilateral = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 128))).clone(namedValues=NamedValues(("off", 2), ("bilat", 128))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktCugBilateral.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktCugBilateral.setDescription('Specifies whether or not Bilateral Closed User Group related facility is supported. If this is set, then the wfLapbPktCugSelection should be set to EXTENDED.')
wfLapbPktRpoaSelection = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktRpoaSelection.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktRpoaSelection.setDescription('Specifies whether or not RPOA related facility is supported. Outgoing calls will not contain any RPOA facility. But if set this packet layer will simply accept calls with RPOA related facility.')
wfLapbPktChargeInform = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktChargeInform.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktChargeInform.setDescription('Specifies whether or not the charging information related facilities are supported. Outgoing calls will not contain the charge information related facility. But if set this packet layer will simply accept calls with the charge information related facility. No charging information will be collected.')
wfLapbPktTransitDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktTransitDelay.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktTransitDelay.setDescription('Transit delay indication facility. If set, accept calls with this facility.')
wfLapbPktFullAddressing = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('on')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktFullAddressing.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktFullAddressing.setDescription('If this attribute is set, the full local X121 address (calling address) is supplied in the outgoing call request and the X.25 network also expected to provide the full called address in the incoming call packet.')
wfLapbPktAccFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 255, 103))).clone(namedValues=NamedValues(("basic", 2), ("allext", 255), ("defbas", 103))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktAccFormat.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktAccFormat.setDescription('Specifies the format of the call accepted packet.')
wfLapbPktRelFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 255, 103))).clone(namedValues=NamedValues(("basic", 2), ("allext", 255), ("defext", 103))).clone('basic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktRelFormat.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktRelFormat.setDescription('Connection release format - format of Clear Requests')
wfLapbPktT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktT1.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktT1.setDescription('Local confirmation timeouts in seconds. This timer represents the following CCITT timers. If DCE: T10 (restart), T12 (reset), T13 (clear) If DTE: T20 (restart), T22 (reset), T23 (clear)')
wfLapbPktT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(180)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktT2.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktT2.setDescription('Call confirmation time out in seconds. This represent the CCITT T11 timer for the DCE and T21 timer for the DTE.')
wfLapbPktT3 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 2000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktT3.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktT3.setDescription('Congestion or busy condition watchdog timer in milliseconds. When system resources needed for packet assembly/deassembly depleted, this timer is set to reenter the PLP state machine to retry. User should use extreme caution in manipulating this timer.')
wfLapbPktT4 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(200, 2000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktT4.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktT4.setDescription('Data packet transmission watchdog timer in milliseconds. This is the delay for acknowledgement. It is used to reenter PLP state machine also. User should use extreme caution in manipulating this timer.')
wfLapbPktIwcCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktIwcCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktIwcCnt.setDescription("Number of IWC (Incoming VC's) defined on this access link.")
wfLapbPktIwcId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktIwcId.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktIwcId.setDescription("Low LCN ID for IWC (Incoming VC's) defined on this access link.")
wfLapbPktBwcCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktBwcCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktBwcCnt.setDescription("Number of BWC (Bidirectional VC's) defined on this access link.")
wfLapbPktBwcId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktBwcId.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktBwcId.setDescription("Low LCN ID for BWC (Bidirectional VC's) defined on this access link.")
wfLapbPktOwcCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktOwcCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktOwcCnt.setDescription("Number of OWC (Outgoing VC's) defined on this access link.")
wfLapbPktOwcId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktOwcId.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktOwcId.setDescription("Low LCN ID for OWC (Outgoing VC's) defined on this access link.")
wfLapbPktDefWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktDefWindow.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktDefWindow.setDescription('Non standard default transmit/receive window size.')
wfLapbPktDefLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("size16", 4), ("size32", 5), ("size64", 6), ("size128", 7), ("size256", 8), ("size512", 9), ("size1024", 10), ("size2048", 11), ("size4096", 12))).clone('size128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktDefLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktDefLength.setDescription('Non standard default transmit/receive packet size. This attribute should not be greater than the wfSyncEntry attribute wfSyncMtu.')
wfLapbPktDefClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 13)).clone(11)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktDefClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktDefClass.setDescription('Non standard default transmit/receive throughput class assignment.')
wfLapbPktDxe = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("x25dtersta", 1), ("x25dte", 2), ("x25dce", 3), ("x25dtedxe", 4))).clone('x25dtersta')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktDxe.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktDxe.setDescription('Specify type of local X25 interface and imply subsequent rules of X.25. DXE_X25DTERSTA ->DTE mode with Restart Procedure. DXE_X25DTE ->DTE mode without any restart procedure DXE_X25DCE ->DCE mode with restart procedure DXE_X25DTEDXE ->DTE/DTE environment, unassigned roles.')
wfLapbPktConformance = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(257, 258, 513, 514, 1025, 1026))).clone(namedValues=NamedValues(("dxe1980", 257), ("fsel1980", 258), ("dxe1984", 513), ("fsel1984", 514), ("dxe1988", 1025), ("fsel1988", 1026))).clone('dxe1988')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktConformance.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktConformance.setDescription('CCITT conformance recommendation used on each line.')
wfLapbPktStandard = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(16, 32, 1))).clone(namedValues=NamedValues(("stdiso", 16), ("stddod", 32), ("stdnone", 1))).clone('stdnone')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktStandard.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStandard.setDescription('Network Standard to be used on each line.')
wfLapbPktNetaddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 48), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktNetaddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktNetaddr.setDescription("This Link's Network address (X121 address).")
wfLapbPktStatistics = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("statson", 1), ("statsoff", 2))).clone('statsoff')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktStatistics.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatistics.setDescription('Gives the user the ability to Turn ON or Shut OFF statistics computation. This can be shut off for better performance on the line. Now it also provides a small packet trace function.')
wfLapbPktNetaddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("pdntype", 1), ("ddntype", 2), ("bfetype", 3))).clone('pdntype')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktNetaddrType.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktNetaddrType.setDescription('This defines whether the Network connection is to a DDN network or PDN Network. This is used to decide how the Local X121 Network address is derived. If this attribute is set to DDN the Local X121 address used in the attribute wfLapbPktNetaddr will be derived from the user supplied IP address. Otherwise the X121 address should be supplid by the user.')
wfLapbPktDDNIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 51), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktDDNIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktDDNIpAddr.setDescription('If the wfLapbPktNetaddrType is DDNTYPE or DDN_BFE this is the user supplied local IP address. The router will convert this to the corresponding X121 address and the X121 address value will be put in wfLapbPktNetaddr attribute.')
wfLapbPktPDNX121Addr = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 52), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktPDNX121Addr.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktPDNX121Addr.setDescription('If the wfLapbPktNetaddrType is PDNTYPE this is the user supplied local X.121 address. The router will put this value in wfLapbPktNetaddr attribute.')
wfLapbPktTxT5 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 53), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 8000)).clone(200)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktTxT5.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktTxT5.setDescription('Tx window size transmit delay timer')
wfLapbPktUseDfltService = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktUseDfltService.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktUseDfltService.setDescription('Indicates whether or not to use the default ddn service.')
wfLapbPktPVCCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 55), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 512))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktPVCCnt.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktPVCCnt.setDescription('Number of PVCs defined on this access link.')
wfLapbPktPVCLowLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4095)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktPVCLowLcn.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktPVCLowLcn.setDescription('Low LCN ID for PVCs defined on this access link.')
wfLapbPktClientTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 57), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 999)).clone(120)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktClientTimer.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktClientTimer.setDescription('Client application response timeout period in seconds. This timer allows for the extended delays that can occur negotiating with remote clients (e.g., IPEX or QLLC). This timer must be greater than the wfLapbPktT3 period and less than wfLapbPktT2.')
wfLapbPktPduSize = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 58), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1600, 4096)).clone(1600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktPduSize.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktPduSize.setDescription('The X.25 PDU Size for this logical channel. This PDU size represents the M_BUF_SIZE used for X.25 Fragmentation and Reassembly in the packet layer. This is the largest message size X.25 will handle from a client on a given Logical Channel. Changing this attribute enables X.25 to handle client messages up to 4096 bytes in length')
wfLapbPktTranspacCauseCodeEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktTranspacCauseCodeEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktTranspacCauseCodeEnable.setDescription('Use Transpac Cause Codes , default = disabled.')
wfLapbPktTxMbsQueueThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktTxMbsQueueThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktTxMbsQueueThreshold.setDescription('The maximum number of packets that TX mbs queue can hold. If X.25 receives more packets and TX mbs queue count reaches this maximum, it will open up another SVC connection. The default is zero and the maximum queue count is equal to wfLapbPktDefWindow + 1, which is three.')
wfLapbPktBackupDebugLvl = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("one", 1), ("debug", 4))).clone('one')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktBackupDebugLvl.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktBackupDebugLvl.setDescription('Debug level for X.25 backup messages')
wfLapbPktBackupEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 5, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfLapbPktBackupEnable.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktBackupEnable.setDescription('Backup Enable/Disable parameter')
wfLapbPktStatsTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6), )
if mibBuilder.loadTexts: wfLapbPktStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsTable.setDescription('The table of LAPB PKT Level Statistics.')
wfLapbPktStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1), ).setIndexNames((0, "Wellfleet-X25-MIB", "wfLapbPktStatsSlotNum"), (0, "Wellfleet-X25-MIB", "wfLapbPktStatsConnector"), (0, "Wellfleet-X25-MIB", "wfLapbPktStatsLineNumber"), (0, "Wellfleet-X25-MIB", "wfLapbPktStatsLLIndex"))
if mibBuilder.loadTexts: wfLapbPktStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsEntry.setDescription('Packet level statistics.')
wfLapbPktStatsSlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsSlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsSlotNum.setDescription('Slot number and instance ID for this Lapb Packet Layer Line instance.')
wfLapbPktStatsConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsConnector.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsConnector.setDescription('Port number and instance ID for this Lapb Packet Layer Line instance.')
wfLapbPktStatsLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsLineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsLineNumber.setDescription('Instance identifier member. This is the line number assigned to the driver X.25 is running over. No used in 7.60')
wfLapbPktStatsLLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsLLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsLLIndex.setDescription('Instance identifier member. This is the lower layer index presented to X25 by the layer immediately below it on the protocol stack. If the lower layer is a driver, the index will be 0. Not used in 7.60.')
wfLapbPktStatsCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsCct.setDescription('Circuit number for this instance.')
wfLapbPktStatsLineAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsLineAddress.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsLineAddress.setDescription('The local X.121 address of this line.')
wfLapbPktStatsMaxVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsMaxVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsMaxVcs.setDescription('Maximum number of Virtual Circuits allowed on this line.')
wfLapbPktStatsActiveVcs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsActiveVcs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsActiveVcs.setDescription('Number of Active Virtual Circuits on this line.')
wfLapbPktStatsActiveMax = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsActiveMax.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsActiveMax.setDescription('Highest number of active Virtual Circuits on this line.')
wfLapbPktStatsTotalConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsTotalConnections.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsTotalConnections.setDescription('Number of Total Virtual Connections performed since start up.')
wfLapbPktStatsFailedConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsFailedConnections.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsFailedConnections.setDescription('Number of unsuccessful Virtual Connections performed since start up.')
wfLapbPktStatsNormalDisconnects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsNormalDisconnects.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsNormalDisconnects.setDescription('Number of Normal Virtual Circuit Disconnections.')
wfLapbPktStatsAbnormalDisconnects = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsAbnormalDisconnects.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsAbnormalDisconnects.setDescription('Number of Abnormal Virtual Circuit Disconnections.')
wfLapbPktStatsDataTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsDataTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsDataTxs.setDescription('Number of Data Packets Transmitted on this line.')
wfLapbPktStatsInterruptTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsInterruptTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsInterruptTxs.setDescription('Number of Interrupt Packets sent.')
wfLapbPktStatsResetTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsResetTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsResetTxs.setDescription('Number of Reset Requests sent.')
wfLapbPktStatsRrTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRrTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRrTxs.setDescription('Number of Receiver Ready Packets sent.')
wfLapbPktStatsRnrTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRnrTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRnrTxs.setDescription('Number of Receiver Not Ready Packets sent.')
wfLapbPktStatsRejectTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRejectTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRejectTxs.setDescription('Number of Reject Packets sent.')
wfLapbPktStatsRestartTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRestartTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRestartTxs.setDescription('Number of Restart Packets sent.')
wfLapbPktStatsDiagTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsDiagTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsDiagTxs.setDescription('Number of Diagnostic Packets sent.')
wfLapbPktStatsSegmentTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsSegmentTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsSegmentTxs.setDescription('Number of Charge Units sent.')
wfLapbPktStatsBytesTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsBytesTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsBytesTxs.setDescription('Number of Data Bytes sent.')
wfLapbPktStatsIntBytesTxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsIntBytesTxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsIntBytesTxs.setDescription('Number of Interrupt Data Bytes sent.')
wfLapbPktStatsDataRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsDataRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsDataRxs.setDescription('Number of Data Packets received on this line.')
wfLapbPktStatsInterruptRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsInterruptRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsInterruptRxs.setDescription('Number of Interrupt Packets received.')
wfLapbPktStatsResetRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsResetRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsResetRxs.setDescription('Number of Reset Requests received.')
wfLapbPktStatsRrRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRrRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRrRxs.setDescription('Number of Receiver Ready Packets received.')
wfLapbPktStatsRnrRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRnrRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRnrRxs.setDescription('Number of Receiver Not Ready Packets received.')
wfLapbPktStatsRejectRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRejectRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRejectRxs.setDescription('Number of Reject Packets received.')
wfLapbPktStatsRestartRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsRestartRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsRestartRxs.setDescription('Number of Restart Packets received.')
wfLapbPktStatsDiagRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsDiagRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsDiagRxs.setDescription('Number of Diagnostic Packets received.')
wfLapbPktStatsSegmentRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsSegmentRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsSegmentRxs.setDescription('Number of Charge Units received.')
wfLapbPktStatsBytesRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsBytesRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsBytesRxs.setDescription('Number of Data Bytes received.')
wfLapbPktStatsIntBytesRxs = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsIntBytesRxs.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsIntBytesRxs.setDescription('Number of Interrupt Data Bytes received.')
wfLapbPktStatsOnOffSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 6, 1, 36), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfLapbPktStatsOnOffSwitch.setStatus('mandatory')
if mibBuilder.loadTexts: wfLapbPktStatsOnOffSwitch.setDescription('This tells the user if Statistics Computation is turned ON or OFF.')
wfX25PvcServiceTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7), )
if mibBuilder.loadTexts: wfX25PvcServiceTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcServiceTable.setDescription('the table of Lapb Pvc Packet level parameters')
wfX25PvcServiceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1), ).setIndexNames((0, "Wellfleet-X25-MIB", "wfX25SlotNum"), (0, "Wellfleet-X25-MIB", "wfX25Connector"), (0, "Wellfleet-X25-MIB", "wfX25LineNumber"), (0, "Wellfleet-X25-MIB", "wfX25LLIndex"), (0, "Wellfleet-X25-MIB", "wfX25PvcServiceCct"), (0, "Wellfleet-X25-MIB", "wfX25PvcServiceIndex"))
if mibBuilder.loadTexts: wfX25PvcServiceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcServiceEntry.setDescription('An entry in the LAPB PKT table')
wfX25PvcDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcDelete.setDescription('Create/Delete parameter, Default is created')
wfX25PvcDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcDisable.setDescription('Enable/Disable Parameter')
wfX25SlotNum = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25SlotNum.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25SlotNum.setDescription('Part of the Instance Identifier. This is the slot number where this X25 packet layer is running')
wfX25Connector = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25Connector.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25Connector.setDescription('Part of the Instance Identifier. This is the physical connector number for the physical layer associated with this packet layer')
wfX25LineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25LineNumber.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25LineNumber.setDescription('Part of the Instance Id. This is the line number assigned to the LAPB driver associated with the X25 Packet layer.')
wfX25LLIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25LLIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25LLIndex.setDescription('Instance identifier. This is the lower layer index presented to X25 by the layer immediately below it on the protocol stack. If the lower layer is a driver, the index will be 0. Not used in 7.60.')
wfX25PvcServiceCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25PvcServiceCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcServiceCct.setDescription('Instance Id. This is the Circuit number')
wfX25PvcServiceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25PvcServiceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcServiceIndex.setDescription('Instace Id. This is the lcn on which this pvc is running')
wfX25PvcServiceType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4, 8, 16, 32))).clone(namedValues=NamedValues(("pdntype", 1), ("ddntype", 2), ("ptoptype", 4), ("npttype", 8), ("ipextype", 16), ("qllctype", 32)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcServiceType.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcServiceType.setDescription('Type of Service for this PVC Service record')
wfX25PvcRxDefWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcRxDefWindow.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcRxDefWindow.setDescription('This is the receive window size used for setting up the pvc.')
wfX25PvcTxDefWindow = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 127)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcTxDefWindow.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcTxDefWindow.setDescription('This is the transmit window size used for setting up the pvc.')
wfX25PvcRxDefLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("size16", 4), ("size32", 5), ("size64", 6), ("size128", 7), ("size256", 8), ("size512", 9), ("size1024", 10), ("size2048", 11), ("size4096", 12))).clone('size128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcRxDefLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcRxDefLength.setDescription('This is the receive packet size.')
wfX25PvcTxDefLength = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("size16", 4), ("size32", 5), ("size64", 6), ("size128", 7), ("size256", 8), ("size512", 9), ("size1024", 10), ("size2048", 11), ("size4096", 12))).clone('size128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcTxDefLength.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcTxDefLength.setDescription('This is the trasmit packet size')
wfX25PvcRxDefClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("thrclass75", 3), ("thrclass150", 4), ("thrclass300", 5), ("thrclass600", 6), ("thrclass1200", 7), ("thrclass2400", 8), ("thrclass4800", 9), ("thrclass9600", 10), ("thrclass19200", 11), ("thrclass48k", 12), ("thrclass64k", 13))).clone('thrclass19200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcRxDefClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcRxDefClass.setDescription('This is the receive througput class value that can be used on a per pvc basis. For this to be effective, the wfX25Throughput must be set ON')
wfX25PvcTxDefClass = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 7, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13))).clone(namedValues=NamedValues(("thrclass75", 3), ("thrclass150", 4), ("thrclass300", 5), ("thrclass600", 6), ("thrclass1200", 7), ("thrclass2400", 8), ("thrclass4800", 9), ("thrclass9600", 10), ("thrclass19200", 11), ("thrclass48k", 12), ("thrclass64k", 13))).clone('thrclass19200')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25PvcTxDefClass.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25PvcTxDefClass.setDescription('This is the transmit througput class value that can be used on a per pvc basis. For this to be effective, the wfX25Throughput must be set ON')
wfX25QllcAddrMapTable = MibTable((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8), )
if mibBuilder.loadTexts: wfX25QllcAddrMapTable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapTable.setDescription('table of X.121 address to LLC Mac address mappings.')
wfX25QllcAddrMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1), ).setIndexNames((0, "Wellfleet-X25-MIB", "wfX25QllcAddrMapCct"), (0, "Wellfleet-X25-MIB", "wfX25QllcAddrMapIndex"))
if mibBuilder.loadTexts: wfX25QllcAddrMapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapEntry.setDescription('An entry in the QLLC Address Mapping table')
wfX25QllcAddrMapDelete = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("created", 1), ("deleted", 2))).clone('created')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapDelete.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapDelete.setDescription('Create/Delete parameter.')
wfX25QllcAddrMapDisable = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapDisable.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapDisable.setDescription('Enable/Disable parameter.')
wfX25QllcAddrMapState = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("notactive", 2), ("notpresent", 3))).clone('notpresent')).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25QllcAddrMapState.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapState.setDescription('The current state of the QLLC Mapping.')
wfX25QllcAddrMapCct = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25QllcAddrMapCct.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapCct.setDescription('Circuit number and instance ID member.')
wfX25QllcAddrMapIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: wfX25QllcAddrMapIndex.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapIndex.setDescription('X.25 QLLC Address Map entry record ID for this instance.')
wfX25QllcAddrMapPartnerX121 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapPartnerX121.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapPartnerX121.setDescription('The X.121 address of a X.25 device emulated by this interface.')
wfX25QllcAddrMapAdjacentX121 = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapAdjacentX121.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapAdjacentX121.setDescription('The X.121 address of a X.25 device connecting thru this interface. This address may contain wildcard characters.')
wfX25QllcAddrMapPid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)).clone(195)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapPid.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapPid.setDescription('QLLC Protocol ID used in the first byte of Call User Data of the X.25 Call Request packet.')
wfX25QllcAddrMapPartnerMac = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 9), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapPartnerMac.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapPartnerMac.setDescription('The LLC MAC address of a LLC device connecting thru this interface. The LLC MAC address may contain wildcard characters, see wfX25QllcAddrMapOptions attribute below.')
wfX25QllcAddrMapPartnerSap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapPartnerSap.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapPartnerSap.setDescription('The SAP of a LLC device connecting thru this interface.')
wfX25QllcAddrMapAdjacentMac = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 11), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapAdjacentMac.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapAdjacentMac.setDescription('The LLC MAC address of a LLC device emulated by this interface. If set to nil, a LLC MAC address will be dynamically assign by X.25 from an address pool defined in the X.25 Service Record.')
wfX25QllcAddrMapAdjacentSap = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 254)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapAdjacentSap.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapAdjacentSap.setDescription('The SAP of a LLC device emulated by this interface.')
wfX25QllcAddrMapOptions = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 13), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapOptions.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapOptions.setDescription('This object is a bitmask, setting individual bit postions enable the option. Values may be added together to enable multiple options. Hex Dec Value Value Options --------------------------------------------------------- 0x0001 1 Do not wait for Adjacent DTE/DCE to send an QXID before forwarding an QXID to it. 0x0002 2 Enable when SDLC endstations are connecting to QLLC hosts that do not support receipt of XID polls and do not retransmit XIDs. 0x0004 4 wfX25QllcAddrMapPartnerMac field contains wildcard characters.')
wfX25QllcAddrMapTrace = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 14), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapTrace.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapTrace.setDescription('This object is a bitmask, setting individual bit postions enable logging of internal QLLC messages and events. Values may be added together to enable multiple message groups. Hex Dec Value Value Message/Event --------------------------------------------------------- 0x0001 1 Enable QLLC logging. 0x0002 2 Data frames/packets. 0x0004 4 Flow Control messages. 0x0008 8 Client registration messages. 0x0010 16 X.25 session establishment messages. 0x0020 32 Test frames/packets. 0x0040 64 XID frames/packes. 0x0080 128 Set Mode frames/packets. 0x0100 256 Disconnect frames/packets. 0x0200 512 Configuration changes. 0x0400 1024 Death of client (DLSw or APPN). 0x0800 2048 Data Path (DP) messages.')
wfX25QllcAddrMapPuType = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("pu21", 1), ("pu20", 2))).clone('pu20')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapPuType.setStatus('obsolete')
if mibBuilder.loadTexts: wfX25QllcAddrMapPuType.setDescription('PU type (T2.0 or T2.1) of the locally attached QLLC device.')
wfX25QllcAddrMapGenXid = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapGenXid.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapGenXid.setDescription('Simulate receiving an XID command from the QLLC device. This object should be enabled when an PU 2.0 QLLC device is connecting thru DLSw to an non-X.25 host.')
wfX25QllcAddrMapNodeId = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 17), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapNodeId.setStatus('obsolete')
if mibBuilder.loadTexts: wfX25QllcAddrMapNodeId.setDescription('The 8 hexadecimal digit Node Identification field of the simulated XID (see wfX25QllcAddrMapGenXid object). This field has two sub-fields, ID Block and ID Number. The first 3 hexadecimal digits are the ID block value and the last 5 hexadecimal digits are the ID Number value.')
wfX25QllcAddrMapName = MibTableColumn((1, 3, 6, 1, 4, 1, 18, 3, 5, 9, 4, 8, 1, 18), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: wfX25QllcAddrMapName.setStatus('mandatory')
if mibBuilder.loadTexts: wfX25QllcAddrMapName.setDescription('A informational name for this QLLC Mapping.')
mibBuilder.exportSymbols("Wellfleet-X25-MIB", wfLapbPktFullAddressing=wfLapbPktFullAddressing, wfX25PvcServiceCct=wfX25PvcServiceCct, wfLapbPktTransitDelay=wfLapbPktTransitDelay, wfX25QllcAddrMapPartnerSap=wfX25QllcAddrMapPartnerSap, wfX25QllcAddrMapAdjacentX121=wfX25QllcAddrMapAdjacentX121, wfX25VcPktsLargerThanBurstThrCnt=wfX25VcPktsLargerThanBurstThrCnt, wfX25ServicePvcLcn=wfX25ServicePvcLcn, wfLapbPktBackupDebugLvl=wfLapbPktBackupDebugLvl, wfLapbPktStatsNormalDisconnects=wfLapbPktStatsNormalDisconnects, wfX25ServiceFlowFacility=wfX25ServiceFlowFacility, wfX25ServiceBurstThrPerVc=wfX25ServiceBurstThrPerVc, wfX25VcBytesRxs=wfX25VcBytesRxs, wfLapbPktStatsCct=wfLapbPktStatsCct, wfX25QllcAddrMapCct=wfX25QllcAddrMapCct, wfX25ServiceCct=wfX25ServiceCct, wfX25ServiceVcPriority=wfX25ServiceVcPriority, wfX25ServiceCugNum=wfX25ServiceCugNum, wfLapbPktNetaddrType=wfLapbPktNetaddrType, wfLapbPktDisable=wfLapbPktDisable, wfLapbPktStatsTotalConnections=wfLapbPktStatsTotalConnections, wfLapbPktStatsConnector=wfLapbPktStatsConnector, wfLapbPktStatsMaxVcs=wfLapbPktStatsMaxVcs, wfLapbPktFlowCtl=wfLapbPktFlowCtl, wfLapbPktFastAccept=wfLapbPktFastAccept, wfX25ServiceIndex=wfX25ServiceIndex, wfLapbPktStatsOnOffSwitch=wfLapbPktStatsOnOffSwitch, wfX25ServicePtopCallRequest=wfX25ServicePtopCallRequest, wfLapbPktCugOA=wfLapbPktCugOA, wfLapbPktOwcId=wfLapbPktOwcId, wfX25VcIntBytesRxs=wfX25VcIntBytesRxs, wfX25VcSlotNum=wfX25VcSlotNum, wfLapbPktMaxThroughput=wfLapbPktMaxThroughput, wfLapbPktLinkId=wfLapbPktLinkId, wfLapbPktStatsInterruptTxs=wfLapbPktStatsInterruptTxs, wfX25PvcServiceEntry=wfX25PvcServiceEntry, wfLapbPktTranspacCauseCodeEnable=wfLapbPktTranspacCauseCodeEnable, wfX25PvcTxDefLength=wfX25PvcTxDefLength, wfX25ServiceRemoteIpAddr=wfX25ServiceRemoteIpAddr, wfX25ServiceWindowTimeout=wfX25ServiceWindowTimeout, wfX25QllcAddrMapName=wfX25QllcAddrMapName, wfX25QllcAddrMapDisable=wfX25QllcAddrMapDisable, wfLapbPktTxT5=wfLapbPktTxT5, wfLapbPktThroughput=wfLapbPktThroughput, wfLapbPktStatsRnrRxs=wfLapbPktStatsRnrRxs, wfLapbPktReverseCharging=wfLapbPktReverseCharging, wfLapbPktTable=wfLapbPktTable, wfLapbPktLLIndex=wfLapbPktLLIndex, wfLapbPktConnector=wfLapbPktConnector, wfX25VcResetRxs=wfX25VcResetRxs, wfLapbPktDefLength=wfLapbPktDefLength, wfLapbPktStatsResetRxs=wfLapbPktStatsResetRxs, wfLapbPktStatsActiveVcs=wfLapbPktStatsActiveVcs, wfX25ServiceDelete=wfX25ServiceDelete, wfLapbPktLineNumber=wfLapbPktLineNumber, wfX25QllcAddrMapPuType=wfX25QllcAddrMapPuType, wfX25ServiceRetryNumber=wfX25ServiceRetryNumber, wfX25VcLineNumber=wfX25VcLineNumber, wfX25ServiceSlot=wfX25ServiceSlot, wfLapbPktUserIdentity=wfLapbPktUserIdentity, wfX25ServiceUserFacility=wfX25ServiceUserFacility, wfLapbPktStatsDataRxs=wfLapbPktStatsDataRxs, wfX25ServiceRevChRequest=wfX25ServiceRevChRequest, wfLapbPktT1=wfLapbPktT1, wfX25ServiceTable=wfX25ServiceTable, wfLapbPktStandard=wfLapbPktStandard, wfLapbPktStatsBytesRxs=wfLapbPktStatsBytesRxs, wfX25QllcAddrMapEntry=wfX25QllcAddrMapEntry, wfLapbPktStatsEntry=wfLapbPktStatsEntry, wfX25VcIntBytesTxs=wfX25VcIntBytesTxs, wfLapbPktStatistics=wfLapbPktStatistics, wfLapbPktStatsResetTxs=wfLapbPktStatsResetTxs, wfLapbPktIwcId=wfLapbPktIwcId, wfLapbPktStatsRestartTxs=wfLapbPktStatsRestartTxs, wfX25VcCct=wfX25VcCct, wfLapbPktPVCCnt=wfLapbPktPVCCnt, wfX25=wfX25, wfX25SlotNum=wfX25SlotNum, wfX25ServiceRevChAccept=wfX25ServiceRevChAccept, wfX25VcInterruptTxs=wfX25VcInterruptTxs, wfLapbPktCugBilateral=wfLapbPktCugBilateral, wfLapbPktAccFormat=wfLapbPktAccFormat, wfX25ServiceEntryName=wfX25ServiceEntryName, wfX25VcApPktsDropped=wfX25VcApPktsDropped, wfX25PvcDisable=wfX25PvcDisable, wfX25VcDataTxs=wfX25VcDataTxs, wfLapbPktSeqSize=wfLapbPktSeqSize, wfX25ServicePrecedence=wfX25ServicePrecedence, wfX25ServiceMUX=wfX25ServiceMUX, wfX25QllcAddrMapPid=wfX25QllcAddrMapPid, wfX25ServiceConnId=wfX25ServiceConnId, wfX25ServiceEntry=wfX25ServiceEntry, wfLapbPktStatsRrRxs=wfLapbPktStatsRrRxs, wfX25ServiceForceCugZero=wfX25ServiceForceCugZero, wfLapbPktRelFormat=wfLapbPktRelFormat, wfX25QllcAddrMapIndex=wfX25QllcAddrMapIndex, wfX25QllcAddrMapGenXid=wfX25QllcAddrMapGenXid, wfX25PvcDelete=wfX25PvcDelete, wfX25QllcAddrMapState=wfX25QllcAddrMapState, wfLapbPktStatsDiagRxs=wfLapbPktStatsDiagRxs, wfX25VcBurstQHighWaterPkts=wfX25VcBurstQHighWaterPkts, wfX25ServiceVcBurstThroughput=wfX25ServiceVcBurstThroughput, wfLapbPktT3=wfLapbPktT3, wfX25VcMbsOutstandingPostTx=wfX25VcMbsOutstandingPostTx, wfLapbPktStatsAbnormalDisconnects=wfLapbPktStatsAbnormalDisconnects, wfX25ServiceCugFormat=wfX25ServiceCugFormat, wfLapbPktT4=wfLapbPktT4, wfX25VcDataRxs=wfX25VcDataRxs, wfLapbPktRpoaSelection=wfLapbPktRpoaSelection, wfX25ServiceVcType=wfX25ServiceVcType, wfX25ServiceRemoteX121Addr=wfX25ServiceRemoteX121Addr, wfLapbPktStatsInterruptRxs=wfLapbPktStatsInterruptRxs, wfX25ServiceSetupTime=wfX25ServiceSetupTime, wfLapbPktStatsActiveMax=wfLapbPktStatsActiveMax, wfX25ServiceVcBurstQDepth=wfX25ServiceVcBurstQDepth, wfLapbPktLineState=wfLapbPktLineState, wfX25PvcRxDefLength=wfX25PvcRxDefLength, wfX25ServiceDisable=wfX25ServiceDisable, wfLapbPktTxMbsQueueThreshold=wfLapbPktTxMbsQueueThreshold, wfX25VcPktDrops=wfX25VcPktDrops, wfLapbPktConformance=wfLapbPktConformance, wfX25ServiceBackupRecoveryDelay=wfX25ServiceBackupRecoveryDelay, wfLapbPktStatsIntBytesRxs=wfLapbPktStatsIntBytesRxs, wfLapbPktBackupEnable=wfLapbPktBackupEnable, wfX25ServiceMacPoolSize=wfX25ServiceMacPoolSize, wfX25QllcAddrMapPartnerX121=wfX25QllcAddrMapPartnerX121, wfX25ServiceVcBurstQClippedPkts=wfX25ServiceVcBurstQClippedPkts, wfLapbPktDxe=wfLapbPktDxe, wfLapbPktDefWindow=wfLapbPktDefWindow, wfLapbPktStatsRejectRxs=wfLapbPktStatsRejectRxs, wfX25QllcAddrMapAdjacentSap=wfX25QllcAddrMapAdjacentSap, wfLapbPktDefClass=wfLapbPktDefClass, wfX25ServiceBCast=wfX25ServiceBCast, wfX25BackupInitiation=wfX25BackupInitiation, wfLapbPktClientTimer=wfLapbPktClientTimer, wfX25QllcAddrMapOptions=wfX25QllcAddrMapOptions, wfX25ServiceLineNumber=wfX25ServiceLineNumber, wfLapbPktStatsDataTxs=wfLapbPktStatsDataTxs, wfX25VcMbsQueueCntPostTx=wfX25VcMbsQueueCntPostTx, wfLapbPktFastSelect=wfLapbPktFastSelect, wfX25VcPlpPktDrops=wfX25VcPlpPktDrops, wfLapbPktStatsLineNumber=wfLapbPktStatsLineNumber, wfX25QllcAddrMapNodeId=wfX25QllcAddrMapNodeId, wfX25ServiceMacPoolStart=wfX25ServiceMacPoolStart, wfX25PvcTxDefClass=wfX25PvcTxDefClass, wfX25VcRrTxs=wfX25VcRrTxs, wfLapbPktMaxWindow=wfLapbPktMaxWindow, wfLapbPktOutCalls=wfLapbPktOutCalls, wfX25LLIndex=wfX25LLIndex, wfX25VcTxQueueCnt=wfX25VcTxQueueCnt, wfLapbPktDelete=wfLapbPktDelete, wfX25QllcAddrMapTrace=wfX25QllcAddrMapTrace, wfLapbPktInCalls=wfLapbPktInCalls, wfX25VcConnector=wfX25VcConnector, wfX25PvcServiceTable=wfX25PvcServiceTable, wfX25ServiceType=wfX25ServiceType, wfX25ServiceMaxIdle=wfX25ServiceMaxIdle, wfX25VcInterruptRxs=wfX25VcInterruptRxs, wfX25VcRrRxs=wfX25VcRrRxs, wfX25ServiceVcBurstQHighWaterPkts=wfX25ServiceVcBurstQHighWaterPkts, wfX25ServicePktSize=wfX25ServicePktSize, wfX25VcBurstQPktCnt=wfX25VcBurstQPktCnt, wfX25VcTxQueueCntPostTx=wfX25VcTxQueueCntPostTx, wfX25ServiceFastSelAccept=wfX25ServiceFastSelAccept, wfX25ServicePlpPktDrops=wfX25ServicePlpPktDrops, wfLapbPktPduSize=wfLapbPktPduSize, wfLapbPktBwcCnt=wfLapbPktBwcCnt, wfX25VcRnrTxs=wfX25VcRnrTxs, wfX25ServiceConnector=wfX25ServiceConnector, wfX25ServiceMaxConn=wfX25ServiceMaxConn, wfX25PvcRxDefClass=wfX25PvcRxDefClass, wfLapbPktStatsSegmentTxs=wfLapbPktStatsSegmentTxs, wfLapbPktStatsSegmentRxs=wfLapbPktStatsSegmentRxs, wfLapbPktChargeInform=wfLapbPktChargeInform, wfLapbPktSlotNum=wfLapbPktSlotNum, wfX25QllcAddrMapTable=wfX25QllcAddrMapTable, wfX25VcEntry=wfX25VcEntry, wfLapbPktStatsRestartRxs=wfLapbPktStatsRestartRxs, wfX25QllcAddrMapPartnerMac=wfX25QllcAddrMapPartnerMac, wfX25PvcServiceType=wfX25PvcServiceType, wfX25ServiceVcPktDrops=wfX25ServiceVcPktDrops, wfX25VcResetTxs=wfX25VcResetTxs, wfX25VcMbsQueueCnt=wfX25VcMbsQueueCnt, wfLapbPktReverseAccept=wfLapbPktReverseAccept, wfLapbPktDDNIpAddr=wfLapbPktDDNIpAddr, wfX25VcBytesTxs=wfX25VcBytesTxs, wfX25ServiceVcBurstQPktCnt=wfX25ServiceVcBurstQPktCnt, wfX25ServiceConnRef=wfX25ServiceConnRef, wfX25QllcAddrMapAdjacentMac=wfX25QllcAddrMapAdjacentMac, wfLapbPktStatsRrTxs=wfLapbPktStatsRrTxs, wfLapbPktStatsDiagTxs=wfLapbPktStatsDiagTxs, wfLapbPktStatsRejectTxs=wfLapbPktStatsRejectTxs, wfLapbPktMaxLength=wfLapbPktMaxLength, wfLapbPktStatsTable=wfLapbPktStatsTable, wfX25QllcAddrMapDelete=wfX25QllcAddrMapDelete, wfLapbPktPVCLowLcn=wfLapbPktPVCLowLcn, wfX25VcTable=wfX25VcTable, wfLapbPktStatsIntBytesTxs=wfLapbPktStatsIntBytesTxs, wfX25Delete=wfX25Delete, wfLapbPktStatsFailedConnections=wfLapbPktStatsFailedConnections, wfX25VcBurstQClippedPkts=wfX25VcBurstQClippedPkts, wfX25ServiceWinSize=wfX25ServiceWinSize, wfLapbPktOwcCnt=wfLapbPktOwcCnt, wfX25VcRejectRxs=wfX25VcRejectRxs, wfX25VcRemoteX121Addr=wfX25VcRemoteX121Addr, wfLapbPktPDNX121Addr=wfLapbPktPDNX121Addr, wfX25ServiceLLIndex=wfX25ServiceLLIndex, wfX25LineNumber=wfX25LineNumber, wfX25VcNumber=wfX25VcNumber, wfX25PvcTxDefWindow=wfX25PvcTxDefWindow, wfLapbPktEntry=wfLapbPktEntry, wfLapbPktLapbCct=wfLapbPktLapbCct, wfX25VcRnrRxs=wfX25VcRnrRxs, wfX25Disable=wfX25Disable, wfLapbPktStatsBytesTxs=wfLapbPktStatsBytesTxs, wfX25VcSegmentTxs=wfX25VcSegmentTxs, wfX25ServiceFastSelRequest=wfX25ServiceFastSelRequest, wfLapbPktStatsRnrTxs=wfLapbPktStatsRnrTxs, wfX25ServiceWcpEnable=wfX25ServiceWcpEnable, wfLapbPktStatsSlotNum=wfLapbPktStatsSlotNum, wfLapbPktIwcCnt=wfLapbPktIwcCnt, wfX25ServiceCallRetry=wfX25ServiceCallRetry, wfLapbPktCugSelection=wfLapbPktCugSelection, wfX25VcRejectTxs=wfX25VcRejectTxs, wfX25VcSegmentRxs=wfX25VcSegmentRxs, wfX25Connector=wfX25Connector, wfX25PvcRxDefWindow=wfX25PvcRxDefWindow, wfX25PvcServiceIndex=wfX25PvcServiceIndex, wfX25VcMbsOutstanding=wfX25VcMbsOutstanding, wfX25VcMaxTx=wfX25VcMaxTx, wfX25ServiceCugType=wfX25ServiceCugType, wfX25VcLLIndex=wfX25VcLLIndex, wfLapbPktUseDfltService=wfLapbPktUseDfltService, wfLapbPktT2=wfLapbPktT2, wfLapbPktStatsLineAddress=wfLapbPktStatsLineAddress, wfLapbPktBwcId=wfLapbPktBwcId, wfLapbPktStatsLLIndex=wfLapbPktStatsLLIndex, wfX25ServiceValid=wfX25ServiceValid, wfLapbPktNetaddr=wfLapbPktNetaddr, wfX25ServiceBFE=wfX25ServiceBFE, wfX25State=wfX25State)

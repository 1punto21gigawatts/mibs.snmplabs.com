#
# PySNMP MIB module MICROCOM-MBR-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/MICROCOM-MBR-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:12:40 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, NotificationType, ModuleIdentity, Unsigned32, iso, ObjectIdentity, IpAddress, NotificationType, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Counter64, enterprises, Counter32, MibIdentifier, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "NotificationType", "ModuleIdentity", "Unsigned32", "iso", "ObjectIdentity", "IpAddress", "NotificationType", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Counter64", "enterprises", "Counter32", "MibIdentifier", "TimeTicks")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class MacAddress(OctetString):
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(6, 6)
    fixedLength = 6

class CompRatio(Integer32):
    pass

class PortNum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 5)

class VcNum(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 15)

class StatsInterval(Integer32):
    pass

class LongTermStatsPeriod(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 6)

class StatsRawCount(Integer32):
    pass

mnpi = MibIdentifier((1, 3, 6, 1, 4, 1, 102))
mbr = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1))
mbrSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1))
mbrSysInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 1))
mbrSysSwVers = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 1))
mbrSWRev = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSWRev.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSWRev.setDescription('Major release number of the current software image')
mbrSWRel = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSWRel.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSWRel.setDescription('Minor release number of the current software image')
mbrSWTstVers = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSWTstVers.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSWTstVers.setDescription('Internal test release number of the current software image')
mbrSWSpecial = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSWSpecial.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSWSpecial.setDescription("'Customer Special' release number of the current software image")
mbrBootDate = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrBootDate.setStatus('mandatory')
if mibBuilder.loadTexts: mbrBootDate.setDescription('Date of last system boot in an opaque format. When the value is represented as a four-byte number in canonical form with byte 0 being the most significant, then the following is true: bytes 0-1: two-byte number is the year value byte 2: one-byte number is the month value byte 3: one-byte number is the day of the month')
mbrBootTime = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrBootTime.setStatus('mandatory')
if mibBuilder.loadTexts: mbrBootTime.setDescription('Hour of last system boot in an opaque format. When the value is represented as a four-byte number in canonical form with byte 0 being the most significant, then the following is true: byte 0: one-byte number is the hour (1-24) byte 1: one-byte number is the minute (0-59) byte 2: one-byte number is the second (0-59) byte 3: has no significance')
mbrConfigString = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 4))
pysmiFakeCol1000 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 4, 1) + (1000, ), Integer32())
mbrArchCfgStr = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 4, 1), OctetString()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1000"))
if mibBuilder.loadTexts: mbrArchCfgStr.setStatus('mandatory')
if mibBuilder.loadTexts: mbrArchCfgStr.setDescription('Archived (backup) config string. This corresponds to the file bridge.bak. Each instance of this object corresponds to a fixed size record that is a portion of the entire configuration string. The integer index identifies the logical record accessed in the config string.')
pysmiFakeCol1001 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 4, 2) + (1001, ), Integer32())
mbrCurCfgStr = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 4, 2), OctetString()).setMaxAccess("readwrite").setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1001"))
if mibBuilder.loadTexts: mbrCurCfgStr.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCurCfgStr.setDescription("Current config string--This config will be read and used the next time the mbr restarts. This corresponds to the file bridge.cfg. Each instance of this object corresponds to a fixed size record that is a portion of the entire configuration string. The integer index identifies the logical record accessed in the config string. After writing a new mbrCurCfgStr, use mbrCtrlCmd(8) to save the string to the MBR's disk.")
pysmiFakeCol1002 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 4, 3) + (1002, ), Integer32())
mbrRunCfgStr = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 4, 3), OctetString()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1002"))
if mibBuilder.loadTexts: mbrRunCfgStr.setStatus('mandatory')
if mibBuilder.loadTexts: mbrRunCfgStr.setDescription('Running config string--The config the mbr used when it was last started. This corresponds to the file bridge.run. Each instance of this object corresponds to a fixed size record that is a portion of the entire configuration string. The integer index identifies the logical record accessed in the config string.')
mbrSysAddress = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 5), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSysAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSysAddress.setDescription('System MAC Address. Corresponds to the MAC address of one of the LAN ports present in the MBR.')
pysmiFakeCol1003 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 6) + (1003, ), Integer32())
mbrConfigRec = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 1, 6), Counter32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1003"))
if mibBuilder.loadTexts: mbrConfigRec.setStatus('mandatory')
if mibBuilder.loadTexts: mbrConfigRec.setDescription('Number of logical configuration records in a config string (of size 400 octets). The integer index value is one of the following: 1: mbrArchCfgStr, 2: mbrCurCfgStr, 3: mbrRunCfgStr')
mbrSysCfgTbl = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 2))
mbrSysType = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 4))).clone(namedValues=NamedValues(("mbr6000", 2), ("mbr6500", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSysType.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSysType.setDescription('MBR product type')
mbrSysName = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrSysName.setReference('RFC1213, March 1991')
if mibBuilder.loadTexts: mbrSysName.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSysName.setDescription('This object is identical to sysName. It corresponds to the contents of the MBR file name.dat')
mbrSysPasswd = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 2, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrSysPasswd.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSysPasswd.setDescription('The system password. A read of this object results with a zero length string. Note that a control session is required to write this object. The maximum allowed length of this object is 32 octets')
mbrSysStats = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 3))
mbrDesigRootAddr = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 3, 1), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrDesigRootAddr.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.1')
if mibBuilder.loadTexts: mbrDesigRootAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDesigRootAddr.setDescription('The MAC address of the root of the spanning tree as determined by the Spanning Tree Protocol executing on this bridge.')
mbrDesigRootPriority = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrDesigRootPriority.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.1')
if mibBuilder.loadTexts: mbrDesigRootPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDesigRootPriority.setDescription('The priority value of the root of the spanning tree as determined by the Spanning Tree Protocol executing on this bridge')
mbrRootPathCost = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrRootPathCost.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.2')
if mibBuilder.loadTexts: mbrRootPathCost.setStatus('mandatory')
if mibBuilder.loadTexts: mbrRootPathCost.setDescription('The cost of the path to the root as seen from this bridge')
mbrRootPort = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 3, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrRootPort.setReference('P802.1d/D9, July 14, 1989: Section 4.5.3.3')
if mibBuilder.loadTexts: mbrRootPort.setStatus('mandatory')
if mibBuilder.loadTexts: mbrRootPort.setDescription('A string that describes the port number of the port which offers the lowest cost path from this bridge to the root bridge')
mbrSysControl = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 4))
mbrCtrlRequester = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlRequester.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlRequester.setDescription('A unique string submitted by a manager when attempting to establish a control session. When a control session has been established, this value is copied to mbrSessPartner. The MAC address of the requesting manager is typically used (because it is unique). This object should be included first in each set-request that attempts to modify mbrSessionFlag, and objects in the mbrSysControl group.')
mbrCtrlPasswd = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlPasswd.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlPasswd.setDescription('The password value submitted for verification when attempting to establish a control session. Verification is performed by comparing this value to mbrSysPasswd. An exact match is required for verification (and control session establishment). NULL is a valid value.')
mbrCtrlCmd = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 3), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlCmd.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlCmd.setDescription("Writing this object causes an action to be taken by the MBR. The action taken corresponds to the value submitted by the manager. Control commands consist of the following values: -verifyPassword(1): compares mbrCtrlPasswd to mbrSysPasswd. If exact match, then mbrCtrlRequester is copied to mbrSessPartner and control session is established. -systemBoot(2): initiates a system boot if control session is active. -requestDownload(3): performs a file operation on mbrDlFileName. The operation is specified by mbrCtrlParm. -clearAlarms(4): clears the MBR alarm table. -clearStats(5): resets the statistics on the MBR port corresponding to mbrCtrlPort. -updateConfig(8): This command causes mbrCurCfgStr to copied into mbrArchCfgStr and saves mbrCurCfgStr to the MBR's disk. Use this command after writing a new mbrCurCfgStr.")
mbrCtrlPort = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 4), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlPort.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlPort.setDescription('The port number value submitted by a manager to be referenced in conjunction with port-specific actions defined by mbrCtrlCmd values. This value must be set when mbrCtrlCmd is set to clearStats(6).')
mbrCtrlAddress = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 5), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlAddress.setDescription('Meaningful to SNMP/LLC-SNAP communications only.')
mbrCtrlPath = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 6), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlPath.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlPath.setDescription('Meaningful to SNMP/LLC-SNAP communications only.')
mbrCtrlParm = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 7), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlParm.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlParm.setDescription('This object qualifies the download operation requested when mbrCtrlCmd is requestDownload(3). The valid download operations are: 0: open file mbrDlFileName for reading, 1: open file mbrDlFileName for writing, 2: close file mbrDlFileName')
mbrCtrlVC = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 4, 8), Counter32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrCtrlVC.setStatus('mandatory')
if mibBuilder.loadTexts: mbrCtrlVC.setDescription('Meaningful to SNMP/LLC-SNAP communications only.')
mbrSession = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 5))
mbrSessionFlag = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrSessionFlag.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSessionFlag.setDescription('This object is true when a control session is active on this MBR. The control session partner may write a value of false to terminate the control session. The session is terminated only if mbrSessionPartner is exactly equal to mbrCtrlRequester.')
mbrSessionPartner = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 5, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(6, 6)).setFixedLength(6)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSessionPartner.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSessionPartner.setDescription('This object identifies the control session partner. It is copied from the value of mbrCtrlRequester when a control session is established.')
mbrSessionPath = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 5, 3), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrSessionPath.setStatus('mandatory')
if mibBuilder.loadTexts: mbrSessionPath.setDescription('Meaningful to SNMP/LLC-SNAP communications only.')
mbrDownload = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 6))
mbrDlFileName = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrDlFileName.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDlFileName.setDescription("The target file's path name")
mbrDlDevice = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 2), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrDlDevice.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDlDevice.setDescription('This object is obsolete')
mbrDlStatus = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrDlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDlStatus.setDescription('This object denotes the state of the current download operation as follows: 0: download complete, 3: download progressing, 4: disk error occurred')
pysmiFakeCol1004 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 4) + (1004, ), Integer32())
mbrDlReadRec = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 4), OctetString()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1004"))
if mibBuilder.loadTexts: mbrDlReadRec.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDlReadRec.setDescription('Each instance of this object corresponds to one fixed size record in the file mbrDlFileName. The integer index identifies the logical record accessed in mbrDlFileName. This object can be read only after mbrDlFileName has been opened for reading.')
pysmiFakeCol1005 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 5) + (1005, ), Integer32())
mbrDlWriteRec = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 5), OctetString()).setMaxAccess("readwrite").setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1005"))
if mibBuilder.loadTexts: mbrDlWriteRec.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDlWriteRec.setDescription('Each instance of this object corresponds to one fixed size record in the file mbrDlFileName. The integer index identifies the logical record written to in mbrDlFileName. This object can be set only after mbrDlFileName has been opened for writing. The records must be written in order. Reading this object returns an octet string of length zero')
mbrDlFileSize = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 6, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrDlFileSize.setStatus('mandatory')
if mibBuilder.loadTexts: mbrDlFileSize.setDescription('This object provides the number of records in mbrDlFileName. It is calculated by the MBR when mbrDlFileName is opened (for reading or writing). The fixed record size is 1024 octets.')
mbrAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 7))
mbrAlarmTable = MibTable((1, 3, 6, 1, 4, 1, 102, 1, 1, 7, 1), )
if mibBuilder.loadTexts: mbrAlarmTable.setStatus('mandatory')
if mibBuilder.loadTexts: mbrAlarmTable.setDescription('Information about MBR alarms')
pysmiFakeCol1006 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 7, 1, 1) + (1006, ), Integer32())
mbrAlarmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 102, 1, 1, 7, 1, 1), ).setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1006"))
if mibBuilder.loadTexts: mbrAlarmEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mbrAlarmEntry.setDescription('An entry in the MBR alarm table. The integer index corresponds to the MBR alarm code.')
mbrAlarmText = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 7, 1, 1, 7), Integer32())
if mibBuilder.loadTexts: mbrAlarmText.setStatus('mandatory')
if mibBuilder.loadTexts: mbrAlarmText.setDescription('The alarm text string that corresponds to the alarm instance represented by the current SNMP trap. Some alarm text strings contain printf-style format specifiers. The parameters that apply to the format specifiers are specified by the instances of mbrTrapInfo in the same SNMP trap.')
mbrNetReports = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 8))
mbrNetRptDestIpAddress = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 8, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mbrNetRptDestIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mbrNetRptDestIpAddress.setDescription('The IP address of a SNMP trap destination. A control session should be established before writing this object.')
mbrTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 10))
mbrTrapCode = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 10, 1), Counter32())
if mibBuilder.loadTexts: mbrTrapCode.setStatus('mandatory')
if mibBuilder.loadTexts: mbrTrapCode.setDescription('This value is the MBR alarm code. An SNMP trap containing this object represents an instance of the MBR alarm.')
mbrTrapPort = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 10, 2), Integer32())
if mibBuilder.loadTexts: mbrTrapPort.setStatus('mandatory')
if mibBuilder.loadTexts: mbrTrapPort.setDescription('This value is the MBR port that an alarm has occurred on. Alarms that do not logically correspond to a port are assigned port number 1.')
pysmiFakeCol1007 = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 1, 10, 3) + (1007, ), Integer32())
mbrTrapInfo = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 10, 3), Integer32()).setIndexNames((0, "MICROCOM-MBR-MIB", "pysmiFakeCol1007"))
if mibBuilder.loadTexts: mbrTrapInfo.setStatus('mandatory')
if mibBuilder.loadTexts: mbrTrapInfo.setDescription('One or more parameters that apply to a specific MBR alarm. The integer index identifies the position of the parameter in the printf argument list. The argument list is formed by ordering all mbrTrapInfo instances in one SNMP trap. This argument list is applied to the accompanying mbrAlarmText printf format string.')
mbrRingMgtAlarms = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 1, 11))
mbrRmAlarmStatAddr = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 11, 1), MacAddress())
if mibBuilder.loadTexts: mbrRmAlarmStatAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mbrRmAlarmStatAddr.setDescription('The MAC address of the Token Ring station that is experiencing a problem')
mbrRmAlarmNaunAddr = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 11, 2), MacAddress())
if mibBuilder.loadTexts: mbrRmAlarmNaunAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mbrRmAlarmNaunAddr.setDescription('The MAC address of the nearest active upstream neighbor (NAUN) of the Token Ring station that is experiencing a problem')
mbrRmAlarmBeaconType = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 1, 11, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("recoveryModeSet", 1), ("signalLossError", 2), ("streamSignalNotClaimToken", 3), ("streamSignalClaimToken", 4))))
if mibBuilder.loadTexts: mbrRmAlarmBeaconType.setStatus('mandatory')
if mibBuilder.loadTexts: mbrRmAlarmBeaconType.setDescription('The value of the Beacon Type subvector in the last Beacon MAC frame received')
mbrWanInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2))
mbrWifTable = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2))
mbrWifEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1))
mbrWifInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2))
mbrWifLinkState = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("disabled", 0), ("blocked", 1), ("listening", 2), ("learning", 3), ("forwarding", 4), ("blockingInit", 5), ("up", 6), ("down", 7)))).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLinkState.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLinkState.setDescription('This details the Spanning Tree Algorithm (STA) state of the port. When STA is off, the port may be either up, down, or disabled.')
mbrWifLinkDelay = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 2))
mbrWifLinkDelaySeconds = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 2, 1), Counter32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLinkDelaySeconds.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLinkDelaySeconds.setDescription('The seconds component of the round-trip link delay across the WAN port connection, including processing by the remote MBR.')
mbrWifLinkDelayMillis = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 2, 2), Counter32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLinkDelayMillis.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLinkDelayMillis.setDescription('The milliseconds component of the round-trip link delay across a WAN port connection, including processing by the remote MBR.')
mbrWifSppActiveCount = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 3), Integer32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifSppActiveCount.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifSppActiveCount.setDescription('The number of active SPP connections for this WAN port. This number is updated by the MBR only when the 3Com protocol support option is enabled for this WAN port.')
mbrWifLinkSpeed = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 4), Integer32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLinkSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLinkSpeed.setDescription('The bandwith of the port in units of 100 bps. This object is equivalent to ifSpeed/100')
mbrWifLinkChangeTime = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 5), Integer32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLinkChangeTime.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLinkChangeTime.setDescription('Hour of last system boot in an opaque format. When the value is represented as a four-byte integer in canonical form with byte 0 being the most significant, then the following is true: byte 0: one-byte integer is the hour (1-24) byte 1: one-byte integer is the minute (0-59) byte 2: one-byte integer is the second (0-59) byte 3: has no significance')
mbrWifLinkChangeDate = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 6), Integer32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLinkChangeDate.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLinkChangeDate.setDescription('Date of last system boot in an opaque format. When the value is represented as a four-byte integer in canonical form with byte 0 being the most significant, then the following is true: bytes 0-1: two-byte integer is the year value byte 2: one-byte integer is the month value byte 3: one-byte integer is the day of the month')
mbrWifLongTermStatsInterval = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 7), LongTermStatsPeriod()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLongTermStatsInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLongTermStatsInterval.setDescription('This object represents the current time interval that the MBR is using to track its long term statistics for this port.')
mbrWifCompNeg = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("compressionOff", 0), ("compressionOn", 1)))).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifCompNeg.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifCompNeg.setDescription('Negotiated compression for this port')
mbrWifLoadShareSetId = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 9), Counter32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifLoadShareSetId.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLoadShareSetId.setDescription('This object is non-zero only if this port is a member of a set of load-sharing WAN ports. All members of a single set of load-sharing WAN ports share the same mbrWifLoadShareSetId (usually the lowest port number of the set)')
mbrWifSpecificInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10))
mbrWifX25Info = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1))
mbrWifVcCount = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifVcCount.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcCount.setDescription('The number of VCs configured for this port.')
mbrWifVcInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2))
mbrWifVcCallState = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("noSwitch", 0), ("idle", 1), ("calling", 2), ("listening", 3), ("established", 4), ("disconnecting", 5), ("available", 6)))).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcCallState.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcCallState.setDescription('The call state of this VC.')
mbrWifVcDelay = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 2))
mbrWifVcDelaySeconds = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifVcDelaySeconds.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcDelaySeconds.setDescription('The seconds component of the round-trip delay across the VC, including processing by the remote MBR.')
mbrWifVcDelayMillis = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 2, 2), Integer32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcDelayMillis.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcDelayMillis.setDescription('The milliseconds component of the round-trip delay across the VC, including processing by the remote MBR.')
mbrWifVcLongTermStatsInterval = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 3), LongTermStatsPeriod()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcLongTermStatsInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcLongTermStatsInterval.setDescription('This object represents the current time interval that the MBR is using to track its long term statistics for this VC.')
mbrWifVcCompNeg = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("compressionOff", 0), ("compressionOn", 1)))).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcCompNeg.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcCompNeg.setDescription('Negotiated compression for this VC')
mbrWifVcLcn = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 5), Integer32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcLcn.setDescription('The LCN assigned to this VC')
mbrWifVcRemoteDte = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 2, 10, 1, 2, 6), DisplayString()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcRemoteDte.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcRemoteDte.setDescription('The DTE address to which this VC call is established')
mbrWifStatTable = MibTable((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3), )
if mibBuilder.loadTexts: mbrWifStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifStatTable.setDescription('Table for short and long term WAN statistics')
mbrWifStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1), ).setIndexNames((0, "MICROCOM-MBR-MIB", "StatsInterval"), (0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifStatEntry.setDescription("An entry in the WAN statistics table. The first of the two integer index values specifies the relative time interval of the statistic value. Short term stats are measured over a sliding 128-second window. Long term stats are measured over the period specified by the WAN port's mbrWifLongTermStatsInterval. The second index value specifies the MBR WAN port.")
mbrWifRcvChars = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 1), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifRcvChars.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRcvChars.setDescription('The number of octets received from this WAN port during the last stats interval.')
mbrWifXmtChars = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 2), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifXmtChars.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifXmtChars.setDescription('The number of octets transmitted from this WAN port during the last stats interval.')
mbrWifRcvFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 3), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifRcvFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRcvFrames.setDescription('The number of HDLC frames received from this WAN port during the last stats interval.')
mbrWifXmtFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 4), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifXmtFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifXmtFrames.setDescription('The number of HDLC frames transmitted out this WAN port during the last stats interval.')
mbrWifRcvBadFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 5), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifRcvBadFrames.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRcvBadFrames.setDescription('The number of HDLC frames received with error during the last stats interval.')
mbrWifXmtRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 6), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifXmtRejects.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifXmtRejects.setDescription('The number of HDLC frame rejects transmitted during the last stats interval.')
mbrWifRcvRejects = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 7), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifRcvRejects.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRcvRejects.setDescription('The number of HDLC frame rejects received during the last stats interval.')
mbrWifRexmtTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 8), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifRexmtTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRexmtTimeouts.setDescription('The number of retransmission timer timeouts occurrences during the last stats interval.')
mbrWifLanPktsDiscarded = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 9), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifLanPktsDiscarded.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifLanPktsDiscarded.setDescription('The number of LAN packets discarded due to lack of resources during the last stats interval.')
mbrWifMgmtPktsForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 10), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifMgmtPktsForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifMgmtPktsForwarded.setDescription('The number of proprietary link-management packets forwarded during the last stats interval.')
mbrWifRcvCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 11), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifRcvCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRcvCompRatio.setDescription('The current ratio of raw octets to compressed octets received for this WAN connection. The index indicates the MBR port number.')
mbrWifXmtCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 12), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifXmtCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifXmtCompRatio.setDescription('The current ratio of raw octets to compressed octets transmitted for this WAN connection. The index indicates the MBR port number.')
mbrWifRminCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 13), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifRminCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRminCompRatio.setDescription('The lowest ratio of raw octets to compressed octets received for this WAN connection. The index indicates the MBR port number.')
mbrWifXminCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 14), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifXminCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifXminCompRatio.setDescription('The lowest ratio of raw octets to compressed octets transmitted for this WAN connection. The index indicates the MBR port number.')
mbrWifRmaxCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 15), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifRmaxCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifRmaxCompRatio.setDescription('The highest ratio of raw octets to compressed octets received for this WAN connection. The index indicates the MBR port number.')
mbrWifXmaxCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 1, 16), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrWifXmaxCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifXmaxCompRatio.setDescription('The highest ratio of raw octets to compressed octets transmitted for this WAN connection. The index indicates the MBR port number.')
mbrWifVcStatTable = MibTable((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2), )
if mibBuilder.loadTexts: mbrWifVcStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcStatTable.setDescription('Table for short and long term VC statistics')
mbrWifVcStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1), ).setIndexNames((0, "MICROCOM-MBR-MIB", "StatInterval"), (0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcStatEntry.setDescription("An entry in the VC statistics table. The first of the three integer index values specifies the relative time interval of the statisitics value. Short term stats are measured over a sliding 128-second window. Long term stats are measured over the period specified by the VC's mbrWifVcLongTermStatsInterval. The second index value specifies the MBR X.25 WAN port. The third index value specifies the VC number.")
mbrWifVcRcvChars = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 1), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifVcRcvChars.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcRcvChars.setDescription('The number of octets received from this VC during the last stats interval.')
mbrWifVcXmtChars = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 2), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifVcXmtChars.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcXmtChars.setDescription('The number of octets transmitted on this VC during the last stats interval.')
mbrWifVcRcvX25Pkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 3), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifVcRcvX25Pkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcRcvX25Pkts.setDescription('The number of X.25 packets received from this VC during the last stats interval.')
mbrWifVcXmtX25Pkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 4), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrWifVcXmtX25Pkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcXmtX25Pkts.setDescription('The number of X.25 packets transmitted on this VC during the last stats interval.')
mbrWifVcRcvCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 5), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcRcvCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcRcvCompRatio.setDescription('The current ratio of raw octets to compressed octets received for this VC. The index values indicate the MBR port number and VC number, respectively.')
mbrWifVcXmtCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 6), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcXmtCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcXmtCompRatio.setDescription('The current ratio of raw octets to compressed octets transmitted for this VC. The index values indicate the MBR port number and VC number, respectively.')
mbrWifVcRminCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 7), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcRminCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcRminCompRatio.setDescription('The lowest ratio of raw octets to compressed octets received for this VC. The index values indicate the MBR port number and VC number, respectively.')
mbrWifVcXminCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 8), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcXminCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcXminCompRatio.setDescription('The lowest ratio of raw octets to compressed octets transmitted for this VC. The index values indicate the MBR port number and VC number, respectively.')
mbrWifVcRmaxCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 9), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcRmaxCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcRmaxCompRatio.setDescription('The highest ratio of raw octets to compressed octets received for this VC. The index values indicate the MBR port number and VC number, respectively.')
mbrWifVcXmaxCompRatio = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 2, 2, 1, 3, 2, 1, 10), CompRatio()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"), (0, "MICROCOM-MBR-MIB", "VcNum"))
if mibBuilder.loadTexts: mbrWifVcXmaxCompRatio.setStatus('mandatory')
if mibBuilder.loadTexts: mbrWifVcXmaxCompRatio.setDescription('The highest ratio of raw octets to compressed octets transmitted for this VC. The index values indicate the MBR port number and VC number, respectively.')
mbrLanInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 3))
mbrLifTable = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 3, 2))
mbrLifEntry = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1))
mbrLifInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 2))
mbrLifState = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 2, 1), Counter32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrLifState.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifState.setDescription('This object represents the Spanning Tree Algorithm (STA) state of the port. The values are enumerated for the object mbrWifLinkState. When STA is off, the port may be one of up, down, or disabled. The integer index value indicates the MBR port.')
mbrLifMacAddress = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 2, 2), MacAddress()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrLifMacAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifMacAddress.setDescription('The MAC address of the LAN card corresponding to this port. The integer index value indicates the MBR port.')
mbrLifHardwareRev = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 2, 3), Counter32()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrLifHardwareRev.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifHardwareRev.setDescription('The hardware revision level of the LAN card correspond- ing to this port. The integer index value indicates the MBR port.')
mbrLifLongTermStatsInterval = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 2, 4), LongTermStatsPeriod()).setMaxAccess("readonly").setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrLifLongTermStatsInterval.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifLongTermStatsInterval.setDescription('This object represents the current time interval that the MBR is using to track its long term statistics for this port.')
mbrLifRingNumber = MibScalar((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 2, 5), Integer32()).setIndexNames((0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrLifRingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifRingNumber.setDescription('The ring number assigned to the 802.5 LAN that this port is connected to. This object is available in SNMP traps only.')
mbrLifStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3))
mbrLifStatTable = MibTable((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1), )
if mibBuilder.loadTexts: mbrLifStatTable.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifStatTable.setDescription('Table for short and long term LAN statistics')
mbrLifStatEntry = MibTableRow((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1), ).setIndexNames((0, "MICROCOM-MBR-MIB", "StatsInterval"), (0, "MICROCOM-MBR-MIB", "PortNum"))
if mibBuilder.loadTexts: mbrLifStatEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifStatEntry.setDescription("An entry in the LAN statistics table. The first of the two integer index values specifies the relative time interval of the statistic value. Short term stats are measured over a sliding 128-second window. Long term stats are measured over the period specified by the LAN port's mbrLifLongTermStatsInterval. The second value specifies the MBR LAN port.")
mbrLifRcvPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1, 1), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrLifRcvPkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifRcvPkts.setDescription('The number of packets received from this WAN port during the last stats interval.')
mbrLifFwdPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1, 2), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrLifFwdPkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifFwdPkts.setDescription('The number of packets transmitted from this LAN port during the last stats interval.')
mbrLifRcvMcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1, 3), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrLifRcvMcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifRcvMcastPkts.setDescription('The number of multicast packets received from this LAN port during the last stats interval.')
mbrLifFwdMcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1, 4), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrLifFwdMcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifFwdMcastPkts.setDescription('The number of multicast packets forwarded to other ports during the last stats interval.')
mbrLifRcvErrPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1, 5), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrLifRcvErrPkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifRcvErrPkts.setDescription('The number of packets received with error during the last stats interval.')
mbrLifNobufDiscPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1, 6), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrLifNobufDiscPkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifNobufDiscPkts.setDescription('The number of received packets discarded due to lack of resources during the last stats interval.')
mbrLifXmtPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 102, 1, 3, 2, 1, 3, 1, 1, 7), StatsRawCount()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mbrLifXmtPkts.setStatus('mandatory')
if mibBuilder.loadTexts: mbrLifXmtPkts.setDescription('The number of packets transmitted during the last stats interval.')
mibBuilder.exportSymbols("MICROCOM-MBR-MIB", mbrDesigRootAddr=mbrDesigRootAddr, LongTermStatsPeriod=LongTermStatsPeriod, mbrLanInterfaces=mbrLanInterfaces, mbrSWRel=mbrSWRel, mbrWifVcRemoteDte=mbrWifVcRemoteDte, mbrWifRcvRejects=mbrWifRcvRejects, mbrSessionPath=mbrSessionPath, mbrSWRev=mbrSWRev, mbrWifStatTable=mbrWifStatTable, mbrWifXminCompRatio=mbrWifXminCompRatio, mbrWifXmtCompRatio=mbrWifXmtCompRatio, StatsInterval=StatsInterval, mbrWifVcXmtChars=mbrWifVcXmtChars, mbrAlarmEntry=mbrAlarmEntry, mbrLifRcvErrPkts=mbrLifRcvErrPkts, mbrRootPort=mbrRootPort, mbrWifLinkChangeDate=mbrWifLinkChangeDate, mbrWifVcXmtCompRatio=mbrWifVcXmtCompRatio, mbrWifEntry=mbrWifEntry, mbrCtrlPasswd=mbrCtrlPasswd, mbrWifLinkDelay=mbrWifLinkDelay, mbrWifLinkDelaySeconds=mbrWifLinkDelaySeconds, pysmiFakeCol1006=pysmiFakeCol1006, mbrWifVcRminCompRatio=mbrWifVcRminCompRatio, mbrWifLinkDelayMillis=mbrWifLinkDelayMillis, mbrWifX25Info=mbrWifX25Info, mbrLifLongTermStatsInterval=mbrLifLongTermStatsInterval, pysmiFakeCol1007=pysmiFakeCol1007, mbr=mbr, mbrTrapCode=mbrTrapCode, mbrNetRptDestIpAddress=mbrNetRptDestIpAddress, mbrWifRexmtTimeouts=mbrWifRexmtTimeouts, mbrLifRcvMcastPkts=mbrLifRcvMcastPkts, mbrWifInfo=mbrWifInfo, pysmiFakeCol1003=pysmiFakeCol1003, mbrLifHardwareRev=mbrLifHardwareRev, mbrSysControl=mbrSysControl, mbrCtrlPort=mbrCtrlPort, mbrRmAlarmStatAddr=mbrRmAlarmStatAddr, mbrWifVcXminCompRatio=mbrWifVcXminCompRatio, mnpi=mnpi, mbrLifStatEntry=mbrLifStatEntry, mbrLifState=mbrLifState, mbrLifStatistics=mbrLifStatistics, PortNum=PortNum, mbrWifRmaxCompRatio=mbrWifRmaxCompRatio, mbrDesigRootPriority=mbrDesigRootPriority, mbrSession=mbrSession, mbrWifVcLongTermStatsInterval=mbrWifVcLongTermStatsInterval, mbrWifLoadShareSetId=mbrWifLoadShareSetId, mbrWifXmaxCompRatio=mbrWifXmaxCompRatio, pysmiFakeCol1005=pysmiFakeCol1005, mbrLifXmtPkts=mbrLifXmtPkts, mbrSysSwVers=mbrSysSwVers, mbrWifLinkChangeTime=mbrWifLinkChangeTime, pysmiFakeCol1004=pysmiFakeCol1004, mbrDlDevice=mbrDlDevice, mbrBootTime=mbrBootTime, mbrTraps=mbrTraps, mbrWifVcDelay=mbrWifVcDelay, mbrCurCfgStr=mbrCurCfgStr, mbrWifVcCallState=mbrWifVcCallState, mbrLifRingNumber=mbrLifRingNumber, mbrWifVcXmtX25Pkts=mbrWifVcXmtX25Pkts, mbrConfigRec=mbrConfigRec, mbrWifVcDelayMillis=mbrWifVcDelayMillis, mbrRootPathCost=mbrRootPathCost, mbrWifVcCount=mbrWifVcCount, mbrWifVcXmaxCompRatio=mbrWifVcXmaxCompRatio, mbrWifRcvBadFrames=mbrWifRcvBadFrames, mbrWifVcRcvCompRatio=mbrWifVcRcvCompRatio, CompRatio=CompRatio, mbrSWTstVers=mbrSWTstVers, mbrDlReadRec=mbrDlReadRec, mbrRmAlarmNaunAddr=mbrRmAlarmNaunAddr, mbrRunCfgStr=mbrRunCfgStr, mbrWifSppActiveCount=mbrWifSppActiveCount, mbrSysAddress=mbrSysAddress, mbrLifFwdMcastPkts=mbrLifFwdMcastPkts, mbrWifStatEntry=mbrWifStatEntry, mbrWifXmtFrames=mbrWifXmtFrames, mbrWifLinkSpeed=mbrWifLinkSpeed, mbrAlarmText=mbrAlarmText, mbrLifEntry=mbrLifEntry, mbrCtrlParm=mbrCtrlParm, mbrNetReports=mbrNetReports, mbrLifTable=mbrLifTable, mbrWifVcRcvChars=mbrWifVcRcvChars, mbrLifNobufDiscPkts=mbrLifNobufDiscPkts, mbrAlarms=mbrAlarms, mbrTrapInfo=mbrTrapInfo, mbrWifVcInfo=mbrWifVcInfo, mbrConfigString=mbrConfigString, mbrCtrlAddress=mbrCtrlAddress, mbrWifRcvChars=mbrWifRcvChars, mbrRingMgtAlarms=mbrRingMgtAlarms, mbrSysInfo=mbrSysInfo, mbrSessionFlag=mbrSessionFlag, mbrWifLinkState=mbrWifLinkState, mbrWifSpecificInfo=mbrWifSpecificInfo, mbrWifVcRcvX25Pkts=mbrWifVcRcvX25Pkts, mbrDlWriteRec=mbrDlWriteRec, StatsRawCount=StatsRawCount, mbrSysName=mbrSysName, mbrDlFileName=mbrDlFileName, mbrCtrlCmd=mbrCtrlCmd, mbrLifInfo=mbrLifInfo, mbrWifLongTermStatsInterval=mbrWifLongTermStatsInterval, mbrRmAlarmBeaconType=mbrRmAlarmBeaconType, mbrWifRminCompRatio=mbrWifRminCompRatio, mbrWifMgmtPktsForwarded=mbrWifMgmtPktsForwarded, mbrDlStatus=mbrDlStatus, mbrSystem=mbrSystem, mbrWifVcCompNeg=mbrWifVcCompNeg, mbrSessionPartner=mbrSessionPartner, mbrWifVcLcn=mbrWifVcLcn, mbrWifRcvCompRatio=mbrWifRcvCompRatio, mbrWanInterfaces=mbrWanInterfaces, mbrDlFileSize=mbrDlFileSize, mbrBootDate=mbrBootDate, mbrSysPasswd=mbrSysPasswd, mbrWifCompNeg=mbrWifCompNeg, mbrDownload=mbrDownload, mbrCtrlVC=mbrCtrlVC, mbrCtrlPath=mbrCtrlPath, mbrWifLanPktsDiscarded=mbrWifLanPktsDiscarded, mbrCtrlRequester=mbrCtrlRequester, pysmiFakeCol1002=pysmiFakeCol1002, mbrArchCfgStr=mbrArchCfgStr, mbrWifVcDelaySeconds=mbrWifVcDelaySeconds, pysmiFakeCol1001=pysmiFakeCol1001, pysmiFakeCol1000=pysmiFakeCol1000, mbrAlarmTable=mbrAlarmTable, mbrLifStatTable=mbrLifStatTable, mbrWifVcStatTable=mbrWifVcStatTable, mbrWifXmtRejects=mbrWifXmtRejects, mbrWifVcStatEntry=mbrWifVcStatEntry, MacAddress=MacAddress, mbrSysStats=mbrSysStats, mbrSWSpecial=mbrSWSpecial, mbrSysCfgTbl=mbrSysCfgTbl, mbrWifRcvFrames=mbrWifRcvFrames, mbrLifMacAddress=mbrLifMacAddress, mbrLifRcvPkts=mbrLifRcvPkts, mbrWifXmtChars=mbrWifXmtChars, mbrTrapPort=mbrTrapPort, mbrWifTable=mbrWifTable, mbrLifFwdPkts=mbrLifFwdPkts, mbrWifVcRmaxCompRatio=mbrWifVcRmaxCompRatio, mbrSysType=mbrSysType, VcNum=VcNum)

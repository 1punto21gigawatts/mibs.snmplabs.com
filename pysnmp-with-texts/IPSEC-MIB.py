#
# PySNMP MIB module IPSEC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IPSEC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:56:28 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, Counter64, TimeTicks, Integer32, Gauge32, ObjectIdentity, IpAddress, NotificationType, Unsigned32, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Bits, experimental, MibIdentifier, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "Counter64", "TimeTicks", "Integer32", "Gauge32", "ObjectIdentity", "IpAddress", "NotificationType", "Unsigned32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Bits", "experimental", "MibIdentifier", "Counter32")
DateAndTime, DisplayString, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "DisplayString", "TruthValue", "TextualConvention")
ipsecMIB = ModuleIdentity((1, 3, 6, 1, 3, 500))
ipsecMIB.setRevisions(('1999-01-25 12:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ipsecMIB.setRevisionsDescriptions(('Initial revision.',))
if mibBuilder.loadTexts: ipsecMIB.setLastUpdated('9901251200Z')
if mibBuilder.loadTexts: ipsecMIB.setOrganization('IETF IPSec Working Group')
if mibBuilder.loadTexts: ipsecMIB.setContactInfo(' Tim Jenkins TimeStep Corporation 362 Terry Fox Drive Kanata, ON K0A 2H0 Canada 613-599-3610 tjenkins@timestep.com')
if mibBuilder.loadTexts: ipsecMIB.setDescription('The MIB module to describe generic IPSec objects, and entity level IPSec objects and events.')
ipsecMIBObjects = MibIdentifier((1, 3, 6, 1, 3, 500, 1))
ipsec = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1))
ipsecProtSuiteTable = MibTable((1, 3, 6, 1, 3, 500, 1, 1, 1), )
if mibBuilder.loadTexts: ipsecProtSuiteTable.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteTable.setDescription('The (conceptual) table containing information on IPSec protection suites.')
ipsecProtSuiteEntry = MibTableRow((1, 3, 6, 1, 3, 500, 1, 1, 1, 1), ).setIndexNames((0, "IPSEC-MIB", "ipsecProtSuiteIndex"))
if mibBuilder.loadTexts: ipsecProtSuiteEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteEntry.setDescription('An entry (conceptual row) containing the information on a particular IPSec protection suite.')
ipsecProtSuiteIndex = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteIndex.setDescription('A unique value, greater than zero, for each IPSec protection suite. It is recommended that values are assigned contiguously starting from 1.')
ipsecProtSuiteLocalAddress = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteLocalAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteLocalAddress.setDescription('The local IP address used by the protection suite. The size of this object is 4 if the address is an IPv4 address, or 16 if the address is an IPv6 address.')
ipsecProtSuiteRemoteAddress = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteRemoteAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteRemoteAddress.setDescription('The peer IP address used by the protection suite. The size of this object is 4 if the address is an IPv4 address, or 16 if the address is an IPv6 address.')
ipsecProtSuiteInboundEspSpi = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteInboundEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteInboundEspSpi.setDescription('The value of the SPI for the inbound protection suite that provides the ESP security service, or zero if ESP is not used.')
ipsecProtSuiteOutboundEspSpi = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteOutboundEspSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteOutboundEspSpi.setDescription('The value of the SPI for the outbound protection suite that provides the ESP security service, or zero if ESP is not used.')
ipsecProtSuiteInboundAhSpi = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteInboundAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteInboundAhSpi.setDescription('The value of the SPI for the inbound protection suite that provides the AH security service, or zero if AH is not used.')
ipsecProtSuiteOutboundAhSpi = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteOutboundAhSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteOutboundAhSpi.setDescription('The value of the SPI for the outbound protection suite that provides the AH security service, or zero if AH is not used.')
ipsecProtSuiteInboundCompCpi = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteInboundCompCpi.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteInboundCompCpi.setDescription('The value of the CPI for the inbound protection suite that provides IP compression, or zero if IPCOMP is not used.')
ipsecProtSuiteOutboundCompCpi = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteOutboundCompCpi.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteOutboundCompCpi.setDescription('The value of the CPI for the outbound protection suite that provides IP compression, or zero if IPCOMP is not used.')
ipsecProtSuiteLocalId = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteLocalId.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteLocalId.setDescription('The local identifier of the protection suite, or 0 if unknown or if the protection suite uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchange during phase 2 negotiations.')
ipsecProtSuiteLocalIdType = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 11), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteLocalIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteLocalIdType.setDescription("The type of identifier presented by 'ipsecTunnelLocalId', or 0 if unknown or if the protection suite uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchange during phase 2 negotiations.")
ipsecProtSuiteRemoteId = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 12), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteRemoteId.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteRemoteId.setDescription('The remote identifier of the protection suite, or 0 if unknown or if the protection suite uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchange during phase 2 negotiations.')
ipsecProtSuiteRemoteIdType = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 13), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteRemoteIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteRemoteIdType.setDescription("The type of identifier presented by 'ipsecTunnelRemoteId', or 0 if unknown or if the protection suite uses transport mode encapsulation. This value is taken directly from the optional ID payloads that are exchange during phase 2 negotiations.")
ipsecProtSuiteProtocol = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteProtocol.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteProtocol.setDescription('The IP protocol number that this protection suite carries, or 0 if it carries any protocol.')
ipsecProtSuiteLocalPort = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteLocalPort.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteLocalPort.setDescription('The local UDP or TCP port number that this protection suite carries, or 0 if it carries any port number.')
ipsecProtSuiteRemotePort = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteRemotePort.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteRemotePort.setDescription('The remote UDP or TCP port number that this protection suite carries, or 0 if it carries any port number.')
ipsecProtSuiteDifHelGroupDesc = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteDifHelGroupDesc.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteDifHelGroupDesc.setDescription('A unique value representing the Diffie-Hellman group description used to set up this protection suite, or 0 if the description is unknown. Specific values are used as described in the ISAKMP Class Values of Group Description from Appendix A of [IKE].')
ipsecProtSuiteDifHelGroupType = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteDifHelGroupType.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteDifHelGroupType.setDescription('A unique value representing the Diffie-Hellman group type used to set up this protection suite, or 0 if the type is unknown. Specific values are used as described in the ISAKMP Class Values of Group Type from Appendix A of [IKE].')
ipsecProtSuitePFS = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 19), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuitePFS.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuitePFS.setDescription("'true' if the protection suite was created using perfect forward secrect.")
ipsecProtSuiteEncapsulation = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("transport", 1), ("tunnel", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteEncapsulation.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteEncapsulation.setDescription('The type of encapsulation used by this protection suite.')
ipsecProtSuiteEspEncAlg = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteEspEncAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteEspEncAlg.setDescription('A unique value representing the encryption algorithm applied to traffic carried by this protection suite if it uses ESP or 0 if there is no encryption applied by ESP or if ESP is not used. Specific values are taken from section 4.4.4 of [IPDOI].')
ipsecProtSuiteEspEncKeyLength = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 22), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteEspEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteEspEncKeyLength.setDescription("The length of the encryption key in bits used for the algorithm specified in the 'ipsecTunnelEspEncAlg' object, or 0 if the key length is implicit in the specified algorithm or there is no encryption specified.")
ipsecProtSuiteEspAuthAlg = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteEspAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteEspAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this protection suite if it uses ESP or 0 if there is no authentication applied by ESP or if ESP is not used. Specific values are taken from the Authentication Algorithm attribute values of Section 4.5 of [IPDOI].')
ipsecProtSuiteAhAuthAlg = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteAhAuthAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteAhAuthAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this protection suite if it uses AH or 0 if AH is not used. Specific values are taken from Section 4.4.3 of [IPDOI].')
ipsecProtSuiteCompAlg = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteCompAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteCompAlg.setDescription('A unique value representing the compression algorithm applied to traffic carried by this protection suite if it uses IPCOMP. Specific values are taken from Section 4.4.5 of [IPDOI].')
ipsecProtSuiteCreationTime = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 26), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteCreationTime.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteCreationTime.setDescription('The date and time that the current protection suite was set up.')
ipsecProtSuiteTimeLimit = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 27), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteTimeLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteTimeLimit.setDescription('The maximum lifetime in seconds of the protection suite, or 0 if there is no time constraint on its expiration.')
ipsecProtSuiteTrafficLimit = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 28), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setUnits('1024-byte blocks').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteTrafficLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteTrafficLimit.setDescription('The maximum traffic in 1024-byte blocks that the protection suite is allowed to support, or 0 if there is no traffic constraint on its expiration.')
ipsecProtSuiteInTrafficCount = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 29), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setUnits('1024-byte blocks').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteInTrafficCount.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteInTrafficCount.setDescription("The amount of inbound traffic accumulated that counts against the protection suite's expiration by traffic limitation, measured in 1024-byte blocks. This value may be 0 if the protection suite does not expire based on traffic. In the case of multiple SAs within a protection suite, this value is the maximum of any traffic accumulation values applied to any of the individual SAs within the protection suite.")
ipsecProtSuiteOutTrafficCount = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 30), OctetString().subtype(subtypeSpec=ValueSizeConstraint(4, 255))).setUnits('1024-byte blocks').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteOutTrafficCount.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteOutTrafficCount.setDescription("The amount of outbound traffic accumulated that counts against the protection suite's expiration by traffic limitation, measured in 1024-byte blocks. This value may be 0 if the protection suite does not expire based on traffic. In the case of multiple SAs within a protection suite, this value is the maximum of any traffic accumulation values applied to any of the individual SAs within the protection suite.")
ipsecProtSuiteInboundTraffic = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 31), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteInboundTraffic.setDescription('The amount of user level traffic measured in bytes handled by the protection suite in the inbound direction. This is not necessarily the same as the amount of traffic applied against the traffic expiration limit.')
ipsecProtSuiteOutboundTraffic = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 32), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteOutboundTraffic.setDescription('The amount of user level traffic measured in bytes handled by the protection suite in the outbound direction. This is not necessarily the same as the amount of traffic applied against the traffic expiration limit.')
ipsecProtSuiteInboundPackets = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 33), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteInboundPackets.setDescription('The number of packets handled by the protection suite in the inbound direction.')
ipsecProtSuiteOutboundPackets = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 34), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteOutboundPackets.setDescription('The number of packets handled by the protection suite in the outbound direction.')
ipsecProtSuiteDecryptErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteDecryptErrors.setDescription('The number of inbound packets discarded by the protection suite due to decryption errors.')
ipsecProtSuiteAuthErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteAuthErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteAuthErrors.setDescription('The number of inbound packets discarded by the protection suite due to authentication errors. This includes hash failures in both ESP and AH.')
ipsecProtSuiteReplayErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteReplayErrors.setDescription('The number of inbound packets discarded by the protection suite due to replay errors. This includes replay failures both ESP and AH.')
ipsecProtSuitePolicyErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuitePolicyErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuitePolicyErrors.setDescription('The number of inbound packets discarded by the protection suite due to policy errors.')
ipsecProtSuiteOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteOtherReceiveErrors.setDescription('The number of inbound packets discarded by the protection suite due to errors other than decryption, authentication or replay errors. This may include decompression errors or errors due to a lack of receive buffers.')
ipsecProtSuiteSendErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 1, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecProtSuiteSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecProtSuiteSendErrors.setDescription('The number of outbound packets discarded by the protection suite due to any error. This may include compression errors or errors due to a lack of transmit buffers.')
ipsecIkeSaTable = MibTable((1, 3, 6, 1, 3, 500, 1, 1, 2), )
if mibBuilder.loadTexts: ipsecIkeSaTable.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTable.setDescription("The (conceptual) table containing information on IPSec's IKE SAs.")
ipsecIkeSaEntry = MibTableRow((1, 3, 6, 1, 3, 500, 1, 1, 2, 1), ).setIndexNames((0, "IPSEC-MIB", "ipsecIkeSaIndex"))
if mibBuilder.loadTexts: ipsecIkeSaEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaEntry.setDescription('An entry (conceptual row) containing the information on a particular IKE SA.')
ipsecIkeSaIndex = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaIndex.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaIndex.setDescription("A unique value, greater than zero, for each phase 1 SA. It is recommended that values are assigned contiguously starting from 1. The value for each entry must remain constant at least from one re-initialization of entity's network management system to the next re-initialization.")
ipsecIkeSaInitiatorCookie = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaInitiatorCookie.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaInitiatorCookie.setDescription('The value of the cookie used by the initiator for the phase 1 SA.')
ipsecIkeSaResponderCookie = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaResponderCookie.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaResponderCookie.setDescription('The value of the cookie used by the responder for the phase 1 SA.')
ipsecIkeSaLocalIpAddress = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 4), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaLocalIpAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaLocalIpAddress.setDescription('The local IP address used to negotiated the SA. The size of the object is 4 if the address is an IPv4 address and 16 if an IPv6 address.')
ipsecIkeSaLocalPortNumber = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaLocalPortNumber.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaLocalPortNumber.setDescription('The local UDP port number that this SA was negotiated with.')
ipsecIkeSaLocalIdType = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaLocalIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaLocalIdType.setDescription('The type of ID used by the local end of this SA. Specific values are used as described in Section 4.6.2.1 of [IPDOI].')
ipsecIkeSaLocalId = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaLocalId.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaLocalId.setDescription('The ID of the local host that negotiated this SA. The length may require truncation under some conditions.')
ipsecIkeSaPeerIpAddress = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 10), OctetString().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(4, 4), ValueSizeConstraint(16, 16), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerIpAddress.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerIpAddress.setDescription('The IP address of the peer that this SA was negotiated with. The size of the object is 4 if the address is an IPv4 address and 16 if it is an IPv6 address.')
ipsecIkeSaPeerPortNumber = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerPortNumber.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerPortNumber.setDescription('The UDP port number of the peer that this SA was negotiated with.')
ipsecIkeSaAuthMethod = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaAuthMethod.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaAuthMethod.setDescription('The authentication method used to authenticate the peer. Note that this does not include the specific method of authentication if extended authenticated is used. Specific values are used as described in the ISAKMP Class Values of Authentication Method from Appendix A of [IKE].')
ipsecIkeSaPeerIdType = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerIdType.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerIdType.setDescription('The type of ID used by the peer. Specific values are used as described in Section 4.6.2.1 of [IPDOI].')
ipsecIkeSaPeerId = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 14), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerId.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerId.setDescription('The ID of the peer this SA was negotiated with. The length may require truncation under some conditions.')
ipsecIkeSaPeerCertSerialNum = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 15), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerCertSerialNum.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerCertSerialNum.setDescription('The serial number of the certificate of the peer this SA was negotiated with. This object has no meaning if a certificate was not used in authenticating the peer.')
ipsecIkeSaPeerCertIssuer = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 16), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 511))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPeerCertIssuer.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPeerCertIssuer.setDescription('The issuer of the certificate of the peer this SA was negotiated with. This object has no meaning if a certificate was not used in authenticating the peer.')
ipsecIkeSaEncAlg = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaEncAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaEncAlg.setDescription('A unique value representing the encryption algorithm applied to traffic carried by this SA. Specific values are used as described in the ISAKMP Class Values of Encryption Algorithms from Appendix A of [IKE].')
ipsecIkeSaEncKeyLength = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaEncKeyLength.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaEncKeyLength.setDescription('The length of the encryption key in bits used for algorithm specified in the ipsecIkeSaEncAlg object or 0 if the key length is implicit in the specified algorithm.')
ipsecIkeSaHashAlg = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaHashAlg.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaHashAlg.setDescription('A unique value representing the hash algorithm applied to traffic carried by this SA. Specific values are used as described in the ISAKMP Class Values of Hash Algorithms from Appendix A of [IKE].')
ipsecIkeSaDifHelGroupDesc = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupDesc.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupDesc.setDescription('A unique value representing the Diffie-Hellman group description used or 0 if the group is unknown. Specific values are used as described in the ISAKMP Class Values of Group Description from Appendix A of [IKE].')
ipsecIkeSaDifHelGroupType = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupType.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDifHelGroupType.setDescription('A unique value representing the Diffie-Hellman group type used or 0 if the group is unknown. Specific values are used as described in the ISAKMP Class Values of Group Type from Appendix A of [IKE].')
ipsecIkeSaDifHelFieldSize = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDifHelFieldSize.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDifHelFieldSize.setDescription('The field size, in bits, of the Diffie-Hellman group used to generate the key-pair, or 0 if unknown.')
ipsecIkeSaPRF = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPRF.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPRF.setDescription('The pseudo-random functions used, or 0 if not used or if unknown. Specific values are used as described in the ISAKMP Class Values of PRF from Appendix A of [IKE] (which specifies none at the present time).')
ipsecIkeSaPFS = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 24), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaPFS.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaPFS.setDescription('A value that indicates that perfect forward secrecy is used for all IPSec SAs created by this IKE SA.')
ipsecIkeSaTimeStart = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 25), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTimeStart.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTimeStart.setDescription('The date and time that the SA was set up.')
ipsecIkeSaTimeLimit = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 26), OctetString()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTimeLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTimeLimit.setDescription('The maximum lifetime in seconds of the SA, or 0 if there is no time constraint on its expiration.')
ipsecIkeSaTrafficLimit = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 27), OctetString()).setUnits('Kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaTrafficLimit.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaTrafficLimit.setDescription('The maximum traffic in 1024-byte blocks that the SA is allowed to carry, or 0 if there is no traffic constraint on its expiration.')
ipsecIkeSaInboundTraffic = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 28), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaInboundTraffic.setDescription('The amount traffic measured in bytes handled in the SA in the inbound direction.')
ipsecIkeSaOutboundTraffic = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 29), Counter64()).setUnits('bytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaOutboundTraffic.setDescription('The amount traffic measured in bytes handled in the SA in the outbound direction.')
ipsecIkeSaInboundPackets = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaInboundPackets.setDescription('The number of packets handled in the SA in the inbound direction.')
ipsecIkeSaOutboundPackets = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaOutboundPackets.setDescription('The number of packets handled in the SA in the outbound direction.')
ipsecIkeProtSuitesCreated = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeProtSuitesCreated.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeProtSuitesCreated.setDescription('The total number of phase 2 protection suites created by the SA.')
ipsecIkeProtSuitesDeleted = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeProtSuitesDeleted.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeProtSuitesDeleted.setDescription('The total number of phase 2 protection suites deleted by the SA.')
ipsecIkeSaDecryptErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaDecryptErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaDecryptErrors.setDescription('The number of inbound packets discarded by the phase1 SA due to decryption errors.')
ipsecIkeSaAuthErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaAuthErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaAuthErrors.setDescription('The number of inbound packets discarded by the phase 1 SA due to authentication errors.')
ipsecIkeSaOtherReceiveErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaOtherReceiveErrors.setDescription('The number of inbound packets discarded by the phase 1 SA due to errors other than decryption or authentication errors. This may include errors due to a lack of receive buffers.')
ipsecIkeSaSendErrors = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSaSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSaSendErrors.setDescription('The number of outbound packets discarded by the phase 1 SA due to any error. This may include errors due to a lack of transmit buffers.')
ipsecTrapsA = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1, 3))
ipsecTraps = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1, 3, 0))
ipsecIpsecStats = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1, 4))
ipsecIpsecErrorStats = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1, 5))
ipsecIkeStats = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1, 6))
ipsecIkeErrorStats = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1, 7))
ipsecNotifications = MibIdentifier((1, 3, 6, 1, 3, 500, 1, 1, 8))
ipsecIpsecTotalProtSuites = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 4, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecTotalProtSuites.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecTotalProtSuites.setDescription('The total number of phase 2 protection suites established by the entity since boot time.')
ipsecIpsecNegFailures = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 4, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecNegFailures.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecNegFailures.setDescription('The total number of phase 2 protection suite negotiations that failed that occurred in the entity since boot time.')
ipsecIpsecTotalInboundPackets = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 4, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecTotalInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecTotalInboundPackets.setDescription('The total number of inbound packets carried on IPSec protection suites since boot time.')
ipsecIpsecTotalTransOutboundPackets = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 4, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecTotalTransOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecTotalTransOutboundPackets.setDescription('The total number of outbound packets carried on IPSec protection suites since boot time.')
ipsecIpsecTotalTransInboundTraffic = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 4, 5), Counter64()).setUnits('Kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecTotalTransInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecTotalTransInboundTraffic.setDescription('The total amount of inbound traffic carried on IPSec protection suites since boot time, measured in 1024-octet blocks.')
ipsecIpsecTotalTransOutboundTraffic = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 4, 6), Counter64()).setUnits('Kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecTotalTransOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecTotalTransOutboundTraffic.setDescription('The total amount of outbound traffic carried on IPSec protection suites since boot time, measured in 1024-octet blocks.')
ipsecIpsecDecryptionErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 5, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecDecryptionErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecDecryptionErrors.setDescription('The total number of packets received by the entity in the IPSec protection suites since boot time with decryption errors.')
ipsecIpsecAuthenticationErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecAuthenticationErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecAuthenticationErrors.setDescription('The total number of packets received by the entity in the IPSec protection suites since boot time with authentication errors. This includes all packets in which the hash value is determined to be invalid.')
ipsecIpsecReplayErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecReplayErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecReplayErrors.setDescription('The total number of packets received by the entity in the IPSec protection suites since boot time with replay errors.')
ipsecIpsecPolicyErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecPolicyErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecPolicyErrors.setDescription('The total number of packets received by the entity in the IPSec protection suites since boot time and discarded due to policy errors. This includes packets that had selectors that were invalid for the SA or protection suite that carried them.')
ipsecIpsecOtherReceiveErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecOtherReceiveErrors.setDescription('The total number of packets received by the entity in the IPSec protection suites since boot time and discarded due to errors not due to decryption, authentication, replay or policy.')
ipsecIpsecSendErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 5, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIpsecSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIpsecSendErrors.setDescription('The total number of packets to be sent by the entity in the IPSec protection suites since boot time and discarded due to errors.')
ipsecUnknownSpiErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 5, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecUnknownSpiErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecUnknownSpiErrors.setDescription('The total number of packets received by the entity since boot time with SPIs or CPIs that were not valid.')
ipsecIkeTotalSAs = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 6, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeTotalSAs.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeTotalSAs.setDescription('The total number of phase 1 SAs successfully established by the entity since boot time.')
ipsecIkeNegFailures = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 6, 2), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeNegFailures.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeNegFailures.setDescription('The total number of phase 1 SA negotiations that failed that occurred in the entity since boot time.')
ipsecIkeTotalInboundPackets = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 6, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeTotalInboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeTotalInboundPackets.setDescription('The total number of inbound packets carried on phase 1 SAs since boot time.')
ipsecIkeTotalTransOutboundPackets = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 6, 4), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeTotalTransOutboundPackets.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeTotalTransOutboundPackets.setDescription('The total number of outbound packets carried on phase 1 SAs since boot time.')
ipsecIkeTotalTransInboundTraffic = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 6, 5), Counter64()).setUnits('Kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeTotalTransInboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeTotalTransInboundTraffic.setDescription('The total amount of inbound traffic carried on phase 1 SAs since boot time, measured in 1024-octet blocks.')
ipsecIkeTotalTransOutboundTraffic = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 6, 6), Counter64()).setUnits('Kbytes').setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeTotalTransOutboundTraffic.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeTotalTransOutboundTraffic.setDescription('The total amount of outbound traffic carried on phase 1 SAs since boot time, measured in 1024-octet blocks.')
ipsecIkeProtocolErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 7, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeProtocolErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeProtocolErrors.setDescription('The total number of packets received by the entity since boot time with IKE protocol errors. This includes packets with invalid cookies, but does not include errors that are associated with specific IKE SAs.')
ipsecIkeDecryptionErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeDecryptionErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeDecryptionErrors.setDescription('The total number of packets received by the entity in the IPSec protection suites since boot time with decryption errors.')
ipsecIkeAuthenticationErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeAuthenticationErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeAuthenticationErrors.setDescription('The total number of packets received by the entity in the IPSec protection suites since boot time with authentication errors. This includes all packets in which the hash value is determined to be invalid.')
ipsecIkeOtherReceiveErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeOtherReceiveErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeOtherReceiveErrors.setDescription('The total number of packets received by the entity in phase 1 SAs since boot time and discarded due to errors not due to decryption or authentication.')
ipsecIkeSendErrors = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecIkeSendErrors.setStatus('current')
if mibBuilder.loadTexts: ipsecIkeSendErrors.setDescription('The total number of packets to be sent by the entity in phase 1 SAs since boot time and discarded due to errors.')
ipsecNotifyMessageTotalCount = MibScalar((1, 3, 6, 1, 3, 500, 1, 1, 8, 1), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNotifyMessageTotalCount.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyMessageTotalCount.setDescription("The total number of all types of notify messages sent or received by the entity since boot time. It is the sum of all occurrences in the 'ipsecNotifyCountTable'.")
ipsecNotifyCountTable = MibTable((1, 3, 6, 1, 3, 500, 1, 1, 8, 2), )
if mibBuilder.loadTexts: ipsecNotifyCountTable.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyCountTable.setDescription('The (conceptual) table containing information on IPSec notify message counts. This table MAY be sparsely populated; that is, rows for which the count is 0 may be absent.')
ipsecNotifyCountEntry = MibTableRow((1, 3, 6, 1, 3, 500, 1, 1, 8, 2, 1), ).setIndexNames((0, "IPSEC-MIB", "ipsecNotifyMessage"))
if mibBuilder.loadTexts: ipsecNotifyCountEntry.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyCountEntry.setDescription('An entry (conceptual row) containing the total number of occurrences of a notify message.')
ipsecNotifyMessage = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNotifyMessage.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyMessage.setDescription('The value representing a specific IPSec notify message, or 0 if unknown. Values are assigned from the set of notify message types as defined in Section 3.14.1 of [ISAKMP]. In addition, the value 0 may be used for this object when the object is used as a trap cause, and the cause is unknown.')
ipsecNotifyMessageCount = MibTableColumn((1, 3, 6, 1, 3, 500, 1, 1, 8, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipsecNotifyMessageCount.setStatus('current')
if mibBuilder.loadTexts: ipsecNotifyMessageCount.setDescription('The total number of times the specific notify message has been received or sent by the entity since system boot.')
ipsecTrapIkeNegFailure = NotificationType((1, 3, 6, 1, 3, 500, 1, 1, 3, 0, 1)).setObjects(("IPSEC-MIB", "ipsecIkeSaLocalIdType"), ("IPSEC-MIB", "ipsecIkeSaLocalId"), ("IPSEC-MIB", "ipsecIkeSaPeerIdType"), ("IPSEC-MIB", "ipsecIkeSaPeerId"), ("IPSEC-MIB", "ipsecIkeSaLocalIpAddress"), ("IPSEC-MIB", "ipsecIkeSaLocalPortNumber"), ("IPSEC-MIB", "ipsecIkeSaPeerIpAddress"), ("IPSEC-MIB", "ipsecIkeSaPeerPortNumber"), ("IPSEC-MIB", "ipsecIkeSaAuthMethod"), ("IPSEC-MIB", "ipsecIkeSaPeerCertSerialNum"), ("IPSEC-MIB", "ipsecIkeSaPeerCertIssuer"), ("IPSEC-MIB", "ipsecNotifyMessage"))
if mibBuilder.loadTexts: ipsecTrapIkeNegFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIkeNegFailure.setDescription('An attempt to negotiate a phase 1 SA failed.')
ipsecTrapInvalidCookie = NotificationType((1, 3, 6, 1, 3, 500, 1, 1, 3, 0, 2)).setObjects(("IPSEC-MIB", "ipsecIkeSaPeerIpAddress"), ("IPSEC-MIB", "ipsecIkeSaPeerPortNumber"))
if mibBuilder.loadTexts: ipsecTrapInvalidCookie.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapInvalidCookie.setDescription('IKE packets with invalid cookies were detected from the specified peer. Implementations SHOULD send one trap per peer (within a reasonable time period, rather than sending one trap per packet.')
ipsecTrapIpsecNegFailure = NotificationType((1, 3, 6, 1, 3, 500, 1, 1, 3, 0, 3)).setObjects(("IPSEC-MIB", "ipsecIkeSaIndex"), ("IPSEC-MIB", "ipsecNotifyMessage"))
if mibBuilder.loadTexts: ipsecTrapIpsecNegFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecNegFailure.setDescription('An attempt to negotiate a phase 2 protection suite within the specified IKE SA failed.')
ipsecTrapIpsecAuthFailure = NotificationType((1, 3, 6, 1, 3, 500, 1, 1, 3, 0, 4)).setObjects(("IPSEC-MIB", "ipsecProtSuiteIndex"))
if mibBuilder.loadTexts: ipsecTrapIpsecAuthFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecAuthFailure.setDescription('IPSec packets with invalid hashes were found in the specified protection suite. Implementations SHOULD send one trap per protection suite (within a reasonable time period), rather than sending one trap per packet.')
ipsecTrapIpsecReplayFailure = NotificationType((1, 3, 6, 1, 3, 500, 1, 1, 3, 0, 5)).setObjects(("IPSEC-MIB", "ipsecProtSuiteIndex"))
if mibBuilder.loadTexts: ipsecTrapIpsecReplayFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecReplayFailure.setDescription('IPSec packets with invalid sequence numbers were found in the specified protection suite. Implementations SHOULD send one trap per protection suite (within a reasonable time period), rather than sending one trap per packet.')
ipsecTrapIpsecPolicyFailure = NotificationType((1, 3, 6, 1, 3, 500, 1, 1, 3, 0, 6)).setObjects(("IPSEC-MIB", "ipsecProtSuiteIndex"))
if mibBuilder.loadTexts: ipsecTrapIpsecPolicyFailure.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapIpsecPolicyFailure.setDescription('IPSec packets carrying packets with invalid selectors for the specified protection suite were found. Implementations SHOULD send one trap per protection suite (within a reasonable time period), rather than sending one trap per packet.')
ipsecTrapInvalidSpi = NotificationType((1, 3, 6, 1, 3, 500, 1, 1, 3, 0, 7)).setObjects(("IPSEC-MIB", "ipsecIkeSaPeerIpAddress"))
if mibBuilder.loadTexts: ipsecTrapInvalidSpi.setStatus('current')
if mibBuilder.loadTexts: ipsecTrapInvalidSpi.setDescription('ESP, AH or IPCOMP packets with unknown SPIs (or CPIs) were detected from the specified peer. Implementations SHOULD send one trap per peer (within a reasonable time period), rather than sending one trap per packet.')
mibBuilder.exportSymbols("IPSEC-MIB", ipsecIkeSaInitiatorCookie=ipsecIkeSaInitiatorCookie, ipsecIkeSaDifHelGroupDesc=ipsecIkeSaDifHelGroupDesc, ipsecIkeProtSuitesDeleted=ipsecIkeProtSuitesDeleted, ipsecIpsecTotalInboundPackets=ipsecIpsecTotalInboundPackets, ipsecIkeErrorStats=ipsecIkeErrorStats, PYSNMP_MODULE_ID=ipsecMIB, ipsecIkeSaOutboundPackets=ipsecIkeSaOutboundPackets, ipsecIkeSaPeerIpAddress=ipsecIkeSaPeerIpAddress, ipsecIkeSaTrafficLimit=ipsecIkeSaTrafficLimit, ipsecProtSuiteInboundAhSpi=ipsecProtSuiteInboundAhSpi, ipsecProtSuiteTimeLimit=ipsecProtSuiteTimeLimit, ipsecIkeSaInboundTraffic=ipsecIkeSaInboundTraffic, ipsecTraps=ipsecTraps, ipsecProtSuitePFS=ipsecProtSuitePFS, ipsecProtSuiteTrafficLimit=ipsecProtSuiteTrafficLimit, ipsecIkeTotalTransInboundTraffic=ipsecIkeTotalTransInboundTraffic, ipsecProtSuiteDecryptErrors=ipsecProtSuiteDecryptErrors, ipsecIkeTotalSAs=ipsecIkeTotalSAs, ipsecNotifyCountEntry=ipsecNotifyCountEntry, ipsecNotifications=ipsecNotifications, ipsecTrapIpsecReplayFailure=ipsecTrapIpsecReplayFailure, ipsecProtSuiteInTrafficCount=ipsecProtSuiteInTrafficCount, ipsecProtSuiteEntry=ipsecProtSuiteEntry, ipsecIpsecErrorStats=ipsecIpsecErrorStats, ipsecIkeSaLocalId=ipsecIkeSaLocalId, ipsecProtSuiteInboundTraffic=ipsecProtSuiteInboundTraffic, ipsecProtSuiteTable=ipsecProtSuiteTable, ipsecProtSuiteLocalId=ipsecProtSuiteLocalId, ipsecProtSuiteRemotePort=ipsecProtSuiteRemotePort, ipsecIpsecAuthenticationErrors=ipsecIpsecAuthenticationErrors, ipsecNotifyCountTable=ipsecNotifyCountTable, ipsecIkeSaDecryptErrors=ipsecIkeSaDecryptErrors, ipsecIkeSaOutboundTraffic=ipsecIkeSaOutboundTraffic, ipsecProtSuiteRemoteIdType=ipsecProtSuiteRemoteIdType, ipsecProtSuiteDifHelGroupType=ipsecProtSuiteDifHelGroupType, ipsecProtSuiteDifHelGroupDesc=ipsecProtSuiteDifHelGroupDesc, ipsecProtSuiteEspEncKeyLength=ipsecProtSuiteEspEncKeyLength, ipsecProtSuiteOutboundTraffic=ipsecProtSuiteOutboundTraffic, ipsecProtSuiteOutboundCompCpi=ipsecProtSuiteOutboundCompCpi, ipsecNotifyMessageTotalCount=ipsecNotifyMessageTotalCount, ipsecIkeSaTable=ipsecIkeSaTable, ipsecIkeSaPFS=ipsecIkeSaPFS, ipsecProtSuiteRemoteAddress=ipsecProtSuiteRemoteAddress, ipsecIkeSaAuthMethod=ipsecIkeSaAuthMethod, ipsecIkeSaHashAlg=ipsecIkeSaHashAlg, ipsecProtSuiteReplayErrors=ipsecProtSuiteReplayErrors, ipsecIkeSaTimeStart=ipsecIkeSaTimeStart, ipsecIkeOtherReceiveErrors=ipsecIkeOtherReceiveErrors, ipsecIkeStats=ipsecIkeStats, ipsecIpsecTotalTransOutboundTraffic=ipsecIpsecTotalTransOutboundTraffic, ipsecIkeDecryptionErrors=ipsecIkeDecryptionErrors, ipsecProtSuiteOutboundPackets=ipsecProtSuiteOutboundPackets, ipsecProtSuiteOtherReceiveErrors=ipsecProtSuiteOtherReceiveErrors, ipsecIkeSaEncAlg=ipsecIkeSaEncAlg, ipsecTrapIpsecPolicyFailure=ipsecTrapIpsecPolicyFailure, ipsecProtSuiteInboundPackets=ipsecProtSuiteInboundPackets, ipsecProtSuiteIndex=ipsecProtSuiteIndex, ipsecProtSuiteCreationTime=ipsecProtSuiteCreationTime, ipsecIpsecDecryptionErrors=ipsecIpsecDecryptionErrors, ipsecIkeSaDifHelGroupType=ipsecIkeSaDifHelGroupType, ipsecProtSuiteEspAuthAlg=ipsecProtSuiteEspAuthAlg, ipsecIpsecStats=ipsecIpsecStats, ipsecIpsecOtherReceiveErrors=ipsecIpsecOtherReceiveErrors, ipsecIkeSaAuthErrors=ipsecIkeSaAuthErrors, ipsecIkeSaEntry=ipsecIkeSaEntry, ipsecIkeSaDifHelFieldSize=ipsecIkeSaDifHelFieldSize, ipsecProtSuiteAuthErrors=ipsecProtSuiteAuthErrors, ipsecIkeProtSuitesCreated=ipsecIkeProtSuitesCreated, ipsecProtSuiteProtocol=ipsecProtSuiteProtocol, ipsecIkeSaSendErrors=ipsecIkeSaSendErrors, ipsecIkeSaPeerId=ipsecIkeSaPeerId, ipsecIpsecNegFailures=ipsecIpsecNegFailures, ipsecTrapInvalidCookie=ipsecTrapInvalidCookie, ipsecIkeSendErrors=ipsecIkeSendErrors, ipsecNotifyMessage=ipsecNotifyMessage, ipsecIkeTotalTransOutboundPackets=ipsecIkeTotalTransOutboundPackets, ipsecIkeSaOtherReceiveErrors=ipsecIkeSaOtherReceiveErrors, ipsecProtSuiteOutboundAhSpi=ipsecProtSuiteOutboundAhSpi, ipsecIkeTotalInboundPackets=ipsecIkeTotalInboundPackets, ipsecProtSuiteSendErrors=ipsecProtSuiteSendErrors, ipsecIkeSaPRF=ipsecIkeSaPRF, ipsecProtSuiteEspEncAlg=ipsecProtSuiteEspEncAlg, ipsecIpsecPolicyErrors=ipsecIpsecPolicyErrors, ipsecIkeTotalTransOutboundTraffic=ipsecIkeTotalTransOutboundTraffic, ipsecNotifyMessageCount=ipsecNotifyMessageCount, ipsecIkeSaPeerIdType=ipsecIkeSaPeerIdType, ipsecIpsecTotalProtSuites=ipsecIpsecTotalProtSuites, ipsecTrapIpsecAuthFailure=ipsecTrapIpsecAuthFailure, ipsecIkeSaPeerPortNumber=ipsecIkeSaPeerPortNumber, ipsecProtSuiteOutTrafficCount=ipsecProtSuiteOutTrafficCount, ipsecTrapIpsecNegFailure=ipsecTrapIpsecNegFailure, ipsecIkeSaTimeLimit=ipsecIkeSaTimeLimit, ipsecIkeSaIndex=ipsecIkeSaIndex, ipsecIkeAuthenticationErrors=ipsecIkeAuthenticationErrors, ipsecTrapInvalidSpi=ipsecTrapInvalidSpi, ipsecProtSuiteInboundCompCpi=ipsecProtSuiteInboundCompCpi, ipsecTrapIkeNegFailure=ipsecTrapIkeNegFailure, ipsecProtSuiteLocalAddress=ipsecProtSuiteLocalAddress, ipsecProtSuiteLocalPort=ipsecProtSuiteLocalPort, ipsecProtSuiteOutboundEspSpi=ipsecProtSuiteOutboundEspSpi, ipsecIkeSaEncKeyLength=ipsecIkeSaEncKeyLength, ipsecProtSuiteAhAuthAlg=ipsecProtSuiteAhAuthAlg, ipsecIkeSaResponderCookie=ipsecIkeSaResponderCookie, ipsecIkeSaLocalIpAddress=ipsecIkeSaLocalIpAddress, ipsecIpsecTotalTransInboundTraffic=ipsecIpsecTotalTransInboundTraffic, ipsecIkeProtocolErrors=ipsecIkeProtocolErrors, ipsecProtSuiteEncapsulation=ipsecProtSuiteEncapsulation, ipsecMIB=ipsecMIB, ipsecTrapsA=ipsecTrapsA, ipsecIkeSaLocalIdType=ipsecIkeSaLocalIdType, ipsecProtSuiteLocalIdType=ipsecProtSuiteLocalIdType, ipsecIkeSaPeerCertIssuer=ipsecIkeSaPeerCertIssuer, ipsecMIBObjects=ipsecMIBObjects, ipsec=ipsec, ipsecUnknownSpiErrors=ipsecUnknownSpiErrors, ipsecIpsecSendErrors=ipsecIpsecSendErrors, ipsecProtSuiteCompAlg=ipsecProtSuiteCompAlg, ipsecIpsecReplayErrors=ipsecIpsecReplayErrors, ipsecProtSuiteRemoteId=ipsecProtSuiteRemoteId, ipsecIkeSaLocalPortNumber=ipsecIkeSaLocalPortNumber, ipsecProtSuitePolicyErrors=ipsecProtSuitePolicyErrors, ipsecProtSuiteInboundEspSpi=ipsecProtSuiteInboundEspSpi, ipsecIkeSaPeerCertSerialNum=ipsecIkeSaPeerCertSerialNum, ipsecIkeSaInboundPackets=ipsecIkeSaInboundPackets, ipsecIkeNegFailures=ipsecIkeNegFailures, ipsecIpsecTotalTransOutboundPackets=ipsecIpsecTotalTransOutboundPackets)

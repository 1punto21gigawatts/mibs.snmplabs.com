#
# PySNMP MIB module CXAtmDxi-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CXAtmDxi-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:32:08 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion")
cxAtmDxi, Alias = mibBuilder.importSymbols("CXProduct-SMI", "cxAtmDxi", "Alias")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Integer32, NotificationType, TimeTicks, Counter32, Counter64, Gauge32, ModuleIdentity, ObjectIdentity, MibIdentifier, IpAddress, Bits, iso, MibScalar, MibTable, MibTableRow, MibTableColumn = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Integer32", "NotificationType", "TimeTicks", "Counter32", "Counter64", "Gauge32", "ModuleIdentity", "ObjectIdentity", "MibIdentifier", "IpAddress", "Bits", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
class PSapIndex(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 0)

class SubRef(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class Dfa(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 1023)

class DfaX(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 16777216)

class Vpi(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 255)

class Vci(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 65535)

atmDxiMibLevel = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiMibLevel.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiMibLevel.setDescription('Used to determine current MIB module release supported by agent. Object is in decimal.')
atmDxiTranslationDfa = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 2), DfaX()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiTranslationDfa.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiTranslationDfa.setDescription('Its specification implies a translation request to the corresponding VPI/VCI pair, according to the translation mode specified by atmDxiTranslationMode. The result can be read from objects atmDxiTranslationVpi & atmDXiTranslationVci. ')
atmDxiTranslationVpi = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 3), Vpi()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiTranslationVpi.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiTranslationVpi.setDescription('Its specification implies a translation request between the pair (VPI,VCI) into the corresponding DFA, according to the translation mode specified by atmDxiTranslationMode. The result can be read from object atmDxiTranslationDfa. ')
atmDxiTranslationVci = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 4), Vci()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiTranslationVci.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiTranslationVci.setDescription('Its specification implies a translation request between the pair (VPI,VCI) into the corresponding DFA, according to the translation mode specified by atmDxiTranslationMode. The result can be read from object atmDxiTranslationDfa. ')
atmDxiTranslationMode = MibScalar((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("twobytes", 1), ("fourbytes", 2))).clone('twobytes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiTranslationMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiTranslationMode.setDescription('Defines the mode used for translation between DFAs and the pair (VPI,VCI). The mode determines how many bytes are used to encode/decode DFAs or (VPI/VCI) pairs at their respective interface.')
atmDxiPSapTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10), )
if mibBuilder.loadTexts: atmDxiPSapTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapTable.setDescription('A table containing information pertaining to one public service access point (PSAP).')
atmDxiPSapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1), ).setIndexNames((0, "CXAtmDxi-MIB", "atmDxiPSapNumber"))
if mibBuilder.loadTexts: atmDxiPSapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapEntry.setDescription('Defines an entry in the Public Service Access Point group.')
atmDxiPSapNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 1), PSapIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapNumber.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapNumber.setDescription('Identifies this PSAP (public service access point) with a numerical value. Values are unique per public service access point. Value 0 is reserved for the PSAP and is non removable.')
atmDxiPSapConnectTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 600)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiPSapConnectTimer.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapConnectTimer.setDescription('Determines the number of seconds between attempts to establish a connection for a DXI to ATM circuit mapping. A connection is attempted only for defined non-connected routes. ')
atmDxiPSapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clearStats", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: atmDxiPSapControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapControl.setDescription('Permits control of a specific PSAP (public service access point). Options: clearStats (1): Clear all statistics stored by statistics objects.')
atmDxiPSapState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("offline", 1), ("connected", 4))).clone('offline')).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapState.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapState.setDescription('Indicates the current state of this PSAP (public service access point). Options: offline (1): Indicates a newly created public service access point whose configuration has not yet been sent to the ATM DXI layer. connected (4): PSAP is connected and data flow can proceed.')
atmDxiPSapTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapTxFrames.setDescription('Indicates the number of frames transmitted by this public service access point.')
atmDxiPSapRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapRxFrames.setDescription('Indicates the number of frames received by this public service access point.')
atmDxiPSapTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapTxOctets.setDescription('Indicates the number of octets transmitted by this public service access point.')
atmDxiPSapRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapRxOctets.setDescription('Indicates the number of octets received by this public service access point.')
atmDxiPSapOutSuccessfullConnects = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapOutSuccessfullConnects.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapOutSuccessfullConnects.setDescription('Indicates the number of successful outgoing connections established by this PSAP (public service access point). An outgoing connection is always attempted from the ATM DXI to the Inter-Application Module (IAM).')
atmDxiPSapOutUnsuccessfullConnects = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapOutUnsuccessfullConnects.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapOutUnsuccessfullConnects.setDescription('Indicates the number of unsuccessful outgoing connections attempted by this PSAP (public service access point). An outgoing connection is always attempted from the ATM DXI to the Inter-Application Module (IAM).')
atmDxiPSapInConnectsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapInConnectsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapInConnectsReceived.setDescription('Indicates the number of connect attempts received at this PSAP (public service access point). An incoming connection is always attempted from the Inter-Application Module (IAM) to ATM DXI. The ATM DXI layer will always refuse such connection attempts.')
atmDxiPSapTxResets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapTxResets.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapTxResets.setDescription('Indicates the number of reset frames sent by this PSAP (public service access point).')
atmDxiPSapRxResets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapRxResets.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapRxResets.setDescription('Indicates the number of reset frames received by this PSAP (public service access point).')
atmDxiPSapNoServiceDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapNoServiceDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapNoServiceDiscards.setDescription('Indicates the number of frames received from the ATM protocol stack which have been discarded by this PSAP (public service access point) because: - the DXI port is down.')
atmDxiPSapCongestionDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 10, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiPSapCongestionDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiPSapCongestionDiscards.setDescription('Indicates the number of received frames discarded due to system congestion.')
atmDxiSapTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11), )
if mibBuilder.loadTexts: atmDxiSapTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapTable.setDescription('A table containing information pertaining to one service access point (interface).')
atmDxiSapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: atmDxiSapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapEntry.setDescription('Defines an entry in the Service Access Point group.')
atmDxiSapMode = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("mode-1a", 1), ("mode-1b", 2), ("mode-2", 3), ("modeTransparent", 4), ("modeLoopback", 5))).clone('mode-1a')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiSapMode.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapMode.setDescription('Defines the DXI operating mode to be used at the service access point.')
atmDxiSapTransparentDfa = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 6), Dfa()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiSapTransparentDfa.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapTransparentDfa.setDescription("Identifies the DXI frame address to use when the associated sap is configured for the transparent mode of operation (object atmDxiSapMode, value 'modeTransparent').")
atmDxiSapControl = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("clearStats", 1)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: atmDxiSapControl.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapControl.setDescription('Permits control of this SAP (service access point). Options: clearStats (1): Clear all statistics stored by statistics objects maintained within the service access point table.')
atmDxiSapRxLmiFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSapRxLmiFrames.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapRxLmiFrames.setDescription('Indicates the number of DXI LMI (link management interface) frames received by this SAP.')
atmDxiSapNoRouteDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSapNoRouteDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapNoRouteDiscards.setDescription('Indicates the number of frames received from a DXI port which have been discarded by this SAP (service access point) because: - no route was associated with the frame - the frame was destined for a route that is not connected - the associated ATM circuit is down.')
atmDxiSapRxInvalidDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSapRxInvalidDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapRxInvalidDiscards.setDescription('Indicates the following: - number of incorrectly formatted DXI frames received by this SAP - number of frames received whose length is less than the minimum acceptable - number of frames received in error, as signaled by the lower layer. Such errors include: - aborted frames - frames with a bad CRC - overrun frames - frames with a non-integral number of bits - frames that are longer than the lower layer is configured to accept. - number of frames received while port is down.')
atmDxiSapCongestionDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSapCongestionDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapCongestionDiscards.setDescription('Indicates the number of received frames discarded at this SAP (service access point) due to system congestion.')
atmDxiSapFlowControlDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 11, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSapFlowControlDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSapFlowControlDiscards.setDescription('Indicates the number of frames received from a DXI port which have been discarded by this SAP (service access point) because the associated route was flow controlled from the remote.')
atmDxiSysRouteTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12), )
if mibBuilder.loadTexts: atmDxiSysRouteTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSysRouteTable.setDescription('A table containing associations between ATM DXI circuits at DXI ports, and ATM circuits at a UNI port. Associations (routes) permit interconnectivity between the two types of circuits.')
atmDxiSysRouteEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CXAtmDxi-MIB", "atmDxiSRDxiFrameAddress"))
if mibBuilder.loadTexts: atmDxiSysRouteEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSysRouteEntry.setDescription('Defines an entry in the Route group.')
atmDxiSRDxiFrameAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12, 1, 1), Dfa()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRDxiFrameAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRDxiFrameAddress.setDescription('Identifies the DXI frame address which when combined with the ifIndex, uniquely identifies a DXI circuit.')
atmDxiSRRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("invalid", 1), ("valid", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiSRRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRRowStatus.setDescription('Determines the status of the objects in this row. Options: invalid (1): The row is deleted from the table immediately, however, values are still in effect until the next reset. valid (2): Use this value to add a new row to the table, or modify an existing row.')
atmDxiSRDestAlias = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12, 1, 3), Alias()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiSRDestAlias.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRDestAlias.setDescription('Determines the textual name of the destination service this route connects to. When attempting a DXI circuit connection to an ATM circuit, this object specifies the name of the circuit at the ATM layer. ATM DXI connections between 2 DXI cards within the same chassis is not provisioned for. Range of Values: 1 -16 characters (first character must be a letter).')
atmDxiSRSubRef = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12, 1, 4), SubRef()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: atmDxiSRSubRef.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRSubRef.setDescription('Specifies a reference number that is used by layers supporting circuit consolidation, such as the FRIM, and must be unique for all routes sharing the same destination circuit at such layers. The implementation of circuit consolidation onto a single ATM circuit is anticipated within the ATM Adaptation Layer (AAL5). Range of Values: 1 - 255 (when connecting to a service supporting circuit consolidation) 0 (when not using circuit consolidation, or when connecting to a service that does not support its use.)')
atmDxiSRRouteState = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("offLine", 1), ("notConnected", 2), ("inProgress", 3), ("connected", 4), ("connectedFlowOff", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRRouteState.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRRouteState.setDescription('Indicates the status of this route. Options: offLine (1): Indicates that the ATM DXI SAP this route is associated with does not exist or is offline. notConnected (2): Indicates that the remote destination does not exist, or has refused the connection. inProgress (3): Indicates that the connection is in the process of being established. This is a transient state. connected (4): Indicates that the connection is established and is ready for data transfer. connectedFlowOff (5): Indicates that the connections is established but data flow has been stopped.')
atmDxiSRFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 12, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 8, 10, 11, 12, 13, 15, 16, 17, 18))).clone(namedValues=NamedValues(("noFailure", 1), ("internalError", 2), ("localAllocFailure", 3), ("remoteAllocFailure", 4), ("localNoAccess", 5), ("remoteNoAccess", 6), ("remotePvcDown", 8), ("remotePvcBusy", 10), ("localFcnFailure", 11), ("remoteFcnFailure", 12), ("localDsnFailure", 13), ("remoteAliasNotFound", 15), ("remoteNoPvcService", 16), ("mpeInvalidSubref", 17), ("routeStalled", 18)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRFailureReason.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRFailureReason.setDescription("Indicates the status of a failed connection. The value of this object is only valid between attempts to establish the route connection atmDxiSRRouteState = notConnected), and may or may not change after successive failed attempts. Options: noFailure (1): Once a system route has been successfully connected, this value is maintained for the duration of the connection. internalError (2): An internal error has occurred. localAllocFailure (3): There is insufficient memory available for ATM DXI to establish this connection. remoteAllocFailure (4): There is insufficient memory available for the destination protocol layer to establish this connection. localNoAccess (5): This route is associated with a SAP that does not exist. remoteNoAccess (6): This route is associated with a SAP that does not exist at the destination layer. remotePvcDown (8): The PVC at the destination protocol layer is down. remotePvcBusy (10): The destination associated with this route is already connected. This typically occurs when the route is a non-MPE (PVC consolidating) circuit. localFcnFailure (11): Flow control negotiation failed. remoteFcnFailure (12): Flow control negotiation failed at the destination protocol layer. localDsnFailure (13): Data size negotiation failed. remoteAliasNotFound (15): The destination alias (atmDxiSRDestAlias) does not exist. remoteNoPvcService (16): The destination protocol layer does not support PVC service. mpeInvalidSubref (17): The value of atmDxiSRSubRef is invalid at the destination protocol layer. (i.e., atmDxiSRSubRef is set to '0' and the destination circuit is configured for PVC consolidation). routeStalled (18): An invalid control packet exchange has occurred during the route setup procedure. The route is temporarily stalled but will recover within 5 seconds.")
atmDxiSysRouteStatsTable = MibTable((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13), )
if mibBuilder.loadTexts: atmDxiSysRouteStatsTable.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSysRouteStatsTable.setDescription('A table containing statistics for established routes in the route table.')
atmDxiSysRouteStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "CXAtmDxi-MIB", "atmDxiSRStatsDxiFrameAddress"))
if mibBuilder.loadTexts: atmDxiSysRouteStatsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSysRouteStatsEntry.setDescription('Defines an entry in the Route Statistics group.')
atmDxiSRStatsDxiFrameAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 1), Dfa()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsDxiFrameAddress.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsDxiFrameAddress.setDescription('Identifies the DXI frame address, which when combined with the ifIndex, uniquely identifies a DXI circuit.')
atmDxiSRStatsCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsCreationTime.setDescription("Indicates the system clock's time at which this connection was created.")
atmDxiSRStatsNegotiatedDataSize = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsNegotiatedDataSize.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsNegotiatedDataSize.setDescription('Indicates the data size of a frame negotiated at connection. ')
atmDxiSRStatsTxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsTxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsTxFrames.setDescription('Indicates the number of frames transmitted by this connection.')
atmDxiSRStatsRxFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsRxFrames.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsRxFrames.setDescription('Indicates the number of frames received by this connection.')
atmDxiSRStatsTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsTxOctets.setDescription('Indicates the number of octets transmitted by this connection.')
atmDxiSRStatsRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsRxOctets.setDescription('Indicates the number of octets received by this connection.')
atmDxiSRStatsFlowControlDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 495, 2, 1, 6, 58, 13, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: atmDxiSRStatsFlowControlDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: atmDxiSRStatsFlowControlDiscards.setDescription('Indicates the number of frames which were destined for this route but were discarded due to flow control from the remote.')
mibBuilder.exportSymbols("CXAtmDxi-MIB", atmDxiPSapRxFrames=atmDxiPSapRxFrames, atmDxiSapControl=atmDxiSapControl, Dfa=Dfa, atmDxiMibLevel=atmDxiMibLevel, atmDxiPSapEntry=atmDxiPSapEntry, atmDxiSysRouteStatsTable=atmDxiSysRouteStatsTable, atmDxiSRSubRef=atmDxiSRSubRef, atmDxiPSapConnectTimer=atmDxiPSapConnectTimer, atmDxiSRStatsTxFrames=atmDxiSRStatsTxFrames, Vci=Vci, atmDxiPSapRxOctets=atmDxiPSapRxOctets, atmDxiSapMode=atmDxiSapMode, atmDxiSRFailureReason=atmDxiSRFailureReason, atmDxiSapTransparentDfa=atmDxiSapTransparentDfa, atmDxiSapFlowControlDiscards=atmDxiSapFlowControlDiscards, atmDxiSRStatsCreationTime=atmDxiSRStatsCreationTime, atmDxiSRStatsRxFrames=atmDxiSRStatsRxFrames, atmDxiSRDestAlias=atmDxiSRDestAlias, atmDxiSRStatsDxiFrameAddress=atmDxiSRStatsDxiFrameAddress, atmDxiSRStatsTxOctets=atmDxiSRStatsTxOctets, atmDxiTranslationVci=atmDxiTranslationVci, atmDxiSapRxInvalidDiscards=atmDxiSapRxInvalidDiscards, atmDxiPSapOutUnsuccessfullConnects=atmDxiPSapOutUnsuccessfullConnects, atmDxiPSapInConnectsReceived=atmDxiPSapInConnectsReceived, atmDxiSysRouteEntry=atmDxiSysRouteEntry, atmDxiSapCongestionDiscards=atmDxiSapCongestionDiscards, atmDxiPSapTxFrames=atmDxiPSapTxFrames, atmDxiTranslationDfa=atmDxiTranslationDfa, atmDxiPSapState=atmDxiPSapState, atmDxiSRRowStatus=atmDxiSRRowStatus, atmDxiPSapControl=atmDxiPSapControl, DfaX=DfaX, atmDxiPSapTxResets=atmDxiPSapTxResets, atmDxiPSapNoServiceDiscards=atmDxiPSapNoServiceDiscards, atmDxiSRStatsFlowControlDiscards=atmDxiSRStatsFlowControlDiscards, atmDxiSapTable=atmDxiSapTable, Vpi=Vpi, atmDxiPSapRxResets=atmDxiPSapRxResets, atmDxiPSapCongestionDiscards=atmDxiPSapCongestionDiscards, atmDxiSapNoRouteDiscards=atmDxiSapNoRouteDiscards, PSapIndex=PSapIndex, atmDxiPSapOutSuccessfullConnects=atmDxiPSapOutSuccessfullConnects, atmDxiPSapTable=atmDxiPSapTable, atmDxiSRRouteState=atmDxiSRRouteState, atmDxiTranslationVpi=atmDxiTranslationVpi, atmDxiPSapTxOctets=atmDxiPSapTxOctets, atmDxiSRStatsNegotiatedDataSize=atmDxiSRStatsNegotiatedDataSize, atmDxiSysRouteTable=atmDxiSysRouteTable, atmDxiSysRouteStatsEntry=atmDxiSysRouteStatsEntry, atmDxiSRStatsRxOctets=atmDxiSRStatsRxOctets, atmDxiTranslationMode=atmDxiTranslationMode, atmDxiSapEntry=atmDxiSapEntry, atmDxiSRDxiFrameAddress=atmDxiSRDxiFrameAddress, atmDxiSapRxLmiFrames=atmDxiSapRxLmiFrames, SubRef=SubRef, atmDxiPSapNumber=atmDxiPSapNumber)

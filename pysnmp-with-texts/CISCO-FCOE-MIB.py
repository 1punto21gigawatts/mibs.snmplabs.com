#
# PySNMP MIB module CISCO-FCOE-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-FCOE-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:58:23 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "ConstraintsUnion", "SingleValueConstraint")
ciscoMgmt, = mibBuilder.importSymbols("CISCO-SMI", "ciscoMgmt")
fcmInstanceIndex, fcmSwitchIndex = mibBuilder.importSymbols("FC-MGMT-MIB", "fcmInstanceIndex", "fcmSwitchIndex")
InterfaceIndexOrZero, InterfaceIndex = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero", "InterfaceIndex")
VlanIndex, = mibBuilder.importSymbols("Q-BRIDGE-MIB", "VlanIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ObjectGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ObjectGroup", "ModuleCompliance")
Gauge32, iso, ModuleIdentity, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, Counter64, Counter32, IpAddress, NotificationType, ObjectIdentity, MibIdentifier, TimeTicks, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "iso", "ModuleIdentity", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "Counter64", "Counter32", "IpAddress", "NotificationType", "ObjectIdentity", "MibIdentifier", "TimeTicks", "Integer32")
DisplayString, TimeStamp, TextualConvention, MacAddress, TruthValue, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TimeStamp", "TextualConvention", "MacAddress", "TruthValue", "RowStatus")
T11FabricIndex, = mibBuilder.importSymbols("T11-TC-MIB", "T11FabricIndex")
ciscoFCoEMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 673))
ciscoFCoEMIB.setRevisions(('2008-06-16 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoFCoEMIB.setRevisionsDescriptions(('Initial version of this MIB module.',))
if mibBuilder.loadTexts: ciscoFCoEMIB.setLastUpdated('200806160000Z')
if mibBuilder.loadTexts: ciscoFCoEMIB.setOrganization('Cisco Systems Inc.')
if mibBuilder.loadTexts: ciscoFCoEMIB.setContactInfo('Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553 -NETS E-mail: fcoe@cisco.com')
if mibBuilder.loadTexts: ciscoFCoEMIB.setDescription('This MIB module is for configuring and monitoring Fibre Channel over Ethernet (FCoE) related entities. This MIB defines the Virtual FC (VFC) Interface as an object that represents either a VF_Port or a VE_Port on the FCF. Virtual FC interfaces can be either statically created or dynamically created at the time of FIP based FLOGI or ELP request. In this document the term VSAN ID is used interchangeably with Fabric Index defined in the T11 standards. Terminologies used in this MIB are defined by the T11 FCoE standard. Refer to www.t11.org. This MIB also supports configuration of the following objects: - Mapping of FCoE VLAN ID used to carry traffic for a VSAN ID - FC-MAP value used by the FCF operating in FPMA mode - FIP snooping related objects')
ciscoFCoEMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 673, 1))
ciscoFCoEMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 673, 2))
cfcoeConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1))
cfcoeFipSnoopingObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 2))
class VfcBindType(TextualConvention, Integer32):
    description = 'Defines the different methods to identify (or bind to) - the ENode associated with a particular VF_Port VFC - the remote-FCF associated with a particular VE_Port VFC interfaceIndex(1) - This type is used when the ifIndex of an ethernet interface over which the FCF reaches the ENode or the remote-FCF is used to identify the ENode or the remote-FCF. This type is to be used only when the ENode or the remote-FCF is directly connected to the FCF over a specific ethernet interface. macAddress(2) - This type is used when the ENode or the remote-FCF is reachable by the FCF over a L2 Ethernet network. An ENode or remote-FCF is associated to a VFC only if the source MAC address in the FIP frames matches with the bound MAC Address on the VFC.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("interfaceIndex", 1), ("macAddress", 2))

cfcoeCfgTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1), )
if mibBuilder.loadTexts: cfcoeCfgTable.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgTable.setDescription('This table facilitates configuration of FCoE parameters on a per Fibre Channel management instance.')
cfcoeCfgEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1, 1), ).setIndexNames((0, "FC-MGMT-MIB", "fcmInstanceIndex"), (0, "FC-MGMT-MIB", "fcmSwitchIndex"))
if mibBuilder.loadTexts: cfcoeCfgEntry.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgEntry.setDescription('There is one entry in this table for each Fibre Channel management instance.')
cfcoeCfgFcmap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3).clone(hexValue="0EFC00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeCfgFcmap.setReference('ANSI INCITS xxx-200x, T11/Project 1871-D, Fibre Channel - Backbone 5 (FC-BB-5), 10 June 2008, section 7.8 and table 41.')
if mibBuilder.loadTexts: cfcoeCfgFcmap.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgFcmap.setDescription('This object configures the FC-MAP value used by the FCF when operating in FPMA mode. The default value is 0EFC00h, as written in the standard.')
cfcoeCfgDynamicVfcCreation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1, 1, 2), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeCfgDynamicVfcCreation.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgDynamicVfcCreation.setDescription('This object allows the user to enable (TRUE) or disable (FALSE) dynamic VFC interface creation on the FCF. When set to TRUE VFC interfaces are dynamically created when a FIP based FLOGI or ELP request is received.')
cfcoeCfgDynamicVfcAgeTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(10, 1000000)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeCfgDynamicVfcAgeTimer.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgDynamicVfcAgeTimer.setDescription('This ageing timer (in seconds) is used by the FCF to age out dynamically created VFC interfaces. The default value is 300 seconds.')
cfcoeCfgDefaultFCFPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeCfgDefaultFCFPriority.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgDefaultFCFPriority.setDescription('The FIP priority value advertised by the FCF to ENodes by default. cfcoeStaticVfcFCFPriority configured for a VFC interface overrides this setting for the ENode associated with the VFC.')
cfcoeCfgDATov = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 60)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeCfgDATov.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgDATov.setDescription('The Discovery_Advertisement_Timeout value configured for the FCF. This is used as the timeout value in seconds by the FCF to send periodic Discovery Advertisements.')
cfcoeCfgAddressingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("fpma", 1), ("spma", 2), ("both", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeCfgAddressingMode.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgAddressingMode.setDescription('Addressing mode(s) supported by the FCF. Implementations should fail set requests for unsupported modes.')
cfcoeVLANTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 2), )
if mibBuilder.loadTexts: cfcoeVLANTable.setStatus('current')
if mibBuilder.loadTexts: cfcoeVLANTable.setDescription('This table facilitates configuration of VLAN and Fabric (VSAN) associations in an FCoE network. FCoE forwarding for a fabric is over a VLAN in a L2 Ethernet network. That is, reachability between the ENode/remote-FCF and an FCF for a given fabric is determined by the reachability provided by the Ethernet network on the corresponding VLAN. An active entry in this table indicates the VLAN that is used to transport FCoE traffic for a certain VSAN. Some implmentations may allow traffic from only one VSAN to be transported over a given VLAN. Such implmentations should prevent multiple entries with the same VLAN ID or the VSAN ID from being created in this table. Modifying existing VLAN-VSAN associations is not supported. Entries must be deleted first and then recreated.')
cfcoeVLANEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 2, 1), ).setIndexNames((0, "FC-MGMT-MIB", "fcmInstanceIndex"), (0, "FC-MGMT-MIB", "fcmSwitchIndex"), (0, "CISCO-FCOE-MIB", "cfcoeVLANIndex"), (0, "CISCO-FCOE-MIB", "cfcoeFabricIndex"))
if mibBuilder.loadTexts: cfcoeVLANEntry.setStatus('current')
if mibBuilder.loadTexts: cfcoeVLANEntry.setDescription('There is one entry in this table for each VLAN that is designated to transport FCoE traffic for a given fabric (VSAN).')
cfcoeVLANIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 2, 1, 1), VlanIndex())
if mibBuilder.loadTexts: cfcoeVLANIndex.setStatus('current')
if mibBuilder.loadTexts: cfcoeVLANIndex.setDescription('This object identifies the VLAN ID that FCoE FCF function is being enabled for.')
cfcoeFabricIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 2, 1, 2), T11FabricIndex())
if mibBuilder.loadTexts: cfcoeFabricIndex.setStatus('current')
if mibBuilder.loadTexts: cfcoeFabricIndex.setDescription('This object identifies the Fabric Index of the VSAN traffic for which can be transported over the VLAN identified by cfcoeVLANIndex.')
cfcoeVLANOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfcoeVLANOperState.setStatus('current')
if mibBuilder.loadTexts: cfcoeVLANOperState.setDescription("Operational state of this VLAN-VSAN association entry. The 'up' state is achieved when both the VSAN and VLAN are valid.")
cfcoeVLANRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 2, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cfcoeVLANRowStatus.setStatus('current')
if mibBuilder.loadTexts: cfcoeVLANRowStatus.setDescription('The status of this conceptual row. The RowStatus becomes active on successful creation of an entry.')
cfcoeStaticVfcTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3), )
if mibBuilder.loadTexts: cfcoeStaticVfcTable.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcTable.setDescription('This table facilitates the creation and deletion of static VFC interfaces. While VFCs can be dynamically created based on FIP FLOGI/ELP requests users may want to associate certain pre-configured policy for a particular ENode or a remote-FCF. In such cases static VFC creation becomes necessary. In addition to creating a static VFC it also needs to be associated to an ENode or remote-FCF. The VFC binding provides such an associaton. Binding may occur after a VFC is created.')
cfcoeStaticVfcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1), ).setIndexNames((0, "FC-MGMT-MIB", "fcmInstanceIndex"), (0, "FC-MGMT-MIB", "fcmSwitchIndex"), (0, "CISCO-FCOE-MIB", "cfcoeStaticVfcIndex"))
if mibBuilder.loadTexts: cfcoeStaticVfcEntry.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcEntry.setDescription('There is one entry in this table for each statically created VFC Interface.')
cfcoeStaticVfcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: cfcoeStaticVfcIndex.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcIndex.setDescription('This index uniquely identifies a static VFC entry in this table.')
cfcoeStaticVfcFCFPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(128)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cfcoeStaticVfcFCFPriority.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcFCFPriority.setDescription('If this VFC is for a VF_Port this object is used to configure FCF priority to be advertised to the ENode associated with the VFC.')
cfcoeStaticVfcBindType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 3), VfcBindType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cfcoeStaticVfcBindType.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcBindType.setDescription('The mechanism to identify the ENode associated with this VFC if it is of type VF_Port or to identify the remote-FCF associated with this VFC if it is of type VE_Port.')
cfcoeStaticVfcBindIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 4), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cfcoeStaticVfcBindIfIndex.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcBindIfIndex.setDescription('This object allows for configuration of ifIndex of the ethernet interface over which the FCF reaches the ENode or the remote-FCF that this VFC identifies. This object is to be used only when the ENode or the remote-FCF is directly connected to the FCF over a specific ethernet interface. If the ENode or remote-FCF is not directly connected to the FCF, this field must be set to zero.')
cfcoeStaticVfcBindMACAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 5), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cfcoeStaticVfcBindMACAddress.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcBindMACAddress.setDescription('This object allows the user to configure MAC address of the ENode or the remote-FCF that this VFC interface identifies. An ENode or remote-FCF is associated to this VFC only if the source MAC address in the FIP frames matches with this object.')
cfcoeStaticVfcIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 6), InterfaceIndex()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfcoeStaticVfcIfIndex.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcIfIndex.setDescription('The ifIndex of this virtual FC interface.')
cfcoeStaticVfcCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 7), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfcoeStaticVfcCreationTime.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcCreationTime.setDescription("The timestamp of this entry's creation time.")
cfcoeStaticVfcFailureCause = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 8), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cfcoeStaticVfcFailureCause.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcFailureCause.setDescription('The cause of failure for the last bind operation. This object will be zero length if and only if the bind is successful.')
cfcoeStaticVfcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 1, 3, 1, 9), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cfcoeStaticVfcRowStatus.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcRowStatus.setDescription('The status of this conceptual row. The RowStatus becomes active on successful creation of a virtual interface. The VFC must be bound before it can become operational.')
cfcoeFipSnoopingEnable = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeFipSnoopingEnable.setStatus('current')
if mibBuilder.loadTexts: cfcoeFipSnoopingEnable.setDescription('This object is used to enable or disable FIP Snooping on an Ethernet Bridge.')
cfcoeFipSnoopingFcmap = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 2, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(3, 3)).setFixedLength(3).clone(hexValue="0EFC00")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: cfcoeFipSnoopingFcmap.setStatus('current')
if mibBuilder.loadTexts: cfcoeFipSnoopingFcmap.setDescription('This object configures the FC-MAP value associated with the FIP snooping Ethernet bridge.')
cfcoeEnodeIntfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 2, 3), )
if mibBuilder.loadTexts: cfcoeEnodeIntfTable.setStatus('current')
if mibBuilder.loadTexts: cfcoeEnodeIntfTable.setDescription('The (conceptual) table containing the interfaces on an Ethernet bridge that are directly connected to ENodes. A FIP Snooping bridge will automatically configure ACLs on these interfaces based on FIP login requests and responses.')
cfcoeEnodeIntfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-FCOE-MIB", "cfcoeEnodeIntfIfIndex"))
if mibBuilder.loadTexts: cfcoeEnodeIntfEntry.setStatus('current')
if mibBuilder.loadTexts: cfcoeEnodeIntfEntry.setDescription('An entry (conceptual row) in the cfcoeEnodeIntfTable, representing an interface directly connected to an ENode on the Ethernet Bridge.')
cfcoeEnodeIntfIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 2, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: cfcoeEnodeIntfIfIndex.setStatus('current')
if mibBuilder.loadTexts: cfcoeEnodeIntfIfIndex.setDescription('The ifIndex of the interface on the Ethernet bridge connected to an Enode.')
cfcoeEnodeIntfRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 673, 1, 2, 3, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cfcoeEnodeIntfRowStatus.setStatus('current')
if mibBuilder.loadTexts: cfcoeEnodeIntfRowStatus.setDescription('The status of this conceptual row.')
cFCoEMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 1))
cFCoEMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 2))
cFCoEMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 1, 1)).setObjects(("CISCO-FCOE-MIB", "cfcoeCfgConformanceObjects"), ("CISCO-FCOE-MIB", "cfcoeVLANConformanceObjects"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcConformanceObjects"), ("CISCO-FCOE-MIB", "cfcoeFipSnoopingConformanceObjects"), ("CISCO-FCOE-MIB", "cfcoeEnodeIntfObjects"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cFCoEMIBCompliance = cFCoEMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cFCoEMIBCompliance.setDescription('The compliance statement for entities which implement the CISCO-FCOE-MIB mib.')
cfcoeCfgConformanceObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 2, 1)).setObjects(("CISCO-FCOE-MIB", "cfcoeCfgFcmap"), ("CISCO-FCOE-MIB", "cfcoeCfgDynamicVfcCreation"), ("CISCO-FCOE-MIB", "cfcoeCfgDynamicVfcAgeTimer"), ("CISCO-FCOE-MIB", "cfcoeCfgDefaultFCFPriority"), ("CISCO-FCOE-MIB", "cfcoeCfgDATov"), ("CISCO-FCOE-MIB", "cfcoeCfgAddressingMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cfcoeCfgConformanceObjects = cfcoeCfgConformanceObjects.setStatus('current')
if mibBuilder.loadTexts: cfcoeCfgConformanceObjects.setDescription('A collection of objects related to all implementations of FCoE.')
cfcoeVLANConformanceObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 2, 2)).setObjects(("CISCO-FCOE-MIB", "cfcoeVLANOperState"), ("CISCO-FCOE-MIB", "cfcoeVLANRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cfcoeVLANConformanceObjects = cfcoeVLANConformanceObjects.setStatus('current')
if mibBuilder.loadTexts: cfcoeVLANConformanceObjects.setDescription('A collection of objects related to implementation of FCoE VLANs.')
cfcoeStaticVfcConformanceObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 2, 3)).setObjects(("CISCO-FCOE-MIB", "cfcoeStaticVfcFCFPriority"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcBindType"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcBindIfIndex"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcBindMACAddress"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcIfIndex"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcCreationTime"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcFailureCause"), ("CISCO-FCOE-MIB", "cfcoeStaticVfcRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cfcoeStaticVfcConformanceObjects = cfcoeStaticVfcConformanceObjects.setStatus('current')
if mibBuilder.loadTexts: cfcoeStaticVfcConformanceObjects.setDescription('A collection of objects related to implementation of static VFC interfaces.')
cfcoeFipSnoopingConformanceObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 2, 4)).setObjects(("CISCO-FCOE-MIB", "cfcoeFipSnoopingEnable"), ("CISCO-FCOE-MIB", "cfcoeFipSnoopingFcmap"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cfcoeFipSnoopingConformanceObjects = cfcoeFipSnoopingConformanceObjects.setStatus('current')
if mibBuilder.loadTexts: cfcoeFipSnoopingConformanceObjects.setDescription('A collection of objects related to implementation of FIP Snooping.')
cfcoeEnodeIntfObjects = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 673, 2, 2, 5)).setObjects(("CISCO-FCOE-MIB", "cfcoeEnodeIntfRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cfcoeEnodeIntfObjects = cfcoeEnodeIntfObjects.setStatus('current')
if mibBuilder.loadTexts: cfcoeEnodeIntfObjects.setDescription('A collection of objects related to implementation of ENode interfaces on a FIP snooping bridge.')
mibBuilder.exportSymbols("CISCO-FCOE-MIB", cfcoeCfgAddressingMode=cfcoeCfgAddressingMode, cfcoeStaticVfcEntry=cfcoeStaticVfcEntry, cfcoeStaticVfcFailureCause=cfcoeStaticVfcFailureCause, cfcoeFipSnoopingObjects=cfcoeFipSnoopingObjects, ciscoFCoEMIBConformance=ciscoFCoEMIBConformance, cfcoeFabricIndex=cfcoeFabricIndex, ciscoFCoEMIB=ciscoFCoEMIB, cfcoeVLANOperState=cfcoeVLANOperState, cfcoeStaticVfcIndex=cfcoeStaticVfcIndex, cfcoeCfgDefaultFCFPriority=cfcoeCfgDefaultFCFPriority, cfcoeEnodeIntfEntry=cfcoeEnodeIntfEntry, cfcoeEnodeIntfTable=cfcoeEnodeIntfTable, cfcoeVLANRowStatus=cfcoeVLANRowStatus, ciscoFCoEMIBObjects=ciscoFCoEMIBObjects, cfcoeCfgTable=cfcoeCfgTable, cfcoeStaticVfcBindType=cfcoeStaticVfcBindType, cfcoeCfgEntry=cfcoeCfgEntry, cfcoeEnodeIntfIfIndex=cfcoeEnodeIntfIfIndex, cfcoeStaticVfcBindMACAddress=cfcoeStaticVfcBindMACAddress, cfcoeStaticVfcCreationTime=cfcoeStaticVfcCreationTime, cfcoeStaticVfcConformanceObjects=cfcoeStaticVfcConformanceObjects, VfcBindType=VfcBindType, PYSNMP_MODULE_ID=ciscoFCoEMIB, cfcoeCfgConformanceObjects=cfcoeCfgConformanceObjects, cfcoeStaticVfcBindIfIndex=cfcoeStaticVfcBindIfIndex, cFCoEMIBGroups=cFCoEMIBGroups, cfcoeEnodeIntfObjects=cfcoeEnodeIntfObjects, cfcoeFipSnoopingEnable=cfcoeFipSnoopingEnable, cfcoeFipSnoopingFcmap=cfcoeFipSnoopingFcmap, cfcoeConfig=cfcoeConfig, cfcoeVLANIndex=cfcoeVLANIndex, cfcoeVLANEntry=cfcoeVLANEntry, cfcoeVLANConformanceObjects=cfcoeVLANConformanceObjects, cFCoEMIBCompliance=cFCoEMIBCompliance, cfcoeVLANTable=cfcoeVLANTable, cfcoeStaticVfcFCFPriority=cfcoeStaticVfcFCFPriority, cfcoeFipSnoopingConformanceObjects=cfcoeFipSnoopingConformanceObjects, cfcoeCfgDATov=cfcoeCfgDATov, cfcoeEnodeIntfRowStatus=cfcoeEnodeIntfRowStatus, cfcoeStaticVfcTable=cfcoeStaticVfcTable, cfcoeCfgDynamicVfcCreation=cfcoeCfgDynamicVfcCreation, cfcoeStaticVfcIfIndex=cfcoeStaticVfcIfIndex, cfcoeStaticVfcRowStatus=cfcoeStaticVfcRowStatus, cFCoEMIBCompliances=cFCoEMIBCompliances, cfcoeCfgDynamicVfcAgeTimer=cfcoeCfgDynamicVfcAgeTimer, cfcoeCfgFcmap=cfcoeCfgFcmap)

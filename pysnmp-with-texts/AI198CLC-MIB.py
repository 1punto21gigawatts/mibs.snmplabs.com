#
# PySNMP MIB module AI198CLC-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/AI198CLC-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:15:57 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ValueSizeConstraint")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
ModuleIdentity, MibIdentifier, ObjectIdentity, TimeTicks, Unsigned32, IpAddress, Counter64, NotificationType, Gauge32, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter32, Integer32, iso, enterprises, Bits = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "MibIdentifier", "ObjectIdentity", "TimeTicks", "Unsigned32", "IpAddress", "Counter64", "NotificationType", "Gauge32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter32", "Integer32", "iso", "enterprises", "Bits")
DateAndTime, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "DisplayString", "TextualConvention")
aii = MibIdentifier((1, 3, 6, 1, 4, 1, 539))
aiSystemOID = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2))
aiCLC = ModuleIdentity((1, 3, 6, 1, 4, 1, 539, 9))
if mibBuilder.loadTexts: aiCLC.setLastUpdated('9505081700Z')
if mibBuilder.loadTexts: aiCLC.setOrganization('Applied Innovation Incorporated')
if mibBuilder.loadTexts: aiCLC.setContactInfo(' Engineering MIB Administrator Postal: Applied Innovation Inc. 5800 Innovation Drive Dublin, OH 43016 Tel: 614/798-2000 Fax: 614/798-1770 E-mail: snmp@aiinet.com')
if mibBuilder.loadTexts: aiCLC.setDescription('The MIB Module for Series 1 Common Logic Controllers (CLC)')
aiCLCSystem = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 9, 1))
ai198 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198))
ai198Ver1 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1))
ai198Ver10 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 0))
ai198Ver102 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 0, 2))
ai198Ver103 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 0, 3))
ai198Ver104 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 0, 4))
ai198Ver12 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 2))
ai198Ver120 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 2, 0))
ai198Ver13 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 3))
ai198Ver130 = MibIdentifier((1, 3, 6, 1, 4, 1, 539, 2, 198, 1, 3, 0))
aiCLCBox1DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox1DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox1DensAdmin.setDescription('The administration value for the slot density for Chassis 1 of and AISwitch.')
aiCLCBox2DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(16)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox2DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox2DensAdmin.setDescription('The administration value for the slot density for Chassis 2 of and AISwitch.')
aiCLCBox3DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox3DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox3DensAdmin.setDescription('The administration value for the slot density for Chassis 3 of and AISwitch.')
aiCLCBox4DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox4DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox4DensAdmin.setDescription('The administration value for the slot density for Chassis 4 of and AISwitch.')
aiCLCBox5DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox5DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox5DensAdmin.setDescription('The administration value for the slot density for Chassis 5 of and AISwitch.')
aiCLCBox6DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox6DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox6DensAdmin.setDescription('The administration value for the slot density for Chassis 6 of and AISwitch.')
aiCLCBox7DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox7DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox7DensAdmin.setDescription('The administration value for the slot density for Chassis 7 of and AISwitch.')
aiCLCBox8DensAdmin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4, 8, 16, 32))).clone(namedValues=NamedValues(("disabled", 1), ("four", 4), ("eight", 8), ("sixteen", 16), ("thirtytwo", 32))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBox8DensAdmin.setStatus('current')
if mibBuilder.loadTexts: aiCLCBox8DensAdmin.setDescription('The administration value for the slot density for Chassis 8 of and AISwitch.')
aiCLCNodeName = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 9), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0, 29)).clone('NODE-XXX')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCNodeName.setStatus('current')
if mibBuilder.loadTexts: aiCLCNodeName.setDescription('This associates a name with an AI Switch. This string is part of the prompt for a user port.')
aiCLCLogPortEnable = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCLogPortEnable.setStatus('current')
if mibBuilder.loadTexts: aiCLCLogPortEnable.setDescription('Enable/Disable the display of Alarm and Activity Information.')
aiCLCAlmLogPort = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAlmLogPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCAlmLogPort.setDescription('The Alarm and Activity Log Port Number.')
aiCLCActLogLvl = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCActLogLvl.setStatus('current')
if mibBuilder.loadTexts: aiCLCActLogLvl.setDescription('The alarm level which when met or exceeded will cause messages to be printed on the log port.')
aiCLCMinorAlmMin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCMinorAlmMin.setStatus('current')
if mibBuilder.loadTexts: aiCLCMinorAlmMin.setDescription('The alarm level which when met or exceeded will cause a minor alarm to be reported.')
aiCLCMinorAlmMax = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(4)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCMinorAlmMax.setStatus('current')
if mibBuilder.loadTexts: aiCLCMinorAlmMax.setDescription('The alarm level which when exceeded will not cause a minor alarm to be reported.')
aiCLCMajorAlmMin = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCMajorAlmMin.setStatus('current')
if mibBuilder.loadTexts: aiCLCMajorAlmMin.setDescription('The alarm level which when met or exceeded will cause a major alarm to be reported.')
aiCLCMajorAlmMax = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(9)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCMajorAlmMax.setStatus('current')
if mibBuilder.loadTexts: aiCLCMajorAlmMax.setDescription('The alarm level which when exceeded will not cause a major alarm to be reported.')
aiCLCCraftLogEcho = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCraftLogEcho.setStatus('current')
if mibBuilder.loadTexts: aiCLCCraftLogEcho.setDescription('Echo Alarm and Activity information on the craft port.')
aiCLCCaamlRoute = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 18), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0, 200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCaamlRoute.setStatus('current')
if mibBuilder.loadTexts: aiCLCCaamlRoute.setDescription('Name of the destination used for the CAAML Log.')
aiCLCCaamlIdleTmr = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCaamlIdleTmr.setStatus('current')
if mibBuilder.loadTexts: aiCLCCaamlIdleTmr.setDescription('The number of seconds that must pass without any messages being printed on CAAML, before the CAAML connection is torn down.')
aiCLCCaamlRetryTmr = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)).clone(10)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCaamlRetryTmr.setStatus('current')
if mibBuilder.loadTexts: aiCLCCaamlRetryTmr.setDescription('The number of seconds that must pass after an unsuccessful attempt at bringing the CAAML connection up before a retry will occur.')
aiCLCConnInfo = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCConnInfo.setStatus('current')
if mibBuilder.loadTexts: aiCLCConnInfo.setDescription('Print connection information on user terminals.')
aiCLCLongBrkLen = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1875, 50000)).clone(1875)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCLongBrkLen.setStatus('current')
if mibBuilder.loadTexts: aiCLCLongBrkLen.setDescription('Long Break length in milliseconds rounded to the nearest 1/64th second.')
aiCLCDestMenu = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestMenu.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestMenu.setDescription('Print Destination Menu on user terminals.')
aiCLCDownSpd = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDownSpd.setStatus('current')
if mibBuilder.loadTexts: aiCLCDownSpd.setDescription('Allow ports of different speeds to be connected.')
aiCLCFaultSwitch = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCFaultSwitch.setStatus('current')
if mibBuilder.loadTexts: aiCLCFaultSwitch.setDescription('In dual CLC systems, a fault on the active CLC will cause automatic switchover from the faulted CLC to the backup CLC.')
aiCLCDestMenuFmt = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 4))).clone(namedValues=NamedValues(("oneCol", 1), ("fourCol", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestMenuFmt.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestMenuFmt.setDescription('The number of columns used to print the destination menu.')
aiCLCAutoCLCUpdate = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAutoCLCUpdate.setStatus('current')
if mibBuilder.loadTexts: aiCLCAutoCLCUpdate.setDescription("Automatic configuration of the backup CLC when the active CLC's configuration changes.")
aiCLCAlarmLvl = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAlarmLvl.setStatus('current')
if mibBuilder.loadTexts: aiCLCAlarmLvl.setDescription('Current Alarm Level. A write clears the alarms. A read returns the current alarm level.')
aiCLCTimeDate = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 29), DateAndTime()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTimeDate.setStatus('current')
if mibBuilder.loadTexts: aiCLCTimeDate.setDescription('This is the Current Time and Date. The DateAndTime type is a structured OCTET STRING, defined in v2-tc.my (SNMPv2 Textual Conventions).')
aiCLCRstTimeDate = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 30), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCRstTimeDate.setStatus('current')
if mibBuilder.loadTexts: aiCLCRstTimeDate.setDescription('This is the Time and Date of Last Reset. The DateAndTime type is a structured OCTET STRING, defined in v2-tc.my (SNMPv2 Textual Conventions).')
aiCLCHoldConn = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 31), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCHoldConn.setStatus('current')
if mibBuilder.loadTexts: aiCLCHoldConn.setDescription('Number of connections placed on hold ')
aiCLCNumPorts = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 32), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCNumPorts.setStatus('current')
if mibBuilder.loadTexts: aiCLCNumPorts.setDescription('Number of ports detected ')
aiCLCQueuedPorts = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCQueuedPorts.setStatus('current')
if mibBuilder.loadTexts: aiCLCQueuedPorts.setDescription('Number of ports in wait queue ')
aiCLCEEPromFaults = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 34), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCEEPromFaults.setStatus('current')
if mibBuilder.loadTexts: aiCLCEEPromFaults.setDescription('Number of EEProm failures')
aiCLCFreeEE = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 35), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1048576))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCFreeEE.setStatus('current')
if mibBuilder.loadTexts: aiCLCFreeEE.setDescription('Number of free EEProm bytes ')
aiCLCBuffers = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 36), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCBuffers.setStatus('current')
if mibBuilder.loadTexts: aiCLCBuffers.setDescription('Number of buffers created ')
aiCLCFreeBuffers = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 37), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCFreeBuffers.setStatus('current')
if mibBuilder.loadTexts: aiCLCFreeBuffers.setDescription('Number of free buffers ')
aiCLCBufAllocErr = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCBufAllocErr.setStatus('current')
if mibBuilder.loadTexts: aiCLCBufAllocErr.setDescription('Number of buffer allocation errors ')
aiCLCBufAlign = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 39), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCBufAlign.setStatus('current')
if mibBuilder.loadTexts: aiCLCBufAlign.setDescription('Number of buffer re-alignments ')
aiCLCCpuXacts = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCpuXacts.setStatus('current')
if mibBuilder.loadTexts: aiCLCCpuXacts.setDescription('Number of inter-cpu transactions')
aiCLCSLCXacts = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 41), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCSLCXacts.setStatus('current')
if mibBuilder.loadTexts: aiCLCSLCXacts.setDescription('Number of SLC Window transactions ')
aiCLCConnectionsPlaced = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 42), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCConnectionsPlaced.setStatus('current')
if mibBuilder.loadTexts: aiCLCConnectionsPlaced.setDescription('Number of connections placed')
aiCLCTxTail = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 43), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCTxTail.setStatus('current')
if mibBuilder.loadTexts: aiCLCTxTail.setDescription('Number of TXTail misses ')
aiCLCEECRC = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 44), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCEECRC.setStatus('current')
if mibBuilder.loadTexts: aiCLCEECRC.setDescription('Configuration EEPROM CRC.')
aiCLCVersion = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 45), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCVersion.setStatus('current')
if mibBuilder.loadTexts: aiCLCVersion.setDescription('Software version, time, and date of currently executing software')
aiCLCBackupCLC = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 46), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("present", 1), ("notPresent", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCBackupCLC.setStatus('current')
if mibBuilder.loadTexts: aiCLCBackupCLC.setDescription('Status of the Backup CLC.')
aiCLCCpu = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 47), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("slotA", 1), ("slotB", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCpu.setStatus('current')
if mibBuilder.loadTexts: aiCLCCpu.setDescription('The location of the active CLC.')
aiCLCCpyConfig = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 48), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("copy", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCpyConfig.setStatus('current')
if mibBuilder.loadTexts: aiCLCCpyConfig.setDescription('Copy configuration from active CLC to backup CLC. A write of copy(2) causes the transfer to begin. A read will return copy(2) if a transfer is in progress and a none(1) if idle. A write of none(1) is not permitted and is flagged as an error.')
aiCLCDLWinVerbose = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDLWinVerbose.setStatus('current')
if mibBuilder.loadTexts: aiCLCDLWinVerbose.setDescription('Verbose report of Window Transactions.')
aiCLCDLWinIn = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDLWinIn.setStatus('current')
if mibBuilder.loadTexts: aiCLCDLWinIn.setDescription('Verbose report of incoming Window Transactions.')
aiCLCDLWinOut = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDLWinOut.setStatus('current')
if mibBuilder.loadTexts: aiCLCDLWinOut.setDescription('Verbose report of outgoing Window Transactions.')
aiCLCDLWinUni = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDLWinUni.setStatus('current')
if mibBuilder.loadTexts: aiCLCDLWinUni.setDescription('Verbose report of unified Window Transactions.')
aiCLCDLMsgAll = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDLMsgAll.setStatus('current')
if mibBuilder.loadTexts: aiCLCDLMsgAll.setDescription('Verbose report of log messages.')
aiCLCDLNoBody = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDLNoBody.setStatus('current')
if mibBuilder.loadTexts: aiCLCDLNoBody.setDescription('Report log messages headers only.')
aiCLCDLAlias = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDLAlias.setStatus('current')
if mibBuilder.loadTexts: aiCLCDLAlias.setDescription('Verbose report of alias translations.')
aiCLCDebugVal = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 56), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 143))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDebugVal.setStatus('current')
if mibBuilder.loadTexts: aiCLCDebugVal.setDescription('Value of the debug variable representing all debug combinations.')
aiCLCSwitchRestart = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 57), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("restart", 1), ("restartCfg", 2), ("nextCLC", 3), ("reset", 4), ("resetSLC", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCSwitchRestart.setStatus('current')
if mibBuilder.loadTexts: aiCLCSwitchRestart.setDescription('A write of this object causes the switch to be restarted in the designated mode. A read of this object always returns the value restart(1), which has no particular significance.')
aiCLCInitStrings = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 58), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("good", 1), ("bad", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCInitStrings.setStatus('current')
if mibBuilder.loadTexts: aiCLCInitStrings.setDescription('This object is used to test the condition of the strings on the CLC. A read of this object causes the test to be performed and then reports the outcome.')
aiCLCCopyFlash = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 59), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("none", 1), ("apbs", 2), ("apas", 3), ("asbs", 4), ("asap", 5), ("bpas", 6), ("bpbs", 7), ("bsbp", 8), ("bsas", 9)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCopyFlash.setStatus('current')
if mibBuilder.loadTexts: aiCLCCopyFlash.setDescription('Copy Flash from one bank to another. AP - Active Primary AS - Active Secondary BP - Backup Primary BS - Backup Secondary A read returns a value corresponding to the activity in progress. A write causes the requested transfer to begin. A write of none(1) is not permitted and is flagged as an error.')
aiCLCCopyFlashToSLC = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 60), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCopyFlashToSLC.setStatus('current')
if mibBuilder.loadTexts: aiCLCCopyFlashToSLC.setDescription("This object is used to begin or obtain the status of the SLC Download process. Writing a SLC base port to this object will cause the SLC at that baseport to search for new firmware on the active or backup CLC. If a valid SLC image is located, then the SLC will download that code and begin to run. A read of this variable will return the value 1 if a SLC download is in process, or a 0 if there aren't downloads in progress.")
aiCLCReadCommunity = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 61), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCReadCommunity.setStatus('current')
if mibBuilder.loadTexts: aiCLCReadCommunity.setDescription('The read community string for the CLC.')
aiCLCWriteCommunity = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 62), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCWriteCommunity.setStatus('current')
if mibBuilder.loadTexts: aiCLCWriteCommunity.setDescription('The write community string for the CLC.')
aiCLCIPAdrs = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 63), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCIPAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCIPAdrs.setDescription('The IP address for the CLC.')
aiCLCRouterIPAdrs = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 64), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRouterIPAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCRouterIPAdrs.setDescription('The router ip address for the CLC.')
aiCLCSubnetIPAdrs = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 65), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCSubnetIPAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCSubnetIPAdrs.setDescription('The subnet mask for the CLC. ')
aiCLCTrapTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 1, 66), )
if mibBuilder.loadTexts: aiCLCTrapTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCTrapTable.setDescription('A table of Trap destination IP addresses.')
aiCLCLastTrapMsgText = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 67), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 512))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCLastTrapMsgText.setStatus('current')
if mibBuilder.loadTexts: aiCLCLastTrapMsgText.setDescription('This is the message text associated with the last generated trap.')
aiCLCLastTrapMsgNum = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 68), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCLastTrapMsgNum.setStatus('current')
if mibBuilder.loadTexts: aiCLCLastTrapMsgNum.setDescription('This is the message number of the last generated trap log message.')
aiCLCCrashMsgText = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 69), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCrashMsgText.setStatus('current')
if mibBuilder.loadTexts: aiCLCCrashMsgText.setDescription('This is a place holder. It is required to allow verification of OID of trap crash message object. A read of this object will return an empty string.')
aiCLCNumEventsSinceLastTrap = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 70), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCNumEventsSinceLastTrap.setStatus('current')
if mibBuilder.loadTexts: aiCLCNumEventsSinceLastTrap.setDescription('This is the number of times an event that would generate a trap has occurred since the last time that trap was transmitted. The traps are not transmitted while the aiCLCTrapTimer is running. This number will accompany the next transmitted trap. This object is really a place holder. It is required to allow verification of the OID of this information in a trap (var-bind). A read of this object will result in an error from the snmp agent.')
aiCLCTrapTimer = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 71), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 65535)).clone(300)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTrapTimer.setStatus('current')
if mibBuilder.loadTexts: aiCLCTrapTimer.setDescription('After a trap is generated, a timer is started. If the event that generated the trap occurs while the timer is running, no trap will be generated for the event. The value of this object is the duration of the timer in SECONDS.')
aiCLCAsyncTrap = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 72), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAsyncTrap.setStatus('current')
if mibBuilder.loadTexts: aiCLCAsyncTrap.setDescription('When this object is enabled, link up/link down traps are sent to managers listed in the trap table. The traps are normally not used and must specifically be enabled by a manager.')
aiCLCTelnetServerPort = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 73), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(23)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTelnetServerPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCTelnetServerPort.setDescription('The tcp port number used by the telnet server may be configured using the aiCLCTelnetServerPort object. By default this object uses the well known port number 23.')
aiCLCColdStartTrapDelay = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 74), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 600))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCColdStartTrapDelay.setStatus('current')
if mibBuilder.loadTexts: aiCLCColdStartTrapDelay.setDescription('The sending of the cold start trap may be delayed to allow system startup and link startup to occur. This will typically be done on systems using IP over X.25 links. This value is specified in seconds.')
aiCLCFtpCtrlPort = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 75), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(21)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCFtpCtrlPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCFtpCtrlPort.setDescription('The FTP Server control port number. New values for this object take affect after a reset. The FTP Server data port is automatically selected to be one less than the control port.')
aiCLCBackupCLCHealth = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 76), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("present", 1), ("notPresent", 2), ("presentFaulted", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCBackupCLCHealth.setStatus('current')
if mibBuilder.loadTexts: aiCLCBackupCLCHealth.setDescription('Health status of the Backup CLC.')
aiCLCBanner = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 77), DisplayString().subtype(subtypeSpec=ValueRangeConstraint(0, 1170))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCBanner.setStatus('current')
if mibBuilder.loadTexts: aiCLCBanner.setDescription('The banner for the CLC. There is a maximum 15 lines with 76 characters allowed per line.')
aiCLCTimeZone = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 78), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-720, 720))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTimeZone.setStatus('current')
if mibBuilder.loadTexts: aiCLCTimeZone.setDescription('The time zone offset for the CLC in minutes.')
aiCLCDaylightSavings = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 79), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDaylightSavings.setStatus('current')
if mibBuilder.loadTexts: aiCLCDaylightSavings.setDescription('Daylight Savings')
aiCLCSNTP = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 80), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCSNTP.setStatus('current')
if mibBuilder.loadTexts: aiCLCSNTP.setDescription('SNTP')
aiCLCSNTPPrimaryServer = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 81), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCSNTPPrimaryServer.setStatus('current')
if mibBuilder.loadTexts: aiCLCSNTPPrimaryServer.setDescription('The IP address for the Primary SNTP Server.')
aiCLCSNTPSecondaryServer = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 82), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCSNTPSecondaryServer.setStatus('current')
if mibBuilder.loadTexts: aiCLCSNTPSecondaryServer.setDescription('The IP address for the Secondary SNTP Server.')
aiCLCSNTPPollInterval = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 83), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCSNTPPollInterval.setStatus('current')
if mibBuilder.loadTexts: aiCLCSNTPPollInterval.setDescription('SNTP Poll Interval')
aiCLCRadiusEnabled = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 84), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("localFallback", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRadiusEnabled.setStatus('current')
if mibBuilder.loadTexts: aiCLCRadiusEnabled.setDescription('RADIUS enabled/disabled state.')
aiCLCRadiusAddr1 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 85), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRadiusAddr1.setStatus('current')
if mibBuilder.loadTexts: aiCLCRadiusAddr1.setDescription('The IP address for the Primary RADIUS Server.')
aiCLCRadiusPort1 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 86), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1812)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRadiusPort1.setStatus('current')
if mibBuilder.loadTexts: aiCLCRadiusPort1.setDescription('The port number associated with the Primary RADIUS Server.')
aiCLCRadiusSecret1 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 87), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24)).clone('applied')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRadiusSecret1.setStatus('current')
if mibBuilder.loadTexts: aiCLCRadiusSecret1.setDescription('The Secret for the Primary RADIUS Server.')
aiCLCRadiusAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 88), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRadiusAddr2.setStatus('current')
if mibBuilder.loadTexts: aiCLCRadiusAddr2.setDescription('The IP address for the Secondary RADIUS Server.')
aiCLCRadiusPort2 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 89), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(1812)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRadiusPort2.setStatus('current')
if mibBuilder.loadTexts: aiCLCRadiusPort2.setDescription('The port number associated with the Secondary RADIUS Server.')
aiCLCRadiusSecret2 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 90), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24)).clone('applied')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCRadiusSecret2.setStatus('current')
if mibBuilder.loadTexts: aiCLCRadiusSecret2.setDescription('The Secret for the Secondary RADIUS Server.')
aiCLCTrapInterval = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 91), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTrapInterval.setStatus('current')
if mibBuilder.loadTexts: aiCLCTrapInterval.setDescription('The interval of the faulted primary CLC trap. If the primary CLC was faulted and the interval was set between 1 and 65535 minutes, the backup CLC will repeatedly send the faulted primary CLC trap. To disable this trap, set the interval to 0. If reset the interval to 0 after the primary CLC has been faulted, the backup CLC will stop sending the trap. New value for this object will take affect without rebooting the switch. This object has no effect on other traps.')
aiCLCTacacsEnabled = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 92), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1), ("localFallback", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTacacsEnabled.setStatus('current')
if mibBuilder.loadTexts: aiCLCTacacsEnabled.setDescription('TACACS+ enabled/disabled state.')
aiCLCTacacsAddr1 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 93), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTacacsAddr1.setStatus('current')
if mibBuilder.loadTexts: aiCLCTacacsAddr1.setDescription('The IP address for the Primary TACACS Server.')
aiCLCTacacsPort1 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 94), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(49)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTacacsPort1.setStatus('current')
if mibBuilder.loadTexts: aiCLCTacacsPort1.setDescription('The port number associated with the Primary TACACS Server.')
aiCLCTacacsSecret1 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 95), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24)).clone('applied')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTacacsSecret1.setStatus('current')
if mibBuilder.loadTexts: aiCLCTacacsSecret1.setDescription('The Secret for the Primary TACACS Server.')
aiCLCTacacsAddr2 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 96), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTacacsAddr2.setStatus('current')
if mibBuilder.loadTexts: aiCLCTacacsAddr2.setDescription('The IP address for the Secondary TACACS Server.')
aiCLCTacacsPort2 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 97), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(49)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTacacsPort2.setStatus('current')
if mibBuilder.loadTexts: aiCLCTacacsPort2.setDescription('The port number associated with the Secondary TACACS Server.')
aiCLCTacacsSecret2 = MibScalar((1, 3, 6, 1, 4, 1, 539, 9, 1, 98), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24)).clone('applied')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCTacacsSecret2.setStatus('current')
if mibBuilder.loadTexts: aiCLCTacacsSecret2.setDescription('The Secret for the Secondary TACACS Server.')
aiCLCTrapTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 1, 66, 1), ).setIndexNames((0, "AI198CLC-MIB", "aiCLCTrapIPAdrs"))
if mibBuilder.loadTexts: aiCLCTrapTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCTrapTableEntry.setDescription('Information about a particular Trap destination.')
aiCLCTrapIPAdrs = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 1, 66, 1, 1), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiCLCTrapIPAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCTrapIPAdrs.setDescription('The IP Address of the destination to which SNMP Traps will be sent.')
aiCLCTrapRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 1, 66, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiCLCTrapRowStatus.setStatus('current')
if mibBuilder.loadTexts: aiCLCTrapRowStatus.setDescription('The aiCLC Trap Table entry row status.')
aiCLCCardTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 2), )
if mibBuilder.loadTexts: aiCLCCardTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCCardTable.setDescription('A table of line cards contained in an AISwitch.')
aiCLCCardTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 2, 1), ).setIndexNames((0, "AI198CLC-MIB", "aiCLCCTIndex"))
if mibBuilder.loadTexts: aiCLCCardTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCCardTableEntry.setDescription('Information about a particular line card.')
aiCLCCTIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTIndex.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTIndex.setDescription('The card table index.')
aiCLCCTAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTAdminStatus.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTAdminStatus.setDescription('This represents the state of the card and may be used to change the state of the card. For DUMB cards if one port on the card is up, then the entire card is considered to be up. ')
aiCLCCTBasePort = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTBasePort.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTBasePort.setDescription('The base port number for the line card.')
aiCLCCTHighPort = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCTHighPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTHighPort.setDescription('The highest port number accessible by the line card.')
aiCLCCTRdCommStr = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTRdCommStr.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTRdCommStr.setDescription('The SNMP read community string by which this card is known.')
aiCLCCTWrCommStr = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 6), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTWrCommStr.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTWrCommStr.setDescription('The SNMP write community string by which this card is known.')
aiCLCCTCardSnmpState = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nosnmp", 1), ("snmpProxy", 2), ("snmpDirect", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCTCardSnmpState.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTCardSnmpState.setDescription("This field describes the capabilities of the card. A card may not be snmp capable and will have the value nosnmp(1). A card may be snmp capable but isn't present on the IP network. This card is may proxied for and will have the type snmpProxy(2). The last type of snmp capability is where are card is present on the IP network and can be managed directly. This card will have a type of snmpDirect(3). ")
aiCLCCTCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("asynch", 1), ("aslc", 2), ("ethernet", 3), ("x25", 4), ("asp", 5), ("islc", 6), ("ai2524", 7), ("ai294", 8), ("ai196im", 9), ("x25m", 10), ("islc1", 11), ("ai296", 12), ("ai285", 13), ("ai232", 14), ("ai196ILEG", 15), ("aimod", 16), ("aiflx", 17), ("empty", 18), ("ai120", 19), ("aie1", 20), ("aitc", 21), ("aifocus", 22), ("wanE1", 23), ("wanT1", 24))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTCardType.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTCardType.setDescription('The line card type.')
aiCLCCTSlotExp = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTSlotExp.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTSlotExp.setDescription('The number of slots the line card is to logically occupy.')
aiCLCCTIPAdrs = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTIPAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTIPAdrs.setDescription('The IP address associated with the line card.')
aiCLCCTRtrIPAdrs = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTRtrIPAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTRtrIPAdrs.setDescription('The router ip address for this line card.')
aiCLCCTSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 12), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTSubnetMask.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTSubnetMask.setDescription('The subnet mask for this line card. ')
aiCLCCTAutoIdIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCTAutoIdIndex.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTAutoIdIndex.setDescription('The index into the Auto Id table associated with this line card.')
aiCLCCTSysOID = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 14), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCTSysOID.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTSysOID.setDescription('The SNMP System OID associated with this line card.')
aiCLCCTRealCardType = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24))).clone(namedValues=NamedValues(("asynch", 1), ("aslc", 2), ("ethernet", 3), ("x25", 4), ("asp", 5), ("islc", 6), ("ai2524", 7), ("ai294", 8), ("ai196im", 9), ("x25m", 10), ("islc1", 11), ("ai296", 12), ("ai285", 13), ("ai232", 14), ("ai196ILEG", 15), ("aimod", 16), ("aiflx", 17), ("empty", 18), ("ai120", 19), ("aie1", 20), ("aitc", 21), ("aifocus", 22), ("wanE1", 23), ("wanT1", 24))).clone(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCTRealCardType.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTRealCardType.setDescription('The real line card type.')
aiCLCCTIPRange = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTIPRange.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTIPRange.setDescription('The IP address range of this line card.')
aiCLCCTTelnetPort = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65534))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTTelnetPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTTelnetPort.setDescription('The telnet port of this line card.')
aiCLCCTCardReset = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("na", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTCardReset.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTCardReset.setDescription('Card is included when * is used with STPSLC, DISABL, or ENABL.')
aiCLCCTLastSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCCTLastSequenceNumber.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTLastSequenceNumber.setDescription('This is the sequence number of the last trap sent by this card. The sequence number starts at zero following a hardware reset or power-up. When the sequence number reaches 0xffffffff, it rolls over to 0 on the next trap.')
aiCLCCTRtr2IPAdrs = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 2, 1, 20), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCTRtr2IPAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCCTRtr2IPAdrs.setDescription('The secondary router ip address for this line card.')
aiCLCPortTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 3), )
if mibBuilder.loadTexts: aiCLCPortTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortTable.setDescription('A table of port information.')
aiCLCPortTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 3, 1), ).setIndexNames((0, "AI198CLC-MIB", "aiCLCPortNumber"))
if mibBuilder.loadTexts: aiCLCPortTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortTableEntry.setDescription('Information unique to a particular port.')
aiCLCPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCPortNumber.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortNumber.setDescription('The AISwitch Port Number associated with the entry.')
aiCLCPortType = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("user", 1), ("destination", 2), ("actConn", 3), ("dedicated", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortType.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortType.setDescription('This is used to configure how the port is being used.')
aiCLCPortDedicated = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortDedicated.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortDedicated.setDescription("The port number to which this port is dedicated when the type is 'dedicated'.")
aiCLCPortDestName = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortDestName.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortDestName.setDescription('The destination to which this port is assigned.')
aiCLCPortEcho = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortEcho.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortEcho.setDescription('This determines whether echoing is on when the port is connected to the AISwitch.')
aiCLCPortDestMenu = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortDestMenu.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortDestMenu.setDescription("This determines whether the destination menu is displayed when the port type is 'user'.")
aiCLCPortQueue = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortQueue.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortQueue.setDescription('This determines whether the port is allowed to be put on hold when the destination port is busy.')
aiCLCSLCProtocolCode = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCSLCProtocolCode.setStatus('current')
if mibBuilder.loadTexts: aiCLCSLCProtocolCode.setDescription('This is the slc protocol processing code.')
aiCLCPortState = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCPortState.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortState.setDescription('This is used to determine whether the port is enabled or disabled.')
aiCLCPortStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20))).clone(namedValues=NamedValues(("idle", 1), ("selcos", 2), ("pswd", 3), ("uname", 4), ("dna", 5), ("tcp", 6), ("queue", 7), ("holdq", 8), ("waitq", 9), ("ai", 10), ("conn", 11), ("preconn", 12), ("predisc", 13), ("hold", 14), ("netconn", 15), ("file", 16), ("inact", 17), ("swdwn", 18), ("telnetClient", 19), ("unknown", 20)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCPortStatus.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortStatus.setDescription("This value is the port status which include the following values; idle(1), selecting class of service selcos(2), entering password pswd(3), entering username(4), entering destination network address dna(5), entering a TCP address tcp(6), answering 'wish to queue' queue(7), answering 'wish to hold' holdq(8), connected to switch ai(9), connected conn(10), in the process of connecting preconn(11), in the process of disconnecting predisc(12), hold(13), network connect pending netconn(14), performing a file transfer file(15), inactive inact(16), slc is receiving software download swdwn(17), port is using a telnet client telnetClient(18), unknown(20).")
aiCLCPortAlm = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 9))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCPortAlm.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortAlm.setDescription('The current alarm value for the port.')
aiCLCPortDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 29))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortDesc.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortDesc.setDescription('This is used to describe the port in textual form.')
aiCLCPortReset = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCPortReset.setStatus('current')
if mibBuilder.loadTexts: aiCLCPortReset.setDescription('Port is included when * is used with DISABL or ENABL.')
aiCLCAliasTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 4), )
if mibBuilder.loadTexts: aiCLCAliasTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCAliasTable.setDescription('A table of call alias information.')
aiCLCAliasTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 4, 1), ).setIndexNames((1, "AI198CLC-MIB", "aiCLCAliasIndex"))
if mibBuilder.loadTexts: aiCLCAliasTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCAliasTableEntry.setDescription('Information unique to a particular alias.')
aiCLCAliasIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 200))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiCLCAliasIndex.setStatus('current')
if mibBuilder.loadTexts: aiCLCAliasIndex.setDescription('The alias name in the form of a DisplayString. This is the key field for the Alias Table.')
aiCLCAliasRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiCLCAliasRowStatus.setStatus('current')
if mibBuilder.loadTexts: aiCLCAliasRowStatus.setDescription('The Alias Table Entry row status.')
aiCLCXlatType = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("simple", 1), ("muxconn", 2), ("muxxlat", 3), ("slcroute", 4))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCXlatType.setStatus('current')
if mibBuilder.loadTexts: aiCLCXlatType.setDescription('The type of alias translation to be performed.')
aiCLCAliasDestName = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 4), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAliasDestName.setStatus('current')
if mibBuilder.loadTexts: aiCLCAliasDestName.setDescription('The destination to be used for the alias.')
aiCLCCalledAdrs = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 5), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCalledAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCCalledAdrs.setDescription('The called address used in the macro.')
aiCLCAliasDestMenu = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAliasDestMenu.setStatus('current')
if mibBuilder.loadTexts: aiCLCAliasDestMenu.setDescription('This determines whether the alias appears on the destination menu.')
aiCLCLinkNum = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 7), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCLinkNum.setStatus('current')
if mibBuilder.loadTexts: aiCLCLinkNum.setDescription('The link number or alias macro used for the link number.')
aiCLCCallerAdrs = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 8), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCallerAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCCallerAdrs.setDescription('The caller address used in the macro.')
aiCLCCallData = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 9), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCallData.setStatus('current')
if mibBuilder.loadTexts: aiCLCCallData.setDescription('The call data which may be a destination or an alias macro.')
aiCLCApplicString = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 10), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCApplicString.setStatus('current')
if mibBuilder.loadTexts: aiCLCApplicString.setDescription('The application string which may be a string or an alias macro.')
aiCLCCalledProtoStr = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 11), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCalledProtoStr.setStatus('current')
if mibBuilder.loadTexts: aiCLCCalledProtoStr.setDescription('The string that may specify the called protocol for a call using the alias macro.')
aiCLCCallerProtoStr = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 12), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCCallerProtoStr.setStatus('current')
if mibBuilder.loadTexts: aiCLCCallerProtoStr.setDescription('The string that may specify the calling protocol for a call using the alias macro.')
aiCLCAlternRoute = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAlternRoute.setStatus('current')
if mibBuilder.loadTexts: aiCLCAlternRoute.setDescription('The string may specify a destination or an alias macro that is used as an alternate route.')
aiCLCAliasPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 4, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 5)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAliasPosition.setStatus('current')
if mibBuilder.loadTexts: aiCLCAliasPosition.setDescription("The position of the alias in the alias list. When 'set' a new or an existing alias, this value can be used as a flag to request a saving to the beginning (0) or to the end (99999) of the alias list. As default, the CLC always saves a new alias to the end and a modified alias to its old position.")
aiCLCDestTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 5), )
if mibBuilder.loadTexts: aiCLCDestTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestTable.setDescription('This table contains information pertaining to destinations and their attributes.')
aiCLCDestTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 5, 1), ).setIndexNames((1, "AI198CLC-MIB", "aiCLCDestName"))
if mibBuilder.loadTexts: aiCLCDestTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestTableEntry.setDescription('This information pertains to one entry in the destination table.')
aiCLCDestName = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiCLCDestName.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestName.setDescription('The name of the destination in the form of an OCTET STRING.')
aiCLCDestRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("active", 1), ("notInService", 2), ("notReady", 3), ("createAndGo", 4), ("createAndWait", 5), ("destroy", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: aiCLCDestRowStatus.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestRowStatus.setDescription('The key field for the Destination table entry.')
aiCLCDestCallInit = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestCallInit.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestCallInit.setDescription('This is used to turn on or turn off call initiation on ports assigned to this destination.')
aiCLCDestDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestDisc.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestDisc.setDescription("This is used to turn on or turn off the user's disconnect keys when connected to this destination.")
aiCLCDestDispMenu = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestDispMenu.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestDispMenu.setDescription('This is used to turn on or turn off the display of the destination name on the destination menu.')
aiCLCDestBaud = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestBaud.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestBaud.setDescription('This is used to turn on or turn off whether the baud rate is checked before connecting to the destination.')
aiCLCDestIsSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("yes", 1), ("no", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestIsSwitch.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestIsSwitch.setDescription('This is used to indicate that the destination is another AI switch.')
aiCLCDestTmrType = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("actTmr", 1), ("sessTmr", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestTmrType.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestTmrType.setDescription('This is used to set the type of timer associated with the destination.')
aiCLCDestTmrVal = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4368000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestTmrVal.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestTmrVal.setDescription('This value is the timer duration in milliseconds ranging from 1mS to 4368000mS or about 72 hours.')
aiCLCDestTmrDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4368000)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestTmrDelay.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestTmrDelay.setDescription('This value is the delay in milliseconds before allowing further calls on the destination after a call terminates. The range is 1mS to 4368000mS or about 72 hours.')
aiCLCDestPswd = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestPswd.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestPswd.setDescription('This is password associated with the destination.')
aiCLCDestQPswd = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestQPswd.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestQPswd.setDescription('This is password used to control access to the queue management functions associated with the destination.')
aiCLCDestMenuMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 13), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestMenuMsg.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestMenuMsg.setDescription('This string is displayed next to the destination in the destination menu.')
aiCLCDestConnMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 14), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestConnMsg.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestConnMsg.setDescription('This string is forced out the destination port when a connection begins.')
aiCLCDestDiscMsg = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 15), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestDiscMsg.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestDiscMsg.setDescription('This string is forced out the destination port when a connection terminates.')
aiCLCDestState = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestState.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestState.setDescription('This is used to enable or disable the destination.')
aiCLCDestNumPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCDestNumPorts.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestNumPorts.setDescription('This is used to determine the number of ports assigned to this destination.')
aiCLCDestNumUsed = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCDestNumUsed.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestNumUsed.setDescription('This is used to determine the number of ports in use for this destination.')
aiCLCDestNumFree = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCDestNumFree.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestNumFree.setDescription('This is used to determine the number of ports that are free for this destination.')
aiCLCDestQHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 20), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65536))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCDestQHigh.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestQHigh.setDescription('This is used to determine the maximum number of ports that were queued to this destination.')
aiCLCDestPortList = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 21), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCDestPortList.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestPortList.setDescription('This string contains a list of port numbers assigned to this destination.')
aiCLCDestWaitForPort = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 5, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCDestWaitForPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCDestWaitForPort.setDescription('This is used to allow the user to wait for a port when all ports for the destination are busy.')
aiCLCAsyncTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 6), )
if mibBuilder.loadTexts: aiCLCAsyncTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCAsyncTable.setDescription('The Async Table.')
aiCLCAsyncTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 6, 1), ).setIndexNames((0, "AI198CLC-MIB", "aiCLCAsyncifIndex"))
if mibBuilder.loadTexts: aiCLCAsyncTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCAsyncTableEntry.setDescription('An Async Table entry.')
aiCLCAsyncifIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAsyncifIndex.setStatus('current')
if mibBuilder.loadTexts: aiCLCAsyncifIndex.setDescription('The ifIndex from the interfaces table.')
aiCLCAsyncPort = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAsyncPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCAsyncPort.setDescription('The AISwitch port number.')
aiCLCAsyncAdminStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAsyncAdminStatus.setStatus('current')
if mibBuilder.loadTexts: aiCLCAsyncAdminStatus.setDescription('The key field for the Async table entry.')
aiCLCAsyncDiscType = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("nobrkdisc", 1), ("brkdisc", 2), ("longbrkdisc", 3))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCAsyncDiscType.setStatus('current')
if mibBuilder.loadTexts: aiCLCAsyncDiscType.setDescription('The disconnect type for the async port.')
aiCLCEIASignals = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("eiaDisabled", 1), ("dsrRtsPass", 2), ("dsrOffDisc", 3), ("dsrOnOffDisc", 4), ("dcdOffDisc", 5), ("dcdOnOffDisc", 6))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCEIASignals.setStatus('current')
if mibBuilder.loadTexts: aiCLCEIASignals.setDescription('The EIA signals may be disabled (eiaDisabled(1)) or configured for pass through (dsrRtsPass(2)). Additionally the port can be configured to disconnect on loss of DSR (dsrOffDisc(3)), disconnect on change of state of DSR (dsrOnOffDisc(4)), disconnect on loss of DCD (dcdOffDisc(5)), or disconnect on change of state of DCD (dcdOnOffDisc(6)).')
aiCLCEIARtsDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCEIARtsDisc.setStatus('current')
if mibBuilder.loadTexts: aiCLCEIARtsDisc.setDescription('Upon disconnect RTS may be configured to be on(1), or off(2).')
aiCLCEIADtrDisc = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCEIADtrDisc.setStatus('current')
if mibBuilder.loadTexts: aiCLCEIADtrDisc.setDescription('Upon disconnect DTR may be configured to be on(1), or off(2).')
aiCLCEIARtsConn = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCEIARtsConn.setStatus('current')
if mibBuilder.loadTexts: aiCLCEIARtsConn.setDescription('Upon connect RTS may be configured to be on(1), or off(2).')
aiCLCEIADtrConn = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCEIADtrConn.setStatus('current')
if mibBuilder.loadTexts: aiCLCEIADtrConn.setDescription('Upon connect DTR may be configured to be on(1), or off(2).')
aiCLCEIARtsToggle = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCEIARtsToggle.setStatus('current')
if mibBuilder.loadTexts: aiCLCEIARtsToggle.setDescription('Upon disconnect RTS may be configured to toggle (on(1)) or not (off(2)).')
aiCLCEIADtrToggle = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 6, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2))).clone(2)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: aiCLCEIADtrToggle.setStatus('current')
if mibBuilder.loadTexts: aiCLCEIADtrToggle.setDescription('Upon disconnect DTR may be configured to toggle (on(1)) or not (off(2)).')
aiCLCAutoIDTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 7), )
if mibBuilder.loadTexts: aiCLCAutoIDTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCAutoIDTable.setDescription('A table of board identification information for an AISwitch.')
aiCLCAutoIDTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 7, 1), ).setIndexNames((0, "AI198CLC-MIB", "aiCLCAIDIndex"))
if mibBuilder.loadTexts: aiCLCAutoIDTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCAutoIDTableEntry.setDescription('Board Identification information for a particular card.')
aiCLCAIDIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAIDIndex.setStatus('current')
if mibBuilder.loadTexts: aiCLCAIDIndex.setDescription('The Auto ID Table index.')
aiCLCAIDPort = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 7, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAIDPort.setStatus('current')
if mibBuilder.loadTexts: aiCLCAIDPort.setDescription('The port number where the card resides. If the port number is not valid then 256 will be reported.')
aiCLCAIDProduct = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 7, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAIDProduct.setStatus('current')
if mibBuilder.loadTexts: aiCLCAIDProduct.setDescription('The product name for the card.')
aiCLCAIDSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 7, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAIDSerialNumber.setStatus('current')
if mibBuilder.loadTexts: aiCLCAIDSerialNumber.setDescription('The serial number for the card.')
aiCLCAIDManufDate = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 7, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAIDManufDate.setStatus('current')
if mibBuilder.loadTexts: aiCLCAIDManufDate.setDescription('The date of manufacture for the card.')
aiCLCAIDMACAdrs = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 7, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAIDMACAdrs.setStatus('current')
if mibBuilder.loadTexts: aiCLCAIDMACAdrs.setDescription('The MAC address for the card.')
aiCLCAI2524LinkTable = MibTable((1, 3, 6, 1, 4, 1, 539, 9, 8), )
if mibBuilder.loadTexts: aiCLCAI2524LinkTable.setStatus('current')
if mibBuilder.loadTexts: aiCLCAI2524LinkTable.setDescription('A table of link status for AI2524 Router Cards.')
aiCLCAI2524LinkTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 539, 9, 8, 1), ).setIndexNames((0, "AI198CLC-MIB", "aiCLCAI2524Port"))
if mibBuilder.loadTexts: aiCLCAI2524LinkTableEntry.setStatus('current')
if mibBuilder.loadTexts: aiCLCAI2524LinkTableEntry.setDescription('Link information particular to AI2524 Router Cards.')
aiCLCAI2524Port = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAI2524Port.setStatus('current')
if mibBuilder.loadTexts: aiCLCAI2524Port.setDescription('The port number for the AI2524 Router Card. ')
aiCLCAI2524LinkStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 539, 9, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: aiCLCAI2524LinkStatus.setStatus('current')
if mibBuilder.loadTexts: aiCLCAI2524LinkStatus.setDescription('The 10BT link status for the AI2524 Router Card.')
mibBuilder.exportSymbols("AI198CLC-MIB", aiCLCActLogLvl=aiCLCActLogLvl, aiCLCRadiusPort2=aiCLCRadiusPort2, aiCLCCTCardType=aiCLCCTCardType, aiCLCCpu=aiCLCCpu, aiCLCLastTrapMsgText=aiCLCLastTrapMsgText, ai198Ver103=ai198Ver103, aiCLCCTIPAdrs=aiCLCCTIPAdrs, aiCLCAliasPosition=aiCLCAliasPosition, aiCLCDestTmrVal=aiCLCDestTmrVal, aiCLCAsyncTable=aiCLCAsyncTable, aii=aii, aiCLCRadiusAddr1=aiCLCRadiusAddr1, aiCLCEIADtrConn=aiCLCEIADtrConn, ai198Ver102=ai198Ver102, aiCLCSystem=aiCLCSystem, aiCLCNodeName=aiCLCNodeName, aiCLCCopyFlash=aiCLCCopyFlash, aiCLCBox3DensAdmin=aiCLCBox3DensAdmin, aiCLCPortEcho=aiCLCPortEcho, aiCLCLongBrkLen=aiCLCLongBrkLen, aiCLCCpuXacts=aiCLCCpuXacts, aiCLCDebugVal=aiCLCDebugVal, aiCLCCrashMsgText=aiCLCCrashMsgText, aiCLCAI2524Port=aiCLCAI2524Port, aiCLCCTBasePort=aiCLCCTBasePort, aiCLCPortType=aiCLCPortType, aiCLCDestRowStatus=aiCLCDestRowStatus, aiCLCTacacsSecret2=aiCLCTacacsSecret2, aiCLCSNTPPollInterval=aiCLCSNTPPollInterval, aiCLCAsyncAdminStatus=aiCLCAsyncAdminStatus, aiCLCEIADtrToggle=aiCLCEIADtrToggle, aiCLCXlatType=aiCLCXlatType, aiCLCTacacsAddr1=aiCLCTacacsAddr1, aiCLC=aiCLC, aiCLCTrapTableEntry=aiCLCTrapTableEntry, aiCLCDLAlias=aiCLCDLAlias, aiCLCIPAdrs=aiCLCIPAdrs, aiCLCBox7DensAdmin=aiCLCBox7DensAdmin, aiCLCSNTP=aiCLCSNTP, aiCLCTrapIPAdrs=aiCLCTrapIPAdrs, aiCLCCalledAdrs=aiCLCCalledAdrs, ai198Ver130=ai198Ver130, aiCLCCpyConfig=aiCLCCpyConfig, aiCLCFreeEE=aiCLCFreeEE, aiCLCBufAllocErr=aiCLCBufAllocErr, aiCLCCTAdminStatus=aiCLCCTAdminStatus, aiCLCAliasDestMenu=aiCLCAliasDestMenu, aiCLCDestQHigh=aiCLCDestQHigh, ai198Ver104=ai198Ver104, aiCLCSLCXacts=aiCLCSLCXacts, aiCLCCardTableEntry=aiCLCCardTableEntry, aiCLCQueuedPorts=aiCLCQueuedPorts, aiCLCMajorAlmMax=aiCLCMajorAlmMax, aiCLCDestDispMenu=aiCLCDestDispMenu, aiCLCPortReset=aiCLCPortReset, aiCLCBox1DensAdmin=aiCLCBox1DensAdmin, aiCLCAutoCLCUpdate=aiCLCAutoCLCUpdate, aiCLCAsyncPort=aiCLCAsyncPort, aiCLCPortStatus=aiCLCPortStatus, aiCLCPortDestName=aiCLCPortDestName, aiCLCAliasIndex=aiCLCAliasIndex, aiCLCTrapTimer=aiCLCTrapTimer, PYSNMP_MODULE_ID=aiCLC, aiCLCAsyncDiscType=aiCLCAsyncDiscType, aiCLCRadiusAddr2=aiCLCRadiusAddr2, aiCLCCTSysOID=aiCLCCTSysOID, aiCLCColdStartTrapDelay=aiCLCColdStartTrapDelay, aiCLCDestWaitForPort=aiCLCDestWaitForPort, aiCLCBox6DensAdmin=aiCLCBox6DensAdmin, aiCLCAIDPort=aiCLCAIDPort, aiCLCAliasTableEntry=aiCLCAliasTableEntry, aiCLCTacacsEnabled=aiCLCTacacsEnabled, ai198Ver1=ai198Ver1, aiCLCPortQueue=aiCLCPortQueue, aiCLCAIDSerialNumber=aiCLCAIDSerialNumber, aiCLCTrapRowStatus=aiCLCTrapRowStatus, aiCLCPortAlm=aiCLCPortAlm, aiCLCAliasRowStatus=aiCLCAliasRowStatus, aiCLCAutoIDTableEntry=aiCLCAutoIDTableEntry, ai198Ver120=ai198Ver120, aiCLCCTIndex=aiCLCCTIndex, aiCLCRadiusSecret1=aiCLCRadiusSecret1, aiCLCVersion=aiCLCVersion, aiCLCCTRtr2IPAdrs=aiCLCCTRtr2IPAdrs, aiCLCCardTable=aiCLCCardTable, aiCLCEIARtsDisc=aiCLCEIARtsDisc, ai198Ver13=ai198Ver13, aiCLCDownSpd=aiCLCDownSpd, aiCLCSLCProtocolCode=aiCLCSLCProtocolCode, aiCLCCallerProtoStr=aiCLCCallerProtoStr, aiCLCCTSubnetMask=aiCLCCTSubnetMask, ai198Ver12=ai198Ver12, aiCLCSubnetIPAdrs=aiCLCSubnetIPAdrs, aiCLCFaultSwitch=aiCLCFaultSwitch, aiCLCTacacsSecret1=aiCLCTacacsSecret1, aiCLCConnInfo=aiCLCConnInfo, aiCLCTacacsPort2=aiCLCTacacsPort2, aiCLCSNTPSecondaryServer=aiCLCSNTPSecondaryServer, aiCLCAliasDestName=aiCLCAliasDestName, aiCLCAutoIDTable=aiCLCAutoIDTable, aiCLCMajorAlmMin=aiCLCMajorAlmMin, aiCLCRadiusEnabled=aiCLCRadiusEnabled, aiCLCDestNumPorts=aiCLCDestNumPorts, aiCLCDestMenuFmt=aiCLCDestMenuFmt, aiCLCBuffers=aiCLCBuffers, aiCLCCallerAdrs=aiCLCCallerAdrs, aiCLCDestPortList=aiCLCDestPortList, aiCLCDestCallInit=aiCLCDestCallInit, aiCLCReadCommunity=aiCLCReadCommunity, ai198=ai198, aiCLCDestTmrDelay=aiCLCDestTmrDelay, aiCLCAIDMACAdrs=aiCLCAIDMACAdrs, aiCLCCTCardReset=aiCLCCTCardReset, aiCLCAlternRoute=aiCLCAlternRoute, aiCLCCaamlRetryTmr=aiCLCCaamlRetryTmr, aiCLCAIDIndex=aiCLCAIDIndex, aiCLCCTWrCommStr=aiCLCCTWrCommStr, aiCLCPortTable=aiCLCPortTable, aiCLCDestDiscMsg=aiCLCDestDiscMsg, aiCLCCTRealCardType=aiCLCCTRealCardType, aiCLCTacacsPort1=aiCLCTacacsPort1, aiCLCEIASignals=aiCLCEIASignals, aiCLCBanner=aiCLCBanner, aiCLCLogPortEnable=aiCLCLogPortEnable, aiCLCEIARtsConn=aiCLCEIARtsConn, aiCLCHoldConn=aiCLCHoldConn, aiCLCEECRC=aiCLCEECRC, aiCLCDestBaud=aiCLCDestBaud, aiCLCCaamlIdleTmr=aiCLCCaamlIdleTmr, aiCLCBox2DensAdmin=aiCLCBox2DensAdmin, aiCLCDLWinIn=aiCLCDLWinIn, aiCLCDLNoBody=aiCLCDLNoBody, aiCLCCTRtrIPAdrs=aiCLCCTRtrIPAdrs, aiCLCApplicString=aiCLCApplicString, aiCLCAIDManufDate=aiCLCAIDManufDate, aiCLCAI2524LinkTable=aiCLCAI2524LinkTable, aiCLCEIADtrDisc=aiCLCEIADtrDisc, aiCLCDLMsgAll=aiCLCDLMsgAll, aiCLCMinorAlmMin=aiCLCMinorAlmMin, aiCLCDLWinOut=aiCLCDLWinOut, aiCLCLastTrapMsgNum=aiCLCLastTrapMsgNum, aiCLCDestName=aiCLCDestName, aiCLCRadiusSecret2=aiCLCRadiusSecret2, aiCLCPortDestMenu=aiCLCPortDestMenu, aiCLCBox8DensAdmin=aiCLCBox8DensAdmin, aiCLCDestPswd=aiCLCDestPswd, aiCLCFreeBuffers=aiCLCFreeBuffers, aiCLCPortTableEntry=aiCLCPortTableEntry, aiCLCRouterIPAdrs=aiCLCRouterIPAdrs, aiCLCDestTableEntry=aiCLCDestTableEntry, aiCLCDestTmrType=aiCLCDestTmrType, aiCLCCaamlRoute=aiCLCCaamlRoute, aiCLCCraftLogEcho=aiCLCCraftLogEcho, aiCLCDLWinVerbose=aiCLCDLWinVerbose, aiCLCWriteCommunity=aiCLCWriteCommunity, aiCLCDaylightSavings=aiCLCDaylightSavings, aiCLCCTRdCommStr=aiCLCCTRdCommStr, aiCLCDestDisc=aiCLCDestDisc, aiCLCPortDesc=aiCLCPortDesc, aiCLCFtpCtrlPort=aiCLCFtpCtrlPort, aiCLCAlmLogPort=aiCLCAlmLogPort, aiCLCTimeDate=aiCLCTimeDate, aiCLCCTLastSequenceNumber=aiCLCCTLastSequenceNumber, aiCLCAIDProduct=aiCLCAIDProduct, aiCLCCTIPRange=aiCLCCTIPRange, aiCLCCTTelnetPort=aiCLCCTTelnetPort, aiCLCRstTimeDate=aiCLCRstTimeDate, aiCLCConnectionsPlaced=aiCLCConnectionsPlaced, aiCLCSNTPPrimaryServer=aiCLCSNTPPrimaryServer, aiCLCEIARtsToggle=aiCLCEIARtsToggle, aiCLCPortDedicated=aiCLCPortDedicated, aiCLCBox5DensAdmin=aiCLCBox5DensAdmin, aiCLCDestNumUsed=aiCLCDestNumUsed, aiCLCMinorAlmMax=aiCLCMinorAlmMax, aiCLCCallData=aiCLCCallData, aiCLCDestMenuMsg=aiCLCDestMenuMsg, aiCLCPortState=aiCLCPortState, aiCLCCopyFlashToSLC=aiCLCCopyFlashToSLC, aiCLCCalledProtoStr=aiCLCCalledProtoStr, aiCLCEEPromFaults=aiCLCEEPromFaults, aiCLCCTHighPort=aiCLCCTHighPort, aiCLCDLWinUni=aiCLCDLWinUni, aiCLCBox4DensAdmin=aiCLCBox4DensAdmin, aiCLCAI2524LinkTableEntry=aiCLCAI2524LinkTableEntry, aiCLCDestTable=aiCLCDestTable, aiCLCAsyncTableEntry=aiCLCAsyncTableEntry, aiCLCNumEventsSinceLastTrap=aiCLCNumEventsSinceLastTrap, aiCLCDestIsSwitch=aiCLCDestIsSwitch, aiCLCSwitchRestart=aiCLCSwitchRestart, aiCLCLinkNum=aiCLCLinkNum, aiCLCBackupCLCHealth=aiCLCBackupCLCHealth, aiCLCCTSlotExp=aiCLCCTSlotExp, aiCLCTacacsAddr2=aiCLCTacacsAddr2, ai198Ver10=ai198Ver10, aiCLCInitStrings=aiCLCInitStrings, aiCLCTrapInterval=aiCLCTrapInterval, aiCLCDestConnMsg=aiCLCDestConnMsg, aiCLCAliasTable=aiCLCAliasTable, aiCLCTxTail=aiCLCTxTail, aiCLCDestQPswd=aiCLCDestQPswd, aiCLCBackupCLC=aiCLCBackupCLC, aiCLCDestNumFree=aiCLCDestNumFree, aiCLCTelnetServerPort=aiCLCTelnetServerPort, aiCLCRadiusPort1=aiCLCRadiusPort1, aiCLCPortNumber=aiCLCPortNumber, aiSystemOID=aiSystemOID, aiCLCDestMenu=aiCLCDestMenu, aiCLCAsyncifIndex=aiCLCAsyncifIndex, aiCLCTrapTable=aiCLCTrapTable, aiCLCAlarmLvl=aiCLCAlarmLvl, aiCLCDestState=aiCLCDestState, aiCLCAsyncTrap=aiCLCAsyncTrap, aiCLCTimeZone=aiCLCTimeZone, aiCLCBufAlign=aiCLCBufAlign, aiCLCAI2524LinkStatus=aiCLCAI2524LinkStatus, aiCLCCTAutoIdIndex=aiCLCCTAutoIdIndex, aiCLCNumPorts=aiCLCNumPorts, aiCLCCTCardSnmpState=aiCLCCTCardSnmpState)

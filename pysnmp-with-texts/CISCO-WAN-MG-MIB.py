#
# PySNMP MIB module CISCO-WAN-MG-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-WAN-MG-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:18:45 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
ciscoWan, = mibBuilder.importSymbols("CISCOWAN-SMI", "ciscoWan")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Counter64, Counter32, IpAddress, Unsigned32, MibIdentifier, NotificationType, Integer32, TimeTicks, Bits, iso, ModuleIdentity, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Counter64", "Counter32", "IpAddress", "Unsigned32", "MibIdentifier", "NotificationType", "Integer32", "TimeTicks", "Bits", "iso", "ModuleIdentity", "ObjectIdentity")
TextualConvention, TruthValue, RowStatus, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "TruthValue", "RowStatus", "DisplayString")
ciscoWanMgMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 351, 150, 10))
ciscoWanMgMIB.setRevisions(('2005-05-27 00:00', '2004-01-20 00:00', '2002-06-14 00:00', '2001-05-25 00:00', '2000-07-19 15:00', '2000-03-27 00:00', '1999-11-27 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ciscoWanMgMIB.setRevisionsDescriptions(('Added mgEndpointExtTable. ', 'Update descriptions in MIB.', 'Imported Unsigned32 from SNMPv2-SMI instead of CISCO-TC.', 'deprecated following objects: mgcAssociationState, mgcAssociationStateControl, mgcUnassociationPolicy, mgcCommLossUnassociationTimeout. mgcProtocolTable, mgcProtocolEntry and mgcProtocolRowStatus.', 'Create new table mediaGatewayDomainName. Deprecated mgcDnsResolution in mgcTable. Added mgcDnsResolutionFlag to mgcResolutionTable.', 'Added DEFVAL clause for mgEndpointCreationPolicy.', 'Initial Version of the MIB.',))
if mibBuilder.loadTexts: ciscoWanMgMIB.setLastUpdated('200505270000Z')
if mibBuilder.loadTexts: ciscoWanMgMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: ciscoWanMgMIB.setContactInfo(' Cisco Systems Customer Service Postal: 170 W Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-wanatm@cisco.com')
if mibBuilder.loadTexts: ciscoWanMgMIB.setDescription('The MIB module for managing Media Gateways (MGs). Terms used: MG: Media Gateway MGC: Media Gateway Controller MGCP: Media Gateway Control Protocol NE: Notified Entity RSIP: Restart In Progress (MGCP standard message)')
ciscoWanMgMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 1))
mediaGateway = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1))
mediaGatewayController = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2))
mediaGatewayEndpoint = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3))
mediaGatewayLine = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 4))
mediaGatewayControllerResolution = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5))
mediaGatewayDomainName = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 6))
mgName = MibScalar((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgName.setStatus('current')
if mibBuilder.loadTexts: mgName.setDescription('Denotes name of the MG, as it is identified by media gateway controllers. This corresponds to a domain name under which the Media Gateway could also be registered in a DNS.')
mgAdministrativeState = MibScalar((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inService", 1), ("commandedOutOfService", 2), ("pendingOutOfService", 3))).clone('commandedOutOfService')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgAdministrativeState.setStatus('current')
if mibBuilder.loadTexts: mgAdministrativeState.setDescription("This object indicates the current admin state of the Media Gateway. The possible admin states are: 'inService' - The MG is ready to provide service. In this state, the MG will respond to connection control requests, emit autonomous messages to MGCs as applicable, etc. 'commandedOutOfService' - The MG does not provide service and all resources have been released. In this state, the MG will not respond to any connection control requests or emit autonomous messages. 'pendingOutOfService' - This is a transitional state prior to going 'commandedOutOfService'. In this state the MG provides service but does not accept new service requests (i.e. creation of connections) will transition to 'commandedOutOfService' according to 'mgShutdownGraceTime'.")
mgAdministrativeStateControl = MibScalar((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("inService", 1), ("forcefulOutOfService", 2), ("gracefulOutOfService", 3))).clone('forcefulOutOfService')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgAdministrativeStateControl.setStatus('current')
if mibBuilder.loadTexts: mgAdministrativeStateControl.setDescription("This control object is used to change the service state of the MG from 'inService' to 'commandedOutOfService' and from 'commandedOutOfService' to 'inService'. The resulting service state of the gateway is represented by 'mgAdministrativeState'. If set, this object triggers the following: 'inService': Transition 'mgAdministrativeState' to 'inService'. In the course, the MG's MGCs may get notified of this transition, e.g. in the case of MGCP through emission of RSIPs to registered call agents according to policy. 'forcefulOutOfService': Take the gateway out-of-service forcefully. This releases any resources at the MG. In the course, the MGCs may get notified of this transition, e.g. in the case of MGCP through emission of RSIPs to registered call agents according to policy. 'gracefulOutOfService': Take the gateway out-of-service gracefully. If there are no resources existing, 'mgAdministrative' transitions to 'commandedOutOfService' immediately. If resources exist, 'mgAdministrativeState' transitions to 'pendingOutOfService' thus initiating a graceful shutdown. In the course, the MGs MGCs may get notified of this transition, e.g. in the case of MGCP through emission of RSIPs to registered call agents according to policy.")
mgShutdownGraceTime = MibScalar((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgShutdownGraceTime.setStatus('current')
if mibBuilder.loadTexts: mgShutdownGraceTime.setDescription("This object indicates the time in seconds after which an MG will transition from 'gracefulOutOfService' to 'forcefulOutOfService'. A value of -1 indicates that the MG allows for draining, i.e. will automatically transition after the last resource in use has been released. Otherwise, it essentially indicates the amount of time an MGC has to perform any cleanup, e.g. deletion of connections etc.")
mgSupportedProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 7), )
if mibBuilder.loadTexts: mgSupportedProtocolTable.setStatus('current')
if mibBuilder.loadTexts: mgSupportedProtocolTable.setDescription('This is a table which identifies the protocols, along with their revisions that the media gateway supports for purposes of communication with an MGC. The table is created by the agent at system startup and cannot changed.')
mgSupportedProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 7, 1), ).setIndexNames((0, "CISCO-WAN-MG-MIB", "mgProtocolNumber"))
if mibBuilder.loadTexts: mgSupportedProtocolEntry.setStatus('current')
if mibBuilder.loadTexts: mgSupportedProtocolEntry.setDescription('Represents an individual table entry in mgSupportedProtocolTable.')
mgProtocolNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 7, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mgProtocolNumber.setStatus('current')
if mibBuilder.loadTexts: mgProtocolNumber.setDescription('Serves as index to this table.')
mgProtocolName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 1, 7, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgProtocolName.setStatus('current')
if mibBuilder.loadTexts: mgProtocolName.setDescription("A control protocol and its revision supported by the call gateway. For example: 'MGCP 0.1 11/9/99' The protocol can be one of the control protocols like MGCP or it can be a signaling backhaul protocol or it can be resource co-ordination protocol like SRCP.")
maxConcurrentMgcs = MibScalar((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('controllers').setMaxAccess("readonly")
if mibBuilder.loadTexts: maxConcurrentMgcs.setStatus('current')
if mibBuilder.loadTexts: maxConcurrentMgcs.setDescription('This object identifies the maximum number of MGCs the MG can have.')
mgcTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1), )
if mibBuilder.loadTexts: mgcTable.setStatus('current')
if mibBuilder.loadTexts: mgcTable.setDescription('This is a table which contains information about the individual MGCs.')
mgcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-WAN-MG-MIB", "mgcNumber"))
if mibBuilder.loadTexts: mgcEntry.setStatus('current')
if mibBuilder.loadTexts: mgcEntry.setDescription('Represents an individual table entry in mgcTable.')
mgcNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mgcNumber.setStatus('current')
if mibBuilder.loadTexts: mgcNumber.setDescription('Serves as index to this table.')
mgcName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcName.setStatus('current')
if mibBuilder.loadTexts: mgcName.setDescription('Denotes the name of the media gateway controller. This corresponds to a domain name under which the MGC could also be registered in a DNS. Once the row has become active, this value may not be modified.')
mgcDnsResolution = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 3), TruthValue().clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgcDnsResolution.setStatus('deprecated')
if mibBuilder.loadTexts: mgcDnsResolution.setDescription("Indicates how the MG resolves the IP address of the MGC. 'true(1)' - the resolution is done using an external DNS server. 'false(2)' - the resolution is done using mgcResolutionTable.")
mgcAssociationState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mgcUnassociated", 1), ("mgcAssociated", 2), ("mgcAssociatedCommLoss", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgcAssociationState.setStatus('deprecated')
if mibBuilder.loadTexts: mgcAssociationState.setDescription("Represents the state of the association between the MG and the MGC. The possible values are: 'mgcUnassociated' : MG and MGC are not associated. For example, in the case where MGCP is the coordination protocol, it means no subscription to autonomous messages such as RSIP but control requests would be answered. 'mgcAssociated' : MG and MGC are associated. E.g. in the case where MGC is the coordination protocol, it means MGC is subscribed to autonomous messages such as RSIP. 'mgcAssociatedCommLoss' : Associated but MGC unreachable. This object is being moved to the mgcRedundancyGrpParamTable. This object is deprecated because the association state is defined per MGC redundancy group, rather than per MGC.")
mgcAssociationStateControl = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mgcUnassociate", 1), ("mgcAssociate", 2), ("mgcClear", 3))).clone('mgcUnassociate')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcAssociationStateControl.setStatus('deprecated')
if mibBuilder.loadTexts: mgcAssociationStateControl.setDescription("Used to control the association state, as represented by mgcAssociationState. The possible value for a set operation on this object are: 'mgcUnassociate': Transition from any state to 'mgcUnassociated'. If registered, MG will initiate deregistration. 'mgcAssociate' : Transition to 'mgcAssociated'. If applicable, MG will register with MGC. If MGCP is the coordination protocol, MG will send RSIP. If MG cannot establish communication, it will subsequently transition into 'mgcAssociatedCommLoss' for the 'mgcAssociationState' object. If MG is already associated with MGC, no transition will take place and mgcAssociationState shall not change. 'mgcClear' : No action will be taken. This means that the Media Gateway will not initiate any association/unassociation. This object is being moved to the mgcRedundancyGrpParamTable. This object is deprecated because the association state control is defined per MGC redundancy group, rather than per MGC.")
mgcUnassociationPolicy = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("mgcNoAction", 1), ("mgcRelease", 2))).clone('mgcNoAction')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcUnassociationPolicy.setStatus('deprecated')
if mibBuilder.loadTexts: mgcUnassociationPolicy.setDescription("Indicates what MG will do when mgcAssociationState transitions to unassociated. 'mgcNoAction' : indicates that MG will take no further action. In particular, no resources will be released nor connections be flushed. 'mgcRelease' : indicates that upon unassociation, the MG will release all resources and flush all connections. This object may not always be configurable, i.e. be read only in some agent implementations. In these cases, mgcNoAction shall be supported as the default value.")
mgcCommLossUnassociationTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 65535)).clone(-1)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcCommLossUnassociationTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: mgcCommLossUnassociationTimeout.setDescription("Indicates how long, in seconds, upon detection of a communication loss, subscriptions to autonomous notifications (such as notification requests and RSIPs in the case of MGCP) remain valid and communications will be reattempted for an MGC in 'mgcAssociatedCommLoss' state. A value of -1 indicates that the MGC may remain in 'mgcAssociatedCommLoss' state indefinitely. A value of 0 indicates that the MGC transitions into 'mgcUnassociated' state immediately. This object may not always be configurable, i.e. be read only in some agent implementations. An MG implementation may not support differentiation of the timeout between associations. In such an event, any modification to the value for one MGC will take effect globally.")
mgcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcRowStatus.setStatus('current')
if mibBuilder.loadTexts: mgcRowStatus.setDescription("Controls the creation and deletion of a table entry. An entry may be created using the 'createAndGo' option. When the row is successfully created, the RowStatus would be set to 'active' by the agent. An entry may be deleted by setting the RowStatus to 'destroy'. Other options such as `createAndWait', 'notInService', 'notReady' will not be used. For creating the row, a value for mgcName must be provided. This mgcName should be already added in mgDomainName table and at least 1 IP should associated to this mgcName. To all other objects, defaults defined by the agent implementation may apply. Deletion of a row with mgcAssociationState other than unassociated shall be rejected.")
mgcProtocolTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 2), )
if mibBuilder.loadTexts: mgcProtocolTable.setStatus('deprecated')
if mibBuilder.loadTexts: mgcProtocolTable.setDescription('This table contains information about which protocols are being used in a particular association between the gateway and the MGCs. Because there may be a number of different protocols in use for a particular control association between the gateway and an MGC, this information is kept in a separate table rather than being included in mgcTable. In effect, it constitutes a relationship between mgcTable and mgSupportedProtocolTable. With support for multiple MGC redundancy groups, the protocols will be defined per MGC redundancy group rather than per MGC. A new table mgcRedundancyGrpProtocolTable is introduced.')
mgcProtocolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-WAN-MG-MIB", "mgcNumber"), (0, "CISCO-WAN-MG-MIB", "mgProtocolNumber"))
if mibBuilder.loadTexts: mgcProtocolEntry.setStatus('deprecated')
if mibBuilder.loadTexts: mgcProtocolEntry.setDescription('Represents an individual table entry in mgcProtocolTable. mgcNumber references the media gateway controller, constituting a foreign key into mgcTable and adapting the value of mgcNumber of that MGC. mgProtocolNumber references the protocol, reflecting the mgProtocolNumber from the mgSupportedProtocolTable. When active, it is expected that mgcNumber and mgcProtocolNumber contain valid values that maintain referential integrity, i.e. constitute valid foreign keys into mgcTable and mgSupportedProtocolTable respectively. The attempt to create a row that would violate referential integrity shall be rejected. With support for multiple MGC redundancy groups, the protocols will be defined per MGC redundancy group rather than per MGC.')
mgcProtocolRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 2, 2, 1, 1), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcProtocolRowStatus.setStatus('deprecated')
if mibBuilder.loadTexts: mgcProtocolRowStatus.setDescription("Controls the creation and deletion of a table entry. An entry may be created using the 'createAndGo' option. When the row is successfully created, the RowStatus would be set to 'active' by the agent. An entry may be deleted by setting the RowStatus to 'destroy'. Other options such as `createAndWait', 'notInService', 'notReady' will not be used. With support for multiple MGC redundancy groups, the protocols will be defined per MGC redundancy group rather than per MGC.")
mgEndpointCreationPolicy = MibScalar((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dynamic", 1), ("strictDynamic", 2), ("static", 3))).clone('static')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mgEndpointCreationPolicy.setStatus('current')
if mibBuilder.loadTexts: mgEndpointCreationPolicy.setDescription("Identifies whether the MG creates endpoints for connections involving single channels (e.g. DS0s) dynamically upon receipt of a create connection request in the control protocol, or whether the endpoints have to be configured statically. This does not apply for endpoints involving several channels (such as nx64) which will in general be configured statically. 'dynamic': Endpoint created dynamically if not already existing. 'strictDynamic': Endpoint created dynamically; connection requests must not refer to preexisting endpoint. 'static': Endpoint statically provisioned. This object will in general not be configurable, i.e. be read only in most agent implementations.")
mgEndpointTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1), )
if mibBuilder.loadTexts: mgEndpointTable.setStatus('current')
if mibBuilder.loadTexts: mgEndpointTable.setDescription('This table contains information about the individual endpoints.')
mgEndpointEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-WAN-MG-MIB", "mgEndpointNumber"))
if mibBuilder.loadTexts: mgEndpointEntry.setStatus('current')
if mibBuilder.loadTexts: mgEndpointEntry.setDescription('Represents an individual table entry in mgEndpointTable.')
mgEndpointNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mgEndpointNumber.setStatus('current')
if mibBuilder.loadTexts: mgEndpointNumber.setDescription('Identifies endpoint as it is known by the NE. The endpoint number is unique for the entire MG and ranges from 1 to the maximum number of endpoints that the MG can support.')
mgEndpointLineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgEndpointLineNumber.setStatus('current')
if mibBuilder.loadTexts: mgEndpointLineNumber.setDescription('Identifies the DS1 line. Generally, this will correspond to the ifIndex of the physical interface terminating the line. Once the row has become active, this value may not be changed.')
mgEndpointName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgEndpointName.setStatus('current')
if mibBuilder.loadTexts: mgEndpointName.setDescription('Identifies endpoint as it is known by the MGC. If MG and MGC use a mutually agreed upon convention, this may be supplied by the agent, i.e. be read-only.')
mgEndpointSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setUnits('Kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: mgEndpointSpeed.setStatus('current')
if mibBuilder.loadTexts: mgEndpointSpeed.setDescription("Indicates the endpoint's bandwidth, in Kbps. Typically, this will be 64 times the number of channels terminated by the endpoint.")
mgEndpointState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mgEndpointActive", 1), ("mgEndpointFailed", 2), ("mgEndpointDegraded", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgEndpointState.setStatus('current')
if mibBuilder.loadTexts: mgEndpointState.setDescription("Indicates the state of the endpoint. 'mgEndpointActive' - the endpoint is in service and operational. 'mgEndpointFailed' - the endpoint is in service but not operational, e.g. because a line that the endpoint belongs to is in a state of service affecting alarm. 'mgEndpointDegraded' - the endpoint is in service but not fully operational, e.g. in cases with endpoints with channels on multiple lines, when one of the lines is in a state of service affecting alarm If MGCP is used as the control protocol, the following transitions will generally trigger an RSIP command: from 'mgEndpointActive'/'mgEndpointDegraded' to 'mgEndpointFailed' or from 'mgEndpointFailed' to 'mgEndpointDegraded'/'mgEndpointActive'. Transitions between 'mgEndpointActive' and 'mgEndpointDegraded' will generally not trigger emission of RSIP.")
mgEndpointChannelMap = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgEndpointChannelMap.setStatus('current')
if mibBuilder.loadTexts: mgEndpointChannelMap.setDescription("Bit map of DS0s used by the endpoint. Bit positions set to '1' represent DS0s used by the endpoint. The Bit position corresponds to the DS0 number. Once the row has become active, this value may not be changed.")
mgEndpointRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 1, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgEndpointRowStatus.setStatus('current')
if mibBuilder.loadTexts: mgEndpointRowStatus.setDescription("Controls the creation and deletion of a table entry. An entry may be created using the 'createAndGo' option. When the row is successfully created, the RowStatus would be set to 'active' by the agent thereby creating an endpoint. An endpoint may be deleted by setting the RowStatus to 'destroy'. Other options such as `createAndWait', 'notInService', 'notReady' will not be used. On creation, values for mgEndpointLineNumber and mgEndpointChannelMap have to be supplied.")
lineAssignmentTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 4, 1), )
if mibBuilder.loadTexts: lineAssignmentTable.setStatus('current')
if mibBuilder.loadTexts: lineAssignmentTable.setDescription('This table contains information about each line in the media gateway.')
lineAssignmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-WAN-MG-MIB", "lineNumber"))
if mibBuilder.loadTexts: lineAssignmentEntry.setStatus('current')
if mibBuilder.loadTexts: lineAssignmentEntry.setDescription('Represents an individual table entry in lineAssignmentTable.')
lineNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: lineNumber.setStatus('current')
if mibBuilder.loadTexts: lineNumber.setDescription('Identifies the DS1 line. Generally, this will correspond to the ifIndex of the physical interface terminating the line.')
channelAssignment = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: channelAssignment.setStatus('current')
if mibBuilder.loadTexts: channelAssignment.setDescription('Each bit that is set represents that the corresponding DS0 is in use, either because it has been assigned to an endpoint or because it constitutes a signaling channel that is not available for assignment to an endpoint.')
lineName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 4, 1, 1, 3), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineName.setStatus('current')
if mibBuilder.loadTexts: lineName.setDescription("Line name as identified by the MGC, if applicable. The default line name is 'LINE'. If MG uses a common convention, this may be supplied by the agent, i.e. be read-only.")
mgcResolutionTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1), )
if mibBuilder.loadTexts: mgcResolutionTable.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionTable.setDescription('This table provides the name to IP address mapping for each of the MGCs, external DNS server, tftp server and announcement server. It also stores the IP addresses of external resolved domain name. Several addresses may be associated with a single name.')
mgcResolutionEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-WAN-MG-MIB", "mgcResolutionIndex"))
if mibBuilder.loadTexts: mgcResolutionEntry.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionEntry.setDescription('Represents an individual table entry in mgcResolutionTable.')
mgcResolutionIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mgcResolutionIndex.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionIndex.setDescription('Serves as index to this table. The table will be divided into two, index 1 to 88 will be used by the user and index 89 to 176 will be used by the VDNS to fill in the externally resolved IP address.')
mgcResolutionName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcResolutionName.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionName.setDescription('Denotes the name of the entity (MGC and/or NE) whose address is to be resolved. Once the row has become active, this value may not be changed.')
mgcResolutionIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1, 3), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcResolutionIpAddress.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionIpAddress.setDescription('Denotes the IP address of the entity. Once the row has become active, this value may not be changed. To change the IP address, an entry will have to be removed and a new entry will have to be added.')
mgcResolutionCommState = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("csActive", 1), ("csInactive", 2))).clone('csInactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgcResolutionCommState.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionCommState.setDescription("Indicates whether the address is the one currently applied for communications with the system of that name. 'csActive' - name resolves to that IP address 'csInactive' - IP address currently not in use On creation of the row, this value will be 'csInactive', although it may transition immediately to active, triggering the notification of 'mgcCommStateActive' specified in CISCO-VISM-TRAPS-MIB.")
mgcResolutionPreference = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcResolutionPreference.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionPreference.setDescription('This object can be used by the MG in the selection of an IP address if multiple IP addresses are available for the same name. This object cannot be modified after this entry is created. It has to be unique among various IP addresses of a same domain name. In which case the IP address associated with mgcResolutionPreference 1 would be selected over the IP address associated with mgcResolutionPreference 2.')
mgcResolutionRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgcResolutionRowStatus.setStatus('current')
if mibBuilder.loadTexts: mgcResolutionRowStatus.setDescription("Controls the creation and deletion of a table entry. An entry may be created using the 'createAndGo' option. mgcResolutionIndex, mgcResolutionName, mgcResolutionIpAddress, and mgcResolutionPreference should be provided when creating an entry. mgcResolutionIndex can be 1 - 88. Entries with index 89 - 176 will be implicitly added when VDNS resolves IP addresses of domain servers. Usually maximum 8 IP addresses can be added to one mgcName. For external DNS server only 3 IP addresses with the highest will be used. Before creating an entry in this table one entry should already been created in mgDomainNameTable with the same name as mgcResolutionName. When the row is successfully created, the RowStatus would be set to 'active' by the agent. An entry may be deleted by setting the RowStatus to 'destroy'. Only mgcResolutionIndex should be provided to delete an entry. The last IP within 1 - 88 should not be deleted if the mgcResolutionName is still configured for MGC, tftp server, external DNS server, PRI backhaul session group or announcement server and there is no external resolved IP (entry 89 - 176) for this domain name. Other options such as `createAndWait', 'notInService', 'notReady' will not be used.")
mgcDnsResolutionFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 5, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("internal", 1), ("external", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mgcDnsResolutionFlag.setStatus('current')
if mibBuilder.loadTexts: mgcDnsResolutionFlag.setDescription("All entries statically configured by the customer (i.e. all entries in the top half of the table) will have the flag set to 'internal'. All IP addresses obtained due to external resolution of the domain name (that is, entries in the bottom half of the table) will have this flag set to 'external'.")
mgDomainNameTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 6, 1), )
if mibBuilder.loadTexts: mgDomainNameTable.setStatus('current')
if mibBuilder.loadTexts: mgDomainNameTable.setDescription('This table provides the domain names that are configured by users. The domain names could refer to Call Agents, tftp server for CAS file download, external DNS server or announcement server.')
mgDomainNameEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 6, 1, 1), ).setIndexNames((0, "CISCO-WAN-MG-MIB", "mgDomainNameIndex"))
if mibBuilder.loadTexts: mgDomainNameEntry.setStatus('current')
if mibBuilder.loadTexts: mgDomainNameEntry.setDescription('Represents an individual table entry in mgDomainNameTable.')
mgDomainNameIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mgDomainNameIndex.setStatus('current')
if mibBuilder.loadTexts: mgDomainNameIndex.setDescription('This object serves as index to this table.')
mgDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 6, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgDomainName.setStatus('current')
if mibBuilder.loadTexts: mgDomainName.setDescription('This object denotes the domain name of MGCs, tftp server, external DNS server or announcement server. Once the row has become active, this value may not be changed.')
mgDnsResolutionType = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("internalOnly", 1), ("externalOnly", 2), ("internalFirst", 3), ("externalFirst", 4))).clone('internalOnly')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgDnsResolutionType.setStatus('current')
if mibBuilder.loadTexts: mgDnsResolutionType.setDescription("This object determines the kind of DNS resolution to be applied for a particular domain name. 'internalOnly' means that the gateway will not try to resolve the IP address for this domain name using external DNS. The IP address/es for this domain name will be obtained from the first half of mgcResolutionTable, which are added by the user. 'externalOnly' means the IP address for this domain name will be resolved externally using external DNS. 'internalFirst' means the first preference will be given to statically provisioned IP address/es, followed the IP address/es resolved using external DNS. 'externalFirst' means the first preference will be given to IP addresses resolved using external DNS followed by statically provisioned IP addresses. This object can be modified when mgDomainNameRowStatus is active except that if the mgDomainName refers to external DNS server then this object cannot be changed. The request to change from 'internalOnly' to other types will be rejected if external DNS server is 'NULL'. The external DNS server can be set to 'NULL' through the object vismExtDnsServerDn in CISCO-VISM-MODULE-MIB. When user change this object to 'internalOnly' then all the externally resolved IP addresses should be implicitly deleted from mgcResolutionTable.")
mgDomainNameRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 6, 1, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgDomainNameRowStatus.setStatus('current')
if mibBuilder.loadTexts: mgDomainNameRowStatus.setDescription("Controls the creation and deletion and of a table entry. An entry may be created using the 'createAndGo' option. User can only set mgDnsResolutionType to 'internalOnly'. The request to set an entry with mgDnsResolutionType of 'externalOnly', 'internalFirst' or 'externalFirst' would be rejected if the external DNS server is 'NULL'. When the row is successfully created, the RowStatus would be set to 'active' by the agent. An entry may be deleted by setting the RowStatus to 'destroy'. The deletion of an entry will be rejected if there is still reference to this domain name. For example, it cannot be deleted if it is configured as MGC, tftp server, external DNS server or announcement server. Also user added IPs should already been deleted. After delete the domain name externally resolved IPs are purged implicitly. The request to change from 'internalOnly' to other types will be rejected if external DNS server is 'NULL'. Other options such as `createAndWait', 'notInService', 'notReady' will not be used.")
mgEndpointExtTable = MibTable((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 3), )
if mibBuilder.loadTexts: mgEndpointExtTable.setStatus('current')
if mibBuilder.loadTexts: mgEndpointExtTable.setDescription('This table extends the mgEndpointTable. Objects that do not directly describe the endpoint but extend the rules to configure the mgEndpointTable can be added to this table. Each table entry describes an instance of an endpoint on a media gateway.')
mgEndpointExtEntry = MibTableRow((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 3, 1), )
mgEndpointEntry.registerAugmentions(("CISCO-WAN-MG-MIB", "mgEndpointExtEntry"))
mgEndpointExtEntry.setIndexNames(*mgEndpointEntry.getIndexNames())
if mibBuilder.loadTexts: mgEndpointExtEntry.setStatus('current')
if mibBuilder.loadTexts: mgEndpointExtEntry.setDescription('Each entry represents a media gateway endpoint interface.')
mgEndpointRepetition = MibTableColumn((1, 3, 6, 1, 4, 1, 351, 150, 10, 1, 3, 3, 1, 1), Unsigned32().clone(1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mgEndpointRepetition.setStatus('current')
if mibBuilder.loadTexts: mgEndpointRepetition.setDescription('This object is used to create multiple rows in the mgEndpointTable as specified in the SNMP PDU, starting from the row specified by the index of the instance for the number of rows specified in this object. The repetition operation will start from the mgEndpointNumber, mgEndpointLineNumber and mgEndpointChannelMap that is specified in the PDU and will add rows for the number specified in this object. If for a given mgEndpointLineNumber all the endpoints channels are exhausted, it will proceed to the next mgEndpointLineNumber. This will continue until the number of repetitions specified in this object is exhausted or the number of DS1s and endpoints is exhausted, whichever comes first. The agent will need to be able to populate the objects in the mgEndpointTable with the appropriate values as new rows are created. ')
mgMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 3))
mgMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 1))
mgMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2))
mgMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 1, 1)).setObjects(("CISCO-WAN-MG-MIB", "mediaGatewayGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayEndpointGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayLineGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerResolutionGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mgMIBCompliance = mgMIBCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: mgMIBCompliance.setDescription('The compliance statement for the SNMP entities which implement MGMIB.')
mgMIBCompliance1 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 1, 2)).setObjects(("CISCO-WAN-MG-MIB", "mediaGatewayGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerGroup1"), ("CISCO-WAN-MG-MIB", "mediaGatewayEndpointGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayLineGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayDomainNameGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerResolutionGroup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mgMIBCompliance1 = mgMIBCompliance1.setStatus('deprecated')
if mibBuilder.loadTexts: mgMIBCompliance1.setDescription('The compliance statement for the SNMP entities which implement MGMIB.')
mgMIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 1, 3)).setObjects(("CISCO-WAN-MG-MIB", "mediaGatewayGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerGroup2"), ("CISCO-WAN-MG-MIB", "mediaGatewayEndpointGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayLineGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayDomainNameGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerResolutionGroup1"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mgMIBCompliance2 = mgMIBCompliance2.setStatus('deprecated')
if mibBuilder.loadTexts: mgMIBCompliance2.setDescription('The compliance statement for the SNMP entities which implement MGMIB.')
mgMIBCompliance3 = ModuleCompliance((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 1, 4)).setObjects(("CISCO-WAN-MG-MIB", "mediaGatewayGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerGroup2"), ("CISCO-WAN-MG-MIB", "mediaGatewayEndpointGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayLineGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayDomainNameGroup"), ("CISCO-WAN-MG-MIB", "mediaGatewayControllerResolutionGroup1"), ("CISCO-WAN-MG-MIB", "mediaGatewayEndptRepetitionGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mgMIBCompliance3 = mgMIBCompliance3.setStatus('current')
if mibBuilder.loadTexts: mgMIBCompliance3.setDescription('The compliance statement for the SNMP entities which implement MGMIB.')
mediaGatewayGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 1)).setObjects(("CISCO-WAN-MG-MIB", "mgName"), ("CISCO-WAN-MG-MIB", "mgAdministrativeState"), ("CISCO-WAN-MG-MIB", "mgAdministrativeStateControl"), ("CISCO-WAN-MG-MIB", "mgShutdownGraceTime"), ("CISCO-WAN-MG-MIB", "mgProtocolName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayGroup = mediaGatewayGroup.setStatus('current')
if mibBuilder.loadTexts: mediaGatewayGroup.setDescription('This group contains objects that apply to the media gateway as a whole, such as global parameters and state.')
mediaGatewayControllerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 2)).setObjects(("CISCO-WAN-MG-MIB", "maxConcurrentMgcs"), ("CISCO-WAN-MG-MIB", "mgcName"), ("CISCO-WAN-MG-MIB", "mgcDnsResolution"), ("CISCO-WAN-MG-MIB", "mgcAssociationState"), ("CISCO-WAN-MG-MIB", "mgcAssociationStateControl"), ("CISCO-WAN-MG-MIB", "mgcUnassociationPolicy"), ("CISCO-WAN-MG-MIB", "mgcCommLossUnassociationTimeout"), ("CISCO-WAN-MG-MIB", "mgcRowStatus"), ("CISCO-WAN-MG-MIB", "mgcProtocolRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayControllerGroup = mediaGatewayControllerGroup.setStatus('deprecated')
if mibBuilder.loadTexts: mediaGatewayControllerGroup.setDescription('This group contains objects that describe the Media Gateway Controllers with which the Media gateway communicates.')
mediaGatewayEndpointGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 3)).setObjects(("CISCO-WAN-MG-MIB", "mgEndpointCreationPolicy"), ("CISCO-WAN-MG-MIB", "mgEndpointName"), ("CISCO-WAN-MG-MIB", "mgEndpointLineNumber"), ("CISCO-WAN-MG-MIB", "mgEndpointSpeed"), ("CISCO-WAN-MG-MIB", "mgEndpointState"), ("CISCO-WAN-MG-MIB", "mgEndpointChannelMap"), ("CISCO-WAN-MG-MIB", "mgEndpointRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayEndpointGroup = mediaGatewayEndpointGroup.setStatus('current')
if mibBuilder.loadTexts: mediaGatewayEndpointGroup.setDescription("This group contains objects describing the media gateway's endpoints.")
mediaGatewayLineGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 4)).setObjects(("CISCO-WAN-MG-MIB", "channelAssignment"), ("CISCO-WAN-MG-MIB", "lineName"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayLineGroup = mediaGatewayLineGroup.setStatus('current')
if mibBuilder.loadTexts: mediaGatewayLineGroup.setDescription('This group contains objects which relate lines to endpoints. These objects complement the information contained in a line MIB.')
mediaGatewayControllerResolutionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 5)).setObjects(("CISCO-WAN-MG-MIB", "mgcResolutionName"), ("CISCO-WAN-MG-MIB", "mgcResolutionIpAddress"), ("CISCO-WAN-MG-MIB", "mgcResolutionCommState"), ("CISCO-WAN-MG-MIB", "mgcResolutionPreference"), ("CISCO-WAN-MG-MIB", "mgcResolutionRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayControllerResolutionGroup = mediaGatewayControllerResolutionGroup.setStatus('deprecated')
if mibBuilder.loadTexts: mediaGatewayControllerResolutionGroup.setDescription('This group contains information to resolve names to IP addresses in the absence of DNS support.')
mediaGatewayControllerGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 6)).setObjects(("CISCO-WAN-MG-MIB", "maxConcurrentMgcs"), ("CISCO-WAN-MG-MIB", "mgcName"), ("CISCO-WAN-MG-MIB", "mgcAssociationState"), ("CISCO-WAN-MG-MIB", "mgcAssociationStateControl"), ("CISCO-WAN-MG-MIB", "mgcUnassociationPolicy"), ("CISCO-WAN-MG-MIB", "mgcCommLossUnassociationTimeout"), ("CISCO-WAN-MG-MIB", "mgcRowStatus"), ("CISCO-WAN-MG-MIB", "mgcProtocolRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayControllerGroup1 = mediaGatewayControllerGroup1.setStatus('deprecated')
if mibBuilder.loadTexts: mediaGatewayControllerGroup1.setDescription('This group contains objects that describe the MGCs with which the MG communicates.')
mediaGatewayControllerResolutionGroup1 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 7)).setObjects(("CISCO-WAN-MG-MIB", "mgcResolutionName"), ("CISCO-WAN-MG-MIB", "mgcResolutionIpAddress"), ("CISCO-WAN-MG-MIB", "mgcResolutionCommState"), ("CISCO-WAN-MG-MIB", "mgcResolutionPreference"), ("CISCO-WAN-MG-MIB", "mgcResolutionRowStatus"), ("CISCO-WAN-MG-MIB", "mgcDnsResolutionFlag"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayControllerResolutionGroup1 = mediaGatewayControllerResolutionGroup1.setStatus('current')
if mibBuilder.loadTexts: mediaGatewayControllerResolutionGroup1.setDescription('This group contains information to resolve names to IP addresses both in the absence of DNS support and with DNS support.')
mediaGatewayDomainNameGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 8)).setObjects(("CISCO-WAN-MG-MIB", "mgDomainName"), ("CISCO-WAN-MG-MIB", "mgDnsResolutionType"), ("CISCO-WAN-MG-MIB", "mgDomainNameRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayDomainNameGroup = mediaGatewayDomainNameGroup.setStatus('current')
if mibBuilder.loadTexts: mediaGatewayDomainNameGroup.setDescription(' This group contains domain names and information about how these domain names will be resolved.')
mediaGatewayControllerGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 9)).setObjects(("CISCO-WAN-MG-MIB", "maxConcurrentMgcs"), ("CISCO-WAN-MG-MIB", "mgcName"), ("CISCO-WAN-MG-MIB", "mgcRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayControllerGroup2 = mediaGatewayControllerGroup2.setStatus('current')
if mibBuilder.loadTexts: mediaGatewayControllerGroup2.setDescription('This group contains objects that describe the Media Gateway Controllers with which the Media gateway communicates.')
mediaGatewayEndptRepetitionGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 351, 150, 10, 3, 2, 10)).setObjects(("CISCO-WAN-MG-MIB", "mgEndpointRepetition"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    mediaGatewayEndptRepetitionGroup = mediaGatewayEndptRepetitionGroup.setStatus('current')
if mibBuilder.loadTexts: mediaGatewayEndptRepetitionGroup.setDescription("This group contains repetition objects describing the media gateway's endpoints as defined in the mgEndpointExtTable.")
mibBuilder.exportSymbols("CISCO-WAN-MG-MIB", mgName=mgName, mediaGatewayLine=mediaGatewayLine, mgDomainNameIndex=mgDomainNameIndex, mgSupportedProtocolEntry=mgSupportedProtocolEntry, mediaGatewayEndpoint=mediaGatewayEndpoint, mgEndpointExtTable=mgEndpointExtTable, mgDnsResolutionType=mgDnsResolutionType, mgDomainNameTable=mgDomainNameTable, mgEndpointRepetition=mgEndpointRepetition, mgEndpointExtEntry=mgEndpointExtEntry, mediaGatewayLineGroup=mediaGatewayLineGroup, mgMIBGroups=mgMIBGroups, mgProtocolNumber=mgProtocolNumber, mgMIBCompliances=mgMIBCompliances, mgcProtocolEntry=mgcProtocolEntry, mediaGatewayDomainName=mediaGatewayDomainName, mgcEntry=mgcEntry, mgEndpointEntry=mgEndpointEntry, lineAssignmentTable=lineAssignmentTable, mgcAssociationStateControl=mgcAssociationStateControl, mediaGatewayDomainNameGroup=mediaGatewayDomainNameGroup, mgAdministrativeStateControl=mgAdministrativeStateControl, mgEndpointRowStatus=mgEndpointRowStatus, mgcResolutionPreference=mgcResolutionPreference, mgcName=mgcName, mgDomainNameRowStatus=mgDomainNameRowStatus, mgcNumber=mgcNumber, mgMIBCompliance=mgMIBCompliance, lineNumber=lineNumber, mgcResolutionRowStatus=mgcResolutionRowStatus, mgcProtocolRowStatus=mgcProtocolRowStatus, mgcTable=mgcTable, mgcResolutionIndex=mgcResolutionIndex, mgcRowStatus=mgcRowStatus, mediaGatewayControllerGroup2=mediaGatewayControllerGroup2, mgAdministrativeState=mgAdministrativeState, mgcCommLossUnassociationTimeout=mgcCommLossUnassociationTimeout, mgEndpointTable=mgEndpointTable, mediaGatewayEndpointGroup=mediaGatewayEndpointGroup, mgMIBCompliance3=mgMIBCompliance3, mgcResolutionIpAddress=mgcResolutionIpAddress, mgSupportedProtocolTable=mgSupportedProtocolTable, mgcDnsResolutionFlag=mgcDnsResolutionFlag, channelAssignment=channelAssignment, lineName=lineName, PYSNMP_MODULE_ID=ciscoWanMgMIB, mgEndpointLineNumber=mgEndpointLineNumber, mgEndpointNumber=mgEndpointNumber, mediaGateway=mediaGateway, mgMIBConformance=mgMIBConformance, mgcDnsResolution=mgcDnsResolution, lineAssignmentEntry=lineAssignmentEntry, mediaGatewayControllerGroup=mediaGatewayControllerGroup, mediaGatewayControllerResolutionGroup=mediaGatewayControllerResolutionGroup, mediaGatewayControllerGroup1=mediaGatewayControllerGroup1, mgEndpointCreationPolicy=mgEndpointCreationPolicy, mgMIBCompliance2=mgMIBCompliance2, mediaGatewayControllerResolutionGroup1=mediaGatewayControllerResolutionGroup1, mgProtocolName=mgProtocolName, mgcUnassociationPolicy=mgcUnassociationPolicy, ciscoWanMgMIBObjects=ciscoWanMgMIBObjects, mgMIBCompliance1=mgMIBCompliance1, mediaGatewayController=mediaGatewayController, mgcResolutionTable=mgcResolutionTable, mediaGatewayEndptRepetitionGroup=mediaGatewayEndptRepetitionGroup, ciscoWanMgMIB=ciscoWanMgMIB, mgcProtocolTable=mgcProtocolTable, mgDomainName=mgDomainName, mgcResolutionEntry=mgcResolutionEntry, mgEndpointState=mgEndpointState, maxConcurrentMgcs=maxConcurrentMgcs, mgcResolutionName=mgcResolutionName, mgShutdownGraceTime=mgShutdownGraceTime, mgDomainNameEntry=mgDomainNameEntry, mgcResolutionCommState=mgcResolutionCommState, mgEndpointName=mgEndpointName, mediaGatewayGroup=mediaGatewayGroup, mediaGatewayControllerResolution=mediaGatewayControllerResolution, mgEndpointSpeed=mgEndpointSpeed, mgEndpointChannelMap=mgEndpointChannelMap, mgcAssociationState=mgcAssociationState)

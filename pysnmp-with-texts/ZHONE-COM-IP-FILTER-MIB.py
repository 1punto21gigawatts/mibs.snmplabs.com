#
# PySNMP MIB module ZHONE-COM-IP-FILTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ZHONE-COM-IP-FILTER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:47:04 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, SingleValueConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "SingleValueConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Gauge32, Counter64, iso, Integer32, ModuleIdentity, ObjectIdentity, IpAddress, Unsigned32, MibIdentifier, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, NotificationType, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Counter64", "iso", "Integer32", "ModuleIdentity", "ObjectIdentity", "IpAddress", "Unsigned32", "MibIdentifier", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "NotificationType", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
zhoneModules, zhoneIp = mibBuilder.importSymbols("Zhone", "zhoneModules", "zhoneIp")
ZhoneRowStatus, ZhoneAdminString = mibBuilder.importSymbols("Zhone-TC", "ZhoneRowStatus", "ZhoneAdminString")
comIpFilter = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 6, 58))
comIpFilter.setRevisions(('2005-01-10 10:16', '2005-01-03 09:24', '2004-12-21 09:25', '2004-08-30 11:00', '2004-04-06 00:17', '2001-01-17 08:48', '2000-09-11 16:22',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: comIpFilter.setRevisionsDescriptions(('changed portAccessArg1, portAccessArg2 to more intuitive names.', 'changed portArg1, portArg2 to IP addresses', 'added Port_Access', 'V01.01.02 - Add type field to mcastControlList.', 'V01.01.01 - Implementation of multicast-control-list.', 'V01.01.00 - Added keyword markup, updated SMI, Added the filterStmtRenumTable and filterStatsTable', 'V01.00.00 - Initial Release',))
if mibBuilder.loadTexts: comIpFilter.setLastUpdated('200501100015Z')
if mibBuilder.loadTexts: comIpFilter.setOrganization('Zhone Technologies, Inc.')
if mibBuilder.loadTexts: comIpFilter.setContactInfo(' Postal: Zhone Technologies, Inc. @ Zhone Way 7001 Oakport Street Oakland, CA 94621 USA Toll-Free: +1 877-ZHONE20 (+1 877-946-6320) Tel: +1-510-777-7000 Fax: +1-510-777-7001 E-mail: support@zhone.com')
if mibBuilder.loadTexts: comIpFilter.setDescription('Zhone IP Filter MIB Module. IP Software Minneapolis, MN')
filter = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8))
if mibBuilder.loadTexts: filter.setStatus('current')
if mibBuilder.loadTexts: filter.setDescription('The MIB module representing IP filter specifications in Zhone Technologies products. IP filtering is typically performed to enhance network security by limiting what access is allowed between two networks. Filtering is also effective in eliminating certain denial-of-service attacks. Packet filtering also provides a framework for sanity checking packet headers, and rejecting packets that are unlikely (or that should be impossible). In this way, packet filtering can prevent certain unfortunate mistakes from shutting a network down.')
if mibBuilder.loadTexts: filter.setReference("RFC1812, 'Requirements for IP Version 4 Routers,' ftp://ftp.isi.edu/in-notes/rfc1812.txt. RFC2267, 'Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing,' ftp://ftp.isi.edu/in-notes/rfc2267.txt. RFC2474, 'Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers', ftp://ftp.isi.edu/in-notes/rfc2474.txt. D. Brent Chapman, 'Network (In)Security Through IP Packet Filtering,' Proceedings of the 3rd USENIX Security Symposium, Sept. 1992. Andrew Molitor, 'An Architecture for Advanced Packet Filtering,' Proceedings of the 5th USENIX Security Symposium, June. 1995. Paul Russell, 'Linux IPCHAINS-HOWTO,' http://www.rustcorp.com/linux/ipchains/HOWTO.html, v1.0.7, Mar. 1999.")
filterGlobal = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 1))
if mibBuilder.loadTexts: filterGlobal.setStatus('current')
if mibBuilder.loadTexts: filterGlobal.setDescription('Global filter provisioning information.')
fltGlobalIndexNext = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fltGlobalIndexNext.setStatus('current')
if mibBuilder.loadTexts: fltGlobalIndexNext.setDescription('The next available filter spec table index (filterSpecIndex). A GET on this object increments the value by one. A GETNEXT on this object will always return zero.')
fltGlobalTimeout = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: fltGlobalTimeout.setStatus('current')
if mibBuilder.loadTexts: fltGlobalTimeout.setDescription('Filter inconsistency timeout in seconds. A filter spec is considered to be in an inconsistent state when the value of the objects fltSpecVersion1 and fltSpecVersion2 are not equal. This timeout indicates the minimum number of seconds a filter may be in an inconsistent state before the filter spec becomes invalid and the default action for a filter is used as the filter. Provided fltGlobalTimeout is long enough, it should ensure that both an old modification is permanently stalled (ensuring exclusive access) as well as enough time to repair a filter. Default is five seconds.')
filterSpecTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2), )
if mibBuilder.loadTexts: filterSpecTable.setStatus('current')
if mibBuilder.loadTexts: filterSpecTable.setDescription("The filter specification table contains specifications for the IP filtering module. Rows are indexed by a single integer index (filterSpecIndex). The fltGlobalIndexNext object is used to determine the next index value. Each row points to a sequence of rows (statements) in the filterStatementTable. When any row in that sequence is modified, created, or removed, the fltSpecVersion1 and fltSpecVersion2 objects must be incremented. Rows are created by assigning fltSpecIndex and setting fltSpecRowStatus to 'createAndGo'. All columnar objects in this table have default values, so no objects other than the index value need be set to create a row. Rows are removed by setting fltSpecRowStatus to 'destroy'. When a row is removed, each row in filterStatementTable with the same fltSpecIndex is automatically removed.")
filterSpecEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1), ).setIndexNames((0, "ZHONE-COM-IP-FILTER-MIB", "fltSpecIndex"))
if mibBuilder.loadTexts: filterSpecEntry.setStatus('current')
if mibBuilder.loadTexts: filterSpecEntry.setDescription('An entry in the filterSpecTable.')
fltSpecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: fltSpecIndex.setStatus('current')
if mibBuilder.loadTexts: fltSpecIndex.setDescription('The index that identifies an entry in the filterSpecTable. The fltGlobalIndexNext object is used to determine the next value of this object.')
fltSpecName = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1, 2), ZhoneAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltSpecName.setStatus('current')
if mibBuilder.loadTexts: fltSpecName.setDescription('The filter name associated with this filter specification. This name should indicate the nature of the filter. The default value is an empty string.')
fltSpecDesc = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1, 3), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltSpecDesc.setStatus('current')
if mibBuilder.loadTexts: fltSpecDesc.setDescription('Textual description of the filter specification. This should briefly describe the nature of the filter defined by the associated filter statements. The default value is an empty string.')
fltSpecVersion1 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1, 4), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltSpecVersion1.setStatus('current')
if mibBuilder.loadTexts: fltSpecVersion1.setDescription('The version number of the filter specification. This is used to flag any changes in the statements that comprise a filter. Each time a modification occurs to an object in a filter spec (including the the list of filter statements of the same fltSpecIndex in filterStatementTable), the value of this object, and fltSpecVersion2 must be incremented. The manager adding, deleting, or modifying a filter statement or statements must increment this version number in the following manner. A read of fltSpecVersion1 returns its current value. A write to fltSpecVersion1 must be one greater than its current value. A successful write of this object transfers ownership to the manager, where the manager must subsequently perform any desired modifications to the filter spec and then write the new value of fltSpecVersion1 to the fltSpecVersion2 object to release ownership. When fltSpecVersion1 does not equal to fltSpecVersion2, the filter spec is in an inconsistent state. If the filter spec remains in an inconsistent state longer than the time specified in fltGlobalTimeout, the filter spec is declared invalid and the filter spec does not become active. The previously provisioned filter spec will remain active. If no previous filter spec was provisioned for this interface, a default action is used. It is up to the manager to fix the invalid filter spec and bring it into a consistent state.')
fltSpecVersion2 = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1, 5), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltSpecVersion2.setStatus('current')
if mibBuilder.loadTexts: fltSpecVersion2.setDescription('The version number of the filter specification. The value of this object must be equal to fltSpecVersion1, otherwise the filter spec is inconsistent. See fltSpecVersion1 for details.')
fltSpecLanguageVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1, 6), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltSpecLanguageVersion.setStatus('current')
if mibBuilder.loadTexts: fltSpecLanguageVersion.setDescription('The language version of the filter. The language version further details the meaning and use of the objects in filterStatmentTable. The definitions of the filter languages is beyond the scope of this description.')
fltSpecRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 2, 1, 7), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltSpecRowStatus.setStatus('current')
if mibBuilder.loadTexts: fltSpecRowStatus.setDescription('Zhone convention to support row creation and deletion. This is the only object required to create or destroy a row in this table.')
filterStatementTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3), )
if mibBuilder.loadTexts: filterStatementTable.setStatus('current')
if mibBuilder.loadTexts: filterStatementTable.setDescription("This table contains the filter specification statements for the IP filtering module. A complete filter specification is comprised of all the linked statements (rows) that are pointed to by an entry in the filterSpecTable. Filter statements are linked together by fltSpecIndex, and are ordered within the comprised filter using fltStmtIndex. A statement can only be owned by one filter spec. Rows are created by assigning fltSpecIndex and fltStmtIndex, and setting fltStmtRowStatus to 'createAndGo'. All columnar objects in this table have default values, so no objects other than the index values need be set to create a row. Rows are destroyed by setting fltStmtRowStatus to 'delete'. When rows are created or destroyed, the version of the corresponding filter spec row is incremented.")
filterStatementEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1), ).setIndexNames((0, "ZHONE-COM-IP-FILTER-MIB", "fltSpecIndex"), (0, "ZHONE-COM-IP-FILTER-MIB", "fltStmtIndex"))
if mibBuilder.loadTexts: filterStatementEntry.setStatus('current')
if mibBuilder.loadTexts: filterStatementEntry.setDescription('An entry in the filterStatement table. Each entry represents one of a sequence of statements that comprise a filter. Each filter statement consists of an index, specific packet header fields, and arbitrary packet offsets and values. Some objects in this entry define ranges for specific packet header fields. These objects define comparison operations on the field they share in the following manner: Low High Compare Method for field f --- ---- ------------------------------------------- 0 0 no comparison on the field 0 H less than or equal to High (f <= H) L 0 exact match (L == f) L H inclusive between comparison (L <= f <= H) ')
fltStmtIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: fltStmtIndex.setStatus('current')
if mibBuilder.loadTexts: fltStmtIndex.setDescription('The table index that identifies a filter statement. These indicies should be sparse to allow for insertion into the list.')
fltStmtIpSrcAddrLow = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtIpSrcAddrLow.setStatus('current')
if mibBuilder.loadTexts: fltStmtIpSrcAddrLow.setDescription('The inclusive lower bound for the source IP address range. See the filterStatementEntry description for details.')
fltStmtIpSrcAddrHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 3), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtIpSrcAddrHigh.setStatus('current')
if mibBuilder.loadTexts: fltStmtIpSrcAddrHigh.setDescription('The inclusive upper bound for the source IP address range. See the filterStatementEntry description for details.')
fltStmtSrcPortLow = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtSrcPortLow.setStatus('current')
if mibBuilder.loadTexts: fltStmtSrcPortLow.setDescription('The inclusive lower bound for the transport layer source port range. See the filterStatementEntry description for details.')
fltStmtSrcPortHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtSrcPortHigh.setStatus('current')
if mibBuilder.loadTexts: fltStmtSrcPortHigh.setDescription('The inclusive upper bound for the transport layer source port range. See the filterStatementEntry description for details.')
fltStmtIpDstAddrLow = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 6), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtIpDstAddrLow.setStatus('current')
if mibBuilder.loadTexts: fltStmtIpDstAddrLow.setDescription('The inclusive lower bound for the destination IP address range. See the filterStatementEntry description for details.')
fltStmtIpDstAddrHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 7), IpAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtIpDstAddrHigh.setStatus('current')
if mibBuilder.loadTexts: fltStmtIpDstAddrHigh.setDescription('The inclusive upper bound for the destination IP address range. See the filterStatementEntry description for details.')
fltStmtDstPortLow = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtDstPortLow.setStatus('current')
if mibBuilder.loadTexts: fltStmtDstPortLow.setDescription('The inclusive lower bound for the transport layer destination port range. See the filterStatementEntry description for details.')
fltStmtDstPortHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtDstPortHigh.setStatus('current')
if mibBuilder.loadTexts: fltStmtDstPortHigh.setDescription('The inclusive upper bound for the transport layer destination port range. See the filterStatementEntry description for details.')
fltStmtIpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("any", 1), ("ip", 2), ("tcp", 3), ("udp", 4), ("icmp", 5))).clone('any')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtIpProtocol.setStatus('current')
if mibBuilder.loadTexts: fltStmtIpProtocol.setDescription('The IP protocol value that is to be matched. The enum values are as follows: any(1) : any protocol type is a match (wildcard) ip(2) : raw IP packet tcp(3) : TCP packet udp(4) : UDP packet icmp(5) : ICMP packet The default value is any(1).')
fltStmtArbValueBase = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("none", 1), ("ip", 2), ("udp", 3), ("tcp", 4), ("icmp", 5), ("ipOptions", 6), ("tcpOptions", 7))).clone('none')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtArbValueBase.setStatus('current')
if mibBuilder.loadTexts: fltStmtArbValueBase.setDescription('This field identifies the protocol header to which the arbitrary value comparison applies. The enum values are as follows: none(1) : no arbitrary value comparison ip(2) : base is IP header udp(3) : base is UDP header tcp(4) : base is TCP header icmp(5) : base is ICMP header ipOptions(6) : base is IP options header tcpOptions(7) : base is TCP options header The default value is none(1).')
fltStmtArbOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtArbOffset.setStatus('current')
if mibBuilder.loadTexts: fltStmtArbOffset.setDescription('The offset, in octets, from the beginning of the header to the most significant octet for the arbitrary value comparison.')
fltStmtArbMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 13), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtArbMask.setStatus('current')
if mibBuilder.loadTexts: fltStmtArbMask.setDescription('This object is mask for for arbitrary value comparisons. The non-zero bits in this field determine the size of the arbitrary field.')
fltStmtArbValueLow = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 14), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtArbValueLow.setStatus('current')
if mibBuilder.loadTexts: fltStmtArbValueLow.setDescription('This object is the inclusive lower bound for arbitrary value comparison. See the filterStatementEntry description for details.')
fltStmtArbValueHigh = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 15), Unsigned32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtArbValueHigh.setStatus('current')
if mibBuilder.loadTexts: fltStmtArbValueHigh.setDescription('This object is the inclusive upper bound for arbitrary value comparison. See the filterStatementEntry description for details.')
fltStmtModifier = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 16), Bits().clone(namedValues=NamedValues(("notIpSrc", 0), ("notSrcPort", 1), ("notDstIp", 2), ("notPortDst", 3), ("notProtocol", 4), ("notArbitrary", 5), ("notStatement", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtModifier.setStatus('current')
if mibBuilder.loadTexts: fltStmtModifier.setDescription('Filter statement modifier. The bits set in this object logically negate the results of the comparisons made on their respecive fields as shown : notIpSrcAddr(1) : fltStmtIpSrcAddrLow, fltStmtIpSrcAddrHigh notSrcPort(2) : fltStmtSrcPortLow, fltStmtSrcPortHigh notIpDstAddr(3) : fltStmtIpDstAddrLow, fltStmtIpDstAddrHigh notDstPort(4) : fltStmtDstPortLow, fltStmtDstPortHigh notIpProtocol(5) : fltStmtIpProtocol notArbitrary(6) : fltStmtArbValueLow, fltStmtArbValueHigh notStatement(7) : negate outcome of the entire statement No bits set (the default) specifies to use all outcomes as is.')
fltStmtAction = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 17), Bits().clone(namedValues=NamedValues(("reset", 0), ("permit", 1), ("deny", 2), ("forward", 3), ("reject", 4), ("log", 5))).clone(namedValues=NamedValues(("deny", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtAction.setStatus('current')
if mibBuilder.loadTexts: fltStmtAction.setDescription('Filter statement action. The bits set in this object specify actions to take on packets matching this statement. Supported actions are: reset(0) : Return a TCP reset packet to the packet sender and drop the packet. This cannot be specified with permit. permit(1) : Stop filtering the packet and allow it to be sent on the associated interface. This cannot be specified with deny. deny(2) : Stop filtering the packet and discard it. This cannot be specified with permit. forward(3) : Forward the packet the IP address specified in fltStmtActionArg. reject(4) : Return an ICMP destination unreachable packet (type 3) to the packet sender with code 13 (communication administratively prohibited). This cannot be specified permit. log(5) : Write the packet to the log stream. There are some mutually exclusive bits: reset(0) and permit(1), permit(1) and deny(2), permit(1) and reject(4). No bits set implies to continue filtering on the packet.')
fltStmtActionArg = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 18), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtActionArg.setStatus('current')
if mibBuilder.loadTexts: fltStmtActionArg.setDescription('Filter statement action argument. The meaning of this object depends on the value of fltStmtAction: forward(3) : An IP address to forward the packet to. The value of this object must be non-zero. All other values of fltStmtAction have no relation to this object. The default is zero.')
fltStmtRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 3, 1, 19), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: fltStmtRowStatus.setStatus('current')
if mibBuilder.loadTexts: fltStmtRowStatus.setDescription('Zhone convention to support row creation and deletion. This is the only object required to create or destroy a row in this table.')
filterStmtRenumTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 4), )
if mibBuilder.loadTexts: filterStmtRenumTable.setStatus('current')
if mibBuilder.loadTexts: filterStmtRenumTable.setDescription('This table provides a mechanism for renumbering individual filter statments within their particular filter spec.')
filterStmtRenumEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 4, 1), )
filterStatementEntry.registerAugmentions(("ZHONE-COM-IP-FILTER-MIB", "filterStmtRenumEntry"))
filterStmtRenumEntry.setIndexNames(*filterStatementEntry.getIndexNames())
if mibBuilder.loadTexts: filterStmtRenumEntry.setStatus('current')
if mibBuilder.loadTexts: filterStmtRenumEntry.setDescription('An entry in the filterStmtRenumTable.')
fltStmtIndexNew = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fltStmtIndexNew.setStatus('current')
if mibBuilder.loadTexts: fltStmtIndexNew.setDescription("The new statement index for the filter statement. Reading this object will return the same value as the 'fltStmtIndex' portion of its index. Writing to this object will cause the corresponding filter statement to be relocated to the position identified by the value written here. If no statement exists at the current index, 'no such instance' will be returned. If a statement already exists at the new index then 'inconsistent value' is returned. For example, to move the second statement of filter #4 to the third position (e.g. to make room for a new statement #2), the following SNMP set-request would be issued: fltStmtIndexNew.4.2 = 3 There is no default value for this object as it is derived from the fltStmtIndex.")
filterStatsTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5), )
if mibBuilder.loadTexts: filterStatsTable.setStatus('current')
if mibBuilder.loadTexts: filterStatsTable.setDescription('This table provides ingress and egress IP filter statistics for each interface. This table is indexed by the ifIndex of the interface and the direction (ingress or egress) of traffic being filtered. This is a read-only table.')
filterStatsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "ZHONE-COM-IP-FILTER-MIB", "fltStatDirection"))
if mibBuilder.loadTexts: filterStatsEntry.setStatus('current')
if mibBuilder.loadTexts: filterStatsEntry.setDescription('An entry in the filterStatsTable. There will be an entry for each filter provisioned on an interface. There can be, at most, two filters provisioned per interface; one for ingress filtering and the other for egress filtering.')
fltStatDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ingress", 1), ("egress", 2))))
if mibBuilder.loadTexts: fltStatDirection.setStatus('current')
if mibBuilder.loadTexts: fltStatDirection.setDescription('The direction for which this set of statistics is kept: ingress or egress.')
fltStatResetPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 2), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatResetPkts.setStatus('current')
if mibBuilder.loadTexts: fltStatResetPkts.setDescription('The number of discarded packets for which a TCP reset packet was sent.')
fltStatPermitPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 3), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatPermitPkts.setStatus('current')
if mibBuilder.loadTexts: fltStatPermitPkts.setDescription('The number of permitted packets.')
fltStatDenyPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 4), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatDenyPkts.setStatus('current')
if mibBuilder.loadTexts: fltStatDenyPkts.setDescription('The number of discarded packets.')
fltStatForwardPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 5), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatForwardPkts.setStatus('current')
if mibBuilder.loadTexts: fltStatForwardPkts.setDescription('The number of packets forwarded to the IP address specified in the filter.')
fltStatRejectPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 6), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatRejectPkts.setStatus('current')
if mibBuilder.loadTexts: fltStatRejectPkts.setDescription('The number of discarded packets for which an ICMP destination unreachable packet with code 13 was sent.')
fltStatLogPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 7), Counter32()).setUnits('packets').setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatLogPkts.setStatus('current')
if mibBuilder.loadTexts: fltStatLogPkts.setDescription('The number of logged packets.')
fltStatDefaultPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatDefaultPkts.setStatus('current')
if mibBuilder.loadTexts: fltStatDefaultPkts.setDescription('The number of packets that pass through the filter without matching upon which the default action is used.')
fltStatSpecVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 9), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatSpecVersion.setStatus('current')
if mibBuilder.loadTexts: fltStatSpecVersion.setDescription('The version of the filter being used on this interface.')
fltStatSpecIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 5, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fltStatSpecIndex.setStatus('current')
if mibBuilder.loadTexts: fltStatSpecIndex.setDescription('The index of the filter specification being used on this interface. If there is no filter configured for an interface, the entry will not exist in this table.')
mcastControl = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6))
if mibBuilder.loadTexts: mcastControl.setStatus('current')
if mibBuilder.loadTexts: mcastControl.setDescription('The MIB module representing Multicast control list specifications in Zhone Technologies products. The First application of multicast control list is to accept of deny a IGMP request to join or leave a IGMP group. Any IGMP request to join a group is accepted only if the group address is available in the Multicast Control list pointed by a field in the ip-interface-record.')
mcastControlListTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6, 1), )
if mibBuilder.loadTexts: mcastControlListTable.setStatus('current')
if mibBuilder.loadTexts: mcastControlListTable.setDescription('Multicast control list table conatins the one of the IP Address that can be allowed to join to by a IGMP join request from IP interface that has the the multicast control list in its ip-interfce-profile. The address to the table is the multicast control list ID and the precedence. The Row status in the table contains indication of whether the row is being created or destroyed. ')
mcastControlListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6, 1, 1), ).setIndexNames((0, "ZHONE-COM-IP-FILTER-MIB", "mcastControlListControlId"), (0, "ZHONE-COM-IP-FILTER-MIB", "mcastControlListControlPrecedence"))
if mibBuilder.loadTexts: mcastControlListEntry.setStatus('current')
if mibBuilder.loadTexts: mcastControlListEntry.setDescription('An entry in the Multicast Control List.')
mcastControlListControlId = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mcastControlListControlId.setStatus('current')
if mibBuilder.loadTexts: mcastControlListControlId.setDescription('Description.')
mcastControlListControlPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6, 1, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: mcastControlListControlPrecedence.setStatus('current')
if mibBuilder.loadTexts: mcastControlListControlPrecedence.setDescription('Description.')
mcastControlListRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6, 1, 1, 3), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastControlListRowStatus.setStatus('current')
if mibBuilder.loadTexts: mcastControlListRowStatus.setDescription('Description.')
mcastControlListIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6, 1, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastControlListIpAddress.setStatus('current')
if mibBuilder.loadTexts: mcastControlListIpAddress.setDescription('multicast ip address.')
mcastControlListType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 6, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("always-on", 2), ("periodic", 3))).clone('normal')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: mcastControlListType.setStatus('current')
if mibBuilder.loadTexts: mcastControlListType.setDescription('Defines the video stream type. normal - join and leave when desired. Used for video. always-on - always joined. Meant for EBS, not video. periodic - will join and leave after task complete. Not meant for video. Used to download the tv guide.')
portAccessControl = ObjectIdentity((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7))
if mibBuilder.loadTexts: portAccessControl.setStatus('current')
if mibBuilder.loadTexts: portAccessControl.setDescription('This MIB represents the port access control list in Zhone products. It is used to control access to internal ports. Initially it is used just for TELNET (23) , but in theory could be used for other ports as well.')
portAccessNextIndex = MibScalar((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portAccessNextIndex.setStatus('current')
if mibBuilder.loadTexts: portAccessNextIndex.setDescription('Description: A hint for the next free index should the manager want to create a new entry.')
portAccessTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 2), )
if mibBuilder.loadTexts: portAccessTable.setStatus('current')
if mibBuilder.loadTexts: portAccessTable.setDescription('Contains the list of entries that control port access on this device.')
portAccessEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 2, 1), ).setIndexNames((0, "ZHONE-COM-IP-FILTER-MIB", "portAccessIndex"))
if mibBuilder.loadTexts: portAccessEntry.setStatus('current')
if mibBuilder.loadTexts: portAccessEntry.setDescription('This contains the entry that is to be accepted. Currently only used to control access to port 23. arg1, arg2 provide IP Address/mask to allow in.')
portAccessIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100)))
if mibBuilder.loadTexts: portAccessIndex.setStatus('current')
if mibBuilder.loadTexts: portAccessIndex.setDescription('The index of this entry in table. 100 entries should be more than enough.')
portAccessRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 2, 1, 2), ZhoneRowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portAccessRowStatus.setStatus('current')
if mibBuilder.loadTexts: portAccessRowStatus.setDescription('Description.: used to create/delete entries in the table.')
portAccessNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1023))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portAccessNumber.setStatus('current')
if mibBuilder.loadTexts: portAccessNumber.setDescription('PortNumber that this applies to, 1..1023 supported.')
portAccessSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 2, 1, 4), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portAccessSrcAddr.setStatus('current')
if mibBuilder.loadTexts: portAccessSrcAddr.setDescription('The IP address that we will accept packets from.')
portAccessNetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 4, 1, 8, 7, 2, 1, 5), IpAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: portAccessNetMask.setStatus('current')
if mibBuilder.loadTexts: portAccessNetMask.setDescription('portAccessNetMask - used to pass the range that we will accept with regards to portAccessSrcAddr.')
mibBuilder.exportSymbols("ZHONE-COM-IP-FILTER-MIB", fltStmtIpDstAddrLow=fltStmtIpDstAddrLow, fltStmtIpSrcAddrHigh=fltStmtIpSrcAddrHigh, mcastControlListIpAddress=mcastControlListIpAddress, fltSpecVersion1=fltSpecVersion1, fltStatSpecIndex=fltStatSpecIndex, portAccessSrcAddr=portAccessSrcAddr, fltStatSpecVersion=fltStatSpecVersion, portAccessNumber=portAccessNumber, fltStmtIpProtocol=fltStmtIpProtocol, fltStmtModifier=fltStmtModifier, fltSpecLanguageVersion=fltSpecLanguageVersion, fltStmtSrcPortLow=fltStmtSrcPortLow, mcastControlListControlPrecedence=mcastControlListControlPrecedence, fltStmtActionArg=fltStmtActionArg, fltSpecVersion2=fltSpecVersion2, filterStmtRenumEntry=filterStmtRenumEntry, filterStmtRenumTable=filterStmtRenumTable, portAccessTable=portAccessTable, mcastControlListControlId=mcastControlListControlId, fltStmtIpDstAddrHigh=fltStmtIpDstAddrHigh, fltStmtRowStatus=fltStmtRowStatus, comIpFilter=comIpFilter, portAccessControl=portAccessControl, fltStatDirection=fltStatDirection, mcastControl=mcastControl, fltStmtArbValueLow=fltStmtArbValueLow, mcastControlListTable=mcastControlListTable, filterGlobal=filterGlobal, fltSpecIndex=fltSpecIndex, PYSNMP_MODULE_ID=comIpFilter, fltStmtSrcPortHigh=fltStmtSrcPortHigh, filterStatsTable=filterStatsTable, fltStmtArbMask=fltStmtArbMask, fltGlobalIndexNext=fltGlobalIndexNext, fltStmtIndexNew=fltStmtIndexNew, mcastControlListRowStatus=mcastControlListRowStatus, filterStatsEntry=filterStatsEntry, fltStmtArbValueBase=fltStmtArbValueBase, fltStatLogPkts=fltStatLogPkts, fltStatResetPkts=fltStatResetPkts, fltStatPermitPkts=fltStatPermitPkts, mcastControlListType=mcastControlListType, portAccessIndex=portAccessIndex, fltStmtDstPortLow=fltStmtDstPortLow, fltGlobalTimeout=fltGlobalTimeout, filterStatementTable=filterStatementTable, fltStatDefaultPkts=fltStatDefaultPkts, filter=filter, fltStmtArbOffset=fltStmtArbOffset, portAccessEntry=portAccessEntry, portAccessNextIndex=portAccessNextIndex, fltStatRejectPkts=fltStatRejectPkts, mcastControlListEntry=mcastControlListEntry, filterStatementEntry=filterStatementEntry, fltStmtIndex=fltStmtIndex, filterSpecTable=filterSpecTable, fltSpecRowStatus=fltSpecRowStatus, fltStmtArbValueHigh=fltStmtArbValueHigh, portAccessNetMask=portAccessNetMask, portAccessRowStatus=portAccessRowStatus, fltStmtAction=fltStmtAction, fltStmtIpSrcAddrLow=fltStmtIpSrcAddrLow, filterSpecEntry=filterSpecEntry, fltStatDenyPkts=fltStatDenyPkts, fltSpecDesc=fltSpecDesc, fltSpecName=fltSpecName, fltStmtDstPortHigh=fltStmtDstPortHigh, fltStatForwardPkts=fltStatForwardPkts)

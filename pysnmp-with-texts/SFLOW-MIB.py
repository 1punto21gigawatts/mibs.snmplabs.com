#
# PySNMP MIB module SFLOW-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/SFLOW-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:19:03 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint")
dlink_common_mgmt, = mibBuilder.importSymbols("DLINK-ID-REC-MIB", "dlink-common-mgmt")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Gauge32, ObjectIdentity, Counter64, Counter32, enterprises, NotificationType, Integer32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, MibIdentifier, iso, Unsigned32, TimeTicks, ModuleIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "ObjectIdentity", "Counter64", "Counter32", "enterprises", "NotificationType", "Integer32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "MibIdentifier", "iso", "Unsigned32", "TimeTicks", "ModuleIdentity")
DisplayString, TextualConvention, RowStatus = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention", "RowStatus")
sFlowMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 171, 12, 36))
if mibBuilder.loadTexts: sFlowMIB.setLastUpdated('0810300000Z')
if mibBuilder.loadTexts: sFlowMIB.setOrganization('D-Link Corp.')
if mibBuilder.loadTexts: sFlowMIB.setContactInfo('http://support.dlink.com')
if mibBuilder.loadTexts: sFlowMIB.setDescription('The Structure of sFlow for the proprietary enterprise.')
sFlowAgent = MibIdentifier((1, 3, 6, 1, 4, 1, 171, 12, 36, 1))
class SFlowDataSource(TextualConvention, Integer32):
    description = "Identifies a source of sFlow data. The following data source types are currently defined: - ifIndex.<I> SFlowDataSources of this traditional form are called 'port-based'. Ideally the sampling entity will perform sampling on all flows originating from or destined to the specified interface. However, if the switch architecture only allows input or output sampling then the sampling agent is permitted to only sample input flows input or output flows. Each packet must only be considered once for sampling, irrespective of the number of ports it will be forwarded to. Note: Port 0 is used to indicate that all ports on the device are represented by a single data source. - sFlowFsPacketSamplingRate applies to all ports on the device capable of packet sampling. - smonVlanDataSource.<V> An SFlowDataSource of this form refers to a 'Packet-based VLAN' and is called a 'VLAN-based' dataSource. <V> is the VLAN ID as defined by the IEEE 802.1Q standard. The value is between 1 and 4094 inclusive, and it represents an 802.1Q VLAN-ID with global scope within a given bridged domain. Sampling is performed on all packets received that are part of the specified VLAN (no matter which port they arrived on). Each packet will only be considered once for sampling, irrespective of the number of ports it will be forwarded to. - entPhysicalEntry.<N> An SFlowDataSource of this form refers to a physical entity within the agent (e.g. entPhysicalClass = backplane(4)) and is called an 'entity-based' dataSource. Sampling is performed on all packets entering the resource (e.g. If the backplane is being sampled, all packets transmitted onto the backplane will be considered as single candidates for sampling irrespective of the number of ports they ultimately reach). Note: Since each SFlowDataSource operates independently a packet that crosses multiple DataSources may generate multiple flow records."
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 65535)

class SFlowReceiver(TextualConvention, Integer32):
    description = 'Identify the sFlow receiver associated with this resource. A value of zero indicates that this resource is available. If non-zero, the value must correspond to a valid, active sFlowRcvrIndex. If the value is currently zero, it may be set to any active entry in the sFlowRcvrTable. If the value is not zero, then set to anything other than zero or its current value will result in an SNMP error (bad value). Setting to zero frees the resource and returns all the values in this entry to their default values. If an entry in the sFlowRcvrTable expires, either because the sFlowRcvrOwner is set to the empty string or because the sFlowRcvrTimeout reaches zero, then the agent must mark all associated resources as available (by setting the associated SFlowReceiver entry to zero) and all values in these records must be restored to their default values. This mechanism provides no enforcement and relies on the cooperation of management entities in order to ensure that competition for a resource is fairly resolved. A management entity should not make any changes to a resource without first acquiring it by successfully writing its sFlowRcvrIndex value as the SFlowReceiver for the resource.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(1, 4)

sFlowVersion = MibScalar((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 1), SnmpAdminString().clone('1.00')).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFlowVersion.setStatus('current')
if mibBuilder.loadTexts: sFlowVersion.setDescription('This indicates the sFlow version')
sFlowAgentAddress = MibScalar((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sFlowAgentAddress.setStatus('current')
if mibBuilder.loadTexts: sFlowAgentAddress.setDescription('The IP address associated with this agent.')
sFlowAgentState = MibScalar((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowAgentState.setStatus('current')
if mibBuilder.loadTexts: sFlowAgentState.setDescription('This object can enable or disable sFlow.')
sFlowRcvrTable = MibTable((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4), )
if mibBuilder.loadTexts: sFlowRcvrTable.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrTable.setDescription('A table of the receivers of sFlow information.')
sFlowRcvrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1), ).setIndexNames((0, "SFLOW-MIB", "sFlowRcvrIndex"), (0, "SFLOW-MIB", "sFlowRcvrOwner"))
if mibBuilder.loadTexts: sFlowRcvrEntry.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrEntry.setDescription('Attributes of an sFlow Receiver.')
sFlowRcvrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 4)))
if mibBuilder.loadTexts: sFlowRcvrIndex.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrIndex.setDescription('Index into sFlowReceiverTable.')
sFlowRcvrOwner = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 16)))
if mibBuilder.loadTexts: sFlowRcvrOwner.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrOwner.setDescription('The entity making use of this sFlowRcvrTable entry. The empty string indicates that the entry is currently unclaimed. An entity wishing to claim an sFlowRcvrTable entry must ensure that the entry is unclaimed before trying to claim it. The entry is claimed by setting the owner string. The entry must be claimed before any changes can be made to other sampler objects. In order to avoid a race condition, the entity taking control of the sampler should set both the owner and a value for sFlowRcvrTimeout in the same SNMP set request. This mechanism provides no enforcement and relies on the cooperation of management entities in order to ensure that competition for a receiver entry is fairly resolved.')
sFlowRcvrTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 2000000))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowRcvrTimeout.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrTimeout.setDescription('The time (in seconds) remaining before the sampler is released and stops sampling. When set, the owner establishes control for the specified period. When read, the remaining time in the interval is returned. A management entity wanting to maintain control of the sampler is responsible for setting a new value before the old one expires. When the interval expires, the agent is responsible for restoring all other entities in this row to their default values. It must also free all other resources associated with this sFlowRcvrTable entry. The value 0 indicate it is never time out. ')
sFlowRcvrMaximumDatagramSize = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 1400)).clone(1400)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowRcvrMaximumDatagramSize.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrMaximumDatagramSize.setDescription('The maximum number of data bytes that can be sent in a single sample datagram. The manager should set this value to avoid fragmentation of the sFlow datagrams.')
sFlowRcvrAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1, 5), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowRcvrAddress.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrAddress.setDescription('The IP address of the sFlow collector. If set to 0.0.0.0, no sFlow datagrams will be sent.')
sFlowRcvrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(6343)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowRcvrPort.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrPort.setDescription('The destination port for sFlow datagrams.')
sFlowRcvrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 4, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sFlowRcvrRowStatus.setStatus('current')
if mibBuilder.loadTexts: sFlowRcvrRowStatus.setDescription('This object indicates the status of this entry.')
sFlowFsTable = MibTable((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 5), )
if mibBuilder.loadTexts: sFlowFsTable.setStatus('current')
if mibBuilder.loadTexts: sFlowFsTable.setDescription('A table of the flow samplers within a device.')
sFlowFsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 5, 1), ).setIndexNames((0, "SFLOW-MIB", "sFlowFsDataSource"), (0, "SFLOW-MIB", "sFlowFsReceiver"))
if mibBuilder.loadTexts: sFlowFsEntry.setStatus('current')
if mibBuilder.loadTexts: sFlowFsEntry.setDescription('Attributes of a flow sampler.')
sFlowFsDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 5, 1, 1), SFlowDataSource())
if mibBuilder.loadTexts: sFlowFsDataSource.setStatus('current')
if mibBuilder.loadTexts: sFlowFsDataSource.setDescription('sFlowDataSource for this flow sampler.')
sFlowFsReceiver = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 5, 1, 3), SFlowReceiver())
if mibBuilder.loadTexts: sFlowFsReceiver.setStatus('current')
if mibBuilder.loadTexts: sFlowFsReceiver.setDescription('The SFlowReceiver for this flow sampler.')
sFlowFsPacketSamplingRate = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 5, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowFsPacketSamplingRate.setStatus('current')
if mibBuilder.loadTexts: sFlowFsPacketSamplingRate.setDescription('The statistical sampling rate for packet sampling from this source. Set to N to sample 1/Nth of the packets in the monitored flows. An agent should choose its own algorithm to introduce variance into the sampling so that exactly every Nth packet is not counted. A sampling rate of 1 counts all packets. A sampling rate of 0 disables sampling. The agent is permitted to have minimum and maximum allowable values for the sampling rate. A minimum rate lets the agent designer set an upper bound on the overhead associated with sampling, and a maximum rate may be the result of hardware restrictions (such as counter size). In addition not all values between the maximum and minimum may be realizable as the sampling rate (again because of implementation considerations). When the sampling rate is set the agent is free to adjust the value so that it lies between the maximum and minimum values and has the closest achievable value. When read, the agent must return the actual sampling rate it will be using (after the adjustments previously described). The sampling algorithm must converge so that over time the number of packets sampled approaches 1/Nth of the total number of packets in the monitored flows.')
sFlowFsMaximumHeaderSize = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 5, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(18, 256)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowFsMaximumHeaderSize.setStatus('current')
if mibBuilder.loadTexts: sFlowFsMaximumHeaderSize.setDescription('The maximum number of bytes that should be copied from a sampled packet. The agent may have an internal maximum and minimum permissible sizes. If an attempt is made to set this value outside the permissible range then the agent should adjust the value to the closest permissible value.')
sFlowFsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 5, 1, 6), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sFlowFsRowStatus.setStatus('current')
if mibBuilder.loadTexts: sFlowFsRowStatus.setDescription('This object indicates the status of this entry.')
sFlowCpTable = MibTable((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 6), )
if mibBuilder.loadTexts: sFlowCpTable.setStatus('current')
if mibBuilder.loadTexts: sFlowCpTable.setDescription('A table of the counter pollers within a device.')
sFlowCpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 6, 1), ).setIndexNames((0, "SFLOW-MIB", "sFlowCpDataSource"), (0, "SFLOW-MIB", "sFlowCpReceiver"))
if mibBuilder.loadTexts: sFlowCpEntry.setStatus('current')
if mibBuilder.loadTexts: sFlowCpEntry.setDescription('Attributes of a counter poller.')
sFlowCpDataSource = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 6, 1, 1), SFlowDataSource())
if mibBuilder.loadTexts: sFlowCpDataSource.setStatus('current')
if mibBuilder.loadTexts: sFlowCpDataSource.setDescription('Identifies the source of the data for the counter poller.')
sFlowCpReceiver = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 6, 1, 3), SFlowReceiver())
if mibBuilder.loadTexts: sFlowCpReceiver.setStatus('current')
if mibBuilder.loadTexts: sFlowCpReceiver.setDescription('The SFlowReciever associated with this counter poller.')
sFlowCpInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 6, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 120))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sFlowCpInterval.setStatus('current')
if mibBuilder.loadTexts: sFlowCpInterval.setDescription('The maximum number of seconds between successive samples of the counters associated with this data source. A sampling interval of 0 disables counter sampling. The agent is permitted to have minimum and maximum allowable values for the counter polling interval. A minimum interval lets the agent designer set an upper bound on the overhead associated with polling, and a maximum interval may be the result of implementation restrictions (such as counter size). In addition not all values between the maximum and minimum may be realizable as the sampling interval (again because of implementation considerations). The minimum sampling interval is 20, the maximum sampling interval is 120. ')
sFlowCpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 171, 12, 36, 1, 6, 1, 5), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: sFlowCpRowStatus.setStatus('current')
if mibBuilder.loadTexts: sFlowCpRowStatus.setDescription('This object indicates the status of this entry.')
mibBuilder.exportSymbols("SFLOW-MIB", sFlowRcvrEntry=sFlowRcvrEntry, sFlowRcvrMaximumDatagramSize=sFlowRcvrMaximumDatagramSize, sFlowRcvrRowStatus=sFlowRcvrRowStatus, sFlowRcvrOwner=sFlowRcvrOwner, sFlowCpInterval=sFlowCpInterval, sFlowCpReceiver=sFlowCpReceiver, sFlowCpRowStatus=sFlowCpRowStatus, sFlowAgentAddress=sFlowAgentAddress, sFlowFsMaximumHeaderSize=sFlowFsMaximumHeaderSize, sFlowCpTable=sFlowCpTable, sFlowRcvrTimeout=sFlowRcvrTimeout, SFlowReceiver=SFlowReceiver, sFlowFsTable=sFlowFsTable, sFlowCpEntry=sFlowCpEntry, sFlowAgentState=sFlowAgentState, sFlowFsPacketSamplingRate=sFlowFsPacketSamplingRate, PYSNMP_MODULE_ID=sFlowMIB, sFlowFsReceiver=sFlowFsReceiver, SFlowDataSource=SFlowDataSource, sFlowAgent=sFlowAgent, sFlowVersion=sFlowVersion, sFlowFsEntry=sFlowFsEntry, sFlowRcvrPort=sFlowRcvrPort, sFlowCpDataSource=sFlowCpDataSource, sFlowFsRowStatus=sFlowFsRowStatus, sFlowFsDataSource=sFlowFsDataSource, sFlowRcvrTable=sFlowRcvrTable, sFlowRcvrIndex=sFlowRcvrIndex, sFlowRcvrAddress=sFlowRcvrAddress, sFlowMIB=sFlowMIB)

#
# PySNMP MIB module Nortel-Magellan-Passport-SubnetInterfaceMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-Magellan-Passport-SubnetInterfaceMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:28:24 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
modIndex, mod = mibBuilder.importSymbols("Nortel-Magellan-Passport-ShelfMIB", "modIndex", "mod")
DisplayString, Unsigned32, RowStatus, Integer32, StorageType = mibBuilder.importSymbols("Nortel-Magellan-Passport-StandardTextualConventionsMIB", "DisplayString", "Unsigned32", "RowStatus", "Integer32", "StorageType")
DigitString, NonReplicated = mibBuilder.importSymbols("Nortel-Magellan-Passport-TextualConventionsMIB", "DigitString", "NonReplicated")
passportMIBs, = mibBuilder.importSymbols("Nortel-Magellan-Passport-UsefulDefinitionsMIB", "passportMIBs")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
TimeTicks, Bits, Unsigned32, iso, Gauge32, MibIdentifier, Counter32, NotificationType, Integer32, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Counter64, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "TimeTicks", "Bits", "Unsigned32", "iso", "Gauge32", "MibIdentifier", "Counter32", "NotificationType", "Integer32", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Counter64", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
subnetInterfaceMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45))
modVcs = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2))
modVcsRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 1), )
if mibBuilder.loadTexts: modVcsRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsRowStatusTable.setDescription('This entry controls the addition and deletion of modVcs components.')
modVcsRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 1, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"), (0, "Nortel-Magellan-Passport-SubnetInterfaceMIB", "modVcsIndex"))
if mibBuilder.loadTexts: modVcsRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsRowStatusEntry.setDescription('A single entry in the table represents a single modVcs component.')
modVcsRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsRowStatus.setDescription('This variable is used as the basis for SNMP naming of modVcs components. These components can be added and deleted.')
modVcsComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modVcsComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
modVcsStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: modVcsStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsStorageType.setDescription('This variable represents the storage type value for the modVcs tables.')
modVcsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: modVcsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsIndex.setDescription('This variable represents the index for the modVcs tables.')
modVcsAccOptTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 10), )
if mibBuilder.loadTexts: modVcsAccOptTable.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsAccOptTable.setDescription("Accounting information is owned by the Vc System; it is stored in the Vc Accounting component, which itself is considered to be a component on the switch. The Accounting Component contains a bit map indicating which of the accounting facilities are to be spooled in the accounting record - for example, bit '0' if set indicates that the accounting facility with facility code H.00 should be spooled if present in the Vc for accounting purposes. The data contained in the Vc Accounting must be identical network wide even though the component can be changed and upgraded on a module by module basis.")
modVcsAccOptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 10, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"), (0, "Nortel-Magellan-Passport-SubnetInterfaceMIB", "modVcsIndex"))
if mibBuilder.loadTexts: modVcsAccOptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsAccOptEntry.setDescription('An entry in the modVcsAccOptTable.')
modVcsSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n1", 0), ("n2", 1), ("n4", 2), ("n8", 3), ("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n128')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsSegmentSize.setDescription('This attribute specifies the segment size for accounting of national calls. Minimum allowed segment size is 1. If data segment is sent which is less than segmentSize it is still counted as one segment.')
modVcsUnitsCounted = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("segments", 0), ("frames", 1))).clone('segments')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsUnitsCounted.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsUnitsCounted.setDescription('This attribute specifies what is counted by frame services. If set to frames, frames are counted, else segments are counted.')
modVcsAccountingFax = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="20")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsAccountingFax.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsAccountingFax.setDescription('Each value corresponds to an accounting facility code, of which there are currently 10 facility codes defined with codes H.00 to H.09, and corresponding to the above 10 facilities. Each of the above facilities may or may not be present and stored in the Vc for accounting purposes, depending on the nature of the call. For example, only those Vcs where a NUI (Network User Identifier) is used for charging or identification purposes will have a NUI stored in the Vc. Description of bits: notused0(0) notused1(1) originalCalledAddressFax(2)')
modVcsGenerationMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("bothEnds", 0), ("singleEnd", 1))).clone('singleEnd')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsGenerationMode.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsGenerationMode.setDescription('This attribute specifies part of the rules by which the network generates accounting records. If set to bothEnds, then both ends of the Vc generate accounting records. If set to singleEnd, then the charged end of the Vc generates accounting records. In single end generation mode, if the call does not clear gracefully, both ends of the Vc will generate accounting record.')
modVcsAddOptTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12), )
if mibBuilder.loadTexts: modVcsAddOptTable.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsAddOptTable.setDescription('The Vc AddressingOptions group describes the addressing parameters. It is currently owned by the Vc. Most of the data contained in the Vc AddressingOptions group is identical network wide even though the group can be changed and upgraded on a module by module basis.')
modVcsAddOptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"), (0, "Nortel-Magellan-Passport-SubnetInterfaceMIB", "modVcsIndex"))
if mibBuilder.loadTexts: modVcsAddOptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsAddOptEntry.setDescription('An entry in the modVcsAddOptTable.')
modVcsDefaultNumberingPlan = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsDefaultNumberingPlan.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsDefaultNumberingPlan.setDescription('This attribute specifies the numbering plan used which determines the address format: X.121-- the international numbering plan for public packet switched data networks or E.164-- the international numbering plan for ISDN and PSTN. The default numbering plan does not need to be consistent across all of the nodes in the network.')
modVcsNetworkIdType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("dnic", 0), ("inic", 1))).clone('dnic')).setMaxAccess("readonly")
if mibBuilder.loadTexts: modVcsNetworkIdType.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsNetworkIdType.setDescription('This attribute specifies whether the network uses a DNIC or INIC. It is used by X.75 Gateways to indicate whether in network the DNIC or INIC is used in various utilities. If it is DNIC it can be DNIC or DCC type. If it is INIC it can be 4 digits only.')
modVcsX121Type = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("dnic", 0), ("dcc", 1))).clone('dnic')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsX121Type.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsX121Type.setDescription('This attribute specifies whether DNIC mode or DCC mode is used in X.121 address of international calls. If DCC is specified, then the first 3 digits of each DNA must be the Network ID Code. If this attribute is changed all Dnas in the network must start with this code. Numbering plan is affected by the change.')
modVcsNetworkIdCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 6), DigitString().subtype(subtypeSpec=ValueSizeConstraint(3, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsNetworkIdCode.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsNetworkIdCode.setDescription('This attribute specifies the DNIC (Data Network ID Code) of the network or DCC code.')
modVcsX121IntlAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsX121IntlAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsX121IntlAddresses.setDescription('This attribute indicates if any DTE is allowed to signal international addresses.')
modVcsX121IntllPrefixDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(9)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsX121IntllPrefixDigit.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsX121IntllPrefixDigit.setDescription('This attribute indicates the prefix digit to be used for X.121 international calls. When this digit is provided the call will have full international address.')
modVcsX121MinAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsX121MinAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsX121MinAddressLength.setDescription('This attribute indicates minimum length of x121 address.')
modVcsX121MaxAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsX121MaxAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsX121MaxAddressLength.setDescription('This attribute indicates maximum length of x121 address.')
modVcsX121ToE164EscapeSignificance = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsX121ToE164EscapeSignificance.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsX121ToE164EscapeSignificance.setDescription('This attribute specifies whether an X.121 to E.164 escape digit has significance in selecting an X.32 (analog) or an ISDN switched path. If two values are significant (the value 0 or the value 9) then yes is set to this attribute. If the value of the originally entered escape digit is not significant in routing the call then value of no is assigned to this attribute.')
modVcsE164IntlFormatAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164IntlFormatAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164IntlFormatAllowed.setDescription("This attribute indicates whether or not to allow national format E.164 addresses. If this attribute is set to a value of Yes (=1) then national format E.164 addresses are not allowed and international format addresses only are allowed. If this attribute is set to a value of No (=0), then national format E.164 addresses are allowed. If only international format E.164 addresses are allowed, then the 'e164NatlPrefixDigit' attribute is not required, nor is the 'e164IntlPrefixDigits' required.")
modVcsE164IntlPrefixDigits = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 15), DigitString().subtype(subtypeSpec=ValueSizeConstraint(0, 3)).clone(hexValue="30")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164IntlPrefixDigits.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164IntlPrefixDigits.setDescription("This attribute specifies the E.164 international prefix digits. If applicable, it is specified as 1 to 3 BCD digits. The 3 BCD digits are stored with the length of the international prefix in the low order nibble, nibble [0] followed by the most significant digit of the international prefix in the next low order nibble, nibble [1], etc. This attribute is not required if the corresponding attribute, 'e164IntlFormatOnly' is set to a value of Yes (=1).")
modVcsE164NatlPrefixDigit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 9)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164NatlPrefixDigit.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164NatlPrefixDigit.setDescription('This attribute contains the E.164 national prefix which may be added in front of E.164 local or national call. If e164IntlFormatOnly is set to 1, this attribute is not needed.')
modVcsE164LocalAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(4, 15)).clone(7)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164LocalAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164LocalAddressLength.setDescription('This attribute indicates the length of a local E.164 DNA on this module. This attribute is not required if the corresponding attribute, e164IntlFormatOnly is set to a value of yes. This attribute does not need to be consistent across all of the nodes in the network.')
modVcsE164TeleCountryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 18), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 4)).clone(hexValue="31")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164TeleCountryCode.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164TeleCountryCode.setDescription('This attribute specifies the E.164 Telephone Country Code (TCC) for the country in which the network resides. If applicable, it is specified as 1 to 3 BCD digits. The 3 BCD digits are stored with the length of the TCC in the low order nibble, nibble [0] followed by the most significant digit of the TCC in the next low order nibble, nibble [1], etc.')
modVcsE164NatlMinAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164NatlMinAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164NatlMinAddressLength.setDescription('This attribute indicates minimum length of e164 national address.')
modVcsE164NatlMaxAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 21), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164NatlMaxAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164NatlMaxAddressLength.setDescription('This attribute indicates maximum length of e164 national address.')
modVcsE164IntlMinAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164IntlMinAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164IntlMinAddressLength.setDescription('This attribute indicates minimum length of e164 international address.')
modVcsE164IntlMaxAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 23), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164IntlMaxAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164IntlMaxAddressLength.setDescription('This attribute indicates maximum length of e164 international address.')
modVcsE164LocalMinAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 24), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(1)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164LocalMinAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164LocalMinAddressLength.setDescription('This attribute indicates minimum length of e164 local address.')
modVcsE164LocalMaxAddressLength = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 12, 1, 25), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 16)).clone(15)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsE164LocalMaxAddressLength.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsE164LocalMaxAddressLength.setDescription('This attribute indicates maximum length of e164 local address.')
modVcsIntOptTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 13), )
if mibBuilder.loadTexts: modVcsIntOptTable.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsIntOptTable.setDescription('The Vc InterfaceOptions group defines Vc system parameters common in the network. It is owned by the Vc and is considered to be a module wide component on the switch. The data contained in the Vc InterfaceOptions group must be identical network wide even though this group can be changed and upgraded on a module by module basis.')
modVcsIntOptEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 13, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"), (0, "Nortel-Magellan-Passport-SubnetInterfaceMIB", "modVcsIndex"))
if mibBuilder.loadTexts: modVcsIntOptEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsIntOptEntry.setDescription('An entry in the modVcsIntOptTable.')
modVcsHighPriorityPacketSizes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 13, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2).clone(hexValue="ff80")).setMaxAccess("readonly")
if mibBuilder.loadTexts: modVcsHighPriorityPacketSizes.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsHighPriorityPacketSizes.setDescription('This attribute indicates which packet sizes are supported for high priority calls within the network. Description of bits: n16(0) n32(1) n64(2) n128(3) n256(4) n512(5) n1024(6) n2048(7) n4096(8)')
modVcsMaxSubnetPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("n16", 4), ("n32", 5), ("n64", 6), ("n128", 7), ("n256", 8), ("n512", 9), ("n1024", 10), ("n2048", 11), ("n4096", 12))).clone('n512')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsMaxSubnetPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsMaxSubnetPacketSize.setDescription('This attribute specifies the maximum subnet packet size used for the connections originating or terminating on this module. All modules in the same network should have the same maxSubnetPacketSize. If this value is not identical throughout the network, the following points need to be considered: a) When Passport and DPN switches are connected in the same network, the maxSubnetPacketSize on a DPN switch can be at most 2048 and the DPN part of the network must be configured with hardware which supports this size: - Dedicated PE386 Network link/Trunk - Minimum measured link speed of 256Kbits/sec This hardware has to be present on every potential data path between connecting end points! b) The calling end of the connection signals the maxSubnetPacketSize value to the called end. The called end then compares this value to its own provisioned value and selects the smaller value. Note that this smaller value is not signalled back to the calling end. The calling and called ends can therefore have different maxSubnetPacketSize values.')
modVcsCallSetupTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 13, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 100)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsCallSetupTimer.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsCallSetupTimer.setDescription('This attribute specifies the Vc callSetupTimer in units of 1 second ticks. This timer specifies how long the Vc will wait, after sending a subnet Call Request packet into the network, for a response from the remote end of the Vc (in the form of a subnet Raccept packet). If, after sending a subnet Call packet into the network, a response is not received within this time period, the Vc will time out, clearing the call in the assumption that the remote end is unreachable. This timer must be long enough to take into account the time required for routing the subnet Call Request through the Source Call Routing and the Destination Call Routing systems in order to be delivered to the final destination.')
modVcsCallRetryTimer = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 13, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(30, 300)).clone(60)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsCallRetryTimer.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsCallRetryTimer.setDescription('This attribute specifies, for Vc implementing Direct Calls with the auto-call retry feature (including PVCs), the Vc callRetryTimer in units of 1 second ticks. This timer specifies how long the Vc will wait between unsuccessful call attempts.')
modVcsDelaySubnetAcks = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 13, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsDelaySubnetAcks.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsDelaySubnetAcks.setDescription('This attribute specifies delay acknowledgment timer mechanism. If this attribute is set to no, then the Vc will automatically return acknowledgment packets without delay. If this attribute is set to yes, then the Vc will wait for one second in an attempt to piggyback the acknowledgment packet on another credit or data packet. If the Vc cannot piggyback the acknowledgment packet within this time, then the packet is returned without piggybacking.')
modVcsWinsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 213), )
if mibBuilder.loadTexts: modVcsWinsTable.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsWinsTable.setDescription('This is the windowSize corresponding to the given packet size and throughput class. All Vcs using the windowSize matrix support large Vc windows on both ends of the Vc, and support the signalling of the chosen Vc window size from the destination (called) end to the source (calling) end. This is the only matrix supported. The windowSize should be configured in the same way network wide, though it can be upgraded on a module by module basis. Vcs using the windowSize matrix will run properly if the matrices on different nodes differ since the Vc window is selected by the destination (called) side of the Vc.')
modVcsWinsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 213, 1), ).setIndexNames((0, "Nortel-Magellan-Passport-ShelfMIB", "modIndex"), (0, "Nortel-Magellan-Passport-SubnetInterfaceMIB", "modVcsIndex"), (0, "Nortel-Magellan-Passport-SubnetInterfaceMIB", "modVcsWinsPktIndex"), (0, "Nortel-Magellan-Passport-SubnetInterfaceMIB", "modVcsWinsTptIndex"))
if mibBuilder.loadTexts: modVcsWinsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsWinsEntry.setDescription('An entry in the modVcsWinsTable.')
modVcsWinsPktIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 213, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("n16", 0), ("n32", 1), ("n64", 2), ("n128", 3), ("n256", 4), ("n512", 5), ("n1024", 6), ("n2048", 7), ("n4096", 8), ("n8192", 9), ("n32768", 10), ("n65535", 11))))
if mibBuilder.loadTexts: modVcsWinsPktIndex.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsWinsPktIndex.setDescription('This variable represents the next to last index for the modVcsWinsTable.')
modVcsWinsTptIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 213, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 15)))
if mibBuilder.loadTexts: modVcsWinsTptIndex.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsWinsTptIndex.setDescription('This variable represents the final index for the modVcsWinsTable.')
modVcsWinsValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 2, 4, 1, 16, 2, 213, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: modVcsWinsValue.setStatus('mandatory')
if mibBuilder.loadTexts: modVcsWinsValue.setDescription('This variable represents an individual value for the modVcsWinsTable.')
subnetInterfaceGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 1))
subnetInterfaceGroupBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 1, 5))
subnetInterfaceGroupBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 1, 5, 1))
subnetInterfaceGroupBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 1, 5, 1, 2))
subnetInterfaceCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 3))
subnetInterfaceCapabilitiesBE = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 3, 5))
subnetInterfaceCapabilitiesBE00 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 3, 5, 1))
subnetInterfaceCapabilitiesBE00A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 2, 4, 2, 45, 3, 5, 1, 2))
mibBuilder.exportSymbols("Nortel-Magellan-Passport-SubnetInterfaceMIB", subnetInterfaceMIB=subnetInterfaceMIB, modVcsE164IntlMaxAddressLength=modVcsE164IntlMaxAddressLength, subnetInterfaceCapabilitiesBE00=subnetInterfaceCapabilitiesBE00, modVcsE164NatlPrefixDigit=modVcsE164NatlPrefixDigit, modVcsWinsTable=modVcsWinsTable, modVcsAddOptTable=modVcsAddOptTable, modVcsX121IntlAddresses=modVcsX121IntlAddresses, modVcsWinsTptIndex=modVcsWinsTptIndex, modVcsAccOptEntry=modVcsAccOptEntry, modVcsHighPriorityPacketSizes=modVcsHighPriorityPacketSizes, modVcsIntOptTable=modVcsIntOptTable, modVcsRowStatusEntry=modVcsRowStatusEntry, modVcsRowStatus=modVcsRowStatus, subnetInterfaceGroup=subnetInterfaceGroup, subnetInterfaceGroupBE00A=subnetInterfaceGroupBE00A, subnetInterfaceGroupBE00=subnetInterfaceGroupBE00, modVcsX121MinAddressLength=modVcsX121MinAddressLength, modVcsDelaySubnetAcks=modVcsDelaySubnetAcks, modVcsRowStatusTable=modVcsRowStatusTable, modVcsAddOptEntry=modVcsAddOptEntry, modVcsCallSetupTimer=modVcsCallSetupTimer, modVcsX121IntllPrefixDigit=modVcsX121IntllPrefixDigit, modVcsIndex=modVcsIndex, modVcs=modVcs, modVcsE164NatlMaxAddressLength=modVcsE164NatlMaxAddressLength, modVcsE164TeleCountryCode=modVcsE164TeleCountryCode, modVcsE164IntlMinAddressLength=modVcsE164IntlMinAddressLength, modVcsE164LocalMaxAddressLength=modVcsE164LocalMaxAddressLength, modVcsMaxSubnetPacketSize=modVcsMaxSubnetPacketSize, modVcsWinsPktIndex=modVcsWinsPktIndex, subnetInterfaceCapabilities=subnetInterfaceCapabilities, modVcsStorageType=modVcsStorageType, modVcsAccOptTable=modVcsAccOptTable, modVcsDefaultNumberingPlan=modVcsDefaultNumberingPlan, modVcsE164IntlPrefixDigits=modVcsE164IntlPrefixDigits, modVcsWinsValue=modVcsWinsValue, modVcsCallRetryTimer=modVcsCallRetryTimer, modVcsUnitsCounted=modVcsUnitsCounted, modVcsAccountingFax=modVcsAccountingFax, modVcsComponentName=modVcsComponentName, subnetInterfaceCapabilitiesBE00A=subnetInterfaceCapabilitiesBE00A, modVcsSegmentSize=modVcsSegmentSize, modVcsX121Type=modVcsX121Type, modVcsGenerationMode=modVcsGenerationMode, modVcsE164IntlFormatAllowed=modVcsE164IntlFormatAllowed, modVcsX121ToE164EscapeSignificance=modVcsX121ToE164EscapeSignificance, modVcsIntOptEntry=modVcsIntOptEntry, modVcsE164LocalAddressLength=modVcsE164LocalAddressLength, modVcsNetworkIdCode=modVcsNetworkIdCode, modVcsE164NatlMinAddressLength=modVcsE164NatlMinAddressLength, subnetInterfaceGroupBE=subnetInterfaceGroupBE, modVcsX121MaxAddressLength=modVcsX121MaxAddressLength, modVcsWinsEntry=modVcsWinsEntry, subnetInterfaceCapabilitiesBE=subnetInterfaceCapabilitiesBE, modVcsNetworkIdType=modVcsNetworkIdType, modVcsE164LocalMinAddressLength=modVcsE164LocalMinAddressLength)

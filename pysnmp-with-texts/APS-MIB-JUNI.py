#
# PySNMP MIB module APS-MIB-JUNI (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/APS-MIB-JUNI
# Produced by pysmi-0.3.4 at Wed May  1 11:24:19 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion")
InterfaceIndex, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex")
juniSonetApsExperiment, = mibBuilder.importSymbols("Juniper-Experiment", "juniSonetApsExperiment")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
ModuleIdentity, TimeTicks, MibIdentifier, NotificationType, ObjectIdentity, Unsigned32, Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, Counter64, Counter32, iso, Integer32, Gauge32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "TimeTicks", "MibIdentifier", "NotificationType", "ObjectIdentity", "Unsigned32", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Counter64", "Counter32", "iso", "Integer32", "Gauge32", "IpAddress")
RowStatus, DisplayString, TimeStamp, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TimeStamp", "TextualConvention")
junidApsMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1))
junidApsMIB.setRevisions(('2001-05-24 23:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: junidApsMIB.setRevisionsDescriptions(('Initial version of this MIB, published as RFC xxxx.',))
if mibBuilder.loadTexts: junidApsMIB.setLastUpdated('200105242300Z')
if mibBuilder.loadTexts: junidApsMIB.setOrganization('IETF AToMMIB Working Group')
if mibBuilder.loadTexts: junidApsMIB.setContactInfo(' Jeff Johnson Postal: RedBack Networks. Inc. 350 Holger Way San Jose, CA 95134-1362 Tel: +1 408 571 5460 Email: jeff@redback.com Michael Thatcher Postal: RedBack Networks. Inc. 350 Holger Way San Jose, CA 95134-1362 Tel: +1 408 571 5449 Email: thatcher@redback.com Jim Kuhfeld Postal: RedBack Networks. Inc. 350 Holger Way San Jose, CA 95134-1362 Tel: +1 408 571 5465 Email: jkuhfeld@redback.com')
if mibBuilder.loadTexts: junidApsMIB.setDescription('This management information module supports the configuration and management of SONET linear APS groups. The definitions and descriptions used in this mib have been derived from Synchronous Optical Network (SONET) Transport Systems: Common Generic Criteria, GR-253-CORE Revision 2, January 1999, section 5.3. The MIB is also consistent with the Multiplex Section Protection (MSP) protocol as specified in ITU-T Recommendation G.783, Characteristics of synchronous digital hierarchy (SDH) equipment function blocks, Annex A and B. ')
junidApsMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1))
junidApsMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 2))
junidApsMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3))
class JunidApsK1K2(TextualConvention, OctetString):
    reference = 'Bellcore (Telcordia Technologies) GR-253-CORE, Issue 2, Revision 2 (January 1999), 5.3.5.'
    description = 'This Textual Convention describes an object that stores a SONET K1 and K2 byte APS protocol field. K1 is located in the first octet, K2 is located in the second octet. Bits are numbered from left to right. Bits 1-4 of the K1 byte indicate a request. 1111 Lockout of Protection 1110 Forced Switch 1101 SF - High Priority 1100 SF - Low Priority 1011 SD - High Priority 1010 SD - Low Priority 1001 not used 1000 Manual Switch 0111 not used 0110 Wait-to-Restore 0101 not used 0100 Exercise 0011 not used 0010 Reverse Request 0001 Do Not Revert 0000 No Request Bits 5-8 of the K1 byte indicate the channel associated with the request defined in bits 1-4. 0000 is the Null channel. 1-14 are working channels. 15 is the extra traffic channel Bits 1-4 of the K2 byte indicate a channel. The channel is defined with the same syntax as K1 Bits 5-8. Bit 5 of the K2 byte indicates the architecture. 0 if the architecture is 1+1 1 if the architecture is 1:n Bits 6-8 of the K2 byte indicates the mode. 000 - 011 are reserved for future use 100 indicates the mode is unidirectional 101 indicates the mode is bidirectional 110 RDI-L 111 AIS-L '
    status = 'current'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(2, 2)
    fixedLength = 2

class JunidApsSwitchCommand(TextualConvention, Integer32):
    description = 'An APS switch command allows a user to perform protection switch actions. The Switch command values are: noCmd This value should be returned by a read request when no switch command has been written to the object in question since initialization. This value may not be used in a write operation. clear Clears all of the switch commands listed below for the specified channel. lockoutOfProtection Prevents any of the working channels from switching to the protection line. The specified channel should be the protection channel. forcedSwitchWorkToProtect Switches the specified working channel to the protection line. forcedSwitchProtectToWork Switches the working channel back from the protection line to the working line. The specified channel should be the protection channel. manualSwitchWorkToProtect Switches the specified working channel to the protection line. manualSwitchProtectToWork Switches the working channel back from the protection line to the working line. The specified channel should be the protection channel. exercise Exercises the protocol for a protection switch of the specified channel by issuing an Exercise request for that channel and checking the response on the APS channel. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))
    namedValues = NamedValues(("noCmd", 1), ("clear", 2), ("lockoutOfProtection", 3), ("forcedSwitchWorkToProtect", 4), ("forcedSwitchProtectToWork", 5), ("manualSwitchWorkToProtect", 6), ("manualSwitchProtectToWork", 7), ("exercise", 8))

class JunidApsControlCommand(TextualConvention, Integer32):
    description = 'An APS control command applies only to LTE that support the 1:n architecture and performs the following actions. The Control command values are: noCmd This value should be returned by a read request when no control command has been written to the object in question since initialization. This value may not be used in a write operation. lockoutWorkingChannel Prevents the specified working channel from switching to the protection line. clearLockoutWorkingChannel Clears the lockout a working channel command for the channel specified. '
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("noCmd", 1), ("lockoutWorkingChannel", 2), ("clearLockoutWorkingChannel", 3))

junidApsConfig = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1))
junidApsConfigGroups = MibScalar((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsConfigGroups.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigGroups.setDescription('The count of APS groups. This count includes all rows in junidApsConfigTable.')
junidApsConfigTable = MibTable((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2), )
if mibBuilder.loadTexts: junidApsConfigTable.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigTable.setDescription('This table lists the APS groups that have been configured on the system.')
junidApsConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1), ).setIndexNames((1, "APS-MIB-JUNI", "junidApsConfigName"))
if mibBuilder.loadTexts: junidApsConfigEntry.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigEntry.setDescription('A conceptual row in the junidApsConfigTable.')
junidApsConfigName = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: junidApsConfigName.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigName.setDescription('A textual name for the APS group. ')
junidApsConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 2), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigRowStatus.setDescription('The status of this APS group entry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. Also, all associated junidApsChanConfigEntry rows must represent a set of consecutive channel numbers beginning with 0 or 1, depending on the selected architecture. When set to notInService changes may be made to junidApsConfigMode, junidApsConfigRevert, junidApsConfigDirection, junidApsConfigExtraTraffic, junidApsConfigSdBerThreshold, junidApsConfigSfBerThreshold, and junidApsConfigWaitToRestore. Also, associated junidApsChanConfigTable objects may be added, deleted and modified. ')
junidApsConfigMode = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("onePlusOne", 1), ("oneToN", 2), ("onePlusOneCompatible", 3), ("onePlusOneOptimized", 4))).clone('onePlusOne')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigMode.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigMode.setDescription('The architecture of the APS group. onePlusOne The 1+1 architecture permanently bridges the working line to the protection line. oneToN The 1:n architecture allows one protection channel to protect up to n working channels. When a fault is detected on one of the n working channels that channel is bridged over the protection channel. onePlusOneCompatible This refers to 1 + 1 bidirectional switching compatible with 1:n bidirectional switching as specified in ITU-T Recommendation G.783 (04/97) section A.3.4.1. Since this mode necessitates bidirectional switching, junidApsConfigDirection must be set to bidirectional whenever onePlusOneCompatible is set. onePlusOneOptimized This refers to 1 + 1 bidirectional switching optimized for a network using predominantly 1 + 1 bidirectional switching as specified in ITU-T Recommendation G.783 (04/97) section B.1. Since this mode necessitates bidirectional switching, junidApsConfigDirection must be set to bidirectional whenever onePlusOneOptimized is set. This object may not be modified if the associated junidApsConfigRowStatus object is equal to active(1).')
junidApsConfigRevert = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("nonrevertive", 1), ("revertive", 2))).clone('nonrevertive')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigRevert.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigRevert.setDescription('The revertive mode of the APS group. nonrevertive Traffic remains on the protection line until another switch request is received. revertive When the condition that caused a switch to the protection line has been cleared the signal is switched back to the working line. Since switching is revertive with the 1:n architecture, junidApsConfigRevert must be set to revertive if junidApsConfigMode is set to oneToN. Switching may optionally be revertive with the 1+1 architecture. This object may not be modified if the associated junidApsConfigRowStatus object is equal to active(1). ')
junidApsConfigDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("unidirectional", 1), ("bidirectional", 2))).clone('unidirectional')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigDirection.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigDirection.setDescription('The directional mode of the APS group. unidirectional The unidirectional mode provides protection in one direction. bidirectional The bidirectional mode provides protection in both directions. This object may not be modified if the associated junidApsConfigRowStatus object is equal to active(1). ')
junidApsConfigExtraTraffic = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigExtraTraffic.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigExtraTraffic.setDescription("This object enables or disables the transfer of extra traffic on the protection channel in a 1:n architecture. This object must be set to disabled if the architecture is 1+1. It may be necessary to disable this in order to interwork with other SONET network elements that don't support extra traffic. This object may not be modified if the associated junidApsConfigRowStatus object is equal to active(1). ")
junidApsConfigSdBerThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 9)).clone(5)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigSdBerThreshold.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigSdBerThreshold.setDescription('The Signal Degrade Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. This object may be modified if the associated junidApsConfigRowStatus object is equal to active(1).')
junidApsConfigSfBerThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 5)).clone(3)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigSfBerThreshold.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigSfBerThreshold.setDescription('The Signal Failure Bit Error Rate. The negated value of this number is used as the exponent of 10 for computing the threshold value for the Bit Error Rate (BER). For example, a value of 5 indicates a BER threshold of 10^-5. This object may be modified if the associated junidApsConfigRowStatus object is equal to active(1).')
junidApsConfigWaitToRestore = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 720)).clone(300)).setUnits('seconds').setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsConfigWaitToRestore.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigWaitToRestore.setDescription('The Wait To Restore period in seconds. After clearing of a condition that necessitated an automatic switch, the wait to restore period must elapse before reverting. This is intended to avoid rapid switch oscillations. GR-253-CORE specifies a Wait To Restore range of 5 to 12 minutes. G.783 defines a 5 to 12 minute Wait To Restore range in section 5.4.1.1.3, but also allows for a shorter WTR period in Table 2-1, WaitToRestore value (MI_WTRtime: 0..(5)..12 minutes). This object may not be modified if the associated junidApsConfigRowStatus object is equal to active(1).')
junidApsConfigCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 1, 2, 1, 10), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsConfigCreationTime.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigCreationTime.setDescription('The value of sysUpTime at the time the row was created')
junidApsStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2), )
if mibBuilder.loadTexts: junidApsStatusTable.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusTable.setDescription('This table provides status information about APS groups that have been configured on the system.')
junidApsStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1), ).setIndexNames((1, "APS-MIB-JUNI", "junidApsConfigName"))
if mibBuilder.loadTexts: junidApsStatusEntry.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusEntry.setDescription('A conceptual row in the junidApsStatusTable. Entries in this table are created as a side effect of row addition in junidApsConfigTable.')
junidApsStatusK1K2Rcv = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 1), JunidApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusK1K2Rcv.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusK1K2Rcv.setDescription('The current value of the K1 and K2 bytes received on the protection channel.')
junidApsStatusK1K2Trans = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 2), JunidApsK1K2()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusK1K2Trans.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusK1K2Trans.setDescription('The current value of the K1 and K2 bytes transmitted on the protection channel.')
junidApsStatusCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 3), Bits().clone(namedValues=NamedValues(("modeMismatch", 0), ("channelMismatch", 1), ("psbf", 2), ("feplf", 3), ("extraTraffic", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusCurrent.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusCurrent.setDescription('The current status of the APS group. modeMismatch Modes other than 1+1 unidirectional monitor protection line K2 bit 5, which indicates the architecture and K2 bits 6-8, which indicate if the mode is unidirectional or bidirectional. A conflict between the current local mode and the received K2 mode information constitutes a mode mismatch. channelMismatch This bit indicates a mismatch between the transmitted K1 channel and the received K2 channel has been detected. psbf This bit indicates a Protection Switch Byte Failure (PSBF) is in effect. This condition occurs when either an inconsistent APS byte or an invalid code is detected. An inconsistent APS byte occurs when no three consecutive K1 bytes of the last 12 successive frames are identical, starting with the last frame containing a previously consistent byte. An invalid code occurs when the incoming K1 byte contains an unused code or a code irrelevant for the specific switching operation (e.g., Reverse Request while no switching request is outstanding) in three consecutive frames. An invalid code also occurs when the incoming K1 byte contains an invalid channel number in three consecutive frames. feplf Modes other than 1+1 unidirectional monitor the K1 byte for Far-End Protection-Line failures. A Far-End Protection-Line defect is declared based on receiving SF on the protection line. extraTraffic This bit indicates whether extra traffic is currently being accepted on the protection line. ')
junidApsStatusModeMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusModeMismatches.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusModeMismatches.setDescription('A count of Mode Mismatch conditions.')
junidApsStatusChannelMismatches = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusChannelMismatches.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusChannelMismatches.setDescription('A count of Channel Mismatch conditions.')
junidApsStatusPSBFs = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusPSBFs.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusPSBFs.setDescription('A count of Protection Switch Byte Failure conditions. This condition occurs when either an inconsistent APS byte or an invalid code is detected. An inconsistent APS byte occurs when no three consecutive K1 bytes of the last 12 successive frames are identical, starting with the last frame containing a previously consistent byte. An invalid code occurs when the incoming K1 byte contains an unused code or a code irrelevant for the specific switching operation (e.g., Reverse Request while no switching request is outstanding) in three consecutive frames. An invalid code also occurs when the incoming K1 byte contains an invalid channel number in three consecutive frames.')
junidApsStatusFEPLFs = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusFEPLFs.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusFEPLFs.setDescription('A count of Far-End Protection-Line Failure conditions. This condition is declared based on receiving SF on the protection line in the K1 byte.')
junidApsStatusSwitchedChannel = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsStatusSwitchedChannel.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusSwitchedChannel.setDescription('This field is set to the number of the channel that is currently switched to protection. The value 0 indicates no channel is switched to protection. The values 1-14 indicate that working channel is switched to protection.')
junidApsMap = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 3))
junidApsChanLTEs = MibScalar((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 3, 1), Gauge32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsChanLTEs.setStatus('current')
if mibBuilder.loadTexts: junidApsChanLTEs.setDescription('The count of SONET LTE interfaces on the system. Each interface that is included has an ifType value of sonet(39).')
junidApsMapTable = MibTable((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 3, 2), )
if mibBuilder.loadTexts: junidApsMapTable.setStatus('current')
if mibBuilder.loadTexts: junidApsMapTable.setDescription('This table lists the SONET LTE interfaces on the system. Each interface that is listed has an ifType value of sonet(39).')
junidApsMapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 3, 2, 1), ).setIndexNames((0, "APS-MIB-JUNI", "junidApsMapIfIndex"))
if mibBuilder.loadTexts: junidApsMapEntry.setStatus('current')
if mibBuilder.loadTexts: junidApsMapEntry.setDescription('A conceptual row in the junidApsMapTable.')
junidApsMapIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 3, 2, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: junidApsMapIfIndex.setStatus('current')
if mibBuilder.loadTexts: junidApsMapIfIndex.setDescription('The Interface Index assigned to a SONET LTE. This is an interface with ifType sonet(39).')
junidApsMapGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 3, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsMapGroupName.setStatus('current')
if mibBuilder.loadTexts: junidApsMapGroupName.setDescription('A textual name for the APS group which this channel is included in. If the channel is not part of an APS group this value is set to a string of size 0. When an instance of junidApsChanConfigIfIndex is set equal to an instance of junidApsMapIfIndex, junidApsMapGroupName is set equal to the corresponding value of junidApsChanConfigGroupName. If the junidApsMapIfIndex ceases to be equal to an instance of junidApsChanConfigIfIndex, either because of a change in the value of junidApsChanConfigIfIndex, or because of row deletion in the junidApsChanConfigTable, junidApsMapGroupName is set to a string of size 0. ')
junidApsMapChanNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-1, 14))).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsMapChanNumber.setStatus('current')
if mibBuilder.loadTexts: junidApsMapChanNumber.setDescription('This field is set to a unique channel number within an APS group. The value 0 indicates the null channel. The values 1-14 define a working channel. If the SONET LTE is not part of an APS group this value is set to -1. When an instance of junidApsChanConfigIfIndex is set equal to an instance of junidApsMapIfIndex, junidApsMapChanNumber is set equal to the corresponding value of junidApsChanConfigNumber. If the junidApsMapIfIndex ceases to be equal to an instance of junidApsChanConfigIfIndex, either because of a change in the value of junidApsChanConfigIfIndex, or because of row deletion in the junidApsChanConfigTable, junidApsMapChanNumber is set to -1. ')
junidApsChanConfigTable = MibTable((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 4), )
if mibBuilder.loadTexts: junidApsChanConfigTable.setStatus('current')
if mibBuilder.loadTexts: junidApsChanConfigTable.setDescription('This table lists the APS channels that have been configured in APS groups.')
junidApsChanConfigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 4, 1), ).setIndexNames((0, "APS-MIB-JUNI", "junidApsChanConfigGroupName"), (0, "APS-MIB-JUNI", "junidApsChanConfigNumber"))
if mibBuilder.loadTexts: junidApsChanConfigEntry.setStatus('current')
if mibBuilder.loadTexts: junidApsChanConfigEntry.setDescription('A conceptual row in the junidApsChanConfigTable.')
junidApsChanConfigGroupName = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 4, 1, 1), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(1, 32)))
if mibBuilder.loadTexts: junidApsChanConfigGroupName.setStatus('current')
if mibBuilder.loadTexts: junidApsChanConfigGroupName.setDescription('A textual name for the APS group which this channel is included in.')
junidApsChanConfigNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 4, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 14)))
if mibBuilder.loadTexts: junidApsChanConfigNumber.setStatus('current')
if mibBuilder.loadTexts: junidApsChanConfigNumber.setDescription('This field is set to a unique channel number within an APS group. The value 0 indicates the null channel. The values 1-14 define a working channel. This field must be assigned a unique number within the group.')
junidApsChanConfigRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 4, 1, 3), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsChanConfigRowStatus.setStatus('current')
if mibBuilder.loadTexts: junidApsChanConfigRowStatus.setDescription('The status of this APS channel entry. An entry may not exist in the active state unless all objects in the entry have an appropriate value. A row in the junidApsChanConfigTable may not be created, deleted, set to notInService or otherwise modified if the junidApsChanConfigGroupName value is equal to an junidApsConfigName value and the associated junidApsConfigRowStatus object is equal to active. However, if the junidApsConfigRowStatus object is equal to notInService, a row may be created, deleted or modified. In other words, a channel may not be added, deleted or modified if the group is active. A row may be created with an junidApsChanConfigGroupName value that is not equal to any existing instance of junidApsConfigName. This action is the initial step in adding a SONET LTE to a new APS group. If this object is set to destroy, the associated instance of junidApsMapGroupName will be set to a string of size 0 and the junidApsMapChanNumber will be set to -1. The channel status entry will also be deleted by this action. junidApsChanConfigNumber must be set to a unique channel number within the APS group. The value 0 indicates the null channel. The values 1-14 define a working channel. When an attempt is made to set the corresponding junidApsConfigRowStatus field to active the junidApsChanConfigNumber values of all entries with equal junidApsChanConfigGroupName fields must represent a set of consecutive integer values beginning with 0 or 1, depending on the architecture of the group, and ending with n, where n is greater than or equal to 1 and less than or equal to 14. Otherwise, the error inconsistentValue is returned to the junidApsConfigRowStatus set attempt. ')
junidApsChanConfigIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 4, 1, 4), InterfaceIndex()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsChanConfigIfIndex.setStatus('current')
if mibBuilder.loadTexts: junidApsChanConfigIfIndex.setDescription('The Interface Index assigned to a SONET LTE. This is an interface with ifType sonet(39). The value of this object must be unique among all instances of junidApsChanConfigIfIndex. In other words, a particular SONET LTE can only be configured in one APS group. This object cannot be set if the junidApsChanConfigGroupName instance associated with this row is equal to an instance of junidApsConfigName and the corresponding junidApsConfigRowStatus object is set to active. In other words this value cannot be changed if the APS group is active. However, This value may be changed if the junidApsConfigRowStatus value is equal to notInService. ')
junidApsChanConfigPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("low", 1), ("high", 2))).clone('low')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: junidApsChanConfigPriority.setStatus('current')
if mibBuilder.loadTexts: junidApsChanConfigPriority.setDescription('The priority of the channel. This field deterimines whether high or low priority SD and SF codes are used in K1 requests. This field is only applicable if the channel is to be included in a group using the 1:n architecture. It is not applicable if the channel is to be included in a group using the 1+1 architecture, and is ignored in that case. This object cannot be set if the junidApsChanConfigGroupName instance associated with this row is equal to an instance of junidApsConfigName and the corresponding junidApsConfigRowStatus object is set to active. In other words this value cannot be changed if the APS group is active. However, This value may be changed if the junidApsConfigRowStatus value is equal to notInService. ')
junidApsCommandTable = MibTable((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 5), )
if mibBuilder.loadTexts: junidApsCommandTable.setStatus('current')
if mibBuilder.loadTexts: junidApsCommandTable.setDescription('This table allows commands to be sent to configured APS groups.')
junidApsCommandEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 5, 1), ).setIndexNames((0, "APS-MIB-JUNI", "junidApsChanConfigGroupName"), (0, "APS-MIB-JUNI", "junidApsChanConfigNumber"))
if mibBuilder.loadTexts: junidApsCommandEntry.setStatus('current')
if mibBuilder.loadTexts: junidApsCommandEntry.setDescription('A conceptual row in the junidApsCommandTable. This row exists only if the associated junidApsConfigEntry is active.')
junidApsCommandSwitch = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 5, 1, 1), JunidApsSwitchCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: junidApsCommandSwitch.setStatus('current')
if mibBuilder.loadTexts: junidApsCommandSwitch.setDescription('Allows the initiation of an APS switch command on the APS group and channel specified by the index values. If the APS switch command cannot be executed because an equal or higer priority request is in effect, an error is returned. When read this object returns the last command written or noCmd if no command has been written to this channel since initialization. The return of the last command written does not imply that this command is currently in effect. This request may have been preempted by a higher priority local or remote request. In order to determine the current state of the APS group it is necessary to read the objects junidApsStatusK1K2Rcv and junidApsStatusK1K2Trans. The value lockoutOfProtection should only be applied to the protection line channel since that switch command prevents any of the working channels from switching to the protection line. Following the same logic, forcedSwitchProtectToWork and manualSwitchProtectToWork should only be applied to the protection line channel. forcedSwitchWorkToProtect and manualSwitchWorkToProtect should only be applied to a working channel. ')
junidApsCommandControl = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 5, 1, 2), JunidApsControlCommand()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: junidApsCommandControl.setStatus('current')
if mibBuilder.loadTexts: junidApsCommandControl.setDescription('Allows the initiation of an APS control command on the APS group and channel specified by the index values. When read this object returns the last command written or noCmd if no command has been written to this channel since initialization. This object does not apply to the protection line. ')
junidApsChanStatusTable = MibTable((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6), )
if mibBuilder.loadTexts: junidApsChanStatusTable.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusTable.setDescription('This table contains status information for all SONET LTE interfaces that are included in APS groups.')
junidApsChanStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6, 1), ).setIndexNames((0, "APS-MIB-JUNI", "junidApsChanConfigGroupName"), (0, "APS-MIB-JUNI", "junidApsChanConfigNumber"))
if mibBuilder.loadTexts: junidApsChanStatusEntry.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusEntry.setDescription('A conceptual row in the junidApsChanStatusTable. A row in this table is created as a side effect of row addition in the junidApsChanConfigTable. The junidApsChanStatusTable row exists as long as the junidApsChanConfigTable entry exists, regardless of whether the associated junidApsChanConfigRowStatus is active. ')
junidApsChanStatusCurrent = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6, 1, 1), Bits().clone(namedValues=NamedValues(("lockedOut", 0), ("sd", 1), ("sf", 2), ("switched", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsChanStatusCurrent.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusCurrent.setDescription('Indicates the current state of the port. lockedOut This bit, when applied to a working channel, indicates that the channel is prevented from switching to the protection line. When applied to the null channel, this bit indicates that no working channel may switch to the protection line. sd A signal degrade condition is in effect. sf A signal failure condition is in effect. switched The switched bit is applied to a working channel if that channel is currently switched to the protection line. ')
junidApsChanStatusSignalDegrades = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsChanStatusSignalDegrades.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusSignalDegrades.setDescription('A count of Signal Degrade conditions. This condition occurs when the line Bit Error Rate exceeds the currently configured threshold.')
junidApsChanStatusSignalFailures = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsChanStatusSignalFailures.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusSignalFailures.setDescription('A count of Signal Failure conditions that have been detected on the incoming signal. This condition occurs when a loss of signal, loss of frame, AIS-L or a Line bit error rate exceeding 10^-3 is detected on an incoming line.')
junidApsChanStatusSwitchovers = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsChanStatusSwitchovers.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusSwitchovers.setDescription('The number of times this channel has switched to the protection line. When queried with index value junidApsChanConfigNumber set to 0, which is the protection line, this object will return 0.')
junidApsChanStatusLastSwitchover = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6, 1, 5), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsChanStatusLastSwitchover.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusLastSwitchover.setDescription('The value of sysUpTime when this channel last completed a switch to the protection line. If this channel has never switched to the protection line, or this channel is the protection line, the value 0 will be returned.')
junidApsChanStatusSwitchoverSeconds = MibTableColumn((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 1, 6, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: junidApsChanStatusSwitchoverSeconds.setStatus('current')
if mibBuilder.loadTexts: junidApsChanStatusSwitchoverSeconds.setDescription('The cumulative Protection Switching Duration (PSD) time in seconds. For a working channel, this is the cumulative number of seconds that service was carried on the protection line. For the protection line, this is the cumulative number of seconds that the protection line has been used to carry any working channel traffic. This information is only valid if revertive switching is enabled. The value 0 will be returned otherwise.')
junidApsNotificationsPrefix = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 2, 0))
junidApsEventSwitchover = NotificationType((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 2, 0, 1)).setObjects(("APS-MIB-JUNI", "junidApsChanStatusSwitchovers"), ("APS-MIB-JUNI", "junidApsChanStatusCurrent"))
if mibBuilder.loadTexts: junidApsEventSwitchover.setStatus('current')
if mibBuilder.loadTexts: junidApsEventSwitchover.setDescription('An junidApsEventSwitchover notification is sent when the value of an instance of junidApsChanStatusSwitchovers increments.')
junidApsEventModeMismatch = NotificationType((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 2, 0, 2)).setObjects(("APS-MIB-JUNI", "junidApsStatusModeMismatches"), ("APS-MIB-JUNI", "junidApsStatusCurrent"))
if mibBuilder.loadTexts: junidApsEventModeMismatch.setStatus('current')
if mibBuilder.loadTexts: junidApsEventModeMismatch.setDescription('An junidApsEventModeMismatch notification is sent when the value of an instance of junidApsStatusModeMismatches increments.')
junidApsEventChannelMismatch = NotificationType((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 2, 0, 3)).setObjects(("APS-MIB-JUNI", "junidApsStatusChannelMismatches"), ("APS-MIB-JUNI", "junidApsStatusCurrent"))
if mibBuilder.loadTexts: junidApsEventChannelMismatch.setStatus('current')
if mibBuilder.loadTexts: junidApsEventChannelMismatch.setDescription('An junidApsEventChannelMismatch notification is sent when the value of an instance of junidApsStatusChannelMismatches increments.')
junidApsEventPSBF = NotificationType((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 2, 0, 4)).setObjects(("APS-MIB-JUNI", "junidApsStatusPSBFs"), ("APS-MIB-JUNI", "junidApsStatusCurrent"))
if mibBuilder.loadTexts: junidApsEventPSBF.setStatus('current')
if mibBuilder.loadTexts: junidApsEventPSBF.setDescription('An junidApsEventPSBF notification is sent when the value of an instance of junidApsStatusPSBFs increments.')
junidApsEventFEPLF = NotificationType((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 2, 0, 5)).setObjects(("APS-MIB-JUNI", "junidApsStatusFEPLFs"), ("APS-MIB-JUNI", "junidApsStatusCurrent"))
if mibBuilder.loadTexts: junidApsEventFEPLF.setStatus('current')
if mibBuilder.loadTexts: junidApsEventFEPLF.setDescription('An junidApsEventFEPLFs notification is sent when the value of an instance of junidApsStatusFEPLFs increments.')
junidApsGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1))
junidApsCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 2))
junidApsCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 2, 1)).setObjects(("APS-MIB-JUNI", "junidApsConfigGeneral"), ("APS-MIB-JUNI", "junidApsStatusGeneral"), ("APS-MIB-JUNI", "junidApsChanGeneral"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsCompliance = junidApsCompliance.setStatus('current')
if mibBuilder.loadTexts: junidApsCompliance.setDescription('The compliance statement for linear APS groups.')
junidApsConfigGeneral = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 1)).setObjects(("APS-MIB-JUNI", "junidApsConfigMode"), ("APS-MIB-JUNI", "junidApsConfigRevert"), ("APS-MIB-JUNI", "junidApsConfigDirection"), ("APS-MIB-JUNI", "junidApsConfigExtraTraffic"), ("APS-MIB-JUNI", "junidApsConfigSdBerThreshold"), ("APS-MIB-JUNI", "junidApsConfigSfBerThreshold"), ("APS-MIB-JUNI", "junidApsConfigCreationTime"), ("APS-MIB-JUNI", "junidApsConfigRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsConfigGeneral = junidApsConfigGeneral.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigGeneral.setDescription('A collection of junidApsConfigTable objects providing configuration information applicable to all linear APS groups.')
junidApsConfigWtr = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 2)).setObjects(("APS-MIB-JUNI", "junidApsConfigWaitToRestore"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsConfigWtr = junidApsConfigWtr.setStatus('current')
if mibBuilder.loadTexts: junidApsConfigWtr.setDescription('The junidApsConfigTable object that provides information which is applicable to groups supporting a configurable WTR period.')
junidApsCommandOnePlusOne = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 3)).setObjects(("APS-MIB-JUNI", "junidApsCommandSwitch"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsCommandOnePlusOne = junidApsCommandOnePlusOne.setStatus('current')
if mibBuilder.loadTexts: junidApsCommandOnePlusOne.setDescription('The junidApsCommandTable object which is applicable to groups implementing the linear APS 1+1 architecture. Also, set operations must be supported.')
junidApsCommandOneToN = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 4)).setObjects(("APS-MIB-JUNI", "junidApsCommandSwitch"), ("APS-MIB-JUNI", "junidApsCommandControl"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsCommandOneToN = junidApsCommandOneToN.setStatus('current')
if mibBuilder.loadTexts: junidApsCommandOneToN.setDescription('A collection of junidApsCommandTable objects which are applicable to groups implementing the linear APS 1:n architecture. Also, set operations must be supported.')
junidApsStatusGeneral = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 5)).setObjects(("APS-MIB-JUNI", "junidApsStatusK1K2Rcv"), ("APS-MIB-JUNI", "junidApsStatusK1K2Trans"), ("APS-MIB-JUNI", "junidApsStatusCurrent"), ("APS-MIB-JUNI", "junidApsStatusModeMismatches"), ("APS-MIB-JUNI", "junidApsStatusChannelMismatches"), ("APS-MIB-JUNI", "junidApsStatusPSBFs"), ("APS-MIB-JUNI", "junidApsStatusFEPLFs"), ("APS-MIB-JUNI", "junidApsStatusSwitchedChannel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsStatusGeneral = junidApsStatusGeneral.setStatus('current')
if mibBuilder.loadTexts: junidApsStatusGeneral.setDescription('A collection of junidApsStatusTable objects providing status information applicable to all linear APS groups.')
junidApsChanGeneral = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 6)).setObjects(("APS-MIB-JUNI", "junidApsChanConfigIfIndex"), ("APS-MIB-JUNI", "junidApsChanConfigRowStatus"), ("APS-MIB-JUNI", "junidApsChanStatusCurrent"), ("APS-MIB-JUNI", "junidApsChanStatusSignalDegrades"), ("APS-MIB-JUNI", "junidApsChanStatusSignalFailures"), ("APS-MIB-JUNI", "junidApsChanStatusSwitchovers"), ("APS-MIB-JUNI", "junidApsChanStatusLastSwitchover"), ("APS-MIB-JUNI", "junidApsChanStatusSwitchoverSeconds"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsChanGeneral = junidApsChanGeneral.setStatus('current')
if mibBuilder.loadTexts: junidApsChanGeneral.setDescription('A collection of channel objects providing information applicable to all linear APS channels.')
junidApsChanOneToN = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 7)).setObjects(("APS-MIB-JUNI", "junidApsChanConfigPriority"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsChanOneToN = junidApsChanOneToN.setStatus('current')
if mibBuilder.loadTexts: junidApsChanOneToN.setDescription('The junidApsChanConfigTable object that provides information which is only applicable to groups implementing the linear APS 1:n architecture.')
junidApsTotalsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 8)).setObjects(("APS-MIB-JUNI", "junidApsConfigGroups"), ("APS-MIB-JUNI", "junidApsChanLTEs"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsTotalsGroup = junidApsTotalsGroup.setStatus('current')
if mibBuilder.loadTexts: junidApsTotalsGroup.setDescription('A collection of objects providing optional counts of configured APS groups and SONET LTE interfaces.')
junidApsMapGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 9)).setObjects(("APS-MIB-JUNI", "junidApsMapGroupName"), ("APS-MIB-JUNI", "junidApsMapChanNumber"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsMapGroup = junidApsMapGroup.setStatus('current')
if mibBuilder.loadTexts: junidApsMapGroup.setDescription('A collection of junidApsMapTable objects providing a mapping from sonet(39) InterfaceIndex to group name and channel number for assigned APS channels and a list of unassigned sonet(39) interfaces.')
junidApsEventOptional = NotificationGroup((1, 3, 6, 1, 4, 1, 4874, 3, 2, 2, 1, 3, 1, 10)).setObjects(("APS-MIB-JUNI", "junidApsEventSwitchover"), ("APS-MIB-JUNI", "junidApsEventModeMismatch"), ("APS-MIB-JUNI", "junidApsEventChannelMismatch"), ("APS-MIB-JUNI", "junidApsEventPSBF"), ("APS-MIB-JUNI", "junidApsEventFEPLF"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    junidApsEventOptional = junidApsEventOptional.setStatus('current')
if mibBuilder.loadTexts: junidApsEventOptional.setDescription('A collection of SONET linear APS notifications that may optionally be implemented.')
mibBuilder.exportSymbols("APS-MIB-JUNI", junidApsChanStatusCurrent=junidApsChanStatusCurrent, junidApsStatusTable=junidApsStatusTable, junidApsStatusFEPLFs=junidApsStatusFEPLFs, junidApsConfigSdBerThreshold=junidApsConfigSdBerThreshold, junidApsStatusModeMismatches=junidApsStatusModeMismatches, junidApsChanStatusEntry=junidApsChanStatusEntry, junidApsMIBNotifications=junidApsMIBNotifications, junidApsChanStatusSignalDegrades=junidApsChanStatusSignalDegrades, junidApsGroups=junidApsGroups, junidApsCommandTable=junidApsCommandTable, junidApsConfigWtr=junidApsConfigWtr, junidApsStatusEntry=junidApsStatusEntry, junidApsStatusK1K2Rcv=junidApsStatusK1K2Rcv, junidApsConfigEntry=junidApsConfigEntry, junidApsConfigTable=junidApsConfigTable, junidApsCommandSwitch=junidApsCommandSwitch, junidApsEventChannelMismatch=junidApsEventChannelMismatch, junidApsConfigGeneral=junidApsConfigGeneral, junidApsEventFEPLF=junidApsEventFEPLF, junidApsChanStatusLastSwitchover=junidApsChanStatusLastSwitchover, junidApsStatusCurrent=junidApsStatusCurrent, junidApsMapChanNumber=junidApsMapChanNumber, junidApsMIBObjects=junidApsMIBObjects, junidApsChanConfigIfIndex=junidApsChanConfigIfIndex, junidApsCommandOnePlusOne=junidApsCommandOnePlusOne, junidApsConfigName=junidApsConfigName, junidApsEventSwitchover=junidApsEventSwitchover, junidApsConfig=junidApsConfig, junidApsStatusSwitchedChannel=junidApsStatusSwitchedChannel, junidApsMIB=junidApsMIB, junidApsCommandEntry=junidApsCommandEntry, JunidApsK1K2=JunidApsK1K2, junidApsChanStatusSwitchoverSeconds=junidApsChanStatusSwitchoverSeconds, junidApsChanGeneral=junidApsChanGeneral, junidApsMIBConformance=junidApsMIBConformance, junidApsConfigCreationTime=junidApsConfigCreationTime, junidApsChanConfigNumber=junidApsChanConfigNumber, junidApsMapGroupName=junidApsMapGroupName, junidApsTotalsGroup=junidApsTotalsGroup, junidApsChanConfigPriority=junidApsChanConfigPriority, junidApsConfigRowStatus=junidApsConfigRowStatus, junidApsMapTable=junidApsMapTable, junidApsChanStatusSignalFailures=junidApsChanStatusSignalFailures, JunidApsControlCommand=JunidApsControlCommand, junidApsConfigGroups=junidApsConfigGroups, junidApsChanConfigGroupName=junidApsChanConfigGroupName, junidApsStatusK1K2Trans=junidApsStatusK1K2Trans, junidApsMap=junidApsMap, junidApsMapIfIndex=junidApsMapIfIndex, junidApsChanConfigTable=junidApsChanConfigTable, junidApsMapGroup=junidApsMapGroup, junidApsConfigSfBerThreshold=junidApsConfigSfBerThreshold, junidApsChanStatusSwitchovers=junidApsChanStatusSwitchovers, PYSNMP_MODULE_ID=junidApsMIB, junidApsConfigWaitToRestore=junidApsConfigWaitToRestore, junidApsChanConfigEntry=junidApsChanConfigEntry, junidApsMapEntry=junidApsMapEntry, junidApsEventPSBF=junidApsEventPSBF, junidApsCommandOneToN=junidApsCommandOneToN, junidApsChanOneToN=junidApsChanOneToN, JunidApsSwitchCommand=JunidApsSwitchCommand, junidApsEventOptional=junidApsEventOptional, junidApsConfigDirection=junidApsConfigDirection, junidApsChanStatusTable=junidApsChanStatusTable, junidApsStatusGeneral=junidApsStatusGeneral, junidApsCommandControl=junidApsCommandControl, junidApsConfigExtraTraffic=junidApsConfigExtraTraffic, junidApsConfigMode=junidApsConfigMode, junidApsConfigRevert=junidApsConfigRevert, junidApsNotificationsPrefix=junidApsNotificationsPrefix, junidApsStatusChannelMismatches=junidApsStatusChannelMismatches, junidApsChanConfigRowStatus=junidApsChanConfigRowStatus, junidApsChanLTEs=junidApsChanLTEs, junidApsStatusPSBFs=junidApsStatusPSBFs, junidApsCompliance=junidApsCompliance, junidApsCompliances=junidApsCompliances, junidApsEventModeMismatch=junidApsEventModeMismatch)

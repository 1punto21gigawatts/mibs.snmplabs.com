#
# PySNMP MIB module IFCP-MGMT-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/IFCP-MGMT-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:53:12 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ConstraintsUnion, SingleValueConstraint, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ConstraintsUnion", "SingleValueConstraint", "ValueRangeConstraint", "ValueSizeConstraint")
PhysicalIndexOrZero, = mibBuilder.importSymbols("ENTITY-MIB", "PhysicalIndexOrZero")
FcAddressIdOrZero, FcNameIdOrZero = mibBuilder.importSymbols("FC-MGMT-MIB", "FcAddressIdOrZero", "FcNameIdOrZero")
ZeroBasedCounter64, = mibBuilder.importSymbols("HCNUM-TC", "ZeroBasedCounter64")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetPortNumber, InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddressType", "InetAddress")
ZeroBasedCounter32, = mibBuilder.importSymbols("RMON2-MIB", "ZeroBasedCounter32")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Bits, NotificationType, Counter64, Gauge32, IpAddress, MibIdentifier, Counter32, ObjectIdentity, Integer32, ModuleIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, Unsigned32, iso, transmission, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "NotificationType", "Counter64", "Gauge32", "IpAddress", "MibIdentifier", "Counter32", "ObjectIdentity", "Integer32", "ModuleIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Unsigned32", "iso", "transmission", "TimeTicks")
TimeStamp, DisplayString, StorageType, TruthValue, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TimeStamp", "DisplayString", "StorageType", "TruthValue", "TextualConvention")
ifcpMgmtMIB = ModuleIdentity((1, 3, 6, 1, 2, 1, 10, 230))
ifcpMgmtMIB.setRevisions(('2011-03-09 00:00', '2006-01-17 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: ifcpMgmtMIB.setRevisionsDescriptions(('Second version of iFCP Management Module. The iFCP address translation mode is deprecated. This MIB module published as RFC 6173.', 'Initial version of iFCP Management Module. This MIB module published as RFC 4369.',))
if mibBuilder.loadTexts: ifcpMgmtMIB.setLastUpdated('201103090000Z')
if mibBuilder.loadTexts: ifcpMgmtMIB.setOrganization('IETF STORage Maintenance (STORM) Working Group')
if mibBuilder.loadTexts: ifcpMgmtMIB.setContactInfo(' Working Group Email : storm@ietf.org Attn: Prakash Venkatesen HCL Technologies Email: prakashvn@hcl.com')
if mibBuilder.loadTexts: ifcpMgmtMIB.setDescription("This module defines management information specific to Internet Fibre Channel Protocol (iFCP) gateway management. Copyright (c) 2011 IETF Trust and the persons identified as authors of the code. All rights reserved. Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).")
class IfcpIpTOVorZero(TextualConvention, Unsigned32):
    reference = 'RFC 4172, iFCP Protocol Specification'
    description = 'The maximum propagation delay, in seconds, for an encapsulated FC frame to traverse the IP network. A value of 0 implies fibre channel frame lifetime limits will not be enforced.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 3600)

class IfcpLTIorZero(TextualConvention, Unsigned32):
    reference = 'RFC 4172, iFCP Protocol Specification'
    description = 'The value for the Liveness Test Interval (LTI) being used in an iFCP connection, in seconds. A value of 0 implies no Liveness Test Interval will be used.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 65535)

class IfcpSessionStates(TextualConvention, Integer32):
    description = 'The value for an iFCP session state.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3))
    namedValues = NamedValues(("down", 1), ("openPending", 2), ("open", 3))

class IfcpAddressMode(TextualConvention, Integer32):
    reference = 'RFC 6172, Deprecation of iFCP Address Translation Mode'
    description = 'The values for iFCP Address Translation Mode.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("addressTransparent", 1), ("addressTranslation", 2))

ifcpGatewayObjects = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 230, 1))
ifcpGatewayConformance = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 230, 2))
ifcpLclGatewayInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 230, 1, 1))
ifcpLclGtwyInstTable = MibTable((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1), )
if mibBuilder.loadTexts: ifcpLclGtwyInstTable.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstTable.setDescription('Information about all local iFCP gateway instances that can be monitored and controlled. This table contains an entry for each local iFCP gateway instance that is being managed.')
ifcpLclGtwyInstEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1), ).setIndexNames((0, "IFCP-MGMT-MIB", "ifcpLclGtwyInstIndex"))
if mibBuilder.loadTexts: ifcpLclGtwyInstEntry.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstEntry.setDescription('An entry in the local iFCP gateway instance table. Parameters and settings for the gateway are found here.')
ifcpLclGtwyInstIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: ifcpLclGtwyInstIndex.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstIndex.setDescription('An arbitrary integer value to uniquely identify this iFCP gateway from other local gateway instances.')
ifcpLclGtwyInstPhyIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 2), PhysicalIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpLclGtwyInstPhyIndex.setReference('Entity MIB (Version 3)')
if mibBuilder.loadTexts: ifcpLclGtwyInstPhyIndex.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstPhyIndex.setDescription('An index indicating the location of this local gateway within a larger entity, if one exists. If supported, this is the entPhysicalIndex from the Entity MIB (Version 3), for this iFCP gateway. If not supported, or if not related to a physical entity, then the value of this object is 0.')
ifcpLclGtwyInstVersionMin = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpLclGtwyInstVersionMin.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpLclGtwyInstVersionMin.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstVersionMin.setDescription('The minimum iFCP protocol version supported by the local iFCP gateway instance.')
ifcpLclGtwyInstVersionMax = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpLclGtwyInstVersionMax.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpLclGtwyInstVersionMax.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstVersionMax.setDescription('The maximum iFCP protocol version supported by the local iFCP gateway instance.')
ifcpLclGtwyInstAddrTransMode = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 5), IfcpAddressMode().clone('addressTransparent')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifcpLclGtwyInstAddrTransMode.setReference('RFC 4172, iFCP Protocol Specification; RFC 6172, Deprecation of iFCP Address Translation Mode')
if mibBuilder.loadTexts: ifcpLclGtwyInstAddrTransMode.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstAddrTransMode.setDescription('The local iFCP gateway operating mode. Changing this value may cause existing sessions to be disrupted.')
ifcpLclGtwyInstFcBrdcstSupport = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifcpLclGtwyInstFcBrdcstSupport.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpLclGtwyInstFcBrdcstSupport.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstFcBrdcstSupport.setDescription('This value indicates whether the local iFCP gateway supports FC Broadcast. Changing this value may cause existing sessions to be disrupted.')
ifcpLclGtwyInstDefaultIpTOV = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 7), IfcpIpTOVorZero().clone(6)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifcpLclGtwyInstDefaultIpTOV.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpLclGtwyInstDefaultIpTOV.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstDefaultIpTOV.setDescription('The default IP_TOV used for iFCP sessions at this gateway. This is the default maximum propagation delay that will be used for an iFCP session. The value can be changed on a per-session basis. The valid range is 0 - 3600 seconds. A value of 0 implies that fibre channel frame lifetime limits will not be enforced.')
ifcpLclGtwyInstDefaultLTInterval = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 8), IfcpLTIorZero().clone(10)).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifcpLclGtwyInstDefaultLTInterval.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpLclGtwyInstDefaultLTInterval.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstDefaultLTInterval.setDescription('The default Liveness Test Interval (LTI), in seconds, used for iFCP sessions at this gateway. This is the default value for an iFCP session and can be changed on a per-session basis. The valid range is 0 - 65535 seconds. A value of 0 implies no Liveness Test Interval will be performed on a session.')
ifcpLclGtwyInstDescr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 9), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 64))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifcpLclGtwyInstDescr.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstDescr.setDescription('A user-entered description for this iFCP gateway.')
ifcpLclGtwyInstNumActiveSessions = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 10), Gauge32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpLclGtwyInstNumActiveSessions.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstNumActiveSessions.setDescription('The current total number of iFCP sessions in the open or open-pending state.')
ifcpLclGtwyInstStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 1, 1, 1, 11), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpLclGtwyInstStorageType.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGtwyInstStorageType.setDescription('The storage type for this row. Parameter values defined for a gateway are usually non-volatile, but may be volatile or permanent in some configurations. If permanent, then the following parameters must have read-write access: ifcpLclGtwyInstAddrTransMode, ifcpLclGtwyInstDefaultIpTOV, and ifcpLclGtwyInstDefaultLTInterval.')
ifcpNportSessionInfo = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 230, 1, 2))
ifcpSessionAttributesTable = MibTable((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1), )
if mibBuilder.loadTexts: ifcpSessionAttributesTable.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionAttributesTable.setDescription('An iFCP session consists of the pair of N_PORTs comprising the session endpoints joined by a single TCP/IP connection. This table provides information on each iFCP session currently using a local iFCP gateway instance. iFCP sessions are created and removed by the iFCP gateway instances, which are reflected in this table.')
ifcpSessionAttributesEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1), ).setIndexNames((0, "IFCP-MGMT-MIB", "ifcpLclGtwyInstIndex"), (0, "IFCP-MGMT-MIB", "ifcpSessionIndex"))
if mibBuilder.loadTexts: ifcpSessionAttributesEntry.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionAttributesEntry.setDescription("Each entry contains information about one iFCP session consisting of a pair of N_PORTs joined by a single TCP/IP connection. This table's INDEX includes ifcpLclGtwyInstIndex, which identifies the local iFCP gateway instance that created the session for the entry. Soon after an entry is created in this table for an iFCP session, it will correspond to an entry in the tcpConnectionTable of the TCP-MIB (RFC 4022). The corresponding entry might represent a preexisting TCP connection, or it might be a newly created entry. (Note that if IPv4 is being used, an entry in RFC 2012's tcpConnTable may also correspond.) The values of ifcpSessionLclPrtlAddrType and ifcpSessionRmtPrtlIfAddrType in this table and the values of tcpConnectionLocalAddressType and tcpConnectionRemAddressType used as INDEX values for the corresponding entry in the tcpConnectionTable should be the same; this makes it simpler to locate a session's TCP connection in the TCP-MIB. (Of course, all four values need to be 'ipv4' if there's a corresponding entry in the tcpConnTable.) If an entry is created in this table for a session, prior to knowing which local and/or remote port numbers will be used for the TCP connection, then ifcpSessionLclPrtlTcpPort and/or ifcpSessionRmtPrtlTcpPort have the value zero until such time as they can be updated to the port numbers (to be) used for the connection. (Thus, a port value of zero should not be used to locate a session's TCP connection in the TCP-MIB.) When the TCP connection terminates, the entry in the tcpConnectionTable and the entry in this table both get deleted (and, if applicable, so does the entry in the tcpConnTable).")
ifcpSessionIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647)))
if mibBuilder.loadTexts: ifcpSessionIndex.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionIndex.setDescription('The iFCP session index is a unique value used as an index to the table, along with a specific local iFCP gateway instance. This index is used because the local N Port and remote N Port information would create a complex index that would be difficult to implement.')
ifcpSessionLclPrtlIfIndex = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 2), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLclPrtlIfIndex.setReference('RFC 2863, The Interfaces Group MIB (IF-MIB)')
if mibBuilder.loadTexts: ifcpSessionLclPrtlIfIndex.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLclPrtlIfIndex.setDescription('This is the interface index in the IF-MIB ifTable being used as the local portal in this session, as described in the IF-MIB. If the local portal is not associated with an entry in the ifTable, then the value is 0. The ifType of the interface will generally be a type that supports IP, but an implementation may support iFCP using other protocols. This object can be used to obtain additional information about the interface.')
ifcpSessionLclPrtlAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 3), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLclPrtlAddrType.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLclPrtlAddrType.setDescription('The type of address in ifcpSessionLclIfAddr.')
ifcpSessionLclPrtlAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 4), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLclPrtlAddr.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLclPrtlAddr.setDescription('This is the external IP address of the interface being used for the iFCP local portal in this session. The address type is defined in ifcpSessionLclPrtlAddrType. If the value is a DNS name, then the name is resolved once, during the initial session instantiation.')
ifcpSessionLclPrtlTcpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 5), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLclPrtlTcpPort.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLclPrtlTcpPort.setDescription('This is the TCP port number that is being used for the iFCP local portal in this session. This is normally an ephemeral port number selected by the gateway. The value may be 0 during an initial setup period.')
ifcpSessionLclNpWwun = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 6), FcNameIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLclNpWwun.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionLclNpWwun.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLclNpWwun.setDescription('World Wide Unique Name of the local N Port. For an unbound session, this variable will be a zero-length string.')
ifcpSessionLclNpFcid = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 7), FcAddressIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLclNpFcid.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionLclNpFcid.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLclNpFcid.setDescription('Fibre Channel Identifier of the local N Port. For an unbound session, this variable will be a zero-length string.')
ifcpSessionRmtNpWwun = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 8), FcNameIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRmtNpWwun.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionRmtNpWwun.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRmtNpWwun.setDescription('World Wide Unique Name of the remote N Port. For an unbound session, this variable will be a zero-length string.')
ifcpSessionRmtPrtlIfAddrType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 9), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRmtPrtlIfAddrType.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRmtPrtlIfAddrType.setDescription('The type of address in ifcpSessionRmtPrtlIfAddr.')
ifcpSessionRmtPrtlIfAddr = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 10), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRmtPrtlIfAddr.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRmtPrtlIfAddr.setDescription('This is the remote gateway IP address being used for the portal on the remote iFCP gateway. The address type is defined in ifcpSessionRmtPrtlIfAddrType. If the value is a DNS name, then the name is resolved once, during the initial session instantiation.')
ifcpSessionRmtPrtlTcpPort = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 11), InetPortNumber().clone(3420)).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRmtPrtlTcpPort.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRmtPrtlTcpPort.setDescription('This is the TCP port number being used for the portal on the remote iFCP gateway. Generally, this will be the iFCP canonical port. The value may be 0 during an initial setup period.')
ifcpSessionRmtNpFcid = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 12), FcAddressIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRmtNpFcid.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionRmtNpFcid.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRmtNpFcid.setDescription('Fibre Channel Identifier of the remote N Port. For an unbound session, this variable will be a zero-length string.')
ifcpSessionRmtNpFcidAlias = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 13), FcAddressIdOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRmtNpFcidAlias.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionRmtNpFcidAlias.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRmtNpFcidAlias.setDescription('Fibre Channel Identifier Alias assigned by the local gateway for the remote N Port. For an unbound session, this variable will be a zero-length string.')
ifcpSessionIpTOV = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 14), IfcpIpTOVorZero()).setUnits('seconds').setMaxAccess("readwrite")
if mibBuilder.loadTexts: ifcpSessionIpTOV.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionIpTOV.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionIpTOV.setDescription('The IP_TOV being used for this iFCP session. This is the maximum propagation delay that will be used for the iFCP session. The value can be changed on a per-session basis and initially defaults to ifcpLclGtwyInstDefaultIpTOV for the local gateway instance. The valid range is 0 - 3600 seconds. A value of 0 implies fibre channel frame lifetime limits will not be enforced.')
ifcpSessionLclLTIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 15), IfcpLTIorZero()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLclLTIntvl.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionLclLTIntvl.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLclLTIntvl.setDescription('The Liveness Test Interval (LTI) used for this iFCP session. The value can be changed on a per-session basis and initially defaults to ifcpLclGtwyInstDefaultLTInterval for the local gateway instance. The valid range is 0 - 65535 seconds. A value of 0 implies that the gateway will not originate Liveness Test messages for the session.')
ifcpSessionRmtLTIntvl = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 16), IfcpLTIorZero()).setUnits('seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRmtLTIntvl.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionRmtLTIntvl.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRmtLTIntvl.setDescription('The Liveness Test Interval (LTI) as requested by the remote gateway instance to use for this iFCP session. This value may change over the life of the session. The valid range is 0 - 65535 seconds. A value of 0 implies that the remote gateway has not been requested to originate Liveness Test messages for the session.')
ifcpSessionBound = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 17), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionBound.setReference('RFC 4172, iFCP Protocol Specification')
if mibBuilder.loadTexts: ifcpSessionBound.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionBound.setDescription('This value indicates whether this session is bound to a specific local and remote N Port. Sessions by default are unbound and ready for future assignment to a local and remote N Port.')
ifcpSessionStorageType = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 1, 1, 18), StorageType().clone('nonVolatile')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionStorageType.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionStorageType.setDescription('The storage type for this row. Parameter values defined for a session are usually non-volatile, but may be volatile or permanent in some configurations. If permanent, then ifcpSessionIpTOV must have read-write access.')
ifcpSessionStatsTable = MibTable((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2), )
if mibBuilder.loadTexts: ifcpSessionStatsTable.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionStatsTable.setDescription('This table provides statistics on an iFCP session.')
ifcpSessionStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1), )
ifcpSessionAttributesEntry.registerAugmentions(("IFCP-MGMT-MIB", "ifcpSessionStatsEntry"))
ifcpSessionStatsEntry.setIndexNames(*ifcpSessionAttributesEntry.getIndexNames())
if mibBuilder.loadTexts: ifcpSessionStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionStatsEntry.setDescription('Provides iFCP-specific statistics per session.')
ifcpSessionState = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 1), IfcpSessionStates()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionState.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionState.setDescription('The current session operating state.')
ifcpSessionDuration = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionDuration.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionDuration.setDescription('This indicates, in seconds, how long the iFCP session has been in an open or open-pending state. When a session is down, the value is reset to 0.')
ifcpSessionTxOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 3), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionTxOctets.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionTxOctets.setDescription('The total number of octets transmitted by the iFCP gateway for this session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionRxOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 4), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRxOctets.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRxOctets.setDescription('The total number of octets received by the iFCP gateway for this session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionTxFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 5), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionTxFrames.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionTxFrames.setDescription('The total number of iFCP frames transmitted by the gateway for this session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionRxFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 6), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionRxFrames.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionRxFrames.setDescription('The total number of iFCP frames received by the gateway for this session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionStaleFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 7), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionStaleFrames.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionStaleFrames.setDescription('The total number of received iFCP frames that were stale and discarded by the gateway for this session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionHeaderCRCErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 8), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionHeaderCRCErrors.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionHeaderCRCErrors.setDescription('The total number of Cyclic Redundancy Check (CRC) errors that occurred in the frame header, detected by the gateway for this session. Usually, a single Header CRC error is sufficient to terminate an iFCP session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionFcPayloadCRCErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 9), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionFcPayloadCRCErrors.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionFcPayloadCRCErrors.setDescription('The total number of CRC errors that occurred in the Fibre Channel frame payload, detected by the gateway for this session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionOtherErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 10), ZeroBasedCounter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionOtherErrors.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionOtherErrors.setDescription('The total number of errors, other than errors explicitly measured, detected by the gateway for this session. Discontinuities in the value of this counter can occur at reinitialization of the management system, and at other times as indicated by the value of ifcpSessionDiscontinuityTime.')
ifcpSessionDiscontinuityTime = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 2, 1, 11), TimeStamp()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionDiscontinuityTime.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionDiscontinuityTime.setDescription('The value of sysUpTime on the most recent occasion at which any one (or more) of the ifcpSessionStatsTable counters suffered a discontinuity. The relevant counters are the specific Counter64-based instances associated with the ifcpSessionStatsTable: ifcpSessionTxOctets, ifcpSessionRxOctets, ifcpSessionTxFrames, ifcpSessionRxFrames, ifcpSessionStaleFrames, ifcpSessionHeaderCRCErrors, ifcpSessionFcPayloadCRCErrors, and ifcpSessionOtherErrors. If no such discontinuities have occurred since the last reinitialization of the local management subsystem, then this object contains a zero value.')
ifcpSessionLcStatsTable = MibTable((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3), )
if mibBuilder.loadTexts: ifcpSessionLcStatsTable.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcStatsTable.setDescription('This table provides low-capacity statistics for an iFCP session. These are provided for backward compatibility with systems that do not support Counter64-based objects. At 1-Gbps rates, a Counter32-based object can wrap as often as every 34 seconds. Counter32-based objects can be sufficient for many situations. However, when possible, it is recommended to use the high-capacity statistics in ifcpSessionStatsTable based on Counter64 objects.')
ifcpSessionLcStatsEntry = MibTableRow((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1), )
ifcpSessionAttributesEntry.registerAugmentions(("IFCP-MGMT-MIB", "ifcpSessionLcStatsEntry"))
ifcpSessionLcStatsEntry.setIndexNames(*ifcpSessionAttributesEntry.getIndexNames())
if mibBuilder.loadTexts: ifcpSessionLcStatsEntry.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcStatsEntry.setDescription('Provides iFCP-specific statistics per session.')
ifcpSessionLcTxOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 1), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcTxOctets.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcTxOctets.setDescription('The total number of octets transmitted by the iFCP gateway for this session.')
ifcpSessionLcRxOctets = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 2), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcRxOctets.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcRxOctets.setDescription('The total number of octets received by the iFCP gateway for this session.')
ifcpSessionLcTxFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 3), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcTxFrames.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcTxFrames.setDescription('The total number of iFCP frames transmitted by the gateway for this session.')
ifcpSessionLcRxFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 4), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcRxFrames.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcRxFrames.setDescription('The total number of iFCP frames received by the gateway for this session.')
ifcpSessionLcStaleFrames = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 5), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcStaleFrames.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcStaleFrames.setDescription('The total number of received iFCP frames that were stale and discarded by the gateway for this session.')
ifcpSessionLcHeaderCRCErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 6), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcHeaderCRCErrors.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcHeaderCRCErrors.setDescription('The total number of CRC errors that occurred in the frame header, detected by the gateway for this session. Usually, a single Header CRC error is sufficient to terminate an iFCP session.')
ifcpSessionLcFcPayloadCRCErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 7), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcFcPayloadCRCErrors.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcFcPayloadCRCErrors.setDescription('The total number of CRC errors that occurred in the Fibre Channel frame payload, detected by the gateway for this session.')
ifcpSessionLcOtherErrors = MibTableColumn((1, 3, 6, 1, 2, 1, 10, 230, 1, 2, 3, 1, 8), ZeroBasedCounter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifcpSessionLcOtherErrors.setStatus('current')
if mibBuilder.loadTexts: ifcpSessionLcOtherErrors.setDescription('The total number of errors, other than errors explicitly measured, detected by the gateway for this session.')
ifcpCompliances = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 230, 2, 1))
ifcpGatewayCompliance = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 230, 2, 1, 1)).setObjects(("IFCP-MGMT-MIB", "ifcpLclGatewayGroup"), ("IFCP-MGMT-MIB", "ifcpLclGatewaySessionGroup"), ("IFCP-MGMT-MIB", "ifcpLclGatewaySessionStatsGroup"), ("IFCP-MGMT-MIB", "ifcpLclGatewaySessionLcStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifcpGatewayCompliance = ifcpGatewayCompliance.setStatus('deprecated')
if mibBuilder.loadTexts: ifcpGatewayCompliance.setDescription('This MODULE-COMPLIANCE has been deprecated because address translation mode has been deprecated in the iFCP standard. It has the implementation requirements for iFCP MIB module compliance.')
ifcpGatewayComplianceNoTranslation = ModuleCompliance((1, 3, 6, 1, 2, 1, 10, 230, 2, 1, 2)).setObjects(("IFCP-MGMT-MIB", "ifcpLclGatewayGroup"), ("IFCP-MGMT-MIB", "ifcpLclGatewaySessionGroupNoTranslation"), ("IFCP-MGMT-MIB", "ifcpLclGatewaySessionStatsGroup"), ("IFCP-MGMT-MIB", "ifcpLclGatewaySessionLcStatsGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifcpGatewayComplianceNoTranslation = ifcpGatewayComplianceNoTranslation.setStatus('current')
if mibBuilder.loadTexts: ifcpGatewayComplianceNoTranslation.setDescription('Implementation requirements for iFCP MIB module compliance. Address translation mode has been deprecated in the iFCP standard.')
if mibBuilder.loadTexts: ifcpGatewayComplianceNoTranslation.setReference('RFC 4172, iFCP Protocol Specification; RFC 6172, Deprecation of iFCP Address Translation Mode')
ifcpGroups = MibIdentifier((1, 3, 6, 1, 2, 1, 10, 230, 2, 2))
ifcpLclGatewayGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 230, 2, 2, 1)).setObjects(("IFCP-MGMT-MIB", "ifcpLclGtwyInstPhyIndex"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstVersionMin"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstVersionMax"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstAddrTransMode"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstFcBrdcstSupport"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstDefaultIpTOV"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstDefaultLTInterval"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstDescr"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstNumActiveSessions"), ("IFCP-MGMT-MIB", "ifcpLclGtwyInstStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifcpLclGatewayGroup = ifcpLclGatewayGroup.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGatewayGroup.setDescription('iFCP local device info group. This group provides information about each gateway.')
ifcpLclGatewaySessionGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 230, 2, 2, 4)).setObjects(("IFCP-MGMT-MIB", "ifcpSessionLclPrtlIfIndex"), ("IFCP-MGMT-MIB", "ifcpSessionLclPrtlAddrType"), ("IFCP-MGMT-MIB", "ifcpSessionLclPrtlAddr"), ("IFCP-MGMT-MIB", "ifcpSessionLclPrtlTcpPort"), ("IFCP-MGMT-MIB", "ifcpSessionLclNpWwun"), ("IFCP-MGMT-MIB", "ifcpSessionLclNpFcid"), ("IFCP-MGMT-MIB", "ifcpSessionRmtNpWwun"), ("IFCP-MGMT-MIB", "ifcpSessionRmtPrtlIfAddrType"), ("IFCP-MGMT-MIB", "ifcpSessionRmtPrtlIfAddr"), ("IFCP-MGMT-MIB", "ifcpSessionRmtPrtlTcpPort"), ("IFCP-MGMT-MIB", "ifcpSessionRmtNpFcid"), ("IFCP-MGMT-MIB", "ifcpSessionRmtNpFcidAlias"), ("IFCP-MGMT-MIB", "ifcpSessionIpTOV"), ("IFCP-MGMT-MIB", "ifcpSessionLclLTIntvl"), ("IFCP-MGMT-MIB", "ifcpSessionRmtLTIntvl"), ("IFCP-MGMT-MIB", "ifcpSessionBound"), ("IFCP-MGMT-MIB", "ifcpSessionStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifcpLclGatewaySessionGroup = ifcpLclGatewaySessionGroup.setStatus('deprecated')
if mibBuilder.loadTexts: ifcpLclGatewaySessionGroup.setDescription('This OBJECT-GROUP has been deprecated because address translation mode has been deprecated in the iFCP standard. iFCP Session group. This group provides information about each iFCP session currently active between iFCP gateways.')
ifcpLclGatewaySessionStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 230, 2, 2, 5)).setObjects(("IFCP-MGMT-MIB", "ifcpSessionState"), ("IFCP-MGMT-MIB", "ifcpSessionDuration"), ("IFCP-MGMT-MIB", "ifcpSessionTxOctets"), ("IFCP-MGMT-MIB", "ifcpSessionRxOctets"), ("IFCP-MGMT-MIB", "ifcpSessionTxFrames"), ("IFCP-MGMT-MIB", "ifcpSessionRxFrames"), ("IFCP-MGMT-MIB", "ifcpSessionStaleFrames"), ("IFCP-MGMT-MIB", "ifcpSessionHeaderCRCErrors"), ("IFCP-MGMT-MIB", "ifcpSessionFcPayloadCRCErrors"), ("IFCP-MGMT-MIB", "ifcpSessionOtherErrors"), ("IFCP-MGMT-MIB", "ifcpSessionDiscontinuityTime"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifcpLclGatewaySessionStatsGroup = ifcpLclGatewaySessionStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGatewaySessionStatsGroup.setDescription('iFCP Session Statistics group. This group provides statistics with 64-bit counters for each iFCP session currently active between iFCP gateways. This group is only required for agents that can support Counter64- based data types.')
ifcpLclGatewaySessionLcStatsGroup = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 230, 2, 2, 6)).setObjects(("IFCP-MGMT-MIB", "ifcpSessionLcTxOctets"), ("IFCP-MGMT-MIB", "ifcpSessionLcRxOctets"), ("IFCP-MGMT-MIB", "ifcpSessionLcTxFrames"), ("IFCP-MGMT-MIB", "ifcpSessionLcRxFrames"), ("IFCP-MGMT-MIB", "ifcpSessionLcStaleFrames"), ("IFCP-MGMT-MIB", "ifcpSessionLcHeaderCRCErrors"), ("IFCP-MGMT-MIB", "ifcpSessionLcFcPayloadCRCErrors"), ("IFCP-MGMT-MIB", "ifcpSessionLcOtherErrors"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifcpLclGatewaySessionLcStatsGroup = ifcpLclGatewaySessionLcStatsGroup.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGatewaySessionLcStatsGroup.setDescription('iFCP Session Low-Capacity Statistics group. This group provides statistics with low-capacity 32-bit counters for each iFCP session currently active between iFCP gateways. This group is only required for agents that do not support Counter64-based data types, or that need to support SNMPv1 applications.')
ifcpLclGatewaySessionGroupNoTranslation = ObjectGroup((1, 3, 6, 1, 2, 1, 10, 230, 2, 2, 7)).setObjects(("IFCP-MGMT-MIB", "ifcpSessionLclPrtlIfIndex"), ("IFCP-MGMT-MIB", "ifcpSessionLclPrtlAddrType"), ("IFCP-MGMT-MIB", "ifcpSessionLclPrtlAddr"), ("IFCP-MGMT-MIB", "ifcpSessionLclPrtlTcpPort"), ("IFCP-MGMT-MIB", "ifcpSessionLclNpWwun"), ("IFCP-MGMT-MIB", "ifcpSessionLclNpFcid"), ("IFCP-MGMT-MIB", "ifcpSessionRmtNpWwun"), ("IFCP-MGMT-MIB", "ifcpSessionRmtPrtlIfAddrType"), ("IFCP-MGMT-MIB", "ifcpSessionRmtPrtlIfAddr"), ("IFCP-MGMT-MIB", "ifcpSessionRmtPrtlTcpPort"), ("IFCP-MGMT-MIB", "ifcpSessionRmtNpFcid"), ("IFCP-MGMT-MIB", "ifcpSessionIpTOV"), ("IFCP-MGMT-MIB", "ifcpSessionLclLTIntvl"), ("IFCP-MGMT-MIB", "ifcpSessionRmtLTIntvl"), ("IFCP-MGMT-MIB", "ifcpSessionBound"), ("IFCP-MGMT-MIB", "ifcpSessionStorageType"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifcpLclGatewaySessionGroupNoTranslation = ifcpLclGatewaySessionGroupNoTranslation.setStatus('current')
if mibBuilder.loadTexts: ifcpLclGatewaySessionGroupNoTranslation.setDescription('iFCP Session group. This group provides information about each iFCP session currently active between iFCP gateways.')
mibBuilder.exportSymbols("IFCP-MGMT-MIB", ifcpSessionLcStatsTable=ifcpSessionLcStatsTable, ifcpSessionLclPrtlAddr=ifcpSessionLclPrtlAddr, ifcpSessionRmtPrtlTcpPort=ifcpSessionRmtPrtlTcpPort, ifcpLclGatewaySessionGroup=ifcpLclGatewaySessionGroup, ifcpLclGtwyInstDefaultIpTOV=ifcpLclGtwyInstDefaultIpTOV, ifcpSessionRmtNpFcidAlias=ifcpSessionRmtNpFcidAlias, ifcpSessionRmtLTIntvl=ifcpSessionRmtLTIntvl, IfcpIpTOVorZero=IfcpIpTOVorZero, ifcpLclGatewayInfo=ifcpLclGatewayInfo, ifcpSessionIndex=ifcpSessionIndex, ifcpLclGtwyInstDescr=ifcpLclGtwyInstDescr, ifcpSessionLclPrtlIfIndex=ifcpSessionLclPrtlIfIndex, ifcpLclGtwyInstIndex=ifcpLclGtwyInstIndex, ifcpSessionStatsTable=ifcpSessionStatsTable, ifcpSessionHeaderCRCErrors=ifcpSessionHeaderCRCErrors, ifcpSessionLclNpFcid=ifcpSessionLclNpFcid, ifcpSessionDiscontinuityTime=ifcpSessionDiscontinuityTime, ifcpSessionLcStatsEntry=ifcpSessionLcStatsEntry, ifcpSessionIpTOV=ifcpSessionIpTOV, IfcpLTIorZero=IfcpLTIorZero, ifcpMgmtMIB=ifcpMgmtMIB, ifcpSessionLclPrtlAddrType=ifcpSessionLclPrtlAddrType, ifcpSessionLclNpWwun=ifcpSessionLclNpWwun, ifcpSessionStorageType=ifcpSessionStorageType, ifcpSessionFcPayloadCRCErrors=ifcpSessionFcPayloadCRCErrors, ifcpSessionStatsEntry=ifcpSessionStatsEntry, ifcpLclGatewayGroup=ifcpLclGatewayGroup, ifcpSessionTxFrames=ifcpSessionTxFrames, ifcpSessionLcRxOctets=ifcpSessionLcRxOctets, ifcpSessionRxOctets=ifcpSessionRxOctets, ifcpNportSessionInfo=ifcpNportSessionInfo, ifcpCompliances=ifcpCompliances, ifcpGatewayCompliance=ifcpGatewayCompliance, ifcpSessionAttributesEntry=ifcpSessionAttributesEntry, ifcpSessionState=ifcpSessionState, ifcpSessionRmtPrtlIfAddrType=ifcpSessionRmtPrtlIfAddrType, ifcpSessionLcTxOctets=ifcpSessionLcTxOctets, ifcpSessionLcHeaderCRCErrors=ifcpSessionLcHeaderCRCErrors, ifcpLclGatewaySessionLcStatsGroup=ifcpLclGatewaySessionLcStatsGroup, ifcpLclGtwyInstStorageType=ifcpLclGtwyInstStorageType, ifcpSessionLcOtherErrors=ifcpSessionLcOtherErrors, PYSNMP_MODULE_ID=ifcpMgmtMIB, ifcpLclGtwyInstAddrTransMode=ifcpLclGtwyInstAddrTransMode, ifcpSessionRmtNpFcid=ifcpSessionRmtNpFcid, ifcpSessionBound=ifcpSessionBound, ifcpSessionRmtNpWwun=ifcpSessionRmtNpWwun, ifcpSessionTxOctets=ifcpSessionTxOctets, ifcpSessionLclLTIntvl=ifcpSessionLclLTIntvl, ifcpGatewayObjects=ifcpGatewayObjects, ifcpLclGatewaySessionGroupNoTranslation=ifcpLclGatewaySessionGroupNoTranslation, ifcpLclGtwyInstPhyIndex=ifcpLclGtwyInstPhyIndex, IfcpSessionStates=IfcpSessionStates, ifcpSessionAttributesTable=ifcpSessionAttributesTable, ifcpSessionRxFrames=ifcpSessionRxFrames, ifcpSessionStaleFrames=ifcpSessionStaleFrames, ifcpSessionLcFcPayloadCRCErrors=ifcpSessionLcFcPayloadCRCErrors, ifcpSessionOtherErrors=ifcpSessionOtherErrors, ifcpLclGtwyInstNumActiveSessions=ifcpLclGtwyInstNumActiveSessions, ifcpLclGtwyInstDefaultLTInterval=ifcpLclGtwyInstDefaultLTInterval, ifcpSessionLcRxFrames=ifcpSessionLcRxFrames, ifcpSessionLcTxFrames=ifcpSessionLcTxFrames, ifcpGroups=ifcpGroups, IfcpAddressMode=IfcpAddressMode, ifcpLclGtwyInstEntry=ifcpLclGtwyInstEntry, ifcpLclGtwyInstVersionMax=ifcpLclGtwyInstVersionMax, ifcpSessionLclPrtlTcpPort=ifcpSessionLclPrtlTcpPort, ifcpLclGtwyInstFcBrdcstSupport=ifcpLclGtwyInstFcBrdcstSupport, ifcpLclGatewaySessionStatsGroup=ifcpLclGatewaySessionStatsGroup, ifcpLclGtwyInstVersionMin=ifcpLclGtwyInstVersionMin, ifcpSessionRmtPrtlIfAddr=ifcpSessionRmtPrtlIfAddr, ifcpSessionLcStaleFrames=ifcpSessionLcStaleFrames, ifcpGatewayConformance=ifcpGatewayConformance, ifcpLclGtwyInstTable=ifcpLclGtwyInstTable, ifcpSessionDuration=ifcpSessionDuration, ifcpGatewayComplianceNoTranslation=ifcpGatewayComplianceNoTranslation)

#
# PySNMP MIB module CISCO-6200-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-6200-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:49:41 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ConstraintsIntersection, ValueRangeConstraint, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ConstraintsIntersection", "ValueRangeConstraint", "ValueSizeConstraint")
ciscoExperiment, = mibBuilder.importSymbols("CISCO-SMI", "ciscoExperiment")
NotificationGroup, ModuleCompliance, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance", "ObjectGroup")
Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, Unsigned32, MibIdentifier, TimeTicks, NotificationType, ObjectIdentity, IpAddress, ModuleIdentity, Counter64, iso, Gauge32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "Unsigned32", "MibIdentifier", "TimeTicks", "NotificationType", "ObjectIdentity", "IpAddress", "ModuleIdentity", "Counter64", "iso", "Gauge32", "Counter32")
TextualConvention, DisplayString, DateAndTime = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString", "DateAndTime")
cisco6200MIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 10, 26))
cisco6200MIB.setRevisions(('1998-02-26 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cisco6200MIB.setRevisionsDescriptions(('The initial release of this MIB only supported CAP line cards.',))
if mibBuilder.loadTexts: cisco6200MIB.setLastUpdated('9807280000Z')
if mibBuilder.loadTexts: cisco6200MIB.setOrganization('Cisco System, Inc.')
if mibBuilder.loadTexts: cisco6200MIB.setContactInfo('Cisco Systems Customer Service Postal: 170 West Tasman Drive San Jose, CA 95134 USA Tel: +1 800 553-NETS E-mail: cs-c6200@cisco.com')
if mibBuilder.loadTexts: cisco6200MIB.setDescription('This MIB provides CISCO 6200 product information It is structured as following groups: system - not part of indices, defines system, slot and port level scalars.')
cisco6200MibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 1))
c62System = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1))
c62Slot = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2))
c62OCInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3))
c62LineInterface = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4))
c62Subscriber = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5))
class C6200CardType(TextualConvention, Integer32):
    description = 'Represents card types contained in the C6200 product lines. oc3si - one port, single mode, intermediate reach OC3 - based interface card ctl - controller card cap8 - eight port CAP RADSL interface card cap16 - sixteen port CAP RADSL interface card oc3ss - one port, single mode, short reach OC3 based - interface card oc3mm - one port, multi mode OC3 based interface card stm1si - one port, single mode, intermediate reach STM1 based interface card stm1mm - one port, multi mode STM1 based interface card dmt8 - eight port DMT RADSL interface card none - marks slot as vacant'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, -1))
    namedValues = NamedValues(("oc3si", 1), ("ctl", 2), ("cap8", 3), ("cap16", 4), ("oc3ss", 5), ("oc3mm", 6), ("stm1si", 7), ("stm1mm", 8), ("dmt8", 9), ("none", -1))

class CommandValue(TextualConvention, Integer32):
    description = 'This parameter controls execution of a command. The intended command can be triggered by setting its value to execute. Its value goes back to ready when intended command execution is complete.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("ready", 1), ("execute", 2))

class AlarmLevel(TextualConvention, Integer32):
    description = 'Represents error status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))
    namedValues = NamedValues(("none", 1), ("minor", 2), ("major", 3), ("critical", 4), ("unknown", 5))

class InterfaceStatus(TextualConvention, Integer32):
    description = 'Represents interface status.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2))
    namedValues = NamedValues(("enabled", 1), ("disabled", 2))

class TestStatus(TextualConvention, Integer32):
    description = 'Represents status of the test per subscriber line. Please refer to lineTestTable for details on how to start a test. Once test completes or aborted, status stays as pass, fail, or aborted respectively until user clears it by setting it to inactive or starts new test and that operation changes this to active.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))
    namedValues = NamedValues(("inactive", 1), ("active", 2), ("pass", 3), ("fail", 4), ("aborted", 5), ("waiting", 6))

class TestType(TextualConvention, Integer32):
    description = 'Represents Types of tests support per line.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))
    namedValues = NamedValues(("none", 0), ("lineQuality", 1), ("capHardware", 2), ("dmtLocalTest", 3))

systemType = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("c62OC3", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemType.setStatus('current')
if mibBuilder.loadTexts: systemType.setDescription('This type provides specific details about C6200 system type and what kind of network interface it uses.')
systemAlarmLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 2), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: systemAlarmLevel.setDescription('This reflects the alarm level of the C6200 system. It is the aggregation of the slot/port level alarms. Alarm levels supported at the system level are none, minor, major and critical. Unknown has no meaning.')
systemAlarmLevelChngCounter = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemAlarmLevelChngCounter.setStatus('current')
if mibBuilder.loadTexts: systemAlarmLevelChngCounter.setDescription('Counter indicating a change in the system alarm level due to change either at the slot or port alarm level. This will be incremented by the system whenever any new alarm is raised or cleared at slot or port level. This is needed as rising or clearing of an alarm at port or slot level may not cause systemAlarmLevel to change. This counter, in such case helps manager application to recognize that alarm levels below system level has changed without causing change in the systemAlarmLevel. e.g. Say: System has two subscriber lines experiencing a minor alarm condition. systemAlarmLevel will be a minor alarm in such case. Now if one of the port level minor alarms clear, a port alarm level would become OK but the system and slot alarm levels may stay as a minor alarm.')
systemReset = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 4), CommandValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemReset.setStatus('current')
if mibBuilder.loadTexts: systemReset.setDescription('This parameter allows user to reboot the system with system configuration from NVRAM (non-volatile memory). It can be used for following purposes: (1) Undo changes made to the system and not yet saved in the NVRAM. (2) Force the system to reboot from NVRAM configuration. This command disrupts service to all the subscribers associated with the system, so it should be use sparingly.')
systemSaveCnfg = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 5), CommandValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemSaveCnfg.setStatus('current')
if mibBuilder.loadTexts: systemSaveCnfg.setDescription('This parameter allows user/operator to make system changes permanent. It causes system to write the system configuration on a non-volatile memory (NVRAM). There is no need to restart the system to make these changes effective.')
systemProvChngCounter = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemProvChngCounter.setStatus('current')
if mibBuilder.loadTexts: systemProvChngCounter.setDescription('Counter indicating a card or subscriber provisioning change. This will be incremented by the system whenever any change is made. This is used to avoid unneccessary polling.')
systemHClockAlarmLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 7), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemHClockAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: systemHClockAlarmLevel.setDescription('This reflects the alarm level of the H-bus backplane clock. H-bus clock error results in critical alarm at the at system level (systemAlarmLevel = critical).')
systemFanAlarmLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 8), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemFanAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: systemFanAlarmLevel.setDescription('This reflects the alarm level of the fans. Error for this parameter indicates failure of one or more fans. This error results in minor alarm at the system level (systemAlarmLevel = minor).')
systemTemperatureAlarmLevel = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 9), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: systemTemperatureAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: systemTemperatureAlarmLevel.setDescription('This reflects the alarm level of the system temperature. When temperature exceeds system preconfigured system allowable limit this parameter indicates an error. This error results in minor alarm at the system level (systemAlarmLevel = minor).')
systemACO = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 1, 10), CommandValue()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: systemACO.setStatus('current')
if mibBuilder.loadTexts: systemACO.setDescription('This parameter deactivates the audible alarm at the system. Audible alarm is generated by the system to announce detection of new alarm(s). Once deactivated, system may activate it again if it detects new additional alarm(s).')
slotTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1), )
if mibBuilder.loadTexts: slotTable.setStatus('current')
if mibBuilder.loadTexts: slotTable.setDescription('Table contains slot level information such as status, status change time, card type and software version. It is indexed using slot identifier. Empty entries are indicated using status empty and card type none. Operator can provision a new card in the system by setting slotCnfType parameter in this table. Changes to the slot configuration are temporary until user actually requests save operation through systemSaveCnfg. Only at that point system writes information in the NVRAM storage and information becomes permanent.')
slotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1), ).setIndexNames((0, "CISCO-6200-MIB", "slotID"))
if mibBuilder.loadTexts: slotEntry.setStatus('current')
if mibBuilder.loadTexts: slotEntry.setDescription('Entry in the slot table')
slotID = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 14)))
if mibBuilder.loadTexts: slotID.setStatus('current')
if mibBuilder.loadTexts: slotID.setDescription('Slot Identifier for the selected slot.')
slotType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 2), C6200CardType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotType.setStatus('current')
if mibBuilder.loadTexts: slotType.setDescription('The current type of card in the physical cage, as reported by the system.')
slotStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("empty", 1), ("notProvisioned", 2), ("missing", 3), ("mismatch", 4), ("match", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotStatus.setStatus('current')
if mibBuilder.loadTexts: slotStatus.setDescription('The current status of the slot.')
slotSwVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotSwVersion.setStatus('current')
if mibBuilder.loadTexts: slotSwVersion.setDescription('The currently active firmware version number as a positive whole number, e.g. 100.')
slotAlarmLevelChngCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotAlarmLevelChngCounter.setStatus('current')
if mibBuilder.loadTexts: slotAlarmLevelChngCounter.setDescription('Counter indicating change in the port alarm level. This is needed as rising or clearing of an port level alarm may not cause slotAlarmLevel to change. This counter, in such case helps a manager application to recognize that the alarm levels below slot level have changed without change in the slotAlarmLevel (e.g. Say: a line card has two subscriber lines experiencing Minor alarm condition. The slot alarm level will be minor alarm in such case. Now if one of the port level minor alarms clear, the port alarm level would become OK but slot alarm level will stay as a minor alarm. Alarm level change includes rising or clearing of a new alarm at slot/port level).')
slotCnfType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 6), C6200CardType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: slotCnfType.setStatus('current')
if mibBuilder.loadTexts: slotCnfType.setDescription('Card type, as provisioned by the operator used to compare against card type reported by the system for monitoring purposes. If slotType and slotCnfType do not match and slotCnfType is not set to none, slotStatus is set to mismatch. This condition only clears when operator corrects the configuration to make them match. The valid card type for each slot is as follows: slot 1: oc3si, oc3mm, stm1si and stm1mm slot 2: ctl slot 3 & 4: none slot 5 - 14: cap8 and dmt8')
slotSubscriberChngCounter = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotSubscriberChngCounter.setStatus('current')
if mibBuilder.loadTexts: slotSubscriberChngCounter.setDescription('Counter indicating change in the subscriber table. This will be incremented by the slot whenever any change is made at the port level. This is used to avoid unneccessary polling at the subscriber table level.')
slotAlarmLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 1, 1, 8), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: slotAlarmLevel.setDescription('This reflects the alarm level of the slot. It is the aggregation of the port level alarms. Alarm levels supported at the slot level are none, minor, major, critical and unknown.')
portID = MibScalar((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 2, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 64)))
if mibBuilder.loadTexts: portID.setStatus('current')
if mibBuilder.loadTexts: portID.setDescription('Port Identifier on the targeted slot. PortID value depends on the slot type.')
oCInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1), )
if mibBuilder.loadTexts: oCInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: oCInterfaceTable.setDescription('This table contains SONET alarm information. It is indexed using slot and port identifier. Each object represents the alarm level of individual SONET alarm condition.')
oCInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-6200-MIB", "slotID"), (0, "CISCO-6200-MIB", "portID"))
if mibBuilder.loadTexts: oCInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: oCInterfaceEntry.setDescription('Each entry represents a SONET alarm condition. Following are the definition of SONET level alarms: EQF - Equipment Failure (Local) (causes slotStatus to be critical) Near End Alarms (causes slotStatus to be critical): LOS - Loss of Signal LOF - Loss of Frame LAIS - Line Alarm Indication Signal LOP - Loss of Pointer PAIS - Path Alarm Indication Signal SLM - Signal Label Mismatch Far End Alarms: (causes slotStatus to be critical) LRFI - Line Remote Failure Indication PRFI - Path Remote Failure Indication Miscellaneous. Alarms: LOST - Loss Of Synchronization (causes slotStatus to be major) LOCD - Loss 0f Cell Delineation. (causes slotStatus to be critical) Individual alarm description describes any interdependencies between alarm types. It also contains port status and interface mode.')
oCIAlarmLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 2), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCIAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: oCIAlarmLevel.setDescription('The current alarm level on the optical interface, may be none, major, critical or unknown. When the port is experiencing equipment failure or any of the near end alarm condition, the alarm level is marked critical. When the port is experiencing a far end alarm condition, the alarm level is marked major. When the port is in loopback mode, the alarm level is marked as unknown.')
oCIEQF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 3), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCIEQF.setStatus('current')
if mibBuilder.loadTexts: oCIEQF.setDescription('Local equipment failure indication. Possible values are none or critical. When this attribute is critical, all other alarm conditions are unknown.')
oCILOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 4), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCILOS.setStatus('current')
if mibBuilder.loadTexts: oCILOS.setDescription('Loss of signal indication. Possible values are none or critical. When this attribute is critical, oCILOF, oCILOP, oCILAIS, oCIPAIS, oCISLM, oCILRFI, oCIPRFI and oCILOCD are unknown.')
oCILOF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 5), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCILOF.setStatus('current')
if mibBuilder.loadTexts: oCILOF.setDescription('Loss of frame indication. Possible values are none, critical or unknown. When this attribute is critical, oCILAIS, oCILOP, oCIPAIS, oCISLM, oCILRFI, oCIPRFI and oCILOCD are unknown.')
oCILAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 6), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCILAIS.setStatus('current')
if mibBuilder.loadTexts: oCILAIS.setDescription('Line alarm indication signal. Possible values are none, critical or unknown. When this attribute is critical, oCILOP and oCISLM are unknown.')
oCILOP = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 7), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCILOP.setStatus('current')
if mibBuilder.loadTexts: oCILOP.setDescription('Loss of pointer indication. Possible values are none, critical or unknown. When this attribute is critical, oCIPAIS, oCISLM and oCILOCD are unknown.')
oCIPAIS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 8), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCIPAIS.setStatus('current')
if mibBuilder.loadTexts: oCIPAIS.setDescription('Path alarm indication signal. Possible values are none, critical or unknown. When this attribute is critical, oCISLM is unknown.')
oCISLM = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 9), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCISLM.setStatus('current')
if mibBuilder.loadTexts: oCISLM.setDescription('Signal label mismatch indication. Possible values are none, critical or unknown.')
oCILRFI = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 10), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCILRFI.setStatus('current')
if mibBuilder.loadTexts: oCILRFI.setDescription('Line remote failure indication. Possible values are none, critical or unknown.')
oCIPRFI = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 11), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCIPRFI.setStatus('current')
if mibBuilder.loadTexts: oCIPRFI.setDescription('Path remote failure indication. Possible values are none, critical or unknown.')
oCILOST = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 12), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCILOST.setStatus('current')
if mibBuilder.loadTexts: oCILOST.setDescription('Loss of synchronization indication. Possible values are none, major or unknown.')
oCILOCD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 13), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCILOCD.setStatus('current')
if mibBuilder.loadTexts: oCILOCD.setDescription('Loss of cell delineation. Possible values are none, critical or unknown.')
oCILoopMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: oCILoopMode.setStatus('current')
if mibBuilder.loadTexts: oCILoopMode.setDescription('This parameter puts the optical interface of C6200 system in facility (far end) loopback mode. It causes the node to loop all the traffic received on the optical interface back to the network. It does not generate any traffic or perform any kind of testing locally. This mode affects services to all the users connected through the node, so this facility must be used with care. User must set it back to disable mode once the testing completes. System will stay in loopback mode, if enabled, until the user disables the loop mode through NMS Manager or the system terminates - in which case loop mode is disabled automatically. It is only meaningful when the out of band management channel is used for management. It may not be useful when the in-band management channel is used for management traffic, as it causes breakdown in the management communications channel. The alarm level of the port is set to unknown while loopback mode is enabled.')
oCPerfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 2), )
if mibBuilder.loadTexts: oCPerfTable.setStatus('current')
if mibBuilder.loadTexts: oCPerfTable.setDescription('This table contains SONET Performance parameters.')
oCPerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 2, 1), ).setIndexNames((0, "CISCO-6200-MIB", "slotID"), (0, "CISCO-6200-MIB", "portID"))
if mibBuilder.loadTexts: oCPerfEntry.setStatus('current')
if mibBuilder.loadTexts: oCPerfEntry.setDescription('Each entry represents a SONET performance parameters for the targeted port.')
oCPTxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCPTxCellCount.setStatus('current')
if mibBuilder.loadTexts: oCPTxCellCount.setDescription('Count of number of non-idle ATM cells inserted into the transmit SONET payload since system start time. This is free running counter and rolls back to zero when the value exceeds 2^32.')
oCPRxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCPRxCellCount.setStatus('current')
if mibBuilder.loadTexts: oCPRxCellCount.setDescription('Count of number of ATM cells received at SONET interface since system start time. Idle cells and cells with uncorrectable header errors are not included in the count. This is a free running counter which rolls back to zero when the value exceeds 2^32.')
oCPHecErrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 3, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: oCPHecErrCount.setStatus('current')
if mibBuilder.loadTexts: oCPHecErrCount.setDescription('A count of uncorrectable header errors since system start time. This is a free running counter which rolls back to zero when the value exceeds 2^32.')
lineInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1), )
if mibBuilder.loadTexts: lineInterfaceTable.setStatus('current')
if mibBuilder.loadTexts: lineInterfaceTable.setDescription('The line table describes basic identification and runtime fault information on the individual subscriber line. A subscriber line consists of a port on the line card, Customer Premises Equipment (CPE) and a physical line connecting both. Fault monitoring is supported for both ends of the line. Subscriber line information consists of upstream (local port) information as well as downstream (Remote CPE) information. Downstream (ATU-C->ATU-R) information is reported by the individual port of the line card locally. Upstream (ATU-R->ATU-C) information is remote end (CPE) information which can be obtained via heartbeat messages generated by the CPE, other proprietary or standards based mechanisms. This information is proxied by the line card on the C6200 system. Entries in the table with non-assigned port have their mode disabled, so no service is available unless the port is configured and assigned to a subscriber.')
lineInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1), ).setIndexNames((0, "CISCO-6200-MIB", "slotID"), (0, "CISCO-6200-MIB", "portID"))
if mibBuilder.loadTexts: lineInterfaceEntry.setStatus('current')
if mibBuilder.loadTexts: lineInterfaceEntry.setDescription('The entry describes the fields being supported by the line table.')
lineAlarmLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 1), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineAlarmLevel.setStatus('current')
if mibBuilder.loadTexts: lineAlarmLevel.setDescription('The current alarm level of the port. Refer to TEXTUAL-CONVENTION section for details on AlarmLevel. Only following values for the AlarmLevel are possible for this attribute: none - Everything is fine minor - Local end or remote end is experiencing problems, e.g. (1) loss of Cell Delineation is observed on the downstream direction. (2) subscriberDwnLineRate and lineDwnLineRate do not match. (3) subscriberUpLineRate and lineUpLineRate do not match. (4) Both Up/down line rates do not match with the subscriber requested rates. (5) loss of signal is observed in the downstream direction for DMT cards and the object subscriberDMTLOSConfig is configured to alarm this condition. (6) loss of frame is observed in the downstream direction for DMT cards. unknown - Remote end is non-reachable. This could be either due to power down at the CPE or due to break in the connection between C6200 system and the CPE. This is exhibited by the lineDMTUpLOS alarm.')
lineDwnSNRMargin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 2), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDwnSNRMargin.setStatus('current')
if mibBuilder.loadTexts: lineDwnSNRMargin.setDescription('In db, the difference between the current downstream signal to noise ratio and the SNR required for the selected line rate. as seen by the cpe. This object must be divided by 10 to obtain the real value for CAP only. Following are the possible values: Negative number - bad SNR margin for the desired line rate. 0 - adequate SNR (no margin) for the desired line rate. Positive number - Good SNR margin for the desired line rate. Higher number means better SNR margin and better line quality.')
lineDwnLOCD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 3), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDwnLOCD.setStatus('deprecated')
if mibBuilder.loadTexts: lineDwnLOCD.setDescription('Downstream loss of cell delineation. It indicates that the cpe received cells on the line do not contain a valid header error check (HEC). This object is no longer supported.')
lineDwnErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDwnErrSecs.setStatus('current')
if mibBuilder.loadTexts: lineDwnErrSecs.setDescription('Downstream count of errored seconds received by the cpe. An error second is a second with line quality problems due to a HEC error in CAP cards or CRC, LOS or SEF events in DMT cards.')
lineDwnLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 5), Gauge32()).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDwnLineRate.setStatus('current')
if mibBuilder.loadTexts: lineDwnLineRate.setDescription('Current downstream line rate in kbps. It is adapted by the line card using rate adaptation logic.')
lineUpSNRMargin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 6), Integer32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: lineUpSNRMargin.setStatus('current')
if mibBuilder.loadTexts: lineUpSNRMargin.setDescription('In db, the difference between the current upstream signal to noise ratio and the SNR required for the selected line rate as seen by the co. This object must be divided by 10 to obtain the real value for CAP only. Following are the possible values: Negative number - bad SNR margin for the desired line rate. 0 - adequate SNR (no margin) for the desired line rate. Positive number - Good SNR margin for the desired line rate. Higher number means better SNR margin and better line quality.')
lineUpLOCD = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 7), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineUpLOCD.setStatus('current')
if mibBuilder.loadTexts: lineUpLOCD.setDescription('Upstream loss of cell delineation. It indicates that the co received cells on the line do not contain a valid header error check (HEC). This alarm will be marked unknown if lineDMTDwnLPR, lineDMTUpLOS or lineDMTUpLOF on a DMT card are minor.')
lineUpErrSecs = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineUpErrSecs.setStatus('current')
if mibBuilder.loadTexts: lineUpErrSecs.setDescription('Upstream count of errored seconds recieved by the co. An error second is a second with line quality problems due to a HEC error. or CRC, LOS or SEF events in DMT cards.')
lineUpLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 9), Gauge32()).setUnits('kbps').setMaxAccess("readonly")
if mibBuilder.loadTexts: lineUpLineRate.setStatus('current')
if mibBuilder.loadTexts: lineUpLineRate.setDescription('Current upstream line rate in kbps. This is adapted by the line card using rate adaptation logic.')
lineRateAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ok", 1), ("down", 2), ("up", 3), ("downAndUp", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineRateAlarm.setStatus('current')
if mibBuilder.loadTexts: lineRateAlarm.setDescription('This parameter is the comparison between actual (lineDwnLineRate/ lineUpLineRate) and the user requested line rates (subscriberDwnLineRate/subscriberUpLineRate). User requested rates are part of the subscriber section of the MIB. Following is the list of possible values: 1 - both the line rates match user requested rates. 2 - Downstream line rate does not match user requested rate. 3 - Upstream line rate does not match user requested rate. 4 - Both rates do not match user requested rates.')
lineMode = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("testing", 1), ("training", 2), ("active", 3), ("down", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineMode.setStatus('current')
if mibBuilder.loadTexts: lineMode.setDescription('This parameter shows current mode of the line. The possible modes are as shown above. Normally line stays in active mode, if everything is fine. If the line test fails, it goes into training mode and tries to acquire next possible lower rate. The line can also go into the training mode when the line card is unable to communicate to the remote end. It does not come out of the training mode until it is able to acquire a user requested rate or a lower rate, if that is unattainable. This mode is changed by the system to down, when the subscriber line is administratively disabled.')
lineDMTDwnAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 12), Gauge32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTDwnAttenuation.setStatus('current')
if mibBuilder.loadTexts: lineDMTDwnAttenuation.setDescription('Measures downstream attenuation of the line reported by the CPE for the DMT card only. The units for this value are in decibels (dB). This object is instantiated for the CAP card.')
lineDMTUpAttenuation = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 13), Gauge32()).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTUpAttenuation.setStatus('current')
if mibBuilder.loadTexts: lineDMTUpAttenuation.setDescription('Measures upstream attenuation of the line reported by the CO for the DMT card only. The units for this value are in decibels (dB). This object is instantiated for the CAP card.')
lineDMTDwnLPR = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 14), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTDwnLPR.setStatus('current')
if mibBuilder.loadTexts: lineDMTDwnLPR.setDescription('Downstream loss of power indicator reported by the CPE for the DMT card only. Valid values are minor, unknown, or none. When this alarm is minor, lineUpLOS, lineUpLOF and lineUpLOCD are unknown. This object is instantiated for the CAP card.')
lineDMTUpLOS = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 15), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTUpLOS.setStatus('current')
if mibBuilder.loadTexts: lineDMTUpLOS.setDescription('Upstream loss of signal alarm indicator reported by the CO for the DMT card only. Valid values are minor or none. When this alarm is minor, lineDMTUpLOF and lineUpLOCD are unknown. This object is instantiated for the CAP card.')
lineDMTUpLOF = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 16), AlarmLevel()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTUpLOF.setStatus('current')
if mibBuilder.loadTexts: lineDMTUpLOF.setDescription('Upstream loss of frame alarm indicator reported by the CO for the DMT card only. Valid values are minor or none. When this alarm is minor, lineUpLOCD is unknown. This alarm value is unknown when lineDMTDwnLPR or lineDMTUpLOS is minor. This object is instantiated for the CAP card.')
lineDMTLoopback = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("dslline", 2), ("local", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineDMTLoopback.setStatus('current')
if mibBuilder.loadTexts: lineDMTLoopback.setDescription('DMT supported ATM layer loopback. dslline loops all ATM cells toward the CO modem back to the CPE. Local loops all ATM cells sent by the ATM trunk card toward the ATM trunk card. When this object is not set to none, lineMode will be set to testing. This object is instantiated for the CAP card.')
linePerfTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2), )
if mibBuilder.loadTexts: linePerfTable.setStatus('current')
if mibBuilder.loadTexts: linePerfTable.setDescription('This table contains line performance parameters. It contains one entry per subscriber line. Only the ATU-C (local) performance parameters are reported in this table.')
linePerfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1), ).setIndexNames((0, "CISCO-6200-MIB", "slotID"), (0, "CISCO-6200-MIB", "portID"))
if mibBuilder.loadTexts: linePerfEntry.setStatus('current')
if mibBuilder.loadTexts: linePerfEntry.setDescription('Each entry represents a performance parameter for the targeted subscriber line.')
lineTxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineTxCellCount.setStatus('current')
if mibBuilder.loadTexts: lineTxCellCount.setDescription('Total cell count in the downstream direction (ATU-C->ATU-R) reported by the CPE. The counter value does not include cells with uncorrectable HEC errors. This is a free running counter which rolls back to zero when the value exceeds 2^32.')
lineRxCellCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineRxCellCount.setStatus('current')
if mibBuilder.loadTexts: lineRxCellCount.setDescription('Total cell count in the upstream direction (ATU-R->ATU-C) reported by the CO. The counter value does not include cells with uncorrectable HEC errors. This is a free running counter which rolls back to zero when the value exceeds 2^32.')
lineHecErrCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineHecErrCount.setStatus('current')
if mibBuilder.loadTexts: lineHecErrCount.setDescription('Total HEC error count in the upstream (ATU-R->ATU-C) direction reported by the CO. This is a free running counter which rolls back to zero when the value exceeds 2^32.')
lineDMTDwnFECCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTDwnFECCount.setStatus('current')
if mibBuilder.loadTexts: lineDMTDwnFECCount.setDescription('Downstream count of forward error correction (FEC) events reported by the CPE for the DMT card only.')
lineDMTUpFECCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTUpFECCount.setStatus('current')
if mibBuilder.loadTexts: lineDMTUpFECCount.setDescription('Upstream count of forward error correction (FEC) events reported by the CO for the DMT card only. This object is instantiated for the CAP card.')
lineDMTDwnCRCCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTDwnCRCCount.setStatus('current')
if mibBuilder.loadTexts: lineDMTDwnCRCCount.setDescription('Downstream count of cyclical error correction (CRC) events reported by the CPE for the DMT card only. This object is instantiated for the CAP card.')
lineDMTUpCRCCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTUpCRCCount.setStatus('current')
if mibBuilder.loadTexts: lineDMTUpCRCCount.setDescription('Upstream count of cyclical error correction (CRC) events reported by the CO for the DMT card only. This object is instantiated for the CAP card.')
lineDMTDwnLOSCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTDwnLOSCount.setStatus('current')
if mibBuilder.loadTexts: lineDMTDwnLOSCount.setDescription('Downstream count of loss of signal (LOS) events reported by the CPE for the DMT card only. This object is instantiated for the CAP card.')
lineDMTUpLOSCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTUpLOSCount.setStatus('current')
if mibBuilder.loadTexts: lineDMTUpLOSCount.setDescription('Upstream count of loss of signal (LOS) events reported by the CO for the DMT card only. This object is instantiated for the CAP card.')
lineDMTDwnSEFCount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTDwnSEFCount.setStatus('current')
if mibBuilder.loadTexts: lineDMTDwnSEFCount.setDescription('Downstream count of severly errored frame (SEF) events reported by the CPE for the DMT card only. This object is instantiated for the CAP card.')
lineDMTUpRDICount = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineDMTUpRDICount.setStatus('current')
if mibBuilder.loadTexts: lineDMTUpRDICount.setDescription('Upstream count of remote defect indication (RDI) events reported by the CO for the DMT card only. This object is instantiated for the CAP card.')
lineTestTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3), )
if mibBuilder.loadTexts: lineTestTable.setStatus('current')
if mibBuilder.loadTexts: lineTestTable.setDescription('The Line test table contains the line test parameters per subscriber line. It controls access to the testing capabilities at the subscriber line level. This table contains an entry per subscriber line.')
lineTestEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1), ).setIndexNames((0, "CISCO-6200-MIB", "slotID"), (0, "CISCO-6200-MIB", "portID"))
if mibBuilder.loadTexts: lineTestEntry.setStatus('current')
if mibBuilder.loadTexts: lineTestEntry.setDescription('The entry describes the fields supported by the line test table.')
lineTestTrigger = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("stop", 1), ("start", 2), ("clear", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineTestTrigger.setStatus('current')
if mibBuilder.loadTexts: lineTestTrigger.setDescription('Starts or stops (aborts) a test in progress. The agent will only start a new test, if no test is active on the targeted port. The user must set lineTestTimeIntvl to an appropriate value before starting test by setting this parameter to start. The System resets the value back to stop when the test completes. This parameter value affects lineTestStatus as following: value current lineTestStatus new lineTestStatus ----- ---------------------- ------------------ start inactive/pass/fail/ active aborted stop active aborted clear pass/fail/aborted inactive The rest of the combinations will result in error. Starting of the test may fail due to a line test already in progress on the selected subscriber line. Agent updates lineTestStartTime, when it accepts the line test. Agent updates lineTestCmplTime, when the test completes or when user aborts the test. Stopping a test resets lineTestUpBitErrRate and lineTestDwnBitErrRate. Clearing a test resets lineTestStartTime, lineTestCmplTime, lineTestUpBitErrRate, and lineTestDwnBitErrRate to zero. lineTestTimeIntvl and lineTestBitErrRateLimit get set back to their defaults. Finally, lineTestStatus is set to inactive. Line test information only resets when the user sets this parameter to clear, otherwise parameters from the previous run of the test are preserved until system is rebooted. All of the parameters are initialized on reboot.')
lineTestType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 2), TestType()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineTestType.setStatus('current')
if mibBuilder.loadTexts: lineTestType.setDescription('The type of the test to be performed. If capHardware test is selected, time interval is determined by the system. Both the test types are destructive: affects the service on that line. The agent will only change lineTestType, if no test is active on the targeted port. For DMT cards, the DMTLocalTest is available. It is a destructive test that affects service on that line.')
lineTestTimeIntvl = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 60)).clone(30)).setUnits('minutes').setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineTestTimeIntvl.setStatus('current')
if mibBuilder.loadTexts: lineTestTimeIntvl.setDescription('Time interval in minutes between 0 - 60 minutes. This parameter is only meaningful, if test type is the line quality test. Default value is 30 minutes. The agent will only change lineTestTimeIntvl, if no test is active on the targeted port.')
lineTestStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 4), TestStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineTestStatus.setStatus('current')
if mibBuilder.loadTexts: lineTestStatus.setDescription('System changes values for this variable based on trigger value as well as based on system reported result. When test completes, system compares lineTestDwnBitErrRate and lineTestUpBitErrRate to lineTestBitErrRateLimit in order to determine whether the line test failed or passed. Agent sets this variable based on this comparison.')
lineTestDwnBitErrRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineTestDwnBitErrRate.setStatus('current')
if mibBuilder.loadTexts: lineTestDwnBitErrRate.setDescription('This is positive integer value representing a negative exponent of 10 for the error rate in the downstream direction. It is only meaningful when the line quality test is done on the affected subscriber line. It is compared against lineTestBitErrRateLimit to determine lineTestStatus value when the line quality test completes. This value is interpreted as following: < 10-7 - Bad line quality 10-7 - Acceptable line quality > 10-7 - Better line quality')
lineTestUpBitErrRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineTestUpBitErrRate.setStatus('current')
if mibBuilder.loadTexts: lineTestUpBitErrRate.setDescription('This is positive integer value representing a negative exponent of 10 for the error rate in the upstream direction. It is only meaningful when the line quality test is done on the affected subscriber line. It is compared against lineTestBitErrRateLimit to determine lineTestStatus value when the line quality test completes. This value is interpreted as following: < 10-7 - Bad line quality 10-7 - Acceptable line quality > 10-7 - Better line quality')
lineTestStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 7), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineTestStartTime.setStatus('current')
if mibBuilder.loadTexts: lineTestStartTime.setDescription('Time stamp in displayable format. This is the time when the system starts the requested test.')
lineTestCmplTime = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 8), DateAndTime()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lineTestCmplTime.setStatus('current')
if mibBuilder.loadTexts: lineTestCmplTime.setDescription('Time stamp in displayable format. This is the time when the system completes the requested test or when the user aborts the test.')
lineTestBitErrRateLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 4, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(3, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: lineTestBitErrRateLimit.setStatus('current')
if mibBuilder.loadTexts: lineTestBitErrRateLimit.setDescription('This is a positive integer representing a negative exponent of 10. It represents bit error rate limit allowed for the subscriber line quality test. The system compares the bit error rates reported at the end of line quality test to this limit to determine line quality. Allowable error rates are between 10-3 and 10-10. The agent will only change lineTestBitErrRateLimit, if no test is active on the targeted port.')
subscriberTable = MibTable((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5, 1), )
if mibBuilder.loadTexts: subscriberTable.setStatus('current')
if mibBuilder.loadTexts: subscriberTable.setDescription('The subscriber table contains configuration information per subscriber line. Non-assigned entries are identified by NULL string for the subscriber name. It contains provisionable information such as subscriber name, line rate and subscriber line state.. The subscriber provisioning request may fail, if the targeted subscriber line is under test. Changes to the subscriber information are temporary until user actually requests save operation through systemSaveCnfg. Only at that point system writes information in the NVRAM storage and information becomes permanent.')
subscriberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5, 1, 1), ).setIndexNames((0, "CISCO-6200-MIB", "slotID"), (0, "CISCO-6200-MIB", "portID"))
if mibBuilder.loadTexts: subscriberEntry.setStatus('current')
if mibBuilder.loadTexts: subscriberEntry.setDescription('The entry describes the fields being supported by the subscriber table.')
subscriberName = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 24)).clone('DSL<slotID>/<portID>')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subscriberName.setStatus('current')
if mibBuilder.loadTexts: subscriberName.setDescription('The subscriber Id, free format string field. First character can not be a space. Set this field to NULL string to delete a subscriber entry from the database. The delete operation will also disable the affected subscriber line. The system resets all the subscriber information such as subscriberUpLineRate, subscriberDwnLineRate, and subscriberLineState to default values on the delete or for non assigned entries.')
subscriberUpLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5, 1, 1, 2), Integer32()).setUnits('kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: subscriberUpLineRate.setStatus('current')
if mibBuilder.loadTexts: subscriberUpLineRate.setDescription('Desired maximum line rate. Actual rate may be lower following training sequence to acquire that rate. Refer to system features document for valid range. When this value is set to -1, system automatically adapts to maximum available rate. Following are the possible rates in kbps the CAP card: 1088, 952, 816, 680, 544, 408, 272 and 91. For the DMT card, the rates range from 64 Kbps to 1024 Kbps in increments of 32 Kbps.')
subscriberDwnLineRate = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5, 1, 1, 3), Integer32()).setUnits('kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: subscriberDwnLineRate.setStatus('current')
if mibBuilder.loadTexts: subscriberDwnLineRate.setDescription('Desired maximum line rate. Actual rate may be lower following training sequence to acquire that rate. Refer to system features document for valid range. When this value is set to -1, system automatically adapts to maximum possible rate. Following are the possible rates in kbps for the CAP card: 7168, 6272, 4480, 2688, 2560, 2240, 1920, 1600, 1280, 960 and 640. For the DMT card, the rates range from 64 Kbps to 8168 Kbps in increments of 32 Kbps.')
subscriberLineState = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5, 1, 1, 4), InterfaceStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subscriberLineState.setStatus('current')
if mibBuilder.loadTexts: subscriberLineState.setDescription('This parameter reflects current state of the subscriber line. It allows targeted subscriber line to be enabled or disabled. Disabling the line cuts off services to the affected subscriber. All the empty lines are disabled by the system. User deletion, by setting subscriberName to NULL, also results in disabling of the line.')
subscriberDMTLOSConfig = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 10, 26, 1, 5, 1, 1, 5), InterfaceStatus().clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: subscriberDMTLOSConfig.setStatus('current')
if mibBuilder.loadTexts: subscriberDMTLOSConfig.setDescription('This value determines whether or not the LOS condition on the subscriber line generates a minor alarm. By default, this value is set to disabled which means that an alarm is not generated when LOS is detected on the subscriber line.')
ciscoC6200MIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 2))
ciscoC6200MIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 1))
ciscoC6200MIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2))
ciscoC6200MIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 1, 1)).setObjects(("CISCO-6200-MIB", "ciscoC6200SystemGroup"), ("CISCO-6200-MIB", "ciscoC6200SlotGroup"), ("CISCO-6200-MIB", "ciscoC6200oCIGroup"), ("CISCO-6200-MIB", "ciscoC6200oCIPerfGroup"), ("CISCO-6200-MIB", "ciscoC6200lineGroup"), ("CISCO-6200-MIB", "ciscoC6200lineTestGroup"), ("CISCO-6200-MIB", "ciscoC6200linePerfGroup"), ("CISCO-6200-MIB", "ciscoC6200subscriberGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200MIBCompliance = ciscoC6200MIBCompliance.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200MIBCompliance.setDescription('The compliance statement for entities which implement the Cisco C6200 MIB. This device-specific MIB will be implemented only by members of the C6200 product line.')
ciscoC6200MIBCompliance2 = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 1, 2)).setObjects(("CISCO-6200-MIB", "ciscoC6200SystemGroup2"), ("CISCO-6200-MIB", "ciscoC6200SlotGroup2"), ("CISCO-6200-MIB", "ciscoC6200oCIGroup2"), ("CISCO-6200-MIB", "ciscoC6200oCIPerfGroup2"), ("CISCO-6200-MIB", "ciscoC6200lineGroup2"), ("CISCO-6200-MIB", "ciscoC6200lineTestGroup2"), ("CISCO-6200-MIB", "ciscoC6200linePerfGroup2"), ("CISCO-6200-MIB", "ciscoC6200subscriberGroup2"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200MIBCompliance2 = ciscoC6200MIBCompliance2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200MIBCompliance2.setDescription('The compliance statement for entities which implement the Cisco C6200 MIB. This device-specific MIB will be implemented only by members of the C6200 product line. This compliance takes effect from IOS Release 11.3(1)DA3.')
ciscoC6200SystemGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 1)).setObjects(("CISCO-6200-MIB", "systemType"), ("CISCO-6200-MIB", "systemAlarmLevel"), ("CISCO-6200-MIB", "systemAlarmLevelChngCounter"), ("CISCO-6200-MIB", "systemReset"), ("CISCO-6200-MIB", "systemSaveCnfg"), ("CISCO-6200-MIB", "systemProvChngCounter"), ("CISCO-6200-MIB", "systemHClockAlarmLevel"), ("CISCO-6200-MIB", "systemFanAlarmLevel"), ("CISCO-6200-MIB", "systemTemperatureAlarmLevel"), ("CISCO-6200-MIB", "systemACO"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200SystemGroup = ciscoC6200SystemGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200SystemGroup.setDescription('System-level information for a C6200 device.')
ciscoC6200SlotGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 2)).setObjects(("CISCO-6200-MIB", "slotType"), ("CISCO-6200-MIB", "slotStatus"), ("CISCO-6200-MIB", "slotSwVersion"), ("CISCO-6200-MIB", "slotAlarmLevelChngCounter"), ("CISCO-6200-MIB", "slotCnfType"), ("CISCO-6200-MIB", "slotSubscriberChngCounter"), ("CISCO-6200-MIB", "slotAlarmLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200SlotGroup = ciscoC6200SlotGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200SlotGroup.setDescription('Slot-level information for a C6200 device.')
ciscoC6200oCIGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 3)).setObjects(("CISCO-6200-MIB", "oCIAlarmLevel"), ("CISCO-6200-MIB", "oCIEQF"), ("CISCO-6200-MIB", "oCILOS"), ("CISCO-6200-MIB", "oCILOF"), ("CISCO-6200-MIB", "oCILAIS"), ("CISCO-6200-MIB", "oCILOP"), ("CISCO-6200-MIB", "oCIPAIS"), ("CISCO-6200-MIB", "oCISLM"), ("CISCO-6200-MIB", "oCILRFI"), ("CISCO-6200-MIB", "oCIPRFI"), ("CISCO-6200-MIB", "oCILOST"), ("CISCO-6200-MIB", "oCILOCD"), ("CISCO-6200-MIB", "oCILoopMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200oCIGroup = ciscoC6200oCIGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200oCIGroup.setDescription('NTC information for a C6200 device.')
ciscoC6200oCIPerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 4)).setObjects(("CISCO-6200-MIB", "oCPTxCellCount"), ("CISCO-6200-MIB", "oCPRxCellCount"), ("CISCO-6200-MIB", "oCPHecErrCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200oCIPerfGroup = ciscoC6200oCIPerfGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200oCIPerfGroup.setDescription('NTC performance information for a C6200 device.')
ciscoC6200lineGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 5)).setObjects(("CISCO-6200-MIB", "lineAlarmLevel"), ("CISCO-6200-MIB", "lineDwnSNRMargin"), ("CISCO-6200-MIB", "lineDwnLOCD"), ("CISCO-6200-MIB", "lineDwnErrSecs"), ("CISCO-6200-MIB", "lineDwnLineRate"), ("CISCO-6200-MIB", "lineUpSNRMargin"), ("CISCO-6200-MIB", "lineUpLOCD"), ("CISCO-6200-MIB", "lineUpErrSecs"), ("CISCO-6200-MIB", "lineUpLineRate"), ("CISCO-6200-MIB", "lineRateAlarm"), ("CISCO-6200-MIB", "lineMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200lineGroup = ciscoC6200lineGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200lineGroup.setDescription('Line-level information for a C6200 device.')
ciscoC6200linePerfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 6)).setObjects(("CISCO-6200-MIB", "lineTxCellCount"), ("CISCO-6200-MIB", "lineRxCellCount"), ("CISCO-6200-MIB", "lineHecErrCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200linePerfGroup = ciscoC6200linePerfGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200linePerfGroup.setDescription('Line-level performance information for a C6200 device.')
ciscoC6200lineTestGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 7)).setObjects(("CISCO-6200-MIB", "lineTestTrigger"), ("CISCO-6200-MIB", "lineTestType"), ("CISCO-6200-MIB", "lineTestTimeIntvl"), ("CISCO-6200-MIB", "lineTestStatus"), ("CISCO-6200-MIB", "lineTestDwnBitErrRate"), ("CISCO-6200-MIB", "lineTestUpBitErrRate"), ("CISCO-6200-MIB", "lineTestStartTime"), ("CISCO-6200-MIB", "lineTestCmplTime"), ("CISCO-6200-MIB", "lineTestBitErrRateLimit"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200lineTestGroup = ciscoC6200lineTestGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200lineTestGroup.setDescription('Line-level test information for a C6200 device.')
ciscoC6200subscriberGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 8)).setObjects(("CISCO-6200-MIB", "subscriberName"), ("CISCO-6200-MIB", "subscriberUpLineRate"), ("CISCO-6200-MIB", "subscriberDwnLineRate"), ("CISCO-6200-MIB", "subscriberLineState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200subscriberGroup = ciscoC6200subscriberGroup.setStatus('obsolete')
if mibBuilder.loadTexts: ciscoC6200subscriberGroup.setDescription('Subscriber-level information for a C6200 device.')
ciscoC6200SystemGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 9)).setObjects(("CISCO-6200-MIB", "systemType"), ("CISCO-6200-MIB", "systemAlarmLevel"), ("CISCO-6200-MIB", "systemAlarmLevelChngCounter"), ("CISCO-6200-MIB", "systemReset"), ("CISCO-6200-MIB", "systemSaveCnfg"), ("CISCO-6200-MIB", "systemProvChngCounter"), ("CISCO-6200-MIB", "systemHClockAlarmLevel"), ("CISCO-6200-MIB", "systemFanAlarmLevel"), ("CISCO-6200-MIB", "systemTemperatureAlarmLevel"), ("CISCO-6200-MIB", "systemACO"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200SystemGroup2 = ciscoC6200SystemGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200SystemGroup2.setDescription('System-level information for a C6200 device.')
ciscoC6200SlotGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 10)).setObjects(("CISCO-6200-MIB", "slotType"), ("CISCO-6200-MIB", "slotStatus"), ("CISCO-6200-MIB", "slotSwVersion"), ("CISCO-6200-MIB", "slotAlarmLevelChngCounter"), ("CISCO-6200-MIB", "slotCnfType"), ("CISCO-6200-MIB", "slotSubscriberChngCounter"), ("CISCO-6200-MIB", "slotAlarmLevel"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200SlotGroup2 = ciscoC6200SlotGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200SlotGroup2.setDescription('Slot-level information for a C6200 device.')
ciscoC6200oCIGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 11)).setObjects(("CISCO-6200-MIB", "oCIAlarmLevel"), ("CISCO-6200-MIB", "oCIEQF"), ("CISCO-6200-MIB", "oCILOS"), ("CISCO-6200-MIB", "oCILOF"), ("CISCO-6200-MIB", "oCILAIS"), ("CISCO-6200-MIB", "oCILOP"), ("CISCO-6200-MIB", "oCIPAIS"), ("CISCO-6200-MIB", "oCISLM"), ("CISCO-6200-MIB", "oCILRFI"), ("CISCO-6200-MIB", "oCIPRFI"), ("CISCO-6200-MIB", "oCILOST"), ("CISCO-6200-MIB", "oCILOCD"), ("CISCO-6200-MIB", "oCILoopMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200oCIGroup2 = ciscoC6200oCIGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200oCIGroup2.setDescription('NTC information for a C6200 device.')
ciscoC6200oCIPerfGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 12)).setObjects(("CISCO-6200-MIB", "oCPTxCellCount"), ("CISCO-6200-MIB", "oCPRxCellCount"), ("CISCO-6200-MIB", "oCPHecErrCount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200oCIPerfGroup2 = ciscoC6200oCIPerfGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200oCIPerfGroup2.setDescription('NTC performance information for a C6200 device.')
ciscoC6200lineGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 13)).setObjects(("CISCO-6200-MIB", "lineAlarmLevel"), ("CISCO-6200-MIB", "lineDwnSNRMargin"), ("CISCO-6200-MIB", "lineDwnErrSecs"), ("CISCO-6200-MIB", "lineDwnLineRate"), ("CISCO-6200-MIB", "lineUpSNRMargin"), ("CISCO-6200-MIB", "lineUpLOCD"), ("CISCO-6200-MIB", "lineUpErrSecs"), ("CISCO-6200-MIB", "lineUpLineRate"), ("CISCO-6200-MIB", "lineRateAlarm"), ("CISCO-6200-MIB", "lineMode"), ("CISCO-6200-MIB", "lineDMTDwnAttenuation"), ("CISCO-6200-MIB", "lineDMTUpAttenuation"), ("CISCO-6200-MIB", "lineDMTDwnLPR"), ("CISCO-6200-MIB", "lineDMTUpLOS"), ("CISCO-6200-MIB", "lineDMTUpLOF"), ("CISCO-6200-MIB", "lineDMTLoopback"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200lineGroup2 = ciscoC6200lineGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200lineGroup2.setDescription('Line-level information for a C6200 device.')
ciscoC6200linePerfGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 14)).setObjects(("CISCO-6200-MIB", "lineTxCellCount"), ("CISCO-6200-MIB", "lineRxCellCount"), ("CISCO-6200-MIB", "lineHecErrCount"), ("CISCO-6200-MIB", "lineDMTDwnFECCount"), ("CISCO-6200-MIB", "lineDMTUpFECCount"), ("CISCO-6200-MIB", "lineDMTDwnCRCCount"), ("CISCO-6200-MIB", "lineDMTUpCRCCount"), ("CISCO-6200-MIB", "lineDMTDwnLOSCount"), ("CISCO-6200-MIB", "lineDMTUpLOSCount"), ("CISCO-6200-MIB", "lineDMTDwnSEFCount"), ("CISCO-6200-MIB", "lineDMTUpRDICount"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200linePerfGroup2 = ciscoC6200linePerfGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200linePerfGroup2.setDescription('Line-level performance information for a C6200 device.')
ciscoC6200lineTestGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 15)).setObjects(("CISCO-6200-MIB", "lineTestTrigger"), ("CISCO-6200-MIB", "lineTestType"), ("CISCO-6200-MIB", "lineTestTimeIntvl"), ("CISCO-6200-MIB", "lineTestStatus"), ("CISCO-6200-MIB", "lineTestDwnBitErrRate"), ("CISCO-6200-MIB", "lineTestUpBitErrRate"), ("CISCO-6200-MIB", "lineTestStartTime"), ("CISCO-6200-MIB", "lineTestCmplTime"), ("CISCO-6200-MIB", "lineTestBitErrRateLimit"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200lineTestGroup2 = ciscoC6200lineTestGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200lineTestGroup2.setDescription('Line-level test information for a C6200 device.')
ciscoC6200subscriberGroup2 = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 10, 26, 2, 2, 16)).setObjects(("CISCO-6200-MIB", "subscriberName"), ("CISCO-6200-MIB", "subscriberUpLineRate"), ("CISCO-6200-MIB", "subscriberDwnLineRate"), ("CISCO-6200-MIB", "subscriberLineState"), ("CISCO-6200-MIB", "subscriberDMTLOSConfig"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ciscoC6200subscriberGroup2 = ciscoC6200subscriberGroup2.setStatus('current')
if mibBuilder.loadTexts: ciscoC6200subscriberGroup2.setDescription('Subscriber-level information for a C6200 device.')
mibBuilder.exportSymbols("CISCO-6200-MIB", lineDMTDwnSEFCount=lineDMTDwnSEFCount, slotSubscriberChngCounter=slotSubscriberChngCounter, c62Subscriber=c62Subscriber, PYSNMP_MODULE_ID=cisco6200MIB, oCILOP=oCILOP, lineAlarmLevel=lineAlarmLevel, oCPHecErrCount=oCPHecErrCount, lineDMTUpLOF=lineDMTUpLOF, slotSwVersion=slotSwVersion, lineTestDwnBitErrRate=lineTestDwnBitErrRate, subscriberUpLineRate=subscriberUpLineRate, oCILAIS=oCILAIS, ciscoC6200linePerfGroup2=ciscoC6200linePerfGroup2, systemHClockAlarmLevel=systemHClockAlarmLevel, linePerfEntry=linePerfEntry, ciscoC6200lineTestGroup=ciscoC6200lineTestGroup, lineDMTDwnFECCount=lineDMTDwnFECCount, lineDMTDwnCRCCount=lineDMTDwnCRCCount, slotStatus=slotStatus, lineTestTrigger=lineTestTrigger, lineDwnLineRate=lineDwnLineRate, ciscoC6200MIBGroups=ciscoC6200MIBGroups, oCILOF=oCILOF, ciscoC6200subscriberGroup2=ciscoC6200subscriberGroup2, oCILOS=oCILOS, oCILoopMode=oCILoopMode, lineMode=lineMode, oCILOST=oCILOST, ciscoC6200lineGroup=ciscoC6200lineGroup, systemFanAlarmLevel=systemFanAlarmLevel, ciscoC6200oCIPerfGroup=ciscoC6200oCIPerfGroup, lineUpLineRate=lineUpLineRate, ciscoC6200oCIPerfGroup2=ciscoC6200oCIPerfGroup2, lineDMTUpCRCCount=lineDMTUpCRCCount, cisco6200MIB=cisco6200MIB, TestStatus=TestStatus, subscriberName=subscriberName, cisco6200MibObjects=cisco6200MibObjects, lineDMTDwnLPR=lineDMTDwnLPR, lineRxCellCount=lineRxCellCount, C6200CardType=C6200CardType, slotAlarmLevelChngCounter=slotAlarmLevelChngCounter, systemAlarmLevelChngCounter=systemAlarmLevelChngCounter, subscriberDwnLineRate=subscriberDwnLineRate, lineInterfaceTable=lineInterfaceTable, c62LineInterface=c62LineInterface, slotCnfType=slotCnfType, lineInterfaceEntry=lineInterfaceEntry, subscriberTable=subscriberTable, lineTestTimeIntvl=lineTestTimeIntvl, ciscoC6200MIBConformance=ciscoC6200MIBConformance, InterfaceStatus=InterfaceStatus, lineDMTDwnAttenuation=lineDMTDwnAttenuation, TestType=TestType, oCPRxCellCount=oCPRxCellCount, oCPTxCellCount=oCPTxCellCount, lineDwnSNRMargin=lineDwnSNRMargin, lineTestUpBitErrRate=lineTestUpBitErrRate, oCInterfaceEntry=oCInterfaceEntry, systemSaveCnfg=systemSaveCnfg, ciscoC6200lineTestGroup2=ciscoC6200lineTestGroup2, ciscoC6200MIBCompliance2=ciscoC6200MIBCompliance2, lineDMTLoopback=lineDMTLoopback, oCIEQF=oCIEQF, slotID=slotID, lineUpLOCD=lineUpLOCD, oCPerfTable=oCPerfTable, systemACO=systemACO, lineDwnLOCD=lineDwnLOCD, lineTestEntry=lineTestEntry, oCInterfaceTable=oCInterfaceTable, lineTestType=lineTestType, AlarmLevel=AlarmLevel, systemReset=systemReset, oCIPAIS=oCIPAIS, systemTemperatureAlarmLevel=systemTemperatureAlarmLevel, oCIPRFI=oCIPRFI, lineRateAlarm=lineRateAlarm, oCILRFI=oCILRFI, lineUpErrSecs=lineUpErrSecs, subscriberEntry=subscriberEntry, lineDMTDwnLOSCount=lineDMTDwnLOSCount, ciscoC6200linePerfGroup=ciscoC6200linePerfGroup, slotAlarmLevel=slotAlarmLevel, oCISLM=oCISLM, slotEntry=slotEntry, c62OCInterface=c62OCInterface, ciscoC6200oCIGroup=ciscoC6200oCIGroup, slotTable=slotTable, ciscoC6200SystemGroup2=ciscoC6200SystemGroup2, linePerfTable=linePerfTable, subscriberLineState=subscriberLineState, lineHecErrCount=lineHecErrCount, subscriberDMTLOSConfig=subscriberDMTLOSConfig, ciscoC6200MIBCompliances=ciscoC6200MIBCompliances, lineTxCellCount=lineTxCellCount, lineDMTUpFECCount=lineDMTUpFECCount, ciscoC6200MIBCompliance=ciscoC6200MIBCompliance, lineTestTable=lineTestTable, lineTestBitErrRateLimit=lineTestBitErrRateLimit, c62System=c62System, c62Slot=c62Slot, systemProvChngCounter=systemProvChngCounter, lineTestStatus=lineTestStatus, lineDwnErrSecs=lineDwnErrSecs, CommandValue=CommandValue, lineDMTUpAttenuation=lineDMTUpAttenuation, ciscoC6200SlotGroup=ciscoC6200SlotGroup, ciscoC6200oCIGroup2=ciscoC6200oCIGroup2, systemAlarmLevel=systemAlarmLevel, oCILOCD=oCILOCD, lineTestCmplTime=lineTestCmplTime, ciscoC6200SystemGroup=ciscoC6200SystemGroup, ciscoC6200SlotGroup2=ciscoC6200SlotGroup2, lineUpSNRMargin=lineUpSNRMargin, lineTestStartTime=lineTestStartTime, ciscoC6200subscriberGroup=ciscoC6200subscriberGroup, systemType=systemType, ciscoC6200lineGroup2=ciscoC6200lineGroup2, slotType=slotType, oCPerfEntry=oCPerfEntry, lineDMTUpLOS=lineDMTUpLOS, oCIAlarmLevel=oCIAlarmLevel, lineDMTUpLOSCount=lineDMTUpLOSCount, lineDMTUpRDICount=lineDMTUpRDICount, portID=portID)

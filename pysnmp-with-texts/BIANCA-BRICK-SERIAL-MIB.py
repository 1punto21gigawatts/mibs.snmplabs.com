#
# PySNMP MIB module BIANCA-BRICK-SERIAL-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/BIANCA-BRICK-SERIAL-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:38:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint", "SingleValueConstraint", "ConstraintsUnion")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Unsigned32, Counter64, ObjectIdentity, Integer32, Counter32, TimeTicks, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, Bits, MibIdentifier, Gauge32, NotificationType, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Counter64", "ObjectIdentity", "Integer32", "Counter32", "TimeTicks", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "Bits", "MibIdentifier", "Gauge32", "NotificationType", "iso")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
org = MibIdentifier((1, 3))
dod = MibIdentifier((1, 3, 6))
internet = MibIdentifier((1, 3, 6, 1))
private = MibIdentifier((1, 3, 6, 1, 4))
enterprises = MibIdentifier((1, 3, 6, 1, 4, 1))
bintec = MibIdentifier((1, 3, 6, 1, 4, 1, 272))
bibo = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4))
serial = MibIdentifier((1, 3, 6, 1, 4, 1, 272, 4, 25))
class Date(Integer32):
    pass

class HexValue(Integer32):
    pass

serialIfTable = MibTable((1, 3, 6, 1, 4, 1, 272, 4, 25, 1), )
if mibBuilder.loadTexts: serialIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfTable.setDescription('The serialIfTable contains information relating to the interfaces available on the system. Each entry corresponds to an available serial interface. Entries cannot be added or deleted by the user. Creating entries: Entries are created by the system automatically when a new serial module is installed. Deleting entries: Entries are removed by the system after the appropriate serial module is removed.')
serialIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1), ).setIndexNames((0, "BIANCA-BRICK-SERIAL-MIB", "serialIfIndex"))
if mibBuilder.loadTexts: serialIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfEntry.setDescription('')
serialIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfIndex.setDescription('Unique interface index of the serial interface.')
serialIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("x21", 2), ("v35", 3), ("v36", 4), ("x21bis", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialIfType.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfType.setDescription('The serial physical interface type none(1) interface disabled x21(2) X.21/V11 (synchronous) v35(3) V.35/V11 (synchronous) v36(4) V.36/V11 (synchronous) x21bis(5) RS232/V.28 (synchronous)')
serialIfConnector = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialIfConnector.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfConnector.setDescription('The physical connector type. When configured as DCE the pins on the output connector act as a DCE interface. If configured as DTE on the output connector act as a DTE interface. dte(1) DTE output pins dce(2) DCE output pins ')
serialIfLeads = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialIfLeads.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfLeads.setDescription('The value of IfLeads has influence on the state of the physical layer (L1State). When configured as IfLeads=enabled, the state of the physical layer depends on the signals of the control interface pins Indication/Control on X.21 or RTS/CTS on the other protocols. When configured as IfLeads=disabled, the state of the physical layer stays always up. enabled(1) interface pins accepted. disabled(2) ignore interface pins.')
serialIfClock = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("extern", 2), ("intern", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialIfClock.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfClock.setDescription('The physical layer (layer 1) clocking mode. When configured as AUTO the clock provided depends what is configured on connector. If connector is configured as DTE clock must provided from external, if the connector is configured as DCE clock is generated and is provided at the output pins. It is possible to configure the clock independed from connector type. EXTERNAL clock means the clock must provided by the external device and INTERNAL clock means the clock is generated by the brick and is provided on the output pins. X.21 on clock line is provided. V.35/V.36 two clock lines are provided. auto(1) connector = DTE = extern, DCE = intern extern(2) clock pins operate as input. intern(3) clock pins operate as output.')
serialIfSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialIfSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfSpeed.setDescription('The serial interface speed in bits per second. The range is dependant on the type of the line (balanced/unbalanced) and the quality and length of the cable. Over a short distance (about 5 m) and with a shielded cable speeds of up to 8 Mbit/sec are possible.')
serialIfL2Mode = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("dte", 1), ("dce", 2), ("auto", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: serialIfL2Mode.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfL2Mode.setDescription('The layer 2 mode. This value has influence on the HDLC address field (first byte of a HDCL frame). When configured as DTE the address in a command frame is 0x01, when configured as DCE it is 0x03. For response frames it is vice versa. When configured as AUTO, layer 2 is set to the same as connector is set. dte(1) HDLC address 0x01 dce(2) HDLC address 0x03 auto(3) same as conector = DTE=0x01 DCE=0x03')
serialIfL1State = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("dn", 1), ("up", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfL1State.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfL1State.setDescription('The serial physical layer state dn(1) physical layer is inactive up(2) physical layer is active')
serialIfSpeedReal = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfSpeedReal.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfSpeedReal.setDescription('In DCE/internal clock mode this is the rounded speed in bits per second, because not every baudrate can exactly be generated. In DTE/external clock mode this is the measured speed, where measurement is possible, or the configured speed in serialIfSpeed.')
serialIfRxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfRxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfRxPackets.setDescription('Count of received valid Frames.')
serialIfRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfRxOctets.setDescription('Count of received bytes.')
serialIfTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfTxPackets.setDescription('Count of transmitted valid Frames.')
serialIfTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfTxOctets.setDescription('Count of transmitted bytes.')
serialIfRxResets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfRxResets.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfRxResets.setDescription('Count of receiver resets. Under rare circumstances it might be necessary to reset the receiver to work properly.')
serialIfRxAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfRxAborts.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfRxAborts.setDescription('Count of receiver aborts. The sender of a frame can indicate a frame as aborted with a special Abort sequence.')
serialIfRxOverruns = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfRxOverruns.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfRxOverruns.setDescription('Count of receiver overruns. If the serial port is unable to grant sufficiently soon/often the bus, the RxFIFO may fill up. This leads to loss of data.')
serialIfRxCRCErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfRxCRCErrors.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfRxCRCErrors.setDescription('Count of corrupted frames. Errors due to interference on the serial cable.')
serialIfRxGiantFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfRxGiantFrames.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfRxGiantFrames.setDescription('Count of received frames with illegal framesize. This can occur if a frame delimiter is destroyed.')
serialIfTxResets = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfTxResets.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfTxResets.setDescription('Count of transmitter resets. Under rare circumstances it might be necessary to reset the transmitter to work properly.')
serialIfTxAborts = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfTxAborts.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfTxAborts.setDescription('Count of transmitter aborts. While sending a frame it might be necessary to indicate this frame as aborted. In this case the receiver regards this frame as illegal.')
serialIfTxUnderruns = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfTxUnderruns.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfTxUnderruns.setDescription('Count of transmitter underruns. The serial data for the serial port is supplied too slowly.')
serialIfTxGiantFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 272, 4, 25, 1, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: serialIfTxGiantFrames.setStatus('mandatory')
if mibBuilder.loadTexts: serialIfTxGiantFrames.setDescription('Count of transmitted frames with illegal framesize. This can occur if an upper module creates packets with more than the maximum allowed packet size.')
mibBuilder.exportSymbols("BIANCA-BRICK-SERIAL-MIB", HexValue=HexValue, serialIfTable=serialIfTable, serialIfL1State=serialIfL1State, serialIfSpeed=serialIfSpeed, serialIfRxAborts=serialIfRxAborts, bintec=bintec, org=org, enterprises=enterprises, private=private, dod=dod, serialIfL2Mode=serialIfL2Mode, serialIfRxResets=serialIfRxResets, serialIfEntry=serialIfEntry, serialIfTxUnderruns=serialIfTxUnderruns, serialIfTxGiantFrames=serialIfTxGiantFrames, serialIfType=serialIfType, serialIfTxOctets=serialIfTxOctets, serialIfIndex=serialIfIndex, serialIfRxOverruns=serialIfRxOverruns, serialIfTxAborts=serialIfTxAborts, serialIfRxCRCErrors=serialIfRxCRCErrors, bibo=bibo, serial=serial, serialIfLeads=serialIfLeads, Date=Date, serialIfRxGiantFrames=serialIfRxGiantFrames, serialIfRxPackets=serialIfRxPackets, serialIfRxOctets=serialIfRxOctets, serialIfTxResets=serialIfTxResets, serialIfSpeedReal=serialIfSpeedReal, serialIfTxPackets=serialIfTxPackets, internet=internet, serialIfConnector=serialIfConnector, serialIfClock=serialIfClock)

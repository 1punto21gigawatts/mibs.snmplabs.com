#
# PySNMP MIB module EFM-CU-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/EFM-CU-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:59:36 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "ConstraintsIntersection")
InterfaceIndex, ifIndex, ifSpeed = mibBuilder.importSymbols("IF-MIB", "InterfaceIndex", "ifIndex", "ifSpeed")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, ObjectGroup, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "ObjectGroup", "NotificationGroup")
Gauge32, Counter32, Integer32, Unsigned32, mib_2, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, ObjectIdentity, Bits, Counter64, iso, ModuleIdentity, MibIdentifier, NotificationType, TimeTicks = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "Counter32", "Integer32", "Unsigned32", "mib-2", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ObjectIdentity", "Bits", "Counter64", "iso", "ModuleIdentity", "MibIdentifier", "NotificationType", "TimeTicks")
TruthValue, DisplayString, PhysAddress, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "TruthValue", "DisplayString", "PhysAddress", "RowStatus", "TextualConvention")
ietfDrafts, = mibBuilder.importSymbols("Zhone", "ietfDrafts")
efmCuMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7))
efmCuMIB.setRevisions(('2012-06-29 00:00', '2005-04-04 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: efmCuMIB.setRevisionsDescriptions(('Added SHDSL Regenerator Statistics.', 'Initial version, published as RFC XXXX.',))
if mibBuilder.loadTexts: efmCuMIB.setLastUpdated('200504040000Z')
if mibBuilder.loadTexts: efmCuMIB.setOrganization('IETF Ethernet Interfaces and Hub MIB Working Group')
if mibBuilder.loadTexts: efmCuMIB.setContactInfo('WG charter: http://www.ietf.org/html.charters/hubmib-charter.html Mailing Lists: General Discussion: hubmib@ietf.org To Subscribe: hubmib-request@ietf.org In Body: subscribe your_email_address Chair: Dan Romascanu Postal: Avaya Atidim Technology Park, Bldg. 3 Tel Aviv 61131 Israel Tel: +972 3 645 8414 E-mail: dromasca@avaya.com Editor: Edward Beili Postal: Actelis Networks Inc. 25 Bazel St., P.O.B. 10173 Petach-Tikva 10173 Israel Tel: +972-3-924-3491 E-mail: edward.beili@actelis.com')
if mibBuilder.loadTexts: efmCuMIB.setDescription("The objects in this MIB module are used to manage the Ethernet in the First Mile (EFM) Copper (EFMCu) Interfaces 2BASE-TL and 10PASS-TS, defined in IEEE Draft P802.3ah/D3.3. The following reference is used throughout this MIB module: [802.3ah] refers to: IEEE Std 802.3ah-2004: 'IEEE Standard for Information technology - Telecommunications and information exchange between systems - Local and metropolitan area networks - Specific requirements - Part 3: Carrier Sense Multiple Access with Collision Detection (CSMA/CD) Access Method and Physical Layer Specifications - Amendment: Media Access Control Parameters, Physical Layers and Management Parameters for Subscriber Access Networks', 07 September 2004. Of particular interest are Clause 61, 'Physical Coding Sublayer (PCS) and common specifications, type 10PASS-TS and type 2BASE-TL', Clause 30, 'Management', Clause 45, 'Management Data Input/Output (MDIO) Interface', Annex 62A, 'PMD profiles for 10PASS-TS' and Annex 63A, 'PMD profiles for 2BASE-TL'. Naming Conventions: Atn - Attenuation CO - Central Office CPE - Customer Premises Equipment EFM - Ethernet in the First Mile EFMCu - EFM Copper MDIO - Management Data Input/Output Mgn - Margin PAF - PME Aggregation Function PCS - Physical Coding Sublayer PMD - Physical Medium Dependent PME - Physical Medium Entity PSD - Power Spectral Density SNR - Signal to Noise Ratio TCPAM - Trellis Coded Pulse Amplitude Modulation Copyright (C) The Internet Society (2004). This version of this MIB module is part of RFC XXXX; see the RFC itself for full legal notices.")
efmCuObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1))
efmCuConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2))
efmCuPort = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1))
efmCuPme = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2))
class ProfileIndex(TextualConvention, Unsigned32):
    description = "A unique value, greater than zero, for each PME configuration profile in the managed EFMCu port. It is recommended that values are assigned contiguously starting from 1. The value for each profile must remain constant at least from one re-initialization of the entity's network management system to the next re-initialization."
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(1, 255)

class ProfileIndexOrZero(TextualConvention, Unsigned32):
    description = 'This textual convention is an extension of the ProfileIndex convention. The latter defines a greater than zero value used to identify a PME profile in the managed EFMCu port. This extension permits the additional value of zero. The value of zero is object-specific and must therefore be defined as part of the description of any object which uses this syntax. Examples of the usage of zero value migh include situations where current operational profile is unknown.'
    status = 'current'
    displayHint = 'd'
    subtypeSpec = Unsigned32.subtypeSpec + ValueRangeConstraint(0, 255)

class ProfileIndexList(TextualConvention, OctetString):
    description = "Represents a list of up to 6 ProfileIndex's. The ProfileIndex textual convention defines a greater than zero value used to identify a PME profile in the managed EFMCu port. The value of this object is a concatenation of one or more (up to 6) octets, where each octet contains an 8-bit ProfileIndex value. The ProfileIndexList specifies a list of alternative profiles, any of which can be chosen for configuration of an PME."
    status = 'current'
    displayHint = '1d:'
    subtypeSpec = OctetString.subtypeSpec + ValueSizeConstraint(1, 6)

class TruthValueOrUnknown(TextualConvention, Integer32):
    description = 'This textual convention is an extension of the TruthValue convention. The latter defines a boolean value with possible values of true(1) and false(2). This extension permits the additional value of unknown(0), which can be returned as a result of GET operation, when an exact true or false value of the object cannot be determined.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2))
    namedValues = NamedValues(("unknown", 0), ("true", 1), ("false", 2))

efmCuPortNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 0))
efmCuLowBandwidth = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 0, 1)).setObjects(("IF-MIB", "ifSpeed"), ("EFM-CU-MIB", "efmCuThreshLowBandwidth"))
if mibBuilder.loadTexts: efmCuLowBandwidth.setStatus('current')
if mibBuilder.loadTexts: efmCuLowBandwidth.setDescription("This notification indicates that EFMCu port's data rate reached or dropped below a Low Bandwidth Threshold (i.e. bandwidth degradation happening in case of PAF when one or more PMEs drop).")
efmCuPortConfTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1), )
if mibBuilder.loadTexts: efmCuPortConfTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPortConfTable.setDescription('Table for Configuration of EFMCu 2BASE-TL/10PASS-TS (PCS) Ports. Entries in this table MUST be maintained in a persistent manner')
efmCuPortConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: efmCuPortConfEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPortConfEntry.setDescription('An entry in the EFMCu Port Configuration table. Each entry represents an EFMCu port indexed by the ifIndex. Note that an EFMCu PCS port runs on top of a single or multiple PME port(s), which are also indexed by ifIndex.')
efmCuPAFAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPAFAdminState.setReference('[802.3ah] 61.2.2, 45.2.3.18.3')
if mibBuilder.loadTexts: efmCuPAFAdminState.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFAdminState.setDescription("Administrative (desired) state of the PAF of the EFMCu port (PCS). When 'disabled', PME Aggregation will not be performed by the PCS. No more than a single PME can be assigned to this PCS in this case. When 'enabled', PAF will be performed by the PCS when the link is Up, even on a single attached PME, if PAF is supported. PCS ports incapable of supporting PAF SHALL return a value of 'disabled'. Attempts to 'enable' such ports SHALL be ignored. PAF 'enabled' port with multiple PMEs assigned cannot be 'disabled'. Attempts to 'disable' such port SHALL be rejected, until at most one PME is left assigned. Changing PAFAdminState is a traffic disruptive operation and as such SHALL be done when the link is Down. Attempts to change this object SHALL be ignored if the link is Up or Initializing. This object maps to the Clause 30 attribute aPAFAdminState. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the PAF enable bit in the 10P/2B PCS control register. This object MUST be maintained in a persistent manner.")
efmCuPAFDiscoveryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 2), PhysAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPAFDiscoveryCode.setReference('[802.3ah] 61.2.2.8.3, 61.2.2.8.4, 45.2.6.6.1')
if mibBuilder.loadTexts: efmCuPAFDiscoveryCode.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFDiscoveryCode.setDescription('PAF Discovery Code of the EFMCu port (PCS). A unique 6 Byte long code used by the Discovery function, when PAF is supported. PCS ports incapable of supporting PAF SHALL return a value of all zeroes. Attempts to change this object SHALL be ignored in this case. This object MUST be instantiated for the -O subtype PCS before writing operations on the efmCuPAFRemoteDiscoveryCode (Set_if_Clear and Clear_if_Same) are performed by PMEs associated with the PCS. The value of this object is read-only for -R port subtypes. The initial value of this object for -R ports after reset is 0. This value may be changed as a result of writing operation on efmCuPAFRemoteDiscoveryCode variable of remote PME of -O subtype, connected to one of the local PMEs associated with the PCS. Discovery MUST be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue if the link is Up or Initializing. The PAF Discovery code maps to the local Discovery code variable in PAF (note that it does not have a corresponding Clause 45 register)')
efmCuAdminProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 3), ProfileIndexList().clone(hexValue="01")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuAdminProfile.setReference('[802.3ah] 30.11.2.1.6')
if mibBuilder.loadTexts: efmCuAdminProfile.setStatus('current')
if mibBuilder.loadTexts: efmCuAdminProfile.setDescription('Desired configuration Profile(s), common for all PMEs in the EFMCu port. This object is a list of pointers to entries in either efmCuPme2BProfileTable or efmCuPme10PProfileTable, depending on the current operating SubType of the EFMCu port as indicated by efmCuPortSide. The value of this object is a list of up to 6 indices of Profiles. If this list consists of a single Profile index, then all PMEs assigned to this EFMCu port SHALL be configured according to the Profile referenced by that index, unless it is overwritten by corresponding non-zero efmCuPmeAdminProfile, which takes precedence over efmCuAdminProfile. The list, consisting of more than one index, allows each PME in the port to be configured according to any Profile specified in the list. By default this object has a single profile index 1, referencing 1st entry in efmCuPme2BProfileTable/ efmCuPme2BProfileTable. This object is writable and readable for the -O subtype (2BaseTL-O or 10PassTS-O) EFMCu ports. It is unavailable for the -R subtype (2BaseTL-R or 10PassTS-R) ports. Note that current operational Profile value is available via efmCuPmeOperProfile object. Modification of this object must be performed when the link is Down. Attempts to change this object MUST be rejected, if the link is Up or Initializing. Attempts to set this object to a list with a member value, that is not the value of the index for an active entry in the corresponding profile table, MUST be rejected. This object MUST be maintained in a persistent manner.')
efmCuTargetDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(1, 100000), ValueRangeConstraint(999999, 999999), )).clone(50000)).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuTargetDataRate.setStatus('current')
if mibBuilder.loadTexts: efmCuTargetDataRate.setDescription("Desired EFMCu port 'net' (as seen across MII) Data Rate in Kbps, to be achieved during initialization, under spectral restrictions placed on each PME via efmCuAdminProfile or efmCuPmeAdminProfile, with the desired SNR Margin specified by efmCuTargetWorstCaseSnrMgn and efmCuTargetCurrentConditionSnrMgn depending on the values of efmCuTargetWorstCaseMode and efmCuTargetCurrentConditionMode. In case of PAF, this object represents a sum of individual PME data rates, modified to compensate for fragmentation and 64/65B framing overhead (e.g. target data rate of 10Mbps shall allow lossless transmission of full-duplex 10Mbps Ethernet frame stream with minimal inter-frame gap). The value is limited above by 100Mbps as this is the max burst rate across MII for EFMCu ports. The value between 1 and 100000 indicates that the total data rate (ifSpeed) of the EFMCu port after initialization should be equal to the target data rate or less, if the target data rate cannot be achieved under spectral restrictions specified by efmCuAdminProfile/efmCuPmeAdminProfile and with desired SNR margin. In case the copper environment allows to achieve higher total data rate than specified by the target, the excess capability SHALL be converted to additional SNR margin and spread evenly across all active PMEs assigned to the (PCS) port. The value of 999999 means that the target data rate is not fixed and should be set to the maximum attainable rate during initialization (Best Effort), under specified spectral restrictions and with desired SNR Margin. This object is read-write for the -O subtype EFMCu ports (2BaseTL-O/10PassTS-O) and not available for the -R subtypes. Changing of the Target Data Rate MUST be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. Note that current Data Rate of the EFMCu port is represented by ifSpeed object of IF-MIB. This object MUST be maintained in a persistent manner.")
efmCuTargetWorstCaseSnrMgn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 21))).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuTargetWorstCaseSnrMgn.setReference('[802.3ah] 61.1.2')
if mibBuilder.loadTexts: efmCuTargetWorstCaseSnrMgn.setStatus('current')
if mibBuilder.loadTexts: efmCuTargetWorstCaseSnrMgn.setDescription('Desired EFMCu port SNR Margin to be achieved on all PMEs assigned to the port, during initializiation if efmCuTargetWorstCaseMode is TRUE. (The SNR margin is the difference between the desired SNR and the actual SNR). Note that 802.3ah recommends using default Target SNR Margin of 5dB for 2BASE-TL ports and 6dB for 10PASS-TS ports in order to achieve mean Bit Error Rate (BER) of 10^-7 at the PMA service interface. This object is read-write for the -O subtype EFMCu ports (2BaseTL-O/10PassTS-O) and not available for the -R subtypes. Changing of the Target SNR Margin MUST be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. Note that current SNR Margin of the PMEs comprising the EFMCu port is represented by efmCuPmeSnrMgn. This object MUST be maintained in a persistent manner.')
efmCuThreshLowBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100000))).setUnits('Kbps').setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuThreshLowBandwidth.setStatus('current')
if mibBuilder.loadTexts: efmCuThreshLowBandwidth.setDescription('This object configures the EFMCu port Low Bandwidth alarm threshold. When the current value of ifSpeed for this port reaches or drops below this threshold, an efmCuLowBandwidth notification MAY be generated if enabled by efmCuLowBandwidthEnable. The value of 0 means no efmCuLowBandwidth notifications SHALL ever be generated. This object is read-write for the -O subtype EFMCu ports (2BaseTL-O/10PassTS-O) and not available for the -R subtypes. This object MUST be maintained in a persistent manner.')
efmCuLowBandwidthEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuLowBandwidthEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuLowBandwidthEnable.setDescription('Indicates whether efmCuLowBandwidth notifications should be generated for this interface. Value of true(1) indicates that efmCuLowBandwidth notification is enabled. Value of false(2) indicates that the notification is disabled. This object MUST be maintained in a persistent manner.')
efmCuTargetCurrentConditionMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuTargetCurrentConditionMode.setReference('[802.3ah] 61.1.2')
if mibBuilder.loadTexts: efmCuTargetCurrentConditionMode.setStatus('current')
if mibBuilder.loadTexts: efmCuTargetCurrentConditionMode.setDescription(' Note that 802.3ah recommends using default Target SNR Margin of 5dB for 2BASE-TL ports and 6dB for 10PASS-TS ports in order to achieve mean Bit Error Rate (BER) of 10^-7 at the PMA service interface. This object is read-write for the -O subtype EFMCu ports (2BaseTL-O/10PassTS-O) and not available for the -R subtypes. Changing of the Target SNR Margin MUST be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. Note that current SNR Margin of the PMEs comprising the EFMCu port is represented by efmCuPmeSnrMgn. This object MUST be maintained in a persistent manner.')
efmCuTargetCurrentConditionSnrMgn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-10, 21)).clone(6)).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuTargetCurrentConditionSnrMgn.setReference('[802.3ah] 61.1.2')
if mibBuilder.loadTexts: efmCuTargetCurrentConditionSnrMgn.setStatus('current')
if mibBuilder.loadTexts: efmCuTargetCurrentConditionSnrMgn.setDescription('Desired EFMCu port SNR Margin to be achieved on all PMEs assigned to the port, during initializiation if efmCuTargetCurrentConditionMode is TRUE. (The SNR margin is the difference between the desired SNR and the actual SNR). Note that 802.3ah recommends using default Target SNR Margin of 5dB for 2BASE-TL ports and 6dB for 10PASS-TS ports in order to achieve mean Bit Error Rate (BER) of 10^-7 at the PMA service interface. This object is read-write for the -O subtype EFMCu ports (2BaseTL-O/10PassTS-O) and not available for the -R subtypes. Changing of the Target SNR Margin MUST be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. Note that current SNR Margin of the PMEs comprising the EFMCu port is represented by efmCuPmeSnrMgn. This object MUST be maintained in a persistent manner.')
efmCuTargetWorstCaseMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 10), TruthValue().clone('true')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuTargetWorstCaseMode.setReference('[802.3ah] 61.1.2')
if mibBuilder.loadTexts: efmCuTargetWorstCaseMode.setStatus('current')
if mibBuilder.loadTexts: efmCuTargetWorstCaseMode.setDescription(' Note that 802.3ah recommends using default Target SNR Margin of 5dB for 2BASE-TL ports and 6dB for 10PASS-TS ports in order to achieve mean Bit Error Rate (BER) of 10^-7 at the PMA service interface. This object is read-write for the -O subtype EFMCu ports (2BaseTL-O/10PassTS-O) and not available for the -R subtypes. Changing of the Target SNR Margin MUST be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. Note that current SNR Margin of the PMEs comprising the EFMCu port is represented by efmCuPmeSnrMgn. This object MUST be maintained in a persistent manner.')
efmCuPAFAutoDiscovery = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("disabled", 1), ("optional", 2), ("required", 3))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPAFAutoDiscovery.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFAutoDiscovery.setDescription('Setting this value to disabled causes the CO and CPE to cease EFM Discovery communications. Bond groups and members must by created manually. Setting this value to optional has the following results depending on the current setup. If no EFM Bond group exists and the CO and CPE have multiple connections connecting them and both support EFM Discovery, then an EFM Bond group will be dynamically created and members will be added to the group. If an EFM bond group exists and it was created dynamically, the CO and CPE will start EFM Discovery. If the EFM Bond group was created manually or by ZMS, EFM Discovery will not be started. When setting this value to required, both the CO and CPE must be capable of supporting EFM Discovery. If two or more connections exist between the CO and CPE, an EFM Bond group will be dynamically created and members will be added to the group. This object MUST be maintained in a persistent manner.')
efmCuPmeErrorClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normalStats", 1), ("clearStats", 2))).clone('normalStats')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeErrorClearStats.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorClearStats.setDescription('This leaf is used to clear Error Monitor statistics. When the value is set to clearStats (2) the stats are cleared for this port. Once the stats have been cleared a read of this entry will return the value for normalStats (1). Only valid user settable value is clearStats (2).')
efmCuPmeSnrClearStats = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normalStats", 1), ("clearStats", 2))).clone('normalStats')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeSnrClearStats.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrClearStats.setDescription('This leaf is used to clear Snr Monitor statistics. When the value is set to clearStats (2) the stats are cleared for this port. Once the stats have been cleared a read of this entry will return the value for normalStats (1). Only valid user settable value is clearStats (2).')
efmCuPortCapabilityTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 2), )
if mibBuilder.loadTexts: efmCuPortCapabilityTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPortCapabilityTable.setDescription('Table for Capabilities of EFMCu 2BASE-TL/10PASS-TS (PCS) Ports. Entries in this table MUST be maintained in a persistent manner')
efmCuPortCapabilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: efmCuPortCapabilityEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPortCapabilityEntry.setDescription('An entry in the EFMCu Port Capability table. Each entry represents an EFMCu port indexed by the ifIndex. Note that an EFMCu PCS port runs on top of a single or multiple PME port(s), which are also indexed by ifIndex.')
efmCuPAFSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 2, 1, 1), TruthValue()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFSupported.setReference('[802.3ah] 61.2.2, 30.11.1.1.4, 45.2.3.17.1')
if mibBuilder.loadTexts: efmCuPAFSupported.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFSupported.setDescription('PME Aggregation Function (PAF) Capability of the EFMCu port (PCS). This object has a value of true(1) when the PCS can perform PME aggregation on the available PMEs. Ports incapable of PAF SHALL return a value of false(2). This object maps to the Clause 30 attribute aPAFSupported. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the PAF available bit in the 10P/2B capability register.')
efmCuPeerPAFSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 2, 1, 2), TruthValueOrUnknown()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPeerPAFSupported.setReference('[802.3ah] 61.2.2, 30.11.1.1.9, 45.2.3.17.2')
if mibBuilder.loadTexts: efmCuPeerPAFSupported.setStatus('current')
if mibBuilder.loadTexts: efmCuPeerPAFSupported.setDescription('PME Aggregation Function (PAF) Capability of the EFMCu port (PCS) link partner. This object has a value of true(1) when the remote PCS can perform PME aggregation on its available PMEs. Ports whose peers are incapable of PAF, SHALL return a value of false(2). Ports whose peers cannot be reached because of the link state, SHALL return a value if unknown(0). This object maps to the Clause 30 attribute aRemotePAFSupported. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the Remote PAF supported bit in the 10P/2B capability register.')
efmCuPAFCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 2, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFCapacity.setReference('[802.3ah] 61.2.2, 30.11.1.1.6')
if mibBuilder.loadTexts: efmCuPAFCapacity.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFCapacity.setDescription('Number of PMEs that can be aggregated by the local PAF. The number of PMEs currently assigned to a particular EFMCu port (efmCuNumPMEs) is never greater than efmCuPAFCapacity. This object maps to the Clause 30 attribute aLocalPAFCapacity.')
efmCuPeerPAFCapacity = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 32), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPeerPAFCapacity.setReference('[802.3ah] 61.2.2, 30.11.1.1.10')
if mibBuilder.loadTexts: efmCuPeerPAFCapacity.setStatus('current')
if mibBuilder.loadTexts: efmCuPeerPAFCapacity.setDescription('Number of PMEs that can be aggregated by the PAF of the peer Phy (PCS port). Value of 0 is returned when peer PAF Capacity is unknown (peer cannot be reached). This object maps to the Clause 30 attribute aRemotePAFCapacity.')
efmCuPortStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3), )
if mibBuilder.loadTexts: efmCuPortStatusTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPortStatusTable.setDescription('This table provides overall status information of EFMCu 2BASE-TL/10PASS-TS ports. This table contains live data from the equipment. As such, it is NOT persistent.')
efmCuPortStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: efmCuPortStatusEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPortStatusEntry.setDescription('An entry in the EFMCu Port Status table. Each entry represents an EFMCu port indexed by the ifIndex. Note that an EFMCu PCS port runs on top of a single or multiple PME port(s), which are also indexed by ifIndex.')
efmCuFltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 1), Bits().clone(namedValues=NamedValues(("noPeer", 0), ("pmeSubTypeMismatch", 1), ("lowBandwidth", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuFltStatus.setReference('ifOperStatus in IF-MIB; efmCuPmeFltStatus')
if mibBuilder.loadTexts: efmCuFltStatus.setStatus('current')
if mibBuilder.loadTexts: efmCuFltStatus.setDescription('EFMCu (PCS) port Fault Status. This is a bitmap of possible conditions. The various bit positions are: noPeer - peer PHY cannot be reached (e.g. no PMEs attached, all PMEs are Down etc.) More info is available in efmCuPmeFltStatus. pmeSubTypeMismatch - local PMEs in the aggregation group are not of the same sub-type, e.g. some PMEs in the local device are -O while others are -R subtype. lowBandwidth - ifSpeed of the port reached or droped below efmCuThreshLowBandwidth This object is intended to supplement ifOperStatus object in IF-MIB. Additional information is available via efmCuPmeFltStatus object for each PME in the aggregation group (single PME if PAF is disabled).')
efmCuPortSide = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("subscriber", 1), ("office", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPortSide.setReference('[802.3ah] 61.1, 30.11.1.1.2')
if mibBuilder.loadTexts: efmCuPortSide.setStatus('current')
if mibBuilder.loadTexts: efmCuPortSide.setDescription("EFM port mode of operation (subtype). The value of 'subscriber' indicates the port is designated as '-R' subtype (all PMEs assigned to this port are of subtype '-R'). The value of the 'office' indicates that the port is designated as '-O' subtype (all PMEs assigned to this port are of subtype '-O'). The value of 'unknown' indicates that the port has no assigned PMEs yet or that the assigned PMEs are not of the same side (subTypePMEMismatch). This object partially maps to the Clause 30 attribute aPhyEnd")
efmCuNumPMEs = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuNumPMEs.setReference('[802.3ah] 61.2.2, 30.11.1.1.6')
if mibBuilder.loadTexts: efmCuNumPMEs.setStatus('current')
if mibBuilder.loadTexts: efmCuNumPMEs.setDescription('Number of PMEs that is currently aggregated by the local PAF (assigned to the EFMCu port using ifStackTable). This number is never greater than efmCuPAFCapacity. This object SHALL be automatically incremented or decremented when a PME is added or deleted to/from the EFMCu port using ifStackTable.')
efmCuPAFInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInErrors.setReference('[802.3ah] 45.2.3.21')
if mibBuilder.loadTexts: efmCuPAFInErrors.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInErrors.setDescription('A number of fragments that have been received across the gamma interface with RxErr asserted and discarded. This read-only counter is inactive (not incremented) when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF RX error register.')
efmCuPAFInSmallFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInSmallFragments.setReference('[802.3ah] 45.2.3.22')
if mibBuilder.loadTexts: efmCuPAFInSmallFragments.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInSmallFragments.setDescription('A number of fragments smaller than minFragmentSize (64 Bytes), that have been received across the gamma interface and discarded. This read-only counter is inactive when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF small fragments register.')
efmCuPAFInLargeFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInLargeFragments.setReference('[802.3ah] 45.2.3.23')
if mibBuilder.loadTexts: efmCuPAFInLargeFragments.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInLargeFragments.setDescription('A number of fragments larger than maxFragmentSize (512 Bytes), that have been received across the gamma interface and discarded. This read-only counter is inactive when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF large fragments register.')
efmCuPAFInBadFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInBadFragments.setReference('[802.3ah] 45.2.3.25')
if mibBuilder.loadTexts: efmCuPAFInBadFragments.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInBadFragments.setDescription('A number of fragments which do not fit into the sequence expected by the frame assembly function, that have been received across the gamma interface and discarded (the frame buffer is flushed to the next valid frame start). This read-only counter is inactive when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF bad fragments register.')
efmCuPAFInLostFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInLostFragments.setReference('[802.3ah] 45.2.3.26')
if mibBuilder.loadTexts: efmCuPAFInLostFragments.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInLostFragments.setDescription('A number of gaps in the sequence of fragments, that have been received across the gamma interface (the frame buffer is flushed to the next valid frame start, when fragment/fragments expected by the frame assembly function is/are not received). This read-only counter is inactive when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF lost fragment register.')
efmCuPAFInLostStarts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInLostStarts.setReference('[802.3ah] 45.2.3.27')
if mibBuilder.loadTexts: efmCuPAFInLostStarts.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInLostStarts.setDescription('A number of missing StartOfPacket indicators expected by the frame assembly function. This read-only counter is inactive when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF lost start of fragment register.')
efmCuPAFInLostEnds = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInLostEnds.setReference('[802.3ah] 45.2.3.28')
if mibBuilder.loadTexts: efmCuPAFInLostEnds.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInLostEnds.setDescription('A number of missing EndOfPacket indicators expected by the frame assembly function. This read-only counter is inactive when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF lost start of fragment register.')
efmCuPAFInOverflows = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 1, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPAFInOverflows.setReference('[802.3ah] 45.2.3.24')
if mibBuilder.loadTexts: efmCuPAFInOverflows.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFInOverflows.setDescription('A number of fragements, received accross the gamma interface and discarded, which would have caused the frame assembly buffer to overflow. This read-only counter is inactive when the PAF is unsupported or disabled. Upon disabling the PAF, the counter retains its previous value. If a Clause 45 MDIO Interface to the PCS is present, then this object maps to the 10P/2B PAF overflow register.')
efmCuPmeNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0))
efmCuPmeLineAtnCrossing = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 1)).setObjects(("EFM-CU-MIB", "efmCuPmeLineAtn"), ("EFM-CU-MIB", "efmCuPmeThreshLineAtn"))
if mibBuilder.loadTexts: efmCuPmeLineAtnCrossing.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeLineAtnCrossing.setDescription('This notification indicates that the loop attenuation threshold (as per the efmCuPmeThreshLineAtn value) has been reached/exceeded for the 2BASE-TL/10PASS-TS PME. This notification MAY be send on the crossing event in both directions: from normal to exceeded and from exceeded to normal. Generation of this notification is controlled by the efmCuPmeLineAtnCrossingEnable object.')
efmCuPmeSnrMgnCrossing = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 2)).setObjects(("EFM-CU-MIB", "efmCuPmeSnrMgn"), ("EFM-CU-MIB", "efmCuPmeThreshMinSnrMgn"), ("EFM-CU-MIB", "efmCuPmeThreshMaxSnrMgnDelta"))
if mibBuilder.loadTexts: efmCuPmeSnrMgnCrossing.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrMgnCrossing.setDescription('This notification indicates that the SNR margin threshold (as per the efmCuPmeThreshMinSnrMgn efmCuPmeThreshMaxSnrMgnDelta values) has been reached/exceeded for the 2BASE-TL/10PASS-TS PME. This notification MAY be send on the crossing event from normal to exceeded. Generation of this notification is controlled by the efmCuPmeSnrMgnCrossingTrapEnable object. The Interval that this is sent can be controlled by the efmCuPmeSnrMonitoringInterval object.')
efmCuPmeDeviceFault = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 3)).setObjects(("EFM-CU-MIB", "efmCuPmeFltStatus"))
if mibBuilder.loadTexts: efmCuPmeDeviceFault.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeDeviceFault.setDescription('This notification indicates that a fault in the PME has been detected by a vendor specific diagnostic or a self-test. Generation of this notification is controlled by the efmCuPmeDeviceFaultEnable object.')
efmCuPmeConfigInitFailure = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 4)).setObjects(("EFM-CU-MIB", "efmCuPmeFltStatus"), ("EFM-CU-MIB", "efmCuAdminProfile"), ("EFM-CU-MIB", "efmCuPmeAdminProfile"))
if mibBuilder.loadTexts: efmCuPmeConfigInitFailure.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeConfigInitFailure.setDescription('This notification indicates that PME initialization has failed, due to inability of the PME link to achieve requested configuration profile. Generation of this notification is controlled by the efmCuPmeConfigInitFailEnable object.')
efmCuPmeProtocolInitFailure = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 5)).setObjects(("EFM-CU-MIB", "efmCuPmeFltStatus"), ("EFM-CU-MIB", "efmCuPmeOperSubType"))
if mibBuilder.loadTexts: efmCuPmeProtocolInitFailure.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeProtocolInitFailure.setDescription('This notification indicates that peer PME was using incompatible protocol during initialization. Generation of this notification is controlled by the efmCuPmeProtocolInitFailEnable object.')
efmCuPmeSnrMgnCrossingClear = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 6)).setObjects(("EFM-CU-MIB", "efmCuPmeSnrMgn"), ("EFM-CU-MIB", "efmCuPmeThreshMinSnrMgn"), ("EFM-CU-MIB", "efmCuPmeThreshMaxSnrMgnDelta"))
if mibBuilder.loadTexts: efmCuPmeSnrMgnCrossingClear.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrMgnCrossingClear.setDescription('This notification indicates that the SNR margin threshold (as per the efmCuPmeThreshMinSnrMgn efmCuPmeThreshMaxSnrMgnDelta values) has been returned within the threshold for the 2BASE-TL/10PASS-TS PME. This notification MAY be sent on the crossing event from exceeded to normal. Generation of this notification is controlled by the efmCuPmeSnrMgnCrossingTrapEnable object. The Interval that this is sent can be controlled by the efmCuPmeSnrMonitoringInterval object.')
efmCuPmeErrorThreshEfmTrafficDisable = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 7)).setObjects(("EFM-CU-MIB", "efmCuPmeErrorThreshMonInterval"))
if mibBuilder.loadTexts: efmCuPmeErrorThreshEfmTrafficDisable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorThreshEfmTrafficDisable.setDescription('This notification indicates that the Error threshold has seen errors for the efmCuPmeErrorThreshMonInterval consecutive seconds for the 2BASE-TL/10PASS-TS PME. This notification indicates that Efm traffic will be stopped from traversing this link. Generation of this notification is controlled by the efmCuPmeErrorThreshMonNotifyEnable object.')
efmCuPmeErrorThreshEfmTrafficEnable = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 8)).setObjects(("EFM-CU-MIB", "efmCuPmeErrorThreshMonClrInterval"))
if mibBuilder.loadTexts: efmCuPmeErrorThreshEfmTrafficEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorThreshEfmTrafficEnable.setDescription('This notification indicates that the Error threshold has seen no errors for the efmCuPmeErrorThreshMonClrInterval consecutive seconds for the 2BASE-TL/10PASS-TS PME. This notification indicates that Efm traffic will resume across this link. Generation of this notification is controlled by the efmCuPmeErrorThreshMonNotifyEnable object.')
efmCuPmeBondGroupTrafficDisabled = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 9))
if mibBuilder.loadTexts: efmCuPmeBondGroupTrafficDisabled.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeBondGroupTrafficDisabled.setDescription('This notification indicates that the Efm Bond Group has no links which are active and capable of allowing traffic to traverse the bond group. This notification indicates that Efm traffic will be stopped from traversing this bond group.')
efmCuPmeBondGroupTrafficEnabled = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 10))
if mibBuilder.loadTexts: efmCuPmeBondGroupTrafficEnabled.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeBondGroupTrafficEnabled.setDescription('This notification indicates that the Efm Bond Group has at least one link which is active and capable of allowing traffic to traverse the link. This notification indicates that Efm traffic will resume across this bond group.')
efmCuPmeLinkTrafficDisabled = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 11))
if mibBuilder.loadTexts: efmCuPmeLinkTrafficDisabled.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeLinkTrafficDisabled.setDescription('This notification indicates that the Efm link is no longer capable of allowing traffic to traverse the link. This notification indicates that Efm traffic will be stopped from traversing this particular link.')
efmCuPmeLinkTrafficEnabled = NotificationType((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 0, 12))
if mibBuilder.loadTexts: efmCuPmeLinkTrafficEnabled.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeLinkTrafficEnabled.setDescription('This notification indicates that the Efm link is now capable of allowing traffic to traverse the link. This notification indicates that Efm traffic will resume across this particular Efm link.')
efmCuPmeConfTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1), )
if mibBuilder.loadTexts: efmCuPmeConfTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeConfTable.setDescription('Table for Configuration of common aspects for EFMCu 2BASE-TL/10PASS-TS PME ports (modems). Configuration of aspects specific to 2BASE-TL or 10PASS-TS PME types is represented in efmCuPme2BConfTable and efmCuPme10PConfTable respectively. Entries in this table MUST be maintained in a persistent manner.')
efmCuPmeConfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: efmCuPmeConfEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeConfEntry.setDescription('An entry in the EFMCu PME Configuration table. Each entry represents common aspects of an EFMCu PME port indexed by the ifIndex. Note that an EFMCu PME port can be stacked below a single PCS port, also indexed by ifIndex, possibly together with other PME ports if PAF is enabled.')
efmCuPmeAdminSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("ieee2BaseTLO", 1), ("ieee2BaseTLR", 2), ("ieee10PassTSO", 3), ("ieee10PassTSR", 4), ("ieee2BaseTLor10PassTSR", 5), ("ieee2BaseTLor10PassTSO", 6), ("ieee10PassTSor2BaseTLO", 7))).clone('ieee2BaseTLR')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeAdminSubType.setReference('[802.3ah] 61.1, 45.2.1.11.4, 45.2.1.11.7')
if mibBuilder.loadTexts: efmCuPmeAdminSubType.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeAdminSubType.setDescription('Administrative (desired) sub-type of the PME. Possible values are: ieee2BaseTLO - PME shall operate as 2BaseTL-O ieee2BaseTLR - PME shall operate as 2BaseTL-R ieee10PassTSO - PME shall operate as 10PassTS-O ieee10PassTSR - PME shall operate as 10PassTS-R ieee2BaseTLor10PassTSR - PME shall operate as 2BaseTL-R or 10PassTS-R. Actual value will be set by -O link partner during initialization (handshake). ieee2BaseTLor10PassTSO - PME shall operate as 2BaseTL-O (preferred) or 10PassTS-O. Actual value will be set during initialization depending on -R link partner capability (i.e. if -R is incapable of the preferred 2BaseTL mode, 10PassTS will be used). ieee10PassTSor2BaseTLO - PME shall operate as 10PassTS-O (preferred) or 2BaseTL-O. Actual value will be set during initialization depending on -R link partner capability (i.e. if -R is incapable of the preferred 10PassTS mode, 2BaseTL will be used). Changing efmCuPmeAdminSubType is a traffic disruptive operation and as such SHALL be done when the link is Down. Attempts to change this object SHALL be ignored if the link is Up or Initializing. Attempts to change this object to an unsupported subtype (see efmCuPmeSubTypesSupported) SHALL be rejected. The current operational sub type is indicated by efmCuPmeOperSubType variable. If a Clause 45 MDIO Interface to the PMA/PMD is present, then this object combines values of the Port sub-type select bits and the PMA/PMD type selection bits in the 10P/2B PMA/PMD control register')
efmCuPmeAdminProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 2), ProfileIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeAdminProfile.setReference('[802.3ah] 30.11.2.1.6')
if mibBuilder.loadTexts: efmCuPmeAdminProfile.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeAdminProfile.setDescription('Desired PME configuration Profile. This object is a pointer to an entry in either efmCuPme2BProfileTable or efmCuPme10PProfileTable, depending on the current operating SubType of the PME. The value of this object is the index of the referenced profile. The value of zero (default) indicates that the PME is configured via efmCuAdminProfile object for the PCS port, to which this PME is assigned. That is, the profile referenced by efmCuPmeAdminProfile takes precedence over the profile(s) referenced by efmCuAdminProfile. This object is writable and readable for the CO subtype PMEs (2BaseTL-O or 10PassTS-O). It is unavailable for the CPE subtype (2BaseTL-R or 10PassTS-R). Note that current operational Profile value is available via efmCuPmeOperProfile object. Modification of this object must be performed when the link is Down. Attempts to change this object MUST be rejected, if the link is Up or Initializing. Attempts to set this object to a value that is not the value of the index for an active entry in the corresponding profile table, MUST be rejected.')
efmCuPAFRemoteDiscoveryCode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 3), PhysAddress().clone(hexValue="000000000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPAFRemoteDiscoveryCode.setReference('[802.3ah] 61.2.2.8.4, 45.2.6.6-45.2.6.8')
if mibBuilder.loadTexts: efmCuPAFRemoteDiscoveryCode.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFRemoteDiscoveryCode.setDescription('PAF Remote Discovery Code of the PME port at CO. A 6 Byte long Discovery Code of the peer PCS connected via the PME. Reading this object results in a Discovery Get operation. Writing a zero to this object results in a Discovery Clear_if_Same operation (the value of efmCuPAFDiscoveryCode at the peer PCS shall be the same as efmCuPAFDiscoveryCode of the local PCS associated with the PME for the operation to succeed). Writing a non-zero value to this object results in a Discovery Set_if_Clear operation. This object does not exist in CPE port subtypes. A zero length octet string SHALL be returned for CPE port subtypes and also when PAF aggregation is not enabled. Discovery MUST be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. If a Clause 45 MDIO Interface to the PMA/PMD is present, then this object is a function of 10P/2B aggregation discovery control register, Discovery operation result bits in 10P/2B aggregation and discovery status register and 10P/2B aggregation discovery code register')
efmCuPmeThreshLineAtn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 128))).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeThreshLineAtn.setReference('[802.3ah] 45.2.1.36')
if mibBuilder.loadTexts: efmCuPmeThreshLineAtn.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeThreshLineAtn.setDescription('Desired Line Attenuation Threshold for the 2B/10P PME. This object configures the line attenuation alarm threshold. When the current value of Line Attenuation reaches or exceeds this threshold, a efmCuPmeLineAtnCrossing notification MAY be generated, if enabled by efmCuPmeLineAtnCrossingEnable. This object is writable for the CO subtype PMEs (-O). It is read-only for the CPE subtype (-R). Changing of the Line Attenuation Threshold must be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. If a Clause 45 MDIO Interface to the PME is present, then this object will map to the Loop attenuation threshold bits in the 2B PMD line quality thresholds register')
efmCuPmeThreshMinSnrMgn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(-127, 128))).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeThreshMinSnrMgn.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeThreshMinSnrMgn.setDescription('Desired Min SNR Margin Threshold for the 2B/10P PME. This object configures the Min SNR margin alarm threshold. When the current value of SNR Margin drops below this threshold, a efmCuPmeSnrMgnCrossing notification MAY be generated, if enabled by efmCuPmeSnrMgnCrossingTrapEnable.')
efmCuPmeLineAtnCrossingEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 6), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeLineAtnCrossingEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeLineAtnCrossingEnable.setDescription('Indicates whether efmCuPmeLineAtnCrossing notifications should be generated for this interface. Value of true(1) indicates that efmCuPmeLineAtnCrossing notification is enabled. Value of false(2) indicates that the notification is disabled.')
efmCuPmeSnrMgnCrossingTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 7), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeSnrMgnCrossingTrapEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrMgnCrossingTrapEnable.setDescription('Indicates whether efmCuPmeSnrMgnCrossing notifications should be generated for this interface. Value of true(1) indicates that efmCuPmeSnrMgnCrossing notification is enabled. Value of false(2) indicates that the notification is disabled.')
efmCuPmeDeviceFaultEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 8), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeDeviceFaultEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeDeviceFaultEnable.setDescription('Indicates whether efmCuPmeDeviceFault notifications should be generated for this interface. Value of true(1) indicates that efmCuPmeDeviceFault notification is enabled. Value of false(2) indicates that the notification is disabled.')
efmCuPmeConfigInitFailEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 9), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeConfigInitFailEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeConfigInitFailEnable.setDescription('Indicates whether efmCuPmeConfigInitFailure notifications should be generated for this interface. Value of true(1) indicates that efmCuPmeConfigInitFailure notification is enabled. Value of false(2) indicates that the notification is disabled.')
efmCuPmeProtocolInitFailEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 10), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeProtocolInitFailEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeProtocolInitFailEnable.setDescription('Indicates whether efmCuPmeProtocolInitFailure notifications should be generated for this interface. Value of true(1) indicates that efmCuPmeProtocolInitFailure notification is enabled. Value of false(2) indicates that the notification is disabled.')
efmCuPmeThreshMaxSnrMgnDelta = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 11), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128)).clone(20)).setUnits('dB').setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeThreshMaxSnrMgnDelta.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeThreshMaxSnrMgnDelta.setDescription('Desired Max SNR Margin Threshold Delta for the 2B/10P PME. This object configures the Max SNR margin threshold delta. When the current value of SNR Margin exceeds the efmCuTargetWorstCaseSnrMgn or efmCuTargetCurrentConditionSnrMgn by more than this max SNR margin threshold delta value, then a efmCuPmeSnrMgnCrossing notification MAY be generated, if enabled by efmCuPmeSnrMgnCrossingTrapEnable. This object is writable for the CO subtype PMEs (2BaseTL-O/10PassTS-R). It is read-only for the CPE subtype (2BaseTL-R/10PassTS-R).')
efmCuPmeMaintenanceMode = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("off", 1), ("manual", 2), ("automaticOnce", 3), ("automaticDaily", 4), ("automaticContinuous", 5))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeMaintenanceMode.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeMaintenanceMode.setDescription('Administrative (desired) Maintenance of the PME. Possible values are: off - No monitoring of SNR values manual - Retrain line only once during the Maintenance Window specified by efmCuPmeMaintenanceStartTime and by efmCuPmeMaintenanceEndTime. automaticOnce - Monitor the SNR only once during the maintenance window, specified by efmCuPmeMaintenanceStartTime and by efmCuPmeMaintenanceEndTime. Retrain the line if the value has crossed the efmCuPmeThreshMinSnrMgn or the efmCuPmeThreshMaxSnrMgnDelta values. automaticDaily - Monitor the SNR daily during the maintenance window, specified by efmCuPmeMaintenanceStartTime and by efmCuPmeMaintenanceEndTime. Retrain the line only once each day during the maintenance window if the value has crossed the efmCuPmeThreshMinSnrMgn or the efmCuPmeThreshMaxSnrMgnDelta values. automaticContinuous - Monitor the SNR daily during the maintenance window, specified by efmCuPmeMaintenanceStartTime and by efmCuPmeMaintenanceEndTime. Retrain the line continuously during the maintenance window after each time elapsed specified by the efmCuPmeSnrMonitoringInterval, if the value has crossed the efmCuPmeThreshMinSnrMgn or the efmCuPmeThreshMaxSnrMgnDelta values. The current operational Maintenance Mode is indicated by efmCuPmeMonitorMode variable.')
efmCuPmeMaintenanceStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 13), DisplayString().clone('00:00')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeMaintenanceStartTime.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeMaintenanceStartTime.setDescription('This will represent the maintenance window start time for the maintenance to retrain the link in manual maintenance mode or the monitoring of the snr value with respect to the snr threshold values specified in efmCuPmeThreshMinSnrMgn and efmCuPmeThreshMaxSnrMgnDelta if the Maintenance Mode is set to automaticOnce or automaticDaily. The format of this string is HH:MM where HH is the military time for hour 0-23 and MM is the military time for minutes 0-59. The current Maintenance Start Time is indicated by efmCuPmeMaintenanceStartTime variable.')
efmCuPmeMaintenanceEndTime = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 14), DisplayString().clone('23:59')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeMaintenanceEndTime.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeMaintenanceEndTime.setDescription('This will represent the maintenance window end time for the maintenance to retrain the link in manual maintenance mode or the monitoring of the snr value with respect to the snr threshold values specified in efmCuPmeThreshMinSnrMgn and efmCuPmeThreshMaxSnrMgnDelta if the Maintenance Mode is set to automaticOnce or automaticDaily. The format of this string is HH:MM where HH is the military time for hour 0-23 and MM is the military time for minutes 0-59. The current Maintenance End Time is indicated by efmCuPmeMaintenanceEndTime variable.')
efmCuPmeSnrMonitoringInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 15), DisplayString().clone('01:00')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeSnrMonitoringInterval.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrMonitoringInterval.setDescription('This will represent the snr monitoring interval for the time elapsed between the monitoring of the snr value with respect to the snr threshold values specified in efmCuPmeThreshMinSnrMgn and efmCuPmeThreshMaxSnrMgnDelta. The format of this string is HH:MM where HH is the military time for hour 0-23 and MM is the military time for minutes 0-59.')
efmCuPmeErrorThreshMonEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 16), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonEnable.setDescription('This will enable/disable the error threshold monitoring. Error threshold monitoring looks for errors on the physical line. When there have been efmCuPmeErrorThreshMonInterval number of consecutive seconds with errors the line will first be taken down with a retrain in hopes of bettering the SNR to rectify the error situation. If, when the line comes up, we do not achieve efmCuPmeErrorThreshMonClrInterval number of consective error-free seconds before hitting another efmCuPmeErrorThreshMonInterval number of consecutive seconds with errors, the line will cease to be used for carrying traffic. The physical line will remain active so error monitoring can continue but data will no longer traverse until efmCuPmeErrorThreshMonClrInterval number of consecutive error-free seconds is achieved, at which time the line will resume carrying traffic.')
efmCuPmeErrorThreshMonNotifyEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 17), TruthValue().clone('false')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonNotifyEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonNotifyEnable.setDescription('This will enable/disable the error threshold monitoring notification (via cli or alarm manager) when an error threshold has been exceeded or cleared.')
efmCuPmeErrorThreshMonInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 18), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 65535)).clone(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonInterval.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonInterval.setDescription('This will specify the number of consecutive seconds of detecting errors that, once reached, will cause the physical line to be deemed a poor performer and cause an action to be taken. See efmCuPmeErrorThreshMonEnable.')
efmCuPmeErrorThreshMonClrInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(3, 65535)).clone(1800)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonClrInterval.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorThreshMonClrInterval.setDescription('This will specify the number of consecutive error-free seconds that must be achieved in order to declare the physical line usable for carrying data traffic. See efmCuPmeErrorThreshMonEnable.')
efmCuPmeLinkTrfcDisablTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuPmeLinkTrfcDisablTrapEnable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeLinkTrfcDisablTrapEnable.setDescription('This will enable/disable the link traffic disable notification (via cli or alarm manager) when a link is capable or no longer capable of passing traffic.')
efmCuPmeCapabilityTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 2), )
if mibBuilder.loadTexts: efmCuPmeCapabilityTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeCapabilityTable.setDescription('Table for Configuration of common aspects for EFMCu 2BASE-TL/10PASS-TS PME ports (modems). Configuration of aspects specific to 2BASE-TL or 10PASS-TS PME types is represented in efmCuPme2BConfTable and efmCuPme10PConfTable respectively. Entries in this table MUST be maintained in a persistent manner.')
efmCuPmeCapabilityEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 2, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: efmCuPmeCapabilityEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeCapabilityEntry.setDescription('An entry in the EFMCu PME Capability table. Each entry represents common aspects of an EFMCu PME port indexed by the ifIndex. Note that an EFMCu PME port can be stacked below a single PCS port, also indexed by ifIndex, possibly together with other PME ports if PAF is enabled.')
efmCuPmeSubTypesSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 2, 1, 1), Bits().clone(namedValues=NamedValues(("ieee2BaseTLO", 0), ("ieee2BaseTLR", 1), ("ieee10PassTSO", 2), ("ieee10PassTSR", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeSubTypesSupported.setReference('[802.3ah] 61.1, 45.2.1.4.1, 45.2.1.4.2, 45.2.1.12.2, 45.2.1.12.3')
if mibBuilder.loadTexts: efmCuPmeSubTypesSupported.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSubTypesSupported.setDescription('PME supported sub-types. This is a bitmap of possible sub-types. The various bit positions are: ieee2BaseTLO - PME is capable of operating as 2BaseTL-O ieee2BaseTLR - PME is capable of operating as 2BaseTL-R ieee10PassTSO - PME is capable of operating as 10PassTS-O ieee10PassTSR - PME is capable of operating as 10PassTS-R An desired mode of operation is determined by efmCuPmeAdminSubType, while efmCuPmeOperSubType relects the current operating mode. If a Clause 45 MDIO Interface to the PCS is present, then this object combines the 10PASS-TS capable and 2BASE-TL capable bits in the 10P/2B PMA/PMD speed ability register and the CO supported and CPE supported bits in the 10P/2B PMA/PMD status register')
efmCuPmeStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3), )
if mibBuilder.loadTexts: efmCuPmeStatusTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeStatusTable.setDescription('This table provides common status information of EFMCu 2BASE-TL/10PASS-TS PME ports. Status information specific to 10PASS-TS PME is represented in efmCuPme10PStatusTable. This table contains live data from the equipment. As such, it is NOT persistent.')
efmCuPmeStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: efmCuPmeStatusEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeStatusEntry.setDescription('An entry in the EFMCu PME Status table. Each entry represents common aspects of an EFMCu PME port indexed by the ifIndex. Note that an EFMCu PME port can be stacked below a single PCS port, also indexed by ifIndex, possibly together with other PME ports if PAF is enabled.')
efmCuPmeOperStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("up", 1), ("downNotReady", 2), ("downReady", 3), ("init", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeOperStatus.setReference('[802.3ah] 30.11.2.1.3, 45.2.1.12.4')
if mibBuilder.loadTexts: efmCuPmeOperStatus.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeOperStatus.setDescription("Current PME link Operational Status. Possible values are: up(1) - link is Up and ready to pass 64/65B encoded frames or fragments. downNotReady(2) - link is Down and the PME does not detect Handshake tones from its peer. This value may indicate a possible problem with the peer PME. downReady(3) - link is Down and the PME detects Handshake tones from its peer. init(4) - link is initializing, as a result of ifAdminStatus being set to 'up' for a particular PME or a PCS the PME is connected to. This object is intended to supplement Down state of ifOperStatus. This object partially maps to the Clause 30 attribute aPMEStatus. If a Clause 45 MDIO Interface to the PME is present, then this object partially maps to PMA/PMD link status bits in 10P/2B PMA/PMD status register.")
efmCuPmeFltStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 2), Bits().clone(namedValues=NamedValues(("lossOfFraming", 0), ("snrMgnDefect", 1), ("lineAtnDefect", 2), ("deviceFault", 3), ("configInitFailure", 4), ("protocolInitFailure", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeFltStatus.setReference('[802.3ah] 30.11.2.1.3, 45.2.1.2.1, 45.2.1.38, 45.2.1.39, 45.2.1.54')
if mibBuilder.loadTexts: efmCuPmeFltStatus.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeFltStatus.setDescription('Current/Last PME link Fault Status. This is a bitmap of possible conditions. The various bit positions are: lossOfFraming - Loss of Framing for 10P or Loss of Sync word for 2B PMD or Loss of 64/65B Framing snrMgnDefect - SNR Margin dropped below the Threshold lineAtnDefect - Line Attenuation exceeds the Threshold deviceFault - Indicates a vendor-dependent diagnostic or self-test fault has been detected. configInitFailure - Configuration initialization failure, due to inability of the PME link to support configuration profile, requested during initialization. protocolInitFailure - Protocol initialization failure, due to incompatible protocol used by the Peer PME during init (that could happen if a peer PMD is G.SDHSL/VDSL modem for 2BASE-TL/10PASS-TS PME respectively). This object is intended to supplement ifOperStatus in IF-MIB. The indications hold information about the last fault. efmCuPmeFltStatus is cleared by the device restart. In addition lossOfFraming, configInitFailure and protocolInitFailure are cleared by PME init. deviceFault is cleared by successful diagnostics/test. snrMgnDefect and lineAtnDefect are cleared by SNR Margin and line Attenuation respectively returning to norm and by PME init. This object partially maps to the Clause 30 attribute aPMEStatus. If a Clause 45 MDIO Interface to the PME is present, then this object consolidates information from various PMA/PMD registers, namely: Fault bit in PMA/PMD status 1 register, 10P/2B PMA/PMD link loss register, 10P outgoing indicator bits status register, 10P incoming indicator bits status register, 2B state defects register.')
efmCuPmeOperSubType = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("ieee2BaseTLO", 1), ("ieee2BaseTLR", 2), ("ieee10PassTSO", 3), ("ieee10PassTSR", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeOperSubType.setReference('[802.3ah] 61.1, 45.2.1.11.4, 45.2.1.11.7, 45.2.1.12.4')
if mibBuilder.loadTexts: efmCuPmeOperSubType.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeOperSubType.setDescription('Current operational sub-type of the PME. Possible values are: ieee2BaseTLO - PME operates as 2BaseTL-O ieee2BaseTLR - PME operates as 2BaseTL-R ieee10PassTSO - PME operates as 10PassTS-O ieee10PassTSR - PME operates as 10PassTS-R The operational sub type of the PME can be configured via efmCuPmeAdminSubType variable. If a Clause 45 MDIO Interface to the PMA/PMD is present, then this object combines values of the Port sub-type select bits, the PMA/PMD type selection bits in the 10P/2B PMA/PMD control register and the PMA/PMD link status bits in the 10P/2B PMA/PMD status register.')
efmCuPmeOperProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 4), ProfileIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeOperProfile.setReference('[802.3ah] 30.11.2.1.7')
if mibBuilder.loadTexts: efmCuPmeOperProfile.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeOperProfile.setDescription('PME current operating Profile. This object is a pointer to an entry in either efmCuPme2BProfileTable or efmCuPme10PProfileTable, depending on the current operating SubType of the PME as indicated by efmCuPmeOperSubType. Note that a profile entry, to which efmCuPmeOperProfile is pointing to, can be created automatically, to reflect achieved parameters in adaptive (not fixed) initialization, i.e. values of efmCuPmeOperProfile and efmCuAdminProfile or efmCuPmeAdminProfile MAY differ. The value of zero indicates that PME is down or initializing. This object partially maps to the aOperatingProfile attribute in Clause 30.')
efmCuPmeSnrMgn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-127, 128), ValueRangeConstraint(65535, 65535), ))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeSnrMgn.setReference('[802.3ah] 30.11.2.1.4, 45.2.1.16')
if mibBuilder.loadTexts: efmCuPmeSnrMgn.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrMgn.setDescription('The current Signal-to-Noise Ratio (SNR) margin with respect to the received signal as perceived by the local PME. The value of 65535 is returned when PME is down or initializing. This object maps to the aPMESNRMgn attribute in Clause 30. If a Clause 45 MDIO Interface is present, then this object maps to the 10P/2B RX SNR margin register.')
efmCuPmePeerSnrMgn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-127, 128), ValueRangeConstraint(65535, 65535), ))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmePeerSnrMgn.setReference('[802.3ah] 45.2.1.17')
if mibBuilder.loadTexts: efmCuPmePeerSnrMgn.setStatus('current')
if mibBuilder.loadTexts: efmCuPmePeerSnrMgn.setDescription('The current SNR margin in dB with respect to the received signal, as perceived by the remote (link partner) PME. The value of 65535 is returned when PME is down or initializing. This object is not supported by -R PME subtypes. If a Clause 45 MDIO Interface is present, then this object maps to the 10P/2B link partner RX SNR margin register.')
efmCuPmeLineAtn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-127, 128), ValueRangeConstraint(65535, 65535), ))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeLineAtn.setReference('[802.3ah] 45.2.1.18')
if mibBuilder.loadTexts: efmCuPmeLineAtn.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeLineAtn.setDescription('The current Line Attenuation in dB as perceived by the local PME. The value of 65535 is returned when PME is down or initializing. If a Clause 45 MDIO Interface is present, then this object maps to the Line Attenuation register')
efmCuPmePeerLineAtn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-127, 128), ValueRangeConstraint(65535, 65535), ))).setUnits('dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmePeerLineAtn.setReference('[802.3ah] 45.2.1.19')
if mibBuilder.loadTexts: efmCuPmePeerLineAtn.setStatus('current')
if mibBuilder.loadTexts: efmCuPmePeerLineAtn.setDescription('The current Line Attenuation in dB as perceived by the remote (link partner) PME. The value of 65535 is returned when PME is down or initializing. This object is not supported by CPE port subtypes. If a Clause 45 MDIO Interface is present, then this object maps to the 20P/2B link partner Line Attenuation register.')
efmCuPmeTCCodingErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeTCCodingErrors.setReference('[802.3ah] 61.3.3.1, 45.2.6.12')
if mibBuilder.loadTexts: efmCuPmeTCCodingErrors.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeTCCodingErrors.setDescription('A number of 64/65-octet encapsulation errors. This counter is incremented for each 64/65-octet encapsulation error detected by the 64/65-octet receive function. The value of zero SHALL be returned when PME is down or initializing. If a Clause 45 MDIO Interface to the PME TC is present, then this object maps to the TC coding violations register (see 45.2.6.12).')
efmCuPmeTCCrcErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeTCCrcErrors.setReference('[802.3ah] 61.3.3.3, 45.2.6.11')
if mibBuilder.loadTexts: efmCuPmeTCCrcErrors.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeTCCrcErrors.setDescription('A number of TC-CRC errors. This counter is incremented for each TC-CRC error detected by the 64/65-octet receive function (see 61.3.3.3 and Figure 61-19). The value of zero SHALL be returned when PME is down or initializing. If a Clause 45 MDIO Interface to the PCME TC is present, then this object maps to the TC CRC error register (see 45.2.6.11).')
efmCuPmeSnrCrossingCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeSnrCrossingCnt.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrCrossingCnt.setDescription('A count of the number of times that the Snr Margin crossed the threshold. This counter is incremented for each time the target snr margin specified by efmCuPmeSnrMgn exceeds the snr threshold specified by efmCuPmeThreshMinSnrMgn and efmCuPmeThreshMaxSnrMgnDelta. The value of zero SHALL be returned when PME is down or initializing.')
efmCuPmeTCDownCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeTCDownCnt.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeTCDownCnt.setDescription('A count of the number of times that the TC Layer went down since the line has obtained link.')
efmCuPmeErrorTCDownCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeErrorTCDownCnt.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorTCDownCnt.setDescription('A count of the number of times that the TC Layer was forced down because of the Error Monitoring Feature. ')
efmCuPmeErrorRestartCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeErrorRestartCnt.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorRestartCnt.setDescription('A count of the number of times that the line was forced to retrain because of the Error Monitoring Feature. ')
efmCuPmeSnrRestartCnt = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeSnrRestartCnt.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeSnrRestartCnt.setDescription('A count of the number of times that the line was forced to retrain because of the Snr Monitoring Feature. ')
efmCuPmeErrorConsecutiveSec = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeErrorConsecutiveSec.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorConsecutiveSec.setDescription('A count of the number of consecutive seconds with an error. This value is set to zero when there is a second without an error.')
efmCuPmeErrorMaxConsecutiveSec = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 3, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPmeErrorMaxConsecutiveSec.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeErrorMaxConsecutiveSec.setDescription('A count of the Max number of consecutive seconds with an error where there has been no need for Error Monitoring to take action on the link.')
efmCuPme2B = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5))
efmCuPme2BProfileTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2), )
if mibBuilder.loadTexts: efmCuPme2BProfileTable.setReference('[802.3ah] Annex 63A, 30.11.2.1.6')
if mibBuilder.loadTexts: efmCuPme2BProfileTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BProfileTable.setDescription('This table supports definitions of administrative and operating Profiles for 2BASE-TL PMEs. First 14 entries in this table SHALL always be defined as follows (see 802.3ah Annex 63A): -------+------+-----+--------+------------------ Profile Rate Power Region Constellation index (Kbps) (dBm) (G.991.2) -------+------+-----+--------+------------------ 1 512 13.5 1 16-TCPAM (default) 2 704 13.5 1 16-TCPAM 3 1024 13.5 1 16-TCPAM 4 2048 13.5 1 16-TCPAM 5 3072 13.5 1 32-TCPAM 6 5696 13.5 1 32-TCPAM 7 512 13.5 2 16-TCPAM 8 704 13.5 2 16-TCPAM 9 1024 13.5 2 16-TCPAM 10 2048 14.5 2 16-TCPAM 11 3072 14.5 2 32-TCPAM 12 5696 14.5 2 32-TCPAM 13 0 0 1 0 (best effort) 14 0 0 2 0 (best effort) These default entries SHALL be created during agent initialization and MUST not be deleted. Entries following the first 14, can be dynamically created and deleted, to provide custom administrative (configuration) profiles and automatic operating profiles. This table MUST be maintained in a persistent manner.')
efmCuPme2BProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1), ).setIndexNames((0, "EFM-CU-MIB", "efmCuPme2BProfileIndex"))
if mibBuilder.loadTexts: efmCuPme2BProfileEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BProfileEntry.setDescription("Each entry corresponds to a single 2BASE-TL PME profile. Each profile contains a set of parameters, used either for configuration or representation of a 2BASE-TL PME. In case a particular profile is referenced via efmCuPmeAdminProfile object (or efmCuAdminProfile if efmCuPmeAdminProfile is zero), it represent the desired parameters the 2BaseTL-O PME initialization. If a profile is referenced via efmCuPmeOperProfile object, it represents current operating parameters of the operational PME. Profiles may be created/deleted using the row creation/ deletion mechanism via efmCuPme2BProfileRowStatus. If an active entry is referenced, the entry MUST remain 'active' until all references are removed. Default entries MUST not be removed.")
efmCuPme2BProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 1), ProfileIndex())
if mibBuilder.loadTexts: efmCuPme2BProfileIndex.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BProfileIndex.setDescription('2BASE-TL PME Profile index. This object is the unique index associated with this profile. Entries in this table are referenced via efmCuAdminProfile or efmCuPmeAdminProfile objects.')
efmCuPme2BProfileDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme2BProfileDescr.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BProfileDescr.setDescription('A textual string containing information about 2BASE-TL PME Profile. The string MAY include information about data rate and spectral limitations of this particular profile.')
efmCuPme2BRegion = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("region1", 1), ("region2", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme2BRegion.setReference('[802.3ah] 45.2.1.42')
if mibBuilder.loadTexts: efmCuPme2BRegion.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BRegion.setDescription('Power Spectral Density (PSD) Regional settings as specified in the relevant Regional Annex of [G.991.2]. Regional settings place limitations on the max allowed data rate, power and constellation. Possible values for this object are: region1 -- Annexes A and F (e.g. North America) region2 -- Annexes B and G (e.g. Europe) Changing of the Region must be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. If a Clause 45 MDIO Interface to the PME is present, then this object maps to the Region bits in the 2B general parameter register.')
efmCuPme2BDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 15352))).setUnits('Kbps').setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme2BDataRate.setReference('[802.3ah] 45.2.1.43')
if mibBuilder.loadTexts: efmCuPme2BDataRate.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BDataRate.setDescription('2BASE-TL PME Data Rate. The rate is fixed when the value of this object is n x 64Kbps, where n=3..60 for 16-TCPAM and n=12..89 for 32-TCPAM. The value of 0 in the administrative profile means that data rate is not fixed but is adaptive and should be set to the maximum attainable rate during line probing, under the spectral limitations placed by the efmCuPme2BRegion. If a Clause 45 MDIO Interface to the PME is present, then this object maps to the Min/Max Data Rate1 bits in the 2B PMD parameters register. This object MUST be maintained in a persistent manner.')
efmCuPme2BPower = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 5), Unsigned32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 0), ValueRangeConstraint(10, 42), ))).setUnits('0.5 dBm').setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme2BPower.setReference('[802.3ah] 45.2.1.43')
if mibBuilder.loadTexts: efmCuPme2BPower.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BPower.setDescription('Signal Transmit Power. Multiple of 0.5dBm. The value of 0 in the administrative profile means that the signal transmit power is not fixed and should be set to maximize the attainable rate, under the spectral limitations placed by the efmCuPme2BRegion. Changing of the Signal Transmit Power must be performed when the link is Down. Attempts to change this object MUST be rejected with the error inconsistentValue, if the link is Up or Initializing. If a Clause 45 MDIO Interface to the PME is present, then this object will map to the Power1 bits in the 2B PMD parameters register')
efmCuPme2BConstellation = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("adaptive", 0), ("tcpam16", 1), ("tcpam32", 2), ("tcpam4", 3), ("tcpam8", 4), ("tcpam64", 5), ("tcpam128", 6)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme2BConstellation.setReference('[802.3ah] 45.2.1.43')
if mibBuilder.loadTexts: efmCuPme2BConstellation.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BConstellation.setDescription('TCPAM Constellation of the 2BASE-TL PME. The possible values are: adaptive(0) - either 16- or 32-TCPAM tcpam16(1) - 16-TCPAM tcpam32(2) - 32-TCPAM tcpam4(3) - 4-TCPAM tcpam8(4) - 8-TCPAM tcpam64(5) - 64-TCPAM tcpam128(6) - 128-TCPAM The value of adaptive(0) in the administrative profile means that the constellation is not fixed and should be set to maximize the attainable rate, under the spectral limitations placed by the efmCuPme2BRegion. If a Clause 45 MDIO Interface to the PME is present, then this object map to the Constellation1 bits in the 2B general parameter register.')
efmCuPme2BProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 7), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme2BProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BProfileRowStatus.setDescription("This object controls creation/deletion of the associated entry in efmCuPme2BProfileTable per the semantics of RowStatus. If an 'active' entry is referenced via efmCuAdminProfile or efmCuPmeAdminProfile, the entry MUST remain 'active' until all references are removed.")
efmCuPmeNtr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 5, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("localOsc", 1), ("refClk8khz", 2)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPmeNtr.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeNtr.setDescription('Network Time and Power The possible values are: localOsc(1) - use local osc for timimg refClk8khz(2) - use Backplane 8KHZ clock for timimg')
efmCuPme10P = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6))
efmCuPme10PProfileTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1), )
if mibBuilder.loadTexts: efmCuPme10PProfileTable.setReference('[802.3ah] Annex 62B.3, 30.11.2.1.6')
if mibBuilder.loadTexts: efmCuPme10PProfileTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PProfileTable.setDescription('This table supports definitions of configuration profiles for 10PassTL PMEs. First 22 entries in this table SHALL always be defined as follows (see 802.3ah Annex 62B.3): -------+--------+----+---------+-----+------------ Profile Bandplan UPBO BandNotch DRate URate Index PSDMask# p# p# p# p# -------+--------+----+---------+-----+------------ 1 1 3 2,6,10,11 20 20(default) 2 13 5 0 20 20 3 1 1 0 20 20 4 16 0 0 100 100 5 16 0 0 70 50 6 6 0 0 50 10 7 17 0 0 30 30 8 8 0 0 30 5 9 4 0 0 25 25 10 4 0 0 15 15 11 23 0 0 10 10 12 23 0 0 5 5 13 16 0 2,5,9,11 100 100 14 16 0 2,5,9,11 70 50 15 6 0 2,6,10,11 50 10 16 17 0 2,5,9,11 30 30 17 8 0 2,6,10,11 30 5 18 4 0 2,6,10,11 25 25 19 4 0 2,6,10,11 15 15 20 23 0 2,5,9,11 10 10 21 23 0 2,5,9,11 5 5 22 30 0 0 200 50 These default entries SHALL be created by during agent initialization and MUST not be deleted. Entries following the first 22, can be dynamically created and deleted, to provide custom administrative (configuration) profiles and automatic operating profiles. This table MUST be maintained in a persistent manner.')
efmCuPme10PProfileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1), ).setIndexNames((0, "EFM-CU-MIB", "efmCuPme10PProfileIndex"))
if mibBuilder.loadTexts: efmCuPme10PProfileEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PProfileEntry.setDescription("Each entry corresponds to a single 10PASS-TS PME profile. Each profile contains a set of parameters, used either for configuration or representation of a 10PASS-TS PME. In case a particular profile is referenced via efmCuPmeAdminProfile object (or efmCuAdminProfile if efmCuPmeAdminProfile is zero), it represent the desired parameters the 10PassTS-O PME initialization. If a profile is referenced via efmCuPmeOperProfile object, it represents current operating parameters of the PME. Profiles may be created/deleted using the row creation/ deletion mechanism via efmCuPme10PProfileRowStatus. If an 'active' entry is referenced, the entry MUST remain 'active' until all references are removed. Default entries MUST not be removed.")
efmCuPme10PProfileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 1), ProfileIndex())
if mibBuilder.loadTexts: efmCuPme10PProfileIndex.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PProfileIndex.setDescription('10PASS-TS PME Profile Index. This object is the unique index associated with this profile. Entries in this table are referenced via efmCuAdminProfile or efmCuPmeAdminProfile.')
efmCuPme10PProfileDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 2), SnmpAdminString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme10PProfileDescr.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PProfileDescr.setDescription('A textual string containing information about 10PASS-TS PME Profile. The string MAY include information about data rate and spectral limitations of this particular profile.')
efmCuPme10PBandplanPSDMskProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29))).clone(namedValues=NamedValues(("profile1", 1), ("profile2", 2), ("profile3", 3), ("profile4", 4), ("profile5", 5), ("profile6", 6), ("profile7", 7), ("profile8", 8), ("profile9", 9), ("profile10", 10), ("profile11", 11), ("profile12", 12), ("profile13", 13), ("profile14", 14), ("profile15", 15), ("profile16", 16), ("profile17", 17), ("profile18", 18), ("profile19", 19), ("profile20", 20), ("profile21", 21), ("profile22", 22), ("profile23", 23), ("profile24", 24), ("profile25", 25), ("profile26", 26), ("profile27", 27), ("profile28", 28), ("profile29", 29)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme10PBandplanPSDMskProfile.setReference('[802.3ah] Annex 62A, 30.5.1.1.22')
if mibBuilder.loadTexts: efmCuPme10PBandplanPSDMskProfile.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PBandplanPSDMskProfile.setDescription('10PASS-TS PME Bandplan and PSD Mask profile, as specified in 802.3ah Annex 62A. Possible values are: --------------+------------------------+-----------+--------- Profile Name PSD Mask Bands Bandplan --------------+------------------------+-----------+--------- profile1(1) - T1.424/T-U P1 FTTCab.M1 x/D/U/D/U A profile2(2) - T1.424/T-U P1 FTTEx.M1 profile3(3) - T1.424/T-U P1 FTTCab.M2 profile4(4) - T1.424/T-U P1 FTTEx.M2 profile5(5) - T1.424/T-U P1 FTTCab.M1 D/D/U/D/U profile6(6) - T1.424/T-U P1 FTTEx.M1 profile7(7) - T1.424/T-U P1 FTTCab.M2 profile8(8) - T1.424/T-U P1 FTTEx.M2 profile9(9) - T1.424/T-U P1 FTTCab.M1 U/D/U/D/x profile10(10) - T1.424/T-U P1 FTTEx.M1 profile11(11) - T1.424/T-U P1 FTTCab.M2 profile12(12) - T1.424/T-U P1 FTTEx.M2 profile13(13) - TS1 101 270-1 Pcab.M1.A x/D/U/D/U B profile14(14) - TS1 101 270-1 Pcab.M1.B profile15(15) - TS1 101 270-1 Pex.P1.M1 profile16(16) - TS1 101 270-1 Pex.P2.M1 profile17(17) - TS1 101 270-1 Pcab.M2 profile18(18) - TS1 101 270-1 Pex.P1.M2 profile19(19) - TS1 101 270-1 Pex.P2.M2 profile20(20) - TS1 101 270-1 Pcab.M1.A U/D/U/D/x profile21(21) - TS1 101 270-1 Pcab.M1.B profile22(22) - TS1 101 270-1 Pex.P1.M1 profile23(23) - TS1 101 270-1 Pex.P2.M1 profile24(24) - TS1 101 270-1 Pcab.M2 profile25(25) - TS1 101 270-1 Pex.P1.M2 profile26(26) - TS1 101 270-1 Pex.P2.M2 profile27(27) - G.993.1 F.1.2.1 (VDSLoPOTS) x/D/U/D/U F profile28(28) - G.993.1 F.1.2.2 (VDSLoTCM-ISDN) profile29(29) - G.993.1 F.1.2.3 (PSD reduction) This object maps to the aBandplanPSDMaskProfile attribute in Clause 30.')
efmCuPme10PUPBOReferenceProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("profile1", 1), ("profile2", 2), ("profile3", 3), ("profile4", 4), ("profile5", 5), ("profile6", 6), ("profile7", 7), ("profile8", 8), ("profile9", 9)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme10PUPBOReferenceProfile.setReference('[802.3ah] Annex 62A.3.4, 30.5.1.1.23')
if mibBuilder.loadTexts: efmCuPme10PUPBOReferenceProfile.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PUPBOReferenceProfile.setDescription('10PASS-TS PME Upstream Power Back-Off (UPBO) Reference PSD Profile, as specified in 802.3ah Annex 62A. Possible values are: profile1(1) - T1.424/T-U Noise A M1 profile2(2) - T1.424/T-U Noise A M2 profile3(3) - T1.424/T-U Noise F M1 profile4(4) - T1.424/T-U Noise F M2 profile5(5) - ETSI TS 101 270-1 Noise A&B profile6(6) - ETSI TS 101 270-1 Noise C profile7(7) - ETSI TS 101 270-1 Noise D profile8(8) - ETSI TS 101 270-1 Noise E profile9(9) - ETSI TS 101 270-1 Noise F This object maps to the aUPBOReferenceProfile attribute in Clause 30.')
efmCuPme10PBandNotchProfiles = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 5), Bits().clone(namedValues=NamedValues(("profile0", 0), ("profile1", 1), ("profile2", 2), ("profile3", 3), ("profile4", 4), ("profile5", 5), ("profile6", 6), ("profile7", 7), ("profile8", 8), ("profile9", 9), ("profile10", 10), ("profile11", 11)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme10PBandNotchProfiles.setReference('[802.3ah] Annex 62A.3.5, 30.5.1.1.19')
if mibBuilder.loadTexts: efmCuPme10PBandNotchProfiles.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PBandNotchProfiles.setDescription('10PASS-TS PME Egress Control Band Notch Profile bitmap, as specified in 802.3ah Annex 62A. Possible values are: --------------+---------+----------+-----------+------+----- Profile Name G.991.3 T1.424/T-U TS101 270-1 StartF EndF Table Table Table (MHz) (MHz) --------------+---------+----------+-----------+------+----- profile0(0) - no profile profile1(1) - F-5 #01 - - 1.810 1.825 profile2(2) - 6-2 15-1 17 1.810 2.000 profile3(3) - F-5 #02 - - 1.907 1.912 profile4(4) - F-5 #03 - - 3.500 3.575 profile5(5) - 6-2 - 17 3.500 3.800 profile6(6) - - 15-1 - 3.500 4.000 profile7(7) - F-5 #04 - - 3.747 3.754 profile8(8) - F-5 #05 - - 3.791 3.805 profile9(9) - 6-2 - 17 7.000 7.100 profile10(10) - F-5 #06 15-1 - 7.000 7.300 profile11(11) - 6-2 15-1 1 10.100 10.150 Any combination of profiles can be specified by ORing individual profiles, for example value of 0x0622 selects profiles 2,6,10 and 11. This object maps to the aBandNotchProfile attribute in Clause 30.')
efmCuPme10PPayloadURateProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 15, 20, 25, 30, 50, 70, 100))).clone(namedValues=NamedValues(("profile5", 5), ("profile10", 10), ("profile15", 15), ("profile20", 20), ("profile25", 25), ("profile30", 30), ("profile50", 50), ("profile70", 70), ("profile100", 100)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme10PPayloadURateProfile.setReference('[802.3ah] Annex 62A.3.6, 30.5.1.1.20')
if mibBuilder.loadTexts: efmCuPme10PPayloadURateProfile.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PPayloadURateProfile.setDescription("10PASS-TS PME Upstream Payload Rate Profile, as specified in 802.3ah Annex 62A. Possible values are: profile5(5) - 2.5 Mbps profile10(10) - 5 Mbps profile15(15) - 7.5 Mbps profile20(20) - 10 Mbps profile25(25) - 12.5 Mbps profile30(30) - 15 Mbps profile50(50) - 25 Mbps profile70(70) - 35 Mbps profile100(100) - 50 Mbps Each value represents a target for the PME's Upstream Payload Bitrate as seen at the MII. If the payload rate of the selected profile cannot be achieved based on the loop environment, bandplan and PSD mask, the PME initialization SHALL fail. This object maps to the aPayloadRateProfileUpstream attribute in Clause 30.")
efmCuPme10PPayloadDRateProfile = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(5, 10, 15, 20, 25, 30, 50, 70, 100, 140, 200))).clone(namedValues=NamedValues(("profile5", 5), ("profile10", 10), ("profile15", 15), ("profile20", 20), ("profile25", 25), ("profile30", 30), ("profile50", 50), ("profile70", 70), ("profile100", 100), ("profile140", 140), ("profile200", 200)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme10PPayloadDRateProfile.setReference('[802.3ah] Annex 62A.3.6, 30.5.1.1.21')
if mibBuilder.loadTexts: efmCuPme10PPayloadDRateProfile.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PPayloadDRateProfile.setDescription("10PASS-TS PME Downstream Payload Rate Profile, as specified in 802.3ah Annex 62A. Possible values are: profile5(5) - 2.5 Mbps profile10(10) - 5 Mbps profile15(15) - 7.5 Mbps profile20(20) - 10 Mbps profile25(25) - 12.5 Mbps profile30(30) - 15 Mbps profile50(50) - 25 Mbps profile70(70) - 35 Mbps profile100(100) - 50 Mbps profile140(140) - 70 Mbps profile200(200) - 100 Mbps Each value represents a target for the PME's Downstream Payload Bitrate as seen at the MII. If the payload rate of the selected profile cannot be achieved based on the loop environment, bandplan and PSD mask, the PME initialization SHALL fail. This object maps to the aPayloadRateProfileDownstream attribute in Clause 30.")
efmCuPme10PProfileRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 1, 1, 8), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: efmCuPme10PProfileRowStatus.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PProfileRowStatus.setDescription("This object controls creation/deletion of the associated entry in efmCuPme10PProfileTable per the semantics of RowStatus. If an active entry is referenced via efmCuAdminProfile or efmCuPmeAdminProfile, the entry MUST remain 'active' until all references are removed.")
efmCuPme10PStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 2), )
if mibBuilder.loadTexts: efmCuPme10PStatusTable.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PStatusTable.setDescription('Table reflecting status of EFMCu 10PASS-TS PMEs (modems).')
efmCuPme10PStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 2, 1), )
efmCuPmeStatusEntry.registerAugmentions(("EFM-CU-MIB", "efmCuPme10PStatusEntry"))
efmCuPme10PStatusEntry.setIndexNames(*efmCuPmeStatusEntry.getIndexNames())
if mibBuilder.loadTexts: efmCuPme10PStatusEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PStatusEntry.setDescription('An entry in the EFMCu 10PASS-TS PME Status table.')
efmCuPme10PElectricalLength = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(0, 8192), ValueRangeConstraint(65535, 65535), ))).setUnits('m').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPme10PElectricalLength.setReference('[802.3ah] 45.2.1.21')
if mibBuilder.loadTexts: efmCuPme10PElectricalLength.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PElectricalLength.setDescription('Electrical Length in meters as perceived by the 10PASS-TS PME after the link is established. The value of 65535 is returned if the link is Down or Initializing or the PME is unable to estimate the Electrical Length. If a Clause 45 MDIO Interface to the PME is present, then this object maps to the 10P Electrical Length register')
efmCuPme10PFECCorrectedBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPme10PFECCorrectedBlocks.setReference('[802.3ah] 45.2.1.22')
if mibBuilder.loadTexts: efmCuPme10PFECCorrectedBlocks.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PFECCorrectedBlocks.setDescription('A count of received and corrected FEC codewords in 10PASS-TS PME. This object maps to aPMEFECCorrectedBlocks attribute in clause 30. If a Clause 45 MDIO Interface to the PMA/PMD is present, then this object maps to the 10P FEC correctable errors register')
efmCuPme10PFECUncorrectedBlocks = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 2, 6, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuPme10PFECUncorrectedBlocks.setReference('[802.3ah] 45.2.1.23')
if mibBuilder.loadTexts: efmCuPme10PFECUncorrectedBlocks.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PFECUncorrectedBlocks.setDescription('A count of received FEC codewords in 10PASS-TS PME, which are uncorrectable. This object maps to aPMEFECUncorrectableBlocks attribute in clause 30. If a Clause 45 MDIO Interface to the PMA/PMD is present, then this object maps to the 10P FEC uncorrectable errors register')
ifAvailableStackTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 3), )
if mibBuilder.loadTexts: ifAvailableStackTable.setReference('ifStackTable of RFC 2863')
if mibBuilder.loadTexts: ifAvailableStackTable.setStatus('current')
if mibBuilder.loadTexts: ifAvailableStackTable.setDescription("This table, modeled after ifStackTable from [IF-MIB], contains information on the possible 'on-top-of' relationships between the multiple sub-layers of network interfaces (as opposed to actual relationships in ifStackTable). In particular, it contains information on which PCS ports (sublayers) can possibly run 'on top of' which PMEs (sublayers), as determined by cross-connect capability of the EFMCu device, where each sub-layer corresponds to a conceptual row in the ifTable. For example, when the PCS port with ifIndex value x can be connected to run on top of the PME with ifIndex value y, then this table contains: ifAvailableStackStatus.x.y=capable Note that there's always at least on PCS for each PME and at least one PME for each PCS in the EFMCu devices, with efmCuPAFCapacity and efmCuPeerPAFCapacity indicating maximum number of PMEs which can be aggregated by local and remote PCS port respectively. This table is read only as it describes device capability")
ifAvailableStackEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 3, 1), ).setIndexNames((0, "EFM-CU-MIB", "ifAvailableStackHigherLayer"), (0, "EFM-CU-MIB", "ifAvailableStackLowerLayer"))
if mibBuilder.loadTexts: ifAvailableStackEntry.setStatus('current')
if mibBuilder.loadTexts: ifAvailableStackEntry.setDescription("Information on a particular relationship between two sub-layers, specifying that one sub-layer (PCS) runs on 'top' of the other sub-layer (PME). Each sub-layer corresponds to a conceptual row in the ifTable (interface index for PCS and PME respectively).")
ifAvailableStackHigherLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 3, 1, 1), InterfaceIndex())
if mibBuilder.loadTexts: ifAvailableStackHigherLayer.setStatus('current')
if mibBuilder.loadTexts: ifAvailableStackHigherLayer.setDescription("The value of ifIndex corresponding to the higher sub-layer of the 'cross-connect capability' relationship, i.e., the PCS sub-layer which MAY run on 'top' of the PME sub-layer identified by the corresponding instance of ifAvailableStackLowerLayer.")
ifAvailableStackLowerLayer = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 3, 1, 2), InterfaceIndex())
if mibBuilder.loadTexts: ifAvailableStackLowerLayer.setStatus('current')
if mibBuilder.loadTexts: ifAvailableStackLowerLayer.setDescription("The value of ifIndex corresponding to the lower sub-layer of the 'cross-connect capability' relationship, i.e., the PME sub-layer which MAY run 'below' the PCS sub-layer identified by the corresponding instance of ifAvailableStackHigherLayer.")
ifAvailableStackStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("capable", 1), ("outOfService", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifAvailableStackStatus.setStatus('current')
if mibBuilder.loadTexts: ifAvailableStackStatus.setDescription("The status of the 'cross-connect capability' relationship between two sub-layers. The following values are defined: capable(1) - the PME sub-layer interface, identified by the ifAvailableStackLowerLayer MAY be connected to run 'below' the PCS sub-layer interface, identified by the ifAvailableStackLowerLayer. outOfService(2) - the PME sub-layer interface cannot be connected due to unavailability of the interface. Note that PME availability per PCS, indicated by 'capable' value, can be constrained by other parameters, for example by aggregation capacity of a PCS or by the PME in question being already connected to another PCS. So, in order to ensure that a particular PME can be connected to the PCS, all respective parameters (e.g. ifAvailableStackTable, ifStackTable and efmCuPAFCapacity) SHALL be inspected. This object is read only, unlike ifStackStatus, as it describes the device capability.")
efmCuRegeneratorStats = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4))
efmCuRegeneratorStatusTable = MibTable((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1), )
if mibBuilder.loadTexts: efmCuRegeneratorStatusTable.setStatus('current')
if mibBuilder.loadTexts: efmCuRegeneratorStatusTable.setDescription('Each EFMCu Regenerator Status table contains performance status aspects of SHDSL modems for nodes on a span of SHDSL regenerators connected to an EFMCu SHDSL port. This table contains live data from the equipment. As such, it is NOT persistent.')
efmCuRegeneratorStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"), (0, "EFM-CU-MIB", "efmCuRegenIndex"), (0, "EFM-CU-MIB", "efmCuRegenSide"))
if mibBuilder.loadTexts: efmCuRegeneratorStatusEntry.setStatus('current')
if mibBuilder.loadTexts: efmCuRegeneratorStatusEntry.setDescription('This is an entry in the EFMCu Regenerator Status table. Each entry contains performance status aspects of a particular SHDSL modem for a node on a span of SHDSL regenerators connected to an EFMCu SHDSL port. Each entry is indexed by the ifIndex, the address of the node and if the modem at the node is on the network or customer side of the node. The LTU-C is the CO node and it has no network side modem. The LTU-R is the CPE node and it has no customer side modem. All regenerators 1-8 have both network and customer side modems.')
efmCuRegenIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("ltu-c", 1), ("ltu-r", 2), ("regenerator-1", 3), ("regenerator-2", 4), ("regenerator-3", 5), ("regenerator-4", 6), ("regenerator-5", 7), ("regenerator-6", 8), ("regenerator-7", 9), ("regenerator-8", 10)))).setUnits('Address')
if mibBuilder.loadTexts: efmCuRegenIndex.setReference('ITU G.991.2 9.5.5.5 Unit Addresses')
if mibBuilder.loadTexts: efmCuRegenIndex.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenIndex.setDescription('The unit address of the regenerator node in the SHDSL span. 1 = STU C (CO) 2 = STU R (CPE) 3 through 10 = Regenerators 1 - 8')
efmCuRegenSide = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("network", 1), ("customer", 2)))).setUnits('Side')
if mibBuilder.loadTexts: efmCuRegenSide.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenSide.setDescription('Specification if the modem is on the network or customer side of the node. Repeaters have both network (up stream) and customer (down stream) facing modems. The CO only has a customer facing modem. The CPE only has a network facing modem.')
efmCuRegenSNR = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 3), Integer32()).setUnits('tenths of dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenSNR.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenSNR.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenSNR.setDescription('The current SHDSL Signal-to-Noise Ratio (SNR) margin with respect to the received signal as perceived by the specific SHDSL modem in the span. The value is reported in tenths of a dB. A value of 65535 is returned when the port is down.')
efmCuRegenLineAttn = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 4), Integer32()).setUnits('tenths of dB').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenLineAttn.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenLineAttn.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenLineAttn.setDescription('The current SHDSL Line Attenuation as perceived by the specific SHDSL modem in the span. The value is reported in tenths of a dB. A value of 65535 is returned when the port is down.')
efmCuRegenCRC = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 5), Counter32()).setUnits('Errors').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenCRC.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenCRC.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenCRC.setDescription('The current SHDSL count of CRC Anomalies as perceived by the specific SHDSL modem in the span. This value is reset when the port is down.')
efmCuRegenES = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 6), Counter32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenES.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenES.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenES.setDescription('The current SHDSL count of Errored Seconds as perceived by the specific SHDSL modem in the span. This value is reset when the port is down.')
efmCuRegenSES = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 7), Counter32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenSES.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenSES.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenSES.setDescription('The current SHDSL count of Severely Errored Seconds as perceived by the specific SHDSL modem in the span. This value is reset when the port is down.')
efmCuRegenUAS = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 8), Counter32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenUAS.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenUAS.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenUAS.setDescription('The current SHDSL count of Unavailable Seconds as perceived by the specific SHDSL modem in the span. This value is reset when the port is down.')
efmCuRegenLOSWS = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 9), Counter32()).setUnits('Seconds').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenLOSWS.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenLOSWS.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenLOSWS.setDescription('The current SHDSL Loss of Sync Word Second (LOSWS) defect count as perceived by the specific SHDSL modem in the span. This value is reset when the port is down. ')
efmCuRegenDCAlarm = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setUnits('Alarm').setMaxAccess("readonly")
if mibBuilder.loadTexts: efmCuRegenDCAlarm.setReference('ITU G.991.2 9.5.5.7.14 SHDSL Network Side Performance Status')
if mibBuilder.loadTexts: efmCuRegenDCAlarm.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenDCAlarm.setDescription('The DC Continuity Fault indicator. This is used to indicate conditions that interfere with span powering such as shorts and open circuits. A value of No is returned when the port is down or initializing.')
efmCuRegenClearCounts = MibTableColumn((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 1, 4, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normalCounts", 1), ("clearCounts", 2))).clone('normalCounts')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: efmCuRegenClearCounts.setStatus('current')
if mibBuilder.loadTexts: efmCuRegenClearCounts.setDescription('This leaf is used to clear SHDSL Regenerator Status counters. When the value is set to clearCounts (2) the stats are cleared for this SHDSL port, regenerator node address, and modem side. Once the stats have been cleared a read of this entry returns the value for normalCounts (1). The only valid user settable value is clearCounts and when set the following counts are cleared: SHDSL count of CRC Anomalies SHDSL count of Errored Seconds SHDSL count of Severely Errored Seconds SHDSL count of Unavailable Seconds SHDSL Loss of Sync Word Second (LOSWS) defect count')
efmCuGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1))
efmCuCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 2))
efmCuBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 1)).setObjects(("EFM-CU-MIB", "efmCuPAFSupported"), ("EFM-CU-MIB", "efmCuAdminProfile"), ("EFM-CU-MIB", "efmCuTargetDataRate"), ("EFM-CU-MIB", "efmCuTargetWorstCaseSnrMgn"), ("EFM-CU-MIB", "efmCuPortSide"), ("EFM-CU-MIB", "efmCuFltStatus"), ("EFM-CU-MIB", "efmCuTargetCurrentConditionMode"), ("EFM-CU-MIB", "efmCuTargetCurrentConditionSnrMgn"), ("EFM-CU-MIB", "efmCuTargetWorstCaseMode"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuBasicGroup = efmCuBasicGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuBasicGroup.setDescription('A collection of objects required for all of EFMCu ports.')
efmCuPAFGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 2)).setObjects(("EFM-CU-MIB", "efmCuPeerPAFSupported"), ("EFM-CU-MIB", "efmCuPAFCapacity"), ("EFM-CU-MIB", "efmCuPeerPAFCapacity"), ("EFM-CU-MIB", "efmCuPAFAdminState"), ("EFM-CU-MIB", "efmCuPAFDiscoveryCode"), ("EFM-CU-MIB", "efmCuPAFRemoteDiscoveryCode"), ("EFM-CU-MIB", "efmCuNumPMEs"), ("EFM-CU-MIB", "ifAvailableStackStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuPAFGroup = efmCuPAFGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFGroup.setDescription('A collection of objects required for optional PME Aggregation Function (PAF) and PAF discovery in EFMCu ports.')
ifStackCapabilityGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 3)).setObjects(("EFM-CU-MIB", "ifAvailableStackStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    ifStackCapabilityGroup = ifStackCapabilityGroup.setStatus('current')
if mibBuilder.loadTexts: ifStackCapabilityGroup.setDescription('A collection of objects providing information on the stacking capability of MIB-II interfaces.')
efmCuPAFErrorsGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 4)).setObjects(("EFM-CU-MIB", "efmCuPAFInErrors"), ("EFM-CU-MIB", "efmCuPAFInSmallFragments"), ("EFM-CU-MIB", "efmCuPAFInLargeFragments"), ("EFM-CU-MIB", "efmCuPAFInBadFragments"), ("EFM-CU-MIB", "efmCuPAFInLostFragments"), ("EFM-CU-MIB", "efmCuPAFInLostStarts"), ("EFM-CU-MIB", "efmCuPAFInLostEnds"), ("EFM-CU-MIB", "efmCuPAFInOverflows"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuPAFErrorsGroup = efmCuPAFErrorsGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuPAFErrorsGroup.setDescription('A collection of objects supporting optional error counters of PAF on EFMCu ports.')
efmCuPmeGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 5)).setObjects(("EFM-CU-MIB", "efmCuPmeAdminProfile"), ("EFM-CU-MIB", "efmCuPmeOperStatus"), ("EFM-CU-MIB", "efmCuPmeFltStatus"), ("EFM-CU-MIB", "efmCuPmeSubTypesSupported"), ("EFM-CU-MIB", "efmCuPmeAdminSubType"), ("EFM-CU-MIB", "efmCuPmeOperSubType"), ("EFM-CU-MIB", "efmCuPAFRemoteDiscoveryCode"), ("EFM-CU-MIB", "efmCuPmeOperProfile"), ("EFM-CU-MIB", "efmCuPmeSnrMgn"), ("EFM-CU-MIB", "efmCuPmePeerSnrMgn"), ("EFM-CU-MIB", "efmCuPmeLineAtn"), ("EFM-CU-MIB", "efmCuPmePeerLineAtn"), ("EFM-CU-MIB", "efmCuPmeTCCodingErrors"), ("EFM-CU-MIB", "efmCuPmeTCCrcErrors"), ("EFM-CU-MIB", "efmCuPmeThreshLineAtn"), ("EFM-CU-MIB", "efmCuPmeThreshMinSnrMgn"), ("EFM-CU-MIB", "efmCuPmeThreshMaxSnrMgnDelta"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuPmeGroup = efmCuPmeGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuPmeGroup.setDescription('A collection of objects providing information about a 2BASE-TL/10PASS-TS PME.')
efmCuAlarmConfGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 6)).setObjects(("EFM-CU-MIB", "efmCuThreshLowBandwidth"), ("EFM-CU-MIB", "efmCuLowBandwidthEnable"), ("EFM-CU-MIB", "efmCuPmeThreshLineAtn"), ("EFM-CU-MIB", "efmCuPmeLineAtnCrossingEnable"), ("EFM-CU-MIB", "efmCuPmeThreshMinSnrMgn"), ("EFM-CU-MIB", "efmCuPmeSnrMgnCrossingTrapEnable"), ("EFM-CU-MIB", "efmCuPmeLineAtnCrossingEnable"), ("EFM-CU-MIB", "efmCuPmeDeviceFaultEnable"), ("EFM-CU-MIB", "efmCuPmeConfigInitFailEnable"), ("EFM-CU-MIB", "efmCuPmeProtocolInitFailEnable"), ("EFM-CU-MIB", "efmCuPmeThreshMaxSnrMgnDelta"), ("EFM-CU-MIB", "efmCuPmeMaintenanceMode"), ("EFM-CU-MIB", "efmCuPmeMaintenanceStartTime"), ("EFM-CU-MIB", "efmCuPmeMaintenanceEndTime"), ("EFM-CU-MIB", "efmCuPmeSnrMonitoringInterval"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuAlarmConfGroup = efmCuAlarmConfGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuAlarmConfGroup.setDescription('A collection of objects required for configuration of alarm thresholds and notifications in EFMCu ports.')
efmCuNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 7)).setObjects(("EFM-CU-MIB", "efmCuLowBandwidth"), ("EFM-CU-MIB", "efmCuPmeLineAtnCrossing"), ("EFM-CU-MIB", "efmCuPmeSnrMgnCrossing"), ("EFM-CU-MIB", "efmCuPmeDeviceFault"), ("EFM-CU-MIB", "efmCuPmeConfigInitFailure"), ("EFM-CU-MIB", "efmCuPmeProtocolInitFailure"), ("EFM-CU-MIB", "efmCuPmeSnrMgnCrossingClear"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuNotificationGroup = efmCuNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuNotificationGroup.setDescription('This group supports notifications of significant conditions associated with EFMCu ports.')
efmCuPme2BProfileGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 8)).setObjects(("EFM-CU-MIB", "efmCuPme2BProfileDescr"), ("EFM-CU-MIB", "efmCuPme2BRegion"), ("EFM-CU-MIB", "efmCuPme2BDataRate"), ("EFM-CU-MIB", "efmCuPme2BPower"), ("EFM-CU-MIB", "efmCuPme2BConstellation"), ("EFM-CU-MIB", "efmCuPme2BProfileRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuPme2BProfileGroup = efmCuPme2BProfileGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuPme2BProfileGroup.setDescription('A collection of objects that constitute a configuration profile for configuration of 2BASE-TL ports.')
efmCuPme10PProfileGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 9)).setObjects(("EFM-CU-MIB", "efmCuPme10PProfileDescr"), ("EFM-CU-MIB", "efmCuPme10PBandplanPSDMskProfile"), ("EFM-CU-MIB", "efmCuPme10PUPBOReferenceProfile"), ("EFM-CU-MIB", "efmCuPme10PBandNotchProfiles"), ("EFM-CU-MIB", "efmCuPme10PPayloadURateProfile"), ("EFM-CU-MIB", "efmCuPme10PPayloadDRateProfile"), ("EFM-CU-MIB", "efmCuPme10PProfileRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuPme10PProfileGroup = efmCuPme10PProfileGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PProfileGroup.setDescription('A collection of objects that constitute a configuration profile for configuration of 10PASS-TS ports.')
efmCuPme10PStatusGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 1, 10)).setObjects(("EFM-CU-MIB", "efmCuPme10PElectricalLength"), ("EFM-CU-MIB", "efmCuPme10PFECCorrectedBlocks"), ("EFM-CU-MIB", "efmCuPme10PFECUncorrectedBlocks"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuPme10PStatusGroup = efmCuPme10PStatusGroup.setStatus('current')
if mibBuilder.loadTexts: efmCuPme10PStatusGroup.setDescription('A collection of objects providing status information specific to 10PASS-TS PMEs.')
efmCuCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 5504, 10, 1, 7, 2, 2, 1)).setObjects(("EFM-CU-MIB", "efmCuBasicGroup"), ("EFM-CU-MIB", "efmCuPmeGroup"), ("EFM-CU-MIB", "efmCuAlarmConfGroup"), ("EFM-CU-MIB", "efmCuNotificationGroup"), ("EFM-CU-MIB", "efmCuPme2BProfileGroup"), ("EFM-CU-MIB", "efmCuPme10PProfileGroup"), ("EFM-CU-MIB", "efmCuPAFGroup"), ("EFM-CU-MIB", "ifStackCapabilityGroup"), ("EFM-CU-MIB", "efmCuPAFErrorsGroup"), ("EFM-CU-MIB", "efmCuPme10PStatusGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    efmCuCompliance = efmCuCompliance.setStatus('current')
if mibBuilder.loadTexts: efmCuCompliance.setDescription('The compliance statement for 2BASE-TL/10PASS-TS interfaces. Compliance with the following external compliance statements is prerequisite: MIB Module Compliance Statement ---------- -------------------- IF-MIB ifCompliance3 IF-INVERTED-STACK-MIB ifInvCompliance EtherLike-MIB dot3Compliance2 MAU-MIB mauModIfCompl3')
mibBuilder.exportSymbols("EFM-CU-MIB", efmCuPAFCapacity=efmCuPAFCapacity, efmCuRegenClearCounts=efmCuRegenClearCounts, efmCuPme2BProfileEntry=efmCuPme2BProfileEntry, efmCuRegeneratorStats=efmCuRegeneratorStats, efmCuPme10PStatusGroup=efmCuPme10PStatusGroup, efmCuRegenDCAlarm=efmCuRegenDCAlarm, efmCuPme10PStatusEntry=efmCuPme10PStatusEntry, efmCuPmeFltStatus=efmCuPmeFltStatus, efmCuPAFSupported=efmCuPAFSupported, efmCuPme10PElectricalLength=efmCuPme10PElectricalLength, efmCuPeerPAFCapacity=efmCuPeerPAFCapacity, efmCuPAFInSmallFragments=efmCuPAFInSmallFragments, efmCuPme2BProfileGroup=efmCuPme2BProfileGroup, efmCuRegenSide=efmCuRegenSide, efmCuPmeErrorThreshMonEnable=efmCuPmeErrorThreshMonEnable, efmCuTargetCurrentConditionSnrMgn=efmCuTargetCurrentConditionSnrMgn, efmCuPmeErrorThreshMonClrInterval=efmCuPmeErrorThreshMonClrInterval, efmCuPme10PFECUncorrectedBlocks=efmCuPme10PFECUncorrectedBlocks, efmCuPmeErrorThreshMonNotifyEnable=efmCuPmeErrorThreshMonNotifyEnable, efmCuPmeSnrMgn=efmCuPmeSnrMgn, efmCuPme2BProfileRowStatus=efmCuPme2BProfileRowStatus, efmCuPort=efmCuPort, efmCuPme10PUPBOReferenceProfile=efmCuPme10PUPBOReferenceProfile, efmCuPmeThreshMinSnrMgn=efmCuPmeThreshMinSnrMgn, efmCuPmeBondGroupTrafficEnabled=efmCuPmeBondGroupTrafficEnabled, efmCuPmeDeviceFaultEnable=efmCuPmeDeviceFaultEnable, efmCuPmeSnrMgnCrossing=efmCuPmeSnrMgnCrossing, efmCuPmeThreshMaxSnrMgnDelta=efmCuPmeThreshMaxSnrMgnDelta, efmCuRegenSES=efmCuRegenSES, efmCuPmeSubTypesSupported=efmCuPmeSubTypesSupported, efmCuCompliances=efmCuCompliances, efmCuObjects=efmCuObjects, efmCuPAFGroup=efmCuPAFGroup, efmCuPmeSnrRestartCnt=efmCuPmeSnrRestartCnt, efmCuPAFInLargeFragments=efmCuPAFInLargeFragments, TruthValueOrUnknown=TruthValueOrUnknown, efmCuPmeAdminSubType=efmCuPmeAdminSubType, ifAvailableStackEntry=ifAvailableStackEntry, efmCuPmeConfEntry=efmCuPmeConfEntry, efmCuPmeErrorThreshEfmTrafficEnable=efmCuPmeErrorThreshEfmTrafficEnable, ifAvailableStackHigherLayer=ifAvailableStackHigherLayer, efmCuBasicGroup=efmCuBasicGroup, efmCuPmePeerSnrMgn=efmCuPmePeerSnrMgn, efmCuPme2BProfileIndex=efmCuPme2BProfileIndex, efmCuPmeStatusTable=efmCuPmeStatusTable, efmCuPme2BProfileDescr=efmCuPme2BProfileDescr, efmCuPmeLineAtnCrossing=efmCuPmeLineAtnCrossing, efmCuRegeneratorStatusTable=efmCuRegeneratorStatusTable, efmCuPmeErrorConsecutiveSec=efmCuPmeErrorConsecutiveSec, ProfileIndexOrZero=ProfileIndexOrZero, efmCuPmeOperProfile=efmCuPmeOperProfile, efmCuRegenSNR=efmCuRegenSNR, efmCuPmeProtocolInitFailEnable=efmCuPmeProtocolInitFailEnable, efmCuPmeLineAtnCrossingEnable=efmCuPmeLineAtnCrossingEnable, efmCuPme10PProfileEntry=efmCuPme10PProfileEntry, efmCuPme10PProfileDescr=efmCuPme10PProfileDescr, efmCuPmeStatusEntry=efmCuPmeStatusEntry, efmCuPAFErrorsGroup=efmCuPAFErrorsGroup, efmCuLowBandwidth=efmCuLowBandwidth, efmCuPmeMaintenanceEndTime=efmCuPmeMaintenanceEndTime, efmCuPAFAdminState=efmCuPAFAdminState, efmCuPme2BConstellation=efmCuPme2BConstellation, efmCuPme2BProfileTable=efmCuPme2BProfileTable, efmCuPmeErrorThreshMonInterval=efmCuPmeErrorThreshMonInterval, efmCuPmeErrorRestartCnt=efmCuPmeErrorRestartCnt, efmCuPmeTCCodingErrors=efmCuPmeTCCodingErrors, efmCuPmeErrorMaxConsecutiveSec=efmCuPmeErrorMaxConsecutiveSec, efmCuPAFInBadFragments=efmCuPAFInBadFragments, efmCuPmeSnrMgnCrossingClear=efmCuPmeSnrMgnCrossingClear, efmCuPmeLinkTrafficEnabled=efmCuPmeLinkTrafficEnabled, efmCuPAFInErrors=efmCuPAFInErrors, efmCuPAFRemoteDiscoveryCode=efmCuPAFRemoteDiscoveryCode, efmCuPmeSnrCrossingCnt=efmCuPmeSnrCrossingCnt, ifAvailableStackStatus=ifAvailableStackStatus, efmCuPme10PProfileRowStatus=efmCuPme10PProfileRowStatus, efmCuPme2B=efmCuPme2B, efmCuRegenES=efmCuRegenES, efmCuPmeMaintenanceStartTime=efmCuPmeMaintenanceStartTime, efmCuRegenIndex=efmCuRegenIndex, efmCuPmeCapabilityTable=efmCuPmeCapabilityTable, efmCuPmeTCDownCnt=efmCuPmeTCDownCnt, efmCuPmeSnrMonitoringInterval=efmCuPmeSnrMonitoringInterval, efmCuFltStatus=efmCuFltStatus, efmCuPortSide=efmCuPortSide, efmCuPme10PPayloadURateProfile=efmCuPme10PPayloadURateProfile, efmCuTargetDataRate=efmCuTargetDataRate, efmCuPmeCapabilityEntry=efmCuPmeCapabilityEntry, efmCuPAFDiscoveryCode=efmCuPAFDiscoveryCode, efmCuPmeErrorTCDownCnt=efmCuPmeErrorTCDownCnt, efmCuPme2BRegion=efmCuPme2BRegion, efmCuPme=efmCuPme, efmCuPAFInOverflows=efmCuPAFInOverflows, efmCuAlarmConfGroup=efmCuAlarmConfGroup, efmCuPmeDeviceFault=efmCuPmeDeviceFault, efmCuPmeConfigInitFailure=efmCuPmeConfigInitFailure, efmCuRegeneratorStatusEntry=efmCuRegeneratorStatusEntry, efmCuPme10PFECCorrectedBlocks=efmCuPme10PFECCorrectedBlocks, efmCuAdminProfile=efmCuAdminProfile, efmCuPme2BDataRate=efmCuPme2BDataRate, efmCuPmeTCCrcErrors=efmCuPmeTCCrcErrors, efmCuPmeThreshLineAtn=efmCuPmeThreshLineAtn, efmCuPmeSnrClearStats=efmCuPmeSnrClearStats, ProfileIndexList=ProfileIndexList, PYSNMP_MODULE_ID=efmCuMIB, efmCuPmeMaintenanceMode=efmCuPmeMaintenanceMode, efmCuPmeLineAtn=efmCuPmeLineAtn, efmCuPAFInLostEnds=efmCuPAFInLostEnds, efmCuPmeNotifications=efmCuPmeNotifications, efmCuPmeConfigInitFailEnable=efmCuPmeConfigInitFailEnable, efmCuPmeAdminProfile=efmCuPmeAdminProfile, ifStackCapabilityGroup=ifStackCapabilityGroup, efmCuPmeOperSubType=efmCuPmeOperSubType, efmCuPmeErrorClearStats=efmCuPmeErrorClearStats, efmCuPmeSnrMgnCrossingTrapEnable=efmCuPmeSnrMgnCrossingTrapEnable, efmCuPmeConfTable=efmCuPmeConfTable, efmCuPmeOperStatus=efmCuPmeOperStatus, efmCuPmeGroup=efmCuPmeGroup, efmCuPme10PProfileGroup=efmCuPme10PProfileGroup, efmCuPmeBondGroupTrafficDisabled=efmCuPmeBondGroupTrafficDisabled, efmCuPAFAutoDiscovery=efmCuPAFAutoDiscovery, efmCuPmeNtr=efmCuPmeNtr, efmCuPme10PBandNotchProfiles=efmCuPme10PBandNotchProfiles, efmCuRegenLineAttn=efmCuRegenLineAttn, efmCuPortCapabilityTable=efmCuPortCapabilityTable, efmCuThreshLowBandwidth=efmCuThreshLowBandwidth, ifAvailableStackLowerLayer=ifAvailableStackLowerLayer, efmCuPortConfEntry=efmCuPortConfEntry, efmCuLowBandwidthEnable=efmCuLowBandwidthEnable, efmCuPmePeerLineAtn=efmCuPmePeerLineAtn, efmCuMIB=efmCuMIB, efmCuPme10P=efmCuPme10P, efmCuPortConfTable=efmCuPortConfTable, ifAvailableStackTable=ifAvailableStackTable, efmCuPme10PBandplanPSDMskProfile=efmCuPme10PBandplanPSDMskProfile, efmCuRegenUAS=efmCuRegenUAS, efmCuPme10PStatusTable=efmCuPme10PStatusTable, ProfileIndex=ProfileIndex, efmCuPortNotifications=efmCuPortNotifications, efmCuTargetCurrentConditionMode=efmCuTargetCurrentConditionMode, efmCuPAFInLostStarts=efmCuPAFInLostStarts, efmCuPortCapabilityEntry=efmCuPortCapabilityEntry, efmCuTargetWorstCaseMode=efmCuTargetWorstCaseMode, efmCuRegenLOSWS=efmCuRegenLOSWS, efmCuPeerPAFSupported=efmCuPeerPAFSupported, efmCuNotificationGroup=efmCuNotificationGroup, efmCuPortStatusEntry=efmCuPortStatusEntry, efmCuPmeErrorThreshEfmTrafficDisable=efmCuPmeErrorThreshEfmTrafficDisable, efmCuPAFInLostFragments=efmCuPAFInLostFragments, efmCuPme2BPower=efmCuPme2BPower, efmCuPmeLinkTrfcDisablTrapEnable=efmCuPmeLinkTrfcDisablTrapEnable, efmCuConformance=efmCuConformance, efmCuPme10PPayloadDRateProfile=efmCuPme10PPayloadDRateProfile, efmCuPme10PProfileTable=efmCuPme10PProfileTable, efmCuRegenCRC=efmCuRegenCRC, efmCuCompliance=efmCuCompliance, efmCuGroups=efmCuGroups, efmCuPmeProtocolInitFailure=efmCuPmeProtocolInitFailure, efmCuPme10PProfileIndex=efmCuPme10PProfileIndex, efmCuPmeLinkTrafficDisabled=efmCuPmeLinkTrafficDisabled, efmCuNumPMEs=efmCuNumPMEs, efmCuTargetWorstCaseSnrMgn=efmCuTargetWorstCaseSnrMgn, efmCuPortStatusTable=efmCuPortStatusTable)

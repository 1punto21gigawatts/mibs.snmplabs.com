#
# PySNMP MIB module LOAD-BAL-SYSTEM-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/LOAD-BAL-SYSTEM-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:08:46 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, SingleValueConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
ModuleIdentity, NotificationType, Bits, iso, MibScalar, MibTable, MibTableRow, MibTableColumn, Integer32, ObjectIdentity, Gauge32, Counter64, IpAddress, Unsigned32, MibIdentifier, enterprises, NotificationType, TimeTicks, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "ModuleIdentity", "NotificationType", "Bits", "iso", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Integer32", "ObjectIdentity", "Gauge32", "Counter64", "IpAddress", "Unsigned32", "MibIdentifier", "enterprises", "NotificationType", "TimeTicks", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
f5 = MibIdentifier((1, 3, 6, 1, 4, 1, 3375))
f5systems = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1))
loadbal = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1))
globals = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1))
virtualAddress = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2))
virtualServer = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3))
snat = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4))
interface = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5))
ifaddress = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6))
pool = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7))
poolMember = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8))
sslProxy = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9))
vlan = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10))
selfIP = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11))
trunk = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 12))
nodes = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13))
vaddress = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100))
ndaddr = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101))
nat = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102))
vport = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103))
member = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104))
loadBalTrap = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110))
loadBalTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2))
globalAttributes = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1))
globalStats = MibIdentifier((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2))
class DisplayString(OctetString):
    pass

class BigAPIStatus(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))
    namedValues = NamedValues(("unchecked", 0), ("up", 1), ("down", 2), ("forcedDown", 3), ("checking", 4), ("maintenance", 5), ("enabled", 6), ("disabled", 7), ("addressDisabled", 8), ("portDisabled", 9), ("addressDown", 10))

globalAttrKernelVersion = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrKernelVersion.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrKernelVersion.setDescription('The kernel version identifier.')
globalAttrPackageVersion = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrPackageVersion.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrPackageVersion.setDescription('The package version.')
globalAttrPackageEdition = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrPackageEdition.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrPackageEdition.setDescription('The package edition.')
globalAttrAgentVersion = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrAgentVersion.setStatus('deprecated')
if mibBuilder.loadTexts: globalAttrAgentVersion.setDescription('This OID has been deprecated.')
globalAttrProductCode = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 10, 99))).clone(namedValues=NamedValues(("indeterminate", 1), ("ha", 2), ("lb", 3), ("threedns", 4), ("flb", 5), ("clb", 6), ("xlb", 7), ("ssl", 8), ("test", 10), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrProductCode.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrProductCode.setDescription('The product identifier, possible values are HA, LB, 3-DNS, CLB, FLB, XLB, and SSL.')
globalAttrSerialNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSerialNumber.setDescription('The serial number of this system.')
globalAttrVendorName = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrVendorName.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrVendorName.setDescription('The name of the vendor of this system.')
globalAttrSSLGatewayLevel = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4, 5, 6, 7, 9, 10, 11, 99))).clone(namedValues=NamedValues(("none", 1), ("tps200", 3), ("tps400", 4), ("tps600", 5), ("tps800", 6), ("tps1000", 7), ("tps500", 9), ("tps1500", 10), ("tps2000", 11), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSSLGatewayLevel.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSSLGatewayLevel.setDescription('An integer describing transactions per second for the gateway. This OID does not apply to 3-DNS.')
globalAttrCPUCount = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrCPUCount.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrCPUCount.setDescription('Total number of CPUs in this system.')
globalAttrAuthorized = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrAuthorized.setStatus('deprecated')
if mibBuilder.loadTexts: globalAttrAuthorized.setDescription('This OID is deprecated.')
globalAttrMaintenceMode = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrMaintenceMode.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrMaintenceMode.setDescription('Describes whether this system is in maintenance mode; true = Yes, false = No.')
globalAttrMaster = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrMaster.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrMaster.setDescription('Describes fail-over state of this system; true = active, false = standby.')
globalAttrUnitID = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrUnitID.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrUnitID.setDescription('In a redundant system, the current unit identifier of this system.')
globalAttrPeerUnitID = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 14), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrPeerUnitID.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrPeerUnitID.setDescription("In a redundant system, the peer's unit identifier.")
globalAttrFastestMaxIdleTime = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrFastestMaxIdleTime.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrFastestMaxIdleTime.setDescription('A maximum time value used for load balancing to the fastest node. This OID does not apply to 3-DNS.')
globalAttrFastFlowActive = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrFastFlowActive.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrFastFlowActive.setDescription('Current fast flow state: possible values include off, on, and auto. This OID does not apply to 3-DNS.')
globalAttrGatewayFailsafeArmed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrGatewayFailsafeArmed.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrGatewayFailsafeArmed.setDescription('Gateway failsafe feature; true = armed, false = (XXX).')
globalAttrMemoryRebootPercent = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrMemoryRebootPercent.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrMemoryRebootPercent.setDescription('The percentage of memory available, which will reboot the system.')
globalAttrMirrorEnabled = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrMirrorEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrMirrorEnabled.setDescription('Describes the state of mirroring; true = enabled, false = disabled.')
globalAttrVerboseLogLevel = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrVerboseLogLevel.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrVerboseLogLevel.setDescription('A value describing the log level of error messages.')
globalAttrWatchDogArmed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrWatchDogArmed.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrWatchDogArmed.setDescription('Describes the state of watch dog; true = armed, false = disarmed.')
globalAttrAutoLastHop = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrAutoLastHop.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrAutoLastHop.setDescription('Describes the behavior of last hop pools; true = (XXX), false = (XXX). This OID does not apply to 3-DNS.')
globalAttrAkamaiConfigPort = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrAkamaiConfigPort.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrAkamaiConfigPort.setDescription('A port number of the Akamai feature used for configuration. This OID does not apply to 3-DNS.')
globalAttrNameSurferWebPort = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrNameSurferWebPort.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrNameSurferWebPort.setDescription('Port number for NameSurfer web access.')
globalAttrNameSurferZonePort = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrNameSurferZonePort.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrNameSurferZonePort.setDescription('Port number for NameSurfer zone access.')
globalAttrOpen3DNSPorts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrOpen3DNSPorts.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrOpen3DNSPorts.setDescription('States whether 3-DNS ports are open; true = open, false = not open.')
globalAttrOpenCorbaPorts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrOpenCorbaPorts.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrOpenCorbaPorts.setDescription('States whether Corba ports are open for traffic; true = open, false = not open.')
globalAttrOpenFTPPorts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrOpenFTPPorts.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrOpenFTPPorts.setDescription('States whether FTP ports are open for traffic; true = open, false = not open.')
globalAttrOpenRSHPorts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrOpenRSHPorts.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrOpenRSHPorts.setDescription('States whether RSH ports are open for traffic; true = open, false = not open.')
globalAttrOpenSSHPorts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrOpenSSHPorts.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrOpenSSHPorts.setDescription('States whether SSH port is open for traffic; true = open, false = not open.')
globalAttrOpenTelnetPorts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrOpenTelnetPorts.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrOpenTelnetPorts.setDescription('States whether telnet port is open for traffic; true = open, false = not open.')
globalAttrWebAdminPort = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 32), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrWebAdminPort.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrWebAdminPort.setDescription('Port number for web administration access.')
globalAttrPersistAcrossServices = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrPersistAcrossServices.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrPersistAcrossServices.setDescription('States whether all simple persistent connections from a client IP address that go to the same virtual address go to the same node; true = same node, false = same node not guaranteed. This OID does not apply to 3-DNS.')
globalAttrPersistAccrossVirtuals = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrPersistAccrossVirtuals.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrPersistAccrossVirtuals.setDescription('States whether all simple persistent connections from the client IP address are sent to the same node; true = same node, false = same node not guaranteed. This OID does not apply to 3-DNS.')
globalAttrPersistMapProxies = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrPersistMapProxies.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrPersistMapProxies.setDescription('States whether AOL proxy addresses are used; true = used, false = not used. This OID does not apply to 3-DNS.')
globalAttrPersistTimerUsedAsLimit = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrPersistTimerUsedAsLimit.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrPersistTimerUsedAsLimit.setDescription('States whether persist timer is reset on each packet; true = reset, false = not reset. This OID does not apply to 3-DNS.')
globalAttrStickyTableLimit = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrStickyTableLimit.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrStickyTableLimit.setDescription('The maximum number of entries allowed in the sticky table. This OID does not apply to 3-DNS.')
globalAttrSNATConnLimit = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSNATConnLimit.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSNATConnLimit.setDescription('A global SNAT connection limit, if zero then unlimited connections. This OID does not apply to 3-DNS.')
globalAttrSNATTCPIdleTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSNATTCPIdleTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSNATTCPIdleTimeout.setDescription('SNAT global TCP timeout value in seconds.(XXX-seconds?) This OID does not apply to 3-DNS.')
globalAttrSNATUDPIdleTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSNATUDPIdleTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSNATUDPIdleTimeout.setDescription('SNAT global UDP timeout value in seconds. (XXX-seconds?). This OID does not apply to 3-DNS.')
globalAttrSystemType = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 41), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 99))).clone(namedValues=NamedValues(("serverappliance", 1), ("d25", 2), ("d30", 3), ("f35", 4), ("dell", 5), ("d35", 6), ("applicationswitch", 7), ("d50", 8), ("d45", 9), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSystemType.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSystemType.setDescription('Hardware type of this system.')
globalAttrNetReboot = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 42), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("notAvailable", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrNetReboot.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrNetReboot.setDescription('States whether this system will attempt a network reboot first; true = attempt network reboot, false = do not attempt network reboot, notAvailable = network reboot is not available on this platform.')
globalAttrQuietBoot = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 43), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrQuietBoot.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrQuietBoot.setDescription('States whether boot messages will be suppressed during a reboot of this system; true = quiet, false = not quiet.')
globalAttrL2CacheTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrL2CacheTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrL2CacheTimeout.setDescription('The layer 2 cache timeout value for this BIG-IP in seconds. This OID does not apply to 3-DNS.')
globalAttrSSLProxyFailOver = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 45), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSSLProxyFailOver.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSSLProxyFailOver.setDescription('States whether this BIG-IP will fail over on a fatal crypto accelerator error; true = fail over, false = do not fail over. This OID does not apply to 3-DNS.')
globalAttrAkamaiConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 46), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrAkamaiConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrAkamaiConfigFile.setDescription('The file path for the Akamai configuration file on this BIG-IP. This OID does not apply to 3-DNS.')
globalAttrSSLProxyServerSessionTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSSLProxyServerSessionTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSSLProxyServerSessionTimeout.setDescription('The session cache timeout value in seconds that proxyd will use for its server-side session cache. This will be set to the same value used by back-end servers for server-side SSL connections from the proxy. This OID does not apply to 3-DNS.')
globalAttrSSLProxyServerSessionCacheSize = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSSLProxyServerSessionCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSSLProxyServerSessionCacheSize.setDescription('The maximum session cache size that proxyd will use for the server-side session cache. This OID does not apply to 3-DNS.')
globalAttrIPForwarding = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 49), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrIPForwarding.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrIPForwarding.setDescription('States whether unknown packets will be forwarded to the gateway; true = forward, false = do not forward. This OID does not apply to 3-DNS.')
globalAttrSSLProxyUncleanShutdown = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 50), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSSLProxyUncleanShutdown.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSSLProxyUncleanShutdown.setDescription('Should the SSL proxy shut down SSL connections uncleanly (closing TCP connection without exchanging SSL shutdown alerts)? This OID does not apply to 3-DNS.')
globalAttrSSLProxyStrictResume = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 51), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSSLProxyStrictResume.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSSLProxyStrictResume.setDescription('Should the SSL proxy disallow SSL sessions to be resumed when the corresponding connection was shut down uncleanly? This OID does not apply to 3-DNS.')
globalAttrSelfConnTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrSelfConnTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrSelfConnTimeout.setDescription('Timeout for connection tracking of self traffic. This OID does not apply to 3-DNS.')
globalAttrFailoverPort = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 1, 53), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("true", 1), ("false", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalAttrFailoverPort.setStatus('mandatory')
if mibBuilder.loadTexts: globalAttrFailoverPort.setDescription('States whether failover port is open for traffic; true = open, false = not open.')
globalStatUptime = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatUptime.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatUptime.setDescription('Total uptime since last reboot, in seconds.')
globalStatBitsin = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatBitsin.setDescription('Total bits read off the network.')
globalStatBitsinHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatBitsinHi32.setDescription('Total bits in. (High order 32).')
globalStatBitsout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatBitsout.setDescription('Total of all bits written to the network.')
globalStatBitsoutHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatBitsoutHi32.setDescription('Total bits out. (High order 32)')
globalStatPcktsin = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatPcktsin.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatPcktsin.setDescription('Total of all packets read off the network.')
globalStatPcktsinHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatPcktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatPcktsinHi32.setDescription('Total packets in. (High Order 32)')
globalStatPcktsout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatPcktsout.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatPcktsout.setDescription('Total of all packets written to the network.')
globalStatPcktsoutHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatPcktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatPcktsoutHi32.setDescription('Total packets out. (High order 32).')
globalStatCurrentConn = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatCurrentConn.setDescription('Total current connections active.')
globalStatMaxConn = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMaxConn.setDescription('Maximum number of active connections allowed.')
globalStatTotalConn = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatTotalConn.setDescription('Total number of connections this balancer has serviced.')
globalStatTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatTimeouts.setDescription('Total number of timeouts for this object (XXX object?).')
globalStatMemoryPoolTotal = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMemoryPoolTotal.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMemoryPoolTotal.setDescription('Total memory pool available on system.')
globalStatMemoryPoolUsed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMemoryPoolUsed.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMemoryPoolUsed.setDescription('Total memory pool currently in use by system.')
globalStatStandBySharedDrop = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatStandBySharedDrop.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatStandBySharedDrop.setDescription('Total number of packets, destined for shared address, but received on standby system.')
globalStatSelfTCPPortDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatSelfTCPPortDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatSelfTCPPortDeny.setDescription('Total number of TCP port denials for all self IP addresses.')
globalStatSelfUDPPortDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatSelfUDPPortDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatSelfUDPPortDeny.setDescription('Total number of UDP port denials for all self IP addresses.')
globalStatMaintenanceModeDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMaintenanceModeDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMaintenanceModeDeny.setDescription('Total number of attempts to deny maintenance mode.')
globalStatVirtualServerUDPPortDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerUDPPortDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerUDPPortDeny.setDescription('Total number of UDP port denials for all virtual addresses. This OID does not apply to 3-DNS.')
globalStatVirtualServerTCPPortDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerTCPPortDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerTCPPortDeny.setDescription('Total number of TCP port denials for all virtual servers. This OID does not apply to 3-DNS.')
globalStatVirtualServerDupSynSSL = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerDupSynSSL.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerDupSynSSL.setDescription('Total number of duplicate SYNs for SSL traffic. This OID does not apply to 3-DNS.')
globalStatVirtualServerDupSynWrongDest = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerDupSynWrongDest.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerDupSynWrongDest.setDescription('Total number of duplicate SYNs for virtual servers, sent to the wrong destination. This OID does not apply to 3-DNS.')
globalStatVirtualServerDupSynNodeDown = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerDupSynNodeDown.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerDupSynNodeDown.setDescription('Total number of duplicate SYNs for virtual servers, sent to down node. This OID does not apply to 3-DNS.')
globalStatVirtualServerNonSynDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerNonSynDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerNonSynDeny.setDescription('Total number of non SYN denials, for all virtual servers. This OID does not apply to 3-DNS.')
globalStatMaxConnPortDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMaxConnPortDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMaxConnPortDeny.setDescription('Total number of connections denied because maximum connections count exceeded. This OID does not apply to 3-DNS.')
globalStatMaxConnVirtualAddressDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMaxConnVirtualAddressDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMaxConnVirtualAddressDeny.setDescription('Total number of connections denied to all virtual addresses, because maximum connections exceeded. This OID does not apply to 3-DNS.')
globalStatMaxConnVirtualPathDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMaxConnVirtualPathDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMaxConnVirtualPathDeny.setDescription('Total number of connections denied to all virtual servers, because maximum connections exceeded. This OID does not apply to 3-DNS.')
globalStatVirtualServerFragNoPort = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerFragNoPort.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerFragNoPort.setDescription('Total number of fragments, sent to virtual servers, with no port. This OID does not apply to 3-DNS.')
globalStatVirtualServerFragNoConn = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatVirtualServerFragNoConn.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatVirtualServerFragNoConn.setDescription('Total number of fragments, sent to virtual servers, with no connection. This OID does not apply to 3-DNS.')
globalStatNoHandlerDeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatNoHandlerDeny.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatNoHandlerDeny.setDescription('Total number of handler denials.')
globalStatTCPTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatTCPTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatTCPTimeouts.setDescription('Total number of TCP timeouts.')
globalStatUDPTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatUDPTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatUDPTimeouts.setDescription('Total number of UDP timeouts.')
globalStatIPTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatIPTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatIPTimeouts.setDescription('Total number of IP timeouts.')
globalStatSSLTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatSSLTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatSSLTimeouts.setDescription('Total number of SSL timeouts. This OID does not apply to 3-DNS.')
globalStatPersistTimeouts = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatPersistTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatPersistTimeouts.setDescription('Total number of persistence timeouts.')
globalStatMultiProcessorMode = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMultiProcessorMode.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMultiProcessorMode.setDescription('Current multiprocessing mode; UP is the uniprocessor mode. ANIP is the auxiliary network interface mode. SMP is the symmetric multiprocessor mode.')
globalStatCPUCount = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatCPUCount.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatCPUCount.setDescription('Total number of CPUs.')
globalStatActiveCPUCount = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 39), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatActiveCPUCount.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatActiveCPUCount.setDescription('Total number of currently active CPUs.')
globalStatANIPPercent = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 40), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatANIPPercent.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatANIPPercent.setDescription('Total percent of CPU devoted to ANIP feature.')
globalStatMaxANIPPercent = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMaxANIPPercent.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMaxANIPPercent.setDescription('Maximum percent of CPU devoted to ANIP feature, since last reboot.')
globalStatMemoryErrors = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMemoryErrors.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMemoryErrors.setDescription('Total number of memory allocation errors.')
globalStatNoNodeErrors = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatNoNodeErrors.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatNoNodeErrors.setDescription('If active member count is zero, then this counter is incremented. (XXX when, how often?)')
globalStatMemoryInUse = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 44), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMemoryInUse.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMemoryInUse.setDescription('Current amount of memory in use.')
globalStatMemoryMaxUsed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 45), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMemoryMaxUsed.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMemoryMaxUsed.setDescription('Maximum amount of memory used since last reboot.')
globalStatMemoryCurrentSize = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 46), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatMemoryCurrentSize.setStatus('mandatory')
if mibBuilder.loadTexts: globalStatMemoryCurrentSize.setDescription('Current memory size. (XXX Current amount of memory available???)')
globalStatCPUTemperature = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 47), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatCPUTemperature.setStatus('deprecated')
if mibBuilder.loadTexts: globalStatCPUTemperature.setDescription('This OID is deprecated -- see Platform MIB.')
globalStatFanSpeed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 1, 2, 48), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: globalStatFanSpeed.setStatus('deprecated')
if mibBuilder.loadTexts: globalStatFanSpeed.setDescription('This OID is deprecated -- see Platform MIB.')
interfaceNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceNumber.setDescription('The number of interfaces on this system.')
interfaceTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2), )
if mibBuilder.loadTexts: interfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceTable.setDescription('A table containing information about the system interfaces.')
interfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "interfaceName"))
if mibBuilder.loadTexts: interfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceEntry.setDescription('Columns in the Interface Table.')
interfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceName.setDescription('The name of this interface. The name will be composed of the slot number, followed by the port number of the interface. These numbers start at 1 and the slots are numbered from left to right. The ports are numbered from top to bottom.')
interfaceIpAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceIpAddresses.setStatus('deprecated')
if mibBuilder.loadTexts: interfaceIpAddresses.setDescription('This OID is deprecated. Each interface will handle IP addresses based on the VLAN(s) assigned to the interface and the IP addresses associated with those VLAN(s). This entry will always return an empty string.')
interfaceDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceDestination.setStatus('deprecated')
if mibBuilder.loadTexts: interfaceDestination.setDescription('This OID is deprecated. All interfaces will always be enabled for destination processing. This will always return true.')
interfaceSource = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceSource.setStatus('deprecated')
if mibBuilder.loadTexts: interfaceSource.setDescription('This OID is deprecated. All interfaces are enabled for source processing. This will always return true.')
interfaceTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: interfaceTimeout.setDescription('This OID is deprecated. This will always return -1; The seconds before a failover is triggered in failsafe mode.')
interfaceArmed = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceArmed.setStatus('deprecated')
if mibBuilder.loadTexts: interfaceArmed.setDescription('This OID is deprecated. This will always return true. The interface will be armed if the interface failsafe mode is activated.')
interfaceVLANSEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceVLANSEnabled.setStatus('deprecated')
if mibBuilder.loadTexts: interfaceVLANSEnabled.setDescription('This attribute is deprecated. This OID will always return true.')
interfaceMasqueradeAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 8), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceMasqueradeAddress.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceMasqueradeAddress.setDescription('MAC masquerade address of this interface.')
interfaceLastTimeChanged = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceLastTimeChanged.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceLastTimeChanged.setDescription('The last time the interface attributes were modified. (XXX what is value?... seconds since ???)')
interfaceSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceSpeed.setDescription('The speed of this interface (XXX in Mbps?-what are possible values? 10000000 100000000).')
interfaceFullDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceFullDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceFullDuplex.setDescription('States whether this interface is operating in full-duplex mode; true = full-duplex, false = not full-duplex.')
interfaceMediaTypeActive = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 12), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceMediaTypeActive.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceMediaTypeActive.setDescription('The currently active media type.')
interfaceMediaDuplexActive = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 13), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceMediaDuplexActive.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceMediaDuplexActive.setDescription('The currently active duplex mode for this interface.')
interfaceMediaStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("active", 1), ("nocarrier", 2), ("invalid", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceMediaStatus.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceMediaStatus.setDescription('The media status for this interface.')
interfaceMediaType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceMediaType.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceMediaType.setDescription('The preferred media type for this interface.')
interfaceMediaDuplex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 16), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceMediaDuplex.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceMediaDuplex.setDescription('The preferred media duplex mode for this interface.')
interfaceMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 5, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: interfaceMTU.setStatus('mandatory')
if mibBuilder.loadTexts: interfaceMTU.setDescription('The maximum transmission unit size for this interface.')
ifaddressNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressNumber.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressNumber.setDescription('The number of interface IP addresses on this system. This table has been deprecated. This OID will always return 0. The selfIP table has taken its place. Interfaces are no longer directly associated with IP addresses.')
ifaddressTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2), )
if mibBuilder.loadTexts: ifaddressTable.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressTable.setDescription('This table has been deprecated it will always be empty. The selfIP table has taken its place. Interfaces are no longer directly associated with IP addresses. They are now only associated with VLANs.')
ifaddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "ifaddressIpAddress"))
if mibBuilder.loadTexts: ifaddressEntry.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressEntry.setDescription('This OID is deprecated. Columns in the Interface Table.')
ifaddressIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressIpAddress.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressIpAddress.setDescription('This OID is deprecated. The IP address for this interface IP address.')
ifaddressInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressInterfaceName.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressInterfaceName.setDescription('This OID is deprecated. The name of the interface for this IP address.')
ifaddressNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressNetmask.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressNetmask.setDescription('This OID is deprecated. The netmask for this interface IP address.')
ifaddressBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressBroadcast.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressBroadcast.setDescription('This OID is deprecated. The broadcast address for this interface IP address.')
ifaddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("iptrue", 1), ("ipshared", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressType.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressType.setDescription('This OID is deprecated. The type for this interface IP address.')
ifaddressUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressUnitId.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressUnitId.setDescription('This OID is deprecated. The unit id for this interface IP address.')
ifaddressVLANTag = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 6, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 5))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ifaddressVLANTag.setStatus('deprecated')
if mibBuilder.loadTexts: ifaddressVLANTag.setDescription('This OID is deprecated. The VLAN tag for this interface IP address.')
poolNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolNumber.setStatus('mandatory')
if mibBuilder.loadTexts: poolNumber.setDescription('The number of pools on this BIG-IP.')
poolTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2), )
if mibBuilder.loadTexts: poolTable.setStatus('mandatory')
if mibBuilder.loadTexts: poolTable.setDescription('A table containing information about the BIG-IP pools.')
poolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "poolName"))
if mibBuilder.loadTexts: poolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: poolEntry.setDescription('Columns in the Pool Table.')
poolName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolName.setStatus('mandatory')
if mibBuilder.loadTexts: poolName.setDescription('The name of this pool.')
poolLBMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))).clone(namedValues=NamedValues(("roundrobin", 1), ("ratioMember", 2), ("leastConnMember", 3), ("observedMember", 4), ("predictiveMember", 5), ("ratioNodeAddress", 6), ("leastConnNodeAddress", 7), ("fastestNodeAddress", 8), ("observerdNodeAddress", 9), ("predictiveNodeAddress", 10), ("dynamicRatio", 11), ("fastestAppResponse", 12)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolLBMode.setStatus('mandatory')
if mibBuilder.loadTexts: poolLBMode.setDescription('The load balance mode of this pool.')
poolDependent = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolDependent.setStatus('mandatory')
if mibBuilder.loadTexts: poolDependent.setDescription('States whether this pool a dependent pool; true = dependent; false = not dependent.')
poolMemberQty = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberQty.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberQty.setDescription('The number of members in this pool.')
poolBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: poolBitsin.setDescription('The total bits in for this pool.')
poolBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: poolBitsout.setDescription('The total bits out for this pool.')
poolBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolBitsinHi32.setDescription('The total bits in for this pool.')
poolBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolBitsoutHi32.setDescription('The total bits out for this pool.')
poolPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: poolPktsin.setDescription('The total packets in for this pool (XXX low 32 bits).')
poolPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: poolPktsout.setDescription('The total packets out for this pool (XXX low 32 bits).')
poolPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolPktsinHi32.setDescription('The total packets in for this pool (XXX low 32 bits).')
poolPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolPktsoutHi32.setDescription('The total packets out for this pool (XXX low 32 bits).')
poolMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: poolMaxConn.setDescription('The maximum number of connections the members of this pool have had open at any one time.')
poolCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: poolCurrentConn.setDescription('The current number of connections the members of this pool have open.')
poolTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: poolTotalConn.setDescription('The total number of connections the members of this pool have served since the pool started.')
poolPersistMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("simple", 2), ("sticky", 3), ("cookie", 4), ("ssl", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolPersistMode.setStatus('mandatory')
if mibBuilder.loadTexts: poolPersistMode.setDescription('Persistence mode for this pool.')
poolSSLTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 17), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolSSLTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: poolSSLTimeout.setDescription('The timeout value in seconds for SSL persistence for this pool.')
poolSimpleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolSimpleTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: poolSimpleTimeout.setDescription('The timeout value in seconds for simple persistence for this pool.')
poolSimpleMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 19), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolSimpleMask.setStatus('mandatory')
if mibBuilder.loadTexts: poolSimpleMask.setDescription('The simple persistence mask for this pool.')
poolStickyMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 20), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolStickyMask.setStatus('mandatory')
if mibBuilder.loadTexts: poolStickyMask.setDescription('The sticky persistence mask for this pool.')
poolCookieMode = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("insert", 2), ("rewrite", 3), ("passive", 4), ("hash", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolCookieMode.setStatus('mandatory')
if mibBuilder.loadTexts: poolCookieMode.setDescription('Cookie mode used with cookie persistence mode.')
poolCookieExpiration = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolCookieExpiration.setStatus('mandatory')
if mibBuilder.loadTexts: poolCookieExpiration.setDescription('The persistent cookie expiration time in seconds for this pool.')
poolCookieHashName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 23), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolCookieHashName.setStatus('mandatory')
if mibBuilder.loadTexts: poolCookieHashName.setDescription('The cookie hash name for this pool.')
poolCookieHashOffset = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolCookieHashOffset.setStatus('mandatory')
if mibBuilder.loadTexts: poolCookieHashOffset.setDescription('The cookie hash offset for this pool.')
poolCookieHashLength = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolCookieHashLength.setStatus('mandatory')
if mibBuilder.loadTexts: poolCookieHashLength.setDescription('The cookie hash length for this pool.')
poolMinActiveMembers = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 26), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMinActiveMembers.setStatus('mandatory')
if mibBuilder.loadTexts: poolMinActiveMembers.setDescription('The minimum number of active members.')
poolActiveMemberCount = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 27), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolActiveMemberCount.setStatus('mandatory')
if mibBuilder.loadTexts: poolActiveMemberCount.setDescription('The number of currently active members for this pool.')
poolPersistMirror = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolPersistMirror.setStatus('mandatory')
if mibBuilder.loadTexts: poolPersistMirror.setDescription('States whether this BIG-IP is set up for persistence mirroring; true = persistence is mirrored, false = persistence is not mirrored.')
poolFallbackHost = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 7, 2, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolFallbackHost.setStatus('mandatory')
if mibBuilder.loadTexts: poolFallbackHost.setDescription('The fallback host for this pool.')
poolMemberNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberNumber.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberNumber.setDescription('The number of pool members on this BIG-IP.')
poolMemberTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2), )
if mibBuilder.loadTexts: poolMemberTable.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberTable.setDescription('A table containing information about the BIG-IP pool members.')
poolMemberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "poolMemberPoolName"), (0, "LOAD-BAL-SYSTEM-MIB", "poolMemberIpAddress"), (0, "LOAD-BAL-SYSTEM-MIB", "poolMemberPort"))
if mibBuilder.loadTexts: poolMemberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberEntry.setDescription('Columns in the Pool Member Table.')
poolMemberPoolName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberPoolName.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberPoolName.setDescription('The name of the pool which contains this member.')
poolMemberIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberIpAddress.setDescription('The IP address of this pool member.')
poolMemberPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberPort.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberPort.setDescription('The port of this pool member.')
poolMemberMaintenance = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberMaintenance.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberMaintenance.setDescription('States whether this pool member is in maintenance mode; true = maintenance mode, false = not maintenance mode.')
poolMemberRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberRatio.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberRatio.setDescription('Load balancing ratio of the member within the pool. Used by member ratio load balancing mode.')
poolMemberPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberPriority.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberPriority.setDescription('Priority level of the member within the pool. Used by priority member load balancing mode.')
poolMemberWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberWeight.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberWeight.setDescription('Weight of the member within the pool. Used during dynamically calculated ratio load balancing.')
poolMemberRipeness = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberRipeness.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberRipeness.setDescription('The current load balancing state in member ratio load balancing mode.')
poolMemberBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberBitsin.setDescription('The total bits in for this pool member.')
poolMemberBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberBitsout.setDescription('The total bits out for this pool member.')
poolMemberBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberBitsinHi32.setDescription('The total bits in for this pool member.')
poolMemberBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberBitsoutHi32.setDescription('The total bits out for this pool member.')
poolMemberPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberPktsin.setDescription('The total packets in for this pool member.')
poolMemberPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberPktsout.setDescription('The total packets out for this pool member.')
poolMemberPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberPktsinHi32.setDescription('The total packets in for this pool member.')
poolMemberPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberPktsoutHi32.setDescription('The total packets out for this pool member.')
poolMemberConnLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberConnLimit.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberConnLimit.setDescription('The maximum number of connections this pool member can have open at any one time.')
poolMemberMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberMaxConn.setDescription('The maximum number of connections this pool member has had open at any one time.')
poolMemberCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberCurrentConn.setDescription('The current number of connections this pool member has open.')
poolMemberTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberTotalConn.setDescription('The total number of connections this pool member have served since the pool member started.')
poolMemberStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 21), BigAPIStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberStatus.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberStatus.setDescription('The status of this pool member.')
poolMemberIpStatus = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 8, 2, 1, 22), BigAPIStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: poolMemberIpStatus.setStatus('mandatory')
if mibBuilder.loadTexts: poolMemberIpStatus.setDescription("The status of this pool member's IP address.")
sslProxyNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyNumber.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyNumber.setDescription('The number of SSL Proxies on this BIG-IP.')
sslProxyTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2), )
if mibBuilder.loadTexts: sslProxyTable.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyTable.setDescription('A table containing information about the BIG-IP SSL Proxies.')
sslProxyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "sslProxyOrigIpAddress"), (0, "LOAD-BAL-SYSTEM-MIB", "sslProxyOrigPort"), (0, "LOAD-BAL-SYSTEM-MIB", "sslProxyDestIpAddress"), (0, "LOAD-BAL-SYSTEM-MIB", "sslProxyDestPort"))
if mibBuilder.loadTexts: sslProxyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyEntry.setDescription('Columns in the SSL Proxy Table.')
sslProxyOrigIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyOrigIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyOrigIpAddress.setDescription('The original IP address of this SSL proxy.')
sslProxyOrigPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyOrigPort.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyOrigPort.setDescription('The original port of this SSL proxy.')
sslProxyDestIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyDestIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyDestIpAddress.setDescription('The destination IP address of this SSL proxy.')
sslProxyDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyDestPort.setDescription('The destination port of this SSL proxy.')
sslProxyNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyNetmask.setDescription('The netmask of this SSL proxy.')
sslProxyBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 6), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyBroadcast.setDescription('The broadcast address of this SSL proxy.')
sslProxyUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyUnitId.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyUnitId.setDescription('The unit id of this SSL proxy.')
sslProxyEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyEnabled.setDescription('States whether this SSL proxy is enabled; true = enabled, false = not enabled.')
sslProxyInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyInterfaceName.setStatus('deprecated')
if mibBuilder.loadTexts: sslProxyInterfaceName.setDescription('SSL proxies now exist on VLANS and not specific interfaces. This OID is deprecated and will always return 0.0.0.0.')
sslProxyLastHopPool = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyLastHopPool.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyLastHopPool.setDescription('The name of the last hop pool for this SSL proxy.')
sslProxyVLANs = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 11), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyVLANs.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyVLANs.setDescription('If this list is empty, (the default) this SSL proxy will be accessible on all VLANS. If this list is not empty, this SSL proxy will be accessible only on those VLANs specified in the list.')
sslProxyLocalTarget = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyLocalTarget.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyLocalTarget.setDescription('Local target of SSL proxy, virtual server or node server true = (XXX), false = (XXX).')
sslProxyAkamaize = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyAkamaize.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyAkamaize.setDescription('States whether Akamaize feature is enabled; true = enabled, false = disabled.')
sslProxyUseSSL = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyUseSSL.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyUseSSL.setDescription('States whether the SSL proxy will use SSL; true = SSL, false = no SSL.')
sslProxyBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyBitsin.setDescription('The total bits in for this SSL proxy.')
sslProxyBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyBitsout.setDescription('The total bits out for this SSL proxy.')
sslProxyBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyBitsinHi32.setDescription('The total bits in for this SSL proxy.')
sslProxyBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyBitsoutHi32.setDescription('The total bits out for this SSL proxy.')
sslProxyPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyPktsin.setDescription('The total packets in for this SSL proxy.')
sslProxyPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyPktsout.setDescription('The total packets out for this SSL proxy.')
sslProxyPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyPktsinHi32.setDescription('The total packets in for this SSL proxy.')
sslProxyPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyPktsoutHi32.setDescription('The total packets out for this SSL proxy.')
sslProxyConnLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 23), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyConnLimit.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyConnLimit.setDescription('The maximum number of connections this SSL proxy can have open at any one time.')
sslProxyMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyMaxConn.setDescription('The maximum number of connections this SSL proxy member has had open at any one time.')
sslProxyCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 25), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyCurrentConn.setDescription('The current number of connections this SSL proxy has open.')
sslProxyTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyTotalConn.setDescription('The total number of connections this SSL proxy has served since the SSL proxy started.')
sslProxyUseServerSSL = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyUseServerSSL.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyUseServerSSL.setDescription('States whether this SSL proxy will use server-side SSL; true = server-side SSL, false = no server-side SSL.')
sslProxyArpEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyArpEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyArpEnabled.setDescription('States whether ARP will be enabled for this SSL proxy; true = ARP enabled, false = ARP disabled.')
sslProxyHTTPHeaderToAdd = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyHTTPHeaderToAdd.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyHTTPHeaderToAdd.setDescription('Text to be added to an HTTP packet header.')
sslProxyInsertClientCipher = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyInsertClientCipher.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyInsertClientCipher.setDescription('States whether the negotiated client request SSL ciphersuite will be inserted into the HTTP packet header; true = yes, false = no.')
sslProxyRewriteRedirects = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 31), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyRewriteRedirects.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyRewriteRedirects.setDescription('The number of rewrite redirects specified for this SSL proxy.')
sslProxyClientInvalidVersions = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyClientInvalidVersions.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyClientInvalidVersions.setDescription('The total number of client invalid versions for this SSL proxy.')
sslProxyServerInvalidVersions = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerInvalidVersions.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerInvalidVersions.setDescription('The total number of server invalid versions for this SSL proxy.')
sslProxyClientCertificate = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("clientcertificateignored", 1), ("clientcertificaterequested", 2), ("clientcertificaterequired", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyClientCertificate.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyClientCertificate.setDescription('Flag describing the use of the client certificate.')
sslProxyVerifyClientOnce = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyVerifyClientOnce.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyVerifyClientOnce.setDescription('States whether each client will be verified one time by this SSL proxy; true = verify once, false = (no verify? or verify more than once?XXX).')
sslProxyVerifyClientDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyVerifyClientDepth.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyVerifyClientDepth.setDescription('States whether this SSL proxy will verify client depth; true = verify, false = do not verify.')
sslProxyClientSessionCacheTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 37), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyClientSessionCacheTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyClientSessionCacheTimeout.setDescription('The timeout value for the client session cache for this SSL proxy in seconds.')
sslProxyClientSessionCacheSize = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 38), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyClientSessionCacheSize.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyClientSessionCacheSize.setDescription('The size of the cache for each client session for this SSL proxy.')
sslProxyChainFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 39), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyChainFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyChainFileName.setDescription('')
sslProxyServerChainFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 40), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerChainFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerChainFileName.setDescription('')
sslProxyCAFileFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 41), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyCAFileFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyCAFileFileName.setDescription('')
sslProxyServerCAFileFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 42), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerCAFileFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerCAFileFileName.setDescription('')
sslProxyCAPathFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 43), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyCAPathFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyCAPathFileName.setDescription('')
sslProxyServerCAPathFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 44), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerCAPathFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerCAPathFileName.setDescription('')
sslProxyCRLFileFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 45), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyCRLFileFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyCRLFileFileName.setDescription('')
sslProxyServerCRLFileFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 46), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerCRLFileFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerCRLFileFileName.setDescription('')
sslProxyCRLPathFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 47), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyCRLPathFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyCRLPathFileName.setDescription('')
sslProxyServerCRLPathFileName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 48), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerCRLPathFileName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerCRLPathFileName.setDescription('')
sslProxyClientCertCAFileFilenName = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 49), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 1024))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyClientCertCAFileFilenName.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyClientCertCAFileFilenName.setDescription('')
sslProxyInsertClientSessionID = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 50), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyInsertClientSessionID.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyInsertClientSessionID.setDescription('Bitmask specifying which SSL session ID(s) to include in the HTTP header.')
sslProxyInsertClientIPAddrPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 51), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyInsertClientIPAddrPort.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyInsertClientIPAddrPort.setDescription('')
sslProxyServerCertificate = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 52), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3))).clone(namedValues=NamedValues(("serverCertificateIgnored", 1), ("serverCertificateRequired", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerCertificate.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerCertificate.setDescription('')
sslProxyVerifyServerDepth = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyVerifyServerDepth.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyVerifyServerDepth.setDescription('')
sslProxyTCPKeepAlivesEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 54), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyTCPKeepAlivesEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyTCPKeepAlivesEnabled.setDescription('')
sslProxyServerTCPKeepAlivesEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 9, 2, 1, 55), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sslProxyServerTCPKeepAlivesEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: sslProxyServerTCPKeepAlivesEnabled.setDescription('')
vlanNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vlanNumber.setDescription('The number of VLANs on this system.')
vlanTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2), )
if mibBuilder.loadTexts: vlanTable.setStatus('mandatory')
if mibBuilder.loadTexts: vlanTable.setDescription('A table containing information for VLANs.')
vlanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "vlanName"))
if mibBuilder.loadTexts: vlanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vlanEntry.setDescription('Columns in the VLAN Table.')
vlanName = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanName.setStatus('mandatory')
if mibBuilder.loadTexts: vlanName.setDescription('The name of this VLAN.')
vlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanID.setStatus('mandatory')
if mibBuilder.loadTexts: vlanID.setDescription('Numeric ID for this VLAN.')
vlanTag = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanTag.setStatus('mandatory')
if mibBuilder.loadTexts: vlanTag.setDescription('Numeric tag for this VLAN.')
vlanAllowOtherProxyARP = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanAllowOtherProxyARP.setStatus('mandatory')
if mibBuilder.loadTexts: vlanAllowOtherProxyARP.setDescription('States whether other VLANS are allowed to perform proxy ARP requests for this VLAN; true = allowed, false = not allowed.')
vlanPortLockedDown = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanPortLockedDown.setStatus('mandatory')
if mibBuilder.loadTexts: vlanPortLockedDown.setDescription('States whether the port lock down feature is enabled for this VLAN; true = enabled, false = disabled.')
vlanTaggedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanTaggedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vlanTaggedPorts.setDescription('A list of the tagged ports on this VLAN.')
vlanUntaggedPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanUntaggedPorts.setStatus('mandatory')
if mibBuilder.loadTexts: vlanUntaggedPorts.setDescription('A list of the untagged ports on this VLAN.')
vlanSnatAutomap = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanSnatAutomap.setStatus('mandatory')
if mibBuilder.loadTexts: vlanSnatAutomap.setDescription('States whether the SNAT automap feature is enabled for this VLAN; true = enabled, false = disabled.')
vlanArmed = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanArmed.setStatus('mandatory')
if mibBuilder.loadTexts: vlanArmed.setDescription('States whether this vlan is armed; true = armed, false = disarmed.')
vlanTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 10, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vlanTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: vlanTimeout.setDescription('The timeout value for this VLAN, in seconds.')
selfIPNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPNumber.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPNumber.setDescription('The number of self IPs on this system.')
selfIPTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2), )
if mibBuilder.loadTexts: selfIPTable.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPTable.setDescription('A table containing information for self IPs.')
selfIPEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "selfIPAddress"))
if mibBuilder.loadTexts: selfIPEntry.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPEntry.setDescription('Columns in the selfIP Table.')
selfIPAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPAddress.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPAddress.setDescription('The IP of this self IP address.')
selfIPNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPNetmask.setDescription('The netmask for this self IP address.')
selfIPBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPBroadcast.setDescription('The broadcast address for this self IP address.')
selfIPUnitID = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPUnitID.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPUnitID.setDescription('For redundant systems, unit number associated with the self IP address.')
selfIPVLAN = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPVLAN.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPVLAN.setDescription('The VLAN associated with this self IP address.')
selfIPSnatAutomap = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPSnatAutomap.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPSnatAutomap.setDescription('SNAT auto map feature for self IP addresses; true = (XXX), false = (XXX).')
selfIPIsFloating = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 11, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: selfIPIsFloating.setStatus('mandatory')
if mibBuilder.loadTexts: selfIPIsFloating.setDescription('States whether self IP address is shared; true = shared, false = not shared.')
trunkNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 12, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkNumber.setStatus('mandatory')
if mibBuilder.loadTexts: trunkNumber.setDescription('The number of trunks on this system.')
trunkTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 12, 2), )
if mibBuilder.loadTexts: trunkTable.setStatus('mandatory')
if mibBuilder.loadTexts: trunkTable.setDescription('A table containing information for trunks.')
trunkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 12, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "trunkControllingInterface"))
if mibBuilder.loadTexts: trunkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: trunkEntry.setDescription('Columns in the trunk Table.')
trunkControllingInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 12, 2, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkControllingInterface.setStatus('mandatory')
if mibBuilder.loadTexts: trunkControllingInterface.setDescription('The name of the controlling interface for this interface trunk.')
trunkInterfaces = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 12, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkInterfaces.setStatus('mandatory')
if mibBuilder.loadTexts: trunkInterfaces.setDescription('A list of the interfaces on this interface trunk.')
trunkMediaSpeed = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 12, 2, 1, 3), Counter64()).setMaxAccess("readonly")
if mibBuilder.loadTexts: trunkMediaSpeed.setStatus('mandatory')
if mibBuilder.loadTexts: trunkMediaSpeed.setDescription('Aggregate trunk media speed in bits/s.')
virtualAddressNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressNumber.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressNumber.setDescription('The number of virtual addresses on this BIG-IP.')
virtualAddressTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2), )
if mibBuilder.loadTexts: virtualAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressTable.setDescription('A table containing information about the BIG-IP Virtual Server addresses.')
virtualAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "virtualAddressIpAddress"))
if mibBuilder.loadTexts: virtualAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressEntry.setDescription('Columns in the Virtual Address Table.')
virtualAddressIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressIpAddress.setDescription('The IP address for this virtual server.')
virtualAddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressStatus.setDescription('Is this server in maintenance mode?')
virtualAddressConnLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressConnLimit.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressConnLimit.setDescription('The total number of connections this virtual address can support at one time.')
virtualAddressNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressNetmask.setDescription('The netmask for this virtual address.')
virtualAddressBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressBroadcast.setDescription('The broadcast address for this virtual address.')
virtualAddressInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressInterface.setStatus('deprecated')
if mibBuilder.loadTexts: virtualAddressInterface.setDescription('This has been deprecated. virtualAddresses are no longer associated a specific interface. Instead each virtualServer of a virtualAddress is associated with a VLAN. A query will now always return none.')
virtualAddressFailoverFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("mirrorconnections", 1), ("mirrorpersistence", 2), ("mirrorconnectionspersistence", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressFailoverFlags.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressFailoverFlags.setDescription('The fail-over flags for the this virtual address. The virtualAddressFailoverFlag is no longer relevant. Mirroring is controlled through the virtualServerFailoverFlag.')
virtualAddressOctetsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressOctetsIn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressOctetsIn.setDescription('The number of octets received from the network from this virtual server.')
virtualAddressOctetsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressOctetsOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressOctetsOut.setDescription('The number of octets sent to the network from this virtual server.')
virtualAddressPacketsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressPacketsIn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressPacketsIn.setDescription('The number of packets received from the network from this virtual server.')
virtualAddressPacketsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressPacketsOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressPacketsOut.setDescription('The number of packets sent to the network from this virtual server.')
virtualAddressCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 12), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressCurrentConn.setDescription('The number of connections currently open on this virtual server.')
virtualAddressMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressMaxConn.setDescription('The maximum number of connections this virtual server has had open at any one time.')
virtualAddressTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressTotalConn.setDescription('The total number of connections this virtual server has served since the server started.')
virtualAddressOctetsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressOctetsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressOctetsInHi32.setDescription('The number of octets received from the network from this virtual server.')
virtualAddressOctetsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressOctetsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressOctetsOutHi32.setDescription('The number of octets sent to the network from this virtual server.')
virtualAddressPacketsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressPacketsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressPacketsInHi32.setDescription('The number of packets received from the network from this virtual server.')
virtualAddressPacketsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressPacketsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressPacketsOutHi32.setDescription('The number of packets sent to the network from this virtual server.')
virtualAddressUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 2, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualAddressUnitId.setStatus('mandatory')
if mibBuilder.loadTexts: virtualAddressUnitId.setDescription('The unit id of this virtual server.')
virtualServerNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerNumber.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerNumber.setDescription('The number of virtual servers on this BIG-IP.')
virtualServerTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2), )
if mibBuilder.loadTexts: virtualServerTable.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerTable.setDescription('A table containing BIG-IP Virtual server information.')
virtualServerEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "virtualServerIpAddress"), (0, "LOAD-BAL-SYSTEM-MIB", "virtualServerPort"))
if mibBuilder.loadTexts: virtualServerEntry.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerEntry.setDescription('Columns in the Virtual Server table.')
virtualServerIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerIpAddress.setDescription('The IP address for this virtual server. Wildcard virtual servers will have an IP address of 255.255.255.255')
virtualServerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPort.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPort.setDescription('The port for this virtual server.')
virtualServerStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("noNodeAvailable", 3), ("notOnThisUnit", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerStatus.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerStatus.setDescription('Is this server in maintenance mode?')
virtualServerConnLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerConnLimit.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerConnLimit.setDescription('The total number of connections this virtual server can support at one time.')
virtualServerAppProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("ssl", 2), ("cookie", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerAppProtocol.setStatus('deprecated')
if mibBuilder.loadTexts: virtualServerAppProtocol.setDescription('This variable has been deprecated. A query will always return -1. The application tunneling protocol this virtual server uses.')
virtualServerAppProtocolTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerAppProtocolTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: virtualServerAppProtocolTimeout.setDescription('This variable has been deprecated. A query will always return -1. The timeout value for persistence timeout for this application protocol session.')
virtualServerAppProtocolReaper = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerAppProtocolReaper.setStatus('deprecated')
if mibBuilder.loadTexts: virtualServerAppProtocolReaper.setDescription('This variable has been deprecated. A query will always return -1. The amount of idle time before we reap an application protocol session.')
virtualServerPersistTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPersistTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPersistTimeout.setDescription('The timeout value for persistence on this connection.')
virtualServerPersistMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 9), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPersistMask.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPersistMask.setDescription('The IP addresses matching this mask will have persistent connections. Those not covered by this mask will not.')
virtualServerSticky = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerSticky.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerSticky.setDescription('States whether destination address affinity is turned on for this connection; true = yes, false = no.')
virtualServerStickyMask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 11), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerStickyMask.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerStickyMask.setDescription('The addresses matching this mask will have destination address affinity if virtualServerSticky is true.')
virtualServerFailoverFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("mirrorconnections", 1), ("mirrorpersistence", 2), ("mirrorconnectionspersistence", 3), ("nomirroring", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerFailoverFlags.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerFailoverFlags.setDescription('The fail-over flags for the this virtual server.')
virtualServerOctetsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerOctetsIn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerOctetsIn.setDescription('The number of octets received from the network from this virtual server.')
virtualServerOctetsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerOctetsOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerOctetsOut.setDescription('The number of octets sent to the network from this virtual server.')
virtualServerPacketsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPacketsIn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPacketsIn.setDescription('The number of packets received from the network from this virtual server.')
virtualServerPacketsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPacketsOut.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPacketsOut.setDescription('The number of packets sent to the network from this virtual server.')
virtualServerCurrentConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerCurrentConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerCurrentConn.setDescription('The number of connections currently open on this virtual server.')
virtualServerMaxConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 18), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerMaxConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerMaxConn.setDescription('The maximum number of connections this virtual server has had open at any one time.')
virtualServerTotalConn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerTotalConn.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerTotalConn.setDescription('The total number of connections this virtual server has served since the server started.')
virtualServerSslNew = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerSslNew.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerSslNew.setDescription('The number of new SSL sessions on this virtual server.')
virtualServerSslHits = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerSslHits.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerSslHits.setDescription('The number of lookup successes in the SSL session id cache for valid session ids.')
virtualServerSslTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerSslTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerSslTimeouts.setDescription('The number of lookup successes in the SSL session id cache for session ids that have already been reaped.')
virtualServerSslMisses = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerSslMisses.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerSslMisses.setDescription('The number of lookup failures in the SSL session id cache.')
virtualServerOctetsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerOctetsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerOctetsInHi32.setDescription('The number of octets received from the network from this virtual server.')
virtualServerOctetsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerOctetsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerOctetsOutHi32.setDescription('The number of octets sent to the network from this virtual server.')
virtualServerPacketsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPacketsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPacketsInHi32.setDescription('The number of packets received from the network from this virtual server.')
virtualServerPacketsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPacketsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPacketsOutHi32.setDescription('The number of packets sent to the network from this virtual server.')
virtualServerCookieMethod = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unspecified", 1), ("insert", 2), ("rewrite", 3), ("passive", 4), ("hash", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerCookieMethod.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerCookieMethod.setDescription('The cookie persistence method for this virtual server. This value is now set on the load balancing pool. This will always return unspecified(1).')
virtualServerRule = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 29), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerRule.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerRule.setDescription('The load balancing rule used by this virtual server.')
virtualServerPool = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 30), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerPool.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerPool.setDescription('The load balancing pool used by this virtual server if a load balancing rule is not defined.')
virtualServerARPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerARPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerARPEnabled.setDescription('States whether ARP is enabled for this virtual server; true = enabled, false = disabled.')
virtualServerLastHopPool = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 32), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerLastHopPool.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerLastHopPool.setDescription('The load balancing pool used by this virtual server if traffic is transparent.')
virtualServerTranslateAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 33), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerTranslateAddress.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerTranslateAddress.setDescription('States whether BIG-IP should translate virtual server addresses; true = translate, false = no translate.')
virtualServerTranslatePort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerTranslatePort.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerTranslatePort.setDescription('States whether port translation is enabled; true = enabled, false = disabled.')
virtualServerSvcDownReset = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerSvcDownReset.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerSvcDownReset.setDescription('States whether a reset is sent when service is marked down; true = reset is sent, false = reset is not sent.')
virtualServerMayUseProxy = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerMayUseProxy.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerMayUseProxy.setDescription('States whether a virtual server will be associated with an SSL proxy; true = yes, false = no.')
virtualServerAccelerate = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 3, 2, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: virtualServerAccelerate.setStatus('mandatory')
if mibBuilder.loadTexts: virtualServerAccelerate.setDescription('States whether the fast flow feature is enabled for this virtual server; true = yes, false = no.')
snatTransTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1), )
if mibBuilder.loadTexts: snatTransTable.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransTable.setDescription('A table of all the secure NATS entries.')
snatTransEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "snatTransAddr"))
if mibBuilder.loadTexts: snatTransEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransEntry.setDescription('Columns in the table of secure NATS entries.')
snatTransEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransEnabled.setDescription('States whether this TransAddress is enabled for SNAT; true = enabled, false = disabled.')
snatTransAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransAddr.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransAddr.setDescription('The IP address to the outside world for this SNAT.')
snatTransIface = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 10))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransIface.setStatus('deprecated')
if mibBuilder.loadTexts: snatTransIface.setDescription('SNATs now exist on VLANS and not specific interfaces. This OID is deprecated and will always return 0.0.0.0.')
snatTransNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransNetmask.setDescription('The network mask for the snatTransAddr.')
snatTransBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransBroadcast.setDescription('The broadcast address for the snatTransAddr.')
snatTransSecsCollectingStats = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransSecsCollectingStats.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransSecsCollectingStats.setDescription('The number of seconds we have been collecting statistics for this port.')
snatTransBitsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransBitsIn.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransBitsIn.setDescription('The total bits in for this SNAT.')
snatTransBitsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransBitsOut.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransBitsOut.setDescription('The total bits out for this SNAT.')
snatTransPktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransPktsIn.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransPktsIn.setDescription('The total packets in for this SNAT.')
snatTransPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransPktsOut.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransPktsOut.setDescription('The total packets out for this SNAT.')
snatTransCurrConns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransCurrConns.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransCurrConns.setDescription('The number of connections currently open for this SNAT.')
snatTransMaxConns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransMaxConns.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransMaxConns.setDescription('The maximum number of connections this SNAT has had open at any one time.')
snatTransTotalConns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransTotalConns.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransTotalConns.setDescription('The total number of connections this SNAT has had since the SNAT started.')
snatTransBitsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransBitsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransBitsInHi32.setDescription('The upper 32 bits of the total number of bits in for this SNAT.')
snatTransBitsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransBitsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransBitsOutHi32.setDescription('The upper 32 bits of the total number of bits out for this SNAT.')
snatTransPktsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransPktsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransPktsInHi32.setDescription('The upper 32 bits of the total number of packets in for this SNAT.')
snatTransPktsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransPktsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransPktsOutHi32.setDescription('The upper 32 bits of the total number of packets out for this SNAT.')
snatTransLastTransPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransLastTransPort.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransLastTransPort.setDescription('Last translated port accessed using the SNAT.')
snatTransUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransUnitId.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransUnitId.setDescription('Unit number of the load balancer to which the SNAT translation address is assigned.')
snatTransVLANs = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransVLANs.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransVLANs.setDescription('If this list is empty, (the default) this secure translation address will be accessible on all VLANs. If this list is not empty then this secure translation address will be accessible only on those VLANs specified in the list.')
snatTransServices = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 1, 1, 21), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTransServices.setStatus('mandatory')
if mibBuilder.loadTexts: snatTransServices.setDescription('If this list is empty, (the default) this SNAT will map all services and protocols. If this list is not empty, then the listed services and protocols will not be mapped.')
snatOrigTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2), )
if mibBuilder.loadTexts: snatOrigTable.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigTable.setDescription('A table of all the secure NATS entries.')
snatOrigEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "snatOrigAddr"))
if mibBuilder.loadTexts: snatOrigEntry.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigEntry.setDescription('Columns in the table of secure NATS entries.')
snatOrigEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigEnabled.setDescription('States whether this OrigAddress is enabled for SNAT; true = enabled, false = disabled.')
snatOrigAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigAddr.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigAddr.setDescription('The IP address to the outside world for this SNAT.')
snatOrigConnLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigConnLimit.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigConnLimit.setDescription('The maximum number of connections through this snat.')
snatOrigTransAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigTransAddr.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigTransAddr.setDescription('The translation address corresponding to this original address.')
snatOrigTcpIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigTcpIdleTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigTcpIdleTimeout.setDescription('The idle timeout value for TCP connections through this SNAT.')
snatOrigUdpIdleTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigUdpIdleTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigUdpIdleTimeout.setDescription('The idle timeout value for TCP connections through this SNAT.')
snatOrigStatsZeroTime = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigStatsZeroTime.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigStatsZeroTime.setDescription('The time the BIG-IP started collecting statistics for this port.')
snatOrigSecsCollectingStats = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigSecsCollectingStats.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigSecsCollectingStats.setDescription('The number of seconds the BIG-IP has been collecting statistics for this port.')
snatOrigBitsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigBitsIn.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigBitsIn.setDescription('Total bits in for this SNAT. (XXX - Low order 32)')
snatOrigBitsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigBitsOut.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigBitsOut.setDescription('Total bits out for this SNAT.')
snatOrigPktsIn = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigPktsIn.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigPktsIn.setDescription('Total packets in for this SNAT.')
snatOrigPktsOut = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigPktsOut.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigPktsOut.setDescription('Total packets out for this SNAT.')
snatOrigCurrConns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigCurrConns.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigCurrConns.setDescription('The current number of connections for this SNAT.')
snatOrigMaxConns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigMaxConns.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigMaxConns.setDescription('The maximum number of connections this SNAT has had at any one time.')
snatOrigTotalConns = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigTotalConns.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigTotalConns.setDescription('The total number of connections this SNAT has had since the SNAT started.')
snatOrigBitsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigBitsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigBitsInHi32.setDescription('The total number of bits in for this SNAT (High order 32).')
snatOrigBitsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigBitsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigBitsOutHi32.setDescription('The total number of bits out for this SNAT (High order 32).')
snatOrigPktsInHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigPktsInHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigPktsInHi32.setDescription('The upper 32 bits of the total number of packets in for this SNAT.')
snatOrigPktsOutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigPktsOutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigPktsOutHi32.setDescription('The upper 32 bits of the total number of packets out for this SNAT.')
snatOrigLastTransPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 4, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatOrigLastTransPort.setStatus('mandatory')
if mibBuilder.loadTexts: snatOrigLastTransPort.setDescription('Last translated port accessed using the SNAT.')
uptime = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 50), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: uptime.setStatus('deprecated')
if mibBuilder.loadTexts: uptime.setDescription('This OID is deprecated. See globalStatUptime. The uptime of this device -- not the uptime of the SNMP agent.')
contot = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 51), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: contot.setStatus('deprecated')
if mibBuilder.loadTexts: contot.setDescription('This OID is deprecated. See globalStatTotalConn. The total number of connections this balancer has serviced.')
concur = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 52), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: concur.setStatus('deprecated')
if mibBuilder.loadTexts: concur.setDescription('This OID is deprecated. See globalStatCurrentConn. The number of current connections.')
conmax = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 53), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: conmax.setStatus('deprecated')
if mibBuilder.loadTexts: conmax.setDescription('This OID is deprecated. See globalStatMaxConn. The maximum number of connections that this balancer has serviced at one time.')
pktsin = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 54), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktsin.setStatus('deprecated')
if mibBuilder.loadTexts: pktsin.setDescription('This OID is deprecated. See globalStatPcktsin. The total count of all packets read off the network.')
pktsout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 55), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktsout.setStatus('deprecated')
if mibBuilder.loadTexts: pktsout.setDescription('This OID is deprecated. See globalStatPcktsout. The total count of all packets written to the network.')
bitsin = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 56), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitsin.setStatus('deprecated')
if mibBuilder.loadTexts: bitsin.setDescription('This OID is deprecated. See globalStatBitsin. The total number of bits read off the network.')
bitsout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 57), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitsout.setStatus('deprecated')
if mibBuilder.loadTexts: bitsout.setDescription('This OID is deprecated. See globalStatBitsout. The total count of all bits written to the network.')
portdeny = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 58), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portdeny.setStatus('mandatory')
if mibBuilder.loadTexts: portdeny.setDescription('The count of port denies that has occurred.')
droppedin = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 59), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: droppedin.setStatus('mandatory')
if mibBuilder.loadTexts: droppedin.setDescription('The count of inbound packets that have been dropped.')
droppedout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 60), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: droppedout.setStatus('mandatory')
if mibBuilder.loadTexts: droppedout.setDescription('The count of outbound packets that have been dropped.')
active = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 61), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("standby", 1), ("active", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: active.setStatus('deprecated')
if mibBuilder.loadTexts: active.setDescription('This OID is deprecated. See globalAttrMaster. Mode of this BIG-IP: active or standby.')
mirrorenabled = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 62), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mirrorenabled.setStatus('deprecated')
if mibBuilder.loadTexts: mirrorenabled.setDescription('This OID is deprecated. See globalAttrMirrorEnabled. State of mirroring on this BIG-IP: enabled or disabled. This OID does not apply to 3-DNS.')
resetcounters = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 63), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(2, 1, 99))).clone(namedValues=NamedValues(("unreset", 2), ("reset", 1), ("unsupported", 99)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: resetcounters.setStatus('mandatory')
if mibBuilder.loadTexts: resetcounters.setDescription('Setting this value to reset(1) will set the BIG-IP traffic counters to 0.')
pktsinHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 64), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktsinHi32.setStatus('deprecated')
if mibBuilder.loadTexts: pktsinHi32.setDescription('This OID is deprecated. See globalStatPcktsinHi32. The total count of all packets read off the network.')
pktsoutHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 65), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pktsoutHi32.setStatus('deprecated')
if mibBuilder.loadTexts: pktsoutHi32.setDescription('This OID is deprecated. See globalStatPcktsoutHi32. The total count of all packets written to the network.')
bitsinHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 66), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitsinHi32.setStatus('deprecated')
if mibBuilder.loadTexts: bitsinHi32.setDescription('This OID is deprecated. See globalStatBitsinHi32. The total number of bits read off the network.')
bitsoutHi32 = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 67), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bitsoutHi32.setStatus('deprecated')
if mibBuilder.loadTexts: bitsoutHi32.setDescription('This OID is deprecated. See globalStatBitsoutHi32. The total count of all bits written to the network.')
nodePing = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 68), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodePing.setStatus('deprecated')
if mibBuilder.loadTexts: nodePing.setDescription('This OID is deprecated. Node ping interval in seconds.')
nodeTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 69), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodeTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: nodeTimeout.setDescription('This OID is deprecated. Node timeout interval in seconds.')
loadbalMode = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 70), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 99))).clone(namedValues=NamedValues(("roundrobin", 1), ("ratioMember", 2), ("leastConnMember", 3), ("observedMember", 4), ("predictiveMember", 5), ("ratioNodeAddress", 6), ("leastConnNodeAddress", 7), ("fastestNodeAddress", 8), ("observerdNodeAddress", 9), ("predictiveNodeAddress", 10), ("dynamicRatio", 11), ("fastestAppResponse", 12), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: loadbalMode.setStatus('mandatory')
if mibBuilder.loadTexts: loadbalMode.setDescription('The global load balance mode. This OID does not apply to 3-DNS.')
watchDogArmed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 71), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("armed", 1), ("disarmed", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: watchDogArmed.setStatus('deprecated')
if mibBuilder.loadTexts: watchDogArmed.setDescription('This OID is deprecated. See globalAttrWatchDogArmed. Watch dog card state.')
snatConnLimit = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 72), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatConnLimit.setStatus('deprecated')
if mibBuilder.loadTexts: snatConnLimit.setDescription('This OID is deprecated. See globalAttrSNATConnLimit. Number of simultaneous connections allowed through a SNAT. This OID does not apply to 3-DNS.')
snatTCPIdleTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 73), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatTCPIdleTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: snatTCPIdleTimeout.setDescription('This OID is deprecated. See globalAttrSNATTCPIdleTimeout. Default connection timeout for SNAT TCP connections. This OID does not apply to 3-DNS.')
snatUDPIdleTimeout = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 74), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: snatUDPIdleTimeout.setStatus('deprecated')
if mibBuilder.loadTexts: snatUDPIdleTimeout.setDescription('This OID is deprecated. See globalAttrSNATUDPIdleTimeout. Default timeout for SNAT UDP connections. This OID does not apply to 3-DNS.')
gatewayFailsafe = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 75), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 99))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: gatewayFailsafe.setStatus('deprecated')
if mibBuilder.loadTexts: gatewayFailsafe.setDescription('This OID is deprecated. See globalAttrGatewayFailsafeArmed. Is gateway failsafe pinging enabled.')
unitId = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 76), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: unitId.setStatus('deprecated')
if mibBuilder.loadTexts: unitId.setDescription('This OID is deprecated. See globalAttrUnitID. Unit id(s) for this load balancer.')
memoryUsed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 77), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryUsed.setStatus('deprecated')
if mibBuilder.loadTexts: memoryUsed.setDescription('This OID is deprecated. See globalStatMemoryPoolUsed. Memory used by the load balancer kernel.')
memoryTotal = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 78), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memoryTotal.setStatus('deprecated')
if mibBuilder.loadTexts: memoryTotal.setDescription('This OID is deprecated. See globalStatMemoryPoolTotal. Total memory available to the load balancer kernel.')
cpuTemperature = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 79), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuTemperature.setStatus('deprecated')
if mibBuilder.loadTexts: cpuTemperature.setDescription('This OID is deprecated.')
fanSpeed = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 80), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanSpeed.setStatus('deprecated')
if mibBuilder.loadTexts: fanSpeed.setDescription('This OID is deprecated.')
multiprocessingMode = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 81), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 99))).clone(namedValues=NamedValues(("up", 1), ("anip", 2), ("smp", 3), ("unsupported", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: multiprocessingMode.setStatus('deprecated')
if mibBuilder.loadTexts: multiprocessingMode.setDescription('This OID is deprecated. See globalStatMultiProcessorMode. The current multiprocessing mode of this BIG-IP. There are three possible multiprocessing modes for a BIG-IP. up(1) is the uniprocessor mode. The BIG-IP will always initially startup in this mode. During boot the BIG-IP if it is configured for and capable of multiprocessing will switch to either ANIP(2), or SMP(3) modes. ANIP is the auxiliary network interface mode. SMP is the symmetric multiprocessor mode.')
percentANIP = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 82), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: percentANIP.setStatus('deprecated')
if mibBuilder.loadTexts: percentANIP.setDescription('This OID is deprecated. See globalStatANIPPercent. Percentage of time the ANIP(auxiliary network interface processor) is doing useful work.')
cpuCount = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 83), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuCount.setStatus('deprecated')
if mibBuilder.loadTexts: cpuCount.setDescription('This OID is deprecated. See globalStatCPUCount. The number of CPUs present on this BIG-IP.')
vaddressNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressNumber.setDescription('The number of virtual IP addresses present on this system.')
vaddressTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2), )
if mibBuilder.loadTexts: vaddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressTable.setDescription('A list of virtual IP addresses. The number of entries is given by the value of vaddressNumber.')
vaddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "vaddressIndex"))
if mibBuilder.loadTexts: vaddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressEntry.setDescription('A table entry containing virtual address information.')
vaddressIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressIndex.setDescription('A unique value for each virtual address defined.')
vaddressDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressDescr.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressDescr.setDescription('A textual string describing the virtual address.')
vaddressIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressIpAddr.setDescription('The IP address for this virtual address.')
vaddressPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressPktsin.setDescription('The total packets in for this virtual address.')
vaddressPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressPktsout.setDescription('The total packets out of this virtual address.')
vaddressBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressBitsin.setDescription('The total bits in for this virtual address.')
vaddressBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressBitsout.setDescription('The total bits out of this virtual address.')
vaddressConcur = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressConcur.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressConcur.setDescription('The current number of connections on this virtual address.')
vaddressConmax = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressConmax.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressConmax.setDescription('The maximum number of connections this virtual server has had open at any one time.')
vaddressConlimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressConlimit.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressConlimit.setDescription('The total number of connections this virtual address can support at one time.')
vaddressContot = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressContot.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressContot.setDescription('The total number of connections this virtual server has served since the server started.')
vaddressStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ready", 1), ("maintenance", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressStatus.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressStatus.setDescription('Status of this virtual address.')
vaddressPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressPktsinHi32.setDescription('The total packets in for this virtual address.')
vaddressPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressPktsoutHi32.setDescription('The total packets out of this virtual address.')
vaddressBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressBitsinHi32.setDescription('The total bits in for this virtual address.')
vaddressBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 100, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vaddressBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vaddressBitsoutHi32.setDescription('The total bits out of this virtual address.')
ndaddrNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrNumber.setDescription('The number of node addresses present on this system.')
ndaddrTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2), )
if mibBuilder.loadTexts: ndaddrTable.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrTable.setDescription('A list of ndaddr entries. The number of entries is given by the value of ndaddrNumber.')
ndaddrEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "ndaddrIndex"))
if mibBuilder.loadTexts: ndaddrEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrEntry.setDescription('A ndaddr entry containing ndaddr statistics.')
ndaddrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrIndex.setDescription('A unique value for each ndaddr defined.')
ndaddrDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrDescr.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrDescr.setDescription('A textual string describing the node address.')
ndaddrIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrIpAddr.setDescription('The Node address (IP Address).')
ndaddrPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrPktsin.setDescription('The total packets in for this node address.')
ndaddrPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrPktsout.setDescription('The total packets out for this node address.')
ndaddrBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrBitsin.setDescription('The total bits in for this node address.')
ndaddrBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrBitsout.setDescription('The total bits out for this node address.')
ndaddrConcur = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrConcur.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrConcur.setDescription('The number of current connections for this node address.')
ndaddrConmax = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrConmax.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrConmax.setDescription('The maximum number of connections this node address has had open at one time.')
ndaddrConlimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrConlimit.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrConlimit.setDescription('The maximum number of connections this node address is allowed to have open at one time.')
ndaddrContot = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrContot.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrContot.setDescription('The total connections that this node address had had.')
ndaddrStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 12), BigAPIStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrStatus.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrStatus.setDescription('The status of this node address.')
ndaddrPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrPktsinHi32.setDescription('The total packets in for this node address.')
ndaddrPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrPktsoutHi32.setDescription('The total packets out for this node address.')
ndaddrBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrBitsinHi32.setDescription('The total bits in for this node address.')
ndaddrBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrBitsoutHi32.setDescription('The total bits out for this node address.')
ndaddrMaintenance = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrMaintenance.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrMaintenance.setDescription('States whether this node address is in maintenance mode; true = maintenance mode, false = no maintenance mode.')
ndaddrIsVirtual = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrIsVirtual.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrIsVirtual.setDescription('States whether the node server is on a different BIG-IP; true = yes, false = no.')
ndaddrRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrRatio.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrRatio.setDescription('Node address ratio, used is load balance algorithm.')
ndaddrTotalRealMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrTotalRealMemory.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrTotalRealMemory.setDescription('Node address, total real memory in KB.')
ndaddrAvailableRealMemory = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 21), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrAvailableRealMemory.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrAvailableRealMemory.setDescription('Node address, total available real memory in KB.')
ndaddrTotalDisk = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 22), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrTotalDisk.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrTotalDisk.setDescription('Node address, total available disk space in KB.')
ndaddrAvailableDisk = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 23), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrAvailableDisk.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrAvailableDisk.setDescription('Node address, available disk space in KB.')
ndaddrAvailableCPU = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 24), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrAvailableCPU.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrAvailableCPU.setDescription('Node address, percentage of CPU available.')
ndaddrDynamicRatio = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 25), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrDynamicRatio.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrDynamicRatio.setDescription('Node address, dynamic ratio, used in load balance algorithm.')
ndaddrPingerState = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 101, 2, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unchecked", 1), ("up", 2), ("down", 3), ("forcedDown", 4), ("checking", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ndaddrPingerState.setStatus('mandatory')
if mibBuilder.loadTexts: ndaddrPingerState.setDescription('Enumerated type, describing node server state, up, down checking, unchecked.')
natNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natNumber.setStatus('mandatory')
if mibBuilder.loadTexts: natNumber.setDescription('The number of NATS present on this system.')
natTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2), )
if mibBuilder.loadTexts: natTable.setStatus('mandatory')
if mibBuilder.loadTexts: natTable.setDescription('A list of NAT entries. The number of entries is given by the value of natNumber.')
natEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "natIndex"))
if mibBuilder.loadTexts: natEntry.setStatus('mandatory')
if mibBuilder.loadTexts: natEntry.setDescription('A NAT entry containing information by nat.')
natIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natIndex.setStatus('mandatory')
if mibBuilder.loadTexts: natIndex.setDescription('A unique value for each NAT defined.')
natDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natDescr.setStatus('mandatory')
if mibBuilder.loadTexts: natDescr.setDescription('A textual string describing the NAT.')
natIpAddrFR = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natIpAddrFR.setStatus('mandatory')
if mibBuilder.loadTexts: natIpAddrFR.setDescription('The FROM IP Address for the NAT.')
natIpAddrTO = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natIpAddrTO.setStatus('mandatory')
if mibBuilder.loadTexts: natIpAddrTO.setDescription('The TO IP Address for the NAT.')
natPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: natPktsin.setDescription('The total packets in for this NAT.')
natPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: natPktsout.setDescription('The total packets out for this NAT.')
natBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: natBitsin.setDescription('The total bits in for this NAT.')
natBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: natBitsout.setDescription('The total bits out for this NAT.')
natPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: natPktsinHi32.setDescription('The total packets in for this NAT.')
natPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: natPktsoutHi32.setDescription('The total packets out for this NAT.')
natBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: natBitsinHi32.setDescription('The total bits in for this NAT.')
natBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: natBitsoutHi32.setDescription('The total bits out for this NAT.')
natOutsideNetmask = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 13), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natOutsideNetmask.setStatus('mandatory')
if mibBuilder.loadTexts: natOutsideNetmask.setDescription('The outside netmask for this NAT.')
natOutsideBroadcast = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 14), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natOutsideBroadcast.setStatus('mandatory')
if mibBuilder.loadTexts: natOutsideBroadcast.setDescription('The outside broadcast address for this NAT.')
natInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 15), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natInterface.setStatus('deprecated')
if mibBuilder.loadTexts: natInterface.setDescription('NATs now exist on VLANS and not specific interfaces. This OID is deprecated and will always return 0.0.0.0.')
natUnitId = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 16), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natUnitId.setStatus('mandatory')
if mibBuilder.loadTexts: natUnitId.setDescription('The unit id associated with this NAT.')
natVLANs = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 17), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natVLANs.setStatus('mandatory')
if mibBuilder.loadTexts: natVLANs.setDescription('If this list is empty, (the default) this NAT will be accessible on all VLANS. If this list is not empty, this NAT will be accessible only on those VLANs specified in the list.')
natARPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natARPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: natARPEnabled.setDescription('States whether the NAT can send ARP requests; true = yes, false = no.')
natEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: natEnabled.setDescription('States whether the NAT is enabled; true = enabled, false = disabled.')
natServices = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 102, 2, 1, 20), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: natServices.setStatus('mandatory')
if mibBuilder.loadTexts: natServices.setDescription('If this list is empty, (the default) this NAT will map all services and protocols. If this list is not empty, then the listed services and protocols will not be mapped.')
vportNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportNumber.setStatus('mandatory')
if mibBuilder.loadTexts: vportNumber.setDescription('The number of virtual ports present on this system.')
vportTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2), )
if mibBuilder.loadTexts: vportTable.setStatus('mandatory')
if mibBuilder.loadTexts: vportTable.setDescription('A list of virtual port entries. The number of entries is given by the value of vportNumber.')
vportEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "vportIndex"))
if mibBuilder.loadTexts: vportEntry.setStatus('mandatory')
if mibBuilder.loadTexts: vportEntry.setDescription('A virtual port entry containing virtual port statistics.')
vportIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportIndex.setStatus('mandatory')
if mibBuilder.loadTexts: vportIndex.setDescription('A unique value for each virtual port defined.')
vportPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportPort.setStatus('mandatory')
if mibBuilder.loadTexts: vportPort.setDescription('The port Number for the virtual port.')
vportDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportDescr.setStatus('mandatory')
if mibBuilder.loadTexts: vportDescr.setDescription('A textual string describing the virtual port.')
vportPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: vportPktsin.setDescription('The total packets in for this virtual port.')
vportPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: vportPktsout.setDescription('The total packets out for this virtual port.')
vportBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: vportBitsin.setDescription('The total bits in for this virtual port.')
vportBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: vportBitsout.setDescription('The total bits out for this virtual port.')
vportConcur = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportConcur.setStatus('mandatory')
if mibBuilder.loadTexts: vportConcur.setDescription('The number of current connections for this virtual port')
vportConmax = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportConmax.setStatus('mandatory')
if mibBuilder.loadTexts: vportConmax.setDescription('The maximum number of connections this virtual port has had open at any one time.')
vportConlimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportConlimit.setStatus('mandatory')
if mibBuilder.loadTexts: vportConlimit.setDescription('The connection limit for this virtual port.')
vportContot = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportContot.setStatus('mandatory')
if mibBuilder.loadTexts: vportContot.setDescription('The total number of connections this virtual port has had open since the server started.')
vportReaped = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportReaped.setStatus('mandatory')
if mibBuilder.loadTexts: vportReaped.setDescription('The total connections reaped on this virtual port.')
vportPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vportPktsinHi32.setDescription('The total packets in for this virtual port.')
vportPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vportPktsoutHi32.setDescription('The total packets out for this virtual port.')
vportBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vportBitsinHi32.setDescription('The total bits in for this virtual port.')
vportBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: vportBitsoutHi32.setDescription('The total bits out for this virtual port.')
vportAllowed = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("allowed", 1), ("disallowed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportAllowed.setStatus('mandatory')
if mibBuilder.loadTexts: vportAllowed.setDescription('Is TCP access allowed for this port?')
vportTCPpersistence = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 18), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportTCPpersistence.setStatus('mandatory')
if mibBuilder.loadTexts: vportTCPpersistence.setDescription('Number of seconds before TCP persistence expires for this virtual port.')
vportUDPpersistence = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 19), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportUDPpersistence.setStatus('mandatory')
if mibBuilder.loadTexts: vportUDPpersistence.setDescription('Number of seconds before UDP persistence expires for this virtual port.')
vportIPpersistence = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 20), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportIPpersistence.setStatus('mandatory')
if mibBuilder.loadTexts: vportIPpersistence.setDescription('Number of seconds before IP persistence expires for this virtual port.')
vportUDPEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 103, 2, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: vportUDPEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: vportUDPEnabled.setDescription('States whether the UDP access to this port is enabled for this port; true = enabled, false = disabled.')
memberTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2), )
if mibBuilder.loadTexts: memberTable.setStatus('mandatory')
if mibBuilder.loadTexts: memberTable.setDescription('A table containing balancer member information.')
memberEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "memberVirtualAddress"), (0, "LOAD-BAL-SYSTEM-MIB", "memberVirtualAddressPort"), (0, "LOAD-BAL-SYSTEM-MIB", "memberOrdinal"))
if mibBuilder.loadTexts: memberEntry.setStatus('mandatory')
if mibBuilder.loadTexts: memberEntry.setDescription('Information Specific to Members.')
memberVirtualAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberVirtualAddress.setStatus('mandatory')
if mibBuilder.loadTexts: memberVirtualAddress.setDescription('The virtual IP address.')
memberVirtualAddressPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberVirtualAddressPort.setStatus('mandatory')
if mibBuilder.loadTexts: memberVirtualAddressPort.setDescription('The virtual IP address port.')
memberOrdinal = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberOrdinal.setStatus('mandatory')
if mibBuilder.loadTexts: memberOrdinal.setDescription('The virtual IP address member ordinal number.')
memberAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberAddress.setStatus('mandatory')
if mibBuilder.loadTexts: memberAddress.setDescription('The node IP address for this member.')
memberPort = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberPort.setStatus('mandatory')
if mibBuilder.loadTexts: memberPort.setDescription('The node port for this member.')
memberStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 6), BigAPIStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberStatus.setStatus('mandatory')
if mibBuilder.loadTexts: memberStatus.setDescription('The status of this member.')
memberPktsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberPktsin.setStatus('mandatory')
if mibBuilder.loadTexts: memberPktsin.setDescription('The count of packets read off the network for this member.')
memberPktsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberPktsout.setStatus('mandatory')
if mibBuilder.loadTexts: memberPktsout.setDescription('The count of packets written to the network for this member.')
memberBitsin = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberBitsin.setStatus('mandatory')
if mibBuilder.loadTexts: memberBitsin.setDescription('The count of bits read off the network for this member.')
memberBitsout = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberBitsout.setStatus('mandatory')
if mibBuilder.loadTexts: memberBitsout.setDescription('The count of bits written to the network for this member.')
memberConcur = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberConcur.setStatus('mandatory')
if mibBuilder.loadTexts: memberConcur.setDescription('The number of connections currently open for this member.')
memberConmax = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberConmax.setStatus('mandatory')
if mibBuilder.loadTexts: memberConmax.setDescription('The maximum number of connections this member has had open at any one time.')
memberConlimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberConlimit.setStatus('mandatory')
if mibBuilder.loadTexts: memberConlimit.setDescription('The total number of connections this member can support at one time.')
memberContot = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberContot.setStatus('mandatory')
if mibBuilder.loadTexts: memberContot.setDescription('The total number of connections this member has served since the server started.')
memberPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: memberPktsinHi32.setDescription('The count of packets read off the network for this member.')
memberPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: memberPktsoutHi32.setDescription('The count of packets written to the network for this member.')
memberBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: memberBitsinHi32.setDescription('The count of bits read off the network for this member.')
memberBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 104, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: memberBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: memberBitsoutHi32.setDescription('The count of bits written to the network for this member.')
nodesNumber = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesNumber.setStatus('mandatory')
if mibBuilder.loadTexts: nodesNumber.setDescription('The number of Nodes present on this system.')
nodesTable = MibTable((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2), )
if mibBuilder.loadTexts: nodesTable.setStatus('mandatory')
if mibBuilder.loadTexts: nodesTable.setDescription('A list of Nodes entries. The number of entries is given by the value of nodesNumber.')
nodesEntry = MibTableRow((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1), ).setIndexNames((0, "LOAD-BAL-SYSTEM-MIB", "nodesIndex"))
if mibBuilder.loadTexts: nodesEntry.setStatus('mandatory')
if mibBuilder.loadTexts: nodesEntry.setDescription('A ndaddr entry containing ndaddr statistics.')
nodesIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesIndex.setStatus('mandatory')
if mibBuilder.loadTexts: nodesIndex.setDescription('A unique value for each nodes defined.')
nodesAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesAddr.setStatus('mandatory')
if mibBuilder.loadTexts: nodesAddr.setDescription('The IP Address and Port of the Node.')
nodesPktsinLo32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesPktsinLo32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesPktsinLo32.setDescription('The low 32 bits of the number of packets delivered to this Node.')
nodesPktsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesPktsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesPktsinHi32.setDescription('The high 32 bits of the number of packets delivered to this Node.')
nodesPktsoutLo32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesPktsoutLo32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesPktsoutLo32.setDescription('The low 32 bits of the number of packets delivered from this Node.')
nodesPktsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesPktsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesPktsoutHi32.setDescription('The high 32 bits of the number of packets delivered from this Node.')
nodesBitsinLo32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesBitsinLo32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesBitsinLo32.setDescription('The low 32 bits of the number of bits delivered to this Node.')
nodesBitsinHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesBitsinHi32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesBitsinHi32.setDescription('The high 32 bits of the number of bits delivered to this Node.')
nodesBitsoutLo32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesBitsoutLo32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesBitsoutLo32.setDescription('The low 32 bits of the number of bits delivered from this Node.')
nodesBitsoutHi32 = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesBitsoutHi32.setStatus('mandatory')
if mibBuilder.loadTexts: nodesBitsoutHi32.setDescription('The high 32 bits of the number of bits delivered from this Node.')
nodesCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesCurrentConnections.setStatus('mandatory')
if mibBuilder.loadTexts: nodesCurrentConnections.setDescription('The number of current connections for this Node.')
nodesMaximumConnections = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesMaximumConnections.setStatus('mandatory')
if mibBuilder.loadTexts: nodesMaximumConnections.setDescription('The maximum number of connections this Node has had open at one time.')
nodesConnectionLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesConnectionLimit.setStatus('mandatory')
if mibBuilder.loadTexts: nodesConnectionLimit.setDescription('The maximum number of connections this Node is allowed to have open at one time.')
nodesTotalConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesTotalConnections.setStatus('mandatory')
if mibBuilder.loadTexts: nodesTotalConnections.setDescription('The total connections that this Node had had.')
nodesEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: nodesEnabled.setDescription('States whether this Node is enabled; true = enabled, false = disabled.')
nodesPingerState = MibTableColumn((1, 3, 6, 1, 4, 1, 3375, 1, 1, 13, 2, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("unchecked", 1), ("up", 2), ("down", 3), ("forcedDown", 4), ("checking", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: nodesPingerState.setStatus('mandatory')
if mibBuilder.loadTexts: nodesPingerState.setDescription('Enumerated type, describing Node state, up, down checking, unchecked.')
loadBalTrapMessage = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: loadBalTrapMessage.setStatus('mandatory')
if mibBuilder.loadTexts: loadBalTrapMessage.setDescription('Text string which describes the loadBalTrap.')
ipAddressString = MibScalar((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipAddressString.setStatus('mandatory')
if mibBuilder.loadTexts: ipAddressString.setDescription('Text string which will contain either an IP address or a hostname which identifies a specific device.')
loadBalTrapMisc = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,1)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"))
if mibBuilder.loadTexts: loadBalTrapMisc.setDescription('Uncategorized trap.')
loadBalTrapServiceDown = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,2)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"), ("LOAD-BAL-SYSTEM-MIB", "ipAddressString"), ("LOAD-BAL-SYSTEM-MIB", "memberPort"))
if mibBuilder.loadTexts: loadBalTrapServiceDown.setDescription('Service Came Down.')
loadBalTrapServiceUP = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,3)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"), ("LOAD-BAL-SYSTEM-MIB", "ipAddressString"), ("LOAD-BAL-SYSTEM-MIB", "memberPort"))
if mibBuilder.loadTexts: loadBalTrapServiceUP.setDescription('Service Came Up.')
loadBalTrapReset = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,4)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"))
if mibBuilder.loadTexts: loadBalTrapReset.setDescription('System Reset.')
loadBalTrapDenial = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,5)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"))
if mibBuilder.loadTexts: loadBalTrapDenial.setDescription('REQUEST DENIAL')
loadBalTrapLogin = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,6)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"))
if mibBuilder.loadTexts: loadBalTrapLogin.setDescription('Root Login.')
loadBalTrapRemoveUnit = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,7)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"))
if mibBuilder.loadTexts: loadBalTrapRemoveUnit.setDescription('Removing unit. Potential failover of this BIG-IP.')
loadBalTrapAddUnit = NotificationType((1, 3, 6, 1, 4, 1, 3375, 1, 1, 110, 2) + (0,8)).setObjects(("LOAD-BAL-SYSTEM-MIB", "loadBalTrapMessage"))
if mibBuilder.loadTexts: loadBalTrapAddUnit.setDescription('Adding unit. This BIG-IP has taken responsibility for a new unit id.')
mibBuilder.exportSymbols("LOAD-BAL-SYSTEM-MIB", natVLANs=natVLANs, globalStatCurrentConn=globalStatCurrentConn, sslProxyTotalConn=sslProxyTotalConn, memberStatus=memberStatus, vlan=vlan, globalStatVirtualServerFragNoConn=globalStatVirtualServerFragNoConn, sslProxyBitsin=sslProxyBitsin, poolMemberRatio=poolMemberRatio, globalStatMemoryCurrentSize=globalStatMemoryCurrentSize, nat=nat, nodesBitsoutHi32=nodesBitsoutHi32, ndaddrDynamicRatio=ndaddrDynamicRatio, interfaceMediaType=interfaceMediaType, pktsout=pktsout, snatTransPktsInHi32=snatTransPktsInHi32, virtualServerSslTimeouts=virtualServerSslTimeouts, interfaceTimeout=interfaceTimeout, globalStatMaintenanceModeDeny=globalStatMaintenanceModeDeny, vaddressBitsin=vaddressBitsin, poolMemberBitsinHi32=poolMemberBitsinHi32, vlanNumber=vlanNumber, poolMemberTotalConn=poolMemberTotalConn, interface=interface, virtualServerOctetsOut=virtualServerOctetsOut, ndaddrPktsout=ndaddrPktsout, memberConlimit=memberConlimit, memberBitsout=memberBitsout, snatTransLastTransPort=snatTransLastTransPort, poolCookieHashOffset=poolCookieHashOffset, snatTransBitsOutHi32=snatTransBitsOutHi32, globalAttrIPForwarding=globalAttrIPForwarding, poolSSLTimeout=poolSSLTimeout, globalAttrSSLProxyStrictResume=globalAttrSSLProxyStrictResume, poolSimpleMask=poolSimpleMask, snatOrigBitsIn=snatOrigBitsIn, trunkInterfaces=trunkInterfaces, sslProxyVerifyServerDepth=sslProxyVerifyServerDepth, virtualServerSslNew=virtualServerSslNew, globalAttrOpen3DNSPorts=globalAttrOpen3DNSPorts, memberPort=memberPort, sslProxyCRLPathFileName=sslProxyCRLPathFileName, virtualAddressInterface=virtualAddressInterface, interfaceIpAddresses=interfaceIpAddresses, virtualServer=virtualServer, globalStatStandBySharedDrop=globalStatStandBySharedDrop, interfaceTable=interfaceTable, natTable=natTable, sslProxyClientCertificate=sslProxyClientCertificate, concur=concur, sslProxyServerCAPathFileName=sslProxyServerCAPathFileName, interfaceMediaTypeActive=interfaceMediaTypeActive, interfaceVLANSEnabled=interfaceVLANSEnabled, virtualServerOctetsInHi32=virtualServerOctetsInHi32, natPktsoutHi32=natPktsoutHi32, poolMemberPktsoutHi32=poolMemberPktsoutHi32, globalStatMemoryPoolUsed=globalStatMemoryPoolUsed, snatTransUnitId=snatTransUnitId, poolCookieExpiration=poolCookieExpiration, virtualAddressCurrentConn=virtualAddressCurrentConn, globalAttrPackageEdition=globalAttrPackageEdition, globalAttrMaster=globalAttrMaster, ifaddressUnitId=ifaddressUnitId, sslProxyServerInvalidVersions=sslProxyServerInvalidVersions, vlanName=vlanName, nodes=nodes, poolTotalConn=poolTotalConn, globalStatBitsout=globalStatBitsout, ndaddrPingerState=ndaddrPingerState, selfIPIsFloating=selfIPIsFloating, sslProxyBitsout=sslProxyBitsout, sslProxy=sslProxy, sslProxyServerCRLPathFileName=sslProxyServerCRLPathFileName, virtualServerAccelerate=virtualServerAccelerate, globalAttributes=globalAttributes, memberContot=memberContot, snatOrigPktsInHi32=snatOrigPktsInHi32, nodesPktsinLo32=nodesPktsinLo32, globalStats=globalStats, virtualServerRule=virtualServerRule, loadBalTrap=loadBalTrap, ifaddressNumber=ifaddressNumber, sslProxyBroadcast=sslProxyBroadcast, globalAttrQuietBoot=globalAttrQuietBoot, virtualAddressTotalConn=virtualAddressTotalConn, poolMemberConnLimit=poolMemberConnLimit, vlanPortLockedDown=vlanPortLockedDown, globalStatMultiProcessorMode=globalStatMultiProcessorMode, sslProxyNetmask=sslProxyNetmask, poolMemberWeight=poolMemberWeight, virtualAddressBroadcast=virtualAddressBroadcast, virtualServerAppProtocolTimeout=virtualServerAppProtocolTimeout, fanSpeed=fanSpeed, loadBalTrapAddUnit=loadBalTrapAddUnit, virtualServerMayUseProxy=virtualServerMayUseProxy, pktsin=pktsin, globalStatBitsinHi32=globalStatBitsinHi32, selfIPAddress=selfIPAddress, virtualAddressTable=virtualAddressTable, nodesIndex=nodesIndex, sslProxyVLANs=sslProxyVLANs, poolCookieHashLength=poolCookieHashLength, vaddressPktsin=vaddressPktsin, trunkTable=trunkTable, memberPktsoutHi32=memberPktsoutHi32, globalAttrMaintenceMode=globalAttrMaintenceMode, poolPktsout=poolPktsout, interfaceArmed=interfaceArmed, sslProxyPktsinHi32=sslProxyPktsinHi32, ndaddrBitsinHi32=ndaddrBitsinHi32, ndaddrAvailableRealMemory=ndaddrAvailableRealMemory, globalAttrProductCode=globalAttrProductCode, memberVirtualAddressPort=memberVirtualAddressPort, poolMinActiveMembers=poolMinActiveMembers, snatTransEntry=snatTransEntry, ndaddrConcur=ndaddrConcur, ndaddrStatus=ndaddrStatus, ndaddrMaintenance=ndaddrMaintenance, globalAttrFastFlowActive=globalAttrFastFlowActive, loadBalTraps=loadBalTraps, virtualServerConnLimit=virtualServerConnLimit, vportAllowed=vportAllowed, natEnabled=natEnabled, globalAttrPersistAcrossServices=globalAttrPersistAcrossServices, interfaceLastTimeChanged=interfaceLastTimeChanged, vportNumber=vportNumber, pktsinHi32=pktsinHi32, globalAttrWatchDogArmed=globalAttrWatchDogArmed, globalAttrPeerUnitID=globalAttrPeerUnitID, globalStatMemoryMaxUsed=globalStatMemoryMaxUsed, snatTransBitsInHi32=snatTransBitsInHi32, globalAttrVerboseLogLevel=globalAttrVerboseLogLevel, bitsin=bitsin, active=active, poolMemberIpAddress=poolMemberIpAddress, natPktsout=natPktsout, poolMemberTable=poolMemberTable, sslProxyServerCertificate=sslProxyServerCertificate, globalAttrSSLProxyUncleanShutdown=globalAttrSSLProxyUncleanShutdown, poolBitsoutHi32=poolBitsoutHi32, vportPktsout=vportPktsout, interfaceSpeed=interfaceSpeed, poolEntry=poolEntry, vaddressStatus=vaddressStatus, interfaceName=interfaceName, virtualAddressFailoverFlags=virtualAddressFailoverFlags, vaddressIpAddr=vaddressIpAddr, sslProxyDestIpAddress=sslProxyDestIpAddress, globalStatCPUCount=globalStatCPUCount, virtualAddressIpAddress=virtualAddressIpAddress, globalStatMaxConnPortDeny=globalStatMaxConnPortDeny, snatTransPktsOutHi32=snatTransPktsOutHi32, globalAttrOpenFTPPorts=globalAttrOpenFTPPorts, globalAttrOpenSSHPorts=globalAttrOpenSSHPorts, virtualAddressNetmask=virtualAddressNetmask, sslProxyBitsoutHi32=sslProxyBitsoutHi32, vportPktsin=vportPktsin, selfIPNumber=selfIPNumber, selfIPVLAN=selfIPVLAN, globalAttrUnitID=globalAttrUnitID, vaddressDescr=vaddressDescr, poolMember=poolMember, globals=globals, globalAttrSelfConnTimeout=globalAttrSelfConnTimeout, memberVirtualAddress=memberVirtualAddress, memberPktsin=memberPktsin, vaddressPktsout=vaddressPktsout, ndaddrTotalRealMemory=ndaddrTotalRealMemory, globalStatSelfTCPPortDeny=globalStatSelfTCPPortDeny, snatTransBitsOut=snatTransBitsOut, sslProxyUseSSL=sslProxyUseSSL, virtualServerTotalConn=virtualServerTotalConn, natServices=natServices, globalAttrSystemType=globalAttrSystemType, globalStatSelfUDPPortDeny=globalStatSelfUDPPortDeny, snat=snat, globalAttrFastestMaxIdleTime=globalAttrFastestMaxIdleTime, virtualAddressMaxConn=virtualAddressMaxConn, virtualAddressConnLimit=virtualAddressConnLimit, virtualServerIpAddress=virtualServerIpAddress, sslProxyClientInvalidVersions=sslProxyClientInvalidVersions, natIndex=natIndex, vportBitsinHi32=vportBitsinHi32, nodesMaximumConnections=nodesMaximumConnections, loadBalTrapDenial=loadBalTrapDenial, vportTCPpersistence=vportTCPpersistence, ndaddrPktsoutHi32=ndaddrPktsoutHi32, ndaddrRatio=ndaddrRatio, sslProxyInsertClientSessionID=sslProxyInsertClientSessionID, sslProxyOrigPort=sslProxyOrigPort, natIpAddrFR=natIpAddrFR, droppedin=droppedin, ndaddrTable=ndaddrTable, globalAttrAuthorized=globalAttrAuthorized, sslProxyPktsoutHi32=sslProxyPktsoutHi32, memberEntry=memberEntry, poolPersistMirror=poolPersistMirror, globalAttrOpenRSHPorts=globalAttrOpenRSHPorts, globalStatFanSpeed=globalStatFanSpeed, globalAttrWebAdminPort=globalAttrWebAdminPort, ndaddrConmax=ndaddrConmax, natInterface=natInterface, sslProxyLocalTarget=sslProxyLocalTarget, ndaddrPktsin=ndaddrPktsin, poolMemberMaxConn=poolMemberMaxConn, vportDescr=vportDescr, nodePing=nodePing, loadBalTrapReset=loadBalTrapReset, virtualServerSvcDownReset=virtualServerSvcDownReset, natDescr=natDescr, poolMemberBitsin=poolMemberBitsin, globalAttrAgentVersion=globalAttrAgentVersion, globalStatMaxConn=globalStatMaxConn, vlanTimeout=vlanTimeout, vportContot=vportContot, vaddressNumber=vaddressNumber, contot=contot, interfaceNumber=interfaceNumber, interfaceMediaDuplex=interfaceMediaDuplex, vportConlimit=vportConlimit, virtualAddressOctetsOut=virtualAddressOctetsOut, sslProxyVerifyClientOnce=sslProxyVerifyClientOnce, sslProxyTCPKeepAlivesEnabled=sslProxyTCPKeepAlivesEnabled, globalStatPcktsin=globalStatPcktsin, ndaddr=ndaddr, sslProxyCRLFileFileName=sslProxyCRLFileFileName, snatTransPktsOut=snatTransPktsOut, poolSimpleTimeout=poolSimpleTimeout, virtualAddressEntry=virtualAddressEntry, vportPktsoutHi32=vportPktsoutHi32, globalStatPcktsinHi32=globalStatPcktsinHi32, sslProxyClientSessionCacheTimeout=sslProxyClientSessionCacheTimeout, globalAttrAkamaiConfigFile=globalAttrAkamaiConfigFile, sslProxyMaxConn=sslProxyMaxConn, selfIPNetmask=selfIPNetmask, vportPktsinHi32=vportPktsinHi32, globalStatPcktsoutHi32=globalStatPcktsoutHi32, ndaddrTotalDisk=ndaddrTotalDisk, globalStatBitsin=globalStatBitsin, loadBalTrapMisc=loadBalTrapMisc, memoryTotal=memoryTotal, globalStatVirtualServerDupSynWrongDest=globalStatVirtualServerDupSynWrongDest, memberBitsoutHi32=memberBitsoutHi32, nodesTable=nodesTable, poolMemberBitsout=poolMemberBitsout, vportPort=vportPort, member=member, natBitsoutHi32=natBitsoutHi32, poolMaxConn=poolMaxConn, snatOrigBitsInHi32=snatOrigBitsInHi32, vaddressIndex=vaddressIndex, globalAttrSerialNumber=globalAttrSerialNumber, globalStatUDPTimeouts=globalStatUDPTimeouts, percentANIP=percentANIP, nodesBitsinLo32=nodesBitsinLo32)
mibBuilder.exportSymbols("LOAD-BAL-SYSTEM-MIB", globalStatTimeouts=globalStatTimeouts, poolMemberPoolName=poolMemberPoolName, snatOrigPktsIn=snatOrigPktsIn, vportIPpersistence=vportIPpersistence, ndaddrIndex=ndaddrIndex, virtualServerCurrentConn=virtualServerCurrentConn, loadbal=loadbal, bitsinHi32=bitsinHi32, poolMemberPriority=poolMemberPriority, sslProxyTable=sslProxyTable, snatTransTable=snatTransTable, virtualServerPool=virtualServerPool, f5systems=f5systems, sslProxyInsertClientIPAddrPort=sslProxyInsertClientIPAddrPort, nodesPktsoutLo32=nodesPktsoutLo32, nodesConnectionLimit=nodesConnectionLimit, virtualServerTranslatePort=virtualServerTranslatePort, globalStatSSLTimeouts=globalStatSSLTimeouts, ifaddressBroadcast=ifaddressBroadcast, globalAttrAutoLastHop=globalAttrAutoLastHop, loadBalTrapLogin=loadBalTrapLogin, snatOrigTable=snatOrigTable, globalAttrStickyTableLimit=globalAttrStickyTableLimit, globalStatVirtualServerUDPPortDeny=globalStatVirtualServerUDPPortDeny, globalAttrSNATConnLimit=globalAttrSNATConnLimit, sslProxyCAFileFileName=sslProxyCAFileFileName, virtualServerAppProtocol=virtualServerAppProtocol, poolMemberIpStatus=poolMemberIpStatus, droppedout=droppedout, globalStatPcktsout=globalStatPcktsout, interfaceEntry=interfaceEntry, vlanEntry=vlanEntry, virtualServerLastHopPool=virtualServerLastHopPool, vlanAllowOtherProxyARP=vlanAllowOtherProxyARP, poolMemberPort=poolMemberPort, snatTransPktsIn=snatTransPktsIn, vaddressPktsoutHi32=vaddressPktsoutHi32, snatOrigCurrConns=snatOrigCurrConns, ndaddrAvailableCPU=ndaddrAvailableCPU, poolMemberMaintenance=poolMemberMaintenance, poolMemberQty=poolMemberQty, sslProxyServerCAFileFileName=sslProxyServerCAFileFileName, virtualServerCookieMethod=virtualServerCookieMethod, natPktsinHi32=natPktsinHi32, pktsoutHi32=pktsoutHi32, trunkMediaSpeed=trunkMediaSpeed, vaddressBitsoutHi32=vaddressBitsoutHi32, snatOrigUdpIdleTimeout=snatOrigUdpIdleTimeout, vaddressEntry=vaddressEntry, vlanTable=vlanTable, globalStatPersistTimeouts=globalStatPersistTimeouts, vportConcur=vportConcur, globalStatMemoryPoolTotal=globalStatMemoryPoolTotal, natPktsin=natPktsin, vlanSnatAutomap=vlanSnatAutomap, memberPktsinHi32=memberPktsinHi32, snatTransCurrConns=snatTransCurrConns, globalAttrSSLGatewayLevel=globalAttrSSLGatewayLevel, natARPEnabled=natARPEnabled, sslProxyClientCertCAFileFilenName=sslProxyClientCertCAFileFilenName, globalAttrOpenTelnetPorts=globalAttrOpenTelnetPorts, sslProxyArpEnabled=sslProxyArpEnabled, virtualAddress=virtualAddress, vportReaped=vportReaped, virtualAddressPacketsOutHi32=virtualAddressPacketsOutHi32, selfIPTable=selfIPTable, snatTransServices=snatTransServices, f5=f5, interfaceMediaStatus=interfaceMediaStatus, globalStatANIPPercent=globalStatANIPPercent, sslProxyPktsin=sslProxyPktsin, sslProxyServerChainFileName=sslProxyServerChainFileName, natEntry=natEntry, memberTable=memberTable, snatOrigBitsOutHi32=snatOrigBitsOutHi32, snatTransTotalConns=snatTransTotalConns, snatOrigTransAddr=snatOrigTransAddr, poolTable=poolTable, poolName=poolName, sslProxyVerifyClientDepth=sslProxyVerifyClientDepth, trunkNumber=trunkNumber, virtualAddressPacketsOut=virtualAddressPacketsOut, memberConmax=memberConmax, vaddressConlimit=vaddressConlimit, multiprocessingMode=multiprocessingMode, gatewayFailsafe=gatewayFailsafe, selfIPUnitID=selfIPUnitID, trunkEntry=trunkEntry, loadBalTrapServiceUP=loadBalTrapServiceUP, poolFallbackHost=poolFallbackHost, poolPersistMode=poolPersistMode, vaddressPktsinHi32=vaddressPktsinHi32, mirrorenabled=mirrorenabled, sslProxyLastHopPool=sslProxyLastHopPool, virtualServerPersistMask=virtualServerPersistMask, snatTransAddr=snatTransAddr, globalStatNoHandlerDeny=globalStatNoHandlerDeny, sslProxyOrigIpAddress=sslProxyOrigIpAddress, interfaceSource=interfaceSource, snatTransNetmask=snatTransNetmask, vportBitsoutHi32=vportBitsoutHi32, globalStatActiveCPUCount=globalStatActiveCPUCount, natIpAddrTO=natIpAddrTO, globalStatCPUTemperature=globalStatCPUTemperature, selfIPEntry=selfIPEntry, ndaddrBitsin=ndaddrBitsin, natNumber=natNumber, snatOrigEnabled=snatOrigEnabled, virtualAddressOctetsOutHi32=virtualAddressOctetsOutHi32, memberBitsinHi32=memberBitsinHi32, pool=pool, poolBitsin=poolBitsin, poolCookieMode=poolCookieMode, vportIndex=vportIndex, globalAttrPersistTimerUsedAsLimit=globalAttrPersistTimerUsedAsLimit, natOutsideBroadcast=natOutsideBroadcast, ifaddressTable=ifaddressTable, snatTransEnabled=snatTransEnabled, globalAttrAkamaiConfigPort=globalAttrAkamaiConfigPort, poolActiveMemberCount=poolActiveMemberCount, snatConnLimit=snatConnLimit, snatOrigTotalConns=snatOrigTotalConns, ndaddrContot=ndaddrContot, poolLBMode=poolLBMode, sslProxyClientSessionCacheSize=sslProxyClientSessionCacheSize, trunk=trunk, nodesEnabled=nodesEnabled, snatTransSecsCollectingStats=snatTransSecsCollectingStats, vlanTaggedPorts=vlanTaggedPorts, ndaddrDescr=ndaddrDescr, ndaddrBitsoutHi32=ndaddrBitsoutHi32, poolMemberBitsoutHi32=poolMemberBitsoutHi32, sslProxyUnitId=sslProxyUnitId, sslProxyDestPort=sslProxyDestPort, ndaddrBitsout=ndaddrBitsout, virtualServerNumber=virtualServerNumber, globalAttrFailoverPort=globalAttrFailoverPort, interfaceMediaDuplexActive=interfaceMediaDuplexActive, virtualServerPacketsOutHi32=virtualServerPacketsOutHi32, nodesBitsoutLo32=nodesBitsoutLo32, virtualAddressNumber=virtualAddressNumber, globalAttrVendorName=globalAttrVendorName, natBitsinHi32=natBitsinHi32, interfaceMasqueradeAddress=interfaceMasqueradeAddress, snatTransMaxConns=snatTransMaxConns, DisplayString=DisplayString, virtualServerTable=virtualServerTable, sslProxyHTTPHeaderToAdd=sslProxyHTTPHeaderToAdd, virtualServerEntry=virtualServerEntry, poolMemberNumber=poolMemberNumber, sslProxyNumber=sslProxyNumber, poolMemberPktsout=poolMemberPktsout, natUnitId=natUnitId, virtualAddressPacketsInHi32=virtualAddressPacketsInHi32, memberAddress=memberAddress, virtualServerSslMisses=virtualServerSslMisses, snatTransIface=snatTransIface, ifaddressEntry=ifaddressEntry, ndaddrPktsinHi32=ndaddrPktsinHi32, virtualServerOctetsOutHi32=virtualServerOctetsOutHi32, snatUDPIdleTimeout=snatUDPIdleTimeout, snatOrigAddr=snatOrigAddr, sslProxyConnLimit=sslProxyConnLimit, globalStatVirtualServerNonSynDeny=globalStatVirtualServerNonSynDeny, virtualServerSslHits=virtualServerSslHits, poolNumber=poolNumber, BigAPIStatus=BigAPIStatus, globalAttrSSLProxyServerSessionTimeout=globalAttrSSLProxyServerSessionTimeout, globalStatMaxConnVirtualAddressDeny=globalStatMaxConnVirtualAddressDeny, virtualServerOctetsIn=virtualServerOctetsIn, vaddressBitsout=vaddressBitsout, globalAttrPersistAccrossVirtuals=globalAttrPersistAccrossVirtuals, virtualAddressOctetsIn=virtualAddressOctetsIn, poolStickyMask=poolStickyMask, globalStatIPTimeouts=globalStatIPTimeouts, selfIP=selfIP, ifaddressIpAddress=ifaddressIpAddress, globalAttrSSLProxyFailOver=globalAttrSSLProxyFailOver, globalStatVirtualServerTCPPortDeny=globalStatVirtualServerTCPPortDeny, sslProxyChainFileName=sslProxyChainFileName, snatTransBitsIn=snatTransBitsIn, globalAttrOpenCorbaPorts=globalAttrOpenCorbaPorts, nodesPktsoutHi32=nodesPktsoutHi32, natOutsideNetmask=natOutsideNetmask, nodesPingerState=nodesPingerState, sslProxyEnabled=sslProxyEnabled, virtualServerPacketsInHi32=virtualServerPacketsInHi32, portdeny=portdeny, nodesBitsinHi32=nodesBitsinHi32, vportEntry=vportEntry, sslProxyInterfaceName=sslProxyInterfaceName, poolMemberPktsin=poolMemberPktsin, snatOrigConnLimit=snatOrigConnLimit, vaddressContot=vaddressContot, snatOrigLastTransPort=snatOrigLastTransPort, ndaddrEntry=ndaddrEntry, watchDogArmed=watchDogArmed, poolMemberPktsinHi32=poolMemberPktsinHi32, snatOrigTcpIdleTimeout=snatOrigTcpIdleTimeout, vportUDPpersistence=vportUDPpersistence, vaddressTable=vaddressTable, memberBitsin=memberBitsin, virtualServerStickyMask=virtualServerStickyMask, virtualServerTranslateAddress=virtualServerTranslateAddress, cpuCount=cpuCount, ndaddrIsVirtual=ndaddrIsVirtual, globalStatMaxConnVirtualPathDeny=globalStatMaxConnVirtualPathDeny, poolBitsout=poolBitsout, vaddress=vaddress, memoryUsed=memoryUsed, ndaddrConlimit=ndaddrConlimit, loadBalTrapMessage=loadBalTrapMessage, poolPktsoutHi32=poolPktsoutHi32, vlanArmed=vlanArmed, globalAttrPersistMapProxies=globalAttrPersistMapProxies, globalStatVirtualServerFragNoPort=globalStatVirtualServerFragNoPort, poolBitsinHi32=poolBitsinHi32, virtualServerPort=virtualServerPort, snatTransBroadcast=snatTransBroadcast, cpuTemperature=cpuTemperature, ifaddressInterfaceName=ifaddressInterfaceName, virtualAddressPacketsIn=virtualAddressPacketsIn, selfIPSnatAutomap=selfIPSnatAutomap, virtualServerPacketsIn=virtualServerPacketsIn, loadBalTrapRemoveUnit=loadBalTrapRemoveUnit, poolPktsin=poolPktsin, snatOrigStatsZeroTime=snatOrigStatsZeroTime, ifaddressType=ifaddressType, globalStatBitsoutHi32=globalStatBitsoutHi32, trunkControllingInterface=trunkControllingInterface, globalAttrSNATUDPIdleTimeout=globalAttrSNATUDPIdleTimeout, poolMemberStatus=poolMemberStatus, sslProxyServerTCPKeepAlivesEnabled=sslProxyServerTCPKeepAlivesEnabled, conmax=conmax, globalStatNoNodeErrors=globalStatNoNodeErrors, globalAttrNameSurferZonePort=globalAttrNameSurferZonePort, vportConmax=vportConmax, natBitsin=natBitsin, globalAttrPackageVersion=globalAttrPackageVersion, interfaceMTU=interfaceMTU, globalStatUptime=globalStatUptime, nodeTimeout=nodeTimeout, memberConcur=memberConcur, globalAttrSSLProxyServerSessionCacheSize=globalAttrSSLProxyServerSessionCacheSize, snatOrigPktsOutHi32=snatOrigPktsOutHi32, sslProxyServerCRLFileFileName=sslProxyServerCRLFileFileName, ndaddrNumber=ndaddrNumber, interfaceDestination=interfaceDestination, sslProxyRewriteRedirects=sslProxyRewriteRedirects, virtualServerStatus=virtualServerStatus, sslProxyInsertClientCipher=sslProxyInsertClientCipher, globalAttrKernelVersion=globalAttrKernelVersion, sslProxyCAPathFileName=sslProxyCAPathFileName, interfaceFullDuplex=interfaceFullDuplex)
mibBuilder.exportSymbols("LOAD-BAL-SYSTEM-MIB", vaddressConcur=vaddressConcur, virtualServerSticky=virtualServerSticky, sslProxyAkamaize=sslProxyAkamaize, vlanTag=vlanTag, virtualServerAppProtocolReaper=virtualServerAppProtocolReaper, ipAddressString=ipAddressString, globalAttrCPUCount=globalAttrCPUCount, snatOrigBitsOut=snatOrigBitsOut, globalStatTCPTimeouts=globalStatTCPTimeouts, virtualServerMaxConn=virtualServerMaxConn, poolMemberCurrentConn=poolMemberCurrentConn, virtualAddressStatus=virtualAddressStatus, ifaddressVLANTag=ifaddressVLANTag, globalAttrMirrorEnabled=globalAttrMirrorEnabled, sslProxyBitsinHi32=sslProxyBitsinHi32, globalAttrNetReboot=globalAttrNetReboot, vlanID=vlanID, virtualServerPacketsOut=virtualServerPacketsOut, selfIPBroadcast=selfIPBroadcast, globalAttrGatewayFailsafeArmed=globalAttrGatewayFailsafeArmed, globalStatVirtualServerDupSynNodeDown=globalStatVirtualServerDupSynNodeDown, ndaddrAvailableDisk=ndaddrAvailableDisk, sslProxyEntry=sslProxyEntry, ndaddrIpAddr=ndaddrIpAddr, poolDependent=poolDependent, vlanUntaggedPorts=vlanUntaggedPorts, loadBalTrapServiceDown=loadBalTrapServiceDown, snatOrigPktsOut=snatOrigPktsOut, natBitsout=natBitsout, globalStatMemoryErrors=globalStatMemoryErrors, globalStatVirtualServerDupSynSSL=globalStatVirtualServerDupSynSSL, snatOrigMaxConns=snatOrigMaxConns, vportTable=vportTable, vportUDPEnabled=vportUDPEnabled, snatTransVLANs=snatTransVLANs, unitId=unitId, nodesTotalConnections=nodesTotalConnections, poolPktsinHi32=poolPktsinHi32, snatOrigEntry=snatOrigEntry, nodesAddr=nodesAddr, sslProxyCurrentConn=sslProxyCurrentConn, globalAttrNameSurferWebPort=globalAttrNameSurferWebPort, poolCurrentConn=poolCurrentConn, vportBitsin=vportBitsin, snatTCPIdleTimeout=snatTCPIdleTimeout, poolMemberEntry=poolMemberEntry, nodesPktsinHi32=nodesPktsinHi32, vaddressConmax=vaddressConmax, vaddressBitsinHi32=vaddressBitsinHi32, resetcounters=resetcounters, globalAttrL2CacheTimeout=globalAttrL2CacheTimeout, bitsout=bitsout, memberOrdinal=memberOrdinal, nodesEntry=nodesEntry, nodesNumber=nodesNumber, vportBitsout=vportBitsout, poolMemberRipeness=poolMemberRipeness, vport=vport, globalAttrSNATTCPIdleTimeout=globalAttrSNATTCPIdleTimeout, ifaddress=ifaddress, snatOrigSecsCollectingStats=snatOrigSecsCollectingStats, poolCookieHashName=poolCookieHashName, memberPktsout=memberPktsout, ifaddressNetmask=ifaddressNetmask, virtualAddressOctetsInHi32=virtualAddressOctetsInHi32, sslProxyUseServerSSL=sslProxyUseServerSSL, globalAttrMemoryRebootPercent=globalAttrMemoryRebootPercent, globalStatTotalConn=globalStatTotalConn, virtualAddressUnitId=virtualAddressUnitId, loadbalMode=loadbalMode, globalStatMaxANIPPercent=globalStatMaxANIPPercent, sslProxyPktsout=sslProxyPktsout, virtualServerFailoverFlags=virtualServerFailoverFlags, globalStatMemoryInUse=globalStatMemoryInUse, virtualServerPersistTimeout=virtualServerPersistTimeout, uptime=uptime, bitsoutHi32=bitsoutHi32, virtualServerARPEnabled=virtualServerARPEnabled, nodesCurrentConnections=nodesCurrentConnections)

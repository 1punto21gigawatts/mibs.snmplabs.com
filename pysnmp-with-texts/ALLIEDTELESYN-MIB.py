#
# PySNMP MIB module ALLIEDTELESYN-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/ALLIEDTELESYN-MIB
# Produced by pysmi-0.3.4 at Wed May  1 11:20:43 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "SingleValueConstraint")
ifIndex, = mibBuilder.importSymbols("IF-MIB", "ifIndex")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Bits, MibScalar, MibTable, MibTableRow, MibTableColumn, NotificationType, Gauge32, Integer32, MibIdentifier, NotificationType, ObjectIdentity, Counter64, enterprises, ModuleIdentity, Counter32, iso, TimeTicks, Unsigned32, IpAddress = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "NotificationType", "Gauge32", "Integer32", "MibIdentifier", "NotificationType", "ObjectIdentity", "Counter64", "enterprises", "ModuleIdentity", "Counter32", "iso", "TimeTicks", "Unsigned32", "IpAddress")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
class InterfaceIndexOrZero(Integer32):
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 2147483647)

alliedTelesyn = MibIdentifier((1, 3, 6, 1, 4, 1, 207))
products = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1))
mibObject = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8))
bridgeRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1))
centreCOM_AR300Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 8)).setLabel("centreCOM-AR300Router")
centreCOM_AR720Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 11)).setLabel("centreCOM-AR720Router")
centreCOM_AR300LRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 12)).setLabel("centreCOM-AR300LRouter")
centreCOM_AR310Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 13)).setLabel("centreCOM-AR310Router")
centreCOM_AR300LURouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 14)).setLabel("centreCOM-AR300LURouter")
centreCOM_AR300URouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 15)).setLabel("centreCOM-AR300URouter")
centreCOM_AR310URouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 16)).setLabel("centreCOM-AR310URouter")
centreCOM_AR350Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 17)).setLabel("centreCOM-AR350Router")
centreCOM_AR370Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 18)).setLabel("centreCOM-AR370Router")
centreCOM_AR330Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 19)).setLabel("centreCOM-AR330Router")
centreCOM_AR395Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 20)).setLabel("centreCOM-AR395Router")
centreCOM_AR390Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 21)).setLabel("centreCOM-AR390Router")
centreCOM_AR370URouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 22)).setLabel("centreCOM-AR370URouter")
centreCOM_AR740Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 23)).setLabel("centreCOM-AR740Router")
centreCOM_AR140SRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 24)).setLabel("centreCOM-AR140SRouter")
centreCOM_AR140URouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 25)).setLabel("centreCOM-AR140URouter")
centreCOM_AR320Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 26)).setLabel("centreCOM-AR320Router")
centreCOM_AR130SRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 27)).setLabel("centreCOM-AR130SRouter")
centreCOM_AR130URouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 28)).setLabel("centreCOM-AR130URouter")
centreCOM_AR160Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 29)).setLabel("centreCOM-AR160Router")
at_AR740RouterDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 43)).setLabel("at-AR740RouterDC")
centreCOM_AR120Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 44)).setLabel("centreCOM-AR120Router")
at_AR410Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 47)).setLabel("at-AR410Router")
at_AR725Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 48)).setLabel("at-AR725Router")
at_AR745Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 49)).setLabel("at-AR745Router")
at_AR410v2Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 50)).setLabel("at-AR410v2Router")
at_AR410v3Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 51)).setLabel("at-AR410v3Router")
at_AR725RouterDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 52)).setLabel("at-AR725RouterDC")
at_AR745RouterDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 53)).setLabel("at-AR745RouterDC")
at_AR450Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 54)).setLabel("at-AR450Router")
at_AR450DualRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 55)).setLabel("at-AR450DualRouter")
at_AR440Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 59)).setLabel("at-AR440Router")
at_AR441Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 60)).setLabel("at-AR441Router")
at_AR442Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 61)).setLabel("at-AR442Router")
at_AR443Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 62)).setLabel("at-AR443Router")
at_AR444Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 63)).setLabel("at-AR444Router")
at_AR420Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 64)).setLabel("at-AR420Router")
at_AR550Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 73)).setLabel("at-AR550Router")
at_AR551Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 74)).setLabel("at-AR551Router")
at_AR552Router = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 1, 75)).setLabel("at-AR552Router")
routerSwitch = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14))
at_Rapier24 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 1)).setLabel("at-Rapier24")
at_Rapier16fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 2)).setLabel("at-Rapier16fSC")
at_Rapier16fVF = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 3)).setLabel("at-Rapier16fVF")
at_Rapier16fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 4)).setLabel("at-Rapier16fMT")
at_Rapier48 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 5)).setLabel("at-Rapier48")
at_Rapier8t8fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 6)).setLabel("at-Rapier8t8fSC")
at_Rapier8t8fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 7)).setLabel("at-Rapier8t8fSCi")
at_Rapier8t8fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 8)).setLabel("at-Rapier8t8fMT")
at_Rapier8t8fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 9)).setLabel("at-Rapier8t8fMTi")
at_Rapier8fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 10)).setLabel("at-Rapier8fSC")
at_Rapier8fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 11)).setLabel("at-Rapier8fSCi")
at_Rapier8fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 12)).setLabel("at-Rapier8fMT")
at_Rapier8fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 13)).setLabel("at-Rapier8fMTi")
at_Rapier16fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 14)).setLabel("at-Rapier16fMTi")
at_RapierG6 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 15)).setLabel("at-RapierG6")
at_RapierG6SX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 16)).setLabel("at-RapierG6SX")
at_RapierG6LX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 17)).setLabel("at-RapierG6LX")
at_RapierG6MT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 18)).setLabel("at-RapierG6MT")
at_Rapier16fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 19)).setLabel("at-Rapier16fSCi")
at_Rapier24i = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 20)).setLabel("at-Rapier24i")
at_Rapier48i = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 21)).setLabel("at-Rapier48i")
at_Switchblade4AC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 22)).setLabel("at-Switchblade4AC")
at_Switchblade4DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 23)).setLabel("at-Switchblade4DC")
at_Switchblade8AC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 24)).setLabel("at-Switchblade8AC")
at_Switchblade8DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 25)).setLabel("at-Switchblade8DC")
at_9816GF = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 26)).setLabel("at-9816GF")
at_9812TF = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 27)).setLabel("at-9812TF")
at_9816GB = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 28)).setLabel("at-9816GB")
at_9812T = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 29)).setLabel("at-9812T")
at_8724XL = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 30)).setLabel("at-8724XL")
at_8748XL = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 31)).setLabel("at-8748XL")
at_8724XLDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 32)).setLabel("at-8724XLDC")
at_8748XLDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 33)).setLabel("at-8748XLDC")
at_9816GB_DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 34)).setLabel("at-9816GB-DC")
at_9812T_DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 35)).setLabel("at-9812T-DC")
at_8824 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 36)).setLabel("at-8824")
at_8848 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 37)).setLabel("at-8848")
at_8824_DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 38)).setLabel("at-8824-DC")
at_8848_DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 39)).setLabel("at-8848-DC")
at_8624XL_80 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 41)).setLabel("at-8624XL-80")
at_8724XL_80 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 42)).setLabel("at-8724XL-80")
at_8748XL_80 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 43)).setLabel("at-8748XL-80")
at_8948EX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 44)).setLabel("at-8948EX")
at_8948MX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 45)).setLabel("at-8948MX")
at_8624T2M = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 46)).setLabel("at-8624T2M")
at_Rapier24i_DC_NEBS = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 47)).setLabel("at-Rapier24i-DC-NEBS")
at_8724XL_DC_NEBS = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 48)).setLabel("at-8724XL-DC-NEBS")
at_9924T = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 49)).setLabel("at-9924T")
at_9924SP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 50)).setLabel("at-9924SP")
at_9924T_4SP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 51)).setLabel("at-9924T-4SP")
at_9924TEMC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 53)).setLabel("at-9924TEMC")
at_8724MLB = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 55)).setLabel("at-8724MLB")
at_8624POE = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 56)).setLabel("at-8624POE")
at_86482SP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 1, 14, 58)).setLabel("at-86482SP")
brouterMib = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4))
atRouter = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4))
objects = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1))
traps = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 2))
sysinfo = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3))
modules = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4))
arInterfaces = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5))
protocols = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 6))
boards = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1))
pprIcmAr023 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 39))
pprIcmAr021s = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 40))
pprIcmAr022 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 41))
pprIcmAr025 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 45))
pprIcmAr024 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 46))
pprAr300 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 49))
pprAr300L = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 52))
pprAr310 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 53))
pprAr120 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 54))
pprAr300Lu = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 55))
pprAr300u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 56))
pprAr310u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 57))
pprAr350 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 58))
pprIcmAr021u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 59))
pprAr720 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 63))
pprAr010 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 67))
pprAr012 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 68))
pprAr011 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 69))
pprAr370 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 70))
pprAr330 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 71))
pprAr395 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 72))
pprAr390 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 73))
pprAr370u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 75))
pprIcmAr020 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 76))
pprAr740 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 79))
pprAr140s = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 80))
pprAr140u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 81))
pprAr160su = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 82))
pprAr320 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 83))
pprAr130s = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 85))
pprAr130u = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 86))
pprRapier24 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 87))
pprNsm0404Pic = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 88))
pprA35SXSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 89))
pprA35LXSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 90))
pprA36MTRJ = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 91))
pprA37VF45 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 92))
pprA38LC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 93))
pprA39Tx = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 94))
pprAr740DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 95))
pprNsm0418BRI = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 96))
pprRapier16fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 97))
ppr8624xl80 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 98))
pprRapier16fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 99))
pprRapier16fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 100))
pprRapier8t8fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 101))
pprRapier8t8fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 102))
pprRapier8t8fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 103))
pprRapier8t8fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 104))
pprRapier8fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 105))
pprRapier8fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 106))
pprRapier8fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 107))
pprRapier8fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 108))
pprRapierG6 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 110))
pprRapierG6SX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 111))
pprRapierG6LX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 112))
pprRapierG6MT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 113))
pprRapier16fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 114))
pprRapier24i = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 115))
pprAr824 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 116))
pprAr816fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 117))
pprAr816fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 118))
pprAr816fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 119))
pprAr816fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 120))
pprAr88t8fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 121))
pprAr88t8fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 122))
pprAr88t8fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 123))
pprAr88t8fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 124))
pprAr88fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 125))
pprAr88fSCi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 126))
pprAr88fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 127))
pprAr88fMTi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 128))
pprAr824i = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 129))
pprAt8724XL = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 130))
pprAt8748XL = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 131))
pprAt8724XLDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 132))
pprAt8748XLDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 133))
pprAt8824 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 134))
pprAt8824DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 135))
ppr8724XLDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 141))
ppr8748XLDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 142))
pprRapier24iDC_NEBS = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 144)).setLabel("pprRapier24iDC-NEBS")
pprAt8724XLDC_NEBS = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 146)).setLabel("pprAt8724XLDC-NEBS")
pprAt8848DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 147))
pprRapier48 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 148))
pprAt8848 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 149))
pprRapier48i = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 150))
pprNsm0424BRI = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 151))
pprIcmAR026 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 153))
ppr9816GF = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 157))
ppr9812TF = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 158))
pprSbChassis4AC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 159))
pprSbChassis4DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 160))
pprSbChassis8AC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 161))
pprSbChassis8DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 162))
pprSbChassis16AC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 163))
pprSbChassis16DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 164))
pprSbControl = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 165))
pprSbControlDTM = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 166))
pprSb48t = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 167))
pprSb96t = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 168))
pprSb32fSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 169))
pprSb32fMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 170))
pprSb8fRJ = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 172))
pprSb8fSXSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 173))
pprSb8fSXMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 174))
pprSb8fLXSC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 175))
pprSb8fLXMT = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 176))
pprAr410 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 177))
pprA40SC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 178))
pprA40MTRJ = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 179))
pprA41SC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 180))
pprA41MTRJ = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 181))
pprAr725 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 182))
pprAr745 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 183))
pprSb8GBIC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 184))
pprA42GBIC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 185))
ppr9816GB = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 186))
ppr9812T = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 187))
pprNsm048DS3 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 188))
pprAr450 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 191))
pprAr450Dual = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 192))
pprSbExpander = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 193))
pprAr725DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 194))
pprAr745DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 195))
pprAr410v2 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 196))
pprAr410v3 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 197))
pprIcmAr027 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 198))
ppr8948EX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 202))
ppr8948MX = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 203))
ppr9816GBDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 204))
ppr9812TDC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 205))
pprIcmAr021v2s = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 206))
pprA50 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 207))
pprA51 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 208))
pprA52 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 209))
pprA53 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 210))
pprFanA01 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 212))
pprAtPwr01AC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 213))
pprAtPwr01DC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 214))
pprAtFan01 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 215))
pprSb24RJ = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 216))
pprSb1XFP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 217))
ppr9924T = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 218))
ppr9924SP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 219))
ppr9924TEMC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 220))
ppr9924T4SP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 221))
pprAR440 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 227))
pprAR441 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 228))
pprAR442 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 229))
pprAR443 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 230))
pprAR444 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 231))
pprAR420 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 232))
pprAt8624T2M = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 239))
pprA46Tx = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 240))
pprAR550 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 241))
pprAR551 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 242))
pprAR552 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 243))
pprC8724MLB = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 248))
pprAt86482SP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 252))
pprAt8624POE = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 253))
pprAtPwr01RAC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 254))
pprAtFan01R = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 255))
pprAtPwr02AC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 264))
pprAtPwr02RAC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 265))
pprSb24SFP = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 1, 269))
release = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 2))
iftypes = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3))
ifaceEth = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3, 1))
ifaceSyn = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3, 2))
ifaceAsyn = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3, 3))
ifaceBri = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3, 4))
ifacePri = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3, 5))
ifacePots = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3, 6))
ifaceGBIC = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 3, 7))
chips = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4))
chip68020Cpu = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 1))
chip68340Cpu = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 2))
chip68302Cpu = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 3))
chip68360Cpu = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 4))
chip860TCpu = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 5))
chipRtc1 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 21))
chipRtc2 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 22))
chipRtc3 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 23))
chipRtc4 = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 24))
chipRam1mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 31))
chipRam2mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 32))
chipRam3mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 33))
chipRam4mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 34))
chipRam6mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 36))
chipRam8mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 38))
chipRam12mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 42))
chipRam16mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 46))
chipRam20mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 50))
chipRam32mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 62))
chipFlash1mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 71))
chipFlash2mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 72))
chipFlash3mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 73))
chipFlash4mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 74))
chipFlash6mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 76))
chipFlash8mb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 78))
chipPem = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 1, 4, 120))
fanAndPs = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1))
fanAndPsRpsConnectionStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("non-supported", 0), ("connected", 1), ("not-connected", 2), ("not-monitoring", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsRpsConnectionStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsRpsConnectionStatus.setDescription('The status of the Redundant Power Supply (RPS) connection, ie, whether an RPS is actually connected or not, regardless of whether the RPS is on or not. not-supported means that an RPS is not supported in this hardware platform, connected means that the RPS is connected, not-connected means that the RPS is not connected, and not-monitoring means that the status of the RPS is not being monitored presently. RPS monitoring can be turned on via the variable fanAndPsRpsMonitoringStatus, or by the command SET SYSTEM RPSMONITOR=ON.')
fanAndPsMainPSUStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("on", 1), ("off", 2), ("faulty", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsMainPSUStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsMainPSUStatus.setDescription('The status of the main Power Supply. on means that the power supply is present and fully operational. off means that the power supply is totally off (and obviously only applies to systems with a redundant power supply). faulty means that the main power supply is delivering power but that a component of the power supply is faulty. This applies to systems like SwitchBlade which have 3 power supplies but do not provide individual power supply monitoring. Also, in the case of SwitchBlade, power supply status includes the status of the fans in the power supply.')
fanAndPsRedundantPSUStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("non-supported", 0), ("on", 1), ("off", 2), ("not-monitoring", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsRedundantPSUStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsRedundantPSUStatus.setDescription('The status of the redundant Power Supply. non-supported means this device does not support redundant power supplies, on means that the redundant power supply is connected and able to supply system power if required, off means that the redundant power supply is either not connected or is connected and is not able to supply system power if required, and not-monitoring means that the status of the RPS is not being monitored presently. RPS monitoring can be turned on via the variable fanAndPsRpsMonitoringStatus, or by the command SET SYSTEM RPSMONITOR=ON.')
fanAndPsRpsMonitoringStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("non-supported", 0), ("on", 1), ("off", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fanAndPsRpsMonitoringStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsRpsMonitoringStatus.setDescription('The current status of redundant power supply monitoring. The monitoring of the redundant power supply and its fan must be enabled by command or by setting this variable to on. The value non-supported means that this device does not support redundant power supplies. Only the values on or off may be written to this variable. If this variables reads as non-supported, an attempt to write to this variable will result in a bad value error.')
fanAndPsMainFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("non-supported", 0), ("ok", 1), ("not-ok", 2), ("warning", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsMainFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsMainFanStatus.setDescription("The status of the main Power Supply fan. non-supported means that this device does not support monitoring on the main power supply fan, or that there is no main power supply fan. The warning means the fan's speed is outside 30% of the expected speed.")
fanAndPsRedundantFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("non-supported", 0), ("ok", 1), ("not-ok", 2), ("not-monitoring", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsRedundantFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsRedundantFanStatus.setDescription('The status of the redundant Power Supply Fan. non-supported means this device does not support redundant power supplies, ok means that the redundant power supply fan is running, not-ok means that the redundant power supply fan is not running, and not-monitoring means that the status of the RPS is not being monitored presently. RPS monitoring can be turned on via the variable fanAndPsRpsMonitoringStatus, or by the command SET SYSTEM RPSMONITOR=ON.')
fanAndPsTemperatureStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("not-ok", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsTemperatureStatus.setDescription('The status of temperature in this device. ok means that the device is not capable of monitoring temperature or that the temperature is OK, not-ok means that the temperature is being monitored and is currently out of the range 0C - 45C.')
fanAndPsFanTrayPresent = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("non-supported", 0), ("present", 1), ("not-present", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsFanTrayPresent.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsFanTrayPresent.setDescription('The status of the presence of the fan tray in this system. Systems which do not support a fan tray return the value non-supported. Upon removal of the fan tray there is a short period (20s) before the value of this variable is changed to not-present. This is to allow for scheduled replacement and/or cleaning of the fan tray.')
fanAndPsFanTrayStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("non-supported", 0), ("ok", 1), ("not-ok", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsFanTrayStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsFanTrayStatus.setDescription('The status of the fan tray in this system. Systems which do not support a fan tray return the value non-supported. The value ok is returned if all fans in the fan tray are running at full speed. The value not-ok is returned if one of more of the fan tray fans is running slow or has stalled.')
fanAndPsMainMonitoringStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("non-supported", 0), ("ok", 1), ("not-ok", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsMainMonitoringStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsMainMonitoringStatus.setDescription('The current status of main power supply monitoring. The monitoring of the main power supply and its fan is always enabled by those systems that support it. Systems which do not support main power supply or fan monitoring report a value of not-supported. The value ok is returned for those systems that do support main power supply and fan monitoring, and where the monitoring operation is reporting valid information (refer to fanAndPsMainFanStatus for the current status of the system). When main power supply and fan monitoring is failing, the value not-ok is returned.')
fanAndPsPsuStatusTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11), )
if mibBuilder.loadTexts: fanAndPsPsuStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuStatusTable.setDescription('The table of AT8948 fanAndPsPsuStatusTable. Each entry in the table represents the status of one of the power supplies in AT8948 system. Each power supply has its own board ID.')
fanAndPsPsuStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "fanAndPsPsuNumber"))
if mibBuilder.loadTexts: fanAndPsPsuStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuStatusEntry.setDescription('A single entry of AT8948 fanAndPsPsuStatusTable, indexed by fanAndPsPsuNumber field.')
fanAndPsPsuNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsPsuNumber.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuNumber.setDescription('The PSU board identity for which this entry holds. If the system consists only of a single PSU board, only one entry will appear in the table, whose index is 1.')
fanAndPsPsuPresent = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsPsuPresent.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuPresent.setDescription("The PSU present state, displayed as 'yes' if present, or 'no' if absent.")
fanAndPsPsuType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("ac", 0), ("dc", 1), ("fan", 2), ("not-present", 3), ("not-supported", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsPsuType.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuType.setDescription('The PSU type, displayed as AC, or DC, or FAN, or NOT PRESENT.')
fanAndPsPsuFan = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("ok", 0), ("fail", 1), ("not-present", 2), ("not-supported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsPsuFan.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuFan.setDescription('The PSU fan status, displayed as OK, or FAIL, or NOT PRESENT.')
fanAndPsPsuTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("high", 1), ("not-present", 2), ("not-supported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsPsuTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuTemperature.setDescription('The PSU temperature, displayed as GOOD, or HIGH, or NOT PRESENT, or NOT SUPPORTED.')
fanAndPsPsuPower = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 11, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("good", 0), ("bad", 1), ("not-present", 2), ("not-supported", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsPsuPower.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsPsuPower.setDescription('The PSU power status, displayed as GOOD, or BAD, or NOT PRESENT or NOT SUPPORTED.')
fanAndPsAccelFanStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("non-supported", 0), ("ok", 1), ("not-ok", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fanAndPsAccelFanStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fanAndPsAccelFanStatus.setDescription('The status of the accelerator card fans. Non-supported means this device does not support monitoring of the accelerator card fans.')
fanAndPsRpsConnectionTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsRpsConnectionStatus"))
if mibBuilder.loadTexts: fanAndPsRpsConnectionTrap.setDescription('Generated when the RPS connection status changes.')
fanAndPsMainPSUStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,2)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsMainPSUStatus"))
if mibBuilder.loadTexts: fanAndPsMainPSUStatusTrap.setDescription('Generated when the main power supply status changes.')
fanAndPsRedundantPSUStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,3)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsRedundantPSUStatus"))
if mibBuilder.loadTexts: fanAndPsRedundantPSUStatusTrap.setDescription('Generated when the RPS status changes.')
fanAndPsMainFanStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,4)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsMainFanStatus"))
if mibBuilder.loadTexts: fanAndPsMainFanStatusTrap.setDescription('Generated when the main fan changes status.')
fanAndPsRedundantFanStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,5)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsRedundantFanStatus"))
if mibBuilder.loadTexts: fanAndPsRedundantFanStatusTrap.setDescription('Generated when the redundant fan changes status.')
fanAndPsTemperatureStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,6)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsTemperatureStatus"))
if mibBuilder.loadTexts: fanAndPsTemperatureStatusTrap.setDescription('Generated when the temperature changes status.')
fanAndPsFanTrayPresentTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,7)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsFanTrayPresent"))
if mibBuilder.loadTexts: fanAndPsFanTrayPresentTrap.setDescription('Generated when the fan tray presence status changes.')
fanAndPsFanTrayStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,8)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsFanTrayStatus"))
if mibBuilder.loadTexts: fanAndPsFanTrayStatusTrap.setDescription('Generated when the fan tray status changes.')
fanAndPsMainMonitoringStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,9)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsMainMonitoringStatus"))
if mibBuilder.loadTexts: fanAndPsMainMonitoringStatusTrap.setDescription('Generated when the main power supply monitoring status changes.')
fanAndPsAccelFanStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 1) + (0,10)).setObjects(("ALLIEDTELESYN-MIB", "fanAndPsAccelFanStatus"))
if mibBuilder.loadTexts: fanAndPsAccelFanStatusTrap.setDescription("Generated when the accelerator fans' status changes.")
restart = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("restart-none", 0), ("restart-warm", 1), ("restart-cold", 2)))).setMaxAccess("writeonly")
if mibBuilder.loadTexts: restart.setStatus('mandatory')
if mibBuilder.loadTexts: restart.setDescription('A router/switch restart request. A management station can remotely instruct an ATI router/switch to action a warm or cold restart. Once all the appropriate internal checks have been made, the router/switch will acknowledge the request via normal SNMP channels. The restart instruction will be actioned after waiting for a period of 5 seconds, this is because the SNMP acknowledgement packet needs time to reach the management station. Once the request has been actioned, it can not be cancelled and communication with the router/switch will be lost during system initialisation.')
cpu = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3))
cpuUtilisationMax = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilisationMax.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUtilisationMax.setDescription('Maximum CPU utilisation since the router was last restarted. Expressed as a percentage.')
cpuUtilisationAvg = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilisationAvg.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUtilisationAvg.setDescription('Average CPU utilisation since the router was last restarted. Expressed as a percentage.')
cpuUtilisationAvgLastMinute = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilisationAvgLastMinute.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUtilisationAvgLastMinute.setDescription('Average CPU utilisation over the past minute. Expressed as a percentage.')
cpuUtilisationAvgLast10Seconds = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilisationAvgLast10Seconds.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUtilisationAvgLast10Seconds.setDescription('Average CPU utilisation over the past ten seconds. Expressed as a percentage.')
cpuUtilisationAvgLastSecond = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilisationAvgLastSecond.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUtilisationAvgLastSecond.setDescription('Average CPU utilisation over the past second. Expressed as a percentage.')
cpuUtilisationMaxLast5Minutes = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilisationMaxLast5Minutes.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUtilisationMaxLast5Minutes.setDescription('Maximum CPU utilisation over the last 5 minutes. Expressed as a percentage.')
cpuUtilisationAvgLast5Minutes = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 3, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cpuUtilisationAvgLast5Minutes.setStatus('mandatory')
if mibBuilder.loadTexts: cpuUtilisationAvgLast5Minutes.setDescription('Average CPU utilisation over the past 5 minutes. Expressed as a percentage.')
sysTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4))
generalTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 1))
generalTemperatureSupported = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("not-supported", 0), ("supported", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: generalTemperatureSupported.setStatus('mandatory')
if mibBuilder.loadTexts: generalTemperatureSupported.setDescription('The value supported indicates general temperature is displayed by the device. The value not-supported indicates the device displays specific temperature information or none at all.')
generalTemperatureActualTemp = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: generalTemperatureActualTemp.setStatus('mandatory')
if mibBuilder.loadTexts: generalTemperatureActualTemp.setDescription("The current temperature of product's base board, in degrees Celsius. A device which doesn't support this group will return the value 0 for this variable.")
generalTemperatureStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("not-ok", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: generalTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: generalTemperatureStatus.setDescription('The status of temperature in this device. ok indicates the temperature is below the threshold temperature or the device is not capable of monitoring temperature. not-ok indicates the temperature is being monitored and is currently above the threshold temperature (displayed in generalTemperatureThreshold).')
generalTemperatureThreshold = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: generalTemperatureThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: generalTemperatureThreshold.setDescription('The temperature threshold for the device. If the temperature of the device rises above this threshold generalTemeratureStatus will indicate a not-ok status.')
generalTemperatureStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 1) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "generalTemperatureStatus"), ("ALLIEDTELESYN-MIB", "generalTemperatureActualTemp"), ("ALLIEDTELESYN-MIB", "generalTemperatureThreshold"))
if mibBuilder.loadTexts: generalTemperatureStatusTrap.setDescription('Generated when the temperature status of the device changes.')
sbTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2))
sbTempTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 1), )
if mibBuilder.loadTexts: sbTempTable.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempTable.setDescription('The table of SwitchBlade sysTemperature. Each entry in the table represents temperature monitoring from one of the CPU cards which may be present in the SwitchBlade system.')
sbTempEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "sbTempIndex"))
if mibBuilder.loadTexts: sbTempEntry.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempEntry.setDescription('A single entry of SwitchBlade sysTemperature')
sbTempIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("master", 1), ("slave", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sbTempIndex.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempIndex.setDescription('The board for which this temperature entry holds. If the system consists only of a single CPU board, only one entry will appear in the table, whose index is master(1).')
sbTempActualTemperature = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sbTempActualTemperature.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempActualTemperature.setDescription('The actual SwitchBlade temperature. This temperature is measured within the SwitchBlade CPU, and is sampled at 1 second intervals.')
sbTempFixedThresholdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("normal", 1), ("crossover", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sbTempFixedThresholdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempFixedThresholdStatus.setDescription('The temperature status with regard to the fixed temperature threshold. The value of the fixed temperature threshold is set at 90 degrees C. This variable represents whether the actual temperature is above the threshold (value is crossover(2)) or below the threshold (value is normal(1)). If the temperature is exactly the same as the fixed temperature threshold, the value of this variable reads as normal(1).')
sbTempSettableThresholdStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("normal", 1), ("crossover", 2), ("undefined", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: sbTempSettableThresholdStatus.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempSettableThresholdStatus.setDescription('The temperature status with regard to the settable temperature threshold. The value of the settable temperature threshold is set by management intervention. This variable represents whether the actual temperature is above the threshold (value is crossover(2)) or below the threshold (value is normal(1)). When the value of this variable is undefined(3), no settable threshold has been specified and the value of sbTempSettableThreshold is not used.')
sbTempSettableThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(30, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: sbTempSettableThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempSettableThreshold.setDescription('The value of the settable temperature threshold. This can be set independently for each temperature entry. The value of this threshold is only valid when sbTempSettableThresholdStatus is not set to undefined(3).')
sbTempFixedThreshold = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: sbTempFixedThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: sbTempFixedThreshold.setDescription('The value of the fixed temperature threshold. This value is fixed for both CPU cards, and cannot be set.')
sbTempFixedThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "sbTempFixedThresholdStatus"), ("ALLIEDTELESYN-MIB", "sbTempActualTemperature"), ("ALLIEDTELESYN-MIB", "sbTempFixedThreshold"))
if mibBuilder.loadTexts: sbTempFixedThresholdTrap.setDescription('Trap occurs when fixed threshold status changes. The actual temperature and the fixed threshold are also given.')
sbTempSettableThresholdTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 2) + (0,2)).setObjects(("ALLIEDTELESYN-MIB", "sbTempSettableThresholdStatus"), ("ALLIEDTELESYN-MIB", "sbTempActualTemperature"), ("ALLIEDTELESYN-MIB", "sbTempSettableThreshold"))
if mibBuilder.loadTexts: sbTempSettableThresholdTrap.setDescription('Trap occurs when settable threshold status changes. The actual temperature and the settable threshold are also given.')
atContactDetails = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: atContactDetails.setStatus('mandatory')
if mibBuilder.loadTexts: atContactDetails.setDescription('The contact details for Allied Telesyn inc.')
acceleratorTemperature = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 3))
acceleratorTemperatureSupported = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 3, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("not-supported", 0), ("supported", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acceleratorTemperatureSupported.setStatus('mandatory')
if mibBuilder.loadTexts: acceleratorTemperatureSupported.setDescription('The value supported indicates whether accelerator card temperature is displayed by the device. The value not-supported indicates the device does not display specific accelerator card temperature information.')
acceleratorTemperatureActualTemp = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: acceleratorTemperatureActualTemp.setStatus('mandatory')
if mibBuilder.loadTexts: acceleratorTemperatureActualTemp.setDescription("The current temperature of product's base board, in degrees Celsius. A device which doesn't support this group will return the value 0 for this variable.")
acceleratorTemperatureStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("not-ok", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: acceleratorTemperatureStatus.setStatus('mandatory')
if mibBuilder.loadTexts: acceleratorTemperatureStatus.setDescription('The status of temperature in this device. ok indicates the temperature is below the threshold temperature or the device is not capable of monitoring temperature. not-ok indicates the temperature is being monitored and is currently above the threshold temperature (displayed in generalTemperatureThreshold).')
acceleratorTemperatureThreshold = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 3, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: acceleratorTemperatureThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: acceleratorTemperatureThreshold.setDescription('The temperature threshold for the device. If the temperature of the device rises above this threshold generalTemeratureStatus will indicate a not-ok status.')
acceleratorTemperatureStatusTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 4, 3) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "acceleratorTemperatureStatus"))
if mibBuilder.loadTexts: acceleratorTemperatureStatusTrap.setDescription('Generated when the temperature status of the device changes.')
bbrNvs = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 6))
bbrNvsReinitialiseTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 6) + (0,1))
if mibBuilder.loadTexts: bbrNvsReinitialiseTrap.setDescription("Generated at boot when the device detects that the BBR has been corrupted and reinitialised. This can happen if the device's BBR battery has run down, and the device has been powered off, then on.")
memory = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 7))
freeMemory = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 7, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: freeMemory.setStatus('mandatory')
if mibBuilder.loadTexts: freeMemory.setDescription('Percentage of free memory still available on device')
totalBuffers = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 7, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: totalBuffers.setStatus('mandatory')
if mibBuilder.loadTexts: totalBuffers.setDescription('Total number of buffers available on device')
realTimeClockStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("invalid", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: realTimeClockStatus.setStatus('mandatory')
if mibBuilder.loadTexts: realTimeClockStatus.setDescription('Shows the status of the real time clock')
hostId = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 3, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 32))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hostId.setStatus('mandatory')
if mibBuilder.loadTexts: hostId.setDescription('Host Identifier of this device')
arBoardMaxIndex = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardMaxIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardMaxIndex.setDescription('The maximum index of boards in the board table. Index 1 is reserved for the main system board of the router.')
arBoardTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2), )
if mibBuilder.loadTexts: arBoardTable.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardTable.setDescription('The table of boards in the AR router.')
arBoardEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "arBoardIndex"))
if mibBuilder.loadTexts: arBoardEntry.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardEntry.setDescription('A single entry in the board table. Each entry consists of information about one board in the router.')
arBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardIndex.setDescription('The index of the board in the board table. Index 1 is reserved for the main system board of the router. Other boards will take index numbers as they are initialised at router startup, or for routers with hot-swap capability, as boards are added to and removed from the router.')
arBoardId = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1, 2), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardId.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardId.setDescription('The type of board in this board entry. The values of this object are taken from the pprXxx object IDs under the boards sub-tree.')
arBoardName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardName.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardName.setDescription('The name of the board in this board entry. This is a readable string which identifies the board to the manager.')
arBoardRevision = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardRevision.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardRevision.setDescription('The manufacturing revision of the board in this board entry. This string has the format Xm-n, where X is P for prototype, or M for manufacturing, m is the major revision number for this board, and n is the field upgrade revision number for this board.')
arBoardSerialNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardSerialNumber.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardSerialNumber.setDescription("The serial number of the board in this board entry. Serial numbers are strings of decimal numbers up to 10 digits in length. Each and every serial number is globally unique. It is possible for the serial number of a board to be invalid. In this case the value returned for this object will be '*** Invalid ***'")
arBoardTotalSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardTotalSlots.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardTotalSlots.setDescription("The number of slots on this board. Each slot from 1 to the value of this object may be empty or occupied by another board. By searching the arSlotTable with this board's board index and all values of slot index from 1 to the value of this object, a tree of the boards in this router can be built. The value 0 for this object means that it has no slots.")
arBoardTotalPositions = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arBoardTotalPositions.setStatus('mandatory')
if mibBuilder.loadTexts: arBoardTotalPositions.setDescription('The number of positions on this board. Each position from 1 to the value of this object contains a single router interface. Note that positions are different from slots. An position contains an actual interface while a slot contains a different board which itself may contain interfaces in its positions.')
arSlotTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 3), )
if mibBuilder.loadTexts: arSlotTable.setStatus('mandatory')
if mibBuilder.loadTexts: arSlotTable.setDescription('The table of slots in the router, indexed by board index and slot index.')
arSlotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 3, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "arSlotBoardIndex"), (0, "ALLIEDTELESYN-MIB", "arSlotSlotIndex"))
if mibBuilder.loadTexts: arSlotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: arSlotEntry.setDescription('A single entry in the board slot table.')
arSlotBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arSlotBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arSlotBoardIndex.setDescription('The index of the board for this slot entry. Index 1 is reserved for the main system board of the router.')
arSlotSlotIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arSlotSlotIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arSlotSlotIndex.setDescription('The index of the slot for this slot entry. Indices start from 1 and are specific to each different board type. There are no gaps in the sequence of slot indices. The maximum value for slot index is given by the value of arBoardTotalSlots for this board.')
arSlotHeldBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 3, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arSlotHeldBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arSlotHeldBoardIndex.setDescription('The index of the board held in the slot for this slot entry. This is an index into the arBoardTable. A value of 0 for this object means that the slot is not populated.')
arSlotDescription = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arSlotDescription.setStatus('mandatory')
if mibBuilder.loadTexts: arSlotDescription.setDescription("A description for this slot entry. This is a textual description which gives the manager a clue as to what the slot for this entry is. For example, the slots on an AR 720 have descriptions 'Bay0', 'Bay1' and 'MAC'.")
arInterfaceTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 4), )
if mibBuilder.loadTexts: arInterfaceTable.setStatus('mandatory')
if mibBuilder.loadTexts: arInterfaceTable.setDescription('The table of physical interfaces in the AR router.')
arInterfaceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 4, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "arInterfaceBoardIndex"), (0, "ALLIEDTELESYN-MIB", "arInterfacePosition"))
if mibBuilder.loadTexts: arInterfaceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: arInterfaceEntry.setDescription('A single entry in the interface table. Each entry consists of information about one interface in the router, and is indexed by the board index and the position of the interface on the board.')
arInterfaceBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arInterfaceBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arInterfaceBoardIndex.setDescription('The index of the board in the board table which contains this interface. Index 1 is reserved for the main system board of the router.')
arInterfacePosition = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 4, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arInterfacePosition.setStatus('mandatory')
if mibBuilder.loadTexts: arInterfacePosition.setDescription('The position of the interface on the board. Each board type will have well-known positions which are the interfaces provided by the board. The number of positions on a given board is given by the object arBoardTotalPositions for this board.')
arInterfaceIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 4, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arInterfaceIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arInterfaceIfIndex.setDescription("The ifIndex for the interface represented by this entry of the interfaces table. This is the ifIndex of the ifEntry used to represent the physical interface. The value 0 is used for interfaces which don't have an ifIndex.")
arInterfaceName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arInterfaceName.setStatus('mandatory')
if mibBuilder.loadTexts: arInterfaceName.setDescription('The name of this interface. This is the name that the manager can use to refer to this interface in entering router commands.')
arInterfaceFullName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: arInterfaceFullName.setStatus('mandatory')
if mibBuilder.loadTexts: arInterfaceFullName.setDescription("The fully qualified name for this interface. This identifies the path that must be followed to reach the interface. This name can be used in router commands. In routers don't support fully qualified names, this is the same as arInterfaceName.")
arIfXTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 5), )
if mibBuilder.loadTexts: arIfXTable.setStatus('mandatory')
if mibBuilder.loadTexts: arIfXTable.setDescription('The table of interface statistics for the AR router. This table extends the ifTable.')
arIfXEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 5, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "arIfXIndex"))
if mibBuilder.loadTexts: arIfXEntry.setStatus('mandatory')
if mibBuilder.loadTexts: arIfXEntry.setDescription('A single entry in the interface extension table. Each entry consists of extra interface information not covered in standard MIBs. The index for this table is ifIndex, the same as for ifTable.')
arIfXIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arIfXIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arIfXIndex.setDescription('The index of the ifTable.')
arIfXAverageInputBitsSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arIfXAverageInputBitsSecond.setStatus('mandatory')
if mibBuilder.loadTexts: arIfXAverageInputBitsSecond.setDescription("The average number of bits received per second on all interfaces over the past 8.5 minutes. The average is calculated by an 8.5 minute (512s) decaying average, which is updated every 4 seconds using the following formula: X' = 127/128X + 1/128i where X' is the new average X is the old average i is the most recent poll result The times and multiplier factors have been chosen to give the simplest possible calculation using bit shifting operations.")
arIfXAverageInputPacketsSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 5, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arIfXAverageInputPacketsSecond.setStatus('mandatory')
if mibBuilder.loadTexts: arIfXAverageInputPacketsSecond.setDescription('The average number of packets received per second on all interfaces over the past 8.5 minutes. See the description for arIfXAverageInputBitsSecond for details of the way in which the average is calculated.')
arIfXAverageOutputBitsSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arIfXAverageOutputBitsSecond.setStatus('mandatory')
if mibBuilder.loadTexts: arIfXAverageOutputBitsSecond.setDescription('The average number of bits sent per second on all interfaces over the past 8.5 minutes. See the description for arIfXAverageInputBitsSecond for details of the way in which the average is calculated.')
arIfXAverageOutputPacketsSecond = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 5, 5, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arIfXAverageOutputPacketsSecond.setStatus('mandatory')
if mibBuilder.loadTexts: arIfXAverageOutputPacketsSecond.setDescription('The average number of bits sent per second on all interfaces over the past 8.5 minutes. See the description for arIfXAverageInputBitsSecond for details of the way in which the average is calculated.')
ethernet = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 23))
ethIntTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 23, 1), )
if mibBuilder.loadTexts: ethIntTable.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntTable.setDescription('The table of Ethernet interfaces.')
ethIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 23, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "ethIntIndex"))
if mibBuilder.loadTexts: ethIntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntEntry.setDescription('A single entry in the Ethernet interfaces table.')
ethIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 23, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntIndex.setDescription('The ifIndex of the Ethernet interface.')
ethIntBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 23, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntBoardIndex.setDescription('The index in the arBoardTable of the board on which this Ethernet interface resides. If this Ethernet interface is not found, the value of this object is 0.')
ethIntBoardPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 23, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntBoardPosition.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntBoardPosition.setDescription("The position on this Ethernet interface's board of this Ethernet interface. If this Ethernet interface is not found, the value of this object is 0.")
ethIntDuplexMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 23, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("full-duplex", 1), ("half-duplex", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ethIntDuplexMode.setStatus('mandatory')
if mibBuilder.loadTexts: ethIntDuplexMode.setDescription('The duplex mode of this Ethernet interface. The value unknown is returned when the interface cannot or has not yet made a determination of its duplex mode, or when the interface cannot be found.')
flash = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31))
flashGetFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashGetFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashGetFailure.setDescription('The number of flash get operations that have failed.')
flashOpenFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashOpenFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashOpenFailure.setDescription('The number of flash open operations that have failed.')
flashReadFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashReadFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashReadFailure.setDescription('The number of flash read operations that have failed.')
flashCloseFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashCloseFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashCloseFailure.setDescription('The number of flash close operations that have failed.')
flashCompleteFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashCompleteFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashCompleteFailure.setDescription('The number of flash complete operations that have failed.')
flashWriteFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashWriteFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashWriteFailure.setDescription('The number of flash write operations that have failed.')
flashCreateFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashCreateFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashCreateFailure.setDescription('The number of flash create operations that have failed.')
flashPutFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashPutFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashPutFailure.setDescription('The number of flash put operations that have failed.')
flashDeleteFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashDeleteFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashDeleteFailure.setDescription('The number of flash delete operations that have failed.')
flashCheckFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashCheckFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashCheckFailure.setDescription('The number of flash check operations that have failed.')
flashEraseFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashEraseFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashEraseFailure.setDescription('The number of flash erase operations that have failed.')
flashCompactFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashCompactFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashCompactFailure.setDescription('The number of flash compaction operations that have failed.')
flashVerifyFailure = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: flashVerifyFailure.setStatus('mandatory')
if mibBuilder.loadTexts: flashVerifyFailure.setDescription('The number of flash verify operations that have failed.')
flashFailureTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 31) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "flashGetFailure"), ("ALLIEDTELESYN-MIB", "flashOpenFailure"), ("ALLIEDTELESYN-MIB", "flashReadFailure"), ("ALLIEDTELESYN-MIB", "flashCloseFailure"), ("ALLIEDTELESYN-MIB", "flashCompleteFailure"), ("ALLIEDTELESYN-MIB", "flashWriteFailure"), ("ALLIEDTELESYN-MIB", "flashCreateFailure"), ("ALLIEDTELESYN-MIB", "flashPutFailure"), ("ALLIEDTELESYN-MIB", "flashDeleteFailure"), ("ALLIEDTELESYN-MIB", "flashCheckFailure"), ("ALLIEDTELESYN-MIB", "flashEraseFailure"), ("ALLIEDTELESYN-MIB", "flashCompactFailure"), ("ALLIEDTELESYN-MIB", "flashVerifyFailure"))
if mibBuilder.loadTexts: flashFailureTrap.setDescription('A flash failure trap is generated when any of the above flash counter is incremented and the failure type is sent in the trap.')
cc = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37))
ccDetailsTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1), )
if mibBuilder.loadTexts: ccDetailsTable.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsTable.setDescription('The table of call details parameters.')
ccDetailsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "ccDetailsIndex"))
if mibBuilder.loadTexts: ccDetailsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsEntry.setDescription('A single entry of ISDN call details. This contains the parameters of a single ISDN call details.')
ccDetailsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDetailsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsIndex.setDescription('The index of the call details entry in the call details table. When an entry is created in this table, the index does not have to be written. However, to reference the values that are written, an unused index must be found by reading the index values of the table until a no such object error is returned. Attempting to create a row by using an already used index will result in simply changing the parameters of an existing call details entry.')
ccDetailsName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsName.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsName.setDescription("The name of the ISDN call details. This must be unique for all ISDN call details, when comparisons are done ignoring the case of letters. Valid characters in the ISDN call name include 0-9, a-z, A-Z and '_'. A name consisting of all digits is not valid. Setting this object is mandatory on row creation. However, this object cannot be set for an existing call. This is because for the command line interface calls are identified by name. There is one exception. Setting ccDetailsName to an empty string will cause the call details to be deleted.")
ccDetailsRemoteName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRemoteName.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsRemoteName.setDescription("The remote ISDN call name. This name can be referenced by certain other call details parameters related with setting up the Q.931 SETUP message for outgoing calls, or searching for calls for incoming calls. Valid characters in the ISDN remote call name include 0-9, a-z, A-Z and '_'. A remote name consisting of all digits is valid.")
ccDetailsCalledNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCalledNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsCalledNumber.setDescription('The number called when this call details is activated. The number should include all telephone network access codes, country codes and area codes required to make a call from the particular ISDN interface. Setting this object is mandatory on row creation.')
ccDetailsCallingNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCallingNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsCallingNumber.setDescription('The number used as the calling number when this call is activated. The calling number can optionally be placed in the outgoing SETUP message.')
ccDetailsAlternateNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsAlternateNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsAlternateNumber.setDescription('The number called when all retries with the main called number have failed. In this event, the router tries once with the alternate number, then checks the ccDetailsKeepup object to determine whether to try again with the main number.')
ccDetailsEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2))).clone('enabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsEnabled.setDescription('Whether this ISDN call is enabled or disabled for incoming and outgoing calls. If the call details entry is disabled, all existing active calls based on this call details entry are left active.')
ccDetailsDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in-only", 1), ("out-only", 2), ("both", 3))).clone('both')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsDirection.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsDirection.setDescription('The direction for which calls may be made or received using this call details entry.')
ccDetailsPrecedence = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in", 1), ("out", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPrecedence.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsPrecedence.setDescription('The precedence of this call details entry in the event of call collision. Call collision occurs when an incoming call for a given details entry is detected while an outgoing call is waiting to complete. This object configures whether the router treats the incoming or outgoing call as having precedence. Since the device at the other end will also probably be experiencing a call collision, the precedence should be configured to the opposite value at the other end. Setting this object is mandatory on row creation.')
ccDetailsHoldupTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 7200))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsHoldupTime.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsHoldupTime.setDescription('The time, in seconds, that active calls created from this call details should be held up after initial activation. The call will be held up for at least this time, unless cleared from the network. Thus, for example, PPP idle timeouts will not bring the call down.')
ccDetailsPreferredIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 11), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPreferredIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsPreferredIfIndex.setDescription('The ifIndex of an ISDN interface on this router which is the preferred ISDN interface on which to make an outgoing call using this call details entry. The ifIndex, if not 0, should reference the ifEntry which contains information about the entire ISDN interface, at the lowest layer. If a channel is not available on this interface, the call can try other interfaces in order to make the call. This object is not used on incoming calls. If the value of this object is set to 0, no interface will be preferred over any other. If the value of this object does not reference the ifEntry for the entire ISDN interface, no interface will be preferred.')
ccDetailsRequiredIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 12), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRequiredIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsRequiredIfIndex.setDescription('The ifIndex of an ISDN interface on this router which is the required ISDN interface on which to make an outgoing call using this call details entry. The ifIndex, if not 0, must reference the ifEntry which contains information about the entire ISDN interface, at the lowest layer. If a channel is not available on this interface, the call fails. This object is not used on incoming calls. If the value of this object is set to 0, no interface will be required. If the value of this object does not reference the ifEntry for the entire ISDN interface, no interface will be required.')
ccDetailsPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsPriority.setDescription('The priority of calls generated from this call details entry. The priority determines whether calls can be bumped for higher priority calls. The value of priority falls into ranges: 0-19 - call bumped by incoming or outgoing, voice or data calls 20-39 - call bumped by outgoing voice and incoming or outgoing data calls 40-59 - call bumped by emergency voice calls or incoming or outgoing data calls 60-99 - call bumped by emergency voice calls or outgoing data calls. Note that when the call is bumped by a data call, the data call must have higher priority than the call being bumped.')
ccDetailsRetryT1 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(5, 120)).clone(30)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryT1.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsRetryT1.setDescription('The time in seconds between retries of calls generated from this call details entry.')
ccDetailsRetryN1 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 15), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 10))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryN1.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsRetryN1.setDescription('The number of retries in a retry group for calls generated from this call details entry. Note that the default value means that by default the call will not be retried.')
ccDetailsRetryT2 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 16), Integer32().subtype(subtypeSpec=ValueRangeConstraint(300, 1200)).clone(600)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryT2.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsRetryT2.setDescription('The time in seconds between retry groups for retries of calls generated from this call details entry.')
ccDetailsRetryN2 = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 17), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 5))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsRetryN2.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsRetryN2.setDescription('The number of retry groups for calls generated from this call details entry. Note that the default value means that by default no retry groups will be attempted.')
ccDetailsKeepup = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsKeepup.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsKeepup.setDescription("A flag indicating whether calls generated from this call details entry should be kept up always. Inspection of this flag takes place when a call is cleared from an external source. If set to 'yes', the call will be retried.")
ccDetailsOutSetupCli = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("off", 1), ("calling", 2), ("interface", 3), ("nonumber", 4))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSetupCli.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsOutSetupCli.setDescription("The CLI information placed into outgoing SETUP messages when this call details is used to generate an outgoing call. The value 'off' means that no CLI information in placed in the SETUP message. The value 'calling' means that the calling number from the call details entry is placed in the SETUP message. The value 'interface' means that the Q.931 interface number for the interface and DLC on which the call is made is placed in the SETUP message. The value 'nonumber' means that the CLI information element is placed in the SETUP message with no number information. The network will fill the number in.")
ccDetailsOutSetupUser = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSetupUser.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsOutSetupUser.setDescription("The user-user information placed into outgoing SETUP messages when this call details is used to generate an outgoing call. The value 'off' means that no user-user information in placed in the SETUP message. The value 'local' means that the call name from the call details entry is placed in the SETUP message. The value 'remote' means that the remote call name from the call details entry is placed in the SETUP message.")
ccDetailsOutSetupCalledSub = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSetupCalledSub.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsOutSetupCalledSub.setDescription("The called subaddress information placed into outgoing SETUP messages when this call details is used to generate an outgoing call. The value 'off' means that no called subaddress information in placed in the SETUP message. The value 'local' means that the call name from the call details entry is placed in the SETUP message. The value 'remote' means that the remote call name from the call details entry is placed in the SETUP message. Note that the action of this object is overridden by the value of the object ccDetailsOutSubaddress.")
ccDetailsOutSubaddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 22), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsOutSubaddress.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsOutSubaddress.setDescription('This object gives a way to override the called subaddress information placed into outgoing SETUP messages when this call details is used to generate an outgoing call, as given by the ccDetailsOutSetupCalledSub object. The object is an arbitrary string of ASCII characters, from 0 to 31 characters long.')
ccDetailsCallback = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCallback.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsCallback.setDescription("A flag indicating whether or not to call back the caller when an incoming call is generated from this call details entry. If set to 'yes', the incoming call will be cleared, and after a short delay, an outgoing call will be activated for this call details entry.")
ccDetailsCallbackDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 24), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(41)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsCallbackDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsCallbackDelay.setDescription('The time, in tenths of a second, which the router will wait after clearing an incoming call whose call details entry specified that the caller should be called back before making the return call. The purpose of this object is to allow the user to specify a delay in callback which will allow the network to properly clear the call at both this end and the remote end.')
ccDetailsInSetupCalledSubSearch = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubSearch.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubSearch.setDescription("Determines whether this call details entry is used in a search of call details for an incoming call based on the contents of the called subaddress information in the incoming SETUP message. The value 'off' means that this call details entry is not used in the search. The value 'local' means that the call details entry is used in the search and the called subaddress information is compared with the call details entry name. The value 'remote' means that the call details entry is used in the search and the called subaddress information is compared with the call details entry remote name. A number of searches are carried out until a matching call is found. First a search against the called subaddress in the SETUP message, then a search against the user-user information in the SETUP message, then a search against the calling number information in the SETUP message, then a search for any call that is configured to respond to any incoming call.")
ccDetailsInSetupUserSearch = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupUserSearch.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupUserSearch.setDescription("Determines whether this call details entry is used in a search of call details for an incoming call based on the contents of the user-user information in the incoming SETUP message. The value 'off' means that this call details entry is not used in the search. The value 'local' means that the call details entry is used in the search and the user-user information is compared with the call details entry name. The value 'remote' means that the call details entry is used in the search and the user-user information is compared with the call details entry remote name. A number of searches are carried out until a matching call is found. First a search against the called subaddress in the SETUP message, then a search against the user-user information in the SETUP message, then a search against the calling number information in the SETUP message, then a search for any call that is configured to respond to any incoming call.")
ccDetailsInSetupCliSearch = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("on", 2), ("list", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliSearch.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupCliSearch.setDescription("Determines whether this call details entry is used in a search of call details for an incoming call based on the contents of the calling number information in the incoming SETUP message. The value 'off' means that this call details entry is not used in the search. The value 'on' means that the call details entry is used in the search and the calling number information is compared with the call details entry called number. The value 'list' means that the call details entry is used in the search and the calling number information is compared with the numbers on the CLI list reference by the object ccDetailsInSetupCliSearchList. The value 'list' cannot be set by an SNMP management entity. Rather the ccDetailsInSetupCliSearchList object should be set to a non-zero value, which will automatically set this object to 'list'. A number of searches are carried out until a matching call is found. First a search against the called subaddress in the SETUP message, then a search against the user-user information in the SETUP message, then a search against the calling number information in the SETUP message, then a search for any call that is configured to respond to any incoming call.")
ccDetailsInSetupCliSearchList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 28), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliSearchList.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupCliSearchList.setDescription("If the ccDetailsInSetupCliSearch object is set to 'list', this object gives the index of the CLI list to search. The value of CLI list indices is 1..100. The value 0 is returned when the ccDetailsInSetupCliSearch object is not set to 'list'. If the value of this object is set to 0 via SNMP, then the ccDetailsInSetupCliSearch object will be internally set to 'off'. Subsequently setting the value of this object to a non-zero value will set the ccDetailsInSetupCliSearch object to 'list'. Note that when using the command line interface, CLI list indices range from 0 to 99, but when using SNMP they range from 1 to 100. This is because SNMP will not allow a table index to have the value 0, and the command line usage of indices from 0 to 99 is too well established to change.")
ccDetailsInAnyFlag = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2))).clone('no')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInAnyFlag.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInAnyFlag.setDescription("Determines whether this call details entry will match any incoming call. After all searched for incoming calls have been carried out based on called subaddress, user-user information and calling number, a search is carried out for the first call found with this flag set to 'yes'.")
ccDetailsInSetupCalledSubCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubCheck.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupCalledSubCheck.setDescription("Determines whether to perform a check when an incoming call matches this call details entry based on the contents of the called subaddress information in the incoming SETUP message. The value 'off' means that the check is not carried out. The value 'local' means that the check is carried out and the called subaddress information is compared with the call details entry name. The value 'remote' means that the check is carried out and the called subaddress information is compared with the call details entry remote name. A number of checks are optionally carried out once a matching call is found. The first check is against the called subaddress in the SETUP message, then against the user-user information in the SETUP message, then against the calling number information in the SETUP message.")
ccDetailsInSetupUserCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("local", 2), ("remote", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupUserCheck.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupUserCheck.setDescription("Determines whether to perform a check when an incoming call matches this call details entry based on the contents of the user-user information in the incoming SETUP message. The value 'off' means that the check is not carried out. The value 'local' means that the check is carried out and the user-user information is compared with the call details entry name. The value 'remote' means that the check is carried out and the user-user information is compared with the call details entry remote name. A number of checks are optionally carried out once a matching call is found. The first check is against the called subaddress in the SETUP message, then against the user-user information in the SETUP message, then against the calling number information in the SETUP message.")
ccDetailsInSetupCliCheck = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 32), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("off", 1), ("present", 2), ("required", 3))).clone('off')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliCheck.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupCliCheck.setDescription("Determines whether to perform a check and which check to perform when an incoming call matches this call details entry based on the contents of the calling number information in the incoming SETUP message. The value 'off' means that the check is not carried out. The value 'present' means that the check is carried out only if calling number information is present. The value 'required' means that the calling number must be present for the check to pass. When the check is carried out, the calling number information is compared with the numbers in the CLI list referenced by the object ccDetailsInSetupCliCheckList. A number of checks are optionally carried out once a matching call is found. The first check is against the called subaddress in the SETUP message, then against the user-user information in the SETUP message, then against the calling number information in the SETUP message.")
ccDetailsInSetupCliCheckList = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 33), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsInSetupCliCheckList.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsInSetupCliCheckList.setDescription("If the ccDetailsInSetupCliCheck object is set to 'present' or 'required', this object gives the index of the CLI list to check against. The value of CLI list indices is 1..100. The value 0 means that no list to check against is defined and the check immediately fails. Note that when using the command line interface, CLI list indices range from 0 to 99, but when using SNMP they range from 1 to 100. This is because SNMP will not allow a table index to have the value 0, and the command line usage of indices from 0 to 99 is too well established to change.")
ccDetailsUserType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 34), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("attach", 1), ("ppp", 2))).clone('attach')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsUserType.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsUserType.setDescription("The type of user of this call. The value 'attach' means that users have to attach to this call before the call can be used for outgoing or incoming calls. The value 'ppp' means that for incoming calls only dynamic PPP interfaces will be created whenever this call details entry is matched.")
ccDetailsLoginType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 35), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("none", 1), ("userdb", 2), ("radius", 3), ("pap-tacacs", 4), ("chap", 5), ("pap-radius", 6), ("tacacs", 7), ("all", 8))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsLoginType.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsLoginType.setDescription("The type of login for calls generated using this call details entry, for incoming calls only. Incoming calls can be configured to go through a logging in phase before the call is brought up. This object defines which login types are used. The value 'none' means don't do a login phase. The value 'userdb' means use the user database on the router to check login parameters. The value 'radius' means use the router's configured RADIUS servers to check the login parameters. The values 'pap-tacacs', 'chap' and 'pap-radius' apply only when the user is 'ppp' and determine how the dynamic PPP interface are configured for authentication. The value 'pap-tacacs' means use PAP to authenticate and use the TACACS server to check the login parameters. The value 'pap-radius' means use PAP to authenticate and use the RADIUS server to check the login parameters. The value 'chap' means use CHAP to authenticate. The value 'tacacs' means use the TACACS server to check login parameters. The value 'all' means use the user database, TACACS and RADIUS to check the login parameters. The login parameters for values 'userdb', 'radius', 'tacacs' and 'all' are determined by the ccDetailsUsername and ccDetailsPassword objects.")
ccDetailsUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 36), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("cli", 2), ("calledsub", 3), ("useruser", 4), ("callname", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsUsername.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsUsername.setDescription("The source of the username when the ccDetailsLoginType object has a value of 'userdb', 'radius', 'tacacs' or 'all'. The value 'none' means no username is defined. The value 'cli' means take the username from the calling number information in the SETUP message. The value 'calledsub' means take the username from the called subaddress information in the SETUP message. The value 'useruser' means take the username from the user-user information in the SETUP message. The value 'callname' means take the username from the call details entry name.")
ccDetailsPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 37), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("none", 1), ("cli", 2), ("calledsub", 3), ("useruser", 4), ("callname", 5))).clone('none')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPassword.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsPassword.setDescription("The source of the password when the ccDetailsLoginType object has a value of 'userdb', 'radius', 'tacacs' or 'all'. The value 'none' means no password is defined. The value 'cli' means take the password from the calling number information in the SETUP message. The value 'calledsub' means take the password from the called subaddress information in the SETUP message. The value 'useruser' means take the password from the user-user information in the SETUP message. The value 'callname' means take the password from the call details entry name.")
ccDetailsBumpDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 38), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(5)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsBumpDelay.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsBumpDelay.setDescription('The time, in tenths of a second, which the router will wait after clearing an existing call which has been bumped to make way for a call based on this call details entry.')
ccDetailsDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 39), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rate-64k", 1), ("rate-56k", 2))).clone('rate-64k')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsDataRate.setDescription('The data rate to use for active calls based on this call details entry. The actual data rate for outgoing calls is determined by both this object and the data rate parameter for the Q.931 interface chosen for the call. If either this object or the interface object specify a rate of 56k, then 56k will be the rate for the call. Otherwise, the default rate of 64k will be used. This allows interoperability between ISDNs which only allow 56k of data on a B channel.')
ccDetailsPppTemplate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 40), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 33)).clone(33)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccDetailsPppTemplate.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsPppTemplate.setDescription('The PPP template to use when creating dynamic PPP interfaces for calls generated from this call details entry. The value 33 represents a default PPP template, the values 1 to 32 represent PPP templates that are currently defined in the router. Note that when using the command line interface, PPP template indices range from 0 to 31, but when using SNMP they range from 1 to 32. This is because SNMP will not allow a table index to have the value 0. While there is no PPP template table accessible via SNMP, if there was, the indices of the table would have to range from 1 to 32.')
ccDetailsUserModule = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 41), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDetailsUserModule.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsUserModule.setDescription('The module ID of the user module currently attached to this ISDN call details entry.')
ccDetailsNumberAttachments = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 1, 1, 42), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccDetailsNumberAttachments.setStatus('mandatory')
if mibBuilder.loadTexts: ccDetailsNumberAttachments.setDescription('The number of attachments from the user module currently attached to this call details entry. The ccAttachmentsTable gives the actual attachments for each call details entry.')
ccCliListTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2), )
if mibBuilder.loadTexts: ccCliListTable.setStatus('mandatory')
if mibBuilder.loadTexts: ccCliListTable.setDescription('The table of CLI list entries.')
ccCliListEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "ccCliListListIndex"), (0, "ALLIEDTELESYN-MIB", "ccCliListEntryIndex"))
if mibBuilder.loadTexts: ccCliListEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ccCliListEntry.setDescription('A single entry in the CLI list table. This contains a single number, as well as index information.')
ccCliListListIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 100))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCliListListIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccCliListListIndex.setDescription('The index of the CLI list. CLI lists from 1 to 100 are defined in the router.')
ccCliListEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCliListEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccCliListEntryIndex.setDescription('The index of the CLI list entry within the CLI list. The minimum CLI list entry is 1. CLI lists are unlimited in length, although internal memory requirements could result in failure to create a given entry. When creating a row in this table, the entry index should be set to index the first empty row. Only one CLI list row in a given list should be created in any one SNMP message. Attempting to create more than one row will result in failure.')
ccCliListNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 2, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ccCliListNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ccCliListNumber.setDescription('The number for this CLI list entry. Setting the number to a zero length string removes the entry from the CLI list, with consequent reshuffling of CLI entry indices. Thus the easiest way to delete an entire CLI list is to repeatedly set the first element in the list to a zero length string. A failure to SET will occur when this is attempted on an empty list.')
ccActiveCallTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3), )
if mibBuilder.loadTexts: ccActiveCallTable.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallTable.setDescription('The table of ISDN active calls.')
ccActiveCallEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "ccActiveCallIndex"))
if mibBuilder.loadTexts: ccActiveCallEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallEntry.setDescription('A single entry in the active call table.')
ccActiveCallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallIndex.setDescription('The index of the active call. There are 128 possible active calls in the router simultaneously.')
ccActiveCallDetailsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallDetailsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallDetailsIndex.setDescription('The index of the call details entry which generated this active call. Thus the index into the ccDetailsTable for this call.')
ccActiveCallIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallIfIndex.setDescription("The interface index of the interface on which this active call is being made or received. A value of zero indicates that the active has not yet had an interface assigned to it. The ifEntry indexed by this object is the ifEntry for the entire ISDN interface, not the ifEntry for the active call's B channel.")
ccActiveCallDataRate = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rate-64k", 1), ("rate-56k", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallDataRate.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallDataRate.setDescription('The data rate in use for this active call. This is determined by the call details setting of data rate, the ISDN interface setting for data rate, and the contents of the bearer capability information in the incoming SETUP message.')
ccActiveCallState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("null", 1), ("off", 2), ("try", 3), ("on", 4), ("wait", 5), ("await1", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallState.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallState.setDescription("The state of this active call. The value 'null' indicates that this active call does not actually exist, in other words it is in the process of being created or destroyed. The value 'off' means that the active call is just being activated. The value 'try' means that the active call is attempting to establish. The value 'on' means that the active call is established. The value 'wait' means that the active call is waiting to retry. The value 'await1' means that the active call is waiting for authentication to succeed before becoming established.")
ccActiveCallDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("undefined", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallDirection.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallDirection.setDescription("The direction of this active call. The value 'in' indicates that this active call is an incoming call, the value 'out' indicates that the active call is an outgoing call. The value 'undefined' indicates that the active call has just been created and a direction has not been assigned to it yet.")
ccActiveCallUserModule = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallUserModule.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallUserModule.setDescription('The module ID of the user module attached to this ISDN active call.')
ccActiveCallUserInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallUserInstance.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallUserInstance.setDescription('The instance of the user module attached to this ISDN active call.')
ccActiveCallBchannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 3, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccActiveCallBchannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccActiveCallBchannelIndex.setDescription("The B channel number for this active entry. BRI interfaces have B channels in the range 1..2, PRI interfaces have B channels in the range 1..31, excluding a channel which is the D channel. A value of 0 for this entry means that either a B channel is not currently allocated for this call, or that more than one B channel is allocated. In the second case, the management client will have to walk the B channel allocation table looking for channels with the same active call index as this call's.")
ccCallLogTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4), )
if mibBuilder.loadTexts: ccCallLogTable.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogTable.setDescription('The table of ISDN call log entries.')
ccCallLogEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "ccCallLogIndex"))
if mibBuilder.loadTexts: ccCallLogEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogEntry.setDescription('A single entry in the ISDN call log table.')
ccCallLogIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogIndex.setDescription('The index of the call log entry. Since the call log table is dynamic, there is no guarantee that this index will continue to refer to the same log entry over time.')
ccCallLogName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogName.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogName.setDescription('The name of the call details entry which generated the active call for which this is the log entry.')
ccCallLogState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("initial", 1), ("active", 2), ("disconnected", 3), ("cleared", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogState.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogState.setDescription("The state of the log entry. The value 'initial' means that the call is being established. The value 'active' means that the call is currently established. The value 'disconnected' means that the call was disconnected after being established for some time. The value 'cleared' means that the call was cleared abormally while in the establishment phase.")
ccCallLogTimeStarted = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogTimeStarted.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogTimeStarted.setDescription("A string in the format 'dd-mmm-yyyy hh:mm:ss' which gives the start time of the call for which this is the log entry. If the call never reached or has not yet reached the active state, this object will be a zero-length string.")
ccCallLogDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("in", 1), ("out", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogDirection.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogDirection.setDescription('The direction of the call for which this is the log entry.')
ccCallLogDuration = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogDuration.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogDuration.setDescription('The duration in seconds, of the call for which this is the log entry. A value of 0 in this field means either that the call has just started, that the call was cleared before becoming established, or that the call is still active. In other words, a non-zero value is present in this object only for calls which reach establishment and have since been cleared.')
ccCallLogRemoteNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccCallLogRemoteNumber.setStatus('mandatory')
if mibBuilder.loadTexts: ccCallLogRemoteNumber.setDescription('For incoming calls, the calling number, if this was made available in the SETUP message. For outgoing calls, the number dialed. If the number was not available, this object is a zero length string.')
ccAttachmentTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5), )
if mibBuilder.loadTexts: ccAttachmentTable.setStatus('mandatory')
if mibBuilder.loadTexts: ccAttachmentTable.setDescription('The table of call detail attachment entries.')
ccAttachmentEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "ccAttachmentDetailsIndex"), (0, "ALLIEDTELESYN-MIB", "ccAttachmentEntryIndex"))
if mibBuilder.loadTexts: ccAttachmentEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ccAttachmentEntry.setDescription('A single entry in the attachment table.')
ccAttachmentDetailsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentDetailsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccAttachmentDetailsIndex.setDescription('The index of the call details entry to which this attachment entry belongs.')
ccAttachmentEntryIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentEntryIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccAttachmentEntryIndex.setDescription('The index of the attachment entry within the attachment list.')
ccAttachmentActiveCallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentActiveCallIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccAttachmentActiveCallIndex.setDescription('The index of the active call for this attachment. A value of 0 indicates that there is currently no active call for this attachment. A value of 1 to 128 references the active call currently in place for this attachment.')
ccAttachmentUserInstance = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 5, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccAttachmentUserInstance.setStatus('mandatory')
if mibBuilder.loadTexts: ccAttachmentUserInstance.setDescription('The instance of the user module attached to the ISDN active call for this attachment. This object should return the same value as the object ccActiveCallUserInstance for the active call indexed by ccAttachmentActiveCallIndex, if this is not 0.')
ccBchannelTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6), )
if mibBuilder.loadTexts: ccBchannelTable.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelTable.setDescription('The table of B channel attachment entries.')
ccBchannelEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "ccBchannelIfIndex"), (0, "ALLIEDTELESYN-MIB", "ccBchannelChannelIndex"))
if mibBuilder.loadTexts: ccBchannelEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelEntry.setDescription('A single entry in the B channel attachment table.')
ccBchannelIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelIfIndex.setDescription("The interface index of the interface which this B channel entry is on. The ifEntry indexed by this object is the ifEntry for the entire ISDN interface, not the ifEntry for the active call's B channel.")
ccBchannelChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelChannelIndex.setDescription('The B channel number for this B channel entry. BRI interfaces have B channels in the range 1..2, PRI interfaces have B channels in the range 1..31, excluding a channel which is the D channel.')
ccBchannelAllocated = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("no", 1), ("yes", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelAllocated.setDescription('A flag indicating whether this B channel is actually allocated to a call or not.')
ccBchannelCallType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 1), ("data", 2), ("voice", 3), ("x25", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelCallType.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelCallType.setDescription('The type of call on this B channel. If the B channel is not allocated, the call type will be undefined.')
ccBchannelActiveCallIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 128))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelActiveCallIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelActiveCallIndex.setDescription('The index of the active call which is currently attached to this B channel. If the value of this object is 0 the channel is either not allocated, or is not allocated to a data call.')
ccBchannelPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelPriority.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelPriority.setDescription('The priority of the call which has this B channel allocated to it. This is in the range 0..99 for data calls, 150 for voice calls and 200 for emergency voice calls. A B channel which is not allocated will have a priority of 0.')
ccBchannelDirection = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 37, 6, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("in", 1), ("out", 2), ("unallocated", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: ccBchannelDirection.setStatus('mandatory')
if mibBuilder.loadTexts: ccBchannelDirection.setDescription("The direction of the call which has this B channel allocated to it. If this B channel is not allocated the value will be 'unallocated'.")
bri = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41))
briIntTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1), )
if mibBuilder.loadTexts: briIntTable.setStatus('mandatory')
if mibBuilder.loadTexts: briIntTable.setDescription('The table of BRI interfaces.')
briIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "briIntIndex"))
if mibBuilder.loadTexts: briIntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: briIntEntry.setDescription('A single entry in the BRI interfaces table.')
briIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: briIntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: briIntIndex.setDescription('The ifIndex of the BRI interface.')
briIntBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: briIntBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: briIntBoardIndex.setDescription('The index in the arBoardTable of the board on which this BRI interface resides.')
briIntBoardPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: briIntBoardPosition.setStatus('mandatory')
if mibBuilder.loadTexts: briIntBoardPosition.setDescription("The position on this BRI interface's board of this BRI interface.")
briIntMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("isdn", 1), ("tdm", 2), ("mixed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: briIntMode.setStatus('mandatory')
if mibBuilder.loadTexts: briIntMode.setDescription('The mode of operation of this BRI interface. The value isdn means that the entire interface is operating as an ISDN interface, the value tdm means that the entire interface is operating as TDM groups and the value mixed means that some channels in the interface are dedicated to ISDN and some to TDM groups.')
briIntTdmChannelMap = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: briIntTdmChannelMap.setStatus('mandatory')
if mibBuilder.loadTexts: briIntTdmChannelMap.setDescription('A bit map of the channels in the BRI interface which are dedicated to TDM. Channel B1 has channel map value of 1, channel B2 has a channel map value of 2.')
briIntIsdnChannelMap = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: briIntIsdnChannelMap.setStatus('mandatory')
if mibBuilder.loadTexts: briIntIsdnChannelMap.setDescription('A bit map of the channels in the BRI interface which are dedicated to ISDN. Channel B1 has channel map value of 1, channel B2 has a channel map value of 2.')
briChanTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 2), )
if mibBuilder.loadTexts: briChanTable.setStatus('mandatory')
if mibBuilder.loadTexts: briChanTable.setDescription('The table of channels on BRI interfaces.')
briChanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 2, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "briChanIntIndex"), (0, "ALLIEDTELESYN-MIB", "briChanChannelIndex"))
if mibBuilder.loadTexts: briChanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: briChanEntry.setDescription('A single entry in the BRI channels table.')
briChanIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: briChanIntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: briChanIntIndex.setDescription('The ifIndex of the BRI interface.')
briChanChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: briChanChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: briChanChannelIndex.setDescription('The channel index of the BRI channel. Channel B1 has index 1, channel B2 has index 2 and the D channel has index 3.')
briChanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("isdn", 1), ("tdm", 2), ("none", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: briChanMode.setStatus('mandatory')
if mibBuilder.loadTexts: briChanMode.setDescription('The mode of this BRI channel. The value isdn means that the channel is reserved for use in ISDN calls. The value tdm means that the channel is reserved for use by TDM. For the D channel, this object will always have the value isdn.')
briChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 41, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: briChanState.setStatus('mandatory')
if mibBuilder.loadTexts: briChanState.setDescription('The state of this BRI channel. The value inactive means that the channel does not currently have an active user, either an ISDN call or an active TDM group. The value active means that the channel is in use, either by an ISDN call or an active TDM group. For the D channel, this object will have the value active if LAPD is using the D channel (either for call control or X.25), or the value inactive otherwise.')
pri = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42))
priIntTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1), )
if mibBuilder.loadTexts: priIntTable.setStatus('mandatory')
if mibBuilder.loadTexts: priIntTable.setDescription('The table of PRI interfaces.')
priIntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "priIntIndex"))
if mibBuilder.loadTexts: priIntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: priIntEntry.setDescription('A single entry in the PRI interfaces table.')
priIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: priIntIndex.setDescription('The ifIndex of the PRI interface.')
priIntBoardIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIntBoardIndex.setStatus('mandatory')
if mibBuilder.loadTexts: priIntBoardIndex.setDescription('The index in the arBoardTable of the board on which this PRI interface resides.')
priIntBoardPosition = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIntBoardPosition.setStatus('mandatory')
if mibBuilder.loadTexts: priIntBoardPosition.setDescription("The position on this PRI interface's board of this PRI interface.")
priIntMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("isdn", 1), ("tdm", 2), ("mixed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIntMode.setStatus('mandatory')
if mibBuilder.loadTexts: priIntMode.setDescription('The mode of operation of this PRI interface. The value isdn means that the entire interface is operating as an ISDN interface, the value tdm means that the entire interface is operating as TDM groups and the value mixed means that some channels in the interface are dedicated to ISDN and some to TDM groups.')
priIntTdmChannelMap = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIntTdmChannelMap.setStatus('mandatory')
if mibBuilder.loadTexts: priIntTdmChannelMap.setDescription('A bit map of the channels in the PRI interface which are dedicated to TDM. PRI channels are numbered from 0 to 31, 0 is unused, 16 (E1) or 24 (T1) is the D channel. The map values are 2 to the power of the channel number.')
priIntIsdnChannelMap = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIntIsdnChannelMap.setStatus('mandatory')
if mibBuilder.loadTexts: priIntIsdnChannelMap.setDescription('A bit map of the channels in the PRI interface which are dedicated to ISDN. PRI channels are numbered from 0 to 31, 0 is unused, 16 (E1) or 24 (T1) is the D channel. The map values are 2 to the power of the channel number.')
priIntType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("e1", 1), ("t1", 2), ("unknown", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: priIntType.setStatus('mandatory')
if mibBuilder.loadTexts: priIntType.setDescription('The type of primary rate interface. E1 has 30 B + D channel, T1 has 23 B + D channel. If the value unknown is returned for this object, the exact PRI type has not yet been determined.')
priChanTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 2), )
if mibBuilder.loadTexts: priChanTable.setStatus('mandatory')
if mibBuilder.loadTexts: priChanTable.setDescription('The table of channels on PRI interfaces.')
priChanEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 2, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "priChanIntIndex"), (0, "ALLIEDTELESYN-MIB", "priChanChannelIndex"))
if mibBuilder.loadTexts: priChanEntry.setStatus('mandatory')
if mibBuilder.loadTexts: priChanEntry.setDescription('A single entry in the PRI channels table.')
priChanIntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: priChanIntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: priChanIntIndex.setDescription('The ifIndex of the PRI interface.')
priChanChannelIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 2, 1, 2), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: priChanChannelIndex.setStatus('mandatory')
if mibBuilder.loadTexts: priChanChannelIndex.setDescription('The channel index of the PRI channel. Valid channels have indices from 1 to 31. The D channel on an E1 interface has index 16, the D channel on a T1 interface has index 24.')
priChanMode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("isdn", 1), ("tdm", 2), ("neither", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: priChanMode.setStatus('mandatory')
if mibBuilder.loadTexts: priChanMode.setDescription('The mode of this PRI channel. The value isdn means that the channel is reserved for use in ISDN calls. The value tdm means that the channel is reserved for use by TDM. For the D channel, this object will usually have the value isdn. An exception is if the interface is running common D channel mode and the D channel is reserved for TDM.')
priChanState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 42, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("inactive", 1), ("active", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: priChanState.setStatus('mandatory')
if mibBuilder.loadTexts: priChanState.setDescription('The state of this PRI channel. The value inactive means that the channel does not currently have an active user, either an ISDN call or an active TDM group. The value active means that the channel is in use, either by an ISDN call or an active TDM group.')
loader = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48))
loadTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 1), )
if mibBuilder.loadTexts: loadTable.setStatus('mandatory')
if mibBuilder.loadTexts: loadTable.setDescription('The table of load parameters, dynamic and static.')
loadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "loadIndex"))
if mibBuilder.loadTexts: loadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: loadEntry.setDescription('A single entry of load parameters. This contains the parameters required to perform a load from the router.')
loadIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadIndex.setStatus('mandatory')
if mibBuilder.loadTexts: loadIndex.setDescription('There are two sets of load information, dynamic and static. The dynamic information is used once, then cleared. The static information is used whenever the dynamic information is not available. The dynamic information is also used to indicate the current load parameters when a load is in progress.')
loadServer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 1, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadServer.setStatus('mandatory')
if mibBuilder.loadTexts: loadServer.setDescription('The IP address from which load will load.')
loadDestination = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("undefined", 1), ("nvs", 2), ("flash", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadDestination.setStatus('mandatory')
if mibBuilder.loadTexts: loadDestination.setDescription('The destination of the file loaded, either flash or nvs memory, or undefined.')
loadFilename = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadFilename.setStatus('mandatory')
if mibBuilder.loadTexts: loadFilename.setDescription('The file name of the file being loaded.')
loadDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 1, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadDelay.setStatus('mandatory')
if mibBuilder.loadTexts: loadDelay.setDescription('A delay in seconds between the initiation of the load and the start of the load. This allows for time to set up TFTP servers in cases where the terminal and TFTP server are using the same piece of equipment but will not work simultaneously.')
loadStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 48, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("idle", 1), ("wait", 2), ("loading", 3), ("complete", 4), ("reset", 5), ("actionstart", 6), ("actionstop", 7)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: loadStatus.setStatus('mandatory')
if mibBuilder.loadTexts: loadStatus.setDescription("Status and action object for the load module. The values 1 to 5 are read-only values and reflect the state of the load module. Values 4 and 5 (complete and reset) are 'read-once', that is, if their values are read, either by SNMP or by manager console command, then they will be changed back to idle(1). The action values (6 and 7) cause a start and stop of the load process respectively. Starting the load can only occur if this field has the values 1, 4, or 5. Stopping the load can only occur is this field has the values 2 or 3. Reading the value of the loadStatus after one of actionstart or actionstop has been set will give one of the values 1 to 5. Note: A single exception to the above rules is that if the value of loadStatus is idle(1), then a write of 1 to this variable will succeed without generating an error. This exception is to allow certain SNMP test suites to test this variable without throwing up errors.")
install = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49))
installTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1), )
if mibBuilder.loadTexts: installTable.setStatus('mandatory')
if mibBuilder.loadTexts: installTable.setDescription('The list of install configurations for the router.')
installEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "instIndex"))
if mibBuilder.loadTexts: installEntry.setStatus('mandatory')
if mibBuilder.loadTexts: installEntry.setDescription('An entry in the list of install configurations.')
instIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("temporary", 1), ("preferred", 2), ("default", 3), ("current", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instIndex.setStatus('mandatory')
if mibBuilder.loadTexts: instIndex.setDescription('The index for the install table. There are four install configurations defined in the router, default, preferred, temporary and current. The router will attempt to use these in the order temporary, preferred, default when it boots. An install that is undefined will be skipped, an install which points to a file which is not present will be skipped. When the temporary install is used, the information is deleted. The current configuration shows what the router currently has installed.')
instRelDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("eprom", 2), ("flash", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instRelDevice.setStatus('mandatory')
if mibBuilder.loadTexts: instRelDevice.setDescription('The device for the release in the install. If the device is flash the file for the release is given in instRelName. Devices none(1) or flash(3) are invalid for the default(3) release.')
instRelName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instRelName.setStatus('mandatory')
if mibBuilder.loadTexts: instRelName.setDescription('The file name for the release in the install, if the instRelDevice is flash(3). If the instRelDevice is none(1) or eprom(2), this object should be a null string.')
instRelMajor = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: instRelMajor.setStatus('mandatory')
if mibBuilder.loadTexts: instRelMajor.setDescription('The major release number for this install. This information is obtained by the router when the other elements in the row are set and is thus not directly set by management. If the release number is a.b.c, the major release number is a.')
instRelMinor = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: instRelMinor.setStatus('mandatory')
if mibBuilder.loadTexts: instRelMinor.setDescription('The minor release number for this install. This information is obtained by the router when the other elements in the row are set and is thus not directly set by management. If the release number is a.b.c, the major release number is b.')
instPatDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 3, 4))).clone(namedValues=NamedValues(("none", 1), ("flash", 3), ("nvs", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instPatDevice.setStatus('mandatory')
if mibBuilder.loadTexts: instPatDevice.setDescription('The device for the patch in the install. The file for the patch is given in instPatName unless the device is none(1).')
instPatName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instPatName.setStatus('mandatory')
if mibBuilder.loadTexts: instPatName.setDescription('The file name for the patch in the install.')
instRelInterim = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: instRelInterim.setStatus('mandatory')
if mibBuilder.loadTexts: instRelInterim.setDescription('The interim release number for this install. This information is obtained by the router when the other elements in the row are set and is thus not directly set by management. If the release number is a.b.c, the major release number is c. If the release number is a.b, the interim release number is 0.')
instRelExists = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instRelExists.setStatus('mandatory')
if mibBuilder.loadTexts: instRelExists.setDescription("Indicates if the release file exists or not. true(1) means it exists, false(2) means it doesn't.")
instPatExists = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instPatExists.setStatus('mandatory')
if mibBuilder.loadTexts: instPatExists.setDescription("Indicates if the patch file exists or not. true(1) means it exists, false(2) means it doesn't")
installHistoryTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 2), )
if mibBuilder.loadTexts: installHistoryTable.setStatus('mandatory')
if mibBuilder.loadTexts: installHistoryTable.setDescription('The table of descriptions of events in the install history of the router.')
installHistoryEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 2, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "instHistIndex"))
if mibBuilder.loadTexts: installHistoryEntry.setStatus('mandatory')
if mibBuilder.loadTexts: installHistoryEntry.setDescription('A single line describing part of the install history of the router.')
instHistIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: instHistIndex.setStatus('mandatory')
if mibBuilder.loadTexts: instHistIndex.setDescription('The index of this event in the install history. Indices run from 1 to the maximum number. The maximum number is not available as a managed object so this table will have to be traversed in order to find out how large it is.')
instHistLine = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: instHistLine.setStatus('mandatory')
if mibBuilder.loadTexts: instHistLine.setDescription('A line of text describing a single event in the install history of the router.')
configFile = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: configFile.setStatus('mandatory')
if mibBuilder.loadTexts: configFile.setDescription('The name of the file that the router will configure from at boot. The format of the name is the same as that for fileName described above. If the configuration file name is a zero length string, then there is no configuration file defined in the router.')
licenceTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4), )
if mibBuilder.loadTexts: licenceTable.setStatus('mandatory')
if mibBuilder.loadTexts: licenceTable.setDescription('The list of release licences in the router.')
licenceEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "licenceIndex"))
if mibBuilder.loadTexts: licenceEntry.setStatus('mandatory')
if mibBuilder.loadTexts: licenceEntry.setDescription('An entry in the list of release licences.')
licenceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: licenceIndex.setDescription('A unique licence index. Licence indices are recalculated every time the router reboots to reflect the current licences on the router. As licences are added, new indices are allocated to the new licences.')
licenceStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("deleting", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: licenceStatus.setStatus('mandatory')
if mibBuilder.loadTexts: licenceStatus.setDescription('The status of the file. When read, this object will always return a value of ok(1), since the object will not exist if the value is deleting(2). Write the value deleting(2) to this object to delete the file.')
licenceRelease = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: licenceRelease.setStatus('mandatory')
if mibBuilder.loadTexts: licenceRelease.setDescription('The file name for the release whose licence this is.')
licenceMajor = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: licenceMajor.setStatus('mandatory')
if mibBuilder.loadTexts: licenceMajor.setDescription('The major release number for the release whose licence this is.')
licenceMinor = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: licenceMinor.setStatus('mandatory')
if mibBuilder.loadTexts: licenceMinor.setDescription('The minor release number for the release whose licence this is.')
licencePassword = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: licencePassword.setStatus('mandatory')
if mibBuilder.loadTexts: licencePassword.setDescription('The password for this release. The password is a string of hex digits.')
licenceExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: licenceExpiry.setStatus('mandatory')
if mibBuilder.loadTexts: licenceExpiry.setDescription('A human-readable string that gives the expiry date of this licence.')
licenceInterim = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 4, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: licenceInterim.setStatus('mandatory')
if mibBuilder.loadTexts: licenceInterim.setDescription('The interim release number for the release whose licence this is.')
createConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: createConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: createConfigFile.setDescription('The name of a file to create containing the current router configuration. A read from this variable will return the same as the variable configFile. Thus to save the current configuration in the current configuration file, read createConfigFile first, then write the result back to createConfigFile. If this variable is written with the name of an existing file, the file will be replaced with the current configuration.')
configFileExist = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: configFileExist.setStatus('mandatory')
if mibBuilder.loadTexts: configFileExist.setDescription("Indicates if the boot configuration file exists or not. true(1) means it exists, false(2) means it doesn't")
configFileExistTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "configFileExist"))
if mibBuilder.loadTexts: configFileExistTrap.setDescription('This trap is generated when the boot file is detected as missing')
currentConfigFile = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 49, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: currentConfigFile.setStatus('mandatory')
if mibBuilder.loadTexts: currentConfigFile.setDescription('The name of the file that the router is currently configured with. The format of the name is the same as that for fileName described above. If the current configuration file name is a zero length string, then there is no current configuration file defined in the router.')
trigger = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 53))
triggerLastTriggerActivated = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 53, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: triggerLastTriggerActivated.setStatus('mandatory')
if mibBuilder.loadTexts: triggerLastTriggerActivated.setDescription('The trigger number of the most recent trigger activated on this router. This is also the variable sent in the trigger trap below. If no triggers have been activated yet since the last restart of this router, this variable will read as 0.')
triggerTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 53) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "triggerLastTriggerActivated"))
if mibBuilder.loadTexts: triggerTrap.setDescription('A trigger trap is generated a trigger is activated. The number of the trigger activated is given by the variable triggerLastTriggerActivated.')
file = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56))
fileTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1), )
if mibBuilder.loadTexts: fileTable.setStatus('mandatory')
if mibBuilder.loadTexts: fileTable.setDescription("A list of all the files in the router's non-volatile storage.")
fileEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "fileIndex"))
if mibBuilder.loadTexts: fileEntry.setStatus('mandatory')
if mibBuilder.loadTexts: fileEntry.setDescription('An entry in the list of files containing information about a single file in the router.')
fileIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileIndex.setStatus('mandatory')
if mibBuilder.loadTexts: fileIndex.setDescription('A unique file index. File indices are recalculated every time the router reboots to reflect the current files on the router. As files are added, new indices are allocated to the new files.')
fileName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileName.setStatus('mandatory')
if mibBuilder.loadTexts: fileName.setDescription('The name of the file, in the form <name.typ>. The name is up to eight characters long, the type is up to three characters long.')
fileDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("flash", 1), ("nvs", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileDevice.setStatus('mandatory')
if mibBuilder.loadTexts: fileDevice.setDescription('The device on which the file resides.')
fileCreationTime = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileCreationTime.setStatus('mandatory')
if mibBuilder.loadTexts: fileCreationTime.setDescription('The creation date and time for the file, in the format <dd-mmm-yy, hh:mm:ss>.')
fileStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ok", 1), ("deleting", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: fileStatus.setStatus('mandatory')
if mibBuilder.loadTexts: fileStatus.setDescription('The status of the file. When read, this object will always return a value of ok(1), since the object will not exist if the value is deleting(2). Write the value deleting(2) to this object to delete the file.')
fileSize = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileSize.setStatus('mandatory')
if mibBuilder.loadTexts: fileSize.setDescription('The size, in bytes, of the file.')
fileNumbers = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 56, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: fileNumbers.setStatus('mandatory')
if mibBuilder.loadTexts: fileNumbers.setDescription('The total number of files in FLASH and NVS.')
ping = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58))
pingTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1), )
if mibBuilder.loadTexts: pingTable.setStatus('mandatory')
if mibBuilder.loadTexts: pingTable.setDescription('The table of ping parameters, dynamic and static.')
pingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "pingIndex"))
if mibBuilder.loadTexts: pingEntry.setStatus('mandatory')
if mibBuilder.loadTexts: pingEntry.setDescription('A single entry of ping parameters. This contains the parameters required to perform a ping from the router. The ping specified by the dynamic parameters, can be initiated or stopped at any time by altering the pingStatus accordingly.')
pingIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: pingIndex.setStatus('mandatory')
if mibBuilder.loadTexts: pingIndex.setDescription('There are two sets of ping information, dynamic and static. The dynamic information is used only once, for the next ping, then automatically replaced with the static information. The static information is used whenever specific dynamic information is not specified. The dynamic information indicates the current ping parameters when a ping is in progress. If static information is not specified, defaults are used. Static information can be changed at any time, but dynamic information cannot be changed while a ping is in progress. A change to the static information when a ping is not currently active, also updates the dynamic information.')
pingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4))).clone(namedValues=NamedValues(("undefined", 0), ("apple", 1), ("ip", 2), ("ipx", 3), ("osi", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: pingProtocol.setDescription('The protocol that the ping will use. The protocol must match the destination address. Ping supports both IP, IPX, Appletalk, and OSI addresses. The protocol must be specified before the address is set, because when the protocol is changed, address is reset to undefined. The default value for this variable is undefined(0).')
pingAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 3), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingAddress.setStatus('mandatory')
if mibBuilder.loadTexts: pingAddress.setDescription('The address specifies the destination address for ping packets for Appletalk, IP, IPX and OSI networks, respectively. The address format must match the protocol being used. The protocol must be specified before the address is set, because changing the protocol resets the address to undefined. The default value for this variable is an undefined address which is coded as a zero length octet string.')
pingNumberOfPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 4), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingNumberOfPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pingNumberOfPackets.setDescription('The number of ping packets to transmit.')
pingPacketSize = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingPacketSize.setStatus('mandatory')
if mibBuilder.loadTexts: pingPacketSize.setDescription('The packet size parameter specifies the length in bytes, of data to include in the data portion of the ping packet. The protocol packet header size and the size of headers for the particular link protocol in use have to be added to the packet size to get the total size of the ping packet. The maximum pingPacketSize can be set to is 1500.')
pingTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 6), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingTimeout.setStatus('mandatory')
if mibBuilder.loadTexts: pingTimeout.setDescription('Timeout specifies the amount of time to wait for a response to a ping packet. Timeout must be greater than zero.')
pingDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 7), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingDelay.setStatus('mandatory')
if mibBuilder.loadTexts: pingDelay.setDescription('The delay parameter specifies the time interval, in seconds, between ping packets.')
pingTrapOnCompletion = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("true", 1), ("false", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingTrapOnCompletion.setStatus('mandatory')
if mibBuilder.loadTexts: pingTrapOnCompletion.setDescription('Specifies whether a trap should be issued on completion of the sequence of pings.')
pingTypeOfService = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingTypeOfService.setStatus('mandatory')
if mibBuilder.loadTexts: pingTypeOfService.setDescription('The Type Of Service (TOS) parameter is only valid for IP addresses, and specifies the TOS field in the IP header of the ping packet, as a decimal in the range 0 to 255.')
pingPattern = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 1, 1, 10), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingPattern.setStatus('mandatory')
if mibBuilder.loadTexts: pingPattern.setDescription('The pattern parameter specifies the data pattern to use in the data portion of the ping packet.')
pingStatus = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("start-running", 1), ("stop-stopped", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: pingStatus.setStatus('mandatory')
if mibBuilder.loadTexts: pingStatus.setDescription("Status and action object for the ping module. A status of '1' indicates that the ping is currently running, the status can be set to '2' to stop the ping. A status of '2' indicates that the ping is currently stopped, the pingStatus can be set to '1' to start the ping. The parameters for the ping can be altered in the pingTable. The destination ping address and protocol have defaults of undefined and must be specified before a ping can be started. The ping statistics are reset to defaults when a ping is started, and updated when the ping stops. Dynamic pingTable information is used only once, for the next ping. Static pingTable information is used for all pings by default, whenever the respective dynamic settings are not specified.")
pingStatistics = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 3))
pingSentPackets = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pingSentPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pingSentPackets.setDescription('The number of ping packets sent to the target in the last ping. The default before the completion of a ping is zero.')
pingReceivedPackets = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 3, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pingReceivedPackets.setStatus('mandatory')
if mibBuilder.loadTexts: pingReceivedPackets.setDescription('The number of packets received from the target in the last ping. The default before the completion of a ping is zero.')
pingMinimumRoundTripTime = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 3, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pingMinimumRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: pingMinimumRoundTripTime.setDescription('The quickest round trip time taken by any of the ping packets in milliseconds in the last ping. The default before the completion of a ping is negative one.')
pingAverageRoundTripTime = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 3, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pingAverageRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: pingAverageRoundTripTime.setDescription('The average round trip time taken by the ping packets in milliseconds in the last ping. The default before the completion of a ping is zero.')
pingMaximumRoundTripTime = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: pingMaximumRoundTripTime.setStatus('mandatory')
if mibBuilder.loadTexts: pingMaximumRoundTripTime.setDescription('The slowest round trip time taken by any of the ping packets in milliseconds in the last ping. The default before the completion of a ping is zero.')
pingTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 58) + (0,1))
if mibBuilder.loadTexts: pingTrap.setDescription('A ping trap is generated when a ping has completed. Traps are only generated if the variable pingTrapOnCompletion is set to true(1) in the dynamic ping entry. A trap is still generated if the ping is stopped prematurely by setting the variable pingStatus to stop/stopped(2).')
dhcp = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70))
dhcpRangeTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1), )
if mibBuilder.loadTexts: dhcpRangeTable.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeTable.setDescription('The table of DHCP ranges.')
dhcpRangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "dhcpRangeIndex"))
if mibBuilder.loadTexts: dhcpRangeEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeEntry.setDescription('A single entry of the DHCP range table. This contains information about a single DHCP range configured on this device.')
dhcpRangeIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeIndex.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeIndex.setDescription('The index of this DHCP range. DHCP ranges are stored in a list which is ordered by range name. The index gives the place in the list. Note that if ranges are added or deleted, the index for a given range will change. Since this table is read-only, this will not have an undue effect, but if in future this table is made read-write, a mechanism will have to be created to lock the indices of the range table while SET operations are proceeding.')
dhcpRangeName = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeName.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeName.setDescription('The name given to identify this DHCP range. This is the ultimate method for uniquely identifying this range. Names are compared without regard to case, for example >range1< will be treated as the same as >RANGE1<.')
dhcpRangeBaseAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeBaseAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeBaseAddress.setDescription('The base address of this range. This address defines the lower bound of the range of IP addresses which can be allocated to devices requesting an IP address via DHCP.')
dhcpRangeNumberOfAddresses = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 256))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeNumberOfAddresses.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeNumberOfAddresses.setDescription('The number of IP address in this range. This number defines the upper bound of the range of IP addresses which can be allocated to devices requesting an IP address via DHCP.')
dhcpRangeGateway = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 1, 1, 5), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeGateway.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeGateway.setDescription('The IP address of the BOOTP relay agent which will be relaying DHCP requests for this range. If this address is 0.0.0.0, then there will be no BOOTP relay agent and the range will be allocated to devices directly connected to this device.')
dhcpTrapVariable = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2))
dhcpRangeExhaustedGateway = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExhaustedGateway.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeExhaustedGateway.setDescription('Whenever a DHCP client attempts to lease an IP address and the DHCP server cannot provide an address, this variable is set to the gateway address of the DHCP request. The gateway address is the IP address of the gateway acting as a BOOTP relay agent for the request. If there is no gateway, the address will be 0.0.0.0. If the gateway address is non-zero, the DHCP range from which the allocation should have been made will able to be identified by lookup in the DHCP range table.')
dhcpRangeExhaustedInterface = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 2, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpRangeExhaustedInterface.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpRangeExhaustedInterface.setDescription('Whenever a DHCP client attempts to lease an IP address and the DHCP server cannot provide an address, this variable is set to the IP address of the interface which received the DHCP request. If the gateway address associated with the failed DHCP request is 0.0.0.0, the interface address will be able to be used to lookup the range that was exhausted and from which the allocation should have been made.')
dhcpRangeExhaustedTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "dhcpRangeExhaustedGateway"), ("ALLIEDTELESYN-MIB", "dhcpRangeExhaustedInterface"))
if mibBuilder.loadTexts: dhcpRangeExhaustedTrap.setDescription('This trap is generated when a DHCP client makes a request for an IP address and the request cannot be satisfied because all addresses in the range are already allocated to other devices.')
dhcpClientTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3), )
if mibBuilder.loadTexts: dhcpClientTable.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpClientTable.setDescription('The table of defined DHCP range client addresses.')
dhcpClientEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "dhcpRangeIndex"), (0, "ALLIEDTELESYN-MIB", "dhcpClientIpAddress"))
if mibBuilder.loadTexts: dhcpClientEntry.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpClientEntry.setDescription('A single entry of the DHCP range client table. This contains information about a single DHCP range client address.')
dhcpClientIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 1), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpClientIpAddress.setDescription('An IP address from the range of available addresses.')
dhcpClientID = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 2), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientID.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpClientID.setDescription('The hardware address of the client, if any, that has been assigned the IP address.')
dhcpClientState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("unused", 0), ("reclaiming", 1), ("inuse", 2), ("offered", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientState.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpClientState.setDescription('The state of the IP address; one of unused, inuse or reclaim.')
dhcpClientType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("auto", 1), ("dyn", 2), ("static", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientType.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpClientType.setDescription('The type of allocation mechanism applied to the IP address; one of static, auto or dyn.')
dhcpClientExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 70, 3, 1, 5), OctetString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: dhcpClientExpiry.setStatus('mandatory')
if mibBuilder.loadTexts: dhcpClientExpiry.setDescription('The expiry date for dynamically allocated IP address.')
firewall = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 77))
firewallTrapMessage = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 77, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: firewallTrapMessage.setStatus('mandatory')
if mibBuilder.loadTexts: firewallTrapMessage.setDescription('The last message sent in a firewall TRAP. This variable is really just a placeholder for the object sent in the firewall TRAP, but can be read independently if required. Note however that a new TRAP will cause this variable to be overwritten.')
firewallTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 77) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "firewallTrapMessage"))
if mibBuilder.loadTexts: firewallTrap.setDescription('A firewall trap is generated when the firewall detects an intrusion or attack and notifies the router manager. Firewall trap notifications are enabled with the command ENABLE FIREWALL NOTIFY=SNMP.')
swi = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87))
swiPortTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 1), )
if mibBuilder.loadTexts: swiPortTable.setStatus('mandatory')
if mibBuilder.loadTexts: swiPortTable.setDescription('Table of port properties.')
swiPortEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "swiPortNumber"))
if mibBuilder.loadTexts: swiPortEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swiPortEntry.setDescription('An entry in the port information table.')
swiPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swiPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: swiPortNumber.setDescription('This object identifies the port of the switch.')
swiPortIngressLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 1, 1, 20), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swiPortIngressLimit.setStatus('mandatory')
if mibBuilder.loadTexts: swiPortIngressLimit.setDescription('The Ingress Bandwidth Limit applied to the port. A value of zero indicates that no limit is set.')
swiPortEgressLimit = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 1, 1, 21), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: swiPortEgressLimit.setStatus('mandatory')
if mibBuilder.loadTexts: swiPortEgressLimit.setDescription('The Egress Bandwidth Limit applied to the port. A value of zero indicates that no limit is set.')
swi56xxPortCounterTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2), )
if mibBuilder.loadTexts: swi56xxPortCounterTable.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortCounterTable.setDescription('Table of swi56xx port counter properties.')
swi56xxPortCounterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "swi56xxPortNumber"))
if mibBuilder.loadTexts: swi56xxPortCounterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortCounterEntry.setDescription('An entry in the port information table.')
swi56xxPortNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortNumber.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortNumber.setDescription('This object identifies the port of the switch.')
swi56xxRxTx64kPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxRxTx64kPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxRxTx64kPkts.setDescription('The number of 64kB packets received and transmitted.')
swi56xxRxTx65To127kPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxRxTx65To127kPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxRxTx65To127kPkts.setDescription('The number of 65kB To 127kB packets received and transmitted.')
swi56xxRxTx128To255kPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxRxTx128To255kPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxRxTx128To255kPkts.setDescription('The number of 128kB To 255kB packets received and transmitted.')
swi56xxRxTx256To511kPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxRxTx256To511kPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxRxTx256To511kPkts.setDescription('The number of 256kB To 511kB packets received and transmitted.')
swi56xxRxTx512To1023kPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxRxTx512To1023kPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxRxTx512To1023kPkts.setDescription('The number of 512kB To 1023kB packets received and transmitted.')
swi56xxRxTx1024ToMaxPktSzPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxRxTx1024ToMaxPktSzPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxRxTx1024ToMaxPktSzPkts.setDescription('The number of 1024kB To MaxPktSz packets received and transmitted.')
swi56xxRxTx519To1522kPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxRxTx519To1522kPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxRxTx519To1522kPkts.setDescription('The number of 519kB To 1522kB packets received and transmitted.')
swi56xxPortRxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxOctets.setDescription('The number of octets received.')
swi56xxPortRxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxPkts.setDescription('The number of packets received.')
swi56xxPortRxFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxFCSErrors.setDescription('The number of frames received containing a Frame Check Sequence error.')
swi56xxPortRxMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxMulticastPkts.setDescription('The number of multicast packets received.')
swi56xxPortRxBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxBroadcastPkts.setDescription('The number of broadcast packets received.')
swi56xxPortRxPauseMACCtlFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxPauseMACCtlFrms.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxPauseMACCtlFrms.setDescription('The number of valid PAUSE MAC Control frames received.')
swi56xxPortRxOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxOversizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxOversizePkts.setDescription('The number of oversize packets received.')
swi56xxPortRxFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxFragments.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxFragments.setDescription('The number of fragments received.')
swi56xxPortRxJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxJabbers.setDescription('The number of jabber frames received.')
swi56xxPortRxMACControlFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxMACControlFrms.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxMACControlFrms.setDescription('The number of MAC Control frames (Pause and Unsupported) received.')
swi56xxPortRxUnsupportOpcode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxUnsupportOpcode.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxUnsupportOpcode.setDescription('The number of MAC Control frames with unsupported opcode (i.e. not Pause) received.')
swi56xxPortRxAlignmentErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxAlignmentErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxAlignmentErrors.setDescription('The number of frames with alignment errors received.')
swi56xxPortRxOutOfRngeLenFld = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxOutOfRngeLenFld.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxOutOfRngeLenFld.setDescription('The number of packets with length out of range received.')
swi56xxPortRxSymErDurCarrier = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxSymErDurCarrier.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxSymErDurCarrier.setDescription('The number of frames with invalid data symbols received.')
swi56xxPortRxCarrierSenseErr = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxCarrierSenseErr.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxCarrierSenseErr.setDescription('The number of false carrier conditions between frames received.')
swi56xxPortRxUndersizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 24), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxUndersizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxUndersizePkts.setDescription('The number of undersized packets received.')
swi56xxPortRxIpInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 25), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortRxIpInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortRxIpInHdrErrors.setDescription('swiPortRxIpInHdrErrors')
swi56xxPortTxOctets = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 26), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxOctets.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxOctets.setDescription('The number of octets transmitted.')
swi56xxPortTxPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 27), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxPkts.setDescription('The number of packets transmitted.')
swi56xxPortTxFCSErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 28), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxFCSErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxFCSErrors.setDescription('The number of frames containing a Frame Check Sequence error transmitted.')
swi56xxPortTxMulticastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 29), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxMulticastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxMulticastPkts.setDescription('The number of multicast packets transmitted.')
swi56xxPortTxBroadcastPkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 30), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxBroadcastPkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxBroadcastPkts.setDescription('The number of broadcast packets transmitted.')
swi56xxPortTxPauseMACCtlFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 31), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxPauseMACCtlFrms.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxPauseMACCtlFrms.setDescription('The number of valid PAUSE MAC Control frames transmitted.')
swi56xxPortTxOversizePkts = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 32), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxOversizePkts.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxOversizePkts.setDescription('The number of oversize packets transmitted.')
swi56xxPortTxFragments = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 33), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxFragments.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxFragments.setDescription('The number of fragments transmitted.')
swi56xxPortTxJabbers = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 34), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxJabbers.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxJabbers.setDescription('The number of jabber frames transmitted.')
swi56xxPortTxPauseCtrlFrms = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 35), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxPauseCtrlFrms.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxPauseCtrlFrms.setDescription('The number of Pause control frames transmitted.')
swi56xxPortTxFrameWDeferrdTx = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 36), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxFrameWDeferrdTx.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxFrameWDeferrdTx.setDescription('The number of frames deferred once before successful transmission.')
swi56xxPortTxFrmWExcesDefer = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 37), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxFrmWExcesDefer.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxFrmWExcesDefer.setDescription('The number of frame aborted after too many deferrals.')
swi56xxPortTxSingleCollsnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 38), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxSingleCollsnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxSingleCollsnFrm.setDescription('The number of frames which experienced exactly one collision.')
swi56xxPortTxMultCollsnFrm = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 39), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxMultCollsnFrm.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxMultCollsnFrm.setDescription('The number of frames which experienced 2 to 15 collisions (including late collisions).')
swi56xxPortTxLateCollsns = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 40), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxLateCollsns.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxLateCollsns.setDescription('The number of frames which experienced late collisions.')
swi56xxPortTxExcessivCollsns = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 41), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxExcessivCollsns.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxExcessivCollsns.setDescription('The number of frames aborted before transmission after 16 collisions.')
swi56xxPortTxCollisionFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 42), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortTxCollisionFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortTxCollisionFrames.setDescription('The total number of collisions.')
swi56xxPortMiscDropEvents = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 43), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortMiscDropEvents.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortMiscDropEvents.setDescription('The number of packets discarded at ingress port.')
swi56xxPortMiscTaggedPktTx = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 44), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortMiscTaggedPktTx.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortMiscTaggedPktTx.setDescription('The number of VLAN tagged packets transmitted.')
swi56xxPortMiscTotalPktTxAbort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 45), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortMiscTotalPktTxAbort.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortMiscTotalPktTxAbort.setDescription('The number of Layer 2 and 3 packets aborted during transmission.')
swi56xxPortHWMultiTTLexpired = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 46), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortHWMultiTTLexpired.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortHWMultiTTLexpired.setDescription('Number of multicast TTL expired frames.')
swi56xxPortHWMultiBridgedFrames = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 47), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortHWMultiBridgedFrames.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortHWMultiBridgedFrames.setDescription('Number of multicast bridged frames')
swi56xxPortHWMultiRxDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 48), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortHWMultiRxDrops.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortHWMultiRxDrops.setDescription('Number of multicast frames dropped at reception')
swi56xxPortHWMultiTxDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 2, 1, 49), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swi56xxPortHWMultiTxDrops.setStatus('mandatory')
if mibBuilder.loadTexts: swi56xxPortHWMultiTxDrops.setDescription('NNumber of multicast frames dropped at transmission')
swiDebugVariables = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 3))
swiDebugMemoryParityErrors = MibScalar((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87, 3, 1), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: swiDebugMemoryParityErrors.setStatus('mandatory')
if mibBuilder.loadTexts: swiDebugMemoryParityErrors.setDescription('For switches based on certain switch chips, the number of parity errors that have been detected in packet memory associated with the switch. If the device does not include the counting of memory parity errors, this variable will return 0.')
swiIntrusionDetectionTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 87) + (0,6)).setObjects(("IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: swiIntrusionDetectionTrap.setDescription('An intrusion detection trap is generated when a port has intrusion detection enabled, and the action taken when intrusion is detected is to generate a trap. Intrusion is detected when the number of MAC addresses learned on the port exceeds the configured learn limit. The ifIndex of the port is included in the trap.')
lb = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104))
lbShowGlobalTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1), )
if mibBuilder.loadTexts: lbShowGlobalTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowGlobalTable.setDescription('General configuration and status of all of the virtual balancers configured on the router.')
lbShowGlobalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "lbGlobalIndex"))
if mibBuilder.loadTexts: lbShowGlobalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowGlobalEntry.setDescription('An entry in the global table.')
lbGlobalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbGlobalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbGlobalIndex.setDescription('The index for the global table.')
lbAffinityTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbAffinityTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: lbAffinityTimeOut.setDescription('The length of time in seconds that a resource can be associated to a source IP address or Cookie after the connection has been closed.')
lbOrphanTimeOut = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbOrphanTimeOut.setStatus('mandatory')
if mibBuilder.loadTexts: lbOrphanTimeOut.setDescription('The length of time in seconds that a connection can exist without having any data traversing it, before being declared an orphan and closed by the router.')
lbCriticalRst = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbCriticalRst.setStatus('mandatory')
if mibBuilder.loadTexts: lbCriticalRst.setDescription('The ratio of total messages received from a resource that can be TCP RST messages represented as a percentage.')
lbTotalResources = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbTotalResources.setStatus('mandatory')
if mibBuilder.loadTexts: lbTotalResources.setDescription('The total number of resources configured on the router.')
lbTotalResPools = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbTotalResPools.setStatus('mandatory')
if mibBuilder.loadTexts: lbTotalResPools.setDescription('The total number of resource pools configured on the router.')
lbTotalVirtBals = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbTotalVirtBals.setStatus('mandatory')
if mibBuilder.loadTexts: lbTotalVirtBals.setDescription('The total number of virtual balancers configured on the router.')
lbCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 1, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbCurrentConnections.setStatus('mandatory')
if mibBuilder.loadTexts: lbCurrentConnections.setDescription('Displays the current total number of connections to all resources in every resource pool on the router.')
lbShowResTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2), )
if mibBuilder.loadTexts: lbShowResTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowResTable.setDescription('A list about the general information about for a given resource.')
lbShowResEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "lbResIndex"))
if mibBuilder.loadTexts: lbShowResEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowResEntry.setDescription('An entry in the resource table.')
lbResIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbResIndex.setDescription('The index for the resource table.')
lbResource = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResource.setStatus('mandatory')
if mibBuilder.loadTexts: lbResource.setDescription('The name of the resource.')
lbResIp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResIp.setStatus('mandatory')
if mibBuilder.loadTexts: lbResIp.setDescription('The IP address that a virtual balancer uses to accesses the resource.')
lbResPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPort.setDescription('The port that the service that the resource offer is accessed on.')
lbResState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResState.setStatus('mandatory')
if mibBuilder.loadTexts: lbResState.setDescription('The current state of the resource, either UP, DOWN, or CLOSING.')
lbResWeight = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResWeight.setStatus('mandatory')
if mibBuilder.loadTexts: lbResWeight.setDescription('The weight that the virtual balancer will apply to the resource when selecting resources to try a connection to from a resource pool using either the WEIGHTEDLEASTCONNECT or WEIGHTEDLOTTERY selection algorithms.')
lbResTotalConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResTotalConnections.setStatus('mandatory')
if mibBuilder.loadTexts: lbResTotalConnections.setDescription('The total number of successful connections that have been made to this resource while it has been in the UP state.')
lbResCurrentConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 2, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResCurrentConnections.setStatus('mandatory')
if mibBuilder.loadTexts: lbResCurrentConnections.setDescription('The total number of connections currently made to the resource.')
lbShowResPoolTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3), )
if mibBuilder.loadTexts: lbShowResPoolTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowResPoolTable.setDescription('A list about the general information about for a given resource pool.')
lbShowResPoolEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "lbResPoolIndex"), (0, "ALLIEDTELESYN-MIB", "lbResPoolResourceIndex"))
if mibBuilder.loadTexts: lbShowResPoolEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowResPoolEntry.setDescription('An entry in the resource pool table.')
lbResPoolIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPoolIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPoolIndex.setDescription('The index for the resource pool table.')
lbResPoolResourceIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPoolResourceIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPoolResourceIndex.setDescription('The index for the resource table.')
lbResPool = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPool.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPool.setDescription('The name of the resource pool.')
lbResPoolSelectionAlg = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPoolSelectionAlg.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPoolSelectionAlg.setDescription('The selection algorithm that ius employed by this resource pool when a resource has been selected for a connection. The options are ROUNDROBIN, WEIGHTEDLEASTCONNECT, WEIGHTEDLOTTERY and FASTESTRESPONSE.')
lbResPoolFailOnLast = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPoolFailOnLast.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPoolFailOnLast.setDescription('Indicates whether or not the resource pool will fail a resource if it is the last resource in the resource pool.')
lbResPoolTotalConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPoolTotalConnections.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPoolTotalConnections.setDescription('The total number of successful connections that have been made to the resources in the resource pool over the lifetime of the resource pool.')
lbResPoolResources = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 3, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbResPoolResources.setStatus('mandatory')
if mibBuilder.loadTexts: lbResPoolResources.setDescription('The name of the resource that is currently allocated to the resource pool.')
lbShowVirtBalTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4), )
if mibBuilder.loadTexts: lbShowVirtBalTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowVirtBalTable.setDescription('A list about the general information about for a given virtual balancer.')
lbShowVirtBalEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "lbVirtBalIndex"))
if mibBuilder.loadTexts: lbShowVirtBalEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowVirtBalEntry.setDescription('An entry in the virtual balancer table.')
lbVirtBalIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalIndex.setDescription('The index for the virtual balancer table.')
lbVirtBal = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBal.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBal.setDescription('The name of the virtual balancer.')
lbVirtBalPublicIp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalPublicIp.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalPublicIp.setDescription('The IP address on which the virtual balancer will receive requests for the service provided by the resource pool associated with it.')
lbVirtBalPublicPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalPublicPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalPublicPort.setDescription('The port on which the virtual balancer will receive requests for the service provided by the resource pool associated with it.')
lbVirtBalState = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalState.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalState.setDescription('The current state of the virtual balancer, can either be UP, CLOSING, or DOWN.')
lbVirtBalResPool = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalResPool.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalResPool.setDescription('The name of the resource pool that is associated with the virtual balancer.')
lbVirtBalType = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalType.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalType.setDescription('The type of load balancer that this virtual balancer currently is, can be either TCP, HTTP, or ROUTE.')
lbVirtBalTotalConnections = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalTotalConnections.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalTotalConnections.setDescription('The total number of stateful connections currently running through this virtual balancer.')
lbVirtBalAffinity = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 9), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalAffinity.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalAffinity.setDescription("Indicates whether or not entries will be made in a virtual balancers' affinity table for each stateful connection to a resource in its' resource pool (TCP and ROUTE type) or for cookies received from clients (HTTP type).")
lbVirtBalHttpErrorCode = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 4, 1, 10), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbVirtBalHttpErrorCode.setStatus('mandatory')
if mibBuilder.loadTexts: lbVirtBalHttpErrorCode.setDescription('A list of the HTTP server error status code added.')
lbShowAffTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5), )
if mibBuilder.loadTexts: lbShowAffTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowAffTable.setDescription('A list of affinity tables for all configured virtual balancers on the router.')
lbShowAffEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "lbAffIndex"))
if mibBuilder.loadTexts: lbShowAffEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowAffEntry.setDescription('An entry in the affinity table.')
lbAffIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbAffIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbAffIndex.setDescription('The index for the affinity table.')
lbAffVirtBal = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbAffVirtBal.setStatus('mandatory')
if mibBuilder.loadTexts: lbAffVirtBal.setDescription('The name of the virtual balancer whose affinity table is being displayed.')
lbAffClientIp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbAffClientIp.setStatus('mandatory')
if mibBuilder.loadTexts: lbAffClientIp.setDescription('The IP address that has affinity to the given resource.')
lbAffCookie = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbAffCookie.setStatus('mandatory')
if mibBuilder.loadTexts: lbAffCookie.setDescription('The cookie that has affinity to the given resource.')
lbAffResource = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbAffResource.setStatus('mandatory')
if mibBuilder.loadTexts: lbAffResource.setDescription('The name of the resource that the Client IP/Cookie has an affinity for.')
lbAffExpiry = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 5, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbAffExpiry.setStatus('mandatory')
if mibBuilder.loadTexts: lbAffExpiry.setDescription('The amount of seconds left before this entry expires, and is removed from the affinity table.')
lbShowConTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 6), )
if mibBuilder.loadTexts: lbShowConTable.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowConTable.setDescription('A list about all of the TCP connections currently open to a given virtual balancer.')
lbShowConEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 6, 1), ).setIndexNames((0, "ALLIEDTELESYN-MIB", "lbConIndex"))
if mibBuilder.loadTexts: lbShowConEntry.setStatus('mandatory')
if mibBuilder.loadTexts: lbShowConEntry.setDescription('An entry in the connections table.')
lbConIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbConIndex.setStatus('mandatory')
if mibBuilder.loadTexts: lbConIndex.setDescription('The index for the connections table.')
lbConVirtBal = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbConVirtBal.setStatus('mandatory')
if mibBuilder.loadTexts: lbConVirtBal.setDescription('The name of the virtual balancer the listed connections are to.')
lbConClientIp = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 6, 1, 3), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbConClientIp.setStatus('mandatory')
if mibBuilder.loadTexts: lbConClientIp.setDescription('The IP address of that originated the connection.')
lbConPort = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 6, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbConPort.setStatus('mandatory')
if mibBuilder.loadTexts: lbConPort.setDescription('The port on the originating system that represents the other end of the connection.')
lbConResource = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 104, 6, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: lbConResource.setStatus('mandatory')
if mibBuilder.loadTexts: lbConResource.setDescription('The name of the resource that the connection has been made to.')
ds3module = MibIdentifier((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109))
ds3TrapTable = MibTable((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109, 1), )
if mibBuilder.loadTexts: ds3TrapTable.setStatus('mandatory')
if mibBuilder.loadTexts: ds3TrapTable.setDescription('The ATR enterprise DS3 trap table.')
ds3TrapEntry = MibTableRow((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109, 1, 1), ).setIndexNames((0, "IF-MIB", "ifIndex"))
if mibBuilder.loadTexts: ds3TrapEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ds3TrapEntry.setDescription('An entry in the ATR enterprise DS3 trap table.')
ds3TcaTrapEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109, 1, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('disabled')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: ds3TcaTrapEnable.setStatus('mandatory')
if mibBuilder.loadTexts: ds3TcaTrapEnable.setDescription('Indicates whether the threshold crossing alert traps should be generated for this interface.')
ds3TrapError = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).clone(namedValues=NamedValues(("ds3NoError", 1), ("ds3PES", 2), ("ds3PSES", 3), ("ds3SEFs", 4), ("ds3UAS", 5), ("ds3LCVs", 6), ("ds3PCVs", 7), ("ds3LESs", 8), ("ds3CCVs", 9), ("ds3CESs", 10), ("ds3CSESs", 11))).clone('ds3NoError')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds3TrapError.setStatus('mandatory')
if mibBuilder.loadTexts: ds3TrapError.setDescription('This variable shows which kind of parameter or primitive caused the trap. This variable is really just a placeholder for the object sent in the DS3 TRAP, but can be read independently if required. The variable will hold the value at the latest trap. A value of ds3NoError shows no trap has occured')
ds3TrapLoc = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ds3NoLoc", 1), ("ds3Near", 2), ("ds3Far", 3))).clone('ds3NoLoc')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds3TrapLoc.setStatus('mandatory')
if mibBuilder.loadTexts: ds3TrapLoc.setDescription('This variable shows whether the trap was caused by a problem at the local or remote end. This variable is really just a placeholder for the object sent in the DS3 TRAP, but can be read independently if required. The variable will hold the value at the latest trap. A value of ds3NoLoc shows no trap had occured.')
ds3TrapInterval = MibTableColumn((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109, 1, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("ds3NoInt", 1), ("ds3Fifteen", 2), ("ds3Twentyfour", 3))).clone('ds3NoInt')).setMaxAccess("readonly")
if mibBuilder.loadTexts: ds3TrapInterval.setStatus('mandatory')
if mibBuilder.loadTexts: ds3TrapInterval.setDescription('This variable shows whether the counter which has crossed the threshold is a twenty four hour or fifteen minute counter. This variable is really just a placeholder for the object sent in the DS3 TRAP, but can be read independently if required. The variable will hold the value at the latest trap. A value of ds3NoInt shows no trap has occured.')
tcaTrap = NotificationType((1, 3, 6, 1, 4, 1, 207, 8, 4, 4, 4, 109) + (0,1)).setObjects(("ALLIEDTELESYN-MIB", "ds3TrapError"), ("ALLIEDTELESYN-MIB", "ds3TrapLoc"), ("ALLIEDTELESYN-MIB", "ds3TrapInterval"))
if mibBuilder.loadTexts: tcaTrap.setDescription('A DS3 trap is generated when a threshold crossing alert occurs. This happens when an error count exceeds a pre determined value. The values are counted over 15 minute and 24 hour periods. Once a trap has occured in a given period it may not occur again within the same period.')
mibBuilder.exportSymbols("ALLIEDTELESYN-MIB", ethIntDuplexMode=ethIntDuplexMode, ccCallLogEntry=ccCallLogEntry, swi56xxPortRxOctets=swi56xxPortRxOctets, ifaceEth=ifaceEth, arIfXAverageOutputPacketsSecond=arIfXAverageOutputPacketsSecond, swi56xxPortTxOversizePkts=swi56xxPortTxOversizePkts, dhcpRangeExhaustedGateway=dhcpRangeExhaustedGateway, pprA40SC=pprA40SC, pprSb24RJ=pprSb24RJ, lbTotalResPools=lbTotalResPools, pprAR440=pprAR440, ccDetailsNumberAttachments=ccDetailsNumberAttachments, chipRam16mb=chipRam16mb, ccBchannelActiveCallIndex=ccBchannelActiveCallIndex, priChanIntIndex=priChanIntIndex, ccActiveCallBchannelIndex=ccActiveCallBchannelIndex, acceleratorTemperature=acceleratorTemperature, sysinfo=sysinfo, fanAndPsRedundantFanStatus=fanAndPsRedundantFanStatus, ccDetailsLoginType=ccDetailsLoginType, lbResIp=lbResIp, chipRtc4=chipRtc4, pingMinimumRoundTripTime=pingMinimumRoundTripTime, generalTemperatureThreshold=generalTemperatureThreshold, at_8848_DC=at_8848_DC, loadFilename=loadFilename, lbShowResPoolEntry=lbShowResPoolEntry, realTimeClockStatus=realTimeClockStatus, swi56xxPortRxUndersizePkts=swi56xxPortRxUndersizePkts, ifaceSyn=ifaceSyn, centreCOM_AR300URouter=centreCOM_AR300URouter, pprIcmAr021s=pprIcmAr021s, swi56xxPortNumber=swi56xxPortNumber, swiPortEgressLimit=swiPortEgressLimit, swiIntrusionDetectionTrap=swiIntrusionDetectionTrap, lbShowAffEntry=lbShowAffEntry, swi56xxPortRxOversizePkts=swi56xxPortRxOversizePkts, dhcp=dhcp, lbAffClientIp=lbAffClientIp, licenceStatus=licenceStatus, cpuUtilisationAvgLast10Seconds=cpuUtilisationAvgLast10Seconds, pprAt8724XLDC=pprAt8724XLDC, briIntBoardIndex=briIntBoardIndex, arSlotEntry=arSlotEntry, pprIcmAr027=pprIcmAr027, dhcpRangeEntry=dhcpRangeEntry, centreCOM_AR130SRouter=centreCOM_AR130SRouter, ppr9816GBDC=ppr9816GBDC, arIfXEntry=arIfXEntry, pprSb8fSXMT=pprSb8fSXMT, sbTempFixedThreshold=sbTempFixedThreshold, chipFlash8mb=chipFlash8mb, chipRam4mb=chipRam4mb, instIndex=instIndex, lbVirtBalPublicIp=lbVirtBalPublicIp, pprAr450Dual=pprAr450Dual, pprSb8fLXSC=pprSb8fLXSC, fanAndPsPsuPresent=fanAndPsPsuPresent, pprAr320=pprAr320, pprA36MTRJ=pprA36MTRJ, pprA41SC=pprA41SC, ccBchannelChannelIndex=ccBchannelChannelIndex, ifacePri=ifacePri, arInterfaceIfIndex=arInterfaceIfIndex, pingNumberOfPackets=pingNumberOfPackets, chipRam32mb=chipRam32mb, arBoardSerialNumber=arBoardSerialNumber, swi56xxPortTxSingleCollsnFrm=swi56xxPortTxSingleCollsnFrm, ppr9816GF=ppr9816GF, at_Rapier48=at_Rapier48, swi56xxPortRxAlignmentErrors=swi56xxPortRxAlignmentErrors, arBoardRevision=arBoardRevision, flashPutFailure=flashPutFailure, acceleratorTemperatureActualTemp=acceleratorTemperatureActualTemp, pprSb96t=pprSb96t, swi56xxPortTxFrmWExcesDefer=swi56xxPortTxFrmWExcesDefer, centreCOM_AR120Router=centreCOM_AR120Router, protocols=protocols, pprA50=pprA50, chipRam1mb=chipRam1mb, arIfXAverageInputBitsSecond=arIfXAverageInputBitsSecond, pprAr140u=pprAr140u, pingPacketSize=pingPacketSize, pprAr300Lu=pprAr300Lu, pprSb8fSXSC=pprSb8fSXSC, ccCallLogDirection=ccCallLogDirection, pprSbControl=pprSbControl, iftypes=iftypes, lbVirtBalIndex=lbVirtBalIndex, pprAr390=pprAr390, pprIcmAR026=pprIcmAR026, flashReadFailure=flashReadFailure, pri=pri, swiDebugVariables=swiDebugVariables, lbShowVirtBalEntry=lbShowVirtBalEntry, pprSb1XFP=pprSb1XFP, pingTypeOfService=pingTypeOfService, dhcpRangeExhaustedTrap=dhcpRangeExhaustedTrap, pprAtPwr01DC=pprAtPwr01DC, cpu=cpu, sbTemperature=sbTemperature, ccDetailsPassword=ccDetailsPassword, instHistLine=instHistLine, swiPortNumber=swiPortNumber, ccDetailsRetryT1=ccDetailsRetryT1, pprAr120=pprAr120, tcaTrap=tcaTrap, licenceExpiry=licenceExpiry, ccDetailsInSetupCliSearch=ccDetailsInSetupCliSearch, ppr8948MX=ppr8948MX, fanAndPsMainPSUStatus=fanAndPsMainPSUStatus, install=install, ccCliListListIndex=ccCliListListIndex, pprAr745=pprAr745, ppr9812TDC=ppr9812TDC, arInterfaceTable=arInterfaceTable, swiPortEntry=swiPortEntry, lbVirtBalState=lbVirtBalState, sbTempIndex=sbTempIndex, priIntIsdnChannelMap=priIntIsdnChannelMap, lb=lb, chip68020Cpu=chip68020Cpu, arInterfaceName=arInterfaceName, at_Rapier16fSC=at_Rapier16fSC, pprSbExpander=pprSbExpander, ccDetailsOutSetupUser=ccDetailsOutSetupUser, briChanMode=briChanMode, licenceMajor=licenceMajor, pprRapier8t8fMT=pprRapier8t8fMT, pprA52=pprA52, swi56xxPortTxExcessivCollsns=swi56xxPortTxExcessivCollsns, swi56xxPortTxMulticastPkts=swi56xxPortTxMulticastPkts, briIntEntry=briIntEntry, pprSbChassis16AC=pprSbChassis16AC, ccActiveCallTable=ccActiveCallTable, ccActiveCallIndex=ccActiveCallIndex, ccCallLogTimeStarted=ccCallLogTimeStarted, pprFanA01=pprFanA01, ccAttachmentEntryIndex=ccAttachmentEntryIndex, swiPortIngressLimit=swiPortIngressLimit, lbShowGlobalEntry=lbShowGlobalEntry, memory=memory, modules=modules, ethIntIndex=ethIntIndex, fileEntry=fileEntry, swi56xxRxTx519To1522kPkts=swi56xxRxTx519To1522kPkts, dhcpRangeName=dhcpRangeName, arIfXAverageInputPacketsSecond=arIfXAverageInputPacketsSecond, ccDetailsEnabled=ccDetailsEnabled, at_8724XLDC=at_8724XLDC, arBoardTotalSlots=arBoardTotalSlots, swi56xxPortHWMultiRxDrops=swi56xxPortHWMultiRxDrops, instPatDevice=instPatDevice, cpuUtilisationMax=cpuUtilisationMax, ccCliListNumber=ccCliListNumber, pprA41MTRJ=pprA41MTRJ, at_8824=at_8824, fanAndPsRedundantFanStatusTrap=fanAndPsRedundantFanStatusTrap, instPatExists=instPatExists, at_Rapier8t8fSCi=at_Rapier8t8fSCi, pprRapier8t8fSC=pprRapier8t8fSC, chipRam12mb=chipRam12mb, at_Rapier16fVF=at_Rapier16fVF, fanAndPsRpsMonitoringStatus=fanAndPsRpsMonitoringStatus, at_AR442Router=at_AR442Router, priIntBoardIndex=priIntBoardIndex, pprAr300u=pprAr300u, chip68360Cpu=chip68360Cpu, arIfXAverageOutputBitsSecond=arIfXAverageOutputBitsSecond, licenceMinor=licenceMinor, loadIndex=loadIndex, swi56xxRxTx128To255kPkts=swi56xxRxTx128To255kPkts, ccDetailsInSetupUserCheck=ccDetailsInSetupUserCheck, briChanIntIndex=briChanIntIndex, ds3TrapLoc=ds3TrapLoc, fanAndPsAccelFanStatusTrap=fanAndPsAccelFanStatusTrap, centreCOM_AR395Router=centreCOM_AR395Router, pprSb48t=pprSb48t, pprAr88t8fMTi=pprAr88t8fMTi, ccBchannelTable=ccBchannelTable, flashCreateFailure=flashCreateFailure, fanAndPsFanTrayPresent=fanAndPsFanTrayPresent, swi56xxPortTxOctets=swi56xxPortTxOctets, ccDetailsCallingNumber=ccDetailsCallingNumber, briIntIsdnChannelMap=briIntIsdnChannelMap, centreCOM_AR140SRouter=centreCOM_AR140SRouter, arSlotDescription=arSlotDescription, pprRapier16fSCi=pprRapier16fSCi, fanAndPs=fanAndPs, at_Rapier8fSCi=at_Rapier8fSCi, fileDevice=fileDevice, alliedTelesyn=alliedTelesyn, pprAr745DC=pprAr745DC, pprAr88t8fSC=pprAr88t8fSC, centreCOM_AR300Router=centreCOM_AR300Router, briChanEntry=briChanEntry, swi56xxPortMiscDropEvents=swi56xxPortMiscDropEvents, dhcpRangeNumberOfAddresses=dhcpRangeNumberOfAddresses, at_RapierG6MT=at_RapierG6MT, pprNsm0418BRI=pprNsm0418BRI, pprAtFan01=pprAtFan01, arBoardEntry=arBoardEntry, ccAttachmentTable=ccAttachmentTable, swi56xxPortRxPauseMACCtlFrms=swi56xxPortRxPauseMACCtlFrms, swi56xxPortMiscTotalPktTxAbort=swi56xxPortMiscTotalPktTxAbort, at_9812TF=at_9812TF, swi56xxPortRxFragments=swi56xxPortRxFragments, swi=swi, priChanChannelIndex=priChanChannelIndex, ifaceBri=ifaceBri, lbAffinityTimeOut=lbAffinityTimeOut, licencePassword=licencePassword, centreCOM_AR720Router=centreCOM_AR720Router, triggerTrap=triggerTrap, pprRapier8t8fSCi=pprRapier8t8fSCi, ccCliListTable=ccCliListTable, ccDetailsRetryN2=ccDetailsRetryN2, pprC8724MLB=pprC8724MLB, pprAR550=pprAR550, arInterfaceFullName=arInterfaceFullName, pprSbChassis4DC=pprSbChassis4DC, firewallTrap=firewallTrap, bbrNvs=bbrNvs, dhcpRangeTable=dhcpRangeTable, sbTempActualTemperature=sbTempActualTemperature, loadTable=loadTable, at_Switchblade8AC=at_Switchblade8AC, pprAr88fMTi=pprAr88fMTi, fanAndPsPsuPower=fanAndPsPsuPower, lbConResource=lbConResource, pprSbChassis16DC=pprSbChassis16DC, acceleratorTemperatureStatusTrap=acceleratorTemperatureStatusTrap, pingStatus=pingStatus, ccBchannelEntry=ccBchannelEntry, chipRam3mb=chipRam3mb, centreCOM_AR370URouter=centreCOM_AR370URouter, pprA38LC=pprA38LC, ccActiveCallDirection=ccActiveCallDirection, fanAndPsMainPSUStatusTrap=fanAndPsMainPSUStatusTrap, centreCOM_AR300LRouter=centreCOM_AR300LRouter, fileNumbers=fileNumbers, arSlotBoardIndex=arSlotBoardIndex, at_AR450DualRouter=at_AR450DualRouter, pprAr824i=pprAr824i, at_86482SP=at_86482SP, cpuUtilisationMaxLast5Minutes=cpuUtilisationMaxLast5Minutes, pprRapier16fMTi=pprRapier16fMTi, dhcpClientState=dhcpClientState, lbShowResEntry=lbShowResEntry, ppr9924SP=ppr9924SP, at_AR410Router=at_AR410Router, pprNsm0404Pic=pprNsm0404Pic, swi56xxRxTx1024ToMaxPktSzPkts=swi56xxRxTx1024ToMaxPktSzPkts, atContactDetails=atContactDetails)
mibBuilder.exportSymbols("ALLIEDTELESYN-MIB", lbResPool=lbResPool, at_AR551Router=at_AR551Router, firewall=firewall, pprAr88fSC=pprAr88fSC, fanAndPsPsuStatusTable=fanAndPsPsuStatusTable, arBoardTable=arBoardTable, ccDetailsRetryN1=ccDetailsRetryN1, swi56xxPortTxJabbers=swi56xxPortTxJabbers, swi56xxPortTxBroadcastPkts=swi56xxPortTxBroadcastPkts, pprAtPwr02RAC=pprAtPwr02RAC, pprAr300=pprAr300, pprAr130s=pprAr130s, at_AR450Router=at_AR450Router, release=release, priChanMode=priChanMode, lbShowConEntry=lbShowConEntry, lbResPoolFailOnLast=lbResPoolFailOnLast, atRouter=atRouter, pprAr816fSCi=pprAr816fSCi, arIfXIndex=arIfXIndex, pprRapier8fSCi=pprRapier8fSCi, trigger=trigger, swi56xxPortRxSymErDurCarrier=swi56xxPortRxSymErDurCarrier, priChanState=priChanState, pprAR420=pprAR420, priChanTable=priChanTable, at_Rapier8fMT=at_Rapier8fMT, at_AR550Router=at_AR550Router, pprAr370u=pprAr370u, ppr9924T4SP=ppr9924T4SP, ping=ping, ccDetailsPrecedence=ccDetailsPrecedence, ppr9812T=ppr9812T, chipRam2mb=chipRam2mb, lbConIndex=lbConIndex, bridgeRouter=bridgeRouter, pprNsm048DS3=pprNsm048DS3, ethIntEntry=ethIntEntry, swi56xxPortTxFrameWDeferrdTx=swi56xxPortTxFrameWDeferrdTx, ccDetailsCallback=ccDetailsCallback, ccBchannelDirection=ccBchannelDirection, ccDetailsIndex=ccDetailsIndex, lbVirtBalPublicPort=lbVirtBalPublicPort, pprAr010=pprAr010, lbVirtBalType=lbVirtBalType, flashGetFailure=flashGetFailure, cpuUtilisationAvgLastMinute=cpuUtilisationAvgLastMinute, pprAr310=pprAr310, swi56xxPortTxFCSErrors=swi56xxPortTxFCSErrors, chipRam20mb=chipRam20mb, at_Rapier24=at_Rapier24, configFileExist=configFileExist, installTable=installTable, lbConPort=lbConPort, pprA40MTRJ=pprA40MTRJ, pprAt8848DC=pprAt8848DC, pprAt8724XLDC_NEBS=pprAt8724XLDC_NEBS, ccDetailsInSetupUserSearch=ccDetailsInSetupUserSearch, fanAndPsPsuFan=fanAndPsPsuFan, pprSb8fLXMT=pprSb8fLXMT, swi56xxPortHWMultiTxDrops=swi56xxPortHWMultiTxDrops, at_Rapier24i_DC_NEBS=at_Rapier24i_DC_NEBS, ccCallLogState=ccCallLogState, pprAr720=pprAr720, lbAffResource=lbAffResource, pingReceivedPackets=pingReceivedPackets, pprAt8748XL=pprAt8748XL, at_RapierG6LX=at_RapierG6LX, pprSb8GBIC=pprSb8GBIC, swi56xxPortRxJabbers=swi56xxPortRxJabbers, dhcpClientIpAddress=dhcpClientIpAddress, generalTemperatureStatusTrap=generalTemperatureStatusTrap, fanAndPsPsuStatusEntry=fanAndPsPsuStatusEntry, sysTemperature=sysTemperature, arSlotTable=arSlotTable, ccDetailsInSetupCalledSubSearch=ccDetailsInSetupCalledSubSearch, instPatName=instPatName, priChanEntry=priChanEntry, swi56xxPortMiscTaggedPktTx=swi56xxPortMiscTaggedPktTx, arInterfaceBoardIndex=arInterfaceBoardIndex, at_8724MLB=at_8724MLB, installHistoryEntry=installHistoryEntry, swi56xxPortRxPkts=swi56xxPortRxPkts, chips=chips, at_Rapier16fMTi=at_Rapier16fMTi, pprAr88fMT=pprAr88fMT, generalTemperatureStatus=generalTemperatureStatus, at_AR420Router=at_AR420Router, swi56xxPortTxPauseMACCtlFrms=swi56xxPortTxPauseMACCtlFrms, lbOrphanTimeOut=lbOrphanTimeOut, swi56xxPortRxOutOfRngeLenFld=swi56xxPortRxOutOfRngeLenFld, arIfXTable=arIfXTable, at_8948MX=at_8948MX, briChanChannelIndex=briChanChannelIndex, ccAttachmentUserInstance=ccAttachmentUserInstance, swi56xxRxTx65To127kPkts=swi56xxRxTx65To127kPkts, at_8624POE=at_8624POE, pprAt8624POE=pprAt8624POE, ppr9924T=ppr9924T, chipFlash4mb=chipFlash4mb, fanAndPsPsuNumber=fanAndPsPsuNumber, pprIcmAr022=pprIcmAr022, cpuUtilisationAvg=cpuUtilisationAvg, fanAndPsAccelFanStatus=fanAndPsAccelFanStatus, lbResPort=lbResPort, lbShowResPoolTable=lbShowResPoolTable, pprAr725=pprAr725, pprRapier8fMTi=pprRapier8fMTi, ccDetailsInSetupCalledSubCheck=ccDetailsInSetupCalledSubCheck, fanAndPsPsuTemperature=fanAndPsPsuTemperature, at_8748XL_80=at_8748XL_80, briIntIndex=briIntIndex, pprIcmAr025=pprIcmAr025, at_Rapier8fSC=at_Rapier8fSC, pprAR552=pprAR552, acceleratorTemperatureStatus=acceleratorTemperatureStatus, centreCOM_AR310Router=centreCOM_AR310Router, pprAr370=pprAr370, pprRapierG6SX=pprRapierG6SX, instRelName=instRelName, products=products, loader=loader, chipFlash6mb=chipFlash6mb, at_AR725RouterDC=at_AR725RouterDC, pprA42GBIC=pprA42GBIC, dhcpRangeGateway=dhcpRangeGateway, ccDetailsInAnyFlag=ccDetailsInAnyFlag, pprAR443=pprAR443, at_AR410v3Router=at_AR410v3Router, chip68340Cpu=chip68340Cpu, ccCliListEntry=ccCliListEntry, lbAffIndex=lbAffIndex, pprAtPwr02AC=pprAtPwr02AC, ccDetailsTable=ccDetailsTable, fanAndPsFanTrayPresentTrap=fanAndPsFanTrayPresentTrap, ccDetailsInSetupCliCheck=ccDetailsInSetupCliCheck, pprAt86482SP=pprAt86482SP, lbAffExpiry=lbAffExpiry, loadEntry=loadEntry, pprIcmAr020=pprIcmAr020, instRelExists=instRelExists, acceleratorTemperatureThreshold=acceleratorTemperatureThreshold, pprRapier24=pprRapier24, ccDetailsDataRate=ccDetailsDataRate, pprRapierG6LX=pprRapierG6LX, chipRtc1=chipRtc1, generalTemperature=generalTemperature, chip860TCpu=chip860TCpu, swi56xxPortCounterEntry=swi56xxPortCounterEntry, pprA53=pprA53, pprAt8824DC=pprAt8824DC, pprAr725DC=pprAr725DC, swi56xxRxTx256To511kPkts=swi56xxRxTx256To511kPkts, sbTempSettableThreshold=sbTempSettableThreshold, sbTempSettableThresholdTrap=sbTempSettableThresholdTrap, traps=traps, at_9924T=at_9924T, at_Switchblade4AC=at_Switchblade4AC, ifaceGBIC=ifaceGBIC, chipRtc2=chipRtc2, ccActiveCallDetailsIndex=ccActiveCallDetailsIndex, ccDetailsCalledNumber=ccDetailsCalledNumber, pprRapier48=pprRapier48, lbVirtBal=lbVirtBal, generalTemperatureSupported=generalTemperatureSupported, pprNsm0424BRI=pprNsm0424BRI, lbResPoolResourceIndex=lbResPoolResourceIndex, swi56xxRxTx64kPkts=swi56xxRxTx64kPkts, chipPem=chipPem, ccDetailsHoldupTime=ccDetailsHoldupTime, ccBchannelCallType=ccBchannelCallType, instRelMinor=instRelMinor, lbResPoolSelectionAlg=lbResPoolSelectionAlg, pprA39Tx=pprA39Tx, pingTrapOnCompletion=pingTrapOnCompletion, at_8624T2M=at_8624T2M, pingStatistics=pingStatistics, ccDetailsPppTemplate=ccDetailsPppTemplate, pingPattern=pingPattern, centreCOM_AR740Router=centreCOM_AR740Router, ccDetailsRemoteName=ccDetailsRemoteName, centreCOM_AR140URouter=centreCOM_AR140URouter, ethIntBoardIndex=ethIntBoardIndex, ccDetailsBumpDelay=ccDetailsBumpDelay, fanAndPsFanTrayStatus=fanAndPsFanTrayStatus, ccDetailsDirection=ccDetailsDirection, ppr9816GB=ppr9816GB, loadServer=loadServer, centreCOM_AR310URouter=centreCOM_AR310URouter, at_8748XLDC=at_8748XLDC, at_8824_DC=at_8824_DC, at_9924TEMC=at_9924TEMC, pprAr88fSCi=pprAr88fSCi, priIntMode=priIntMode, pprRapierG6MT=pprRapierG6MT, at_8624XL_80=at_8624XL_80, fileIndex=fileIndex, ppr8948EX=ppr8948EX, at_8948EX=at_8948EX, pprAr816fMTi=pprAr816fMTi, flashVerifyFailure=flashVerifyFailure, ccCliListEntryIndex=ccCliListEntryIndex, totalBuffers=totalBuffers, fileSize=fileSize, dhcpClientEntry=dhcpClientEntry, fanAndPsTemperatureStatus=fanAndPsTemperatureStatus, centreCOM_AR350Router=centreCOM_AR350Router, ccBchannelPriority=ccBchannelPriority, at_9816GB_DC=at_9816GB_DC, arInterfaceEntry=arInterfaceEntry, lbTotalVirtBals=lbTotalVirtBals, ds3TrapError=ds3TrapError, at_8724XL=at_8724XL, pprAR442=pprAR442, briIntMode=briIntMode, ifaceAsyn=ifaceAsyn, pingTrap=pingTrap, pprAt8848=pprAt8848, pprAt8624T2M=pprAt8624T2M, swi56xxPortRxMACControlFrms=swi56xxPortRxMACControlFrms, ccDetailsKeepup=ccDetailsKeepup, pprA35SXSC=pprA35SXSC, at_AR444Router=at_AR444Router, licenceIndex=licenceIndex, pprAtPwr01RAC=pprAtPwr01RAC, sbTempFixedThresholdStatus=sbTempFixedThresholdStatus, pprSb24SFP=pprSb24SFP, ccCallLogRemoteNumber=ccCallLogRemoteNumber, licenceEntry=licenceEntry, ccActiveCallEntry=ccActiveCallEntry, pprRapierG6=pprRapierG6, lbVirtBalAffinity=lbVirtBalAffinity, mibObject=mibObject, ifacePots=ifacePots, bbrNvsReinitialiseTrap=bbrNvsReinitialiseTrap, ccDetailsEntry=ccDetailsEntry, ccCallLogTable=ccCallLogTable, briIntTable=briIntTable, pprAr410v3=pprAr410v3, pprIcmAr024=pprIcmAr024, priIntIndex=priIntIndex, ds3TrapInterval=ds3TrapInterval, pprSbChassis8AC=pprSbChassis8AC, configFileExistTrap=configFileExistTrap, installEntry=installEntry, briIntTdmChannelMap=briIntTdmChannelMap, flashCompactFailure=flashCompactFailure, lbAffVirtBal=lbAffVirtBal, pingIndex=pingIndex, instRelMajor=instRelMajor, pprAt8824=pprAt8824, ppr9812TF=ppr9812TF, chipRam8mb=chipRam8mb, pprAr130u=pprAr130u)
mibBuilder.exportSymbols("ALLIEDTELESYN-MIB", fanAndPsRedundantPSUStatus=fanAndPsRedundantPSUStatus, pingTable=pingTable, ppr8724XLDC=ppr8724XLDC, fileStatus=fileStatus, licenceInterim=licenceInterim, dhcpClientID=dhcpClientID, centreCOM_AR320Router=centreCOM_AR320Router, pprAr140s=pprAr140s, dhcpRangeIndex=dhcpRangeIndex, swi56xxPortTxCollisionFrames=swi56xxPortTxCollisionFrames, generalTemperatureActualTemp=generalTemperatureActualTemp, centreCOM_AR300LURouter=centreCOM_AR300LURouter, pprSb32fSC=pprSb32fSC, priIntType=priIntType, licenceRelease=licenceRelease, freeMemory=freeMemory, pprSb8fRJ=pprSb8fRJ, ethIntBoardPosition=ethIntBoardPosition, pprAr395=pprAr395, flashDeleteFailure=flashDeleteFailure, at_AR725Router=at_AR725Router, lbCriticalRst=lbCriticalRst, centreCOM_AR330Router=centreCOM_AR330Router, pprAt8724XL=pprAt8724XL, at_AR740RouterDC=at_AR740RouterDC, dhcpClientExpiry=dhcpClientExpiry, lbResource=lbResource, pprAr330=pprAr330, ccDetailsInSetupCliCheckList=ccDetailsInSetupCliCheckList, ds3TcaTrapEnable=ds3TcaTrapEnable, pprAr816fMT=pprAr816fMT, ccDetailsName=ccDetailsName, lbVirtBalHttpErrorCode=lbVirtBalHttpErrorCode, pprIcmAr021u=pprIcmAr021u, pprAr011=pprAr011, fanAndPsMainMonitoringStatusTrap=fanAndPsMainMonitoringStatusTrap, swi56xxPortHWMultiBridgedFrames=swi56xxPortHWMultiBridgedFrames, triggerLastTriggerActivated=triggerLastTriggerActivated, brouterMib=brouterMib, ppr8624xl80=ppr8624xl80, pprAr824=pprAr824, at_AR441Router=at_AR441Router, pprA37VF45=pprA37VF45, flashCompleteFailure=flashCompleteFailure, pingProtocol=pingProtocol, installHistoryTable=installHistoryTable, ds3module=ds3module, flashOpenFailure=flashOpenFailure, pprAR441=pprAR441, pprAr310u=pprAr310u, pprSbChassis8DC=pprSbChassis8DC, ccActiveCallState=ccActiveCallState, centreCOM_AR390Router=centreCOM_AR390Router, swi56xxPortTxPkts=swi56xxPortTxPkts, pprAr740=pprAr740, instHistIndex=instHistIndex, at_9816GF=at_9816GF, arInterfacePosition=arInterfacePosition, instRelDevice=instRelDevice, lbVirtBalResPool=lbVirtBalResPool, ccBchannelAllocated=ccBchannelAllocated, ds3TrapEntry=ds3TrapEntry, swi56xxPortRxUnsupportOpcode=swi56xxPortRxUnsupportOpcode, ccDetailsOutSubaddress=ccDetailsOutSubaddress, pprAt8748XLDC=pprAt8748XLDC, at_AR745Router=at_AR745Router, fanAndPsMainMonitoringStatus=fanAndPsMainMonitoringStatus, priIntTable=priIntTable, loadDestination=loadDestination, sbTempEntry=sbTempEntry, flashWriteFailure=flashWriteFailure, pprRapier24i=pprRapier24i, pprRapier8t8fMTi=pprRapier8t8fMTi, at_Rapier8t8fMTi=at_Rapier8t8fMTi, pprIcmAr023=pprIcmAr023, fanAndPsRedundantPSUStatusTrap=fanAndPsRedundantPSUStatusTrap, ccAttachmentEntry=ccAttachmentEntry, flashCloseFailure=flashCloseFailure, ccDetailsInSetupCliSearchList=ccDetailsInSetupCliSearchList, at_RapierG6SX=at_RapierG6SX, pprA51=pprA51, lbShowResTable=lbShowResTable, lbResState=lbResState, pprRapier16fSC=pprRapier16fSC, swi56xxPortRxMulticastPkts=swi56xxPortRxMulticastPkts, lbVirtBalTotalConnections=lbVirtBalTotalConnections, at_AR443Router=at_AR443Router, flashCheckFailure=flashCheckFailure, fileCreationTime=fileCreationTime, priIntBoardPosition=priIntBoardPosition, pingAddress=pingAddress, at_Rapier8fMTi=at_Rapier8fMTi, ccActiveCallUserModule=ccActiveCallUserModule, ccDetailsUserType=ccDetailsUserType, swi56xxPortRxCarrierSenseErr=swi56xxPortRxCarrierSenseErr, sbTempFixedThresholdTrap=sbTempFixedThresholdTrap, loadDelay=loadDelay, at_8724XL_DC_NEBS=at_8724XL_DC_NEBS, pprAr88t8fMT=pprAr88t8fMT, ccBchannelIfIndex=ccBchannelIfIndex, lbCurrentConnections=lbCurrentConnections, lbResCurrentConnections=lbResCurrentConnections, pingEntry=pingEntry, lbShowGlobalTable=lbShowGlobalTable, at_RapierG6=at_RapierG6, swi56xxRxTx512To1023kPkts=swi56xxRxTx512To1023kPkts, swi56xxPortRxBroadcastPkts=swi56xxPortRxBroadcastPkts, pprRapier16fMT=pprRapier16fMT, lbShowConTable=lbShowConTable, file=file, dhcpRangeBaseAddress=dhcpRangeBaseAddress, chipRam6mb=chipRam6mb, ccAttachmentDetailsIndex=ccAttachmentDetailsIndex, pprA46Tx=pprA46Tx, loadStatus=loadStatus, pprRapier8fMT=pprRapier8fMT, centreCOM_AR370Router=centreCOM_AR370Router, boards=boards, pprRapier8fSC=pprRapier8fSC, ccCallLogIndex=ccCallLogIndex, ccCallLogName=ccCallLogName, at_8848=at_8848, lbGlobalIndex=lbGlobalIndex, lbResPoolTotalConnections=lbResPoolTotalConnections, arBoardIndex=arBoardIndex, ethernet=ethernet, at_8748XL=at_8748XL, cpuUtilisationAvgLastSecond=cpuUtilisationAvgLastSecond, dhcpTrapVariable=dhcpTrapVariable, pingDelay=pingDelay, cpuUtilisationAvgLast5Minutes=cpuUtilisationAvgLast5Minutes, ccDetailsUsername=ccDetailsUsername, flashFailureTrap=flashFailureTrap, ppr9924TEMC=ppr9924TEMC, at_AR410v2Router=at_AR410v2Router, pprAr350=pprAr350, licenceTable=licenceTable, createConfigFile=createConfigFile, ethIntTable=ethIntTable, ppr8748XLDC=ppr8748XLDC, swi56xxPortTxPauseCtrlFrms=swi56xxPortTxPauseCtrlFrms, at_8724XL_80=at_8724XL_80, at_Rapier24i=at_Rapier24i, ccActiveCallIfIndex=ccActiveCallIfIndex, fanAndPsRpsConnectionTrap=fanAndPsRpsConnectionTrap, lbShowAffTable=lbShowAffTable, ccDetailsUserModule=ccDetailsUserModule, arBoardName=arBoardName, ds3TrapTable=ds3TrapTable, at_Rapier48i=at_Rapier48i, pprAr410=pprAr410, lbResWeight=lbResWeight, InterfaceIndexOrZero=InterfaceIndexOrZero, pingAverageRoundTripTime=pingAverageRoundTripTime, arBoardTotalPositions=arBoardTotalPositions, swiDebugMemoryParityErrors=swiDebugMemoryParityErrors, pprAr816fSC=pprAr816fSC, priIntEntry=priIntEntry, pprAr410v2=pprAr410v2, at_Rapier8t8fMT=at_Rapier8t8fMT, ccActiveCallUserInstance=ccActiveCallUserInstance, ccAttachmentActiveCallIndex=ccAttachmentActiveCallIndex, hostId=hostId, pprRapier24iDC_NEBS=pprRapier24iDC_NEBS, ccActiveCallDataRate=ccActiveCallDataRate, pprSb32fMT=pprSb32fMT, at_9924T_4SP=at_9924T_4SP, pprRapier48i=pprRapier48i, arSlotHeldBoardIndex=arSlotHeldBoardIndex, at_AR552Router=at_AR552Router, dhcpClientTable=dhcpClientTable, centreCOM_AR160Router=centreCOM_AR160Router, pprAr88t8fSCi=pprAr88t8fSCi, sbTempSettableThresholdStatus=sbTempSettableThresholdStatus, arBoardId=arBoardId, cc=cc, dhcpRangeExhaustedInterface=dhcpRangeExhaustedInterface, at_AR440Router=at_AR440Router, lbResTotalConnections=lbResTotalConnections, arBoardMaxIndex=arBoardMaxIndex, firewallTrapMessage=firewallTrapMessage, fanAndPsTemperatureStatusTrap=fanAndPsTemperatureStatusTrap, pprAtPwr01AC=pprAtPwr01AC, ccDetailsRequiredIfIndex=ccDetailsRequiredIfIndex, bri=bri, at_9812T_DC=at_9812T_DC, at_Switchblade8DC=at_Switchblade8DC, centreCOM_AR130URouter=centreCOM_AR130URouter, fanAndPsPsuType=fanAndPsPsuType, sbTempTable=sbTempTable, pprIcmAr021v2s=pprIcmAr021v2s, flashEraseFailure=flashEraseFailure, fileName=fileName, swi56xxPortHWMultiTTLexpired=swi56xxPortHWMultiTTLexpired, fanAndPsMainFanStatus=fanAndPsMainFanStatus, pprSbChassis4AC=pprSbChassis4AC, objects=objects, pprAr740DC=pprAr740DC, lbConVirtBal=lbConVirtBal, configFile=configFile, pprAR551=pprAR551, pingMaximumRoundTripTime=pingMaximumRoundTripTime, at_9816GB=at_9816GB, swi56xxPortTxMultCollsnFrm=swi56xxPortTxMultCollsnFrm, at_9812T=at_9812T, acceleratorTemperatureSupported=acceleratorTemperatureSupported, ccDetailsOutSetupCalledSub=ccDetailsOutSetupCalledSub, arSlotSlotIndex=arSlotSlotIndex, at_Rapier16fMT=at_Rapier16fMT, at_9924SP=at_9924SP, chipFlash1mb=chipFlash1mb, lbAffCookie=lbAffCookie, ccDetailsOutSetupCli=ccDetailsOutSetupCli, briChanState=briChanState, instRelInterim=instRelInterim, swi56xxPortTxFragments=swi56xxPortTxFragments, pprAtFan01R=pprAtFan01R, swi56xxPortTxLateCollsns=swi56xxPortTxLateCollsns, ccDetailsPreferredIfIndex=ccDetailsPreferredIfIndex, arInterfaces=arInterfaces, pprAR444=pprAR444, pingSentPackets=pingSentPackets, swi56xxPortRxFCSErrors=swi56xxPortRxFCSErrors, dhcpClientType=dhcpClientType, fanAndPsMainFanStatusTrap=fanAndPsMainFanStatusTrap, pprAr160su=pprAr160su, chipFlash2mb=chipFlash2mb, lbShowVirtBalTable=lbShowVirtBalTable, restart=restart, swi56xxPortRxIpInHdrErrors=swi56xxPortRxIpInHdrErrors, ccDetailsPriority=ccDetailsPriority, briChanTable=briChanTable, lbResIndex=lbResIndex, pprAr300L=pprAr300L, pprA35LXSC=pprA35LXSC, fileTable=fileTable, chipFlash3mb=chipFlash3mb, at_Switchblade4DC=at_Switchblade4DC, swiPortTable=swiPortTable, swi56xxPortCounterTable=swi56xxPortCounterTable, fanAndPsRpsConnectionStatus=fanAndPsRpsConnectionStatus, lbConClientIp=lbConClientIp, chipRtc3=chipRtc3, at_Rapier8t8fSC=at_Rapier8t8fSC, fanAndPsFanTrayStatusTrap=fanAndPsFanTrayStatusTrap, at_Rapier16fSCi=at_Rapier16fSCi, at_AR745RouterDC=at_AR745RouterDC, routerSwitch=routerSwitch, lbTotalResources=lbTotalResources, pprAr012=pprAr012, ccDetailsAlternateNumber=ccDetailsAlternateNumber, briIntBoardPosition=briIntBoardPosition, pprAr450=pprAr450, pingTimeout=pingTimeout)
mibBuilder.exportSymbols("ALLIEDTELESYN-MIB", pprSbControlDTM=pprSbControlDTM, ccDetailsRetryT2=ccDetailsRetryT2, flash=flash, priIntTdmChannelMap=priIntTdmChannelMap, lbResPoolIndex=lbResPoolIndex, ccCallLogDuration=ccCallLogDuration, lbResPoolResources=lbResPoolResources, ccDetailsCallbackDelay=ccDetailsCallbackDelay, currentConfigFile=currentConfigFile, chip68302Cpu=chip68302Cpu)

#
# PySNMP MIB module CISCO-TAP-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/CISCO-TAP-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:13:59 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, OctetString, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "Integer", "OctetString", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetPortNumber, InetAddressPrefixLength, InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetPortNumber", "InetAddressPrefixLength", "InetAddress", "InetAddressType")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ObjectGroup, ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ObjectGroup", "ModuleCompliance", "NotificationGroup")
Bits, ObjectIdentity, Counter32, Unsigned32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, NotificationType, ModuleIdentity, iso, IpAddress, MibIdentifier, Counter64, Integer32, enterprises = mibBuilder.importSymbols("SNMPv2-SMI", "Bits", "ObjectIdentity", "Counter32", "Unsigned32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "NotificationType", "ModuleIdentity", "iso", "IpAddress", "MibIdentifier", "Counter64", "Integer32", "enterprises")
DateAndTime, TextualConvention, RowStatus, MacAddress, TruthValue, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "DateAndTime", "TextualConvention", "RowStatus", "MacAddress", "TruthValue", "DisplayString")
cTapMIB = ModuleIdentity((1, 3, 6, 1, 4, 1, 9, 9, 252))
cTapMIB.setRevisions(('2005-10-12 00:00', '2002-07-25 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: cTapMIB.setRevisionsDescriptions(('Add cTapStream802Debug notification.', 'Initial version of this MIB module.',))
if mibBuilder.loadTexts: cTapMIB.setLastUpdated('200510120000Z')
if mibBuilder.loadTexts: cTapMIB.setOrganization('Cisco Systems, Inc.')
if mibBuilder.loadTexts: cTapMIB.setContactInfo(' Cisco Systems Customer Service Postal:170 W. Tasman Drive San Jose, CA 95134 USA Tel:+1 800 553-NETS E-mail:cs-li@cisco.com')
if mibBuilder.loadTexts: cTapMIB.setDescription("This module manages Cisco's intercept feature.")
cTapMIBNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 0))
cTapMIBObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 1))
cTapMIBConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 2))
cTapMediationGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1))
cTapStreamGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2))
cTapDebugGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 3))
class Dscp(TextualConvention, Integer32):
    description = 'An integer that is in the range of the DiffServ codepoint values.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ValueRangeConstraint(0, 63)

cTapMediationNewIndex = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapMediationNewIndex.setStatus('current')
if mibBuilder.loadTexts: cTapMediationNewIndex.setDescription('This object contains a value which may be used as an index value for a new cTapMediationEntry. Whenever read, the agent will change the value to a new non-conflicting value. This is to reduce the probability of errors during creation of new cTapMediationTable entries.')
cTapMediationTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2), )
if mibBuilder.loadTexts: cTapMediationTable.setStatus('current')
if mibBuilder.loadTexts: cTapMediationTable.setDescription('This table lists the Mediation Devices with which the intercepting device communicates. These may be on the same or different Mediation Devices. This table is written by the Mediation Device, and is always volatile. This is because intercepts may disappear during a restart of the intercepting equipment.')
cTapMediationEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1), ).setIndexNames((0, "CISCO-TAP-MIB", "cTapMediationContentId"))
if mibBuilder.loadTexts: cTapMediationEntry.setStatus('current')
if mibBuilder.loadTexts: cTapMediationEntry.setDescription('The entry describes a single session maintained with an application on a Mediation Device.')
cTapMediationContentId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cTapMediationContentId.setStatus('current')
if mibBuilder.loadTexts: cTapMediationContentId.setDescription("cTapMediationContentId is a session identifier, from the intercept application's perspective, and a content identifier from the Mediation Device's perspective. The Mediation Device is responsible for making sure these are unique, although the SNMP RowStatus row creation process will help by not allowing it to create conflicting entries. Before creating a new entry, a value for this variable may be obtained by reading cTapMediationNewIndex to reduce the probability of a value collision.")
cTapMediationDestAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 2), InetAddressType()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationDestAddressType.setStatus('current')
if mibBuilder.loadTexts: cTapMediationDestAddressType.setDescription('The type of cTapMediationDestAddress.')
cTapMediationDestAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 3), InetAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationDestAddress.setStatus('current')
if mibBuilder.loadTexts: cTapMediationDestAddress.setDescription("The IP Address of the Mediation Device's network interface to which to direct intercepted traffic.")
cTapMediationDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 4), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationDestPort.setStatus('current')
if mibBuilder.loadTexts: cTapMediationDestPort.setDescription("The port number on the Mediation Device's network interface to which to direct intercepted traffic.")
cTapMediationSrcInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationSrcInterface.setStatus('current')
if mibBuilder.loadTexts: cTapMediationSrcInterface.setDescription('The interface on the intercepting device from which to transmit intercepted data. If zero, any interface may be used according to normal IP practice.')
cTapMediationRtcpPort = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 6), InetPortNumber()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapMediationRtcpPort.setStatus('current')
if mibBuilder.loadTexts: cTapMediationRtcpPort.setDescription("The port number on the intercepting device to which the Mediation Devices directs RTCP Receiver Reports and Nacks. This object is only relevant when the value of cTapMediationTransport is 'rtpNack'. This port is assigned by the intercepting device, rather than by the Mediation Device or manager application. The value of this MIB object has no effect before activating the cTapMediationEntry.")
cTapMediationDscp = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 7), Dscp().clone(34)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationDscp.setStatus('current')
if mibBuilder.loadTexts: cTapMediationDscp.setDescription('The Differentiated Services Code Point the intercepting device applies to the IP packets encapsulating the intercepted traffic.')
cTapMediationDataType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationDataType.setStatus('current')
if mibBuilder.loadTexts: cTapMediationDataType.setDescription("If RTP with Ack/Nack resilience is selected as a transport, the mediation process requires an RTP payload type for data transmissions, and a second RTP payload type for retransmissions. This is the RTP payload type for transmissions. This object is only effective when the value of cTapMediationTransport is 'rtpNack'.")
cTapMediationRetransmitType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 127))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationRetransmitType.setStatus('current')
if mibBuilder.loadTexts: cTapMediationRetransmitType.setDescription("If RTP with Ack/Nack resilience is selected as a transport, the mediation process requires an RTP payload type for data transmissions, and a second RTP payload type for retransmissions. This is the RTP payload type for retransmissions. This object is only effective when the value of cTapMediationTransport is 'rtpNack'.")
cTapMediationTimeout = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 10), DateAndTime()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationTimeout.setStatus('current')
if mibBuilder.loadTexts: cTapMediationTimeout.setDescription("The time at which this row and all related Stream Table rows should be automatically removed, and the intercept function cease. Since the initiating network manager may be the only device able to manage a specific intercept or know of its existence, this acts as a fail-safe for the failure or removal of the network manager. The object is only effective when the value of cTapMediationStatus is 'active'.")
cTapMediationTransport = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("udp", 1), ("rtpNack", 2), ("tcp", 3), ("sctp", 4)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationTransport.setStatus('current')
if mibBuilder.loadTexts: cTapMediationTransport.setDescription('The protocol used in transferring intercepted data to the Mediation Device. The following protocols may be supported: udp: PacketCable udp format rtpNack: RTP with Nack resilience tcp: TCP with head of line blocking sctp: SCTP with head of line blocking ')
cTapMediationNotificationEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 12), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationNotificationEnable.setStatus('current')
if mibBuilder.loadTexts: cTapMediationNotificationEnable.setDescription('This variable controls the generation of any notifications or informs by the MIB agent for this table entry.')
cTapMediationStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 2, 1, 13), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapMediationStatus.setStatus('current')
if mibBuilder.loadTexts: cTapMediationStatus.setDescription("The status of this conceptual row. This object is used to manage creation, modification and deletion of rows in this table. cTapMediationTimeout may be modified at any time (even while the row is active). But when the row is active, the other writable objects may not be modified without setting its value to 'notInService'. The entry may not be deleted or deactivated by setting its value to 'destroy' or 'notInService' if there is any associated entry in cTapStreamIpTable, or other such tables when such are defined.")
cTapMediationCapabilities = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 1, 3), Bits().clone(namedValues=NamedValues(("ipV4SrcInterface", 0), ("ipV6SrcInterface", 1), ("udp", 2), ("rtpNack", 3), ("tcp", 4), ("sctp", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapMediationCapabilities.setStatus('current')
if mibBuilder.loadTexts: cTapMediationCapabilities.setDescription('This object displays the device capabilities with respect to certain fields in Mediation Device table. This may be dependent on hardware capabilities, software capabilities. The following values may be supported: ipV4SrcInterface: SNMP ifIndex Value may be used to select the interface (denoted by cTapMediationSrcInterface) on the intercepting device from which to transmit intercepted data to an IPv4 address Mediation Device. ipV6SrcInterface: SNMP ifIndex Value may be used to select the interface (denoted by cTapMediationSrcInterface) on the intercepting device from which to transmit intercepted data to an IPv6 address Mediation Device. udp: UDP may be used as transport protocol (denoted by cTapMediationTransport) in transferring intercepted data to the Mediation Device. rtcpNack: RTP with Nack resilience may be used as transport protocol (denoted by cTapMediationTransport) in transferring intercepted data to the Mediation Device. tcp: TCP may be used as transport protocol (denoted by cTapMediationTransport) in transferring intercepted data to the Mediation Device. sctp: SCTP may be used as transport protocol (denoted by cTapMediationTransport) in transferring intercepted data to the Mediation Device.')
cTapStreamCapabilities = MibScalar((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 1), Bits().clone(namedValues=NamedValues(("tapEnable", 0), ("interface", 1), ("ipV4", 2), ("ipV6", 3), ("l4Port", 4), ("dscp", 5), ("dstMacAddr", 6), ("srcMacAddr", 7), ("ethernetPid", 8), ("dstLlcSap", 9), ("srcLlcSap", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapStreamCapabilities.setStatus('current')
if mibBuilder.loadTexts: cTapStreamCapabilities.setDescription("This object displays what types of intercept streams can be configured on this type of device. This may be dependent on hardware capabilities, software capabilities. The following fields may be supported: interface: SNMP ifIndex Value may be used to select interception of all data crossing an interface or set of interfaces. tapEnable: set if table entries with cTapStreamIpInterceptEnable set to 'false' are used to pre-screen packets for intercept; otherwise these entries are ignored. ipV4: IPv4 Address or prefix may be used to select traffic to be intercepted. ipV6: IPv6 Address or prefix may be used to select traffic to be intercepted. l4Port: TCP/UDP Ports may be used to select traffic to be intercepted. dscp: DSCP may be used to select traffic to be intercepted. dstMacAddr: Destination MAC Address may be used to select traffic to be intercepted. srcMacAddr: Source MAC Address may be used to select traffic to be intercepted. ethernetPid: Ethernet Protocol Identifier may be used to select traffic to be intercepted. dstLlcSap: IEEE 802.2 Destination SAP may be used to select traffic to be intercepted. srcLlcSap: IEEE 802.2 Source SAP may be used to select traffic to be intercepted.")
cTapStreamIpTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2), )
if mibBuilder.loadTexts: cTapStreamIpTable.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpTable.setDescription('The Intercept Stream IP Table lists the IPv4 and IPv6 streams to be intercepted. The same data stream may be required by multiple taps, and one might assume that often the intercepted stream is a small subset of the traffic that could be intercepted. This essentially provides options for packet selection, only some of which might be used. For example, if all traffic to or from a given interface is to be intercepted, one would configure an entry which lists the interface, and wild-card everything else. If all traffic to or from a given IP Address is to be intercepted, one would configure two such entries listing the IP Address as source and destination respectively, and wild-card everything else. If a particular voice on a teleconference is to be intercepted, on the other hand, one would extract the multicast (destination) IP address, the source IP Address, the protocol (UDP), and the source and destination ports from the call control exchange and list all necessary information. The first index indicates which Mediation Device the intercepted traffic will be diverted to. The second index permits multiple classifiers to be used together, such as having an IP address as source or destination. ')
cTapStreamIpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1), ).setIndexNames((0, "CISCO-TAP-MIB", "cTapMediationContentId"), (0, "CISCO-TAP-MIB", "cTapStreamIpIndex"))
if mibBuilder.loadTexts: cTapStreamIpEntry.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpEntry.setDescription('A stream entry indicates a single data stream to be intercepted to a Mediation Device. Many selected data streams may go to the same application interface, and many application interfaces are supported.')
cTapStreamIpIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cTapStreamIpIndex.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpIndex.setDescription('The index of the stream itself.')
cTapStreamIpInterface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpInterface.setReference('RFC 1213, RFC 2096')
if mibBuilder.loadTexts: cTapStreamIpInterface.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpInterface.setDescription('The ifIndex value of the interface over which traffic to be intercepted is received or transmitted. The interface may be physical or virtual. If this is the only parameter specified, and it is other than -1 or 0, all traffic on the selected interface will be chosen. If the value is zero, matching traffic may be received or transmitted on any interface. Additional selection parameters must be selected to limit the scope of traffic intercepted. This is most useful on non-routing platforms or on intercepts placed elsewhere than a subscriber interface. If the value is -1, one or both of cTapStreamIpDestinationAddress and cTapStreamIpSourceAddress must be specified with prefix length greater than zero. Matching traffic on the interface pointed to by ipRouteIfIndex or ipCidrRouteIfIndex values associated with those values is intercepted, whichever is specified to be more focused than a default route. If routing changes, either by operator action or by routing protocol events, the interface will change with it. This is primarily intended for use on subscriber interfaces and other places where routing is guaranteed to be symmetrical. In both of these cases, it is possible to have the same packet selected for intersection on both its ingress and egress interface. Nonetheless, only one instance of the packet is sent to the Mediation Device. This value must be set when creating a stream entry, either to select an interface, to select all interfaces, or to select the interface that routing chooses. Some platforms may not implement the entire range of options.')
cTapStreamIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 3), InetAddressType().clone('ipv4')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpAddrType.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpAddrType.setDescription('The type of address, used in packet selection.')
cTapStreamIpDestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 4), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpDestinationAddress.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpDestinationAddress.setDescription('The Destination address or prefix used in packet selection. This address will be of the type specified in cTapStreamIpAddrType.')
cTapStreamIpDestinationLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 5), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpDestinationLength.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpDestinationLength.setDescription('The length of the Destination Prefix. A value of zero causes all addresses to match. This prefix length will be consistent with the type specified in cTapStreamIpAddrType.')
cTapStreamIpSourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 6), InetAddress().clone(hexValue="00000000")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpSourceAddress.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpSourceAddress.setDescription('The Source Address used in packet selection. This address will be of the type specified in cTapStreamIpAddrType.')
cTapStreamIpSourceLength = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 7), InetAddressPrefixLength()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpSourceLength.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpSourceLength.setDescription('The length of the Source Prefix. A value of zero causes all addresses to match. This prefix length will be consistent with the type specified in cTapStreamIpAddrType.')
cTapStreamIpTosByte = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpTosByte.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpTosByte.setDescription('The value of the TOS byte, when masked with cTapStreamIpTosByteMask, of traffic to be intercepted. If cTapStreamIpTosByte & (~cTapStreamIpTosByteMask) != 0, configuration is rejected.')
cTapStreamIpTosByteMask = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 9), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpTosByteMask.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpTosByteMask.setDescription('The value of the TOS byte in an IPv4 or IPv6 header is ANDed with cTapStreamIpTosByteMask and compared with cTapStreamIpTosByte. If the values are equal, the comparison is equal. If the mask is zero and the TosByte value is zero, the result is to always accept.')
cTapStreamIpFlowId = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 1048575), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpFlowId.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpFlowId.setDescription('The flow identifier in an IPv6 header. -1 indicates that the Flow Id is unused.')
cTapStreamIpProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 255), )).clone(-1)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpProtocol.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpProtocol.setDescription("The IP protocol to match against the IPv4 protocol number or the IPv6 Next- Header number in the packet. -1 means 'any IP protocol'.")
cTapStreamIpDestL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 12), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpDestL4PortMin.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpDestL4PortMin.setDescription('The minimum value that the layer-4 destination port number in the packet must have in order to match. This value must be equal to or less than the value specified for this entry in cTapStreamIpDestL4PortMax. If both cTapStreamIpDestL4PortMin and cTapStreamIpDestL4PortMax are at their default values, the port number is effectively unused.')
cTapStreamIpDestL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 13), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpDestL4PortMax.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpDestL4PortMax.setDescription('The maximum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in cTapStreamIpDestL4PortMin. If both cTapStreamIpDestL4PortMin and cTapStreamIpDestL4PortMax are at their default values, the port number is effectively unused.')
cTapStreamIpSourceL4PortMin = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 14), InetPortNumber()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpSourceL4PortMin.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpSourceL4PortMin.setDescription('The minimum value that the layer-4 destination port number in the packet must have in order to match. This value must be equal to or less than the value specified for this entry in cTapStreamIpSourceL4PortMax. If both cTapStreamIpSourceL4PortMin and cTapStreamIpSourceL4PortMax are at their default values, the port number is effectively unused.')
cTapStreamIpSourceL4PortMax = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 15), InetPortNumber().clone(65535)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpSourceL4PortMax.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpSourceL4PortMax.setDescription('The maximum value that the layer-4 destination port number in the packet must have in order to match this classifier entry. This value must be equal to or greater than the value specified for this entry in cTapStreamIpSourceL4PortMin. If both cTapStreamIpSourceL4PortMin and cTapStreamIpSourceL4PortMax are at their default values, the port number is effectively unused.')
cTapStreamIpInterceptEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 16), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpInterceptEnable.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpInterceptEnable.setDescription("If 'true', the tap should intercept matching traffic. If 'false', this entry is used to pre-screen packets for intercept.")
cTapStreamIpInterceptedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapStreamIpInterceptedPackets.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpInterceptedPackets.setDescription('The number of packets matching this data stream specification that have been intercepted.')
cTapStreamIpInterceptDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapStreamIpInterceptDrops.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpInterceptDrops.setDescription('The number of packets matching this data stream specification that, having been intercepted, were dropped in the lawful intercept process.')
cTapStreamIpStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 2, 1, 19), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStreamIpStatus.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpStatus.setDescription("The status of this conceptual row. This object manages creation, modification, and deletion of rows in this table. cTapStreamIpInterceptEnable may be modified any time even the value of this entry rowStatus object is 'active'. When other rows must be changed, cTapStreamIpStatus must be first set to 'notInService'.")
cTapStream802Table = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3), )
if mibBuilder.loadTexts: cTapStream802Table.setStatus('current')
if mibBuilder.loadTexts: cTapStream802Table.setDescription('The Intercept Stream 802 Table lists the IEEE 802 data streams to be intercepted. The same data stream may be required by multiple taps, and one might assume that often the intercepted stream is a small subset of the traffic that could be intercepted. This essentially provides options for packet selection, only some of which might be used. For example, if all traffic to or from a given interface is to be intercepted, one would configure an entry which lists the interface, and wild-card everything else. If all traffic to or from a given MAC Address is to be intercepted, one would configure two such entries listing the MAC Address as source and destination respectively, and wild-card everything else. The first index indicates which Mediation Device the intercepted traffic will be diverted to. The second index permits multiple classifiers to be used together, such as having a MAC address as source or destination. ')
cTapStream802Entry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1), ).setIndexNames((0, "CISCO-TAP-MIB", "cTapMediationContentId"), (0, "CISCO-TAP-MIB", "cTapStream802Index"))
if mibBuilder.loadTexts: cTapStream802Entry.setStatus('current')
if mibBuilder.loadTexts: cTapStream802Entry.setDescription('A stream entry indicates a single data stream to be intercepted to a Mediation Device. Many selected data streams may go to the same application interface, and many application interfaces are supported.')
cTapStream802Index = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 2147483647))).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cTapStream802Index.setStatus('current')
if mibBuilder.loadTexts: cTapStream802Index.setDescription('The index of the stream itself.')
cTapStream802Fields = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 2), Bits().clone(namedValues=NamedValues(("interface", 0), ("dstMacAddress", 1), ("srcMacAddress", 2), ("ethernetPid", 3), ("dstLlcSap", 4), ("srcLlcSap", 5)))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802Fields.setStatus('current')
if mibBuilder.loadTexts: cTapStream802Fields.setDescription('This object displays what attributes must be tested to identify traffic which requires interception. The packet matches if all flagged fields match. interface: indicates that traffic on the stated interface is to be intercepted dstMacAddress: indicates that traffic destined to a given address should be intercepted srcMacAddress: indicates that traffic sourced from a given address should be intercepted ethernetPid: indicates that traffic with a stated Ethernet Protocol Identifier should be intercepted dstLlcSap: indicates that traffic with an certain 802.2 LLC Destination SAP should be intercepted srcLlcSap: indicates that traffic with an certain 802.2 LLC Source SAP should be intercepted At least one of the bits has to be set in order to activate an entry. If the bit is not on, the corresponding MIB object value has no effect, and need not be specified when creating the entry.')
cTapStream802Interface = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(ValueRangeConstraint(-1, -1), ValueRangeConstraint(0, 0), ValueRangeConstraint(1, 2147483647), ))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802Interface.setReference('RFC 1493')
if mibBuilder.loadTexts: cTapStream802Interface.setStatus('current')
if mibBuilder.loadTexts: cTapStream802Interface.setDescription('The ifIndex value of the interface over which traffic to be intercepted is received or transmitted. The interface may be physical or virtual. If this is the only parameter specified, and it is other than -1 or 0, all traffic on the selected interface will be chosen. If the value is zero, matching traffic may be received or transmitted on any interface. Additional selection parameters must be selected to limit the scope of traffic intercepted. This is most useful on non-routing platforms or on intercepts placed elsewhere than a subscriber interface. If the value is -1, one or both of cTapStream802DestinationAddress and cTapStream802SourceAddress must be specified. Matching traffic on the interface pointed to by the dot1dTpFdbPort values associated with those values is intercepted, whichever is specified. If dot1dTpFdbPort changes, either by operator action or by protocol events, the interface will change with it. This is primarily intended for use on subscriber interfaces and other places where routing is guaranteed to be symmetrical. In both of these cases, it is possible to have the same packet selected for intersection on both its ingress and egress interface. Nonetheless, only one instance of the packet is sent to the Mediation Device. This value must be set when creating a stream entry, either to select an interface, to select all interfaces, or to select the interface that bridging learns. Some platforms may not implement the entire range of options.')
cTapStream802DestinationAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 4), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802DestinationAddress.setStatus('current')
if mibBuilder.loadTexts: cTapStream802DestinationAddress.setDescription('The Destination address used in packet selection.')
cTapStream802SourceAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 5), MacAddress()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802SourceAddress.setStatus('current')
if mibBuilder.loadTexts: cTapStream802SourceAddress.setDescription('The Source Address used in packet selection.')
cTapStream802EthernetPid = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 6), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802EthernetPid.setStatus('current')
if mibBuilder.loadTexts: cTapStream802EthernetPid.setDescription('The value of the Ethernet Protocol Identifier, which may be found on Ethernet traffic or IEEE 802.2 SNAP traffic.')
cTapStream802DestinationLlcSap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802DestinationLlcSap.setStatus('current')
if mibBuilder.loadTexts: cTapStream802DestinationLlcSap.setDescription('The value of the IEEE 802.2 Destination SAP.')
cTapStream802SourceLlcSap = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802SourceLlcSap.setStatus('current')
if mibBuilder.loadTexts: cTapStream802SourceLlcSap.setDescription('The value of the IEEE 802.2 Source SAP.')
cTapStream802InterceptEnable = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 9), TruthValue().clone('true')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802InterceptEnable.setStatus('current')
if mibBuilder.loadTexts: cTapStream802InterceptEnable.setDescription("If 'true', the tap enables interception of matching traffic. If cTapStreamCapabilities flag tapEnable is zero, this may not be set to 'false'.")
cTapStream802InterceptedPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapStream802InterceptedPackets.setStatus('current')
if mibBuilder.loadTexts: cTapStream802InterceptedPackets.setDescription('The number of packets matching this data stream specification that have been intercepted.')
cTapStream802InterceptDrops = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapStream802InterceptDrops.setStatus('current')
if mibBuilder.loadTexts: cTapStream802InterceptDrops.setDescription('The number of packets matching this data stream specification that, having been intercepted, were dropped in the lawful intercept process.')
cTapStream802Status = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 2, 3, 1, 12), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: cTapStream802Status.setStatus('current')
if mibBuilder.loadTexts: cTapStream802Status.setDescription("The status of this conceptual row. This object manages creation, modification, and deletion of rows in this table. cTapStream802InterceptEnable can be modified any time even the value of this entry rowStatus object is active. When other rows must be changed, cTapStream802Status must be first set to 'notInService'.")
cTapDebugTable = MibTable((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 3, 1), )
if mibBuilder.loadTexts: cTapDebugTable.setStatus('current')
if mibBuilder.loadTexts: cTapDebugTable.setDescription('A table that contains Lawful Intercept debug information available on this device. This table is used to map an error code to a text message for further information.')
cTapDebugEntry = MibTableRow((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 3, 1, 1), ).setIndexNames((0, "CISCO-TAP-MIB", "cTapDebugIndex"))
if mibBuilder.loadTexts: cTapDebugEntry.setStatus('current')
if mibBuilder.loadTexts: cTapDebugEntry.setDescription('A list of the debug messages.')
cTapDebugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 3, 1, 1, 1), Unsigned32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: cTapDebugIndex.setStatus('current')
if mibBuilder.loadTexts: cTapDebugIndex.setDescription('Indicates an error code.')
cTapDebugMessage = MibTableColumn((1, 3, 6, 1, 4, 1, 9, 9, 252, 1, 3, 1, 1, 2), SnmpAdminString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: cTapDebugMessage.setStatus('current')
if mibBuilder.loadTexts: cTapDebugMessage.setDescription('A text string contains the description of an error code.')
cTapMIBActive = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 252, 0, 1)).setObjects(("CISCO-TAP-MIB", "cTapStream802Status"))
if mibBuilder.loadTexts: cTapMIBActive.setStatus('current')
if mibBuilder.loadTexts: cTapMIBActive.setDescription('This Notification is sent when an intercepting router or switch is first capable of intercepting a packet corresponding to a configured data stream. If the configured data stream is an IP one, the value of the corresponding cTapStreamIpStatus is included in this notification. If the configured data stream is an IEEE 802 one, the value of the corresponding cTapStream802Status is included in this notification. This notification may be generated in conjunction with the intercept application, which is designed to expect the notification to be sent as reliably as possible, e.g., through the use of a finite number of retransmissions until acknowledged, as and when such mechanisms are available; for example, with SNMPv3, this would be an InformRequest. Filter installation can take a long period of time, during which call progress may be delayed.')
cTapMediationTimedOut = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 252, 0, 2)).setObjects(("CISCO-TAP-MIB", "cTapMediationStatus"))
if mibBuilder.loadTexts: cTapMediationTimedOut.setStatus('current')
if mibBuilder.loadTexts: cTapMediationTimedOut.setDescription('When an intercept is autonomously removed by an intercepting device, such as due to the time specified in cTapMediationTimeout arriving, the device notifies the manager of the action.')
cTapMediationDebug = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 252, 0, 3)).setObjects(("CISCO-TAP-MIB", "cTapMediationContentId"), ("CISCO-TAP-MIB", "cTapDebugIndex"))
if mibBuilder.loadTexts: cTapMediationDebug.setStatus('current')
if mibBuilder.loadTexts: cTapMediationDebug.setDescription('When there is intervention needed due to some events related to entries configured in cTapMediationTable, the device notifies the manager of the event. This notification may be generated in conjunction with the intercept application, which is designed to expect the notification to be sent as reliably as possible, e.g., through the use of a finite number of retransmissions until acknowledged, as and when such mechanisms are available; for example, with SNMPv3, this would be an InformRequest.')
cTapStreamIpDebug = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 252, 0, 4)).setObjects(("CISCO-TAP-MIB", "cTapMediationContentId"), ("CISCO-TAP-MIB", "cTapStreamIpIndex"), ("CISCO-TAP-MIB", "cTapDebugIndex"))
if mibBuilder.loadTexts: cTapStreamIpDebug.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpDebug.setDescription('When there is intervention needed due to some events related to entries configured in cTapStreamIpTable, the device notifies the manager of the event. This notification may be generated in conjunction with the intercept application, which is designed to expect the notification to be sent as reliably as possible, e.g., through the use of a finite number of retransmissions until acknowledged, as and when such mechanisms are available; for example, with SNMPv3, this would be an InformRequest.')
cTapStream802Debug = NotificationType((1, 3, 6, 1, 4, 1, 9, 9, 252, 0, 5)).setObjects(("CISCO-TAP-MIB", "cTapMediationContentId"), ("CISCO-TAP-MIB", "cTapStream802Index"), ("CISCO-TAP-MIB", "cTapDebugIndex"))
if mibBuilder.loadTexts: cTapStream802Debug.setStatus('current')
if mibBuilder.loadTexts: cTapStream802Debug.setDescription('When there is intervention needed due to some events related to entries configured in cTapStream802Table, the device notifies the manager of the event. This notification may be generated in conjunction with the intercept application, which is designed to expect the notification to be sent as reliably as possible, e.g., through the use of a finite number of retransmissions until acknowledged, as and when such mechanisms are available; for example, with SNMPv3, this would be an InformRequest.')
cTapMIBCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 1))
cTapMIBGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2))
cTapMIBCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 1, 1)).setObjects(("CISCO-TAP-MIB", "cTapMediationComplianceGroup"), ("CISCO-TAP-MIB", "cTapStreamComplianceGroup"), ("CISCO-TAP-MIB", "cTapMediationCpbComplianceGroup"), ("CISCO-TAP-MIB", "cTapNotificationGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapMIBCompliance = cTapMIBCompliance.setStatus('current')
if mibBuilder.loadTexts: cTapMIBCompliance.setDescription('The compliance statement for entities which implement the Cisco Intercept MIB')
cTapMediationComplianceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2, 1)).setObjects(("CISCO-TAP-MIB", "cTapMediationNewIndex"), ("CISCO-TAP-MIB", "cTapMediationDestAddressType"), ("CISCO-TAP-MIB", "cTapMediationDestAddress"), ("CISCO-TAP-MIB", "cTapMediationDestPort"), ("CISCO-TAP-MIB", "cTapMediationSrcInterface"), ("CISCO-TAP-MIB", "cTapMediationRtcpPort"), ("CISCO-TAP-MIB", "cTapMediationDscp"), ("CISCO-TAP-MIB", "cTapMediationDataType"), ("CISCO-TAP-MIB", "cTapMediationRetransmitType"), ("CISCO-TAP-MIB", "cTapMediationTimeout"), ("CISCO-TAP-MIB", "cTapMediationTransport"), ("CISCO-TAP-MIB", "cTapMediationNotificationEnable"), ("CISCO-TAP-MIB", "cTapMediationStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapMediationComplianceGroup = cTapMediationComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: cTapMediationComplianceGroup.setDescription('These objects are necessary for description of the data streams directed to a Mediation Device.')
cTapStreamComplianceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2, 2)).setObjects(("CISCO-TAP-MIB", "cTapStreamCapabilities"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapStreamComplianceGroup = cTapStreamComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: cTapStreamComplianceGroup.setDescription('These objects are necessary for a description of the packets to select for interception.')
cTapStreamIpComplianceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2, 3)).setObjects(("CISCO-TAP-MIB", "cTapStreamIpInterface"), ("CISCO-TAP-MIB", "cTapStreamIpAddrType"), ("CISCO-TAP-MIB", "cTapStreamIpDestinationAddress"), ("CISCO-TAP-MIB", "cTapStreamIpDestinationLength"), ("CISCO-TAP-MIB", "cTapStreamIpSourceAddress"), ("CISCO-TAP-MIB", "cTapStreamIpSourceLength"), ("CISCO-TAP-MIB", "cTapStreamIpTosByte"), ("CISCO-TAP-MIB", "cTapStreamIpTosByteMask"), ("CISCO-TAP-MIB", "cTapStreamIpFlowId"), ("CISCO-TAP-MIB", "cTapStreamIpProtocol"), ("CISCO-TAP-MIB", "cTapStreamIpDestL4PortMin"), ("CISCO-TAP-MIB", "cTapStreamIpDestL4PortMax"), ("CISCO-TAP-MIB", "cTapStreamIpSourceL4PortMin"), ("CISCO-TAP-MIB", "cTapStreamIpSourceL4PortMax"), ("CISCO-TAP-MIB", "cTapStreamIpInterceptEnable"), ("CISCO-TAP-MIB", "cTapStreamIpInterceptedPackets"), ("CISCO-TAP-MIB", "cTapStreamIpInterceptDrops"), ("CISCO-TAP-MIB", "cTapStreamIpStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapStreamIpComplianceGroup = cTapStreamIpComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: cTapStreamIpComplianceGroup.setDescription('These objects are necessary for a description of IPv4 and IPv6 packets to select for interception.')
cTapStream802ComplianceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2, 4)).setObjects(("CISCO-TAP-MIB", "cTapStream802Fields"), ("CISCO-TAP-MIB", "cTapStream802Interface"), ("CISCO-TAP-MIB", "cTapStream802DestinationAddress"), ("CISCO-TAP-MIB", "cTapStream802SourceAddress"), ("CISCO-TAP-MIB", "cTapStream802EthernetPid"), ("CISCO-TAP-MIB", "cTapStream802SourceLlcSap"), ("CISCO-TAP-MIB", "cTapStream802DestinationLlcSap"), ("CISCO-TAP-MIB", "cTapStream802InterceptEnable"), ("CISCO-TAP-MIB", "cTapStream802InterceptedPackets"), ("CISCO-TAP-MIB", "cTapStream802InterceptDrops"), ("CISCO-TAP-MIB", "cTapStream802Status"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapStream802ComplianceGroup = cTapStream802ComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: cTapStream802ComplianceGroup.setDescription('These objects are necessary for a description of IEEE 802 packets to select for interception.')
cTapNotificationGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2, 5)).setObjects(("CISCO-TAP-MIB", "cTapMIBActive"), ("CISCO-TAP-MIB", "cTapMediationTimedOut"), ("CISCO-TAP-MIB", "cTapMediationDebug"), ("CISCO-TAP-MIB", "cTapStreamIpDebug"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapNotificationGroup = cTapNotificationGroup.setStatus('current')
if mibBuilder.loadTexts: cTapNotificationGroup.setDescription('These notifications are used to present status from the intercepting device to the Mediation Device.')
cTapMediationCpbComplianceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2, 6)).setObjects(("CISCO-TAP-MIB", "cTapMediationCapabilities"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapMediationCpbComplianceGroup = cTapMediationCpbComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: cTapMediationCpbComplianceGroup.setDescription('These objects are necessary for a description of the mediation device to select for Lawful Intercept.')
cTapDebugComplianceGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 9, 9, 252, 2, 2, 7)).setObjects(("CISCO-TAP-MIB", "cTapDebugMessage"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    cTapDebugComplianceGroup = cTapDebugComplianceGroup.setStatus('current')
if mibBuilder.loadTexts: cTapDebugComplianceGroup.setDescription('These objects are necessary for debug information.')
mibBuilder.exportSymbols("CISCO-TAP-MIB", cTapStreamIpTosByteMask=cTapStreamIpTosByteMask, cTapStreamIpIndex=cTapStreamIpIndex, cTapStreamIpAddrType=cTapStreamIpAddrType, cTapStream802Status=cTapStream802Status, cTapStreamIpComplianceGroup=cTapStreamIpComplianceGroup, cTapStream802DestinationAddress=cTapStream802DestinationAddress, cTapMediationNotificationEnable=cTapMediationNotificationEnable, cTapStream802InterceptedPackets=cTapStream802InterceptedPackets, cTapStream802SourceAddress=cTapStream802SourceAddress, cTapDebugTable=cTapDebugTable, cTapMediationDestPort=cTapMediationDestPort, cTapStreamGroup=cTapStreamGroup, cTapStream802SourceLlcSap=cTapStream802SourceLlcSap, cTapMediationDataType=cTapMediationDataType, cTapMIBActive=cTapMIBActive, cTapStreamIpInterface=cTapStreamIpInterface, cTapMediationDestAddressType=cTapMediationDestAddressType, cTapStream802ComplianceGroup=cTapStream802ComplianceGroup, cTapStream802Fields=cTapStream802Fields, cTapStreamIpProtocol=cTapStreamIpProtocol, cTapStreamIpTable=cTapStreamIpTable, cTapStreamIpDestL4PortMax=cTapStreamIpDestL4PortMax, cTapMIBConformance=cTapMIBConformance, cTapMediationCapabilities=cTapMediationCapabilities, cTapStreamIpEntry=cTapStreamIpEntry, cTapMediationRtcpPort=cTapMediationRtcpPort, cTapStream802Index=cTapStream802Index, cTapStream802Table=cTapStream802Table, cTapMediationEntry=cTapMediationEntry, cTapDebugMessage=cTapDebugMessage, cTapMIBNotifications=cTapMIBNotifications, cTapStream802DestinationLlcSap=cTapStream802DestinationLlcSap, cTapStreamIpInterceptDrops=cTapStreamIpInterceptDrops, cTapMIBObjects=cTapMIBObjects, cTapMediationContentId=cTapMediationContentId, cTapMediationRetransmitType=cTapMediationRetransmitType, cTapStreamIpSourceLength=cTapStreamIpSourceLength, cTapDebugEntry=cTapDebugEntry, Dscp=Dscp, cTapMediationTransport=cTapMediationTransport, cTapMediationNewIndex=cTapMediationNewIndex, cTapStream802Entry=cTapStream802Entry, cTapMIBGroups=cTapMIBGroups, cTapMediationDscp=cTapMediationDscp, cTapStreamIpDestinationLength=cTapStreamIpDestinationLength, cTapStreamIpDestL4PortMin=cTapStreamIpDestL4PortMin, cTapMediationDestAddress=cTapMediationDestAddress, cTapNotificationGroup=cTapNotificationGroup, cTapMediationStatus=cTapMediationStatus, cTapStreamComplianceGroup=cTapStreamComplianceGroup, cTapDebugIndex=cTapDebugIndex, cTapStreamIpInterceptEnable=cTapStreamIpInterceptEnable, cTapMIBCompliance=cTapMIBCompliance, cTapStreamIpStatus=cTapStreamIpStatus, cTapMediationTable=cTapMediationTable, cTapMIBCompliances=cTapMIBCompliances, cTapStreamIpFlowId=cTapStreamIpFlowId, cTapMediationTimedOut=cTapMediationTimedOut, cTapStream802Debug=cTapStream802Debug, cTapStream802EthernetPid=cTapStream802EthernetPid, PYSNMP_MODULE_ID=cTapMIB, cTapMediationSrcInterface=cTapMediationSrcInterface, cTapStream802InterceptDrops=cTapStream802InterceptDrops, cTapMediationGroup=cTapMediationGroup, cTapStreamIpSourceL4PortMax=cTapStreamIpSourceL4PortMax, cTapStreamIpDestinationAddress=cTapStreamIpDestinationAddress, cTapStream802InterceptEnable=cTapStream802InterceptEnable, cTapMediationDebug=cTapMediationDebug, cTapStreamIpTosByte=cTapStreamIpTosByte, cTapStreamIpInterceptedPackets=cTapStreamIpInterceptedPackets, cTapMediationComplianceGroup=cTapMediationComplianceGroup, cTapMIB=cTapMIB, cTapMediationTimeout=cTapMediationTimeout, cTapDebugComplianceGroup=cTapDebugComplianceGroup, cTapDebugGroup=cTapDebugGroup, cTapStreamIpDebug=cTapStreamIpDebug, cTapStreamIpSourceL4PortMin=cTapStreamIpSourceL4PortMin, cTapStreamCapabilities=cTapStreamCapabilities, cTapStreamIpSourceAddress=cTapStreamIpSourceAddress, cTapMediationCpbComplianceGroup=cTapMediationCpbComplianceGroup, cTapStream802Interface=cTapStream802Interface)

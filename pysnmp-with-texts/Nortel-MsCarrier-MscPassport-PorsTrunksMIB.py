#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-PorsTrunksMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-PorsTrunksMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:31:03 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, ObjectIdentifier, Integer = mibBuilder.importSymbols("ASN1", "OctetString", "ObjectIdentifier", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueSizeConstraint, ValueRangeConstraint, ConstraintsIntersection = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsIntersection")
RowPointer, RowStatus, StorageType, Unsigned32, Integer32, DisplayString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "RowPointer", "RowStatus", "StorageType", "Unsigned32", "Integer32", "DisplayString")
NonReplicated, AsciiString = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "NonReplicated", "AsciiString")
mscTrkIndex, mscTrk = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex", "mscTrk")
mscPassportMIBs, = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Bits, Gauge32, TimeTicks, ModuleIdentity, ObjectIdentity, IpAddress, MibIdentifier, Counter32, Unsigned32, Counter64, Integer32, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Bits", "Gauge32", "TimeTicks", "ModuleIdentity", "ObjectIdentity", "IpAddress", "MibIdentifier", "Counter32", "Unsigned32", "Counter64", "Integer32", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
porsTrunksMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39))
mscTrkPa = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4))
mscTrkPaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 1), )
if mibBuilder.loadTexts: mscTrkPaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaRowStatusTable.setDescription('This entry controls the addition and deletion of mscTrkPa components.')
mscTrkPaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"))
if mibBuilder.loadTexts: mscTrkPaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaRowStatusEntry.setDescription('A single entry in the table represents a single mscTrkPa component.')
mscTrkPaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTrkPa components. These components can be added and deleted.')
mscTrkPaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTrkPaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaStorageType.setDescription('This variable represents the storage type value for the mscTrkPa tables.')
mscTrkPaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscTrkPaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaIndex.setDescription('This variable represents the index for the mscTrkPa tables.')
mscTrkPaProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10), )
if mibBuilder.loadTexts: mscTrkPaProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaProvTable.setDescription('This group contains all provisionable attributes relevant to path oriented traffic on a trunk. These attributes provide the maximum number of Logical Channels that are permitted under a Trunk/n and the maximum total bandwidth they are allowed to occupy as a percentage of the outgoing trunk bandwidth.')
mscTrkPaProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"))
if mibBuilder.loadTexts: mscTrkPaProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaProvEntry.setDescription('An entry in the mscTrkPaProvTable.')
mscTrkPaMaxLc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1, 1), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65435)).clone(512)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaMaxLc.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaMaxLc.setDescription('This attribute indicates the number of Logical Channels (LCh/n) supported on this trunk. This attribute is used to allocate memory on the trunk FP for the PORS forwarding tables.Unless running in mapped mode on ATM hardware, the PathAdmin will add 100 channels to maxLc to reduce the chances of allocation clashes. However, you should never see more than maxLc channels in use for any extended period of time. On ATM hardware in mapped mode the PathAdmin will only add 10 channels to maxLc to permit more efficient use of the available VCC space. The PathAdmin may not be able to honor a request for maxLc channels. This will happen when the neighbor PathAdmin asks for less channels than this PathAdmin. To resolve the conflict the PathAdmin will always pick the minimum of the two maxLc values. This minimum value is called the negotiatedMaxLc and can be viewed as an operational parameter of the PathAdmin. Note that in mapped mode on ATM hardware, the value of this attribute provides an upper bound to the number of VCCs that this Trunk/n PathAdmin can occupy. It is not a guarantee that maxLc VCCs will be available to this PathAdmin because the VCC space is a shared resource on the card or port.')
mscTrkPaMaxReservedBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 100)).clone(50)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaMaxReservedBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaMaxReservedBwOut.setDescription('This attribute controls the percentage of trunk bandwidth which may be reserved by outgoing path oriented traffic on the trunk. The sum of requiredBandwidth attributes for all paths on this trunk must not exceed this attribute. Setting this attribute to zero (0) prevents paths from being established on this trunk. The limit of reserved bandwidth for incoming path oriented traffic is set using the same attribute on the trunk component on the other end of the trunk. If this attribute is set to 100% connectionless traffic is given a minimum of 1Kbit per second for administrative traffic. This attribute may now be changed without the trunk being restaging. If the value is decreased calls may be bumped as necessary to free up bandwdith. Increasing the value will have no impact on existing calls and new calls will be able to use the new bandwidth.')
mscTrkPaTrunkSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaTrunkSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaTrunkSecurity.setDescription("This attribute indicates the security level of the trunk. Zero(0) represents the most secure trunk and seven(7) represents the least secure. The path's minimum security requirement is indicated by the Plc requiredSecurity attribute, with values identical in range and meaning to this attribute. PORS ensures that the route selected does not contain a trunk whose PathAdmin trunkSecurity attribute is numerically greater than the path's requiredSecurity.")
mscTrkPaSupportedTrafficTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1).clone(hexValue="f8")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaSupportedTrafficTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaSupportedTrafficTypes.setDescription('This attribute indicates the type of traffic that can be transmitted on the trunk. There are eight(8) possible traffic types, and the trunk can transmit all of them if desired. The voice, data and video traffic types are defined, and five(5) other traffic types can be defined by the network administration. This attribute is used in the route selection process to limit the route to trunks that support the traffic type carried by the path. The requiredTrafficType attribute of the PLC indicates the type of traffic carried on the path. Description of bits: voice(0) data(1) video(2) trafficType1(3) trafficType2(4) trafficType3(5) trafficType4(6) trafficType5(7)')
mscTrkPaTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("terrestrial", 0), ("satellite", 1), ("trunkType1", 2), ("trunkType2", 3), ("trunkType3", 4), ("trunkType4", 5), ("trunkType5", 6), ("trunkType6", 7))).clone('terrestrial')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaTrunkType.setDescription('This attribute lists the type of the trunk. There can be up to eight(8) types of trunks. The terrestrial and satellite trunk types have been defined, leaving six(6) remaining types that can be defined by the network administration. The set of allowed trunk types for a path is indicated in the permittedTrunkType attribute of the PLC. When selecting a route, PORS only chooses trunks whose PathAdmin trunkType are in the permittedTrunkTypes set of the path.')
mscTrkPaCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaCustomerParameter.setDescription('This attribute indicates the customer defined parameter for the trunk. Its value, a number from zero(0) to seven(7), is chosen by a network administration to have a meaning specific to their network, thus allowing them to customize the use of their trunks. A complementary PLC attribute, requiredCustomerParameter, also has a value from zero(0) to seven(7). The Route Selector does not consider trunks whose PathAdmin customerParameter is greater than the requiredCustomerParameter of the path.')
mscTrkPaTrunkCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255)).clone(128)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscTrkPaTrunkCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaTrunkCost.setDescription('This attribute is the cost metric for the trunk. This value is assigned by the network administration to represent the network cost of using this trunk. It can be related to distance, speed, dollars, or any other factor that could be taken into consideration. If the trunkAttributeToMinimize is set to trunkCost, PORS finds a route with the smallest sum of the PathAdmin trunkCost attribute over all trunks. The trunk cost can be increased or decreased without disrupting the service to the link. If it is increased and the PORS optimization feature is enabled calls will move off this link to lower cost links when possible. If the cost is decreased new calls will be attracted to this link.')
mscTrkPaOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11), )
if mibBuilder.loadTexts: mscTrkPaOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaOperTable.setDescription('This group contains all operational attributes relevant to path oriented and connectionless bandwidth utilization and path activity on a trunk.')
mscTrkPaOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"))
if mibBuilder.loadTexts: mscTrkPaOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaOperEntry.setDescription('An entry in the mscTrkPaOperTable.')
mscTrkPaState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 1), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(1, 80))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaState.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaState.setDescription('This attribute gives the operational state of the PathAdmin component. The PathAdmin may be up, down, goingDown, staging or downWaitingRestage.')
mscTrkPaUsedLc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaUsedLc.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaUsedLc.setDescription('This attribute gives the total number of Logical Channels currently busy on the trunk. When this number reaches maxLc, no more paths are allowed to instantiate through this trunk. Note that it is possible for usedLc to be less than maxLc but for there to be no currently free LogicalChannels. This is because a LogicalChannel can be in one of several intermediate states between free and busy.')
mscTrkPaNegotiatedMaxLc = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedMaxLc.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedMaxLc.setDescription("This attribute gives the actual value of maxLc that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's maxLc provisionable attributes the smaller of the two is chosen on both sides. This attribute reflects the minimum of these two maxLc's.")
mscTrkPaMaxReservableBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaMaxReservableBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaMaxReservableBwOut.setDescription("This attribute gives the total bandwidth that this PathAdmin is allowed to reserve. This number is computed by multiplying the parent trunk's measuredSpeedToIf attribute by the maxReservedBwOut provisionable attribute of this PathAdmin.")
mscTrkPaOverReservedBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaOverReservedBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaOverReservedBwOut.setDescription('When bumping is required to free up enough bandwidth for a new path there exists a short period of time when both the new path and the soon to be bumped path are occupying the same bandwidth. This means that the total amount of reserved bandwidth will exceed maxReservableBwOut. When this happens the unreservedBwOut attribute will be 0 and the overReservedBwOut attribute will be non- zero to indicate by how much we are currently overcommitted. This value should quickly drop back to zero as the bumping starts to clear the lower holdingPriority calls.')
mscTrkPaUnreservedBwOut = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaUnreservedBwOut.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaUnreservedBwOut.setDescription('This attribute gives the total of amount of bandwidth that is still available for reservation by new connections. When this number reaches 0 the PathAdmin will no longer admit new connections to the trunk. This number represents available bandwidth in the outward going direction. To determine the inward available bandwidth you must query the PathAdmin at the other end of this Trunk.')
mscTrkPaClashCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaClashCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaClashCount.setDescription('This attribute gives the total number of path setup requests that resulted in an LCh/n or Vcc/x.y clash. A large value for this number is an indicator of poor performance by the PathAdmin in its allocation of LCh/n or Vcc/x.y components. In general the channels will be allocated in opposite orders at each end of the Trunk but this may not always be the case. Note that as the PathAdmin runs out of LCh/n or Vcc/x.y components the number of clashes will increase.')
mscTrkPaNegotiatedSupportedTrafficTypes = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 9), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedSupportedTrafficTypes.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedSupportedTrafficTypes.setDescription("This attribute gives the actual value of supportedTrafficTypes that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's supportedTrafficTypes provisionable attributes the union of the two is chosen on both sides. This attribute reflects the union of these two supportedTrafficTypes 's. It is this union that is advertised to all other nodes in the network and which is used for routing decisions. Description of bits: voice(0) data(1) video(2) trafficType1(3) trafficType2(4) trafficType3(5) trafficType4(6) trafficType5(7)")
mscTrkPaNegotiatedTrunkSecurity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkSecurity.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkSecurity.setDescription("This attribute gives the actual value of the trunkSecurity that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's trunkSecurity provisionable attributes the larger of the two is chosen on both sides. This attribute reflects the maximum of these two trunkSecurity's.")
mscTrkPaNegotiatedCustomerParameter = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 7))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedCustomerParameter.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedCustomerParameter.setDescription("This attribute gives the actual value of customerParameter that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's customerParameter provisionable attributes the larger of the two is chosen on both sides. This attribute reflects the maximum of these two customerParameter's.")
mscTrkPaNegotiatedTrunkCost = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkCost.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkCost.setDescription("This attribute gives the actual value of trunkCost that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's trunkCost provisionable attributes the larger of the two is chosen on both sides. This attribute reflects the maximum of these two trunkCost's.")
mscTrkPaNegotiatedAtmMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("multiplexing", 0), ("mapping", 1), ("notApplicable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedAtmMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedAtmMode.setDescription('This attribute gives the actual value of PathAdmin Atm mode that the PathAdmin has decided on after negotiation with the far end PathAdmin. This is only applicable to ATM cards since the mode on non ATM hardware is not specified. The multiplexing mode implies that all voice traffic will be multiplexed onto the Atm atmConnection Vcc and all data will be multiplexed onto the Trunk Atm atmConnection Vcc. The mapping mode implies that each unique logical channel will be allocated its own Vcc. The mode notApplicable implies either this is not ATM hardware or that no Atm subcomponent exists under this or the peer PathAdmin.')
mscTrkPaNegotiatedTrunkDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 14), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 1500))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkDelay.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkDelay.setDescription("This attribute gives the actual value of parent trunk's half round trip delay (propagation delay) that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmins the larger of the two propagation delays is chosen on both sides. This attribute reflects the maximum of these two propagation delays.")
mscTrkPaNegotiatedTrunkType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 11, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("terrestrial", 0), ("satellite", 1), ("trunkType1", 2), ("trunkType2", 3), ("trunkType3", 4), ("trunkType4", 5), ("trunkType5", 6), ("trunkType6", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaNegotiatedTrunkType.setDescription("This attribute gives the actual value of trunkType that the PathAdmin has decided on after negotiation with the far end PathAdmin. If there is disagreement between the two PathAdmin's trunkType provisionable attributes the provisioned values are used on both sides. That is, both sides maintain their provisioned value..")
mscTrkPaRbwTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 214), )
if mibBuilder.loadTexts: mscTrkPaRbwTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaRbwTable.setDescription('This attribute gives the total bandwidth reserved by paths for each of five (5) holding priorities. For example the bandwidth used by holdingPriority 0 paths is shown in the left most value.')
mscTrkPaRbwEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 214, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaRbwIndex"))
if mibBuilder.loadTexts: mscTrkPaRbwEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaRbwEntry.setDescription('An entry in the mscTrkPaRbwTable.')
mscTrkPaRbwIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 214, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: mscTrkPaRbwIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaRbwIndex.setDescription('This variable represents the index for the mscTrkPaRbwTable.')
mscTrkPaRbwValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 214, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaRbwValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaRbwValue.setDescription('This variable represents an individual value for the mscTrkPaRbwTable.')
mscTrkPaPacntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 215), )
if mibBuilder.loadTexts: mscTrkPaPacntTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPacntTable.setDescription('This attribute gives the total number of path instantiation attempts this trunk has processed since its creation. This number includes successful and unsuccessful attempts. This attribute provides five (5) values of this count, one for each path holdingPriority.')
mscTrkPaPacntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 215, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaPacntIndex"))
if mibBuilder.loadTexts: mscTrkPaPacntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPacntEntry.setDescription('An entry in the mscTrkPaPacntTable.')
mscTrkPaPacntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 215, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: mscTrkPaPacntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPacntIndex.setDescription('This variable represents the index for the mscTrkPaPacntTable.')
mscTrkPaPacntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 215, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaPacntValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPacntValue.setDescription('This variable represents an individual value for the mscTrkPaPacntTable.')
mscTrkPaPfcntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 216), )
if mibBuilder.loadTexts: mscTrkPaPfcntTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPfcntTable.setDescription('This attribute gives the total number of path instantiation failures that have happened since the creation of this trunk. This attribute provides five (5) values of this count, one for each path holdingPriority.')
mscTrkPaPfcntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 216, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaPfcntIndex"))
if mibBuilder.loadTexts: mscTrkPaPfcntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPfcntEntry.setDescription('An entry in the mscTrkPaPfcntTable.')
mscTrkPaPfcntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 216, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: mscTrkPaPfcntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPfcntIndex.setDescription('This variable represents the index for the mscTrkPaPfcntTable.')
mscTrkPaPfcntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 216, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaPfcntValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPfcntValue.setDescription('This variable represents an individual value for the mscTrkPaPfcntTable.')
mscTrkPaPccntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 217), )
if mibBuilder.loadTexts: mscTrkPaPccntTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPccntTable.setDescription('This attribute gives the total number of path clear requests this trunk has processed since its creation. This attribute provides five (5) values of this count, one for each path holdingPriority.')
mscTrkPaPccntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 217, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaPccntIndex"))
if mibBuilder.loadTexts: mscTrkPaPccntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPccntEntry.setDescription('An entry in the mscTrkPaPccntTable.')
mscTrkPaPccntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 217, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: mscTrkPaPccntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPccntIndex.setDescription('This variable represents the index for the mscTrkPaPccntTable.')
mscTrkPaPccntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 217, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaPccntValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPccntValue.setDescription('This variable represents an individual value for the mscTrkPaPccntTable.')
mscTrkPaPbcntTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 218), )
if mibBuilder.loadTexts: mscTrkPaPbcntTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPbcntTable.setDescription('This attribute gives the total number of path bumping requests this trunk has processed since its creation. This attribute provides 5 values of this count, one for each path holdingPriority.')
mscTrkPaPbcntEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 218, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkPaPbcntIndex"))
if mibBuilder.loadTexts: mscTrkPaPbcntEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPbcntEntry.setDescription('An entry in the mscTrkPaPbcntTable.')
mscTrkPaPbcntIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 218, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4)))
if mibBuilder.loadTexts: mscTrkPaPbcntIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPbcntIndex.setDescription('This variable represents the index for the mscTrkPaPbcntTable.')
mscTrkPaPbcntValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 4, 218, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkPaPbcntValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkPaPbcntValue.setDescription('This variable represents an individual value for the mscTrkPaPbcntTable.')
mscTrkLCh = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5))
mscTrkLChRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 1), )
if mibBuilder.loadTexts: mscTrkLChRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscTrkLCh components.')
mscTrkLChRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkLChIndex"))
if mibBuilder.loadTexts: mscTrkLChRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChRowStatusEntry.setDescription('A single entry in the table represents a single mscTrkLCh component.')
mscTrkLChRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscTrkLCh components. These components cannot be added nor deleted.')
mscTrkLChComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscTrkLChStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChStorageType.setDescription('This variable represents the storage type value for the mscTrkLCh tables.')
mscTrkLChIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)))
if mibBuilder.loadTexts: mscTrkLChIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChIndex.setDescription('This variable represents the index for the mscTrkLCh tables.')
mscTrkLChOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10), )
if mibBuilder.loadTexts: mscTrkLChOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChOperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains all operational attributes pertaining to the Logical Channel component owned by this trunk.')
mscTrkLChOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-TrunksMIB", "mscTrkIndex"), (0, "Nortel-MsCarrier-MscPassport-PorsTrunksMIB", "mscTrkLChIndex"))
if mibBuilder.loadTexts: mscTrkLChOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChOperEntry.setDescription('An entry in the mscTrkLChOperTable.')
mscTrkLChNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 2), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChNextHop.setDescription('The nextHop is the name of the component across the bus which is forwarding packets to us. Inversely the nextHop of our nextHop component is us. More precisely, LCh/n components point to each other across the bus via their nextHop attributes. In the case where the next hop is an application the nextHop attribute will indicate the component name of this application.')
mscTrkLChSetupPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChSetupPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChSetupPriority.setDescription("This attribute gives the priority at which a path is established. Zero (0) is the highest priority and four (4) is the lowest. When PORS establishes a path through the network, it uses the setupPriority attribute to determine its potential for bumping established paths to acquire their bandwidth. The holdingPriority, a complementary attribute of this component, indicates the priority a path maintains once it is established. A new path can bump an existing path if the new path's setupPriority is higher (or numerically less) than the existing path's holdingPriority.")
mscTrkLChHoldingPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChHoldingPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChHoldingPriority.setDescription("This attribute gives the priority that a path holds once it is established. Zero (0) is the highest priority and four (4) is the lowest. A path's holdingPriority determines its likelihood of being bumped by a new path to acquire its bandwidth. The setupPriority, a complementary attribute, indicates the priority of a path at establishment time. A new path can bump an existing path if the new path's setupPriority is higher (or numerically less) than the existing path's holdingPriority.")
mscTrkLChEmissionPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChEmissionPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChEmissionPriority.setDescription("This attribute indicates the urgency with which packets on the LCh's path are emitted by this trunk. The emissionPriority translates into the trunk's emission queue. Zero (0) indicates the highest emissionPriority, while three (3) indicates the lowest. Packets with a higher emissionPriority (or numerically less) are put on an emission queue which is serviced before a queue which accepts packets of a lower emissionPriority and hence experience smaller delays traversing congested trunks.")
mscTrkLChDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 3))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChDiscardPriority.setDescription('This attribute indicates the importance of the packets on the path. Zero (0) is used for paths carrying the most important traffic, and two (3) is used for paths carrying the least important traffic. In times of congestion, the discardPriority is used by packet forwarding on the trunk to determine which packets are discarded first to reduce the load. Packets with a higher discardPriority (or numerically less) are discarded after packets with a lower discardPriority (or numerically higher).')
mscTrkLChRequiredTxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChRequiredTxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChRequiredTxBandwidth.setDescription('This attribute gives the bandwidth (in bits per second units) reserved by this LCh/n for emitting packets on the trunk.')
mscTrkLChRequiredRxBandwidth = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChRequiredRxBandwidth.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChRequiredRxBandwidth.setDescription('This attribute gives the bandwidth (in bits per second units) reserved by this LCh/n for receiving packets on the trunk.')
mscTrkLChMode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("unknown", 0), ("hdlcFrmMux", 1), ("aal5FrmMux", 2), ("spoFrmMux", 3), ("spoFrmMap", 4), ("aal5FrmMap", 5), ("cellMap", 6)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChMode.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChMode.setDescription('This attribute gives the operational mode of the LogicalChannel component. It indicates what kind of transport is being performed on the packets in the channel. There are 7 possible values of this attribute as follows: unknown - not currently in busy state, type of forwarding not determined yet. hdlcFrmMux - frames are being multiplexed (multiple LCh/n on same port or channel) using HDLC encapsulation. aal5FrmMux - frames are being multiplexed (multiple LCh/n on same ATM VCC) using the AAL5 segmentation and recombination protocol. spoFrmMux - frames are being multiplexed (multiple LCh/n on same ATM VCC) using the Short Path Oriented segmentation and recombination protocol. This is a proprietary protocol which encapsulates voice frames into a single ATM cell unlike AAL5 which would require two cells to transport the 45 byte voice frames. aal5FrmMap - frames are being mapped (a single LCh/n per ATM VCC) using the AAL5 segmentation and recombination protocol. AAL5 mapped frames are forwarded by hardware in both directions and require no CPU intervention. spoFrmMap - frames are being mapped (a single LCh/n per ATM VCC) using the Short Path Oriented segmentation and recombination protocol. SPO mapped frames are forwarded by hardware in both directions and require no CPU intervention in all but one special case. In particular CPU is required only if frames are being forwarded to an LCh/n whose mode is spoFrmMux. cellMap - ATM cells are being relayed directly over the bus with no segmentation and recombination protocol. The segmentation and recombination is only done at transition points between frame based cards and ATM cell based cards so this hop represents a pure tandem cell hop, ATM card to ATM card. No CPU is required to process these cells.')
mscTrkLChMaximumTransmissionUnit = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChMaximumTransmissionUnit.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChMaximumTransmissionUnit.setDescription('This attribute gives the size of the largest frame this service will send. A value of 0 means that the Mtu is unknown. A value of 45 or less (but non zero) means that ATM single cell transport will be used wherever possible. Otherwise ATM AAL5 adaption layer transport will be required to handle all frames.')
mscTrkLChLocalConnection = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 60, 5, 10, 1, 11), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscTrkLChLocalConnection.setStatus('mandatory')
if mibBuilder.loadTexts: mscTrkLChLocalConnection.setDescription('The localConnection attribute specifies the name of the connection on the local interface. On ATM hardware this is in the form AtmIf/n Vcc/x.y. On non ATM hardware this attribute is empty.')
porsTrunksGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 1))
porsTrunksGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 1, 1))
porsTrunksGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 1, 1, 3))
porsTrunksGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 1, 1, 3, 2))
porsTrunksCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 3))
porsTrunksCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 3, 1))
porsTrunksCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 3, 1, 3))
porsTrunksCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 39, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-PorsTrunksMIB", porsTrunksCapabilitiesCA=porsTrunksCapabilitiesCA, mscTrkLChDiscardPriority=mscTrkLChDiscardPriority, mscTrkLChMaximumTransmissionUnit=mscTrkLChMaximumTransmissionUnit, mscTrkPaOverReservedBwOut=mscTrkPaOverReservedBwOut, mscTrkPaNegotiatedTrunkType=mscTrkPaNegotiatedTrunkType, porsTrunksCapabilitiesCA02=porsTrunksCapabilitiesCA02, mscTrkPaProvTable=mscTrkPaProvTable, mscTrkPaMaxReservableBwOut=mscTrkPaMaxReservableBwOut, mscTrkLChRowStatus=mscTrkLChRowStatus, mscTrkLChLocalConnection=mscTrkLChLocalConnection, mscTrkPaRbwEntry=mscTrkPaRbwEntry, mscTrkLChOperEntry=mscTrkLChOperEntry, mscTrkPa=mscTrkPa, mscTrkPaPccntTable=mscTrkPaPccntTable, mscTrkPaRowStatusEntry=mscTrkPaRowStatusEntry, porsTrunksGroupCA=porsTrunksGroupCA, mscTrkPaPbcntEntry=mscTrkPaPbcntEntry, mscTrkPaProvEntry=mscTrkPaProvEntry, mscTrkPaPfcntIndex=mscTrkPaPfcntIndex, mscTrkPaPbcntValue=mscTrkPaPbcntValue, mscTrkPaState=mscTrkPaState, mscTrkPaNegotiatedAtmMode=mscTrkPaNegotiatedAtmMode, mscTrkPaPacntIndex=mscTrkPaPacntIndex, mscTrkPaPfcntValue=mscTrkPaPfcntValue, porsTrunksCapabilitiesCA02A=porsTrunksCapabilitiesCA02A, mscTrkPaUnreservedBwOut=mscTrkPaUnreservedBwOut, mscTrkPaMaxReservedBwOut=mscTrkPaMaxReservedBwOut, mscTrkPaPccntValue=mscTrkPaPccntValue, mscTrkLChIndex=mscTrkLChIndex, mscTrkPaPacntValue=mscTrkPaPacntValue, mscTrkPaPfcntTable=mscTrkPaPfcntTable, mscTrkPaPccntIndex=mscTrkPaPccntIndex, mscTrkLChOperTable=mscTrkLChOperTable, mscTrkLChComponentName=mscTrkLChComponentName, mscTrkLCh=mscTrkLCh, mscTrkPaComponentName=mscTrkPaComponentName, mscTrkLChRowStatusTable=mscTrkLChRowStatusTable, mscTrkPaRbwTable=mscTrkPaRbwTable, mscTrkPaNegotiatedTrunkDelay=mscTrkPaNegotiatedTrunkDelay, mscTrkPaRbwValue=mscTrkPaRbwValue, mscTrkLChMode=mscTrkLChMode, mscTrkLChNextHop=mscTrkLChNextHop, mscTrkPaOperTable=mscTrkPaOperTable, mscTrkLChHoldingPriority=mscTrkLChHoldingPriority, mscTrkPaTrunkSecurity=mscTrkPaTrunkSecurity, mscTrkPaCustomerParameter=mscTrkPaCustomerParameter, mscTrkPaNegotiatedTrunkSecurity=mscTrkPaNegotiatedTrunkSecurity, mscTrkPaMaxLc=mscTrkPaMaxLc, mscTrkPaStorageType=mscTrkPaStorageType, mscTrkLChRequiredTxBandwidth=mscTrkLChRequiredTxBandwidth, mscTrkPaPbcntIndex=mscTrkPaPbcntIndex, mscTrkPaClashCount=mscTrkPaClashCount, mscTrkPaOperEntry=mscTrkPaOperEntry, mscTrkLChStorageType=mscTrkLChStorageType, mscTrkLChRowStatusEntry=mscTrkLChRowStatusEntry, mscTrkLChSetupPriority=mscTrkLChSetupPriority, mscTrkPaNegotiatedTrunkCost=mscTrkPaNegotiatedTrunkCost, mscTrkPaRbwIndex=mscTrkPaRbwIndex, mscTrkPaPacntTable=mscTrkPaPacntTable, mscTrkPaTrunkType=mscTrkPaTrunkType, mscTrkPaNegotiatedCustomerParameter=mscTrkPaNegotiatedCustomerParameter, mscTrkPaRowStatusTable=mscTrkPaRowStatusTable, porsTrunksGroupCA02=porsTrunksGroupCA02, mscTrkPaNegotiatedMaxLc=mscTrkPaNegotiatedMaxLc, mscTrkPaTrunkCost=mscTrkPaTrunkCost, mscTrkPaUsedLc=mscTrkPaUsedLc, mscTrkPaPccntEntry=mscTrkPaPccntEntry, mscTrkPaNegotiatedSupportedTrafficTypes=mscTrkPaNegotiatedSupportedTrafficTypes, mscTrkPaIndex=mscTrkPaIndex, porsTrunksGroupCA02A=porsTrunksGroupCA02A, mscTrkPaSupportedTrafficTypes=mscTrkPaSupportedTrafficTypes, mscTrkLChEmissionPriority=mscTrkLChEmissionPriority, mscTrkLChRequiredRxBandwidth=mscTrkLChRequiredRxBandwidth, mscTrkPaPfcntEntry=mscTrkPaPfcntEntry, mscTrkPaRowStatus=mscTrkPaRowStatus, porsTrunksMIB=porsTrunksMIB, mscTrkPaPbcntTable=mscTrkPaPbcntTable, porsTrunksGroup=porsTrunksGroup, porsTrunksCapabilities=porsTrunksCapabilities, mscTrkPaPacntEntry=mscTrkPaPacntEntry)

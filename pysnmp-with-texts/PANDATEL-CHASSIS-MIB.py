#
# PySNMP MIB module PANDATEL-CHASSIS-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/PANDATEL-CHASSIS-MIB
# Produced by pysmi-0.3.4 at Wed May  1 14:37:10 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
Integer, ObjectIdentifier, OctetString = mibBuilder.importSymbols("ASN1", "Integer", "ObjectIdentifier", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ValueRangeConstraint, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ValueRangeConstraint", "ConstraintsUnion")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Gauge32, NotificationType, MibIdentifier, NotificationType, Integer32, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, ModuleIdentity, enterprises, iso, ObjectIdentity, IpAddress, TimeTicks, Bits, Unsigned32, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Gauge32", "NotificationType", "MibIdentifier", "NotificationType", "Integer32", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "ModuleIdentity", "enterprises", "iso", "ObjectIdentity", "IpAddress", "TimeTicks", "Bits", "Unsigned32", "Counter32")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
pandatel = MibIdentifier((1, 3, 6, 1, 4, 1, 760))
mibs = MibIdentifier((1, 3, 6, 1, 4, 1, 760, 1))
chassis = MibIdentifier((1, 3, 6, 1, 4, 1, 760, 1, 20000))
chassisTypeID = MibScalar((1, 3, 6, 1, 4, 1, 760, 1, 20000, 1), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisTypeID.setStatus('mandatory')
if mibBuilder.loadTexts: chassisTypeID.setDescription('This may be an authoritative or well-known id that refers to the type of equipment that is being managed. If that is unknown, an (0.0) will also be correct.')
chassisComponents = MibScalar((1, 3, 6, 1, 4, 1, 760, 1, 20000, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("stand-alone", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisComponents.setStatus('mandatory')
if mibBuilder.loadTexts: chassisComponents.setDescription('The number of components the chassis consists of. If the managed unit is stand-alone, this object may return 0, but it can also return 1, if an entry in the component table is provided. This implementory decision must be made according to the specific device characteristics. In other words, this object indicates the number of entries in the component table.')
chassisDevices = MibScalar((1, 3, 6, 1, 4, 1, 760, 1, 20000, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisDevices.setStatus('mandatory')
if mibBuilder.loadTexts: chassisDevices.setDescription('The number of devices in the chassis. This is equivalent to the total amount of devices in all components. Its value will probably be at least one. In other words, this object indicates the number of entries in the device table.')
chassisSlots = MibScalar((1, 3, 6, 1, 4, 1, 760, 1, 20000, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("no-slots", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisSlots.setStatus('mandatory')
if mibBuilder.loadTexts: chassisSlots.setDescription('The number of slots in the chassis. This is equivalent to the total amount of slots in all components and to the maximum number of modules that the chassis can contain. Any virtual slot (addressed {comp,0}) in the slot table will increase the value of this object. If there are no physical or virtual slots, its value will be 0. In other words, this object indicates the number of entries in the slot table.')
chassisModules = MibScalar((1, 3, 6, 1, 4, 1, 760, 1, 20000, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisModules.setStatus('mandatory')
if mibBuilder.loadTexts: chassisModules.setDescription('The number of modules in the chassis. This is equivalent to the total amount of slots in all components that are occupied by a module. Any virtual module (addressed {comp,0}) in the slot table will increase the value of this object. If there are no physical or virtual slots, its value will be 0.')
chassisPorts = MibScalar((1, 3, 6, 1, 4, 1, 760, 1, 20000, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("no-ports", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: chassisPorts.setStatus('mandatory')
if mibBuilder.loadTexts: chassisPorts.setDescription("The number of ports in the chassis. This is equivalent to the total amount of ports on all modules, including virtual modules '0'. If there are no ports, its value will be 0. In other words, this object indicates the number of entries in the port table.")
chassisComponentTable = MibTable((1, 3, 6, 1, 4, 1, 760, 1, 20000, 10), )
if mibBuilder.loadTexts: chassisComponentTable.setStatus('optional')
if mibBuilder.loadTexts: chassisComponentTable.setDescription('The component table of the whole chassis, regardless of the particular component type. May be empty if this is a stand-alone unit.')
chassisDeviceTable = MibTable((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11), )
if mibBuilder.loadTexts: chassisDeviceTable.setStatus('mandatory')
if mibBuilder.loadTexts: chassisDeviceTable.setDescription('The device table of the whole chassis. Includes all functional devices.')
chassisSlotTable = MibTable((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12), )
if mibBuilder.loadTexts: chassisSlotTable.setStatus('optional')
if mibBuilder.loadTexts: chassisSlotTable.setDescription('The slot table of the whole chassis, regardless of the particular slot type. May be empty if there are no slots.')
chassisPortTable = MibTable((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13), )
if mibBuilder.loadTexts: chassisPortTable.setStatus('optional')
if mibBuilder.loadTexts: chassisPortTable.setDescription('The port table of the whole chassis, regardless of the particular port type. May be empty if there are no ports.')
chassisPowerSupplyTable = MibTable((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14), )
if mibBuilder.loadTexts: chassisPowerSupplyTable.setStatus('optional')
if mibBuilder.loadTexts: chassisPowerSupplyTable.setDescription('Table which contains information about all installed power supplies.')
compEntry = MibTableRow((1, 3, 6, 1, 4, 1, 760, 1, 20000, 10, 1), ).setIndexNames((0, "PANDATEL-CHASSIS-MIB", "compComp"))
if mibBuilder.loadTexts: compEntry.setStatus('mandatory')
if mibBuilder.loadTexts: compEntry.setDescription('One entry in the chassis component table. Each entry contains the description of one component.')
compComp = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("main", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: compComp.setStatus('mandatory')
if mibBuilder.loadTexts: compComp.setDescription('The index of this particular component in the chassis.')
compDesign = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("other", 1), ("rack", 2), ("device", 3), ("stack", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: compDesign.setStatus('mandatory')
if mibBuilder.loadTexts: compDesign.setDescription('The general design what this particular component is. A rack is an empty housing whose main purpose is to contain some slots for modules. A device is an active unit with own functionality, e.g. a repeater. It may also contain modules, but that is not its main purpose. A device may be identical with an entry in the device table, if the entry relates to one whole component.')
compTypeID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 10, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: compTypeID.setStatus('mandatory')
if mibBuilder.loadTexts: compTypeID.setDescription('This object identifies the type of this component. It will point to an authoritative or a well-known identifier that may relate to the product type, the product family it has been designed for or, if no other statement can be made, e.g. the type of media the component works with.')
compSlots = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 10, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: compSlots.setStatus('mandatory')
if mibBuilder.loadTexts: compSlots.setDescription('The number of slots this component provides for plugging in modules. This includes all used and unused physical slots, but not a virtual slot 0.')
compModules = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 10, 1, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: compModules.setStatus('mandatory')
if mibBuilder.loadTexts: compModules.setDescription("The number of modules that are contained within this component. This value may include a virtual 'module 0' that is realized on the component main board (see below).")
devcEntry = MibTableRow((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1), ).setIndexNames((0, "PANDATEL-CHASSIS-MIB", "devcComp"), (0, "PANDATEL-CHASSIS-MIB", "devcSlot"))
if mibBuilder.loadTexts: devcEntry.setStatus('mandatory')
if mibBuilder.loadTexts: devcEntry.setDescription('One entry in the chassis device table. Each entry contains the description of one functional device included in the chassis.')
devcComp = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("main", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcComp.setStatus('mandatory')
if mibBuilder.loadTexts: devcComp.setDescription('The index of the component which contains the first module that is part of this device. If this value is 0, the device is realized on a stand-alone unit.')
devcSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("main", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcSlot.setStatus('mandatory')
if mibBuilder.loadTexts: devcSlot.setDescription('The index of the slot relatively to its component which contains the first module that is part of this device. If the device is realized partially or mainly on the component main-board, a slot of 0 is adequate, especially if this component contains no slots.')
devcTypeID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcTypeID.setStatus('mandatory')
if mibBuilder.loadTexts: devcTypeID.setDescription('This object identifies the type of this device. It will point to the authoritative identifier that resides in the (1.3.6.1.4.1) subtree and relates to the type of the managed device.')
devcMgmtAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 4), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcMgmtAddress.setStatus('mandatory')
if mibBuilder.loadTexts: devcMgmtAddress.setDescription("This object returns the network address that must be used to access this device for management purposes. This can be the agent's network address, but it may be different e.g. if the device includes its own agent for management access.")
devcDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcDescr.setStatus('mandatory')
if mibBuilder.loadTexts: devcDescr.setDescription('A textual description of this device.')
devcModules = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcModules.setStatus('mandatory')
if mibBuilder.loadTexts: devcModules.setDescription("The number of modules that are part of this device. If the device is realized partially or mainly on the component main-board, a virtual 'module 0' entry in the slot table may increase this value.")
devcPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcPorts.setStatus('mandatory')
if mibBuilder.loadTexts: devcPorts.setDescription('The number of ports that are part of this device. This does not differentiate between several types of ports.')
devcLastChange = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 11, 1, 8), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: devcLastChange.setStatus('mandatory')
if mibBuilder.loadTexts: devcLastChange.setDescription('The value of SysUpTime in the moment when the last change occurred to the physical configuration of this device. When nothing changed since start-up, the value 0 shall be returned.')
slotEntry = MibTableRow((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1), ).setIndexNames((0, "PANDATEL-CHASSIS-MIB", "slotComp"), (0, "PANDATEL-CHASSIS-MIB", "slotSlot"))
if mibBuilder.loadTexts: slotEntry.setStatus('mandatory')
if mibBuilder.loadTexts: slotEntry.setDescription('One entry in the slot table.')
slotComp = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("main", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotComp.setStatus('mandatory')
if mibBuilder.loadTexts: slotComp.setDescription('The index of the component that contains this slot. If this value is 0, this is a slot on a stand-alone unit.')
slotSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("main", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotSlot.setStatus('mandatory')
if mibBuilder.loadTexts: slotSlot.setDescription('The index of this slot, relatively to the particular component. If this value is 0, this is a virtual entry for a functional module that is realized on a built-in main board. It is correct, but not mandatory, to provide such an entry for sake of completeness.')
slotOwnerDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1, 3), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotOwnerDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: slotOwnerDeviceID.setDescription('This object points to the device that owns this slot. It consists of an authoritative or a well-known id that refers to the type of the owner device, appended with its base address (Comp,Slot). In other words, this identifier refers to the corresponding entry in the chassisDeviceTable. If this slot currently does not belong to any device (e.g. because it is actually not used and will be assigned at run-time), the value will be (0.0).')
slotSlotTypeID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotSlotTypeID.setStatus('mandatory')
if mibBuilder.loadTexts: slotSlotTypeID.setDescription('This object points to an authoritative or a well-known id that refers to the type of this slot. This may point to the media the slot is realized with or to the product family of modules that can be plugged in here.')
slotModuleTypeID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotModuleTypeID.setStatus('mandatory')
if mibBuilder.loadTexts: slotModuleTypeID.setDescription('This object points to an authoritative or a well-known id that refers to the type of module that occupies this slot. If the slot is unused, then the id (0.0) will show that.')
slotModuleName = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotModuleName.setStatus('mandatory')
if mibBuilder.loadTexts: slotModuleName.setDescription('A short textual description of the module that occupies this slot.')
slotPorts = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 12, 1, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: slotPorts.setStatus('mandatory')
if mibBuilder.loadTexts: slotPorts.setDescription('The number of ports on this slot. This does not differentiate between several types of ports.')
portEntry = MibTableRow((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13, 1), ).setIndexNames((0, "PANDATEL-CHASSIS-MIB", "portComp"), (0, "PANDATEL-CHASSIS-MIB", "portSlot"), (0, "PANDATEL-CHASSIS-MIB", "portPort"))
if mibBuilder.loadTexts: portEntry.setStatus('mandatory')
if mibBuilder.loadTexts: portEntry.setDescription('One entry in the chassis port table.')
portComp = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portComp.setStatus('mandatory')
if mibBuilder.loadTexts: portComp.setDescription('The index of the component that contains this port. The component identified by a particular value of this index is the same one as identified by the same value of compIndex.')
portSlot = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("main", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portSlot.setStatus('mandatory')
if mibBuilder.loadTexts: portSlot.setDescription('The slot index of the module that contains this port. The module is identified by the index of the slot where it resides. A virtual slot 0 may refer to an internal module that is realized on the main board and occupies no slot.')
portPort = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPort.setStatus('mandatory')
if mibBuilder.loadTexts: portPort.setDescription('The index of this port, relatively to the particular module.')
portOwnerDeviceID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portOwnerDeviceID.setStatus('mandatory')
if mibBuilder.loadTexts: portOwnerDeviceID.setDescription('This object points to the device that owns this port. It consists of an authoritative or a well-known id that refers to the type of the owner device, appended with its base address (Comp,Slot). In other words, this identifier refers to the corresponding entry in the chassisDeviceTable. If this port currently does not belong to any device (e.g. because it is actually not used and will be assigned at run-time), the value will be (0.0).')
portFunctionalTypeID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13, 1, 5), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: portFunctionalTypeID.setStatus('mandatory')
if mibBuilder.loadTexts: portFunctionalTypeID.setDescription('An unambiguous id referring to the functional type of this port. This may be an authoritative or a well-known id that illustrates what is the purpose of this port. The range of possible port types depend on the individual managed device. For example, a port on a LAN can be a repeater port, a WAN-device port may be a local or a line port, or it may be a console port on a mgmt module.')
portPhysicalType = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 13, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 997, 998, 999))).clone(namedValues=NamedValues(("other", 1), ("single-fiber", 2), ("dual-fiber", 3), ("bnc", 4), ("dpc", 5), ("rj45", 7), ("ics", 8), ("mic", 9), ("db-9-f", 10), ("db-9-m", 11), ("db-15-f", 12), ("db-15-m", 13), ("db-25-f", 14), ("db-25-m", 15), ("db-37-f", 16), ("db-37-m", 17), ("winch-f", 18), ("winch-m", 19), ("mini-c", 20), ("minimicro", 21), ("escon", 22), ("e2000", 23), ("single-sc", 24), ("single-fc", 25), ("single-st", 26), ("dual-sc", 27), ("dual-fc", 28), ("dual-st", 29), ("single-sc-apc", 30), ("single-fc-apc", 31), ("dual-sc-apc", 32), ("dual-fc-apc", 33), ("single-lc", 34), ("single-lc-apc", 35), ("dual-lc", 36), ("dual-lc-apc", 37), ("mt-rj", 38), ("single-sc-45", 39), ("dual-sc-45", 40), ("unknown", 997), ("virtual", 998), ("not-installed", 999)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: portPhysicalType.setStatus('mandatory')
if mibBuilder.loadTexts: portPhysicalType.setDescription('The physical connector type of this port.')
psupplyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14, 1), ).setIndexNames((0, "PANDATEL-CHASSIS-MIB", "psupplyRack"), (0, "PANDATEL-CHASSIS-MIB", "psupplySlot"), (0, "PANDATEL-CHASSIS-MIB", "psupplyIndex"))
if mibBuilder.loadTexts: psupplyEntry.setStatus('mandatory')
if mibBuilder.loadTexts: psupplyEntry.setDescription('The index of the table.')
psupplyRack = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psupplyRack.setStatus('mandatory')
if mibBuilder.loadTexts: psupplyRack.setDescription('The index of the component that contains the power supply.')
psupplySlot = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0))).clone(namedValues=NamedValues(("main", 0)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psupplySlot.setStatus('mandatory')
if mibBuilder.loadTexts: psupplySlot.setDescription('The slot index of the module that contains this port. The module is identified by the index of the slot where it resides. A virtual slot 0 may refer to an internal module that is realized on the main board and occupies no slot.')
psupplyIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psupplyIndex.setStatus('mandatory')
if mibBuilder.loadTexts: psupplyIndex.setDescription('The index of the power supply corresponding to the component.')
psupplyTypeID = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14, 1, 4), ObjectIdentifier()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psupplyTypeID.setStatus('mandatory')
if mibBuilder.loadTexts: psupplyTypeID.setDescription('This object points to an authoritative or a well-known id that refers to the type of power supply that occupies this slot.')
psupplyDescr = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: psupplyDescr.setStatus('mandatory')
if mibBuilder.loadTexts: psupplyDescr.setDescription('A verbal description of the power supply. If there is no power supply installed in this slot, the power supplies that are suitable for this slot will be described.')
psupplyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 760, 1, 20000, 14, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 98, 99))).clone(namedValues=NamedValues(("other", 1), ("up", 2), ("down", 3), ("fail", 4), ("unknown", 98), ("not-present", 99)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: psupplyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: psupplyStatus.setDescription("This entry indicates the operational status of the power supply. The value 'up' means that the power supply works properly. The value 'fail' means that the power supply does not work correctly. The transitions between the values may cause traps.")
componentAdded = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,1)).setObjects(("PANDATEL-CHASSIS-MIB", "compTypeID"))
if mibBuilder.loadTexts: componentAdded.setDescription('This trap will be sent when a component is added to the managed chassis. The component index of the new component is sent along with this trap.')
if mibBuilder.loadTexts: componentAdded.setReference('PANDATEL-CHASSIS-MIB, ComponentAdded event notification.')
componentRemoved = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,2)).setObjects(("PANDATEL-CHASSIS-MIB", "compTypeID"))
if mibBuilder.loadTexts: componentRemoved.setDescription('This trap will be sent when a component is removed from the managed chassis. The component index of the removed component is sent along with this trap.')
if mibBuilder.loadTexts: componentRemoved.setReference('PANDATEL-CHASSIS-MIB, ComponentRemoved event notification.')
moduleAdded = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,3)).setObjects(("PANDATEL-CHASSIS-MIB", "slotModuleTypeID"))
if mibBuilder.loadTexts: moduleAdded.setDescription('This trap will be sent when a module is added. The component number and the index of the new module is sent along with this trap.')
if mibBuilder.loadTexts: moduleAdded.setReference('PANDATEL-CHASSIS-MIB, ModuleAdded event notification.')
moduleRemoved = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,4)).setObjects(("PANDATEL-CHASSIS-MIB", "slotModuleTypeID"))
if mibBuilder.loadTexts: moduleRemoved.setDescription('This trap will be sent when a module in one of the slots is removed. The component number and the index of the removed module is sent along with this trap.')
if mibBuilder.loadTexts: moduleRemoved.setReference('PANDATEL-CHASSIS-MIB, ModuleRemoved event notification.')
powerSupplyAdded = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,21)).setObjects(("PANDATEL-CHASSIS-MIB", "psupplyTypeID"))
if mibBuilder.loadTexts: powerSupplyAdded.setDescription('This trap will be sent when an additional power supply is installed. The component number and the index of the additional power supply is sent along with this trap.')
if mibBuilder.loadTexts: powerSupplyAdded.setReference('PANDATEL-CHASSIS-MIB, PowerSupplyAdded event notification.')
powerSupplyRemoved = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,22)).setObjects(("PANDATEL-CHASSIS-MIB", "psupplyTypeID"))
if mibBuilder.loadTexts: powerSupplyRemoved.setDescription("This trap will be sent when one of the power supplies is removed, i.e. it enters the 'not-present' status. The component number and the index of the removed power supply is sent along with this trap.")
if mibBuilder.loadTexts: powerSupplyRemoved.setReference('PANDATEL-CHASSIS-MIB, PowerSupplyRemoved event notification.')
powerSupplyFailed = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,23)).setObjects(("PANDATEL-CHASSIS-MIB", "psupplyTypeID"))
if mibBuilder.loadTexts: powerSupplyFailed.setDescription("This trap will be sent when one of the power supplies enters the 'fail' status. The component number and the index of the failing power supply is sent along with this trap.")
if mibBuilder.loadTexts: powerSupplyFailed.setReference('PANDATEL-CHASSIS-MIB, PowerSupplyFailed event notification.')
powerSupplyRecovered = NotificationType((1, 3, 6, 1, 4, 1, 760, 1, 20000) + (0,24)).setObjects(("PANDATEL-CHASSIS-MIB", "psupplyTypeID"))
if mibBuilder.loadTexts: powerSupplyRecovered.setDescription("This trap will be sent when one of the power supplies leaves the 'fail' status and enters the 'up' status. If the 'fail' status is left because the power supply has been removed, a powerSupplyRemoved trap type will be sent instead. The component number and the index of the recovering power supply is sent along with this trap.")
if mibBuilder.loadTexts: powerSupplyRecovered.setReference('PANDATEL-CHASSIS-MIB, PowerSupplyRecovered event notification.')
mibBuilder.exportSymbols("PANDATEL-CHASSIS-MIB", moduleAdded=moduleAdded, moduleRemoved=moduleRemoved, portPhysicalType=portPhysicalType, devcComp=devcComp, componentAdded=componentAdded, chassisComponentTable=chassisComponentTable, compComp=compComp, devcSlot=devcSlot, compTypeID=compTypeID, psupplySlot=psupplySlot, devcModules=devcModules, chassisModules=chassisModules, slotComp=slotComp, devcLastChange=devcLastChange, slotOwnerDeviceID=slotOwnerDeviceID, slotSlot=slotSlot, powerSupplyFailed=powerSupplyFailed, portEntry=portEntry, powerSupplyAdded=powerSupplyAdded, slotModuleTypeID=slotModuleTypeID, chassisDeviceTable=chassisDeviceTable, chassis=chassis, chassisPorts=chassisPorts, mibs=mibs, slotSlotTypeID=slotSlotTypeID, compSlots=compSlots, devcTypeID=devcTypeID, compDesign=compDesign, psupplyTypeID=psupplyTypeID, chassisComponents=chassisComponents, portPort=portPort, portComp=portComp, powerSupplyRecovered=powerSupplyRecovered, portFunctionalTypeID=portFunctionalTypeID, devcEntry=devcEntry, devcPorts=devcPorts, psupplyDescr=psupplyDescr, psupplyStatus=psupplyStatus, chassisDevices=chassisDevices, componentRemoved=componentRemoved, psupplyIndex=psupplyIndex, chassisPortTable=chassisPortTable, portSlot=portSlot, chassisSlotTable=chassisSlotTable, compEntry=compEntry, portOwnerDeviceID=portOwnerDeviceID, psupplyEntry=psupplyEntry, chassisPowerSupplyTable=chassisPowerSupplyTable, slotModuleName=slotModuleName, slotPorts=slotPorts, chassisSlots=chassisSlots, chassisTypeID=chassisTypeID, compModules=compModules, devcMgmtAddress=devcMgmtAddress, slotEntry=slotEntry, devcDescr=devcDescr, psupplyRack=psupplyRack, pandatel=pandatel, powerSupplyRemoved=powerSupplyRemoved)

#
# PySNMP MIB module INTEL-IPROUTER-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/INTEL-IPROUTER-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:54:26 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
SingleValueConstraint, ConstraintsUnion, ValueRangeConstraint, ConstraintsIntersection, ValueSizeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "SingleValueConstraint", "ConstraintsUnion", "ValueRangeConstraint", "ConstraintsIntersection", "ValueSizeConstraint")
mib2ext, = mibBuilder.importSymbols("INTEL-GEN-MIB", "mib2ext")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Counter32, MibIdentifier, Gauge32, NotificationType, Bits, IpAddress, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, Integer32, ModuleIdentity, TimeTicks, Unsigned32, Counter64, ObjectIdentity = mibBuilder.importSymbols("SNMPv2-SMI", "Counter32", "MibIdentifier", "Gauge32", "NotificationType", "Bits", "IpAddress", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "Integer32", "ModuleIdentity", "TimeTicks", "Unsigned32", "Counter64", "ObjectIdentity")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
iprouter = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21))
conf = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 1))
confIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1), )
if mibBuilder.loadTexts: confIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: confIfTable.setDescription('The table contains configuration information for each IP link.')
confIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "confIfIndex"))
if mibBuilder.loadTexts: confIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: confIfEntry.setDescription('Configuration information for the IP link.')
confIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: confIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: confIfIndex.setDescription('The ifIndex of the IP link.')
confIfAddrAndMask1 = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 2), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfAddrAndMask1.setStatus('mandatory')
if mibBuilder.loadTexts: confIfAddrAndMask1.setDescription('The primary IP Address and Mask of the IP link. The format of the octet string is: 4 bytes : IP Address. 4 bytes : Subnet Mask. A string of all zeros is used for unnumbered links.')
confIfAddrAndMask2 = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfAddrAndMask2.setStatus('mandatory')
if mibBuilder.loadTexts: confIfAddrAndMask2.setDescription('The second IP Address and Mask of the IP link. The format of the octet string is: 4 bytes : IP Address. 4 bytes : Subnet Mask.')
confIfAddrAndMask3 = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfAddrAndMask3.setStatus('mandatory')
if mibBuilder.loadTexts: confIfAddrAndMask3.setDescription('The third IP Address and Mask of the IP link. The format of the octet string is: 4 bytes : IP Address. 4 bytes : Subnet Mask.')
confIfAddrAndMask4 = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(8, 8)).setFixedLength(8)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfAddrAndMask4.setStatus('mandatory')
if mibBuilder.loadTexts: confIfAddrAndMask4.setDescription('The fourth IP Address and Mask of the IP link. The format of the octet string is: 4 bytes : IP Address. 4 bytes : Subnet Mask.')
confIfRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("none", 1), ("rip-1", 2), ("rip-2", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRouteProto.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRouteProto.setDescription('The Routing Protocol used on the link.')
confIfTrigRip = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfTrigRip.setStatus('mandatory')
if mibBuilder.loadTexts: confIfTrigRip.setDescription('Indicates whether Triggered RIP is used on the link.')
confIfRipMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRipMetric.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRipMetric.setDescription('The RIP metric used on the link.')
confIfRip2AuthType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("none", 1), ("simple-password", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRip2AuthType.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRip2AuthType.setDescription('The RIP-2 Authentication type used on the link.')
confIfRip2AuthKey = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 10), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 16))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRip2AuthKey.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRip2AuthKey.setDescription('The authentication key used in RIP-2.')
confIfBootpReqForw = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfBootpReqForw.setStatus('mandatory')
if mibBuilder.loadTexts: confIfBootpReqForw.setDescription('Indicates whether BOOTP requests are forwarded on the link')
confIfProxyArp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfProxyArp.setStatus('mandatory')
if mibBuilder.loadTexts: confIfProxyArp.setDescription('Indicates whether Proxy Arp is used on the link.')
confIfFiltering = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfFiltering.setStatus('mandatory')
if mibBuilder.loadTexts: confIfFiltering.setDescription('Indicates whether IP filtering is used on the link.')
confIfRxDefAction = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("pass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRxDefAction.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRxDefAction.setDescription('Indicates whether packets not matching any of the Rx filters on the link must be passed or discarded.')
confIfTxDefAction = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("discard", 1), ("pass", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfTxDefAction.setStatus('mandatory')
if mibBuilder.loadTexts: confIfTxDefAction.setDescription('Indicates whether packets not matching any of the Tx filters on the link must be passed or discarded.')
confIfRxDefLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRxDefLogging.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRxDefLogging.setDescription('Indicates whether packets not matching any of the Rx filters must be logged.')
confIfTxDefLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfTxDefLogging.setStatus('mandatory')
if mibBuilder.loadTexts: confIfTxDefLogging.setDescription('Indicates whether packets not matching any of the Tx filters must be logged.')
confIfCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 18), OctetString().subtype(subtypeSpec=ValueSizeConstraint(100, 100)).setFixedLength(100)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: confIfCreateObj.setDescription('Create a non existing table entry. If the entry already exist, genError is returned. Binary format: 4 bytes : confIfAddr1 4 bytes : confIfMask1 4 bytes : confIfAddr2 4 bytes : confIfMask2 4 bytes : confIfAddr3 4 bytes : confIfMask3 4 bytes : confIfAddr4 4 bytes : confIfMask4 1 byte : confIfRouteProto 1 byte : confIfTrigRip 1 byte : confIfRipMetric 1 byte : confIfRip2AuthType 16 bytes : confIfRip2AuthKey 1 byte : confIfBootpReqForw 1 byte : confIfProxyArp 1 byte : confIfFiltering 1 byte : confIfRxDefAction 1 byte : confIfTxDefAction 1 byte : confIfRxDefLogging 1 byte : confIfTxDefLogging 1 byte : confIfTtlThreshold 30 bytes : confIfTunnelName 4 bytes : confIfLocalIP 4 bytes : confIfRemoteIP 1 byte : confIfMgtAccess 1 byte : confIfRtrDiscovery ')
confIfDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: confIfDeleteObj.setDescription('Delete an existing table entry')
confIfMCRouteProto = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: confIfMCRouteProto.setStatus('obsolete')
if mibBuilder.loadTexts: confIfMCRouteProto.setDescription('The multicast Routing Protocol used on the link.')
confIfDvmrpMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: confIfDvmrpMetric.setStatus('obsolete')
if mibBuilder.loadTexts: confIfDvmrpMetric.setDescription('The DVMRP metric used on the link.')
confIfTtlThreshold = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfTtlThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: confIfTtlThreshold.setDescription('The TTL Threshold used on the link.')
confIfTunnelName = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 23), OctetString().subtype(subtypeSpec=ValueSizeConstraint(0, 30))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfTunnelName.setStatus('mandatory')
if mibBuilder.loadTexts: confIfTunnelName.setDescription('The symbolic name of the IP-in-IP tunnel.')
confIfLocalIP = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 24), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfLocalIP.setStatus('mandatory')
if mibBuilder.loadTexts: confIfLocalIP.setDescription('The Local IP address of the IP-in-IP tunnel.')
confIfRemoteIP = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 25), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRemoteIP.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRemoteIP.setDescription('The Remote IP address of the IP-in-IP tunnel.')
confIfMgtAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 26), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfMgtAccess.setStatus('mandatory')
if mibBuilder.loadTexts: confIfMgtAccess.setDescription('Indicates whether management access to the router is allowed via the link.')
confIfRtrDiscovery = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 27), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: confIfRtrDiscovery.setStatus('mandatory')
if mibBuilder.loadTexts: confIfRtrDiscovery.setDescription('Indicates whether the router is allowed to send ICMP Router Advertisement messages.')
confIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lan", 1), ("wan", 2), ("tunnel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: confIfType.setStatus('mandatory')
if mibBuilder.loadTexts: confIfType.setDescription('Indicates the type of interface used for the link.')
confMgtAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 1, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: confMgtAddress.setStatus('mandatory')
if mibBuilder.loadTexts: confMgtAddress.setDescription('Enabled if the first address of this interface is the management address.')
filterTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2), )
if mibBuilder.loadTexts: filterTable.setStatus('mandatory')
if mibBuilder.loadTexts: filterTable.setDescription('The table contains IP filter configuration information.')
filterEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "filterIfIndex"), (0, "INTEL-IPROUTER-MIB", "filterDirIndex"), (0, "INTEL-IPROUTER-MIB", "filterIndex"))
if mibBuilder.loadTexts: filterEntry.setStatus('mandatory')
if mibBuilder.loadTexts: filterEntry.setDescription('Configuration information for the IP filter.')
filterIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: filterIfIndex.setDescription('The ifIndex of the IP link on which the filter is used.')
filterDirIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("rx", 1), ("tx", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterDirIndex.setStatus('mandatory')
if mibBuilder.loadTexts: filterDirIndex.setDescription('Indicates whether the filter is an Rx or Tx filter.')
filterIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterIndex.setStatus('mandatory')
if mibBuilder.loadTexts: filterIndex.setDescription('Index in the Rx or Tx filter list for the link.')
filterAction = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("discard", 1), ("pass", 2), ("disabled", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterAction.setStatus('mandatory')
if mibBuilder.loadTexts: filterAction.setDescription('The action to be taken when a packet matches the filter. Disabled filters are ignored.')
filterLogging = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("disabled", 1), ("enabled", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterLogging.setStatus('mandatory')
if mibBuilder.loadTexts: filterLogging.setDescription('Indicates whether packets matching the filter must be logged.')
filterProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("all", 1), ("other", 2), ("icmp", 3), ("tcp", 4), ("udp", 5), ("igmp", 6), ("ip-ip", 7), ("rsvp", 8)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterProtocol.setStatus('mandatory')
if mibBuilder.loadTexts: filterProtocol.setDescription('Indicates whether the filter matches all protocols, a user defined protocol or a known protocol.')
filterProtocolValue = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 7), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterProtocolValue.setStatus('mandatory')
if mibBuilder.loadTexts: filterProtocolValue.setDescription('The protocol field in the IP header of the packet.')
filterTcpFlags = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("all", 1), ("ack", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterTcpFlags.setStatus('mandatory')
if mibBuilder.loadTexts: filterTcpFlags.setDescription('Indicates whether the filter matches all TCP packets or only TCP packets with the ACK flag set. When the ACK flag is set, the packet belongs to an established TCP connection.')
filterSrcAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("network", 2), ("host", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSrcAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: filterSrcAddrType.setDescription('Indicates whether the filter matches all source addresses, addresses on a specific network or a specific host address.')
filterSrcAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 10), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSrcAddr.setStatus('mandatory')
if mibBuilder.loadTexts: filterSrcAddr.setDescription('Indicates the network or host address which the source address must match.')
filterSrcMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 11), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSrcMask.setStatus('mandatory')
if mibBuilder.loadTexts: filterSrcMask.setDescription('The subnet mask of the network which the source address must match.')
filterSrcPort = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 20, 21, 23, 25, 53, 67, 68, 69, 70, 80, 110, 119, 161, 162, 520, 1990, 2049))).clone(namedValues=NamedValues(("all", 1), ("other", 2), ("ftp-data", 20), ("ftp-control", 21), ("telnet", 23), ("smtp", 25), ("dns", 53), ("bootp-server", 67), ("bootp-client", 68), ("tftp", 69), ("gopher", 70), ("http", 80), ("pop3", 110), ("nntp", 119), ("snmp", 161), ("snmp-trap", 162), ("rip", 520), ("tunnel", 1990), ("nfs", 2049)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSrcPort.setStatus('mandatory')
if mibBuilder.loadTexts: filterSrcPort.setDescription('Indicates whether the filter matches all or a specific UDP/TCP source port.')
filterSrcPortValue = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 13), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSrcPortValue.setStatus('mandatory')
if mibBuilder.loadTexts: filterSrcPortValue.setDescription('The UDP/TCP source port of the filter.')
filterSrcPortOper = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("equal-to", 1), ("not-equal-to", 2), ("greater-than", 3), ("less-than", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterSrcPortOper.setStatus('mandatory')
if mibBuilder.loadTexts: filterSrcPortOper.setDescription('The source port operator indicates whether UDP/TCP source port values equal to, not equal to, greater than or less than the filter source port match the filter.')
filterDestAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("all", 1), ("network", 2), ("host", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestAddrType.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestAddrType.setDescription('Indicates whether the filter matches all destination addresses, addresses on a specific network or a specific host address.')
filterDestAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 16), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestAddr.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestAddr.setDescription('Indicates the network or host address which the destination address must match.')
filterDestMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 17), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestMask.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestMask.setDescription('The subnet mask of the network which the destination address must match.')
filterDestPort = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 20, 21, 23, 25, 53, 67, 68, 69, 70, 80, 110, 161, 162, 520, 1990, 2049))).clone(namedValues=NamedValues(("all", 1), ("other", 2), ("ftp-data", 20), ("ftp-control", 21), ("telnet", 23), ("smtp", 25), ("dns", 53), ("bootp-server", 67), ("bootp-client", 68), ("tftp", 69), ("gopher", 70), ("http", 80), ("pop3", 110), ("snmp", 161), ("snmp-trap", 162), ("rip", 520), ("tunnel", 1990), ("nfs", 2049)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestPort.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestPort.setDescription('Indicates whether the filter matches all or a specific UDP/TCP destination port.')
filterDestPortValue = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 19), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestPortValue.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestPortValue.setDescription('The UDP/TCP destination port of the filter.')
filterDestPortOper = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("equal-to", 1), ("not-equal-to", 2), ("greater-than", 3), ("less-than", 4)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: filterDestPortOper.setStatus('mandatory')
if mibBuilder.loadTexts: filterDestPortOper.setDescription('The destination port operator indicates whether UDP/TCP destination port values equal to, not equal to, greater than or less than the filter destination port match the filter.')
filterHits = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 2, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: filterHits.setStatus('mandatory')
if mibBuilder.loadTexts: filterHits.setDescription('The number of packets matching the filter.')
natTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3), )
if mibBuilder.loadTexts: natTable.setStatus('mandatory')
if mibBuilder.loadTexts: natTable.setDescription('The table contains NAT information.')
natEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "natIfIndex"), (0, "INTEL-IPROUTER-MIB", "natIndex"))
if mibBuilder.loadTexts: natEntry.setStatus('mandatory')
if mibBuilder.loadTexts: natEntry.setDescription('Information for the NAT entry.')
natIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: natIfIndex.setDescription('The ifIndex of the IP link on which the NAT entry is used.')
natIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natIndex.setStatus('mandatory')
if mibBuilder.loadTexts: natIndex.setDescription('Internal NAT index.')
natIntAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natIntAddr.setStatus('mandatory')
if mibBuilder.loadTexts: natIntAddr.setDescription('The Internal IP Address of the NAT entry.')
natIntMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natIntMask.setStatus('mandatory')
if mibBuilder.loadTexts: natIntMask.setDescription('The Internal Mask of the NAT entry.')
natIntPort = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natIntPort.setStatus('mandatory')
if mibBuilder.loadTexts: natIntPort.setDescription('The Internal Port of the NAT entry.')
natExtAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 6), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natExtAddr.setStatus('mandatory')
if mibBuilder.loadTexts: natExtAddr.setDescription('The External IP Address of the NAT entry.')
natExtMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 7), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natExtMask.setStatus('mandatory')
if mibBuilder.loadTexts: natExtMask.setDescription('The External Mask of the NAT entry.')
natExtPort = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 8), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natExtPort.setStatus('mandatory')
if mibBuilder.loadTexts: natExtPort.setDescription('The External Port of the NAT entry.')
natType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("static", 1), ("dynamic", 2), ("singleIpHost", 3), ("singleIpNetwork", 4), ("singleIpIcmp", 5)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: natType.setStatus('mandatory')
if mibBuilder.loadTexts: natType.setDescription('Indicates whether the NAT entry is static or dynamic.')
natTime = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 3, 1, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: natTime.setStatus('mandatory')
if mibBuilder.loadTexts: natTime.setDescription('The time left for dynamic NAT entries.')
statRoutTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4), )
if mibBuilder.loadTexts: statRoutTable.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutTable.setDescription('The table contains static route information.')
statRoutEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "statRoutIfIndex"), (0, "INTEL-IPROUTER-MIB", "statRoutNetwork"))
if mibBuilder.loadTexts: statRoutEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutEntry.setDescription('Information for the static route entry.')
statRoutIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1, 1), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statRoutIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutIfIndex.setDescription('The ifIndex of the IP link on which the static route is used.')
statRoutNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statRoutNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutNetwork.setDescription('IP address of network.')
statRoutMask = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1, 3), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statRoutMask.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutMask.setDescription('Subnet mask of network')
statRoutNextHop = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1, 4), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statRoutNextHop.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutNextHop.setDescription('Next hop router (LAN only)')
statRoutMetric = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1, 5), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statRoutMetric.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutMetric.setDescription('Metric to network')
statRoutCreateObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(12, 12)).setFixedLength(12)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statRoutCreateObj.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutCreateObj.setDescription('Create a non existing table entry. If the entry already exist, genError is returned. Binary format: 4 bytes : statRoutMask 4 bytes : statRoutNextHop 4 bytes : statRoutMetric ')
statRoutDeleteObj = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 4, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("delete", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: statRoutDeleteObj.setStatus('mandatory')
if mibBuilder.loadTexts: statRoutDeleteObj.setDescription('Delete an existing table entry')
tosPrefThreshold = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 1, 5), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 8))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: tosPrefThreshold.setStatus('mandatory')
if mibBuilder.loadTexts: tosPrefThreshold.setDescription('The threshold for Type of Service for the IP router. IP packets have a Precendence value in the Type of Service field. If the value is higher than the threshold the packet will be forwarded with high priority.')
stat = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 2))
statIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1), )
if mibBuilder.loadTexts: statIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: statIfTable.setDescription('The table contains statistic information for each IP link.')
statIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "statIfIndex"))
if mibBuilder.loadTexts: statIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: statIfEntry.setDescription('Statistic information for the IP link.')
statIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: statIfIndex.setDescription('The ifIndex of the IP link.')
statIfType = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("lan", 1), ("wan", 2), ("tunnel", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfType.setStatus('mandatory')
if mibBuilder.loadTexts: statIfType.setDescription('The type of the network (LAN or WAN) to which the IP link is connected.')
statIfState = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("up", 1), ("down", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfState.setStatus('mandatory')
if mibBuilder.loadTexts: statIfState.setDescription('The actual state of the IP link. The link layer informs the IP link of link state changes.')
statIfMTU = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfMTU.setStatus('mandatory')
if mibBuilder.loadTexts: statIfMTU.setDescription('The maximum transmit unit of the IP link. IP packets larger than the MTU will be fragmented.')
statIfRxDefHits = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfRxDefHits.setStatus('mandatory')
if mibBuilder.loadTexts: statIfRxDefHits.setDescription('The number of packets that did not match any of the Rx Filters for the link.')
statIfTxDefHits = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfTxDefHits.setStatus('mandatory')
if mibBuilder.loadTexts: statIfTxDefHits.setDescription('The number of packets that did not match any of the Tx Filters for the link.')
statIfChange = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 2, 2), TimeTicks()).setMaxAccess("readonly")
if mibBuilder.loadTexts: statIfChange.setStatus('mandatory')
if mibBuilder.loadTexts: statIfChange.setDescription('The value of sysUpTime at the time any IP link changed state.')
arp = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 3))
arpIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1), )
if mibBuilder.loadTexts: arpIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfTable.setDescription('The table contains ARP information for each IP link.')
arpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "arpIfIndex"))
if mibBuilder.loadTexts: arpIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfEntry.setDescription('ARP information for the IP link.')
arpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfIndex.setDescription('The ifIndex of the IP link.')
arpIfInReq = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpIfInReq.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfInReq.setDescription('The number of ARP requests received on the link.')
arpIfOutRep = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpIfOutRep.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfOutRep.setDescription('The number of ARP replies sent on the link.')
arpIfOutReq = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpIfOutReq.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfOutReq.setDescription('The number of ARP requests sent on the link.')
arpIfInRep = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpIfInRep.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfInRep.setDescription('The number of ARP replies received on the link.')
arpIfInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpIfInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: arpIfInHdrErrors.setDescription('The number of ARP packets received on the link which were discarded because of ARP header errors.')
arpInReq = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInReq.setStatus('mandatory')
if mibBuilder.loadTexts: arpInReq.setDescription('The total number of ARP requests received.')
arpOutRep = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpOutRep.setStatus('mandatory')
if mibBuilder.loadTexts: arpOutRep.setDescription('The total number of ARP replies sent.')
arpOutReq = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpOutReq.setStatus('mandatory')
if mibBuilder.loadTexts: arpOutReq.setDescription('The total number of ARP requests sent.')
arpInRep = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInRep.setStatus('mandatory')
if mibBuilder.loadTexts: arpInRep.setDescription('The total number of ARP replies received.')
arpInHdrErrors = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 3, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: arpInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: arpInHdrErrors.setDescription('The total number of received ARP packets which were discarded because of ARP header errors.')
ip = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 4))
ipIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1), )
if mibBuilder.loadTexts: ipIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfTable.setDescription('The table contains statistic information for each IP link.')
ipIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "ipIfIndex"))
if mibBuilder.loadTexts: ipIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfEntry.setDescription('IP information for the IP link.')
ipIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfIndex.setDescription('The ifIndex of the IP link.')
ipIfInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfInReceives.setDescription('The number of IP packets received on the link.')
ipIfInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfInHdrErrors.setDescription('The number of IP packets received on the link which were discarded because of IP header errors.')
ipIfInAddrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfInAddrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfInAddrErrors.setDescription('The number of IP packets received on the link which were discarded because of IP source or destination address errors.')
ipIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfInDiscards.setDescription('The number of IP packets received on the link which were discarded because of lack of buffer space.')
ipIfForwDatagrams = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfForwDatagrams.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfForwDatagrams.setDescription('The number of IP packets forwarded on the link.')
ipIfOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfOutRequests.setDescription('The number of IP packets sent by the router itself.')
ipIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 4, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ipIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ipIfOutDiscards.setDescription('The number of IP packets which should have been sent on the link, but were discarded because of lack of buffer space or failed ARP requests.')
icmp = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 5))
icmpIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1), )
if mibBuilder.loadTexts: icmpIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfTable.setDescription('The table contains ICMP information for each IP link.')
icmpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "icmpIfIndex"))
if mibBuilder.loadTexts: icmpIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfEntry.setDescription('ICMP information for the IP link.')
icmpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfIndex.setDescription('The ifIndex of the IP link.')
icmpIfInMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfInMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfInMsgs.setDescription('The number of ICMP messages to the router received on the link.')
icmpIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfInErrors.setDescription('The number of ICMP messages to the router received on the link which were discarded because of ICMP header errors.')
icmpIfInEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfInEchos.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfInEchos.setDescription('The number of ICMP echo requests received on the link.')
icmpIfInEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfInEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfInEchoReps.setDescription('The number of ICMP echo replies received on the link.')
icmpIfOutMsgs = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfOutMsgs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfOutMsgs.setDescription('The number of ICMP messages sent on the link.')
icmpIfOutEchos = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfOutEchos.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfOutEchos.setDescription('The number of ICMP echo requests sent on the link.')
icmpIfOutEchoReps = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpIfOutEchoReps.setStatus('mandatory')
if mibBuilder.loadTexts: icmpIfOutEchoReps.setDescription('The number of ICMP echo replies sent on the link.')
icmpInRouterAdvs = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInRouterAdvs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInRouterAdvs.setDescription('The total number of received ICMP Router Advertisements.')
icmpInRouterSols = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpInRouterSols.setStatus('mandatory')
if mibBuilder.loadTexts: icmpInRouterSols.setDescription('The total number of received ICMP Router Solicitations.')
icmpOutRouterAdvs = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutRouterAdvs.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutRouterAdvs.setDescription('The total number of sent ICMP Router Advertisements.')
icmpOutRouterSols = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 5, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: icmpOutRouterSols.setStatus('mandatory')
if mibBuilder.loadTexts: icmpOutRouterSols.setDescription('The total number of sent ICMP Router Solicitations.')
rip = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 6))
ripIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1), )
if mibBuilder.loadTexts: ripIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfTable.setDescription('The table contains RIP information for each IP link.')
ripIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "ripIfIndex"))
if mibBuilder.loadTexts: ripIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfEntry.setDescription('RIP information for the IP link.')
ripIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfIndex.setDescription('The ifIndex of the IP link.')
ripIfInReceives = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfInReceives.setDescription('The number of RIP packets received on the link.')
ripIfInHdrErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfInHdrErrors.setDescription('The number of RIP packets received on the link which were discarded because of RIP header errors.')
ripIfInBadSrcAddrs = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfInBadSrcAddrs.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfInBadSrcAddrs.setDescription('The number of RIP packets received on the link which were discarded because of source address errors. This may indicate an IP address configuration error on the link or the link of the router from which the RIP packet was received. The error may also occur if the link is connected to a physical network with multiple logical IP networks. In the latter case a source address error is not an indication of an IP address configuration error.')
ripIfInBadVers = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfInBadVers.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfInBadVers.setDescription('The number of RIP packets received on the link which were discarded because of RIP version errors. This indicates a RIP configuration error on the link or the link of the router from which the RIP packet was received. The error occurs when receiving a RIP packet with a version different from the version configured on the link. The error also occurs if a RIP packet is received and the link is configured not to use RIP.')
ripIfInAuthFails = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfInAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfInAuthFails.setDescription('The number of RIP packets received on the link which were discarded because of RIP-2 authentication failures.')
ripIfInUnknComs = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfInUnknComs.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfInUnknComs.setDescription('The number of RIP packets received on the link which were discarded because of an unknown command type. This may indicate that the link is not configured to use Triggered RIP and the remote router is using Triggered RIP.')
ripIfOutSent = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfOutSent.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfOutSent.setDescription('The number of RIP packets sent on the link.')
ripIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ripIfOutDiscards.setDescription('The number of RIP packets discarded because of lack of buffer space.')
ripInReceives = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInReceives.setStatus('mandatory')
if mibBuilder.loadTexts: ripInReceives.setDescription('The total number of received RIP packets.')
ripInHdrErrors = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInHdrErrors.setStatus('mandatory')
if mibBuilder.loadTexts: ripInHdrErrors.setDescription('The total number of received RIP packets discarded because of RIP header errors.')
ripInBadSrcAddrs = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInBadSrcAddrs.setStatus('mandatory')
if mibBuilder.loadTexts: ripInBadSrcAddrs.setDescription('The total number of received RIP packets discarded because of source address errors.')
ripInBadVers = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInBadVers.setStatus('mandatory')
if mibBuilder.loadTexts: ripInBadVers.setDescription('The total number of received RIP packets discarded because of RIP version errors.')
ripInAuthFails = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInAuthFails.setStatus('mandatory')
if mibBuilder.loadTexts: ripInAuthFails.setDescription('The total number of RIP-2 authentication failures.')
ripInUnknComs = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripInUnknComs.setStatus('mandatory')
if mibBuilder.loadTexts: ripInUnknComs.setDescription('The total number of received RIP packets discarded because of an unknown command type.')
ripOutSent = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripOutSent.setStatus('mandatory')
if mibBuilder.loadTexts: ripOutSent.setDescription('The total number of RIP packets sent by the router.')
ripOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 6, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: ripOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: ripOutDiscards.setDescription('The total number of RIP packets discarded because of lack of buffer space.')
bootp = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 7))
bootpIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1), )
if mibBuilder.loadTexts: bootpIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfTable.setDescription('The table contains BOOTP information for each IP link.')
bootpIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "bootpIfIndex"))
if mibBuilder.loadTexts: bootpIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfEntry.setDescription('BOOTP information for the IP link.')
bootpIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfIndex.setDescription('The ifIndex of the IP link.')
bootpIfInRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfInRequests.setDescription('The number of BOOTP requests received on the link.')
bootpIfInReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfInReplies.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfInReplies.setDescription('The number of BOOTP replies received on the link.')
bootpIfInErrors = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfInErrors.setDescription('The number of BOOTP packets received on the link which were discarded because of header errors.')
bootpIfInDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfInDiscards.setDescription('The number of BOOTP requests received on the link which were discarded. This is done in the following situations: - The maximum value of the BOOTP hop count is exceeded. - More than 3 BOOTP packets are received per second. - The router does not have a route back to the assisting router using the receving link.')
bootpIfOutRequests = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfOutRequests.setDescription('The number of BOOTP requests sent on the link.')
bootpIfOutReplies = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfOutReplies.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfOutReplies.setDescription('The number of BOOTP replies sent on the link.')
bootpIfOutDiscards = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpIfOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: bootpIfOutDiscards.setDescription('The number of BOOTP requests discarded because of lack of buffer space.')
bootpInRequests = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpInRequests.setStatus('mandatory')
if mibBuilder.loadTexts: bootpInRequests.setDescription('The total number of received BOOTP requests.')
bootpInReplies = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpInReplies.setStatus('mandatory')
if mibBuilder.loadTexts: bootpInReplies.setDescription('The total number of received BOOTP replies.')
bootpInErrors = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpInErrors.setStatus('mandatory')
if mibBuilder.loadTexts: bootpInErrors.setDescription('The total number of received BOOTP packets discarded because of header errors.')
bootpInDiscards = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpInDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: bootpInDiscards.setDescription('The total number of received BOOTP requests discarded. This is done in the following situations: - The maximum value of the BOOTP hop count is exceeded. - More than 3 BOOTP packets are received per second. - The router does not have a route back to the assisting router using the receiving link.')
bootpOutRequests = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpOutRequests.setStatus('mandatory')
if mibBuilder.loadTexts: bootpOutRequests.setDescription('The total number of BOOTP requests sent by the router.')
bootpOutReplies = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpOutReplies.setStatus('mandatory')
if mibBuilder.loadTexts: bootpOutReplies.setDescription('The total number of BOOTP replies sent to BOOTP clients.')
bootpOutDiscards = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: bootpOutDiscards.setStatus('mandatory')
if mibBuilder.loadTexts: bootpOutDiscards.setDescription('The total number of BOOTP requests discarded because of lack of buffer space.')
bootpMaxHops = MibScalar((1, 3, 6, 1, 4, 1, 343, 6, 21, 7, 9), Integer32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: bootpMaxHops.setStatus('mandatory')
if mibBuilder.loadTexts: bootpMaxHops.setDescription('The maximum allowed value of the hop count in received BOOTP requests.')
octetcounters = MibIdentifier((1, 3, 6, 1, 4, 1, 343, 6, 21, 8))
octetIfTable = MibTable((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1), )
if mibBuilder.loadTexts: octetIfTable.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfTable.setDescription('The table contains octet counters for each IP link.')
octetIfEntry = MibTableRow((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1), ).setIndexNames((0, "INTEL-IPROUTER-MIB", "octetIfIndex"))
if mibBuilder.loadTexts: octetIfEntry.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfEntry.setDescription('Octet counter information for the IP link.')
octetIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfIndex.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfIndex.setDescription('The ifIndex of the IP link.')
octetIfInTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 2), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInTotal.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInTotal.setDescription('The total number of octets received on the IP link.')
octetIfOutTotal = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutTotal.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutTotal.setDescription('The total number of octets sent on the IP link.')
octetIfInOther = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInOther.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInOther.setDescription('The number of octets received on the IP link which were not classified as a specific protocol.')
octetIfOutOther = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutOther.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutOther.setDescription('The number of octets sent on the IP link which were not classified as a specific protocol.')
octetIfInFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInFtp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInFtp.setDescription('The number of FTP octets received on the IP link.')
octetIfOutFtp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 7), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutFtp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutFtp.setDescription('The number of FTP octets sent on the IP link.')
octetIfInTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 8), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInTelnet.setDescription('The number of Telnet octets received on the IP link.')
octetIfOutTelnet = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 9), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutTelnet.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutTelnet.setDescription('The number of Telnet octets sent on the IP link.')
octetIfInSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 10), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInSmtp.setDescription('The number of SMTP octets received on the IP link.')
octetIfOutSmtp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 11), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutSmtp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutSmtp.setDescription('The number of SMTP octets sent on the IP link.')
octetIfInDns = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 12), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInDns.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInDns.setDescription('The number of DNS octets received on the IP link.')
octetIfOutDns = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 13), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutDns.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutDns.setDescription('The number of DNS octets sent on the IP link.')
octetIfInBootp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 14), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInBootp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInBootp.setDescription('The number of BOOTP octets received on the IP link.')
octetIfOutBootp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 15), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutBootp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutBootp.setDescription('The number of BOOTP octets sent on the IP link.')
octetIfInHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInHttp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInHttp.setDescription('The number of HTTP octets received on the IP link.')
octetIfOutHttp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 17), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutHttp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutHttp.setDescription('The number of HTTP octets sent on the IP link.')
octetIfInSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 18), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInSnmp.setDescription('The number of SNMP octets received on the IP link.')
octetIfOutSnmp = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 19), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutSnmp.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutSnmp.setDescription('The number of SNMP octets sent on the IP link.')
octetIfInRip = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 20), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInRip.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInRip.setDescription('The number of RIP octets received on the IP link.')
octetIfOutRip = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 21), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutRip.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutRip.setDescription('The number of RIP octets sent on the IP link.')
octetIfInTunnel = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 22), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfInTunnel.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfInTunnel.setDescription('The number of Tunnel octets received on the IP link.')
octetIfOutTunnel = MibTableColumn((1, 3, 6, 1, 4, 1, 343, 6, 21, 8, 1, 1, 23), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: octetIfOutTunnel.setStatus('mandatory')
if mibBuilder.loadTexts: octetIfOutTunnel.setDescription('The number of Tunnel octets sent on the IP link.')
mibBuilder.exportSymbols("INTEL-IPROUTER-MIB", ripInBadVers=ripInBadVers, confIfTunnelName=confIfTunnelName, icmpIfOutEchos=icmpIfOutEchos, octetIfTable=octetIfTable, filterDestAddr=filterDestAddr, octetIfInDns=octetIfInDns, statIfChange=statIfChange, octetIfInTunnel=octetIfInTunnel, statIfRxDefHits=statIfRxDefHits, icmpIfTable=icmpIfTable, ipIfOutDiscards=ipIfOutDiscards, statRoutDeleteObj=statRoutDeleteObj, icmpIfOutEchoReps=icmpIfOutEchoReps, rip=rip, confIfIndex=confIfIndex, confIfRtrDiscovery=confIfRtrDiscovery, bootpIfIndex=bootpIfIndex, octetIfInOther=octetIfInOther, confIfMgtAccess=confIfMgtAccess, icmpIfInEchos=icmpIfInEchos, filterSrcAddr=filterSrcAddr, ipIfInReceives=ipIfInReceives, ipIfInHdrErrors=ipIfInHdrErrors, filterDestMask=filterDestMask, confIfTable=confIfTable, confIfRip2AuthKey=confIfRip2AuthKey, ripIfInBadSrcAddrs=ripIfInBadSrcAddrs, statIfTxDefHits=statIfTxDefHits, ripInAuthFails=ripInAuthFails, filterHits=filterHits, statRoutTable=statRoutTable, statIfTable=statIfTable, arpIfEntry=arpIfEntry, octetIfOutSnmp=octetIfOutSnmp, confIfEntry=confIfEntry, statRoutNextHop=statRoutNextHop, natEntry=natEntry, arpIfInRep=arpIfInRep, bootpInErrors=bootpInErrors, confIfDvmrpMetric=confIfDvmrpMetric, confIfRouteProto=confIfRouteProto, arpInRep=arpInRep, bootpIfOutReplies=bootpIfOutReplies, bootpMaxHops=bootpMaxHops, icmpIfInMsgs=icmpIfInMsgs, filterLogging=filterLogging, filterTcpFlags=filterTcpFlags, confIfRxDefLogging=confIfRxDefLogging, natExtMask=natExtMask, filterIfIndex=filterIfIndex, bootpIfTable=bootpIfTable, arpInHdrErrors=arpInHdrErrors, confIfDeleteObj=confIfDeleteObj, ripInUnknComs=ripInUnknComs, ripIfInAuthFails=ripIfInAuthFails, arpIfInHdrErrors=arpIfInHdrErrors, ripIfEntry=ripIfEntry, octetIfOutBootp=octetIfOutBootp, confIfBootpReqForw=confIfBootpReqForw, natType=natType, bootpIfOutRequests=bootpIfOutRequests, confIfAddrAndMask4=confIfAddrAndMask4, statRoutMetric=statRoutMetric, octetIfInSmtp=octetIfInSmtp, octetIfOutHttp=octetIfOutHttp, ripIfTable=ripIfTable, natIndex=natIndex, statIfType=statIfType, confIfFiltering=confIfFiltering, octetIfInTelnet=octetIfInTelnet, natExtAddr=natExtAddr, ipIfTable=ipIfTable, statRoutMask=statRoutMask, octetIfOutRip=octetIfOutRip, arpIfTable=arpIfTable, confIfRip2AuthType=confIfRip2AuthType, iprouter=iprouter, octetIfInTotal=octetIfInTotal, arpInReq=arpInReq, bootpIfEntry=bootpIfEntry, filterSrcPortValue=filterSrcPortValue, ipIfIndex=ipIfIndex, icmpIfInErrors=icmpIfInErrors, bootpIfInReplies=bootpIfInReplies, filterDirIndex=filterDirIndex, octetIfIndex=octetIfIndex, octetIfOutTotal=octetIfOutTotal, icmpIfOutMsgs=icmpIfOutMsgs, confIfTxDefAction=confIfTxDefAction, ripOutDiscards=ripOutDiscards, statRoutCreateObj=statRoutCreateObj, confIfCreateObj=confIfCreateObj, icmpInRouterAdvs=icmpInRouterAdvs, statIfMTU=statIfMTU, conf=conf, ripIfInUnknComs=ripIfInUnknComs, octetIfOutSmtp=octetIfOutSmtp, octetIfOutOther=octetIfOutOther, ip=ip, ripIfIndex=ripIfIndex, arpOutReq=arpOutReq, arpIfInReq=arpIfInReq, arpOutRep=arpOutRep, confIfType=confIfType, filterDestPortOper=filterDestPortOper, statRoutIfIndex=statRoutIfIndex, icmpIfInEchoReps=icmpIfInEchoReps, bootp=bootp, confIfTrigRip=confIfTrigRip, filterProtocolValue=filterProtocolValue, filterSrcAddrType=filterSrcAddrType, statIfEntry=statIfEntry, statIfIndex=statIfIndex, bootpIfInErrors=bootpIfInErrors, bootpIfInRequests=bootpIfInRequests, confIfAddrAndMask3=confIfAddrAndMask3, filterProtocol=filterProtocol, ipIfInDiscards=ipIfInDiscards, octetIfOutTelnet=octetIfOutTelnet, icmp=icmp, arpIfOutReq=arpIfOutReq, ipIfEntry=ipIfEntry, confIfAddrAndMask1=confIfAddrAndMask1, natTime=natTime, filterDestPort=filterDestPort, natTable=natTable, arp=arp, stat=stat, filterDestAddrType=filterDestAddrType, tosPrefThreshold=tosPrefThreshold, confIfTtlThreshold=confIfTtlThreshold, bootpInReplies=bootpInReplies, confIfRemoteIP=confIfRemoteIP, confMgtAddress=confMgtAddress, confIfRxDefAction=confIfRxDefAction, octetIfInRip=octetIfInRip, filterSrcPort=filterSrcPort, ripOutSent=ripOutSent, filterAction=filterAction, filterSrcMask=filterSrcMask, filterSrcPortOper=filterSrcPortOper, natExtPort=natExtPort, octetIfInBootp=octetIfInBootp, bootpInDiscards=bootpInDiscards, statIfState=statIfState, ripIfInBadVers=ripIfInBadVers, ripInReceives=ripInReceives, ripInBadSrcAddrs=ripInBadSrcAddrs, confIfRipMetric=confIfRipMetric, ripIfInReceives=ripIfInReceives, octetcounters=octetcounters, confIfAddrAndMask2=confIfAddrAndMask2, confIfTxDefLogging=confIfTxDefLogging, icmpIfEntry=icmpIfEntry, filterTable=filterTable, octetIfEntry=octetIfEntry, confIfLocalIP=confIfLocalIP, arpIfOutRep=arpIfOutRep, ipIfOutRequests=ipIfOutRequests, bootpOutRequests=bootpOutRequests, natIntPort=natIntPort, icmpIfIndex=icmpIfIndex, bootpOutDiscards=bootpOutDiscards, ipIfForwDatagrams=ipIfForwDatagrams, octetIfOutDns=octetIfOutDns, octetIfInHttp=octetIfInHttp, octetIfOutFtp=octetIfOutFtp, arpIfIndex=arpIfIndex, ipIfInAddrErrors=ipIfInAddrErrors, confIfProxyArp=confIfProxyArp, natIntAddr=natIntAddr, ripInHdrErrors=ripInHdrErrors, ripIfOutSent=ripIfOutSent, bootpIfInDiscards=bootpIfInDiscards, bootpIfOutDiscards=bootpIfOutDiscards, bootpOutReplies=bootpOutReplies, octetIfInFtp=octetIfInFtp, filterDestPortValue=filterDestPortValue, natIntMask=natIntMask, filterEntry=filterEntry, octetIfOutTunnel=octetIfOutTunnel, icmpOutRouterSols=icmpOutRouterSols, statRoutEntry=statRoutEntry, natIfIndex=natIfIndex, bootpInRequests=bootpInRequests, filterIndex=filterIndex, icmpInRouterSols=icmpInRouterSols, icmpOutRouterAdvs=icmpOutRouterAdvs, statRoutNetwork=statRoutNetwork, ripIfInHdrErrors=ripIfInHdrErrors, confIfMCRouteProto=confIfMCRouteProto, ripIfOutDiscards=ripIfOutDiscards, octetIfInSnmp=octetIfInSnmp)

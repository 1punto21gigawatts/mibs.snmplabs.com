#
# PySNMP MIB module Storage-Management-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Storage-Management-MIB
# Produced by pysmi-0.3.4 at Wed May  1 15:14:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, Integer, OctetString = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "Integer", "OctetString")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsUnion, ConstraintsIntersection, SingleValueConstraint, ValueSizeConstraint, ValueRangeConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsUnion", "ConstraintsIntersection", "SingleValueConstraint", "ValueSizeConstraint", "ValueRangeConstraint")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
IpAddress, iso, ModuleIdentity, ObjectIdentity, Counter64, MibIdentifier, enterprises, Bits, Counter32, TimeTicks, Integer32, MibScalar, MibTable, MibTableRow, MibTableColumn, Gauge32, Unsigned32, NotificationType, NotificationType = mibBuilder.importSymbols("SNMPv2-SMI", "IpAddress", "iso", "ModuleIdentity", "ObjectIdentity", "Counter64", "MibIdentifier", "enterprises", "Bits", "Counter32", "TimeTicks", "Integer32", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Gauge32", "Unsigned32", "NotificationType", "NotificationType")
TextualConvention, DisplayString = mibBuilder.importSymbols("SNMPv2-TC", "TextualConvention", "DisplayString")
sni = MibIdentifier((1, 3, 6, 1, 4, 1, 231))
sniProductMibs = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2))
sniStorMgmt = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20))
sniStorMgmtAvailInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 1))
sniStorMgmtProductInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1))
sniStorMgmtHsmsInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2))
sniStorMgmtMarenInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3))
sniStorMgmtTlsInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4))
sniStorMgmtRobarInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5))
sniStorMgmtResourceInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 2))
sniStorMgmtPubsetInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 3))
sniStorMgmtDiskInfo = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 4))
sniStorMgmtGlobalData = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 18))
sniStorMgmtPubsetTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 20))
sniStorMgmtDiskTraps = MibIdentifier((1, 3, 6, 1, 4, 1, 231, 2, 20, 21))
storMgmtProductTabNum = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtProductTabNum.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductTabNum.setDescription('The number of entries in the table storMgmtProductTable')
storMgmtProductTable = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 2), )
if mibBuilder.loadTexts: storMgmtProductTable.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductTable.setDescription('The Storage management information table')
storMgmtProductEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 2, 1), ).setIndexNames((0, "Storage-Management-MIB", "storMgmtProductIndex"))
if mibBuilder.loadTexts: storMgmtProductEntry.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductEntry.setDescription('An entry in the table')
storMgmtProductIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtProductIndex.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductIndex.setDescription('A unique value for each entry, its value ranges between 1 and the value of storMgmtProductTabNum')
storMgmtProductName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 2, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtProductName.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductName.setDescription('The name of the product itself')
storMgmtProductVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtProductVersion.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductVersion.setDescription('The installed version of the specified product')
storMgmtProductState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 2, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("created", 1), ("not-created", 2), ("in-delete", 3), ("in-create", 4), ("in-resume", 5), ("in-hold", 6), ("not-resumed", 7), ("locked", 8), ("not-installed", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtProductState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductState.setDescription('Current state of the product')
storMgmtProductTimestamp = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 1, 2, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtProductTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtProductTimestamp.setDescription('Status timestamp (only for started and stopped state)')
storMgmtHsmsOpmode = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("defineshow", 1), ("simulation", 2), ("operation", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtHsmsOpmode.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsOpmode.setDescription('The current operational mode specifies the scope of actions to be performed by HSMS')
storMgmtHsmsModeTimestamp = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtHsmsModeTimestamp.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsModeTimestamp.setDescription('Mode timestamp')
storMgmtHsmsServertask = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 3), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 99))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtHsmsServertask.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsServertask.setDescription('Number of current server tasks')
storMgmtHsmsWaitJobs = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsWaitJobs.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsWaitJobs.setDescription('Number of waiting jobs (state is ACCEPTED)')
storMgmtHsmsInstances = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsInstances.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsInstances.setDescription('')
storMgmtHsmsAcceptReqs = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 6), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsAcceptReqs.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsAcceptReqs.setDescription('')
storMgmtHsmsCompleteReqs = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsCompleteReqs.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsCompleteReqs.setDescription('')
storMgmtHsmsInterruptReqs = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 8), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsInterruptReqs.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsInterruptReqs.setDescription('')
storMgmtHsmsWaitReqsRead = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 9), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsWaitReqsRead.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsWaitReqsRead.setDescription('')
storMgmtHsmsWaitReqsWrite = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 10), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsWaitReqsWrite.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsWaitReqsWrite.setDescription('')
storMgmtHsmsWaitReqsExpress = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 11), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsWaitReqsExpress.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsWaitReqsExpress.setDescription('')
storMgmtHsmsStimeRead = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsStimeRead.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsStimeRead.setDescription('')
storMgmtHsmsStimeWrite = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsStimeWrite.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsStimeWrite.setDescription('')
storMgmtHsmsStimeExpress = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 14), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsStimeExpress.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsStimeExpress.setDescription('')
storMgmtHsmsNetload = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2, 15), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtHsmsNetload.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtHsmsNetload.setDescription('Netload (in Bytes) while performing a backup')
storMgmtHsmsS1Bottleneck = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 2) + (0,1))
if mibBuilder.loadTexts: storMgmtHsmsS1Bottleneck.setDescription('Sending a TRAP, if the agent sees the message HSM0468 for S1 bottleneck')
storMgmtMarenCPTask = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenCPTask.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenCPTask.setDescription('Is MARENCP running?')
storMgmtMarenUCPTask = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenUCPTask.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenUCPTask.setDescription('Is MARENUCP running?')
storMgmtMarenCatConn = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("spd", 1), ("rfalocal", 2), ("rfaremote", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenCatConn.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenCatConn.setDescription('Type of connection to the MAREN catalogue; the access to the catalogue is possible via a shared privat disk or via a RFA connection (local or remote)')
storMgmtMarenConnState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenConnState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenConnState.setDescription('Is connection to the MAREN catalogue active/inactive?')
storMgmtMarenLocTabNum = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 5), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenLocTabNum.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenLocTabNum.setDescription('The number of entries in the table storMgmtMarenLocTable')
storMgmtMarenLocTable = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 6), )
if mibBuilder.loadTexts: storMgmtMarenLocTable.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenLocTable.setDescription('List of available MAREN locations')
storMgmtMarenLocEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 6, 1), ).setIndexNames((0, "Storage-Management-MIB", "storMgmtMarenLocIndex"))
if mibBuilder.loadTexts: storMgmtMarenLocEntry.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenLocEntry.setDescription('An entry in the table')
storMgmtMarenLocIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 6, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenLocIndex.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenLocIndex.setDescription('A unique value for each entry, its value ranges between 1 and the value of storMgmtMarenLocTabNum')
storMgmtMarenLocName = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 6, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenLocName.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenLocName.setDescription('Name of the location, e.g. ROBOTER1 or FIREARCH')
storMgmtMarenLocOpmode = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 6, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenLocOpmode.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenLocOpmode.setDescription('Operating mode e.g. TLS-1 or ROBAR-1')
storMgmtMarenLocFreevol = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 6, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 64))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenLocFreevol.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenLocFreevol.setDescription('Number of free volumes in the specified location; varied according to volumetypes TAPE-Cx')
storMgmtMarenNetworkTabNum = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenNetworkTabNum.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenNetworkTabNum.setDescription('The number of entries in the table storMgmtMarenNetworkTable')
storMgmtMarenNetworkTable = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 8), )
if mibBuilder.loadTexts: storMgmtMarenNetworkTable.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenNetworkTable.setDescription('List of hosts belonging to the same MAREN network as the current host')
storMgmtMarenNetworkEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 8, 1), ).setIndexNames((0, "Storage-Management-MIB", "storMgmtMarenNetworkIndex"))
if mibBuilder.loadTexts: storMgmtMarenNetworkEntry.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenNetworkEntry.setDescription('An entry in the table')
storMgmtMarenNetworkIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 8, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenNetworkIndex.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenNetworkIndex.setDescription('A unique value for each entry, its value ranges between 1 and the value of storMgmtMarenNetworkTabNum')
storMgmtMarenNetworkHost = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3, 8, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtMarenNetworkHost.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtMarenNetworkHost.setDescription('Hostnames belonging to the same MAREN network')
storMgmtMarenNoVolume = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 3) + (0,1))
if mibBuilder.loadTexts: storMgmtMarenNoVolume.setDescription('Sending a TRAP, if the agent sees the message MARUP97 or MARUP98 (no more free volumes available)')
storMgmtTlsTabNum = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtTlsTabNum.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsTabNum.setDescription('The number of entries in the table storMgmtTlsTable')
storMgmtTlsTable = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 2), )
if mibBuilder.loadTexts: storMgmtTlsTable.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsTable.setDescription('The Storage management information table')
storMgmtTlsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 2, 1), ).setIndexNames((0, "Storage-Management-MIB", "storMgmtTlsIndex"))
if mibBuilder.loadTexts: storMgmtTlsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsEntry.setDescription('An entry in the table')
storMgmtTlsIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtTlsIndex.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsIndex.setDescription('A unique value for each entry, its value ranges between 1 and the value of storMgmtTlsTabNum')
storMgmtTlsRobState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 2, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("automatic", 1), ("pause", 2), ("manual", 3), ("off", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtTlsRobState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsRobState.setDescription('Roboter state can be: automatic mode, pause mode, manual mode or off')
storMgmtTlsFreeboxno = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 2, 1, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtTlsFreeboxno.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsFreeboxno.setDescription('Number of free storage boxes in the archive')
storMgmtTlsCleanno = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 2, 1, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtTlsCleanno.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsCleanno.setDescription('Number of available cleaning cartridges')
storMgmtTlsLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4, 2, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtTlsLocation.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtTlsLocation.setDescription('Location(s) for devices supported by the robot system')
storMgmtTlsOffline = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 4) + (0,1))
if mibBuilder.loadTexts: storMgmtTlsOffline.setDescription('Sending a TRAP, if the agent sees the message EXC0858 (no connection to robot)')
storMgmtRobarTabNum = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtRobarTabNum.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarTabNum.setDescription('The number of entries in the table storMgmtRobarTab')
storMgmtRobarTable = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2), )
if mibBuilder.loadTexts: storMgmtRobarTable.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarTable.setDescription('The Storage management information table')
storMgmtRobarEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1), ).setIndexNames((0, "Storage-Management-MIB", "storMgmtRobarIndex"))
if mibBuilder.loadTexts: storMgmtRobarEntry.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarEntry.setDescription('An entry in the table')
storMgmtRobarIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtRobarIndex.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarIndex.setDescription('A unique value for each entry, its value ranges between 1 and the value of storMgmtRobarTabNum')
storMgmtRobarLocation = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtRobarLocation.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarLocation.setDescription('Current ROBAR location')
storMgmtRobarState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("running", 1), ("terminated", 2), ("aborted", 3), ("loaded", 4), ("in-hold", 5), ("not-installed", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtRobarState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarState.setDescription('Is ROBAR-DCAM running, stopped or even not installed?')
storMgmtRobarVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtRobarVersion.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarVersion.setDescription('Current ROBAR version')
storMgmtRobarConnState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("active", 1), ("inactive", 2), ("not-available", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtRobarConnState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarConnState.setDescription('Check connection between ROBAR-BS2000 and ROBAR-SINIX')
storMgmtRobarRobState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("on", 1), ("off", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtRobarRobState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarRobState.setDescription('Roboter state is ON or OFF')
storMgmtRobarRouting = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5, 2, 1, 7), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 63))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtRobarRouting.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtRobarRouting.setDescription('Current routing codes for ROBAR-DCAM')
storMgmtRobarBs2Messages = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 20, 1, 5) + (0,1))
if mibBuilder.loadTexts: storMgmtRobarBs2Messages.setDescription('Sending a TRAP, if the agent sees predefined BS2000 messages like ROB0042 (ROB ON), ROB0043 (ROB OFF), ROB2000 (Connect ok), ROB2001 (Connect not ok), ...')
storMgmtResourcePubset = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 2, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtResourcePubset.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtResourcePubset.setDescription('Catalogue ID of the specified pubset')
storMgmtResourceSaturation = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 2, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("level-0", 1), ("level-1", 2), ("level-2", 3), ("level-3", 4), ("level-4", 5), ("level-5", 6), ("unknown-level", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtResourceSaturation.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtResourceSaturation.setDescription('Saturation level for the specified pubset')
storMgmtResourceCapacity = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 2, 3), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtResourceCapacity.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtResourceCapacity.setDescription('Capacity of the specified pubset in half pages')
storMgmtResourceSpaceAllocated = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 2, 4), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtResourceSpaceAllocated.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtResourceSpaceAllocated.setDescription('Allocated space of the specified pubset in half pages')
storMgmtResourceFragment = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 2, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 31))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtResourceFragment.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtResourceFragment.setDescription('Degree of fragmentation')
storMgmtResourceReusableS1 = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 2, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtResourceReusableS1.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtResourceReusableS1.setDescription('Information is: number of save files, number of occupied PAM pages according to save files, number of unused PAM pages')
storMgmtResourceSecureQueue = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 2, 7), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtResourceSecureQueue.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtResourceSecureQueue.setDescription('The number of tasks waiting in the SECURE queue')
storMgmtPubsetTabNum = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetTabNum.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetTabNum.setDescription('The number of entries in the table storMgmtPubsetTable')
storMgmtPubsetTabState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17))).clone(namedValues=NamedValues(("all", 1), ("paging", 2), ("local", 3), ("remote", 4), ("accessible", 5), ("local-accessible", 6), ("shared", 7), ("exclusive", 8), ("remote-accessible", 9), ("local-accessible-speedcat", 10), ("xcs-pubset", 11), ("hsms-supported", 12), ("single-feature", 13), ("system-managed", 14), ("volume-sets", 15), ("unused-volsets", 16), ("master-change-error", 17)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtPubsetTabState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetTabState.setDescription('State of Pubsets to be shown in the storMgmtPubsetTable ')
storMgmtPubsetTable = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10), )
if mibBuilder.loadTexts: storMgmtPubsetTable.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetTable.setDescription('The Pubset information table')
storMgmtPubsetEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1), ).setIndexNames((0, "Storage-Management-MIB", "storMgmtPubsetIndex"))
if mibBuilder.loadTexts: storMgmtPubsetEntry.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetEntry.setDescription('An entry in the table')
storMgmtPubsetIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 1), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetIndex.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetIndex.setDescription('A unique value for each entry, its value is the CATID of the Pubset storMgmtPubsetIndex ')
storMgmtPubsetTyp = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("single-feature", 1), ("system-managed", 2), ("volumeset", 3), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetTyp.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetTyp.setDescription('Type of the Pubset')
storMgmtPubsetLocal = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("local", 1), ("remote", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetLocal.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetLocal.setDescription('Local / remote Pubset')
storMgmtPubsetHome = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("home", 1), ("imported", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetHome.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetHome.setDescription('Home / imported Pubset')
storMgmtPubsetShared = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("shared", 1), ("exclusive", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetShared.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetShared.setDescription('shared / exclusive Pubset')
storMgmtPubsetMaster = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetMaster.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetMaster.setDescription('Master / slave Pubset')
storMgmtPubsetAccessible = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("accessible", 1), ("inaccessible", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetAccessible.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetAccessible.setDescription('accessible / inaccessible Pubset')
storMgmtPubsetQuiet = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetQuiet.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetQuiet.setDescription('quiet Pubset')
storMgmtPubsetPaging = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("yes", 1), ("no", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetPaging.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetPaging.setDescription('paging Pubset')
storMgmtPubsetSize = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 12), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetSize.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetSize.setDescription('Size of Pubset')
storMgmtPubsetUsedSize = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 13), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetUsedSize.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetUsedSize.setDescription('used space of Pubset')
storMgmtPubsetSaturationLevel = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 3, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7))).clone(namedValues=NamedValues(("level-0", 1), ("level-1", 2), ("level-2", 3), ("level-3", 4), ("level-4", 5), ("level-5", 6), ("unknown-level", 7)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtPubsetSaturationLevel.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtPubsetSaturationLevel.setDescription('Saturation level for the specified pubset')
storMgmtDiskTabNum = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskTabNum.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskTabNum.setDescription('The number of entries in the table storMgmtDiskTable')
storMgmtDiskTabReconfState = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("all", 1), ("attached", 2), ("detached", 3), ("other", 255)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtDiskTabReconfState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskTabReconfState.setDescription('The reconfiguration state of disks to be shown ')
storMgmtDiskTable = MibTable((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10), )
if mibBuilder.loadTexts: storMgmtDiskTable.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskTable.setDescription('The Disk information table')
storMgmtDiskEntry = MibTableRow((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1), ).setIndexNames((0, "Storage-Management-MIB", "storMgmtDiskIndex"))
if mibBuilder.loadTexts: storMgmtDiskEntry.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskEntry.setDescription('An entry in the table')
storMgmtDiskIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 4))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskIndex.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskIndex.setDescription('A unique value for each entry, its value is the Mnemonic of the Disk ')
storMgmtDiskVSN = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 2), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 6))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskVSN.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskVSN.setDescription('VSN of Disk ')
storMgmtDiskDeviceAllocState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 255))).clone(namedValues=NamedValues(("free", 1), ("allocated", 2), ("exclusive-allocated", 3), ("current-public-assigned", 4), ("dms-used-volume-assigned", 5), ("drv-assigned", 6), ("drv-public-assigned", 7), ("drv-dms-used-volume-assigned", 8), ("invalid", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskDeviceAllocState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskDeviceAllocState.setDescription('Device Allocation State ')
storMgmtDiskSystemUse = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("paging-device", 1), ("public-device", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskSystemUse.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskSystemUse.setDescription('Type of the Disk')
storMgmtDiskPoolAttribut = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("shared-privat-disk", 1), ("device-switchable", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskPoolAttribut.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskPoolAttribut.setDescription('Local / remote Disk')
storMgmtDiskReconfState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("attached", 1), ("detach-pending", 2), ("detached", 3), ("assignment-in-progress", 4), ("invalid", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskReconfState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskReconfState.setDescription('Reconfiguration State ')
storMgmtDiskVolAllocState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 255))).clone(namedValues=NamedValues(("free", 1), ("task-exclusive", 2), ("task-sharable", 3), ("current-public", 4), ("current-paging", 5), ("volume-cancelled", 6), ("volume-allocated", 7), ("invalid", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskVolAllocState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskVolAllocState.setDescription('Volume Allocation State ')
storMgmtDiskPrivDiskRunState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 255))).clone(namedValues=NamedValues(("offline", 1), ("active", 2), ("inactive", 3), ("end-in-process", 4), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskPrivDiskRunState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskPrivDiskRunState.setDescription('Private Disk Run State ')
storMgmtDiskPhaseSet = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("online-only", 1), ("premounting", 2), ("mounting", 3), ("in-use", 4), ("not-specified", 5), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskPhaseSet.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskPhaseSet.setDescription('Phase Set')
storMgmtDiskActionState = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 255))).clone(namedValues=NamedValues(("no-action", 1), ("inoperable", 2), ("remount", 3), ("cancelled", 4), ("no-device-available", 5), ("recover", 6), ("positioning", 7), ("writepermission-missing", 8), ("unlock", 9), ("svl-update", 10), ("dismount", 11), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskActionState.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskActionState.setDescription('Action State')
storMgmtDiskUse = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 255))).clone(namedValues=NamedValues(("dms", 1), ("special", 2), ("work", 3), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskUse.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskUse.setDescription(' Disk Use ')
storMgmtDiskAssignTime = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("standard", 1), ("user", 2), ("user-by-default", 3), ("operator", 4), ("operator-by-default", 5), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskAssignTime.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskAssignTime.setDescription('Assign Time ')
storMgmtDiskUserAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("standard", 1), ("shared", 2), ("shared-by-default", 3), ("exclusive", 4), ("exclusive-by-default", 5), ("no", 6), ("no-by-default", 7), ("all", 8), ("all-by-default", 9), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskUserAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskUserAllocation.setDescription('User Allocation ')
storMgmtDiskOperatorControl = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 255))).clone(namedValues=NamedValues(("standard", 1), ("shared", 2), ("shared-by-default", 3), ("exclusive", 4), ("exclusive-by-default", 5), ("no", 6), ("no-by-default", 7), ("all", 8), ("all-by-default", 9), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskOperatorControl.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskOperatorControl.setDescription('Operator Control ')
storMgmtDiskSystemAllocation = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("shared", 1), ("exclusive", 2), ("all", 3), ("current-shared", 4), ("current-exclusive", 5), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskSystemAllocation.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskSystemAllocation.setDescription('Sytem Allocation ')
storMgmtDiskAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 255))).clone(namedValues=NamedValues(("write", 1), ("ppd", 2), ("from-device", 3), ("write-from-device", 4), ("ppd-from-device", 5), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskAccess.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskAccess.setDescription('Disk Access ')
storMgmtDiskRecordingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 231, 2, 20, 4, 10, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 255))).clone(namedValues=NamedValues(("single-recording", 1), ("dual-recording-by-volume", 2), ("unknown", 255)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtDiskRecordingMode.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtDiskRecordingMode.setDescription('Disk Recording Mode')
storMgmtGlobalDataVersion = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 18, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 8))).setMaxAccess("readonly")
if mibBuilder.loadTexts: storMgmtGlobalDataVersion.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtGlobalDataVersion.setDescription('Version of subagent ')
storMgmtGlobalDataInputFile = MibScalar((1, 3, 6, 1, 4, 1, 231, 2, 20, 18, 2), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: storMgmtGlobalDataInputFile.setStatus('mandatory')
if mibBuilder.loadTexts: storMgmtGlobalDataInputFile.setDescription('Filename of input file ')
storMgmtPubsetSatLevTrap = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 20, 20) + (0,301)).setObjects(("Storage-Management-MIB", "storMgmtPubsetIndex"), ("Storage-Management-MIB", "storMgmtPubsetSaturationLevel"))
if mibBuilder.loadTexts: storMgmtPubsetSatLevTrap.setDescription('Saturation level x reached')
storMgmtDiskReconfStateTrap = NotificationType((1, 3, 6, 1, 4, 1, 231, 2, 20, 21) + (0,301)).setObjects(("Storage-Management-MIB", "storMgmtDiskIndex"), ("Storage-Management-MIB", "storMgmtDiskReconfState"))
if mibBuilder.loadTexts: storMgmtDiskReconfStateTrap.setDescription('DiskReconfstate x reached')
mibBuilder.exportSymbols("Storage-Management-MIB", storMgmtPubsetLocal=storMgmtPubsetLocal, storMgmtHsmsServertask=storMgmtHsmsServertask, storMgmtMarenCPTask=storMgmtMarenCPTask, sniStorMgmtDiskInfo=sniStorMgmtDiskInfo, storMgmtRobarRouting=storMgmtRobarRouting, storMgmtHsmsStimeRead=storMgmtHsmsStimeRead, storMgmtPubsetQuiet=storMgmtPubsetQuiet, storMgmtMarenLocOpmode=storMgmtMarenLocOpmode, storMgmtTlsIndex=storMgmtTlsIndex, storMgmtDiskActionState=storMgmtDiskActionState, sniStorMgmtGlobalData=sniStorMgmtGlobalData, storMgmtHsmsWaitReqsExpress=storMgmtHsmsWaitReqsExpress, storMgmtResourceSpaceAllocated=storMgmtResourceSpaceAllocated, storMgmtHsmsAcceptReqs=storMgmtHsmsAcceptReqs, storMgmtPubsetEntry=storMgmtPubsetEntry, storMgmtHsmsInterruptReqs=storMgmtHsmsInterruptReqs, storMgmtDiskPhaseSet=storMgmtDiskPhaseSet, storMgmtDiskVolAllocState=storMgmtDiskVolAllocState, storMgmtPubsetSatLevTrap=storMgmtPubsetSatLevTrap, storMgmtDiskAssignTime=storMgmtDiskAssignTime, sniStorMgmtTlsInfo=sniStorMgmtTlsInfo, storMgmtPubsetHome=storMgmtPubsetHome, storMgmtHsmsWaitReqsWrite=storMgmtHsmsWaitReqsWrite, storMgmtProductEntry=storMgmtProductEntry, storMgmtPubsetSaturationLevel=storMgmtPubsetSaturationLevel, storMgmtMarenConnState=storMgmtMarenConnState, storMgmtHsmsStimeWrite=storMgmtHsmsStimeWrite, storMgmtProductState=storMgmtProductState, storMgmtMarenNetworkHost=storMgmtMarenNetworkHost, storMgmtRobarTabNum=storMgmtRobarTabNum, storMgmtTlsTable=storMgmtTlsTable, storMgmtDiskPoolAttribut=storMgmtDiskPoolAttribut, storMgmtHsmsCompleteReqs=storMgmtHsmsCompleteReqs, storMgmtMarenLocName=storMgmtMarenLocName, storMgmtPubsetTyp=storMgmtPubsetTyp, storMgmtHsmsModeTimestamp=storMgmtHsmsModeTimestamp, sniStorMgmtProductInfo=sniStorMgmtProductInfo, storMgmtDiskSystemAllocation=storMgmtDiskSystemAllocation, storMgmtHsmsOpmode=storMgmtHsmsOpmode, storMgmtTlsLocation=storMgmtTlsLocation, storMgmtDiskIndex=storMgmtDiskIndex, sniProductMibs=sniProductMibs, storMgmtMarenNetworkIndex=storMgmtMarenNetworkIndex, storMgmtTlsRobState=storMgmtTlsRobState, storMgmtDiskPrivDiskRunState=storMgmtDiskPrivDiskRunState, storMgmtMarenNetworkTabNum=storMgmtMarenNetworkTabNum, storMgmtDiskOperatorControl=storMgmtDiskOperatorControl, storMgmtPubsetUsedSize=storMgmtPubsetUsedSize, storMgmtPubsetShared=storMgmtPubsetShared, storMgmtTlsCleanno=storMgmtTlsCleanno, storMgmtMarenLocTabNum=storMgmtMarenLocTabNum, storMgmtPubsetPaging=storMgmtPubsetPaging, storMgmtDiskTabNum=storMgmtDiskTabNum, storMgmtTlsOffline=storMgmtTlsOffline, storMgmtHsmsWaitJobs=storMgmtHsmsWaitJobs, storMgmtResourceSecureQueue=storMgmtResourceSecureQueue, storMgmtRobarIndex=storMgmtRobarIndex, storMgmtRobarEntry=storMgmtRobarEntry, storMgmtProductIndex=storMgmtProductIndex, storMgmtHsmsInstances=storMgmtHsmsInstances, sniStorMgmtDiskTraps=sniStorMgmtDiskTraps, storMgmtPubsetTable=storMgmtPubsetTable, storMgmtHsmsStimeExpress=storMgmtHsmsStimeExpress, storMgmtProductVersion=storMgmtProductVersion, sniStorMgmtRobarInfo=sniStorMgmtRobarInfo, storMgmtMarenLocTable=storMgmtMarenLocTable, sniStorMgmtPubsetInfo=sniStorMgmtPubsetInfo, storMgmtDiskUserAllocation=storMgmtDiskUserAllocation, storMgmtPubsetSize=storMgmtPubsetSize, storMgmtProductName=storMgmtProductName, storMgmtProductTabNum=storMgmtProductTabNum, storMgmtRobarRobState=storMgmtRobarRobState, storMgmtDiskAccess=storMgmtDiskAccess, storMgmtMarenLocEntry=storMgmtMarenLocEntry, storMgmtDiskSystemUse=storMgmtDiskSystemUse, storMgmtGlobalDataVersion=storMgmtGlobalDataVersion, storMgmtRobarConnState=storMgmtRobarConnState, sniStorMgmtAvailInfo=sniStorMgmtAvailInfo, storMgmtMarenNetworkEntry=storMgmtMarenNetworkEntry, storMgmtDiskTabReconfState=storMgmtDiskTabReconfState, storMgmtRobarState=storMgmtRobarState, storMgmtTlsTabNum=storMgmtTlsTabNum, storMgmtResourceFragment=storMgmtResourceFragment, storMgmtProductTimestamp=storMgmtProductTimestamp, sniStorMgmtMarenInfo=sniStorMgmtMarenInfo, storMgmtPubsetIndex=storMgmtPubsetIndex, storMgmtDiskReconfState=storMgmtDiskReconfState, storMgmtTlsEntry=storMgmtTlsEntry, storMgmtResourceSaturation=storMgmtResourceSaturation, storMgmtPubsetAccessible=storMgmtPubsetAccessible, storMgmtResourceCapacity=storMgmtResourceCapacity, storMgmtDiskVSN=storMgmtDiskVSN, storMgmtMarenNetworkTable=storMgmtMarenNetworkTable, storMgmtMarenCatConn=storMgmtMarenCatConn, storMgmtResourceReusableS1=storMgmtResourceReusableS1, storMgmtMarenLocIndex=storMgmtMarenLocIndex, sni=sni, storMgmtDiskReconfStateTrap=storMgmtDiskReconfStateTrap, sniStorMgmtPubsetTraps=sniStorMgmtPubsetTraps, storMgmtMarenNoVolume=storMgmtMarenNoVolume, storMgmtDiskUse=storMgmtDiskUse, storMgmtPubsetTabState=storMgmtPubsetTabState, storMgmtMarenLocFreevol=storMgmtMarenLocFreevol, storMgmtRobarBs2Messages=storMgmtRobarBs2Messages, sniStorMgmtHsmsInfo=sniStorMgmtHsmsInfo, sniStorMgmtResourceInfo=sniStorMgmtResourceInfo, storMgmtHsmsS1Bottleneck=storMgmtHsmsS1Bottleneck, storMgmtDiskTable=storMgmtDiskTable, storMgmtMarenUCPTask=storMgmtMarenUCPTask, storMgmtDiskRecordingMode=storMgmtDiskRecordingMode, storMgmtPubsetTabNum=storMgmtPubsetTabNum, storMgmtHsmsWaitReqsRead=storMgmtHsmsWaitReqsRead, storMgmtResourcePubset=storMgmtResourcePubset, storMgmtTlsFreeboxno=storMgmtTlsFreeboxno, storMgmtRobarVersion=storMgmtRobarVersion, sniStorMgmt=sniStorMgmt, storMgmtPubsetMaster=storMgmtPubsetMaster, storMgmtRobarTable=storMgmtRobarTable, storMgmtRobarLocation=storMgmtRobarLocation, storMgmtProductTable=storMgmtProductTable, storMgmtHsmsNetload=storMgmtHsmsNetload, storMgmtDiskDeviceAllocState=storMgmtDiskDeviceAllocState, storMgmtGlobalDataInputFile=storMgmtGlobalDataInputFile, storMgmtDiskEntry=storMgmtDiskEntry)

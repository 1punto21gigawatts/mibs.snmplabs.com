#
# PySNMP MIB module HM2-L2REDUNDANCY-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/HM2-L2REDUNDANCY-MIB
# Produced by pysmi-0.3.4 at Wed May  1 13:31:34 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueSizeConstraint, ValueRangeConstraint, SingleValueConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueSizeConstraint", "ValueRangeConstraint", "SingleValueConstraint", "ConstraintsIntersection", "ConstraintsUnion")
HmEnabledStatus, hm2ConfigurationMibs = mibBuilder.importSymbols("HM2-TC-MIB", "HmEnabledStatus", "hm2ConfigurationMibs")
InterfaceIndexOrZero, = mibBuilder.importSymbols("IF-MIB", "InterfaceIndexOrZero")
InetAddressType, InetAddress = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddressType", "InetAddress")
SnmpAdminString, = mibBuilder.importSymbols("SNMP-FRAMEWORK-MIB", "SnmpAdminString")
ModuleCompliance, NotificationGroup, ObjectGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup", "ObjectGroup")
Unsigned32, NotificationType, Gauge32, Bits, Counter64, MibScalar, MibTable, MibTableRow, MibTableColumn, iso, MibIdentifier, ObjectIdentity, IpAddress, Counter32, ModuleIdentity, TimeTicks, Integer32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "NotificationType", "Gauge32", "Bits", "Counter64", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "iso", "MibIdentifier", "ObjectIdentity", "IpAddress", "Counter32", "ModuleIdentity", "TimeTicks", "Integer32")
MacAddress, DisplayString, RowStatus, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "MacAddress", "DisplayString", "RowStatus", "TextualConvention")
hm2L2RedundancyMib = ModuleIdentity((1, 3, 6, 1, 4, 1, 248, 11, 40))
hm2L2RedundancyMib.setRevisions(('2011-11-23 00:00',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: hm2L2RedundancyMib.setRevisionsDescriptions(('Initial version.',))
if mibBuilder.loadTexts: hm2L2RedundancyMib.setLastUpdated('201111230000Z')
if mibBuilder.loadTexts: hm2L2RedundancyMib.setOrganization('Hirschmann Automation and Control GmbH')
if mibBuilder.loadTexts: hm2L2RedundancyMib.setContactInfo('Postal: Stuttgarter Str. 45-51 72654 Neckartenzlingen Germany Phone: +49 7127 140 E-mail: hac.support@belden.com')
if mibBuilder.loadTexts: hm2L2RedundancyMib.setDescription('Hirschmann Layer 2 Redundancy MIB. Copyright (C) 2011. All Rights Reserved.')
hm2L2RedundancyMibNotifications = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 0))
hm2L2RedundancyMibObjects = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1))
hm2L2RedundancyMibSNMPExtensionGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 3))
hm2MrpMibGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1))
hm2SrmMibGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4))
hm2RingRedMibGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 7))
hm2RingCouplingMibGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8))
hm2RedundantCplConfigMibGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9))
class Hm2CplPortOpState(TextualConvention, Integer32):
    description = '.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))
    namedValues = NamedValues(("not-connected", 1), ("active", 2), ("standby", 3), ("not-applicable", 4))

hm2MrpTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1), )
if mibBuilder.loadTexts: hm2MrpTable.setStatus('current')
if mibBuilder.loadTexts: hm2MrpTable.setDescription('Every entry in this table contains information about a Media Redundancy Protocol (MRP) domain, defined by IEC 62439-2.')
hm2MrpEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1), ).setIndexNames((0, "HM2-L2REDUNDANCY-MIB", "hm2MrpDomainID"))
if mibBuilder.loadTexts: hm2MrpEntry.setStatus('current')
if mibBuilder.loadTexts: hm2MrpEntry.setDescription('An entry in the hm2MrpTable.')
hm2MrpDomainID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 1), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2MrpDomainID.setStatus('current')
if mibBuilder.loadTexts: hm2MrpDomainID.setDescription('Universally unique identifier belongs to the MRP domain which represents a ring.')
hm2MrpDomainName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 2), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpDomainName.setStatus('current')
if mibBuilder.loadTexts: hm2MrpDomainName.setDescription('A logical name for the MRP domain to ease the management of MRP domains.')
hm2MrpRingport1GroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 3), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRingport1GroupID.setStatus('obsolete')
if mibBuilder.loadTexts: hm2MrpRingport1GroupID.setDescription('Unique index to identify the slot number of the ringport 1 in the MRP domain.')
hm2MrpRingport1IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 4), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRingport1IfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRingport1IfIndex.setDescription('Interface index of the ringport 1 in the MRP domain.')
hm2MrpRingport1OperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("blocked", 2), ("forwarding", 3), ("notConnected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpRingport1OperState.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRingport1OperState.setDescription('Operational state of ringport 1. disabled(1) indicates that all frames are dropped. blocked(2) indicates that all frames are dropped except - MRP topology change frames and MRP test frames from a MRM, - MRP link change frames from a MRC, - frames from other protocols that also define to pass blocked(2) ports. forwarding(3) indicates that all frames are passed through according to the forwarding behavior of IEEE 802.1D. notConnected(4) indicates that the port has no link.')
hm2MrpRingport2GroupID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 6), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRingport2GroupID.setStatus('obsolete')
if mibBuilder.loadTexts: hm2MrpRingport2GroupID.setDescription('Unique index to identify the slot number of the ringport 2 in the MRP domain.')
hm2MrpRingport2IfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 7), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRingport2IfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRingport2IfIndex.setDescription('Interface index of the ringport 2 in the MRP domain.')
hm2MrpRingport2OperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("blocked", 2), ("forwarding", 3), ("notConnected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpRingport2OperState.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRingport2OperState.setDescription('Operational state of ringport 2. disabled(1) indicates that all frames are dropped. blocked(2) indicates that all frames are dropped except - MRP topology change frames and MRP test frames from a MRM, - MRP link change frames from a MRC, - frames from other protocols that also define to pass blocked(2) ports. forwarding(3) indicates that all frames are passed through according to the forwarding behavior of IEEE 802.1D. notConnected(4) indicates that the port has no link.')
hm2MrpRoleAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("client", 1), ("manager", 2))).clone('client')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRoleAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRoleAdminState.setDescription('Control the role of the MRP entity in the MRP domain. If the value is set to client(1) the entity will be in the role of a Media Redundancy Client (MRC). If the value is set to manager(2) the entity will be in the role of a Media Redundancy Manager (MRM).')
hm2MrpRoleOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("client", 1), ("manager", 2), ("undefined", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpRoleOperState.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRoleOperState.setDescription("Operational role of the MRP entity in the MRP domain. client(1) indicates that the MRP entity is in a MRC role. manager(2) indicates that the MRP entity is the manager MRM of this MRP domain. undefined(3) indicates that the MRP entity doesn't work.")
hm2MrpRecoveryDelay = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("delay500", 1), ("delay200", 2), ("delay30", 3), ("delay10", 4))).clone('delay200')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRecoveryDelay.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRecoveryDelay.setDescription('The MRM defines with its parameter set the maximum recovery delay of the ring recovery in the MRP domain. delay500(1) specifies the parameter set for the maximum recovery delay of 500ms in the MRP domain. delay200(2) specifies the parameter set for the maximum recovery delay of 200ms in the MRP domain. delay30(3) specifies the parameter set for the maximum recovery delay of 30ms in the MRP domain. delay10(4) specifies the parameter set for the maximum recovery delay of 10ms in the MRP domain.')
hm2MrpRecoveryDelaySupported = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supportedAll", 1), ("supported200500", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpRecoveryDelaySupported.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRecoveryDelaySupported.setDescription('The 10ms and 30ms recovery time put additional restrictions on the cable length and on the reaction time of each client in the MRP ring, so these recovery times may not be supported by a MRP entity. supportedAll(1) indicates that all recovery times in hm2MrpRecoveryDelay are supported by the MRP entity. supported200500(2) indicates that only the recovery times 500ms and 200ms are supported by the MRP entity.')
hm2MrpVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 13), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpVlanID.setStatus('current')
if mibBuilder.loadTexts: hm2MrpVlanID.setDescription('VLAN identifier assigned to the MRP domain. If value is set to 0 no VLAN is assigned.')
hm2MrpMRMPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 14), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(32768)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpMRMPriority.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMPriority.setDescription('Priority of the MRM. A lower value indicates a higher priority.')
hm2MrpMRMReactOnLinkChange = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2))).clone('enabled')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpMRMReactOnLinkChange.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMReactOnLinkChange.setDescription('Specifies whether the MRM reacts on all MRP link change frames or not. enabled(1) indicates that the MRM reacts on all MRP link change frames. disabled(2) indicates that the MRM does not react on link down MRP link change frames.')
hm2MrpMRMRingOpenCount = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 16), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpMRMRingOpenCount.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMRingOpenCount.setDescription('Counter will be incremented when the ring state changes to ring open.')
hm2MrpMRMLastRingOpenChange = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 17), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpMRMLastRingOpenChange.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMLastRingOpenChange.setDescription('The local time at which the ring state last changed to ring open. Measured in seconds since 00:00:00, January 1, 1970.')
hm2MrpMRMRoundTripDelayMax = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 18), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpMRMRoundTripDelayMax.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMRoundTripDelayMax.setDescription("The max. Round-Trip-Delay (in microseconds) which was measured by the MRM since startup or reset. A device which supports only the recovery delays 200ms and 500ms doesn't support the measuring of round-trip-delay.")
hm2MrpMRMRoundTripDelayMin = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 19), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpMRMRoundTripDelayMin.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMRoundTripDelayMin.setDescription("The min. Round-Trip-Delay (in microseconds) which was measured by the MRM since startup or reset. A device which supports only the recovery delays 200ms and 500ms doesn't support the measuring of round-trip-delay.")
hm2MrpMRMRoundTripDelayReset = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("reset", 1)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2MrpMRMRoundTripDelayReset.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMRoundTripDelayReset.setDescription('A write request with reset(1) will reset the values of hm2MrpMRMRoundTripDelayMax and hm2MrpMRMRoundTripDelayMin to zero at the same time.')
hm2MrpMRMNonBlockingMRCSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpMRMNonBlockingMRCSupported.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRMNonBlockingMRCSupported.setDescription('Ability of the MRM to support MRC in the ring which have hm2MrpMRCBlockedSupported set disabled. enabled(1) indicates that the MRM is able to support MRC in the ring which have hm2MrpMRCBlockedSupported set disabled. disabled(2) indicates that the MRM is not able to support MRC in the ring which have hm2MrpMRCBlockedSupported set disabled.')
hm2MrpMRCBlockedSupported = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 22), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enabled", 1), ("disabled", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpMRCBlockedSupported.setStatus('current')
if mibBuilder.loadTexts: hm2MrpMRCBlockedSupported.setDescription('Ability of the MRC to receive and forward MRP test frames, MRP link change frames and MRP topology change frames at a ringport whose port state is blocked. enabled(1) indicates that the MRC is able to receive and forward these MRP frames at a ringport whose port state is blocked. disabled(2) indicates that the MRC is not able to receive and forward these MRP frames at a ringport whose port state is blocked.')
hm2MrpRingOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 23), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("open", 1), ("closed", 2), ("undefined", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpRingOperState.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRingOperState.setDescription('Actual ring state of the MRP redundancy domain. The ring state can only be detected by the MRM. open(1) indicates that the ring is open. closed(2) indicates that the ring is closed. undefined(3) indicates an undefined ring state or is read if hm2MrpRoleOperState indicates the value client.')
hm2MrpRedundancyOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 24), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("available", 1), ("notAvailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpRedundancyOperState.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRedundancyOperState.setDescription('Operational state of ring redundancy in the MRP domain. available(1) indicates that ring redundancy exists in the MRP domain. notAvailable(2) indicates that ring redundancy does not exist in the MRP domain.')
hm2MrpConfigOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 25), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("noError", 1), ("ringportLinkError", 2), ("multipleMRM", 3), ("singleSideReceive", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpConfigOperState.setStatus('current')
if mibBuilder.loadTexts: hm2MrpConfigOperState.setDescription("Operational state of the configuration in the MRP domain. noError(1) indicates that no configuration error was detected. ringportLinkError(2) indicates that one of the ring lines is not connected with one of the ring ports in the MRP domain. multipleMRM(3) indicates multiple active MRM in the ring. singleSideReceive(4) indicates that the MRM has seen it's test frames, but only on one ring port.")
hm2MrpRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 26), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRowStatus.setDescription('Supports creation, deletion and activation of rows. A row must not be active(1) in order to be modified. A row can be taken out of service by writing the value notInService(2).')
hm2MrpRingport2FixedBackup = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 1, 1, 27), HmEnabledStatus().clone('disable')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2MrpRingport2FixedBackup.setStatus('current')
if mibBuilder.loadTexts: hm2MrpRingport2FixedBackup.setDescription('If value is set to enable(1) the ringport 2 at the MRM will always be the backup port. Setting is only relevant if hm2MrpRoleAdminState is set to manager(2).')
hm2MrpConformance = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2))
hm2MrpCompliances = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2, 1))
hm2MrpCompliance = ModuleCompliance((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2, 1, 1)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2MrpDomainBasicGroup"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpDomainManagerGroup"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpNotificationsGroup"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpDomainDiagGroup"))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2MrpCompliance = hm2MrpCompliance.setStatus('current')
if mibBuilder.loadTexts: hm2MrpCompliance.setDescription('Basic implementation requirements for MRP support. The agent shall support the monitoring and control of MRP redundancy domains.')
hm2MrpGroups = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2, 2))
hm2MrpDomainBasicGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2, 2, 1)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2MrpDomainID"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpDomainName"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRingport1IfIndex"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRingport1OperState"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRingport2IfIndex"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRingport2OperState"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRoleAdminState"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRoleOperState"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRecoveryDelay"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRecoveryDelaySupported"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpVlanID"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpMRCBlockedSupported"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRedundancyOperState"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpConfigOperState"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRowStatus"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2MrpDomainBasicGroup = hm2MrpDomainBasicGroup.setStatus('current')
if mibBuilder.loadTexts: hm2MrpDomainBasicGroup.setDescription('Parameters which are necessary to monitor and control the status of MRP domains.')
hm2MrpDomainManagerGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2, 2, 2)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMPriority"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMReactOnLinkChange"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMNonBlockingMRCSupported"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpRingOperState"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2MrpDomainManagerGroup = hm2MrpDomainManagerGroup.setStatus('current')
if mibBuilder.loadTexts: hm2MrpDomainManagerGroup.setDescription('Additional parameters which are necessary to monitor and control the status of a MRM.')
hm2MrpDomainDiagGroup = ObjectGroup((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2, 2, 3)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMRingOpenCount"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMLastRingOpenChange"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMRoundTripDelayMax"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMRoundTripDelayMin"), ("HM2-L2REDUNDANCY-MIB", "hm2MrpMRMRoundTripDelayReset"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2MrpDomainDiagGroup = hm2MrpDomainDiagGroup.setStatus('current')
if mibBuilder.loadTexts: hm2MrpDomainDiagGroup.setDescription('Parameters which are optional to monitor and control the diagnostic status of MRP domains.')
hm2MrpNotificationsGroup = NotificationGroup((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 2, 2, 4)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2MrpReconfig"))
if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    hm2MrpNotificationsGroup = hm2MrpNotificationsGroup.setStatus('current')
if mibBuilder.loadTexts: hm2MrpNotificationsGroup.setDescription('Notifications indicate changes in the MRP ring.')
hm2MrpFastMrp = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("supported", 1), ("notSupported", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2MrpFastMrp.setStatus('current')
if mibBuilder.loadTexts: hm2MrpFastMrp.setDescription('Fast MRP means that MRP supports also maximum recovery times of 30ms or 10ms as defined in IEC 62439-2. supported(1) indicates that the device is able to support fast recovery times for MRP like 30ms or 10ms. notSupported(2) indicates that only the MRP recovery times 500ms and 200ms are supported by the device.')
hm2SrmGlobalAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2SrmGlobalAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2SrmGlobalAdminState.setDescription('Enables or disables the global SRM admin mode.')
hm2SrmMaxInstances = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 2), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SrmMaxInstances.setStatus('current')
if mibBuilder.loadTexts: hm2SrmMaxInstances.setDescription('Maximum number of supported SRM instances in the hm2SrmTable.')
hm2SrmTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3), )
if mibBuilder.loadTexts: hm2SrmTable.setStatus('current')
if mibBuilder.loadTexts: hm2SrmTable.setDescription('Every entry in this table contains information about a Sub-Ring Manager (SRM) domain.')
hm2SrmEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1), ).setIndexNames((0, "HM2-L2REDUNDANCY-MIB", "hm2SrmRingID"))
if mibBuilder.loadTexts: hm2SrmEntry.setStatus('current')
if mibBuilder.loadTexts: hm2SrmEntry.setDescription('Information about a Sub-Ring Manager (SRM) domain.')
hm2SrmRingID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 1), Integer32()).setMaxAccess("accessiblefornotify")
if mibBuilder.loadTexts: hm2SrmRingID.setStatus('current')
if mibBuilder.loadTexts: hm2SrmRingID.setDescription('Identifier of the sub-ring in the SRM domain.')
hm2SrmAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("manager", 1), ("redundantManager", 2), ("singleManager", 3))).clone('manager')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SrmAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2SrmAdminState.setDescription('Admin state of the entity in the SRM domain. If the value is set to manager(1) the entity will be in the role of a Sub-Ring Manager. If the value is set to redundantManager(2) the entity will be in the role of the Sub-Ring Manager which will block its ringport if the sub-ring is closed. If the value is set to singleManager(3) the entity will be in the role of the single-manager which has both ends of a sub-ring connected and will block one of these ends if the sub-ring is closed. Note: Two instances in the hm2SrmTable are needed to build a single-manager where both instances must have singleManager(3) selected. Note: The sub-ring has two managers at the same time. The redundant manager can be designated.')
hm2SrmOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("manager", 1), ("redundantManager", 2), ("singleManager", 3), ("disabled", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SrmOperState.setStatus('current')
if mibBuilder.loadTexts: hm2SrmOperState.setDescription('Operational state of the entity in the SRM domain. manager(1) indicates that the entity is in the role of a Sub-Ring Manager. redundantManager(2) indicates that the entity is in the role of the Sub-Ring Manager which will block its ringport if the sub-ring is closed. singleManager(3) indicates that the entity is in the role of the single manager. disabled(4) indicates that the protocol does not work on the entity.')
hm2SrmVlanID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 4), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 4042))).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SrmVlanID.setStatus('current')
if mibBuilder.loadTexts: hm2SrmVlanID.setDescription('VLAN identifier of the SRM domain. If value is set to 0 no VLAN is assigned.')
hm2SrmMRPDomainID = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16).clone(hexValue="FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF")).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SrmMRPDomainID.setStatus('current')
if mibBuilder.loadTexts: hm2SrmMRPDomainID.setDescription('Only for MRP: Universally unique identifier belongs to the MRP domain which represents a sub- ring.')
hm2SrmPartnerMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 6), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SrmPartnerMAC.setStatus('current')
if mibBuilder.loadTexts: hm2SrmPartnerMAC.setDescription('The MAC address of the partner Sub-Ring Manager in the same sub-ring domain.')
hm2SrmSubRingProtocol = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(4))).clone(namedValues=NamedValues(("iec-62439-mrp", 4))).clone('iec-62439-mrp')).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SrmSubRingProtocol.setStatus('current')
if mibBuilder.loadTexts: hm2SrmSubRingProtocol.setDescription('If the value is set to iec-62439-mrp(4) the Entity will run the MRP protocol. Note: If using iec-62439-mrp(4) all clients in The sub-ring segment must run MRP according To IEC 62439.')
hm2SrmSubRingName = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 8), SnmpAdminString()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SrmSubRingName.setStatus('current')
if mibBuilder.loadTexts: hm2SrmSubRingName.setDescription('Name of the sub-ring in the SRM domain.')
hm2SrmSubRingPortIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 9), Integer32()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SrmSubRingPortIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2SrmSubRingPortIfIndex.setDescription('Interface index of sub-ring port in the SRM domain.')
hm2SrmSubRingPortOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("disabled", 1), ("blocked", 2), ("forwarding", 3), ("not-connected", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SrmSubRingPortOperState.setStatus('current')
if mibBuilder.loadTexts: hm2SrmSubRingPortOperState.setDescription('Operational state of sub-ring port. disabled(1) indicates that all frames are dropped. blocked(2) indicates that all frames are dropped except - frames used by the selected ring protocol which are defined to pass blocked(2) ports, - frames from other protocols which are Defined to pass blocked(2) ports. forwarding(3) indicates that all frames are passed through according to the forwarding behavior of IEEE 802.1D. not-connected(4) indicates that the port has no link.')
hm2SrmSubRingOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("undefined", 1), ("open", 2), ("closed", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SrmSubRingOperState.setStatus('current')
if mibBuilder.loadTexts: hm2SrmSubRingOperState.setDescription('Operational state of the sub-ring in the SRM domain. undefined(1) indicates an undefined sub-ring state. open(2) indicates that the sub-ring is opened. closed(3) indicates that the sub-ring is closed.')
hm2SrmRedundancyOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redGuaranteed", 1), ("redNotGuaranteed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SrmRedundancyOperState.setStatus('current')
if mibBuilder.loadTexts: hm2SrmRedundancyOperState.setDescription('Operational state of the ring redundancy in The SRM domain. redGuaranteed(1) indicates that ring redundancy is guaranteed in the SRM domain. redNotGuaranteed(2) indicates that ring redundancy is not guaranteed in the SRM domain.')
hm2SrmConfigOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9))).clone(namedValues=NamedValues(("noError", 1), ("ringPortLinkError", 2), ("multipleSRM", 3), ("noPartnerManager", 4), ("concurrentVLAN", 5), ("concurrentPort", 6), ("concurrentRedundancy", 7), ("trunkMember", 8), ("sharedVLAN", 9)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2SrmConfigOperState.setStatus('current')
if mibBuilder.loadTexts: hm2SrmConfigOperState.setDescription('Operational state of the configuration in the SRM domain. noError(1) indicates that no configuration error was detected. ringPortLinkError(2) indicates that the ring port has no link or one of the sub- ring lines is not connected with one of the ring ports of the entity but to another port of the entity. multipleSRM(3) indicates that the Sub-Ring Manager receives frames from more than one Sub-Ring Managers in the sub-ring. noPartnerManager(4) indicates that the Sub-Ring Manager receives his own frames. concurrentVLAN(5) indicates that the VLAN of the SRM domain is used by MRP in the basis ring. concurrentPort(6) indicates that the ringport of the SRM domain is used by another redundancy protocol. concurrentRedundancy(7) indicates the SRM domain is not active because of another active redundancy protocol. trunkMember(8) indicates that the ringport of the SRM domain is member of a trunk. sharedVLAN(9) indicates the SRM domain cannot be active because Shared VLAN is active and MRP is used in the basis ring too.')
hm2SrmRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 4, 3, 1, 20), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2SrmRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2SrmRowStatus.setDescription('Defines the status of the SRM database entry.')
hm2RingRedAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 7, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingRedAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2RingRedAdminState.setDescription('Enables or disables the global (HIPER)Ring Redundancy admin mode.')
hm2RingRedMode = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 7, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("ring-switch", 1))).clone('ring-switch')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingRedMode.setStatus('current')
if mibBuilder.loadTexts: hm2RingRedMode.setDescription('The mode (HIPER)Ring Redundancy is configured.')
hm2RingRedPrimaryIntf = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 7, 3), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingRedPrimaryIntf.setStatus('current')
if mibBuilder.loadTexts: hm2RingRedPrimaryIntf.setDescription('Interface index of the primary interface.')
hm2RingRedPrimaryIntfState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 7, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-available", 1), ("active", 2), ("inactive", 3))).clone('not-available')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingRedPrimaryIntfState.setStatus('current')
if mibBuilder.loadTexts: hm2RingRedPrimaryIntfState.setDescription('Operational state of the primary ring port. The port states are as follows, active - port is logically up and active. inactive - port is logically down. not-available - no Hiper Ring instance is running, check prerequisites.')
hm2RingRedSecondaryIntf = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 7, 5), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingRedSecondaryIntf.setStatus('current')
if mibBuilder.loadTexts: hm2RingRedSecondaryIntf.setDescription('Interface index of the secondary interface.')
hm2RingRedSecondaryIntfState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 7, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("not-available", 1), ("active", 2), ("inactive", 3))).clone('not-available')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingRedSecondaryIntfState.setStatus('current')
if mibBuilder.loadTexts: hm2RingRedSecondaryIntfState.setDescription('Operational state of the secondary ring port. The port states are as follows, active - port is logically up and active. inactive - port is logically down. not-available - no Hiper Ring instance is running, check prerequisites.')
hm2RingCouplingTable = MibTable((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1), )
if mibBuilder.loadTexts: hm2RingCouplingTable.setStatus('current')
if mibBuilder.loadTexts: hm2RingCouplingTable.setDescription('This table contains variables to define an entry in the ring coupling database.')
hm2RingCouplingEntry = MibTableRow((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1), ).setIndexNames((0, "HM2-L2REDUNDANCY-MIB", "hm2RingCplInterconnIfIndex"))
if mibBuilder.loadTexts: hm2RingCouplingEntry.setStatus('current')
if mibBuilder.loadTexts: hm2RingCouplingEntry.setDescription('The entry of the hm2RingCouplingTable.')
hm2RingCplInterconnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 1), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingCplInterconnIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplInterconnIfIndex.setDescription('Interface index of the coupling link. Note that only those ports can be chosen which do not belong to another L2 redundancy mechanism like ring redundancy or dual homing and that row creation is only done by writing to hm2RingCplRowStatus.')
hm2RingCplInterconnIfOpState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 2), Hm2CplPortOpState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplInterconnIfOpState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplInterconnIfOpState.setDescription('Operational state of the coupling interface. active(2) indicates that the port is switching. standby(3) indicates that the port is in standby mode. On the slave active(2) indicates that a ring coupling failure has occured and the port is switching. On the slave standby(3) indicates that the ring coupling is ok and the slave is in standby mode.')
hm2RingCplControlIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 3), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingCplControlIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplControlIfIndex.setDescription('Interface index of the control link in case of outband-control. Note that only those ports can be chosen which do not belong to another L2 redundancy mechanism like ring redundancy or dual homing and that row creation is only done by writing to hm2RingCplRowStatus.')
hm2RingCplControlIfOpState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 4), Hm2CplPortOpState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplControlIfOpState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplControlIfOpState.setDescription('Operational state of the control interface in case of outband-control.')
hm2RingCplPartnerInterconnIfIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 5), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingCplPartnerInterconnIfIndex.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplPartnerInterconnIfIndex.setDescription('Interface index identifies the coupling link of the partner in the ring coupling. This variable can only be set if the hm2RingCplControlMode is local(4).')
hm2RingCplPartnerInterconnIfOpState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 6), Hm2CplPortOpState()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplPartnerInterconnIfOpState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplPartnerInterconnIfOpState.setDescription('Operational state of the coupling interface of the partner in the ring coupling. active(2) indicates that the partner port is switching. standby(3) indicates that the partner port is in standby mode.')
hm2RingCplPartnerIpAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 7), InetAddressType().clone('ipv4')).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplPartnerIpAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplPartnerIpAddrType.setDescription('Partner IP Address type.')
hm2RingCplPartnerIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 8), InetAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplPartnerIpAddr.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplPartnerIpAddr.setDescription('IP Address of the partner in the ring coupling.')
hm2RingCplCouplingMode = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6))).clone(namedValues=NamedValues(("single", 1), ("dual-master-inband", 2), ("dual-master-outband", 3), ("dual-slave-inband", 4), ("dual-slave-outband", 5), ("unknown", 6)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingCplCouplingMode.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplCouplingMode.setDescription("Ring-coupling operating mode . In single(1) mode both coupling ports are local to the switch, switch performs master and slave functions. In dual-master-inband(2) mode second coupling port is on a remote switch, local switch is master, communication over network. In dual-master-outband(3) mode second coupling port is on a remote switch, local switch is master, communication over dedicated control port. In dual-slave-inband(4) mode second coupling port is on a remote switch, local switch is slave, communication over network. In dual-slave-outband(5) mode second coupling port is on a remote switch, local switch is slave, communication over dedicated control port. unknown(6) cannot be set,it's returned when no mode is configured.")
hm2RingCplControlModeOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("outband", 1), ("inband", 2), ("unknown", 3), ("local", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplControlModeOperState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplControlModeOperState.setDescription('Control mode of the ring coupling which can only be chosen by the slave, the master just reports his current control mode. unknown(3) cannot be set. In outband(1) mode an additional line must connect the control interfaces between the two partners in the ring coupling. In inband(2) mode only the coupling link port is needed. In local(4) mode the coupling link port and the partner port are located on the same switch.')
hm2RingCplModeOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("slaveOff", 1), ("slaveOn", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplModeOperState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplModeOperState.setDescription('Mode of operation . slaveOn(2) slave is activated. slaveOff(1) slave is deactivated, the ring coupling is disabled and the switch acts from now in normal rs mode.')
hm2RingCplOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("underCreation", 1), ("slave", 2), ("master", 3), ("local", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplOperState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplOperState.setDescription('Operational state of an entry. If a new entry is created by setting hm2RingCplRowStatus to create(1), the operState returns a value of underCreation(1). slave(2) indicates that switch is configured to be the slave of the ring coupling, that means the switch is in standby mode. master(3) indicates that a switch is configured to be the master of the ring coupling. local(4) indicates that the switch is configured to control a ring coupling where the coupling port and the partner port are located on the same switch.')
hm2RingCplConfigOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))).clone(namedValues=NamedValues(("noError", 1), ("slaveCouplingLinkError", 2), ("slaveControlLinkError", 3), ("masterControlLinkError", 4), ("twoSlaves", 5), ("localPartnerLinkError", 6), ("localInvalidCouplingPort", 7), ("couplingPortNotAvailable", 8), ("controlPortNotAvailable", 9), ("partnerPortNotAvailable", 10)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplConfigOperState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplConfigOperState.setDescription('Operational state of the ring coupling configuration. slaveCouplingLinkError(2) indicates that the coupling link is not connected with the coupling port of the slave but with another port of the slave. In case of outband control additional failures can be detected: slaveControlLinkError(3) indicates that the control port of the slave has either no link or the link fails. masterControlLinkError(4) indicates that the control link is not connected with the control port of the master but with another port of the master. twoSlaves(5) is returned when two slaves are connected by the control line. localPartnerLinkError(6) indicates that the partner coupling link is not connected with the partner port of the slave but with another port of the slave in local control mode. localInvalidCouplingPort(7) indicates that in local mode the coupling line is connected to another switch and not on the same switch like the partner line. couplingPortNotAvailable(8), controlPortNotAvailable(9) and partnerPortNotAvailable(10) indicate that this port is not available because the module related to this port is not available or the port does not exist on this module.')
hm2RingCplCouplingLinks = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 14), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("basicRedundancy", 1), ("extendedRedundancy", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingCplCouplingLinks.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplCouplingLinks.setDescription('Maximum coupling links between two coupled rings in case of a failure in one of the coupled rings. If there is no connection starting from the switch in slave or local operational state over the route of the coupled rings or nets to oneself the slave or the local mode want to set the coupling port in forwarding after a timeout period. basicRedundancy(1) prevents the slave or the local mode from setting its coupling port into forwarding in case of the described failure. In this case the segment which is connected to this coupling port is unreachable until the failure is eliminated. In extendedRedundancy(2) the coupling port and the partner coupling port are allowed to be in forwarding.')
hm2RingCplExtendedDiag = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 15), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("noError", 1), ("basicRedundancyInactive", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplExtendedDiag.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplExtendedDiag.setDescription('Additional operational states detected by the slave or in local mode. basicRedundancyInactive(2) indicates that the coupling port has been prevented from setting into forwarding (please see description of hm2RingCplCouplingLinks).')
hm2RingCplNetCoupling = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 16), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("ringCoupling", 1), ("netCoupling", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RingCplNetCoupling.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplNetCoupling.setDescription('Specifies the kind of the coupled net segment. If two HIPER Rings are coupled ringCoupling(1) must be used. In netCoupling(2) the coupled segment is no HIPER Ring topology and the switches in the coupled net segment may be connected with other ports than their ringports. Notice: if the ring coupling mechanism switches over, in ringCoupling(1) only the address tables of the switches in the two coupled HIPER Rings will be erased, in netCoupling(2) the address tables of all switches in the coupled net will be erased.')
hm2RingCplRedOperState = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 17), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redGuaranteed", 1), ("redNotGuaranteed", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RingCplRedOperState.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplRedOperState.setDescription('Operational state of the Ring/Net coupling redundancy. redGuaranteed(1) indicates that redundancy is guaranteed in the ring coupling. redNotGuaranteed(2) indicates that redundancy is not guaranteed in the ring coupling.')
hm2RingCplRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 8, 1, 1, 22), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: hm2RingCplRowStatus.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplRowStatus.setDescription('Defines the status of a ring coupling database entry.')
hm2RedundantCplAdminState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 1), HmEnabledStatus().clone('disable')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RedundantCplAdminState.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplAdminState.setDescription('Enables or disables the global RCP admin state.')
hm2RedundantCplInPrimaryPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 2), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RedundantCplInPrimaryPort.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplInPrimaryPort.setDescription('The inner coupling port of the primary ring.')
hm2RedundantCplOutPrimaryPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 3), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RedundantCplOutPrimaryPort.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplOutPrimaryPort.setDescription('The outer coupling port of the primary ring.')
hm2RedundantCplInSecondaryPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 4), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RedundantCplInSecondaryPort.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplInSecondaryPort.setDescription('The inner coupling port of the secondary ring')
hm2RedundantCplOutSecondaryPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 5), InterfaceIndexOrZero()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RedundantCplOutSecondaryPort.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplOutSecondaryPort.setDescription('The outer coupling port of the secondary ring')
hm2RedundantCplRole = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 4))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("auto", 4))).clone('auto')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RedundantCplRole.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplRole.setDescription('Configurable role of the RCP coupler.')
hm2RedundantCplCurrentRole = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4, 5))).clone(namedValues=NamedValues(("master", 1), ("slave", 2), ("listening", 3), ("error", 4), ("disabled", 5)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplCurrentRole.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplCurrentRole.setDescription('Current role of the RCP coupler.')
hm2RedundantCplTimeout = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(5, 60000)).clone(250)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: hm2RedundantCplTimeout.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplTimeout.setDescription('RCP coupler timeout in milliseconds.')
hm2RedundantCplPartner = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 9), MacAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplPartner.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplPartner.setDescription('MAC address of the coupling partner.')
hm2RedundantCplPartnerPrimaryPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 10), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplPartnerPrimaryPort.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplPartnerPrimaryPort.setDescription('Port of the coupling partner in the primary ring.')
hm2RedundantCplPartnerSecodaryPort = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 11), InterfaceIndexOrZero()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplPartnerSecodaryPort.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplPartnerSecodaryPort.setDescription('Port of the coupling partner in the secondary ring.')
hm2RedundantCplState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("forwarding", 1), ("blocking", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplState.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplState.setDescription('current forwarding state of the RCP coupler.')
hm2RedundantCplRedundancyState = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("redAvailable", 1), ("redNotAvailable", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplRedundancyState.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplRedundancyState.setDescription('Indicates if coupling redundancy is available.')
hm2RedundantCplPartnerIPAddrType = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 14), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplPartnerIPAddrType.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplPartnerIPAddrType.setDescription('Partner IP Address type.')
hm2RedundantCplPartnerIPAddr = MibScalar((1, 3, 6, 1, 4, 1, 248, 11, 40, 1, 9, 15), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: hm2RedundantCplPartnerIPAddr.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplPartnerIPAddr.setDescription('IP address of the coupling partner.')
hm2MrpReconfig = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 40, 0, 1)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2MrpRingOperState"))
if mibBuilder.loadTexts: hm2MrpReconfig.setStatus('current')
if mibBuilder.loadTexts: hm2MrpReconfig.setDescription('This notification is sent if the MRP ring has switched over.')
hm2SrmReconfig = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 40, 0, 2)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2SrmRingID"), ("HM2-L2REDUNDANCY-MIB", "hm2SrmSubRingOperState"))
if mibBuilder.loadTexts: hm2SrmReconfig.setStatus('current')
if mibBuilder.loadTexts: hm2SrmReconfig.setDescription('This notification is sent if the SRM ring has switched over.')
hm2RingCplReconfig = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 40, 0, 3)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2RingCplInterconnIfOpState"), ("HM2-L2REDUNDANCY-MIB", "hm2RingCplPartnerInterconnIfOpState"), ("HM2-L2REDUNDANCY-MIB", "hm2RingCplPartnerIpAddrType"), ("HM2-L2REDUNDANCY-MIB", "hm2RingCplPartnerIpAddr"))
if mibBuilder.loadTexts: hm2RingCplReconfig.setStatus('current')
if mibBuilder.loadTexts: hm2RingCplReconfig.setDescription('The Ring Coupling mechanism has switched over')
hm2RedundantCplReconfig = NotificationType((1, 3, 6, 1, 4, 1, 248, 11, 40, 0, 4)).setObjects(("HM2-L2REDUNDANCY-MIB", "hm2RedundantCplCurrentRole"), ("HM2-L2REDUNDANCY-MIB", "hm2RedundantCplState"))
if mibBuilder.loadTexts: hm2RedundantCplReconfig.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplReconfig.setDescription('The RCP Redundancy mechanism has switched over.')
hm2RingCouplingMibSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 3, 8))
hm2RedundantCplSESGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 248, 11, 40, 3, 9))
hm2RingCouplingInvalidPortConfiguration = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 40, 3, 8, 1))
if mibBuilder.loadTexts: hm2RingCouplingInvalidPortConfiguration.setStatus('current')
if mibBuilder.loadTexts: hm2RingCouplingInvalidPortConfiguration.setDescription('Could not enable Ring/Net Coupling configuration. In {0} control mode the {1} should be selected, different from the coupling port and in the valid range.')
hm2RedundantCplPortsMissing = ObjectIdentity((1, 3, 6, 1, 4, 1, 248, 11, 40, 3, 9, 1))
if mibBuilder.loadTexts: hm2RedundantCplPortsMissing.setStatus('current')
if mibBuilder.loadTexts: hm2RedundantCplPortsMissing.setDescription('Could not enable RCP. The required ports are not configured.')
mibBuilder.exportSymbols("HM2-L2REDUNDANCY-MIB", hm2RingCplExtendedDiag=hm2RingCplExtendedDiag, hm2RingCplControlModeOperState=hm2RingCplControlModeOperState, hm2MrpRingport1IfIndex=hm2MrpRingport1IfIndex, hm2RingCplInterconnIfIndex=hm2RingCplInterconnIfIndex, hm2MrpMRMRoundTripDelayMin=hm2MrpMRMRoundTripDelayMin, hm2SrmEntry=hm2SrmEntry, hm2SrmPartnerMAC=hm2SrmPartnerMAC, hm2SrmVlanID=hm2SrmVlanID, hm2RingCplPartnerIpAddr=hm2RingCplPartnerIpAddr, hm2MrpConformance=hm2MrpConformance, hm2SrmOperState=hm2SrmOperState, hm2RingCouplingInvalidPortConfiguration=hm2RingCouplingInvalidPortConfiguration, hm2SrmMRPDomainID=hm2SrmMRPDomainID, hm2SrmSubRingProtocol=hm2SrmSubRingProtocol, hm2RedundantCplConfigMibGroup=hm2RedundantCplConfigMibGroup, hm2MrpMibGroup=hm2MrpMibGroup, hm2RingCplCouplingLinks=hm2RingCplCouplingLinks, hm2MrpDomainID=hm2MrpDomainID, hm2RingRedSecondaryIntfState=hm2RingRedSecondaryIntfState, hm2RedundantCplRedundancyState=hm2RedundantCplRedundancyState, hm2MrpDomainName=hm2MrpDomainName, hm2RingCplOperState=hm2RingCplOperState, hm2MrpEntry=hm2MrpEntry, hm2SrmMaxInstances=hm2SrmMaxInstances, hm2SrmReconfig=hm2SrmReconfig, hm2RingCplNetCoupling=hm2RingCplNetCoupling, hm2MrpDomainBasicGroup=hm2MrpDomainBasicGroup, hm2RingCplPartnerIpAddrType=hm2RingCplPartnerIpAddrType, hm2RedundantCplState=hm2RedundantCplState, hm2MrpMRCBlockedSupported=hm2MrpMRCBlockedSupported, hm2MrpMRMRoundTripDelayReset=hm2MrpMRMRoundTripDelayReset, hm2MrpCompliance=hm2MrpCompliance, hm2MrpRingport2IfIndex=hm2MrpRingport2IfIndex, hm2RingCouplingTable=hm2RingCouplingTable, hm2MrpRedundancyOperState=hm2MrpRedundancyOperState, hm2MrpMRMReactOnLinkChange=hm2MrpMRMReactOnLinkChange, PYSNMP_MODULE_ID=hm2L2RedundancyMib, hm2L2RedundancyMibNotifications=hm2L2RedundancyMibNotifications, hm2MrpRecoveryDelay=hm2MrpRecoveryDelay, hm2RedundantCplOutSecondaryPort=hm2RedundantCplOutSecondaryPort, hm2SrmAdminState=hm2SrmAdminState, hm2MrpReconfig=hm2MrpReconfig, hm2RingRedAdminState=hm2RingRedAdminState, hm2SrmRingID=hm2SrmRingID, hm2L2RedundancyMib=hm2L2RedundancyMib, Hm2CplPortOpState=Hm2CplPortOpState, hm2MrpRingport2FixedBackup=hm2MrpRingport2FixedBackup, hm2SrmSubRingPortOperState=hm2SrmSubRingPortOperState, hm2RingRedPrimaryIntf=hm2RingRedPrimaryIntf, hm2RingCplModeOperState=hm2RingCplModeOperState, hm2SrmConfigOperState=hm2SrmConfigOperState, hm2MrpRecoveryDelaySupported=hm2MrpRecoveryDelaySupported, hm2MrpMRMNonBlockingMRCSupported=hm2MrpMRMNonBlockingMRCSupported, hm2SrmRowStatus=hm2SrmRowStatus, hm2MrpRoleOperState=hm2MrpRoleOperState, hm2SrmSubRingOperState=hm2SrmSubRingOperState, hm2MrpConfigOperState=hm2MrpConfigOperState, hm2RingCplCouplingMode=hm2RingCplCouplingMode, hm2RingCplRowStatus=hm2RingCplRowStatus, hm2MrpMRMRingOpenCount=hm2MrpMRMRingOpenCount, hm2RedundantCplOutPrimaryPort=hm2RedundantCplOutPrimaryPort, hm2RingCplReconfig=hm2RingCplReconfig, hm2RedundantCplPartnerIPAddrType=hm2RedundantCplPartnerIPAddrType, hm2RedundantCplTimeout=hm2RedundantCplTimeout, hm2RingCouplingEntry=hm2RingCouplingEntry, hm2SrmRedundancyOperState=hm2SrmRedundancyOperState, hm2MrpMRMPriority=hm2MrpMRMPriority, hm2RingCplRedOperState=hm2RingCplRedOperState, hm2RingRedSecondaryIntf=hm2RingRedSecondaryIntf, hm2SrmSubRingName=hm2SrmSubRingName, hm2RedundantCplInSecondaryPort=hm2RedundantCplInSecondaryPort, hm2RedundantCplReconfig=hm2RedundantCplReconfig, hm2RingCplConfigOperState=hm2RingCplConfigOperState, hm2MrpVlanID=hm2MrpVlanID, hm2L2RedundancyMibSNMPExtensionGroup=hm2L2RedundancyMibSNMPExtensionGroup, hm2MrpFastMrp=hm2MrpFastMrp, hm2RedundantCplPartnerIPAddr=hm2RedundantCplPartnerIPAddr, hm2MrpRingport2OperState=hm2MrpRingport2OperState, hm2MrpNotificationsGroup=hm2MrpNotificationsGroup, hm2MrpGroups=hm2MrpGroups, hm2MrpRingOperState=hm2MrpRingOperState, hm2MrpDomainManagerGroup=hm2MrpDomainManagerGroup, hm2MrpRowStatus=hm2MrpRowStatus, hm2RedundantCplRole=hm2RedundantCplRole, hm2MrpRingport1OperState=hm2MrpRingport1OperState, hm2SrmGlobalAdminState=hm2SrmGlobalAdminState, hm2RedundantCplSESGroup=hm2RedundantCplSESGroup, hm2RingRedPrimaryIntfState=hm2RingRedPrimaryIntfState, hm2RedundantCplPartnerSecodaryPort=hm2RedundantCplPartnerSecodaryPort, hm2RedundantCplPortsMissing=hm2RedundantCplPortsMissing, hm2MrpRoleAdminState=hm2MrpRoleAdminState, hm2SrmTable=hm2SrmTable, hm2RingCplControlIfOpState=hm2RingCplControlIfOpState, hm2RedundantCplPartnerPrimaryPort=hm2RedundantCplPartnerPrimaryPort, hm2RingCplPartnerInterconnIfIndex=hm2RingCplPartnerInterconnIfIndex, hm2MrpMRMLastRingOpenChange=hm2MrpMRMLastRingOpenChange, hm2RedundantCplCurrentRole=hm2RedundantCplCurrentRole, hm2RedundantCplPartner=hm2RedundantCplPartner, hm2RingRedMibGroup=hm2RingRedMibGroup, hm2RingCouplingMibSESGroup=hm2RingCouplingMibSESGroup, hm2MrpRingport2GroupID=hm2MrpRingport2GroupID, hm2MrpDomainDiagGroup=hm2MrpDomainDiagGroup, hm2RingCplPartnerInterconnIfOpState=hm2RingCplPartnerInterconnIfOpState, hm2MrpRingport1GroupID=hm2MrpRingport1GroupID, hm2MrpTable=hm2MrpTable, hm2RingRedMode=hm2RingRedMode, hm2RedundantCplAdminState=hm2RedundantCplAdminState, hm2L2RedundancyMibObjects=hm2L2RedundancyMibObjects, hm2RedundantCplInPrimaryPort=hm2RedundantCplInPrimaryPort, hm2RingCplControlIfIndex=hm2RingCplControlIfIndex, hm2SrmMibGroup=hm2SrmMibGroup, hm2MrpCompliances=hm2MrpCompliances, hm2RingCouplingMibGroup=hm2RingCouplingMibGroup, hm2RingCplInterconnIfOpState=hm2RingCplInterconnIfOpState, hm2MrpMRMRoundTripDelayMax=hm2MrpMRMRoundTripDelayMax, hm2SrmSubRingPortIfIndex=hm2SrmSubRingPortIfIndex)

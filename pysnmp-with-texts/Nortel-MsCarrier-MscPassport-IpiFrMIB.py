#
# PySNMP MIB module Nortel-MsCarrier-MscPassport-IpiFrMIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Nortel-MsCarrier-MscPassport-IpiFrMIB
# Produced by pysmi-0.3.4 at Wed May  1 14:30:37 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
ObjectIdentifier, OctetString, Integer = mibBuilder.importSymbols("ASN1", "ObjectIdentifier", "OctetString", "Integer")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ConstraintsIntersection, ValueSizeConstraint, ValueRangeConstraint, ConstraintsUnion, SingleValueConstraint = mibBuilder.importSymbols("ASN1-REFINEMENT", "ConstraintsIntersection", "ValueSizeConstraint", "ValueRangeConstraint", "ConstraintsUnion", "SingleValueConstraint")
RowPointer, Unsigned32, Integer32, StorageType, RowStatus, DisplayString, Counter32 = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-StandardTextualConventionsMIB", "RowPointer", "Unsigned32", "Integer32", "StorageType", "RowStatus", "DisplayString", "Counter32")
NonReplicated, AsciiString, HexString, EnterpriseDateAndTime, DigitString, Hex = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-TextualConventionsMIB", "NonReplicated", "AsciiString", "HexString", "EnterpriseDateAndTime", "DigitString", "Hex")
mscComponents, mscPassportMIBs = mibBuilder.importSymbols("Nortel-MsCarrier-MscPassport-UsefulDefinitionsMIB", "mscComponents", "mscPassportMIBs")
NotificationGroup, ModuleCompliance = mibBuilder.importSymbols("SNMPv2-CONF", "NotificationGroup", "ModuleCompliance")
Unsigned32, Integer32, NotificationType, ObjectIdentity, Gauge32, TimeTicks, MibScalar, MibTable, MibTableRow, MibTableColumn, Bits, MibIdentifier, IpAddress, ModuleIdentity, Counter64, iso, Counter32 = mibBuilder.importSymbols("SNMPv2-SMI", "Unsigned32", "Integer32", "NotificationType", "ObjectIdentity", "Gauge32", "TimeTicks", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "Bits", "MibIdentifier", "IpAddress", "ModuleIdentity", "Counter64", "iso", "Counter32")
DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "DisplayString", "TextualConvention")
ipiFrMIB = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35))
mscIpiFr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50))
mscIpiFrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 1), )
if mibBuilder.loadTexts: mscIpiFrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpiFr components.')
mscIpiFrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"))
if mibBuilder.loadTexts: mscIpiFrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFr component.')
mscIpiFrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFr components. These components can be added and deleted.')
mscIpiFrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrStorageType.setDescription('This variable represents the storage type value for the mscIpiFr tables.')
mscIpiFrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpiFrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrIndex.setDescription('This variable represents the index for the mscIpiFr tables.')
mscIpiFrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 10), )
if mibBuilder.loadTexts: mscIpiFrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrProvTable.setDescription('This group provides the provisionable attributes for the IpiFr component.')
mscIpiFrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"))
if mibBuilder.loadTexts: mscIpiFrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrProvEntry.setDescription('An entry in the mscIpiFrProvTable.')
mscIpiFrIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 10, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrIpAddress.setDescription('This attribute specifies the unique Internet Protocol (IP) Address that represents the IP address of the IPI service.')
mscIpiFrMaximumNumberOfLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 10, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(24, 24)).clone(24)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrMaximumNumberOfLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrMaximumNumberOfLcn.setDescription('This attribute specifies the maximum number of LCNs that are supported on this service. It specifies the maximum number of connections from external network management sites to this IpiFr service.')
mscIpiFrSubnetMask = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 10, 1, 3), IpAddress().clone(hexValue="ff000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrSubnetMask.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSubnetMask.setDescription('This attribute specifies the subnetwork mask for the IPI service.')
mscIpiFrDna = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2))
mscIpiFrDnaRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 1), )
if mibBuilder.loadTexts: mscIpiFrDnaRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpiFrDna components.')
mscIpiFrDnaRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaIndex"))
if mibBuilder.loadTexts: mscIpiFrDnaRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFrDna component.')
mscIpiFrDnaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFrDna components. These components cannot be added nor deleted.')
mscIpiFrDnaComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrDnaStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaStorageType.setDescription('This variable represents the storage type value for the mscIpiFrDna tables.')
mscIpiFrDnaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpiFrDnaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaIndex.setDescription('This variable represents the index for the mscIpiFrDna tables.')
mscIpiFrDnaAddressTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 10), )
if mibBuilder.loadTexts: mscIpiFrDnaAddressTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaAddressTable.setDescription("Address group contains attributes common to all Dna's. Every Dna used in the network is defined with this group of 2 attributes. String of address digits is complemented by type of address and Npi. These attributes are used to interpret format of the address digits.")
mscIpiFrDnaAddressEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaIndex"))
if mibBuilder.loadTexts: mscIpiFrDnaAddressEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaAddressEntry.setDescription('An entry in the mscIpiFrDnaAddressTable.')
mscIpiFrDnaNumberingPlanIndicator = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaNumberingPlanIndicator.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaNumberingPlanIndicator.setDescription('This attribute indicates the Numbering Plan Indicator (NPI) of the Dna that is entered. Address may belong to X.121 or E.164 plans. X.121 is used in packet svitched data networks.')
mscIpiFrDnaDataNetworkAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaDataNetworkAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaDataNetworkAddress.setDescription('Dna attribute contains digits which form unique identifier of the customer interface. It can be compared (approximation only) to telephone number where phone number identifies unique telephone set. Dna digits are selected and assigned by network operators. MaximumLenOfDna is 15digits.')
mscIpiFrDnaOutgoingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11), )
if mibBuilder.loadTexts: mscIpiFrDnaOutgoingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaOutgoingOptionsTable.setDescription('OutgoingOptions group defines call options of a Dna for calls which are made out of the interface represented by Dna. All these options are not used for calls arriving to the interface represented by Dna.')
mscIpiFrDnaOutgoingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaIndex"))
if mibBuilder.loadTexts: mscIpiFrDnaOutgoingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaOutgoingOptionsEntry.setDescription('An entry in the mscIpiFrDnaOutgoingOptionsTable.')
mscIpiFrDnaOutCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaOutCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaOutCalls.setDescription("This attribute, if set to a value of allowed indicates that outgoing calls (from the DTE to the network) can be made using this particular Dna. If set to a value of disallowed , then outgoing calls cannot be made using this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Outgoing Calls Barred' feature for Dnas in that outgoing calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this Dna to be useable.")
mscIpiFrDnaOutDefaultPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11, 1, 7), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1))).clone('high')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaOutDefaultPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaOutDefaultPriority.setDescription('This attribute, if set to normal indicates that the default priority for outgoing calls (from the DTE to the network) using this particular Dna is normal priority - if the priority is not specified by the DTE. If this attribute is set to high then the default priority for outgoing calls using this particular Dna is high priority. It can be overridden by the discardPriority under DLCI Direct Call subcomponent.')
mscIpiFrDnaOutDefaultPathSensitivity = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11, 1, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1))).clone('delay')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaOutDefaultPathSensitivity.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrDnaOutDefaultPathSensitivity.setDescription('This attribute specifies the default class of path sensitivity to network for all outgoing calls using this particular Dna. The chosen default class of path sensitivity applies to all outgoing calls established using this Dna. This attribute, if set to a value of throughput, indicates that the default class is throughput sensitive. If set to a value of delay, then the default class is delay sensitive. The default of outDefaultPathSensitivity is delay.')
mscIpiFrDnaOutPathSensitivityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaOutPathSensitivityOverRide.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrDnaOutPathSensitivityOverRide.setDescription('If this attribute is set to in the call request, the called end will use the calling end provisioning data on path sensitivity to override its own provisioning data. The default of outPathSensitivityOverRide is yes.')
mscIpiFrDnaDefaultTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11, 1, 18), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9))).clone(namedValues=NamedValues(("normal", 0), ("high", 9))).clone('high')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaDefaultTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaDefaultTransferPriority.setDescription('This attribute specifies the default transfer priority to network for all outgoing calls using this particular Dna. It is overRidden by the transferPriority provisioned in the DLCI Direct Call sub- component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of defaultTransferPriority is high.')
mscIpiFrDnaTransferPriorityOverRide = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 11, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1))).clone('yes')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaTransferPriorityOverRide.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaTransferPriorityOverRide.setDescription('When this attribute is set to yes, the called end will use the calling end provisioning data on transfer priority to override its own provisioning data. If it is set no, the called end will use its own provisioning data on transfer priority. For more information about transfer priority, please refer to the previous attribute defaultTransferPriority. The default of transferPriorityOverRide is yes.')
mscIpiFrDnaIncomingOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 12), )
if mibBuilder.loadTexts: mscIpiFrDnaIncomingOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaIncomingOptionsTable.setDescription('IncomingOptions defines set of options for incoming calls. These options are used for calls arriving to the interface represented by Dna. For calls originated from the interfasce, IncomingOptions attributes are not used.')
mscIpiFrDnaIncomingOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaIndex"))
if mibBuilder.loadTexts: mscIpiFrDnaIncomingOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaIncomingOptionsEntry.setDescription('An entry in the mscIpiFrDnaIncomingOptionsTable.')
mscIpiFrDnaIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 12, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaIncCalls.setDescription("This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) can be made to this Dna. If set to a value of disallowed, then incoming calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for Dna's in that incoming calls are barred if this attribute is set to a value of disallowed. Either outCalls, or incCalls (or both) must be set to a value of allowed for this Dna to be useable.")
mscIpiFrDnaIncAccess = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 12, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('disallowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaIncAccess.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaIncAccess.setDescription("This attribute is an extension of the Closed User Group (CUG) facility, as follows: This attribute, if set to a value of allowed indicates that incoming calls (from the network to the DTE) from the open (non-CUG) part of the network are permitted. It also permits incoming calls from DTEs that have Outgoing Access capabilities. If set to a value of disallowed, then such calls cannot be made to this Dna - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Closed User Group with Incoming Access' feature for Dnas in that incoming access is granted if this attribute is set to a value of allowed.")
mscIpiFrDnaCallOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 13), )
if mibBuilder.loadTexts: mscIpiFrDnaCallOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCallOptionsTable.setDescription('CallOptions group defines additional options for calls not related directly to direction of a call.')
mscIpiFrDnaCallOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 13, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaIndex"))
if mibBuilder.loadTexts: mscIpiFrDnaCallOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCallOptionsEntry.setDescription('An entry in the mscIpiFrDnaCallOptionsTable.')
mscIpiFrDnaServiceCategory = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 13, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32))).clone(namedValues=NamedValues(("gsp", 0), ("x25", 1), ("enhancedIti", 2), ("ncs", 3), ("mlti", 4), ("sm", 5), ("ici", 6), ("dsp3270", 7), ("iam", 8), ("mlhi", 9), ("term3270", 10), ("iti", 11), ("bsi", 13), ("hostIti", 14), ("x75", 15), ("hdsp3270", 16), ("api3201", 20), ("sdlc", 21), ("snaMultiHost", 22), ("redirectionServ", 23), ("trSnaTpad", 24), ("offnetNui", 25), ("gasServer", 26), ("vapServer", 28), ("vapAgent", 29), ("frameRelay", 30), ("ipiVc", 31), ("ipiFr", 32))).clone('ipiFr')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaServiceCategory.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaServiceCategory.setDescription('This attribute is assigned for each different type of service within which this Dna is configured. It is placed into the Service Category attribute in the accounting record by both ends of the Vc.')
mscIpiFrDnaAccountClass = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 13, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaAccountClass.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaAccountClass.setDescription('This attribute specifies the accounting class which is reserved for network operations usage. Its value is returned in the accounting record in the local and remote service type attributes. Use of this attribute is decided by network operator and it is an arbitrary number.')
mscIpiFrDnaServiceExchange = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 13, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaServiceExchange.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaServiceExchange.setDescription('This attribute is an arbitrary number, entered by the network operator. It is included in the accounting record created by Vc.')
mscIpiFrDnaCug = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2))
mscIpiFrDnaCugRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 1), )
if mibBuilder.loadTexts: mscIpiFrDnaCugRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpiFrDnaCug components.')
mscIpiFrDnaCugRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaCugIndex"))
if mibBuilder.loadTexts: mscIpiFrDnaCugRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFrDnaCug component.')
mscIpiFrDnaCugRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaCugRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFrDnaCug components. These components can be added and deleted.')
mscIpiFrDnaCugComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaCugComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrDnaCugStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrDnaCugStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugStorageType.setDescription('This variable represents the storage type value for the mscIpiFrDnaCug tables.')
mscIpiFrDnaCugIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(0, 255)))
if mibBuilder.loadTexts: mscIpiFrDnaCugIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugIndex.setDescription('This variable represents the index for the mscIpiFrDnaCug tables.')
mscIpiFrDnaCugCugOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 10), )
if mibBuilder.loadTexts: mscIpiFrDnaCugCugOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugCugOptionsTable.setDescription("This group defines options for a CUG. Attributes in this group define ClosedUserGroup options associated with interlockCode. DNA's with the same CUG (interlockCode) can make calls within this group. Various combinations which permit or prevent calls in the same CUG group are defined here.")
mscIpiFrDnaCugCugOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrDnaCugIndex"))
if mibBuilder.loadTexts: mscIpiFrDnaCugCugOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugCugOptionsEntry.setDescription('An entry in the mscIpiFrDnaCugCugOptionsTable.')
mscIpiFrDnaCugType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("national", 0), ("international", 1))).clone('national')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaCugType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugType.setDescription('This attribute specifies the CUG type - the CUG is either a national CUG, or an international CUG. International closed user groups are usually established between DTEs for which there is an X.75 Gateway between; whereas national closed user groups are usually established between DTEs for which there is no X.75 Gateway between. (National CUGs cannot normally traverse an X.75 Gateway). If this attribute is set to national, then the CUG is a national CUG, in which case, the dnic should be left at its default value since it is not part of a national CUG. If this attribute is set to international, then the CUG is an international CUG, in which case, the dnic should be set appropriately as part of the CUG interlockCode.')
mscIpiFrDnaCugDnic = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 10, 1, 2), DigitString().subtype(subtypeSpec=ValueSizeConstraint(4, 4)).setFixedLength(4).clone(hexValue="30303030")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaCugDnic.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugDnic.setDescription('This attribute specifies the dnic (Data Network ID Code) of the CUG by which packet networks are identified. This attribute is not applicable if the CUG is a national CUG, as specified by the CUG type attribute. There are usually 1 or 2 dnics assigned per country, for public networks. The U.S. is an exception where each BOC has a dnic. Also, a group of private networks can have its own dnic. dnic value is not an arbitrary number. It is assigned by international agreement and controlled by CCITT.')
mscIpiFrDnaCugInterlockCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 65535)).clone(65535)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaCugInterlockCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugInterlockCode.setDescription("This attribute specifies the CUG identifier of a national or international CUG call. It is an arbitrary number and it also can be called CUG in some descriptions. Interfaces (DNA's) defined with this number can make calls to DNA's with the same interlockCode.")
mscIpiFrDnaCugIncCalls = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 2, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disallowed", 0), ("allowed", 1))).clone('allowed')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrDnaCugIncCalls.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrDnaCugIncCalls.setDescription("This attribute, if set to allowed indicates that incoming calls (from the network to the DTE) can be made using this particular CUG. If set to disallowed, then incoming calls cannot be made using this CUG - such calls will be cleared by the local DCE. This attribute corresponds to the CCITT 'Incoming Calls Barred' feature for CUGs in that incoming calls are barred if this attribute is set to a value of disallowed.")
mscIpiFrLcn = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4))
mscIpiFrLcnRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 1), )
if mibBuilder.loadTexts: mscIpiFrLcnRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpiFrLcn components.')
mscIpiFrLcnRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFrLcn component.')
mscIpiFrLcnRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFrLcn components. These components can be added and deleted.')
mscIpiFrLcnComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrLcnStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnStorageType.setDescription('This variable represents the storage type value for the mscIpiFrLcn tables.')
mscIpiFrLcnIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 1, 1, 10), Integer32().subtype(subtypeSpec=ValueRangeConstraint(16, 39)))
if mibBuilder.loadTexts: mscIpiFrLcnIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnIndex.setDescription('This variable represents the index for the mscIpiFrLcn tables.')
mscIpiFrLcnStateTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10), )
if mibBuilder.loadTexts: mscIpiFrLcnStateTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnStateTable.setDescription('This group contains the three OSI State attributes and the six OSI Status attributes. The descriptions generically indicate what each attribute implies about the component. Note that not all the values and state combinations described here are supported by every component which uses this group. For component-specific information and the valid state combinations, refer to NTP 241- 7001-150, Passport Operations and Maintenance Guide.')
mscIpiFrLcnStateEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnStateEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnStateEntry.setDescription('An entry in the mscIpiFrLcnStateTable.')
mscIpiFrLcnAdminState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("locked", 0), ("unlocked", 1), ("shuttingDown", 2))).clone('unlocked')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnAdminState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnAdminState.setDescription('This attribute indicates the OSI Administrative State of the component. The value locked indicates that the component is administratively prohibited from providing services for its users. A Lock or Lock - force command has been previously issued for this component. When the value is locked, the value of usageState must be idle. The value shuttingDown indicates that the component is administratively permitted to provide service to its existing users only. A Lock command was issued against the component and it is in the process of shutting down. The value unlocked indicates that the component is administratively permitted to provide services for its users. To enter this state, issue an Unlock command to this component. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscIpiFrLcnOperationalState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("disabled", 0), ("enabled", 1))).clone('disabled')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnOperationalState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnOperationalState.setDescription('This attribute indicates the OSI Operational State of the component. The value enabled indicates that the component is available for operation. Note that if adminState is locked, it would still not be providing service. The value disabled indicates that the component is not available for operation. For example, something is wrong with the component itself, or with another component on which this one depends. If the value is disabled, the usageState must be idle. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscIpiFrLcnUsageState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("idle", 0), ("active", 1), ("busy", 2))).clone('idle')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnUsageState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnUsageState.setDescription('This attribute indicates the OSI Usage State of the component. The value idle indicates that the component is not currently in use. The value active indicates that the component is in use and has spare capacity to provide for additional users. The value busy indicates that the component is in use and has no spare operating capacity for additional users at this time. The OSI Status attributes, if supported by the component, may provide more details, qualifying the state of the component.')
mscIpiFrLcnAvailabilityStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 4), OctetString().subtype(subtypeSpec=ValueSizeConstraint(2, 2)).setFixedLength(2)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnAvailabilityStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnAvailabilityStatus.setDescription('If supported by the component, this attribute indicates the OSI Availability status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value inTest indicates that the resource is undergoing a test procedure. If adminState is locked or shuttingDown, the normal users are precluded from using the resource and controlStatus is reservedForTest. Tests that do not exclude additional users can be present in any operational or administrative state but the reservedForTest condition should not be present. The value failed indicates that the component has an internal fault that prevents it from operating. The operationalState is disabled. The value dependency indicates that the component cannot operate because some other resource on which it depends is unavailable. The operationalState is disabled. The value powerOff indicates the resource requires power to be applied and it is not powered on. The operationalState is disabled. The value offLine indicates the resource requires a routine operation (either manual, automatic, or both) to be performed to place it on-line and make it available for use. The operationalState is disabled. The value offDuty indicates the resource is inactive in accordance with a predetermined time schedule. In the absence of other disabling conditions, the operationalState is enabled or disabled. The value degraded indicates the service provided by the component is degraded in some way, such as in speed or operating capacity. However, the resource remains available for service. The operationalState is enabled. The value notInstalled indicates the resource is not present. The operationalState is disabled. The value logFull is not used. Description of bits: inTest(0) failed(1) powerOff(2) offLine(3) offDuty(4) dependency(5) degraded(6) notInstalled(7) logFull(8)')
mscIpiFrLcnProceduralStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 5), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnProceduralStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnProceduralStatus.setDescription("If supported by the component, this attribute indicates the OSI Procedural status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value initializationRequired indicates (for a resource which doesn't initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState is disabled. The value notInitialized indicates (for a resource which does initialize autonomously) that initialization is required before it can perform its normal functions, and this procedure has not been initiated. The operationalState may be enabled or disabled. The value initializing indicates that initialization has been initiated but is not yet complete. The operationalState may be enabled or disabled. The value reporting indicates the resource has completed some processing operation and is notifying the results. The operationalState is enabled. The value terminating indicates the component is in a termination phase. If the resource doesn't reinitialize autonomously, operationalState is disabled; otherwise it is enabled or disabled. Description of bits: initializationRequired(0) notInitialized(1) initializing(2) reporting(3) terminating(4)")
mscIpiFrLcnControlStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 6), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnControlStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnControlStatus.setDescription('If supported by the component, this attribute indicates the OSI Control status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value subjectToTest indicates the resource is available but tests may be conducted simultaneously at unpredictable times, which may cause it to exhibit unusual characteristics. The value partOfServicesLocked indicates that part of the service is restricted from users of a resource. The adminState is unlocked. The value reservedForTest indicates that the component is administratively unavailable because it is undergoing a test procedure. The adminState is locked. The value suspended indicates that the service has been administratively suspended. Description of bits: subjectToTest(0) partOfServicesLocked(1) reservedForTest(2) suspended(3)')
mscIpiFrLcnAlarmStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 7), OctetString().subtype(subtypeSpec=ValueSizeConstraint(1, 1)).setFixedLength(1)).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnAlarmStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnAlarmStatus.setDescription('If supported by the component, this attribute indicates the OSI Alarm status of the component. Note that, even though it is defined as a multi-valued set, at most one value is shown to the user. When no values are in the set, this indicates that either the attribute is not supported or that none of the status conditions described below are present. The value underRepair indicates the component is currently being repaired. The operationalState is enabled or disabled. The value critical indicates one or more critical alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value major indicates one or more major alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value minor indicates one or more minor alarms are outstanding against the component. Other, less severe, alarms may also be outstanding. The operationalState is enabled or disabled. The value alarmOutstanding generically indicates that an alarm of some severity is outstanding against the component. Description of bits: underRepair(0) critical(1) major(2) minor(3) alarmOutstanding(4)')
mscIpiFrLcnStandbyStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 8), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 15))).clone(namedValues=NamedValues(("hotStandby", 0), ("coldStandby", 1), ("providingService", 2), ("notSet", 15))).clone('notSet')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnStandbyStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnStandbyStatus.setDescription('If supported by the component, this attribute indicates the OSI Standby status of the component. The value notSet indicates that either the attribute is not supported or that none of the status conditions described below are present. Note that this is a non-standard value, used because the original specification indicated this attribute was set-valued and thus, did not provide a value to indicate that none of the other three are applicable. The value hotStandby indicates that the resource is not providing service but will be immediately able to take over the role of the resource to be backed up, without initialization activity, and containing the same information as the resource to be backed up. The value coldStandby indicates the resource is a backup for another resource but will not be immediately able to take over the role of the backed up resource and will require some initialization activity. The value providingService indicates that this component, as a backup resource, is currently backing up another resource.')
mscIpiFrLcnUnknownStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("false", 0), ("true", 1))).clone('false')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnUnknownStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnUnknownStatus.setDescription('This attribute indicates the OSI Unknown status of the component. The value false indicates that all of the other OSI State and Status attribute values can be considered accurate. The value true indicates that the actual state of the component is not known for sure.')
mscIpiFrLcnOperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11), )
if mibBuilder.loadTexts: mscIpiFrLcnOperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnOperTable.setDescription('This group contains status of the internal IP network interface.')
mscIpiFrLcnOperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnOperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnOperEntry.setDescription('An entry in the mscIpiFrLcnOperTable.')
mscIpiFrLcnIpInterfaceDevice = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("inactive", 0), ("active", 1))).clone('inactive')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnIpInterfaceDevice.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnIpInterfaceDevice.setDescription('The status of the internal IP network interface is inactive until either the remoteIpAddress attribute is provisioned, or an IP packet is exchanged between a Network Management Station and the internal IP network interface (via the LCN). At this point, the status changes to active.')
mscIpiFrLcnOpRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11, 1, 2), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnOpRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnOpRemoteIpAddress.setDescription('This attribute indicates the IP address of the remote network device connected to this interface. The value is either 0.0.0.0 until the frist data packe tis received from the remote end, or is the value provisioned in remoteIpAddress.')
mscIpiFrLcnPacketsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11, 1, 3), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnPacketsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnPacketsSent.setDescription('This attribute counts the number of IP packets sent from this interface.')
mscIpiFrLcnPacketsReceived = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11, 1, 4), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnPacketsReceived.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnPacketsReceived.setDescription('This attribute counts the number of IP packets received from the remote network device.')
mscIpiFrLcnDiscardTxPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11, 1, 5), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnDiscardTxPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDiscardTxPackets.setDescription('This attribute counts the number of IP packets destined to the remote end which were discarded by this interface.')
mscIpiFrLcnDiscardRcvPackets = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 11, 1, 6), Counter32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnDiscardRcvPackets.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDiscardRcvPackets.setDescription('This attribute counts the number of IP packets received from the remote end which were discarded by this interface.')
mscIpiFrLcnProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 12), )
if mibBuilder.loadTexts: mscIpiFrLcnProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnProvTable.setDescription('This group provides the provisionable attributes for the IpiFR Lcn component.')
mscIpiFrLcnProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnProvEntry.setDescription('An entry in the mscIpiFrLcnProvTable.')
mscIpiFrLcnRemoteIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 12, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnRemoteIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnRemoteIpAddress.setDescription('This attribute specifies the IP address of the remote device connected to this Lcn interface. This device can be a host, and / or a gateway. If the device is a gateway, and StaticRoutes are defined using this gateway, it is recommended that this attribute be set. It is also recommended to set this attribute, if management applications such as Software Download and SNMP, which can initiate IP traffic with Network Management Stations, are potentially using this Lcn interface. IP routing information within IpiFr is not known or activated for this Lcn interface until the remoteIpAddress is known. When the destination IpAddress is left at its default value of 0.0.0.0, the calling IP address is learnt from the first data packet received.')
mscIpiFrLcnDc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2))
mscIpiFrLcnDcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 1), )
if mibBuilder.loadTexts: mscIpiFrLcnDcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpiFrLcnDc components.')
mscIpiFrLcnDcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnDcIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnDcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFrLcnDc component.')
mscIpiFrLcnDcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnDcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFrLcnDc components. These components cannot be added nor deleted.')
mscIpiFrLcnDcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnDcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrLcnDcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnDcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcStorageType.setDescription('This variable represents the storage type value for the mscIpiFrLcnDc tables.')
mscIpiFrLcnDcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpiFrLcnDcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcIndex.setDescription('This variable represents the index for the mscIpiFrLcnDc tables.')
mscIpiFrLcnDcOptionsTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10), )
if mibBuilder.loadTexts: mscIpiFrLcnDcOptionsTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcOptionsTable.setDescription('Options group defines attributes associated with direct call. It defines complete connection in terms of path and call options. This connection can be permanent (pvc) or, in future release, switched (svc). It can have facilities. The total number of bytes of facilities including the facility codes, and all of the facility data from all of the four classes of facilities: CCITT_Facilities DTE_Facilities National_Facilities International_Facilities must not exceed 512 bytes.')
mscIpiFrLcnDcOptionsEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnDcIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnDcOptionsEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcOptionsEntry.setDescription('An entry in the mscIpiFrLcnDcOptionsTable.')
mscIpiFrLcnDcRemoteNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1))).clone('x121')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnDcRemoteNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcRemoteNpi.setDescription('RemoteNumbering Plan Indicator (Npi) indicates the numbering plan used in the remoteDna.')
mscIpiFrLcnDcRemoteDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10, 1, 4), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnDcRemoteDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcRemoteDna.setDescription('This attribute specifies the Data Network Address (Dna) of the remote. This is the called (destination) DTE address (Dna) to which this direct call will be sent. Initially, the called DTE address attribute must be present, that is, there must be a valid destination address. However, it may be possible in the future to configure the direct call with a mnemonic address, in which case, this attribute will contain a zero-length Dna, and the mnemonic address will be carried as one of the facilities.')
mscIpiFrLcnDcRemoteDlci = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 1007))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnDcRemoteDlci.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcRemoteDlci.setDescription('This attribute provides the value of the remote DLCI (Data Link Connection Identifier)')
mscIpiFrLcnDcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("permanentMaster", 1), ("permanentSlave", 2))).clone('permanentSlave')).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnDcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcType.setDescription('This attribute specifies the type of Vc call: permanentMaster, permanentSlave, If the value is set to permanentMaster, then a permanent connection will be established between 2 ends. The remote end must be defined as a permanentSlave, permanentBackupSlave or permanentSlaveWithBackup. The connection cannot be established if the remote end is defined as anything else. The end defined as permanentMaster always initiates the calls. It will attempt to call once per minute. If the value is set to permanentSlave then a permanent connection will be established between 2 ends. The remote end must be defined as a permanentMaster. The connection cannot be established if the remote end is defined as anything else. The permanentSlave end will attempt to call once per minute.')
mscIpiFrLcnDcTransferPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 9, 255))).clone(namedValues=NamedValues(("normal", 0), ("high", 9), ("useDnaDefTP", 255))).clone('useDnaDefTP')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnDcTransferPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcTransferPriority.setDescription('This attribute specifies the transfer priority to network for the outgoing calls using this particular DLCI. It overRides the defaultTransferPriority provisioned in its associated Dna component. The transfer priority is a preference specified by an application according to its delay-sensitivity requirement. Frames with high transfer priority are served by the network before the frames with normal priority. Each transfer priority contains a predetermined setting for trunk queue (interrupting, delay or throughput), routing metric (delay or throughput). When the transfer priority is set at high, the trunk queue is set to high, the routing metric is set to delay. When the transfer priority is set at normal, the trunk queue is set to normal, the routing metric is set to throughput. The default of transferPriority is useDnaDefTP. It means using the provisioning value under defaultTransferPriority of its associated Dna for this DLCI.')
mscIpiFrLcnDcDiscardPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 10, 1, 10), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 3))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("useDnaDefPriority", 3))).clone('useDnaDefPriority')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnDcDiscardPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnDcDiscardPriority.setDescription('This attribute specifies the discard priority for outgoing call using this DLCI. The discard priority has three provisioning values: normal, high, and useDnaDefPriority. Traffic with normal priority are discarded first than the traffic with high priority. The Dna default value (provisioned by outDefaultPriority) is taken if this attribute is set to the value useDnaDefPriority. The default of discardPriority is useDnaDefPriority.')
mscIpiFrLcnDcNfaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 222), )
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaTable.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaTable.setDescription("This is the i'th National facility required for this direct call. Within the provisioning system, the user specifies the facility code along with the facility parameters. The facility is represented internally as a hexadecimal string following the X.25 CCITT representation for facility data. Two explicit attributes discardPriority and transferPriority are created to replace H.01 and H.30 in the group VcsDirectCallOptionsProv of this file. The migrate escape here (DcComponent::migrateFaxEscape) propagates the old provisioning data under H.01. The rule of the above propagation are: 0 in H.01 is equivalent to discardPriority 0; 1 in H.01 is equivalent to discardPriority 1. And 0 in H.30 is equivalent to transferPriority normal; 1 in H.30 is equivalent to transferPriority high. Please refer to discardPriority and transferPriority for more information on how to use them.")
mscIpiFrLcnDcNfaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 222, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnDcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnDcNfaIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaEntry.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaEntry.setDescription('An entry in the mscIpiFrLcnDcNfaTable.')
mscIpiFrLcnDcNfaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 222, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 1)))
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaIndex.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaIndex.setDescription('This variable represents the index for the mscIpiFrLcnDcNfaTable.')
mscIpiFrLcnDcNfaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 222, 1, 2), HexString().subtype(subtypeSpec=ValueSizeConstraint(0, 128))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaValue.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaValue.setDescription('This variable represents an individual value for the mscIpiFrLcnDcNfaTable.')
mscIpiFrLcnDcNfaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 2, 222, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaRowStatus.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrLcnDcNfaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscIpiFrLcnDcNfaTable.')
mscIpiFrLcnVc = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3))
mscIpiFrLcnVcRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 1), )
if mibBuilder.loadTexts: mscIpiFrLcnVcRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpiFrLcnVc components.')
mscIpiFrLcnVcRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnVcIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnVcRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFrLcnVc component.')
mscIpiFrLcnVcRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFrLcnVc components. These components cannot be added nor deleted.')
mscIpiFrLcnVcComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrLcnVcStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcStorageType.setDescription('This variable represents the storage type value for the mscIpiFrLcnVc tables.')
mscIpiFrLcnVcIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 1, 1, 10), NonReplicated())
if mibBuilder.loadTexts: mscIpiFrLcnVcIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcIndex.setDescription('This variable represents the index for the mscIpiFrLcnVc tables.')
mscIpiFrLcnVcCadTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10), )
if mibBuilder.loadTexts: mscIpiFrLcnVcCadTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCadTable.setDescription('This group represents operational call data related to Frame Relay Vc. It can be displayed only for Frame Relay Vc which is created by application.')
mscIpiFrLcnVcCadEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnVcIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnVcCadEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCadEntry.setDescription('An entry in the mscIpiFrLcnVcCadTable.')
mscIpiFrLcnVcType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 1), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3))).clone(namedValues=NamedValues(("svc", 0), ("pvc", 1), ("spvc", 2), ("frf10spvc", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcType.setDescription('This attribute displays the type of call, pvc,svc,spvc or frf10spvc.')
mscIpiFrLcnVcState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcState.setDescription('This attribute displays the state of call control. P5 state is not supported but is listed for completness. Transitions from one state to another take very short time. state most often displayed is dataTransferP4.')
mscIpiFrLcnVcPreviousState = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 3), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2, 3, 4, 5, 6, 7, 8))).clone(namedValues=NamedValues(("creating", 0), ("readyP1", 1), ("dteWaitingP2", 2), ("dceWaitingP3", 3), ("dataTransferP4", 4), ("unsupportedP5", 5), ("dteClearRequestP6", 6), ("dceClearIndicationP7", 7), ("termination", 8)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPreviousState.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPreviousState.setDescription('This attribute displays the previous state of call control. This is a valuable field to determine how the processing is progressing.')
mscIpiFrLcnVcDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscIpiFrLcnVcPreviousDiagnosticCode = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPreviousDiagnosticCode.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPreviousDiagnosticCode.setDescription('This attribute displays the internal substate of call control. It is used to further refine state of call processing.')
mscIpiFrLcnVcCalledNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCalledNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCalledNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the called end.')
mscIpiFrLcnVcCalledDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 7), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCalledDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCalledDna.setDescription('This attribute displays the Data Network Address (Dna) of the called (destination) DTE to which this call is sent. This address if defined at recieving end will complete Vc connection.')
mscIpiFrLcnVcCalledLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCalledLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCalledLcn.setDescription('This attribute displays the Logical Channel Number of the called end. It is valid only after both ends of Vc exchanged relevant information.')
mscIpiFrLcnVcCallingNpi = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 9), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("x121", 0), ("e164", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCallingNpi.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCallingNpi.setDescription('This attribute displays the Numbering Plan Indicator (NPI) of the calling end.')
mscIpiFrLcnVcCallingDna = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 10), DigitString().subtype(subtypeSpec=ValueSizeConstraint(1, 15))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCallingDna.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCallingDna.setDescription('This attribute displays the Data Network Address (Dna) of the calling end.')
mscIpiFrLcnVcCallingLcn = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCallingLcn.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCallingLcn.setDescription('This attribute displays the Logical Channel Number of the calling end.')
mscIpiFrLcnVcAccountingEnabled = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("yes", 0), ("no", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcAccountingEnabled.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcAccountingEnabled.setDescription('This attribute indicates that this optional section of accounting record is suppressed or permitted. If accountingEnabled is yes, conditions for generation of accounting record were met. These conditions include billing options, vc recovery conditions and Module wide accounting data options.')
mscIpiFrLcnVcFastSelectCall = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 13), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("no", 0), ("yes", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcFastSelectCall.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcFastSelectCall.setDescription('This attribute displays that this is a fast select call.')
mscIpiFrLcnVcPathReliability = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 19), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("high", 0), ("normal", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPathReliability.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPathReliability.setDescription('This attribute displays the path reliability.')
mscIpiFrLcnVcAccountingEnd = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 20), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("callingEnd", 0), ("calledEnd", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcAccountingEnd.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcAccountingEnd.setDescription('This attribute indicates if this end should generate an accounting record. Normally, callingEnd is the end to generate an accounting record.')
mscIpiFrLcnVcPriority = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 21), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1))).clone(namedValues=NamedValues(("normal", 0), ("high", 1)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPriority.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPriority.setDescription('This attribute displays whether the call is a normal or a high priority call.')
mscIpiFrLcnVcSegmentSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 22), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcSegmentSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcSegmentSize.setDescription('This attribute displays the segment size (in bytes) used on the call. It is used to calculate the number of segments transmitted and received.')
mscIpiFrLcnVcMaxSubnetPktSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 27), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4096))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcMaxSubnetPktSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcMaxSubnetPktSize.setDescription('This attribute indicates the maximum packet size allowed on the Vc.')
mscIpiFrLcnVcRcosToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 28), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcRcosToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcRcosToNetwork.setDescription('This attribute indicates the routing metric routing class of service to the network.')
mscIpiFrLcnVcRcosFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 29), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("throughput", 0), ("delay", 1), ("multimedia", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcRcosFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcRcosFromNetwork.setDescription('This attribute displays the routing metric Routing Class of Service from the Network.')
mscIpiFrLcnVcEmissionPriorityToNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 30), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcEmissionPriorityToNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcEmissionPriorityToNetwork.setDescription('This attribute displays the network internal emission priotity to the network.')
mscIpiFrLcnVcEmissionPriorityFromNetwork = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 31), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(0, 1, 2))).clone(namedValues=NamedValues(("normal", 0), ("high", 1), ("interrupting", 2)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcEmissionPriorityFromNetwork.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcEmissionPriorityFromNetwork.setDescription('This attribute displays the network internal emission priotity from the network.')
mscIpiFrLcnVcDataPath = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 10, 1, 32), AsciiString().subtype(subtypeSpec=ValueSizeConstraint(0, 32))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcDataPath.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcDataPath.setDescription('This attribute indicates the data path used by the connection. The data path is provisioned in Dna and DirectCall components. The displayed value of this attribute can be different from the provisioned value. If the connection is using dprsOnly data path, the string dprsOnly is displayed. (dynamic packet routing system) If the connection is using dprsMcsOnly data path, the string dprsMcsOnly is displayed. If the connection is using dprsMcsFirst data path, the string dprsMcsFirst is displayed.')
mscIpiFrLcnVcIntdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11), )
if mibBuilder.loadTexts: mscIpiFrLcnVcIntdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcIntdTable.setDescription('This group defines display of interval data collected by Vc. Data in this group is variable and may depend on time when this display command is issued.')
mscIpiFrLcnVcIntdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnVcIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnVcIntdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcIntdEntry.setDescription('An entry in the mscIpiFrLcnVcIntdTable.')
mscIpiFrLcnVcCallReferenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11, 1, 1), Hex().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCallReferenceNumber.setStatus('obsolete')
if mibBuilder.loadTexts: mscIpiFrLcnVcCallReferenceNumber.setDescription('This attribute is obsolete. It is replaced by the callReferenceNumber attribute to display the call reference number in decimal. The SNMP reference for the callReferenceNumber attribute is callReferenceNumberDecimal.')
mscIpiFrLcnVcElapsedTimeTillNow = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcElapsedTimeTillNow.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcElapsedTimeTillNow.setDescription('This attribute displays the elapsed time representing the period of this interval data. It is elapsed time in 0.1 second increments since Vc started.')
mscIpiFrLcnVcSegmentsRx = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcSegmentsRx.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcSegmentsRx.setDescription('This attribute displays the number of segments received at the time command was issued. This is the segment received count maintained by accounting at each end of the Vc. This counter is updated only when the packet cannot be successfully delivered out of the sink Vc and to the sink AP Conditions in which packets may be discarded by the sink Vc include: missing packets due to subnet discards, segmentation protocol violations due to subnet discard, duplicated and out-of-ranged packets and packets that arrive while Vc is in path recovery state.')
mscIpiFrLcnVcSegmentsSent = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 16777215))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcSegmentsSent.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcSegmentsSent.setDescription('This attribute displays the number of segments sent at the time command was issued. This is the segment sent count maintained by accounting at the source Vc. Vc only counts packets that Vc thinks can be delivered successfully into the subnet. In reality, these packets may be dropped by trunking, for instance. This counter is not updated when splitting fails, when Vc is in a path recovery state, when packet forwarding fails to forward this packet and when subsequent packets have to be discarded as we want to minimize the chance of out-of-sequence and do not intentionally send out-of- sequenced packets into the subnet.')
mscIpiFrLcnVcStartTime = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11, 1, 5), EnterpriseDateAndTime().subtype(subtypeSpec=ConstraintsUnion(ValueSizeConstraint(0, 0), ValueSizeConstraint(19, 19), ))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcStartTime.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcStartTime.setDescription('This attribute displays the start time of this interval period. If Vc spans 12 hour time or time of day change startTime reflects new time as recorded at 12 hour periods or time of day changes.')
mscIpiFrLcnVcCallReferenceNumberDecimal = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 11, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 4294967295))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCallReferenceNumberDecimal.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCallReferenceNumberDecimal.setDescription('This attribute displays the call reference number which is a unique number generated by the switch.The same Call Reference Number is stored in the interval data (accounting record) at both ends of the call. It can be used as one of the attributes in matching duplicate records generated at each end of the call.')
mscIpiFrLcnVcFrdTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12), )
if mibBuilder.loadTexts: mscIpiFrLcnVcFrdTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcFrdTable.setDescription('This group defines Frame Relay attributes collected by Frame Relay Vc. The purpose of Vc attributes is to aid end users and verification people to understand the Vc internal behavior. This is particularly useful when the network has experienced abnormality and we want to isolate problems and pinpoint trouble spots. Attributes are collected on a per Vc basis. Until a need is identified, statistics are not collected at a processor level. Each attribute is stored in a 32 bit field and is initialized to zero when a Vc enters into the data transfer state. When a PVC is disconnected and then connected again, the attributes will be reset. Attributes cannot be reset through other methods. Frame Relay Vc uses a best effort data packet delivery protocol and a different packet segmentation and combination methods from the General Vc. The Frame Relay Vc uses the same call setup and control mechanism (e.g. the support of non-flow control data packets) as in a General Vc. Most General Vc statistics and internal variables are used in a Frame Relay Vc and are displayed by software developers')
mscIpiFrLcnVcFrdEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnVcIndex"))
if mibBuilder.loadTexts: mscIpiFrLcnVcFrdEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcFrdEntry.setDescription('An entry in the mscIpiFrLcnVcFrdTable.')
mscIpiFrLcnVcFrmCongestedToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 2), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcFrmCongestedToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcFrmCongestedToSubnet.setDescription('This attribute displays the number of frames from link discarded due to lack of resources. It keeps track of the number of frames from link that have to be discarded. The discard reasons include insufficient memory for splitting the frame into smaller subnet packet size.')
mscIpiFrLcnVcCannotForwardToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCannotForwardToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCannotForwardToSubnet.setDescription('This attribute displays the number of discarded packets that can not be forwarded into the subnet because of subnet congestion. Number of frames from link discarded due to failure in forwarding a packet from Vc into the subnet.- This attribute is increased when packet forwarding fails to forward a packet into the subnet. If a frame is split into multiple subnet packets and a partial packet has to be discarded, all subsequent partial packets that have not yet been delivered to the subnet will be discarded as well.')
mscIpiFrLcnVcNotDataXferToSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 4), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcNotDataXferToSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcNotDataXferToSubnet.setDescription('This attribute records the number of frames from link discarded when the Vc tries to recover from internal path failure.')
mscIpiFrLcnVcOutOfRangeFrmFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 5), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcOutOfRangeFrmFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcOutOfRangeFrmFromSubnet.setDescription('This attribute displays the number of frames from subnet discarded due to out of sequence range for arriving too late.')
mscIpiFrLcnVcCombErrorsFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 6), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcCombErrorsFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcCombErrorsFromSubnet.setDescription('This attribute records the number of subnet packets discarded at the sink Vc due to the Vc segmentation and combination protocol error. Usually, this occurs when the subnet discards packets and thus this statistics can be used to guest the number of subnet packets that are not delivered to the Vc. It cannot be used as an actual measure because some subnet packets may have been delivered to Vc but have to be discarded because these are partial packets to a frame in which some other partial packets have not been properly delivered to Vc')
mscIpiFrLcnVcDuplicatesFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 7), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcDuplicatesFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcDuplicatesFromSubnet.setDescription('This attribute displays the number of subnet packets discarded due to duplication. Although packets are not retransmitted by the Frame Relay Vc, it is possible for the subnet to retransmit packets. When packets are out-of-sequenced and copies of the same packets arrive, then this attribute is increased.')
mscIpiFrLcnVcNotDataXferFromSubnet = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 8), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcNotDataXferFromSubnet.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcNotDataXferFromSubnet.setDescription('This attribute displays the number of subnet packets discarded when data transfer is suspended in Vc recovery.')
mscIpiFrLcnVcFrmLossTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 9), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcFrmLossTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcFrmLossTimeouts.setDescription('This attribute displays the number of lost frame timer expiries. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscIpiFrLcnVcOoSeqByteCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 10), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcOoSeqByteCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcOoSeqByteCntExceeded.setDescription('This attribute displays the number times that the out of sequence byte threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscIpiFrLcnVcPeakOoSeqPktCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 11), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakOoSeqPktCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakOoSeqPktCount.setDescription('This attribute displays the frame relay peak packet count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscIpiFrLcnVcPeakOoSeqFrmForwarded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 12), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakOoSeqFrmForwarded.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakOoSeqFrmForwarded.setDescription('This attribute displays the frame relay peak size of the sequence packet queue. The subnet may deliver packets out-of- sequenced. These packets are then queued in an out-of-sequenced queue, waiting for a packet with the expected sequence number to come. When that packet arrives, this attribute records the maximum number of packets that were out-of-sequenced, but now have become in-sequenced. The statistics is used to measure expected queue size due to normal subnet packet disorder (not due to subnet packet discard). Current implementation also uses this statistics to set a maximum size for the out-of-sequenced queue.')
mscIpiFrLcnVcSendSequenceNumber = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 13), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcSendSequenceNumber.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcSendSequenceNumber.setDescription("This attribute displays the Vc internal packet's send sequence number. Note that a 'packet' in this context, may be either a user data packet, or an OAM frame.")
mscIpiFrLcnVcPktRetryTimeouts = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 15), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPktRetryTimeouts.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPktRetryTimeouts.setDescription('This attribute displays the number of packets which have retransmission time-outs. When this count is excessive, the network is very congested and packets have been discarded in the subnet.')
mscIpiFrLcnVcPeakRetryQueueSize = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 16), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakRetryQueueSize.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakRetryQueueSize.setDescription('This attribute displays the peak size of retransmission queue. This attribute is used as an indicator of the acknowledgment behavior across the subnet. Records the largest body of unacknowledged packets.')
mscIpiFrLcnVcSubnetRecoveries = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 17), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 5000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcSubnetRecoveries.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcSubnetRecoveries.setDescription('This attribute displays the number of successful Vc recovery attempts.')
mscIpiFrLcnVcOoSeqPktCntExceeded = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 19), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 255))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcOoSeqPktCntExceeded.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcOoSeqPktCntExceeded.setDescription('This attribute displays the number times that the out of sequence packet threshold is exceeded. When the threshold is exceeded, this condition is treated as if the loss frame timer has expired and all frames queued at the sink Vc are delivered to the AP. We need to keep this count to examine if the threshold is engineered properly. This should be used in conjunction with the peak value of out-of- sequenced queue and the number of times the loss frame timer has expired. This count should be relatively small when compared with loss frame timer expiry count.')
mscIpiFrLcnVcPeakOoSeqByteCount = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 12, 1, 20), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(0, 50000))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakOoSeqByteCount.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcPeakOoSeqByteCount.setDescription('This attribute displays the frame relay peak byte count of the out of sequence queue. This attribute records the maximum queue length of the out-of-sequenced queue. The counter can be used to deduce the message buffer requirement on a Vc.')
mscIpiFrLcnVcDmepTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 417), )
if mibBuilder.loadTexts: mscIpiFrLcnVcDmepTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcDmepTable.setDescription('This attribute displays the data path used by the connection. Data path is provisioned in Dna and DirectCall components. If the connection is using dprsOnly data path, this attribute is empty. If the connection is using dprsMcsOnly or dprsMcsFirst data path, this attribute displays component name of the dprsMcsEndPoint.')
mscIpiFrLcnVcDmepEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 417, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnVcIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrLcnVcDmepValue"))
if mibBuilder.loadTexts: mscIpiFrLcnVcDmepEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcDmepEntry.setDescription('An entry in the mscIpiFrLcnVcDmepTable.')
mscIpiFrLcnVcDmepValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 4, 3, 417, 1, 1), RowPointer()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrLcnVcDmepValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrLcnVcDmepValue.setDescription('This variable represents both the value and the index for the mscIpiFrLcnVcDmepTable.')
mscIpiFrSr = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5))
mscIpiFrSrRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 1), )
if mibBuilder.loadTexts: mscIpiFrSrRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrRowStatusTable.setDescription('This entry controls the addition and deletion of mscIpiFrSr components.')
mscIpiFrSrRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrSrIndex"))
if mibBuilder.loadTexts: mscIpiFrSrRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFrSr component.')
mscIpiFrSrRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 1, 1, 1), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrSrRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFrSr components. These components can be added and deleted.')
mscIpiFrSrComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrSrComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrSrStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrSrStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrStorageType.setDescription('This variable represents the storage type value for the mscIpiFrSr tables.')
mscIpiFrSrIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscIpiFrSrIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrIndex.setDescription('This variable represents the index for the mscIpiFrSr tables.')
mscIpiFrSrProvTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 10), )
if mibBuilder.loadTexts: mscIpiFrSrProvTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrProvTable.setDescription('This group provides the provisionable parameters for setting up a static route.')
mscIpiFrSrProvEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrSrIndex"))
if mibBuilder.loadTexts: mscIpiFrSrProvEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrProvEntry.setDescription('An entry in the mscIpiFrSrProvTable.')
mscIpiFrSrGatewayIpAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 10, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrSrGatewayIpAddress.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrGatewayIpAddress.setDescription('The attribute specifies the IP Address of the next hop in this route to the destination IP Address. For this static route to be active, the value of this attribute must match the opRemoteIpAddress attribute of one of the Lcn components.')
mscIpiFrSrBGtyIpaTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 327), )
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaTable.setDescription('The attribute specifies an ordered list of alternative gateways to use for the route to the destination IP Address. This attribute is only supported for the default route. If the Lcn interface of the current gateway IP Address fails, then the backupGatewayIpAddresses, listed in this attribute, are searched, in order, for a gatewayIpAddress with an enabled Lcn. If found, the static route to this destination IP Address is updated to use the found gateway IP Address. Note that an Lcn interface can fail due to either the Vc through the Passport Network failing, or an Lmi indication that the far-end link is failed.')
mscIpiFrSrBGtyIpaEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 327, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrSrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrSrBGtyIpaIndex"))
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaEntry.setDescription('An entry in the mscIpiFrSrBGtyIpaTable.')
mscIpiFrSrBGtyIpaIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 327, 1, 1), Integer32().subtype(subtypeSpec=ValueRangeConstraint(1, 23)))
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaIndex.setDescription('This variable represents the index for the mscIpiFrSrBGtyIpaTable.')
mscIpiFrSrBGtyIpaValue = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 327, 1, 2), IpAddress()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaValue.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaValue.setDescription('This variable represents an individual value for the mscIpiFrSrBGtyIpaTable.')
mscIpiFrSrBGtyIpaRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 5, 327, 1, 3), RowStatus()).setMaxAccess("writeonly")
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrSrBGtyIpaRowStatus.setDescription('This variable is used to control the addition and deletion of individual values of the mscIpiFrSrBGtyIpaTable.')
mscIpiFrR = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6))
mscIpiFrRRowStatusTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 1), )
if mibBuilder.loadTexts: mscIpiFrRRowStatusTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRRowStatusTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This entry controls the addition and deletion of mscIpiFrR components.')
mscIpiFrRRowStatusEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 1, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrRIndex"))
if mibBuilder.loadTexts: mscIpiFrRRowStatusEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRRowStatusEntry.setDescription('A single entry in the table represents a single mscIpiFrR component.')
mscIpiFrRRowStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 1, 1, 1), RowStatus()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrRRowStatus.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRRowStatus.setDescription('This variable is used as the basis for SNMP naming of mscIpiFrR components. These components cannot be added nor deleted.')
mscIpiFrRComponentName = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 1, 1, 2), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrRComponentName.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRComponentName.setDescription("This variable provides the component's string name for use with the ASCII Console Interface")
mscIpiFrRStorageType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 1, 1, 4), StorageType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrRStorageType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRStorageType.setDescription('This variable represents the storage type value for the mscIpiFrR tables.')
mscIpiFrRIndex = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 1, 1, 10), IpAddress())
if mibBuilder.loadTexts: mscIpiFrRIndex.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRIndex.setDescription('This variable represents the index for the mscIpiFrR tables.')
mscIpiFrROperTable = MibTable((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 10), )
if mibBuilder.loadTexts: mscIpiFrROperTable.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrROperTable.setDescription('*** THIS TABLE CURRENTLY NOT IMPLEMENTED *** This group contains operational status of the static route')
mscIpiFrROperEntry = MibTableRow((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 10, 1), ).setIndexNames((0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrIndex"), (0, "Nortel-MsCarrier-MscPassport-IpiFrMIB", "mscIpiFrRIndex"))
if mibBuilder.loadTexts: mscIpiFrROperEntry.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrROperEntry.setDescription('An entry in the mscIpiFrROperTable.')
mscIpiFrRGtyIpAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 10, 1, 1), IpAddress().clone(hexValue="00000000")).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrRGtyIpAddr.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRGtyIpAddr.setDescription('The attribute specifies the IP Address of the next hop in this route to the destination IP Address.')
mscIpiFrRLcnIf = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 10, 1, 3), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(16, 39))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrRLcnIf.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRLcnIf.setDescription('This attribute specifies the Lcn interface used by this IP route.')
mscIpiFrRType = MibTableColumn((1, 3, 6, 1, 4, 1, 562, 36, 2, 1, 50, 6, 10, 1, 4), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("host", 1), ("subnet", 2), ("network", 3)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: mscIpiFrRType.setStatus('mandatory')
if mibBuilder.loadTexts: mscIpiFrRType.setDescription('This attribute indicates whether a route is going to a host or a subnet or a network.')
ipiFrGroup = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 1))
ipiFrGroupCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 1, 1))
ipiFrGroupCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 1, 1, 3))
ipiFrGroupCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 1, 1, 3, 2))
ipiFrCapabilities = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 3))
ipiFrCapabilitiesCA = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 3, 1))
ipiFrCapabilitiesCA02 = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 3, 1, 3))
ipiFrCapabilitiesCA02A = MibIdentifier((1, 3, 6, 1, 4, 1, 562, 36, 2, 2, 35, 3, 1, 3, 2))
mibBuilder.exportSymbols("Nortel-MsCarrier-MscPassport-IpiFrMIB", mscIpiFrLcnVcMaxSubnetPktSize=mscIpiFrLcnVcMaxSubnetPktSize, mscIpiFrRRowStatusEntry=mscIpiFrRRowStatusEntry, mscIpiFrSubnetMask=mscIpiFrSubnetMask, mscIpiFrLcnVcSegmentsRx=mscIpiFrLcnVcSegmentsRx, mscIpiFrDnaComponentName=mscIpiFrDnaComponentName, mscIpiFrLcnVcDmepValue=mscIpiFrLcnVcDmepValue, mscIpiFrLcnVcRowStatus=mscIpiFrLcnVcRowStatus, ipiFrCapabilities=ipiFrCapabilities, mscIpiFrLcnVcCallReferenceNumberDecimal=mscIpiFrLcnVcCallReferenceNumberDecimal, mscIpiFrLcnVcPathReliability=mscIpiFrLcnVcPathReliability, mscIpiFrLcnDcRemoteDlci=mscIpiFrLcnDcRemoteDlci, mscIpiFrLcnVcOutOfRangeFrmFromSubnet=mscIpiFrLcnVcOutOfRangeFrmFromSubnet, mscIpiFrLcnVcDmepTable=mscIpiFrLcnVcDmepTable, mscIpiFr=mscIpiFr, mscIpiFrSrRowStatusEntry=mscIpiFrSrRowStatusEntry, mscIpiFrLcnVcPeakRetryQueueSize=mscIpiFrLcnVcPeakRetryQueueSize, mscIpiFrDnaAddressEntry=mscIpiFrDnaAddressEntry, mscIpiFrDnaIndex=mscIpiFrDnaIndex, mscIpiFrLcnVcNotDataXferToSubnet=mscIpiFrLcnVcNotDataXferToSubnet, ipiFrCapabilitiesCA02=ipiFrCapabilitiesCA02, mscIpiFrRStorageType=mscIpiFrRStorageType, mscIpiFrDnaIncomingOptionsEntry=mscIpiFrDnaIncomingOptionsEntry, mscIpiFrDnaCugInterlockCode=mscIpiFrDnaCugInterlockCode, mscIpiFrMaximumNumberOfLcn=mscIpiFrMaximumNumberOfLcn, mscIpiFrLcnVcCannotForwardToSubnet=mscIpiFrLcnVcCannotForwardToSubnet, mscIpiFrLcnVcRowStatusEntry=mscIpiFrLcnVcRowStatusEntry, mscIpiFrLcnVcPriority=mscIpiFrLcnVcPriority, mscIpiFrLcnProvEntry=mscIpiFrLcnProvEntry, mscIpiFrLcnDc=mscIpiFrLcnDc, mscIpiFrLcnVcFrdEntry=mscIpiFrLcnVcFrdEntry, mscIpiFrLcnVcIntdEntry=mscIpiFrLcnVcIntdEntry, mscIpiFrLcnDcRemoteDna=mscIpiFrLcnDcRemoteDna, mscIpiFrLcnVcFastSelectCall=mscIpiFrLcnVcFastSelectCall, mscIpiFrLcnVcIndex=mscIpiFrLcnVcIndex, mscIpiFrRLcnIf=mscIpiFrRLcnIf, mscIpiFrDnaIncomingOptionsTable=mscIpiFrDnaIncomingOptionsTable, mscIpiFrLcnOperTable=mscIpiFrLcnOperTable, mscIpiFrLcnVcSubnetRecoveries=mscIpiFrLcnVcSubnetRecoveries, mscIpiFrDnaIncAccess=mscIpiFrDnaIncAccess, mscIpiFrDnaCugRowStatus=mscIpiFrDnaCugRowStatus, mscIpiFrDnaRowStatus=mscIpiFrDnaRowStatus, mscIpiFrLcn=mscIpiFrLcn, mscIpiFrLcnUsageState=mscIpiFrLcnUsageState, mscIpiFrDnaServiceCategory=mscIpiFrDnaServiceCategory, mscIpiFrLcnAvailabilityStatus=mscIpiFrLcnAvailabilityStatus, mscIpiFrDnaStorageType=mscIpiFrDnaStorageType, mscIpiFrDnaNumberingPlanIndicator=mscIpiFrDnaNumberingPlanIndicator, ipiFrGroupCA=ipiFrGroupCA, mscIpiFrLcnAdminState=mscIpiFrLcnAdminState, mscIpiFrLcnStateEntry=mscIpiFrLcnStateEntry, mscIpiFrLcnVcCombErrorsFromSubnet=mscIpiFrLcnVcCombErrorsFromSubnet, mscIpiFrDnaCugType=mscIpiFrDnaCugType, mscIpiFrDnaOutDefaultPriority=mscIpiFrDnaOutDefaultPriority, mscIpiFrDnaCugComponentName=mscIpiFrDnaCugComponentName, mscIpiFrROperEntry=mscIpiFrROperEntry, mscIpiFrLcnVcSendSequenceNumber=mscIpiFrLcnVcSendSequenceNumber, mscIpiFrRowStatusTable=mscIpiFrRowStatusTable, mscIpiFrDnaCugRowStatusTable=mscIpiFrDnaCugRowStatusTable, mscIpiFrR=mscIpiFrR, mscIpiFrLcnProvTable=mscIpiFrLcnProvTable, mscIpiFrRRowStatusTable=mscIpiFrRRowStatusTable, mscIpiFrLcnDcNfaTable=mscIpiFrLcnDcNfaTable, mscIpiFrLcnOpRemoteIpAddress=mscIpiFrLcnOpRemoteIpAddress, ipiFrGroupCA02A=ipiFrGroupCA02A, mscIpiFrDnaAddressTable=mscIpiFrDnaAddressTable, mscIpiFrLcnOperEntry=mscIpiFrLcnOperEntry, mscIpiFrDnaCallOptionsTable=mscIpiFrDnaCallOptionsTable, mscIpiFrLcnVcStorageType=mscIpiFrLcnVcStorageType, mscIpiFrDnaCugStorageType=mscIpiFrDnaCugStorageType, mscIpiFrLcnDcTransferPriority=mscIpiFrLcnDcTransferPriority, mscIpiFrProvTable=mscIpiFrProvTable, mscIpiFrStorageType=mscIpiFrStorageType, mscIpiFrLcnVcAccountingEnd=mscIpiFrLcnVcAccountingEnd, mscIpiFrProvEntry=mscIpiFrProvEntry, mscIpiFrIpAddress=mscIpiFrIpAddress, mscIpiFrLcnIndex=mscIpiFrLcnIndex, mscIpiFrRowStatus=mscIpiFrRowStatus, mscIpiFrLcnDcStorageType=mscIpiFrLcnDcStorageType, mscIpiFrLcnIpInterfaceDevice=mscIpiFrLcnIpInterfaceDevice, mscIpiFrIndex=mscIpiFrIndex, mscIpiFrLcnVcCalledNpi=mscIpiFrLcnVcCalledNpi, mscIpiFrLcnVcEmissionPriorityFromNetwork=mscIpiFrLcnVcEmissionPriorityFromNetwork, mscIpiFrDnaAccountClass=mscIpiFrDnaAccountClass, mscIpiFrLcnDcRowStatusTable=mscIpiFrLcnDcRowStatusTable, mscIpiFrLcnVcNotDataXferFromSubnet=mscIpiFrLcnVcNotDataXferFromSubnet, mscIpiFrLcnStateTable=mscIpiFrLcnStateTable, mscIpiFrLcnDcRowStatus=mscIpiFrLcnDcRowStatus, mscIpiFrDnaOutPathSensitivityOverRide=mscIpiFrDnaOutPathSensitivityOverRide, mscIpiFrLcnVcPreviousDiagnosticCode=mscIpiFrLcnVcPreviousDiagnosticCode, mscIpiFrDnaIncCalls=mscIpiFrDnaIncCalls, mscIpiFrLcnVcPreviousState=mscIpiFrLcnVcPreviousState, mscIpiFrLcnVcPeakOoSeqPktCount=mscIpiFrLcnVcPeakOoSeqPktCount, mscIpiFrLcnVcPeakOoSeqByteCount=mscIpiFrLcnVcPeakOoSeqByteCount, mscIpiFrLcnVcDmepEntry=mscIpiFrLcnVcDmepEntry, mscIpiFrDnaCugIndex=mscIpiFrDnaCugIndex, mscIpiFrLcnVcAccountingEnabled=mscIpiFrLcnVcAccountingEnabled, mscIpiFrLcnPacketsReceived=mscIpiFrLcnPacketsReceived, mscIpiFrRRowStatus=mscIpiFrRRowStatus, mscIpiFrROperTable=mscIpiFrROperTable, mscIpiFrLcnVcCadEntry=mscIpiFrLcnVcCadEntry, mscIpiFrDnaOutDefaultPathSensitivity=mscIpiFrDnaOutDefaultPathSensitivity, mscIpiFrLcnDcOptionsTable=mscIpiFrLcnDcOptionsTable, mscIpiFrDnaDefaultTransferPriority=mscIpiFrDnaDefaultTransferPriority, mscIpiFrLcnVcDuplicatesFromSubnet=mscIpiFrLcnVcDuplicatesFromSubnet, mscIpiFrLcnVcType=mscIpiFrLcnVcType, mscIpiFrLcnDcComponentName=mscIpiFrLcnDcComponentName, mscIpiFrLcnVcComponentName=mscIpiFrLcnVcComponentName, mscIpiFrLcnVcRcosToNetwork=mscIpiFrLcnVcRcosToNetwork, mscIpiFrLcnVcFrdTable=mscIpiFrLcnVcFrdTable, mscIpiFrSrIndex=mscIpiFrSrIndex, mscIpiFrDnaCugCugOptionsEntry=mscIpiFrDnaCugCugOptionsEntry, mscIpiFrLcnVcCadTable=mscIpiFrLcnVcCadTable, mscIpiFrDnaRowStatusTable=mscIpiFrDnaRowStatusTable, mscIpiFrDnaDataNetworkAddress=mscIpiFrDnaDataNetworkAddress, mscIpiFrLcnOperationalState=mscIpiFrLcnOperationalState, mscIpiFrLcnVcCalledDna=mscIpiFrLcnVcCalledDna, mscIpiFrLcnVcCallingNpi=mscIpiFrLcnVcCallingNpi, mscIpiFrLcnVcCallingLcn=mscIpiFrLcnVcCallingLcn, mscIpiFrSrRowStatus=mscIpiFrSrRowStatus, mscIpiFrSrBGtyIpaEntry=mscIpiFrSrBGtyIpaEntry, mscIpiFrLcnVcFrmCongestedToSubnet=mscIpiFrLcnVcFrmCongestedToSubnet, mscIpiFrDnaRowStatusEntry=mscIpiFrDnaRowStatusEntry, mscIpiFrDnaOutgoingOptionsEntry=mscIpiFrDnaOutgoingOptionsEntry, mscIpiFrSrBGtyIpaRowStatus=mscIpiFrSrBGtyIpaRowStatus, mscIpiFrLcnProceduralStatus=mscIpiFrLcnProceduralStatus, mscIpiFrLcnDiscardRcvPackets=mscIpiFrLcnDiscardRcvPackets, mscIpiFrRowStatusEntry=mscIpiFrRowStatusEntry, mscIpiFrLcnDcNfaEntry=mscIpiFrLcnDcNfaEntry, mscIpiFrDnaCallOptionsEntry=mscIpiFrDnaCallOptionsEntry, mscIpiFrLcnDcOptionsEntry=mscIpiFrLcnDcOptionsEntry, mscIpiFrSr=mscIpiFrSr, mscIpiFrLcnVcIntdTable=mscIpiFrLcnVcIntdTable, mscIpiFrLcnRemoteIpAddress=mscIpiFrLcnRemoteIpAddress, mscIpiFrLcnVcOoSeqPktCntExceeded=mscIpiFrLcnVcOoSeqPktCntExceeded, mscIpiFrSrStorageType=mscIpiFrSrStorageType, mscIpiFrDnaCugDnic=mscIpiFrDnaCugDnic, mscIpiFrLcnVcDiagnosticCode=mscIpiFrLcnVcDiagnosticCode, mscIpiFrLcnDcNfaIndex=mscIpiFrLcnDcNfaIndex, mscIpiFrLcnVc=mscIpiFrLcnVc, mscIpiFrLcnVcSegmentsSent=mscIpiFrLcnVcSegmentsSent, mscIpiFrLcnVcFrmLossTimeouts=mscIpiFrLcnVcFrmLossTimeouts, mscIpiFrLcnDiscardTxPackets=mscIpiFrLcnDiscardTxPackets, mscIpiFrLcnDcType=mscIpiFrLcnDcType, mscIpiFrLcnRowStatus=mscIpiFrLcnRowStatus, ipiFrCapabilitiesCA=ipiFrCapabilitiesCA, mscIpiFrDnaOutCalls=mscIpiFrDnaOutCalls, mscIpiFrSrGatewayIpAddress=mscIpiFrSrGatewayIpAddress, ipiFrCapabilitiesCA02A=ipiFrCapabilitiesCA02A, mscIpiFrLcnAlarmStatus=mscIpiFrLcnAlarmStatus, mscIpiFrLcnDcIndex=mscIpiFrLcnDcIndex, mscIpiFrSrRowStatusTable=mscIpiFrSrRowStatusTable, mscIpiFrLcnVcPeakOoSeqFrmForwarded=mscIpiFrLcnVcPeakOoSeqFrmForwarded, mscIpiFrLcnVcRowStatusTable=mscIpiFrLcnVcRowStatusTable, mscIpiFrComponentName=mscIpiFrComponentName, mscIpiFrLcnVcRcosFromNetwork=mscIpiFrLcnVcRcosFromNetwork, mscIpiFrLcnVcEmissionPriorityToNetwork=mscIpiFrLcnVcEmissionPriorityToNetwork, mscIpiFrDnaTransferPriorityOverRide=mscIpiFrDnaTransferPriorityOverRide, mscIpiFrRIndex=mscIpiFrRIndex, mscIpiFrLcnVcStartTime=mscIpiFrLcnVcStartTime, mscIpiFrDnaOutgoingOptionsTable=mscIpiFrDnaOutgoingOptionsTable, mscIpiFrRGtyIpAddr=mscIpiFrRGtyIpAddr, ipiFrGroup=ipiFrGroup, mscIpiFrLcnVcPktRetryTimeouts=mscIpiFrLcnVcPktRetryTimeouts, mscIpiFrRType=mscIpiFrRType, mscIpiFrLcnStandbyStatus=mscIpiFrLcnStandbyStatus, mscIpiFrSrProvTable=mscIpiFrSrProvTable, mscIpiFrRComponentName=mscIpiFrRComponentName, mscIpiFrLcnVcCalledLcn=mscIpiFrLcnVcCalledLcn, mscIpiFrLcnDcRowStatusEntry=mscIpiFrLcnDcRowStatusEntry, mscIpiFrLcnPacketsSent=mscIpiFrLcnPacketsSent, mscIpiFrLcnDcNfaValue=mscIpiFrLcnDcNfaValue, mscIpiFrLcnDcRemoteNpi=mscIpiFrLcnDcRemoteNpi, mscIpiFrLcnDcDiscardPriority=mscIpiFrLcnDcDiscardPriority, mscIpiFrLcnVcCallingDna=mscIpiFrLcnVcCallingDna, mscIpiFrLcnVcState=mscIpiFrLcnVcState, mscIpiFrDnaCugRowStatusEntry=mscIpiFrDnaCugRowStatusEntry, mscIpiFrLcnVcDataPath=mscIpiFrLcnVcDataPath, mscIpiFrLcnRowStatusEntry=mscIpiFrLcnRowStatusEntry, mscIpiFrSrBGtyIpaTable=mscIpiFrSrBGtyIpaTable, mscIpiFrSrComponentName=mscIpiFrSrComponentName, mscIpiFrLcnControlStatus=mscIpiFrLcnControlStatus, mscIpiFrDnaCugIncCalls=mscIpiFrDnaCugIncCalls, mscIpiFrDna=mscIpiFrDna, mscIpiFrDnaServiceExchange=mscIpiFrDnaServiceExchange, mscIpiFrLcnRowStatusTable=mscIpiFrLcnRowStatusTable, mscIpiFrLcnVcSegmentSize=mscIpiFrLcnVcSegmentSize, mscIpiFrLcnUnknownStatus=mscIpiFrLcnUnknownStatus, mscIpiFrDnaCugCugOptionsTable=mscIpiFrDnaCugCugOptionsTable, mscIpiFrLcnStorageType=mscIpiFrLcnStorageType, mscIpiFrLcnComponentName=mscIpiFrLcnComponentName, mscIpiFrLcnVcOoSeqByteCntExceeded=mscIpiFrLcnVcOoSeqByteCntExceeded, mscIpiFrSrProvEntry=mscIpiFrSrProvEntry, ipiFrGroupCA02=ipiFrGroupCA02, mscIpiFrLcnVcElapsedTimeTillNow=mscIpiFrLcnVcElapsedTimeTillNow, mscIpiFrLcnDcNfaRowStatus=mscIpiFrLcnDcNfaRowStatus, mscIpiFrDnaCug=mscIpiFrDnaCug, ipiFrMIB=ipiFrMIB, mscIpiFrSrBGtyIpaValue=mscIpiFrSrBGtyIpaValue, mscIpiFrSrBGtyIpaIndex=mscIpiFrSrBGtyIpaIndex, mscIpiFrLcnVcCallReferenceNumber=mscIpiFrLcnVcCallReferenceNumber)

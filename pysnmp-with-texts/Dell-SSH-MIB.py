#
# PySNMP MIB module Dell-SSH-MIB (http://snmplabs.com/pysmi)
# ASN.1 source file:///Users/davwang4/Dev/mibs.snmplabs.com/asn1/Dell-SSH-MIB
# Produced by pysmi-0.3.4 at Wed May  1 12:56:42 2019
# On host DAVWANG4-M-1475 platform Darwin version 18.5.0 by user davwang4
# Using Python version 3.7.3 (default, Mar 27 2019, 09:23:15) 
#
OctetString, Integer, ObjectIdentifier = mibBuilder.importSymbols("ASN1", "OctetString", "Integer", "ObjectIdentifier")
NamedValues, = mibBuilder.importSymbols("ASN1-ENUMERATION", "NamedValues")
ValueRangeConstraint, SingleValueConstraint, ValueSizeConstraint, ConstraintsIntersection, ConstraintsUnion = mibBuilder.importSymbols("ASN1-REFINEMENT", "ValueRangeConstraint", "SingleValueConstraint", "ValueSizeConstraint", "ConstraintsIntersection", "ConstraintsUnion")
rnd, = mibBuilder.importSymbols("Dell-MIB", "rnd")
InetAddress, InetAddressType = mibBuilder.importSymbols("INET-ADDRESS-MIB", "InetAddress", "InetAddressType")
ModuleCompliance, NotificationGroup = mibBuilder.importSymbols("SNMPv2-CONF", "ModuleCompliance", "NotificationGroup")
Integer32, Gauge32, ModuleIdentity, NotificationType, MibIdentifier, Unsigned32, Counter64, Counter32, ObjectIdentity, MibScalar, MibTable, MibTableRow, MibTableColumn, IpAddress, TimeTicks, Bits, iso = mibBuilder.importSymbols("SNMPv2-SMI", "Integer32", "Gauge32", "ModuleIdentity", "NotificationType", "MibIdentifier", "Unsigned32", "Counter64", "Counter32", "ObjectIdentity", "MibScalar", "MibTable", "MibTableRow", "MibTableColumn", "IpAddress", "TimeTicks", "Bits", "iso")
RowStatus, DisplayString, TextualConvention = mibBuilder.importSymbols("SNMPv2-TC", "RowStatus", "DisplayString", "TextualConvention")
rlSsh = ModuleIdentity((1, 3, 6, 1, 4, 1, 89, 78))
rlSsh.setRevisions(('2003-01-03 00:24', '2003-09-21 00:24',))

if getattr(mibBuilder, 'version', (0, 0, 0)) > (4, 4, 0):
    if mibBuilder.loadTexts: rlSsh.setRevisionsDescriptions(('The second revision', 'Editorial changes.',))
if mibBuilder.loadTexts: rlSsh.setLastUpdated('200209300024Z')
if mibBuilder.loadTexts: rlSsh.setOrganization('Dell')
if mibBuilder.loadTexts: rlSsh.setContactInfo('www.dell.com')
if mibBuilder.loadTexts: rlSsh.setDescription("The MIB module describes the private MIB for SSH supported by Dell's software and products.")
class RlSshPublicKeyAlgorithm(TextualConvention, Integer32):
    description = 'This textual convention describes the various possible public key algorithms. The key algorithm is used to select the PK to be generated and is also used when viewing the public keys.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1, 2, 999))
    namedValues = NamedValues(("rsa1", 0), ("rsa", 1), ("dsa", 2), ("none", 999))

class RlSshPublicKeyDigestFormat(TextualConvention, Integer32):
    description = 'This textual convention describes the format used to display the public key fingerprint. The hex format is the format used by PGP and OpenSSH. The bubble-babble format is used by SSH.com software.'
    status = 'current'
    subtypeSpec = Integer32.subtypeSpec + ConstraintsUnion(SingleValueConstraint(0, 1))
    namedValues = NamedValues(("hex", 0), ("bubbleBabble", 1))

rlSshMibVersion = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 1), Integer32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshMibVersion.setStatus('current')
if mibBuilder.loadTexts: rlSshMibVersion.setDescription('The MIB version. The current version is 2')
rlSshServer = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 78, 2))
rlSshServerHostPublicKeyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 2, 1), )
if mibBuilder.loadTexts: rlSshServerHostPublicKeyTable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyTable.setDescription("This table contains the router's public key. Each row in this table contains a fragment of the key, in printable binhex format. There may be up to 160 characters in every fragment, and they are all combined to form one key. The key is generated by writing to rlSshServerRegenerateHostKey. To cause clients to connect to this router without printing warning messages (and also prevent active man-in-the-middle), the router's public key must printed out and inserted into the client's authorized_keys file")
rlSshServerHostPublicKeyTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 2, 1, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshServerHostPublicKeyAlgorithm"), (0, "Dell-SSH-MIB", "rlSshServerHostPublicKeyFragmentId"))
if mibBuilder.loadTexts: rlSshServerHostPublicKeyTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyTableEntry.setDescription(' The row definition for this table.')
rlSshServerHostPublicKeyAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 1, 1, 1), RlSshPublicKeyAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerHostPublicKeyAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyAlgorithm.setDescription('Identifies the type of public key to be displayed.')
rlSshServerHostPublicKeyFragmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 1, 1, 2), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFragmentId.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFragmentId.setDescription('Identifies the index of this fragment in the final key. All segments must be combined to form one big key.')
rlSshServerHostPublicKeyFragmentText = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 1, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFragmentText.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFragmentText.setDescription("A part of the readable text entry for the server's public authorzation key.")
rlSshServerHostPublicKeyFingerprintTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 2, 2), )
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintTable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintTable.setDescription("This table contains the fingerprint for the router's public key.")
rlSshServerHostPublicKeyFingerprintTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 2, 2, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshServerHostPublicKeyFingerprintAlgorithm"), (0, "Dell-SSH-MIB", "rlSshServerHostPublicKeyFingerprintDigestFormat"))
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintTableEntry.setDescription(' The row definition for this table.')
rlSshServerHostPublicKeyFingerprintAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 2, 1, 1), RlSshPublicKeyAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintAlgorithm.setDescription('Identifies the type of public key to be displayed.')
rlSshServerHostPublicKeyFingerprintDigestFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 2, 1, 2), RlSshPublicKeyDigestFormat()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintDigestFormat.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprintDigestFormat.setDescription('Format of the digest to be displayed (OpenSSH or SSH.com).')
rlSshServerHostPublicKeyFingerprint = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 2, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprint.setStatus('current')
if mibBuilder.loadTexts: rlSshServerHostPublicKeyFingerprint.setDescription("SECSH format fingerprint of the server's public key. To prevent man in the middle attacks, users should make sure the ssh Server's fingerprint, as printed in the connection process, is similar to the one printed here.")
rlSshServerAuthorizedUsersPublicKeyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 2, 3), )
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyTable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyTable.setDescription("This table contains public keys for all users who are authorized to access the router. For a user to be able to log in using SSH, the user name must appear in this table, and the user's public key must match the one found here.")
rlSshServerAuthorizedUsersPublicKeyTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 2, 3, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshServerAuthorizedUserName"), (0, "Dell-SSH-MIB", "rlSshServerAuthorizedUserPublicKeyFragmentId"))
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyTableEntry.setDescription(' The row definition for this table.')
rlSshServerAuthorizedUserName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 3, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserName.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserName.setDescription('Name of the user who owns this public key. Both the user name and the key bytes must match before a user is authenticated using this key.')
rlSshServerAuthorizedUserPublicKeyFragmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 3, 1, 2), Unsigned32()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFragmentId.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFragmentId.setDescription('Identifies the index of this fragment in the final key. All segments must be combined to form one big key.')
rlSshServerAuthorizedUserPublicKeyFragmentText = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 3, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFragmentText.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFragmentText.setDescription("A part of the readable text entry for the user's public authorzation key.")
rlSshServerAuthorizedUserPublicKeyFragmentStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 3, 1, 4), RowStatus()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFragmentStatus.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFragmentStatus.setDescription("Create or delete a fragment of the user's public key. A user is deleted if it has no remaining fragments.")
rlSshServerAuthorizedUsersPublicKeyFingerprintTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 2, 5), )
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyFingerprintTable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyFingerprintTable.setDescription("This table contains the fingerprints of the public keys for all users who are authorized to access the router. To prevent man in the middle attacks, users should make sure the user's fingerprint, as printed in the connection process, is similar to the one printed here.")
rlSshServerAuthorizedUsersPublicKeyFingerprintTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 2, 5, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshServerAuthorizedUserFingerprintName"), (0, "Dell-SSH-MIB", "rlSshServerAuthorizedUserPublicKeyFingerprintDigestFormat"))
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyFingerprintTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUsersPublicKeyFingerprintTableEntry.setDescription(' The row definition for this table.')
rlSshServerAuthorizedUserFingerprintName = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 5, 1, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 48))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserFingerprintName.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserFingerprintName.setDescription('Name of the user who owns this public key. Both the user name and the key bytes must match before a user is authenticated using this key.')
rlSshServerAuthorizedUserPublicKeyFingerprintAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 5, 1, 2), RlSshPublicKeyAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFingerprintAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFingerprintAlgorithm.setDescription('Identifies the type of public key to be displayed.')
rlSshServerAuthorizedUserPublicKeyFingerprintDigestFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 5, 1, 3), RlSshPublicKeyDigestFormat()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFingerprintDigestFormat.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFingerprintDigestFormat.setDescription('Format of the digest to be displayed (OpenSSH or SSH.com).')
rlSshServerAuthorizedUserPublicKeyFingerprint = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 5, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFingerprint.setStatus('current')
if mibBuilder.loadTexts: rlSshServerAuthorizedUserPublicKeyFingerprint.setDescription("SECSH format fingerprint of the user's public key. To prevent man in the middle attacks, users should make sure their ssh fingerprint, as printed in the connection process, is similar to the one printed here.")
rlSshServerSessionTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 2, 6), )
if mibBuilder.loadTexts: rlSshServerSessionTable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionTable.setDescription('Each row in this table corresponds to an active SSH session with the server')
rlSshServerSessionTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshServerSessionIdentifier"))
if mibBuilder.loadTexts: rlSshServerSessionTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionTableEntry.setDescription(' The row definition for this table.')
rlSshServerSessionIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionIdentifier.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionIdentifier.setDescription('Identifies the connection to which this row corresponds.')
rlSshServerSessionPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1, 2), IpAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionPeerAddress.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionPeerAddress.setDescription('The network address of the remote host connected to the server.')
rlSshServerSessionPeerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1, 3), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionPeerPort.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionPeerPort.setDescription('The source network port of the remote host connected to the server.')
rlSshServerSessionPeerVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1, 4), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionPeerVersion.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionPeerVersion.setDescription('The client version of the remote host connected to the server.')
rlSshServerSessionUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionUsername.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionUsername.setDescription('SSH authenticated name of user connected to the server.')
rlSshServerSessionCipher = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionCipher.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionCipher.setDescription('Data encryption cipher used in this connection.')
rlSshServerSessionHMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 6, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionHMAC.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionHMAC.setDescription('Message authentication code used in this connection.')
rlSshServerSessionInetTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 2, 7), )
if mibBuilder.loadTexts: rlSshServerSessionInetTable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetTable.setDescription('Each row in this table corresponds to an active SSH session with the server')
rlSshServerSessionInetTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshServerSessionInetIdentifier"))
if mibBuilder.loadTexts: rlSshServerSessionInetTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetTableEntry.setDescription('The row definition for this table.')
rlSshServerSessionInetIdentifier = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetIdentifier.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetIdentifier.setDescription('Identifies the connection to which this row corresponds.')
rlSshServerSessionInetPeerAddressType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 2), InetAddressType()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetPeerAddressType.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetPeerAddressType.setDescription('The network address of the remote host connected to the server.')
rlSshServerSessionInetPeerAddress = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 3), InetAddress()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetPeerAddress.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetPeerAddress.setDescription('The network address of the remote host connected to the server.')
rlSshServerSessionInetPeerPort = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 4), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetPeerPort.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetPeerPort.setDescription('The source network port of the remote host connected to the server.')
rlSshServerSessionInetPeerVersion = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 5), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetPeerVersion.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetPeerVersion.setDescription('The client version of the remote host connected to the server.')
rlSshServerSessionInetUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 6), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetUsername.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetUsername.setDescription('SSH authenticated name of user connected to the server.')
rlSshServerSessionInetCipher = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetCipher.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetCipher.setDescription('Data encryption cipher used in this connection.')
rlSshServerSessionInetHMAC = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 7, 1, 8), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerSessionInetHMAC.setStatus('current')
if mibBuilder.loadTexts: rlSshServerSessionInetHMAC.setDescription('Message authentication code used in this connection.')
rlSshServerImportExportSelfKeyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 2, 8), )
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyTable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyTable.setDescription('This table can be used for 2 purposes: 1) Importing public/private key pair to serve as the device key when acting as SSH server. This is done by setting entries to this table, according to the specified format. When the last entry (footer) is set, the whole key pair is checked and if valid, stored in CDB. 2) Exporting the device SSH server public/private key. This can be done by performing GetNext operations on this table.')
rlSshServerImportExportSelfKeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 2, 8, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshServerImportExportSelfKeyAlgorithm"), (0, "Dell-SSH-MIB", "rlSshServerImportExportSelfKeyFormat"), (0, "Dell-SSH-MIB", "rlSshServerImportExportSelfKeyFragmentId"))
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyEntry.setDescription(' The row definition for this table.')
rlSshServerImportExportSelfKeyAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 8, 1, 1), RlSshPublicKeyAlgorithm())
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyAlgorithm.setDescription('Identifies the type of key pair.')
rlSshServerImportExportSelfKeyFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 8, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("uuencoded-format", 1))))
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyFormat.setStatus('current')
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyFormat.setDescription('Specifies the format of public/key pair. The following formats are supported for import/export: 1) uuencoded_format - in this format both private and public key are in uu-encoded format, and are seperated from one another by header and footer. An example of the concateneation of all fragments in this format is: -----BEGIN RSA PRIVATE KEY----- tDaNkZZoCxXfkLLsLDlZ6T9H8U4Gz637eRV7BYBpapkidAxY1UG0/qgfKLPkbId4wzht6ArV9bE4fMtX wSMOxL3q31pOmUdVhjbWYcgZQBDy1DjFSbuIEdP85c96B9bBE2nPv90mSvb/6j8R2NItT/KJeiYMtLtI N3m6/zESKJGIrX0jP1RFDjVZSS5chSAFgB0egsLZEyOQn7jAqpX/x/easD2J6F/OjPXlJ9Hff2tMb3NU QYyBoWH2J9IxhWB6Vo66R9Y04JGR18uL/rV2sMCtpg5ppkVTEpNTp9qE1yXocR2NmzUfNFap+GJ4IHj8 CzkVfmJM/kEWaJsYgHbAgLyRg4QVyelfobv1B71aQ+u1z9KGu/QajkWdR04OQfsGOL1CvU2LGYDcRjfH jv+jl/UkDRRjoD9kt2WvouT+OL6esvKl0OJBqWbGNXg9TWv/VLtJIwgUno+MLaJuOM4Fh44+wpnqUXwQ TFtBFc8pzt5BoOwbv9gXpicTkq4/+GhwXWXxSVFebKhnHAvKSLT+Ba7K7ZeR8EIIxbXdDNFOiS45R2KI jxxXLXK44u6KGl5MygCKXUOFlJ+Zhgrq6ZH17z/RVJQ2CWqb5Ekn9GY3kH9QZ3mb4MDPfriWi2lHGXHY JmJd4SLQhpBdnOS5tu84QmyU3dNbAdzghDsR+dEY/6g7Cn0kcVkeHNZ0H+mCZik5f6XBD8eplkk43bdR FrkwTeAjwurGcKwdiKkR4DlfSq3DKssVBucTqUpqsKqPXLwTIL44rWKhEPXgGPB2XDG0VLvIRKkAgEGI LNTwOm091Ro= -----END RSA PRIVATE KEY----- -----BEGIN RSA PUBLIC KEY----- MIGHAoGBAOeIC9gRg3YaEGGMp3C00qNwLINAEDZV/J4BWM5WnWwCWZyHXDs2XiEmFu0ZONAD4gcT2f2f NNfCBPye39VVuOkKQuSV0MLLX5800LZ4y1BNcPzPZHpnGaCzl7iAjhfj9MolzAh5VRjeiYt0t1um4dm+ q9A4BtfpJqDYxCW9uxd/AgEj -----END RSA PUBLIC KEY----- ')
rlSshServerImportExportSelfKeyFragmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 8, 1, 3), Integer32())
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyFragmentId.setStatus('current')
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyFragmentId.setDescription('Identifies the index of this fragment in the key pair input/output.')
rlSshServerImportExportSelfKeyFragmentText = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 2, 8, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyFragmentText.setStatus('current')
if mibBuilder.loadTexts: rlSshServerImportExportSelfKeyFragmentText.setDescription('A part of the readable text entry for the key pair input/output.')
rlSshServerPort = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 101), Unsigned32().subtype(subtypeSpec=ValueRangeConstraint(1, 65535)).clone(22)).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerPort.setStatus('current')
if mibBuilder.loadTexts: rlSshServerPort.setDescription('Specifies the TCP port used by the SSH 2 Server to listen for incoming connections.')
rlSshServerEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 102), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerEnable.setStatus('current')
if mibBuilder.loadTexts: rlSshServerEnable.setDescription('Enables listening for incoming SSH2 connections on the port defined in rlSshServerPort.')
rlSshServerEnablePublicKeyAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 103), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerEnablePublicKeyAuthentication.setStatus('current')
if mibBuilder.loadTexts: rlSshServerEnablePublicKeyAuthentication.setDescription("If PK authentication is enabled, incoming SSH connections are authenticated using public key authentication (using rlSshServerAuthorizedUsersPublicKeyTable), before authenticating using the router's standard AAA.")
rlSshServerRegenerateHostKey = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 104), RlSshPublicKeyAlgorithm()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerRegenerateHostKey.setStatus('current')
if mibBuilder.loadTexts: rlSshServerRegenerateHostKey.setDescription('Setting to a value other than none results in the Server (Host) Key being regenerated. The key size is host-specific.')
rlSshServerDefaultKeyFlag = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 105), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rsa", 1), ("dsa", 2), ("all", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshServerDefaultKeyFlag.setStatus('current')
if mibBuilder.loadTexts: rlSshServerDefaultKeyFlag.setDescription('This scalar indicates which of the SSH server keys are default keys (automatically generated).')
rlSshServerDeleteSelfKey = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 106), RlSshPublicKeyAlgorithm()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerDeleteSelfKey.setStatus('current')
if mibBuilder.loadTexts: rlSshServerDeleteSelfKey.setDescription("Setting to a value other than 'none' results in deleting the server self key of the chosen type. As a result a default key may be created (according to the MTSC..)")
rlSshServerEnablePublicKeyAuthAutoLogin = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 107), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerEnablePublicKeyAuthAutoLogin.setStatus('current')
if mibBuilder.loadTexts: rlSshServerEnablePublicKeyAuthAutoLogin.setDescription('If PK authentication is succesfull and AAA local DB method is enabled for SSH line, the username is checked with AAA local DB. If present, the user is authenticated automatically without prompting for username or password.')
rlSshServerEnablePasswordAuthentication = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 2, 108), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshServerEnablePasswordAuthentication.setStatus('current')
if mibBuilder.loadTexts: rlSshServerEnablePasswordAuthentication.setDescription("If password authentication is enabled, incoming SSH connections are authenticated with username/password authentication using the router's standard AAA.")
rlSshClient = MibIdentifier((1, 3, 6, 1, 4, 1, 89, 78, 3))
rlSshClientUserName = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 3, 1), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 70)).clone('anonymous')).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientUserName.setStatus('current')
if mibBuilder.loadTexts: rlSshClientUserName.setDescription("Specifies the default user name the ssh client will use when authenticating to a remote server. In SCP sessions this global user name will be used unless a specific user name has been specified for the operation. The value of this MIB must not contain charachters ':' or '@' (those are used to indicate parameters seperation in SCP copy).")
rlSshClientRegenerateSelfKey = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 3, 2), RlSshPublicKeyAlgorithm()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientRegenerateSelfKey.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRegenerateSelfKey.setDescription('Setting to a value other than none results in the client self key being regenerated. The key size is host-specific.')
rlSshClientSelfPublicKeyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 3, 3), )
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyTable.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyTable.setDescription("This table contains the router's client self public key. Each row in this table contains a fragment of the key, in printable binhex format. There may be up to 160 characters in every fragment, and they are all combined to form one key. The key is generated by writing to rlSshClientRegenerateSelfKey. To cause clients to connect to this router without printing warning messages (and also prevent active man-in-the-middle), the router's public key must printed out and inserted into the client's authorized_keys file")
rlSshClientSelfPublicKeyTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 3, 3, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshClientSelfPublicKeyAlgorithm"), (0, "Dell-SSH-MIB", "rlSshClientSelfPublicKeyFragmentId"))
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyTableEntry.setDescription(' The row definition for this table.')
rlSshClientSelfPublicKeyFragmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 3, 1, 1), Unsigned32()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFragmentId.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFragmentId.setDescription('Identifies the index of this fragment in the final key. All segments must be combined to form one big key.')
rlSshClientSelfPublicKeyAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 3, 1, 2), RlSshPublicKeyAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyAlgorithm.setDescription('Identifies the type of public key to be displayed.')
rlSshClientSelfPublicKeyFragmentText = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 3, 1, 3), DisplayString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFragmentText.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFragmentText.setDescription("A part of the readable text entry for the router's client public authorization key.")
rlSshClientSelfPublicKeyFingerprintTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 3, 4), )
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintTable.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintTable.setDescription("This table contains the fingerprint for the client's self key. ")
rlSshClientSelfPublicKeyFingerprintTableEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 3, 4, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshClientSelfPublicKeyFingerprintAlgorithm"), (0, "Dell-SSH-MIB", "rlSshClientSelfPublicKeyFingerprintDigestFormat"))
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintTableEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintTableEntry.setDescription(' The row definition for this table.')
rlSshClientSelfPublicKeyFingerprintAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 4, 1, 1), RlSshPublicKeyAlgorithm()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintAlgorithm.setDescription('Identifies the type of public key to be displayed.')
rlSshClientSelfPublicKeyFingerprintDigestFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 4, 1, 2), RlSshPublicKeyDigestFormat()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintDigestFormat.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprintDigestFormat.setDescription('Format of the digest to be displayed (OpenSSH or SSH.com).')
rlSshClientSelfPublicKeyFingerprint = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 4, 1, 3), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprint.setStatus('current')
if mibBuilder.loadTexts: rlSshClientSelfPublicKeyFingerprint.setDescription("SECSH format fingerprint of the client's self key. To prevent man in the middle attacks, users should make sure the ssh Server's fingerprint, as printed in the connection process, is similar to the one printed here.")
rlSshClientAuthenticationMethod = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 3, 5), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3))).clone(namedValues=NamedValues(("public-key-rsa", 1), ("public-key-dsa", 2), ("password", 3)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientAuthenticationMethod.setStatus('current')
if mibBuilder.loadTexts: rlSshClientAuthenticationMethod.setDescription('Specifies the global authentication method for SSH client. SSH client will apply this authentication method upon connecting to a remote server, if no specific authentication method has been defined for this operation.')
rlSshClientPassword = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 3, 6), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientPassword.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPassword.setDescription("Specifies the global password for SSH client, to be used for 'password' authentication. SSH client will use this password during authentication phase (when connecting remote server), in case no specific password has been specified for this operation. The value of this MIB must not contain charachters ':' or '@' (those are used to indicate parameters seperation in SCP copy). Upon setting the password, its length must be in range 1-70.")
rlSshClientPasswordChangeTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 3, 7), )
if mibBuilder.loadTexts: rlSshClientPasswordChangeTable.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeTable.setDescription("This table allows the user to change the password in a remote SSH server. It should be used when working with 'password' authentication with remote server in SCP sessions. Set operation on this table will initiate SCP session with the SSH server whose inet address is specified in the key rlSshClientPasswordChangeInetAddress. During this session the password for username rlSshClientPasswordChangeUsername will be changed in the server from rlSshClientPasswordChangeOldPassword to rlSshClientPasswordChangeNewPassword. The Set operation might fail, in case an SCP session is already being held. In case 'noError' is returned, the user can poll the fields rlSshClientPasswordChangeStatus and rlSshClientPasswordChangeFailureReason in order to get information on operation status and possible failure reason. Note: up to 3 status records can be saved.")
rlSshClientPasswordChangeEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshClientPasswordChangeInetAddrType"), (0, "Dell-SSH-MIB", "rlSshClientPasswordChangeInetAddr"))
if mibBuilder.loadTexts: rlSshClientPasswordChangeEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeEntry.setDescription(' The row definition for this table.')
rlSshClientPasswordChangeInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rlSshClientPasswordChangeInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeInetAddrType.setDescription('Specifies the inet address type of remote SCP server')
rlSshClientPasswordChangeInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlSshClientPasswordChangeInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeInetAddr.setDescription('Specifies the inet address of remote SCP server')
rlSshClientPasswordChangeUsername = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1, 3), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(1, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientPasswordChangeUsername.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeUsername.setDescription('Specifies the username for which the password change is required.')
rlSshClientPasswordChangeOldPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1, 4), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientPasswordChangeOldPassword.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeOldPassword.setDescription('Specifies the old password that was in use for rlSshClientPasswordChangeUsername until now. Upon setting a value in this entry, length of this field value must be 6-70. Password of length 0 will always be returned on GET operations.')
rlSshClientPasswordChangeNewPassword = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1, 5), DisplayString().subtype(subtypeSpec=ValueSizeConstraint(0, 70))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientPasswordChangeNewPassword.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeNewPassword.setDescription('Specifies the new password that should be in use for rlSshClientPasswordChangeUsername from now on. Upon setting a value in this entry, length of this field value must be 6-70. Password of length 0 will always be returned on GET operations.')
rlSshClientPasswordChangeStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1, 6), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("inProgress", 1), ("succeeded", 2), ("failed", 3), ("noData", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientPasswordChangeStatus.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeStatus.setDescription("Specifies the status of last password change operation on remote server identified by rlSshClientPasswordChangeInetAddress. In case this data was erased (3 or more password change operations have been performed since the operation on this server), the status will be 'noData'.")
rlSshClientPasswordChangeFailureReason = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 7, 1, 7), DisplayString()).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientPasswordChangeFailureReason.setStatus('current')
if mibBuilder.loadTexts: rlSshClientPasswordChangeFailureReason.setDescription("In case the value of rlSshClientPasswordChangeStatus is 'failed', this field will contain the failure reason.")
rlSshClientDeleteSelfKey = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 3, 8), RlSshPublicKeyAlgorithm()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientDeleteSelfKey.setStatus('current')
if mibBuilder.loadTexts: rlSshClientDeleteSelfKey.setDescription("Setting to a value other than 'none' results in deleting the client self key of the chosen type.")
rlSshClientImportExportSelfKeyTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 3, 9), )
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyTable.setStatus('current')
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyTable.setDescription('This table can be used for 2 purposes: 1) Importing public/private key pair to serve as the device key when acting as SSH client. This is done by setting entries to this table, according to the specified format. When the last entry (footer) is set, the whole key pair is checked and if valid, stored in CDB. 2) Exporting the device SSH client public/private key. This can be done by performing GetNext operations on this table.')
rlSshClientImportExportSelfKeyEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 3, 9, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshClientImportExportSelfKeyAlgorithm"), (0, "Dell-SSH-MIB", "rlSshClientImportExportSelfKeyFormat"), (0, "Dell-SSH-MIB", "rlSshClientImportExportSelfKeyFragmentId"))
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyEntry.setDescription(' The row definition for this table.')
rlSshClientImportExportSelfKeyAlgorithm = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 9, 1, 1), RlSshPublicKeyAlgorithm())
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyAlgorithm.setStatus('current')
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyAlgorithm.setDescription('Identifies the type of key pair.')
rlSshClientImportExportSelfKeyFormat = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 9, 1, 2), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1))).clone(namedValues=NamedValues(("uuencoded-format", 1))))
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyFormat.setStatus('current')
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyFormat.setDescription('Specifies the format of public/key pair. The following formats are supported for import/export: 1) uuencoded_format - in this format both private and public key are in uu-encoded format, and are seperated from one another by header and footer. An example of the concateneation of all fragments in this format is: -----BEGIN ENCRYPTED RSA PRIVATE KEY----- tDaNkZZoCxXfkLLsLDlZ6T9H8U4Gz637eRV7BYBpapkidAxY1UG0/qgfKLPkbId4wzht6ArV9bE4fMtX wSMOxL3q31pOmUdVhjbWYcgZQBDy1DjFSbuIEdP85c96B9bBE2nPv90mSvb/6j8R2NItT/KJeiYMtLtI N3m6/zESKJGIrX0jP1RFDjVZSS5chSAFgB0egsLZEyOQn7jAqpX/x/easD2J6F/OjPXlJ9Hff2tMb3NU QYyBoWH2J9IxhWB6Vo66R9Y04JGR18uL/rV2sMCtpg5ppkVTEpNTp9qE1yXocR2NmzUfNFap+GJ4IHj8 CzkVfmJM/kEWaJsYgHbAgLyRg4QVyelfobv1B71aQ+u1z9KGu/QajkWdR04OQfsGOL1CvU2LGYDcRjfH jv+jl/UkDRRjoD9kt2WvouT+OL6esvKl0OJBqWbGNXg9TWv/VLtJIwgUno+MLaJuOM4Fh44+wpnqUXwQ TFtBFc8pzt5BoOwbv9gXpicTkq4/+GhwXWXxSVFebKhnHAvKSLT+Ba7K7ZeR8EIIxbXdDNFOiS45R2KI jxxXLXK44u6KGl5MygCKXUOFlJ+Zhgrq6ZH17z/RVJQ2CWqb5Ekn9GY3kH9QZ3mb4MDPfriWi2lHGXHY JmJd4SLQhpBdnOS5tu84QmyU3dNbAdzghDsR+dEY/6g7Cn0kcVkeHNZ0H+mCZik5f6XBD8eplkk43bdR FrkwTeAjwurGcKwdiKkR4DlfSq3DKssVBucTqUpqsKqPXLwTIL44rWKhEPXgGPB2XDG0VLvIRKkAgEGI LNTwOm091Ro= -----END RSA PRIVATE KEY----- -----BEGIN RSA PUBLIC KEY----- MIGHAoGBAOeIC9gRg3YaEGGMp3C00qNwLINAEDZV/J4BWM5WnWwCWZyHXDs2XiEmFu0ZONAD4gcT2f2f NNfCBPye39VVuOkKQuSV0MLLX5800LZ4y1BNcPzPZHpnGaCzl7iAjhfj9MolzAh5VRjeiYt0t1um4dm+ q9A4BtfpJqDYxCW9uxd/AgEj -----END RSA PUBLIC KEY----- ')
rlSshClientImportExportSelfKeyFragmentId = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 9, 1, 3), Integer32())
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyFragmentId.setStatus('current')
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyFragmentId.setDescription('Identifies the index of this fragment in the key pair input/output.')
rlSshClientImportExportSelfKeyFragmentText = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 9, 1, 4), OctetString()).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyFragmentText.setStatus('current')
if mibBuilder.loadTexts: rlSshClientImportExportSelfKeyFragmentText.setDescription('A part of the readable text entry for the key pair input/output.')
rlSshClientRemoteServerPublicKeyFingerprintTable = MibTable((1, 3, 6, 1, 4, 1, 89, 78, 3, 10), )
if mibBuilder.loadTexts: rlSshClientRemoteServerPublicKeyFingerprintTable.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRemoteServerPublicKeyFingerprintTable.setDescription("Table for storing fingerprints of remote servers public keys. It is used for the purpose of server authentication. An entry can be inserted to this table either explicitly by user configuration, or during copy operation, after user's approval.")
rlSshClientRemoteServerPublicKeyFingerprintEntry = MibTableRow((1, 3, 6, 1, 4, 1, 89, 78, 3, 10, 1), ).setIndexNames((0, "Dell-SSH-MIB", "rlSshClientRemoteServerFingerprintInetAddrType"), (0, "Dell-SSH-MIB", "rlSshClientRemoteServerFingerprintInetAddr"), (0, "Dell-SSH-MIB", "rlSshClientRemoteServerFingerprint"))
if mibBuilder.loadTexts: rlSshClientRemoteServerPublicKeyFingerprintEntry.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRemoteServerPublicKeyFingerprintEntry.setDescription(' The row definition for this table.')
rlSshClientRemoteServerFingerprintInetAddrType = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 10, 1, 1), InetAddressType())
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprintInetAddrType.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprintInetAddrType.setDescription('Remote server inet address type.')
rlSshClientRemoteServerFingerprintInetAddr = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 10, 1, 2), InetAddress())
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprintInetAddr.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprintInetAddr.setDescription('Remote server inet address.')
rlSshClientRemoteServerFingerprint = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 10, 1, 3), OctetString().subtype(subtypeSpec=ValueSizeConstraint(16, 16)).setFixedLength(16)).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprint.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprint.setDescription('Remote server fingerprint.')
rlSshClientRemoteServerFingerprintStatus = MibTableColumn((1, 3, 6, 1, 4, 1, 89, 78, 3, 10, 1, 4), RowStatus()).setMaxAccess("readcreate")
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprintStatus.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRemoteServerFingerprintStatus.setDescription('Row status for this row.')
rlSshClientRemoteServersAuthenticationEnable = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 3, 11), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2))).clone(namedValues=NamedValues(("enable", 1), ("disable", 2)))).setMaxAccess("readwrite")
if mibBuilder.loadTexts: rlSshClientRemoteServersAuthenticationEnable.setStatus('current')
if mibBuilder.loadTexts: rlSshClientRemoteServersAuthenticationEnable.setDescription("Setting this field to 'enable' enables remote servers authentication. As a result, while opening a session with a remote server, the fingerprint of the remote server will be computed and looked for in the table rlSshClientRemoteServerPublicKeyFingerprintTable. If an entry with the key (server-inet-address, server-fingerprint) is found, the server is considered authenticated. Otherwise, the server is not authenticated (unless the user specifically approved this server can be trusted).")
rlSshClientDefaultKeyFlag = MibScalar((1, 3, 6, 1, 4, 1, 89, 78, 3, 12), Integer32().subtype(subtypeSpec=ConstraintsUnion(SingleValueConstraint(1, 2, 3, 4))).clone(namedValues=NamedValues(("rsa", 1), ("dsa", 2), ("all", 3), ("none", 4)))).setMaxAccess("readonly")
if mibBuilder.loadTexts: rlSshClientDefaultKeyFlag.setStatus('current')
if mibBuilder.loadTexts: rlSshClientDefaultKeyFlag.setDescription('This scalar indicates which of the SSH client keys are default keys (automatically generated).')
mibBuilder.exportSymbols("Dell-SSH-MIB", rlSshClientSelfPublicKeyFingerprintTable=rlSshClientSelfPublicKeyFingerprintTable, rlSshServerDefaultKeyFlag=rlSshServerDefaultKeyFlag, rlSshServerSessionInetTable=rlSshServerSessionInetTable, rlSshClientSelfPublicKeyFragmentId=rlSshClientSelfPublicKeyFragmentId, rlSshClientRemoteServerFingerprintStatus=rlSshClientRemoteServerFingerprintStatus, rlSshServerImportExportSelfKeyFragmentText=rlSshServerImportExportSelfKeyFragmentText, rlSshClientImportExportSelfKeyFragmentText=rlSshClientImportExportSelfKeyFragmentText, rlSshClientPasswordChangeEntry=rlSshClientPasswordChangeEntry, rlSshClientSelfPublicKeyFingerprintDigestFormat=rlSshClientSelfPublicKeyFingerprintDigestFormat, rlSshClientRemoteServerFingerprintInetAddr=rlSshClientRemoteServerFingerprintInetAddr, rlSshClientAuthenticationMethod=rlSshClientAuthenticationMethod, PYSNMP_MODULE_ID=rlSsh, rlSshClientPasswordChangeNewPassword=rlSshClientPasswordChangeNewPassword, rlSshServerSessionUsername=rlSshServerSessionUsername, RlSshPublicKeyAlgorithm=RlSshPublicKeyAlgorithm, rlSshServerSessionInetHMAC=rlSshServerSessionInetHMAC, rlSshServerHostPublicKeyFragmentId=rlSshServerHostPublicKeyFragmentId, rlSshServerAuthorizedUserFingerprintName=rlSshServerAuthorizedUserFingerprintName, rlSshServerAuthorizedUserPublicKeyFingerprint=rlSshServerAuthorizedUserPublicKeyFingerprint, rlSshServerEnablePublicKeyAuthAutoLogin=rlSshServerEnablePublicKeyAuthAutoLogin, rlSshClientPasswordChangeInetAddrType=rlSshClientPasswordChangeInetAddrType, rlSshServerSessionTableEntry=rlSshServerSessionTableEntry, RlSshPublicKeyDigestFormat=RlSshPublicKeyDigestFormat, rlSshClientPasswordChangeUsername=rlSshClientPasswordChangeUsername, rlSshClientSelfPublicKeyFragmentText=rlSshClientSelfPublicKeyFragmentText, rlSshServerAuthorizedUserPublicKeyFingerprintDigestFormat=rlSshServerAuthorizedUserPublicKeyFingerprintDigestFormat, rlSshClientDefaultKeyFlag=rlSshClientDefaultKeyFlag, rlSshServerImportExportSelfKeyFragmentId=rlSshServerImportExportSelfKeyFragmentId, rlSshServerSessionInetPeerVersion=rlSshServerSessionInetPeerVersion, rlSshServerImportExportSelfKeyTable=rlSshServerImportExportSelfKeyTable, rlSshServerSessionInetTableEntry=rlSshServerSessionInetTableEntry, rlSshServerSessionInetPeerPort=rlSshServerSessionInetPeerPort, rlSshClientSelfPublicKeyAlgorithm=rlSshClientSelfPublicKeyAlgorithm, rlSshServerAuthorizedUserPublicKeyFragmentId=rlSshServerAuthorizedUserPublicKeyFragmentId, rlSshServerDeleteSelfKey=rlSshServerDeleteSelfKey, rlSshServerHostPublicKeyTableEntry=rlSshServerHostPublicKeyTableEntry, rlSshServerSessionPeerVersion=rlSshServerSessionPeerVersion, rlSshServerSessionPeerAddress=rlSshServerSessionPeerAddress, rlSshServerSessionTable=rlSshServerSessionTable, rlSshClientRegenerateSelfKey=rlSshClientRegenerateSelfKey, rlSshClientPasswordChangeInetAddr=rlSshClientPasswordChangeInetAddr, rlSshServerImportExportSelfKeyEntry=rlSshServerImportExportSelfKeyEntry, rlSshServerEnable=rlSshServerEnable, rlSshServerHostPublicKeyFingerprintTable=rlSshServerHostPublicKeyFingerprintTable, rlSshServerSessionInetIdentifier=rlSshServerSessionInetIdentifier, rlSshClientRemoteServerPublicKeyFingerprintTable=rlSshClientRemoteServerPublicKeyFingerprintTable, rlSshServerHostPublicKeyTable=rlSshServerHostPublicKeyTable, rlSshServerEnablePasswordAuthentication=rlSshServerEnablePasswordAuthentication, rlSshServerSessionInetPeerAddressType=rlSshServerSessionInetPeerAddressType, rlSshClientSelfPublicKeyFingerprintTableEntry=rlSshClientSelfPublicKeyFingerprintTableEntry, rlSshServerPort=rlSshServerPort, rlSshServerAuthorizedUsersPublicKeyTable=rlSshServerAuthorizedUsersPublicKeyTable, rlSshClientPassword=rlSshClientPassword, rlSshServerSessionIdentifier=rlSshServerSessionIdentifier, rlSshServerAuthorizedUserName=rlSshServerAuthorizedUserName, rlSshClientPasswordChangeFailureReason=rlSshClientPasswordChangeFailureReason, rlSshClientRemoteServersAuthenticationEnable=rlSshClientRemoteServersAuthenticationEnable, rlSshServerHostPublicKeyFingerprintDigestFormat=rlSshServerHostPublicKeyFingerprintDigestFormat, rlSshServerAuthorizedUserPublicKeyFragmentText=rlSshServerAuthorizedUserPublicKeyFragmentText, rlSshClientImportExportSelfKeyTable=rlSshClientImportExportSelfKeyTable, rlSshServerHostPublicKeyFingerprint=rlSshServerHostPublicKeyFingerprint, rlSshServerHostPublicKeyFingerprintTableEntry=rlSshServerHostPublicKeyFingerprintTableEntry, rlSshClientSelfPublicKeyTableEntry=rlSshClientSelfPublicKeyTableEntry, rlSshServerSessionPeerPort=rlSshServerSessionPeerPort, rlSshClientImportExportSelfKeyEntry=rlSshClientImportExportSelfKeyEntry, rlSshClientImportExportSelfKeyFragmentId=rlSshClientImportExportSelfKeyFragmentId, rlSshServer=rlSshServer, rlSshClientDeleteSelfKey=rlSshClientDeleteSelfKey, rlSshServerAuthorizedUserPublicKeyFingerprintAlgorithm=rlSshServerAuthorizedUserPublicKeyFingerprintAlgorithm, rlSshClientSelfPublicKeyTable=rlSshClientSelfPublicKeyTable, rlSshServerSessionInetPeerAddress=rlSshServerSessionInetPeerAddress, rlSshServerImportExportSelfKeyAlgorithm=rlSshServerImportExportSelfKeyAlgorithm, rlSshServerSessionHMAC=rlSshServerSessionHMAC, rlSshServerAuthorizedUsersPublicKeyFingerprintTableEntry=rlSshServerAuthorizedUsersPublicKeyFingerprintTableEntry, rlSshClientPasswordChangeOldPassword=rlSshClientPasswordChangeOldPassword, rlSshClient=rlSshClient, rlSshServerAuthorizedUserPublicKeyFragmentStatus=rlSshServerAuthorizedUserPublicKeyFragmentStatus, rlSshServerRegenerateHostKey=rlSshServerRegenerateHostKey, rlSshClientImportExportSelfKeyAlgorithm=rlSshClientImportExportSelfKeyAlgorithm, rlSshClientSelfPublicKeyFingerprintAlgorithm=rlSshClientSelfPublicKeyFingerprintAlgorithm, rlSshServerHostPublicKeyAlgorithm=rlSshServerHostPublicKeyAlgorithm, rlSshServerSessionInetUsername=rlSshServerSessionInetUsername, rlSshServerEnablePublicKeyAuthentication=rlSshServerEnablePublicKeyAuthentication, rlSshClientSelfPublicKeyFingerprint=rlSshClientSelfPublicKeyFingerprint, rlSshServerAuthorizedUsersPublicKeyFingerprintTable=rlSshServerAuthorizedUsersPublicKeyFingerprintTable, rlSshClientRemoteServerFingerprint=rlSshClientRemoteServerFingerprint, rlSshClientRemoteServerPublicKeyFingerprintEntry=rlSshClientRemoteServerPublicKeyFingerprintEntry, rlSshServerSessionInetCipher=rlSshServerSessionInetCipher, rlSshMibVersion=rlSshMibVersion, rlSshClientPasswordChangeStatus=rlSshClientPasswordChangeStatus, rlSshClientRemoteServerFingerprintInetAddrType=rlSshClientRemoteServerFingerprintInetAddrType, rlSshClientPasswordChangeTable=rlSshClientPasswordChangeTable, rlSshServerHostPublicKeyFragmentText=rlSshServerHostPublicKeyFragmentText, rlSshClientImportExportSelfKeyFormat=rlSshClientImportExportSelfKeyFormat, rlSshServerAuthorizedUsersPublicKeyTableEntry=rlSshServerAuthorizedUsersPublicKeyTableEntry, rlSsh=rlSsh, rlSshServerImportExportSelfKeyFormat=rlSshServerImportExportSelfKeyFormat, rlSshClientUserName=rlSshClientUserName, rlSshServerSessionCipher=rlSshServerSessionCipher, rlSshServerHostPublicKeyFingerprintAlgorithm=rlSshServerHostPublicKeyFingerprintAlgorithm)
